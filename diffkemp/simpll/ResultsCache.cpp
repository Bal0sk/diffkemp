//===-------------- ResultsCache.cpp - Parsing result cache ---------------===//
//
//       SimpLL - Program simplifier for analysis of semantic difference      //
//
// This file is published under Apache 2.0 license. See LICENSE for details.
// Author: Tomas Glozar, tglozar@gmail.com
//===----------------------------------------------------------------------===//
///
/// \file
/// This file implements a class that is used for retreiving information about
/// already compared functions from cache files generated by DiffKemp.
///
//===----------------------------------------------------------------------===//

#include "ResultsCache.h"
#include "Utils.h"
#include <llvm/Support/MemoryBuffer.h>
#include <llvm/Support/raw_ostream.h>

using namespace llvm;

/// Parses a cache file and loads it into the cache map.
void ResultsCache::importFileToCacheMap(std::string filename) {
    ErrorOr<std::unique_ptr<MemoryBuffer>> ignoreFunOpen =
            MemoryBuffer::getFileOrSTDIN(filename);
    if (ignoreFunOpen) {
        std::unique_ptr<MemoryBuffer> ignoreFunFile =
                std::move(ignoreFunOpen.get());
        StringRef ignoreFunString = ignoreFunFile->getBuffer();
        auto lines = std::make_unique<SmallVector<StringRef, 1000>>();
        ignoreFunString.split(*lines, '\n');
        for (StringRef line : *lines) {
            auto refPair = line.split(':');
            cacheMap[filename].insert(
                    {std::get<0>(refPair).str(), std::get<1>(refPair).str()});
        }
    }
}

/// Find the information whether the function pair is cached in the
/// corresponding file.
bool ResultsCache::isFunctionPairCached(const Function *FunL,
                                        const Function *FunR) {
    auto SubprogramL = FunL->getSubprogram();
    auto SubprogramR = FunR->getSubprogram();
    if (!SubprogramL || !SubprogramR)
        // Missing debug info.
        return false;
    std::string FilenameL =
            joinPath(SubprogramL->getDirectory(), SubprogramL->getFilename());
    std::string FilenameR =
            joinPath(SubprogramR->getDirectory(), SubprogramR->getFilename());
    // Convert the C source file paths using the cache directory to the
    // path of the cache file and load it if it exists.
    findAndReplace(FilenameL, "/", "$");
    findAndReplace(FilenameR, "/", "$");
    std::string cacheFilename =
            cacheDirectory + "/" + FilenameL + ":" + FilenameR;
    if (cacheMap.find(cacheFilename) == cacheMap.end()) {
        // Cache file wasn't loaded and parsed yet.
        importFileToCacheMap(cacheFilename);
    }
    if (cacheMap.find(cacheFilename) != cacheMap.end()) {
        return cacheMap[cacheFilename].find(
                       {FunL->getName().str(), FunR->getName().str()})
               != cacheMap[cacheFilename].end();
    } else
        // Cache file not found in map even after load attempt.
        return false;
}
