; ModuleID = 'tests/regression/kernel_modules/usbcore/usbcore_new-usbfs_snoop.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

module asm "\09.section \22___kcrctab_gpl+usb_disabled\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_disabled\09"
module asm "\09.long\09__crc_usb_disabled\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_find_alt_setting\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_find_alt_setting\09"
module asm "\09.long\09__crc_usb_find_alt_setting\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_ifnum_to_if\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_ifnum_to_if\09"
module asm "\09.long\09__crc_usb_ifnum_to_if\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_altnum_to_altsetting\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_altnum_to_altsetting\09"
module asm "\09.long\09__crc_usb_altnum_to_altsetting\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_find_interface\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_find_interface\09"
module asm "\09.long\09__crc_usb_find_interface\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_for_each_dev\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_for_each_dev\09"
module asm "\09.long\09__crc_usb_for_each_dev\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_alloc_dev\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_alloc_dev\09"
module asm "\09.long\09__crc_usb_alloc_dev\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_get_dev\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_get_dev\09"
module asm "\09.long\09__crc_usb_get_dev\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_put_dev\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_put_dev\09"
module asm "\09.long\09__crc_usb_put_dev\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_get_intf\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_get_intf\09"
module asm "\09.long\09__crc_usb_get_intf\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_put_intf\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_put_intf\09"
module asm "\09.long\09__crc_usb_put_intf\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_lock_device_for_reset\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_lock_device_for_reset\09"
module asm "\09.long\09__crc_usb_lock_device_for_reset\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_get_current_frame_number\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_get_current_frame_number\09"
module asm "\09.long\09__crc_usb_get_current_frame_number\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+__usb_get_extra_descriptor\22, \22a\22\09"
module asm "\09.weak\09__crc___usb_get_extra_descriptor\09"
module asm "\09.long\09__crc___usb_get_extra_descriptor\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_alloc_coherent\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_alloc_coherent\09"
module asm "\09.long\09__crc_usb_alloc_coherent\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_free_coherent\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_free_coherent\09"
module asm "\09.long\09__crc_usb_free_coherent\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_debug_root\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_debug_root\09"
module asm "\09.long\09__crc_usb_debug_root\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+ehci_cf_port_reset_rwsem\22, \22a\22\09"
module asm "\09.weak\09__crc_ehci_cf_port_reset_rwsem\09"
module asm "\09.long\09__crc_ehci_cf_port_reset_rwsem\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_wakeup_notification\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_wakeup_notification\09"
module asm "\09.long\09__crc_usb_wakeup_notification\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hub_clear_tt_buffer\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hub_clear_tt_buffer\09"
module asm "\09.long\09__crc_usb_hub_clear_tt_buffer\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hub_claim_port\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hub_claim_port\09"
module asm "\09.long\09__crc_usb_hub_claim_port\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hub_release_port\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hub_release_port\09"
module asm "\09.long\09__crc_usb_hub_release_port\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_set_device_state\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_set_device_state\09"
module asm "\09.long\09__crc_usb_set_device_state\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_disable_ltm\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_disable_ltm\09"
module asm "\09.long\09__crc_usb_disable_ltm\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_enable_ltm\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_enable_ltm\09"
module asm "\09.long\09__crc_usb_enable_ltm\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_root_hub_lost_power\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_root_hub_lost_power\09"
module asm "\09.long\09__crc_usb_root_hub_lost_power\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_disable_lpm\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_disable_lpm\09"
module asm "\09.long\09__crc_usb_disable_lpm\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_unlocked_disable_lpm\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_unlocked_disable_lpm\09"
module asm "\09.long\09__crc_usb_unlocked_disable_lpm\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_enable_lpm\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_enable_lpm\09"
module asm "\09.long\09__crc_usb_enable_lpm\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_unlocked_enable_lpm\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_unlocked_enable_lpm\09"
module asm "\09.long\09__crc_usb_unlocked_enable_lpm\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_ep0_reinit\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_ep0_reinit\09"
module asm "\09.long\09__crc_usb_ep0_reinit\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_reset_device\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_reset_device\09"
module asm "\09.long\09__crc_usb_reset_device\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_queue_reset_device\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_queue_reset_device\09"
module asm "\09.long\09__crc_usb_queue_reset_device\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hub_find_child\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hub_find_child\09"
module asm "\09.long\09__crc_usb_hub_find_child\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcds_loaded\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcds_loaded\09"
module asm "\09.long\09__crc_usb_hcds_loaded\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_bus_idr\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_bus_idr\09"
module asm "\09.long\09__crc_usb_bus_idr\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_bus_idr_lock\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_bus_idr_lock\09"
module asm "\09.long\09__crc_usb_bus_idr_lock\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_poll_rh_status\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_poll_rh_status\09"
module asm "\09.long\09__crc_usb_hcd_poll_rh_status\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_start_port_resume\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_start_port_resume\09"
module asm "\09.long\09__crc_usb_hcd_start_port_resume\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_end_port_resume\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_end_port_resume\09"
module asm "\09.long\09__crc_usb_hcd_end_port_resume\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_calc_bus_time\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_calc_bus_time\09"
module asm "\09.long\09__crc_usb_calc_bus_time\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_link_urb_to_ep\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_link_urb_to_ep\09"
module asm "\09.long\09__crc_usb_hcd_link_urb_to_ep\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_check_unlink_urb\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_check_unlink_urb\09"
module asm "\09.long\09__crc_usb_hcd_check_unlink_urb\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_unlink_urb_from_ep\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_unlink_urb_from_ep\09"
module asm "\09.long\09__crc_usb_hcd_unlink_urb_from_ep\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_unmap_urb_setup_for_dma\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_unmap_urb_setup_for_dma\09"
module asm "\09.long\09__crc_usb_hcd_unmap_urb_setup_for_dma\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_unmap_urb_for_dma\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_unmap_urb_for_dma\09"
module asm "\09.long\09__crc_usb_hcd_unmap_urb_for_dma\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_map_urb_for_dma\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_map_urb_for_dma\09"
module asm "\09.long\09__crc_usb_hcd_map_urb_for_dma\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_giveback_urb\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_giveback_urb\09"
module asm "\09.long\09__crc_usb_hcd_giveback_urb\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_alloc_streams\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_alloc_streams\09"
module asm "\09.long\09__crc_usb_alloc_streams\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_free_streams\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_free_streams\09"
module asm "\09.long\09__crc_usb_free_streams\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_resume_root_hub\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_resume_root_hub\09"
module asm "\09.long\09__crc_usb_hcd_resume_root_hub\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_bus_start_enum\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_bus_start_enum\09"
module asm "\09.long\09__crc_usb_bus_start_enum\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_irq\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_irq\09"
module asm "\09.long\09__crc_usb_hcd_irq\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hc_died\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hc_died\09"
module asm "\09.long\09__crc_usb_hc_died\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_create_shared_hcd\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_create_shared_hcd\09"
module asm "\09.long\09__crc_usb_create_shared_hcd\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_create_hcd\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_create_hcd\09"
module asm "\09.long\09__crc_usb_create_hcd\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_get_hcd\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_get_hcd\09"
module asm "\09.long\09__crc_usb_get_hcd\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_put_hcd\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_put_hcd\09"
module asm "\09.long\09__crc_usb_put_hcd\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_is_primary_hcd\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_is_primary_hcd\09"
module asm "\09.long\09__crc_usb_hcd_is_primary_hcd\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_add_hcd\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_add_hcd\09"
module asm "\09.long\09__crc_usb_add_hcd\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_remove_hcd\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_remove_hcd\09"
module asm "\09.long\09__crc_usb_remove_hcd\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_platform_shutdown\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_platform_shutdown\09"
module asm "\09.long\09__crc_usb_hcd_platform_shutdown\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_mon_register\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_mon_register\09"
module asm "\09.long\09__crc_usb_mon_register\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_mon_deregister\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_mon_deregister\09"
module asm "\09.long\09__crc_usb_mon_deregister\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_init_urb\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_init_urb\09"
module asm "\09.long\09__crc_usb_init_urb\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_alloc_urb\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_alloc_urb\09"
module asm "\09.long\09__crc_usb_alloc_urb\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_free_urb\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_free_urb\09"
module asm "\09.long\09__crc_usb_free_urb\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_get_urb\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_get_urb\09"
module asm "\09.long\09__crc_usb_get_urb\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_anchor_urb\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_anchor_urb\09"
module asm "\09.long\09__crc_usb_anchor_urb\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_unanchor_urb\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_unanchor_urb\09"
module asm "\09.long\09__crc_usb_unanchor_urb\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_submit_urb\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_submit_urb\09"
module asm "\09.long\09__crc_usb_submit_urb\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_unlink_urb\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_unlink_urb\09"
module asm "\09.long\09__crc_usb_unlink_urb\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_kill_urb\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_kill_urb\09"
module asm "\09.long\09__crc_usb_kill_urb\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_poison_urb\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_poison_urb\09"
module asm "\09.long\09__crc_usb_poison_urb\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_unpoison_urb\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_unpoison_urb\09"
module asm "\09.long\09__crc_usb_unpoison_urb\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_block_urb\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_block_urb\09"
module asm "\09.long\09__crc_usb_block_urb\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_kill_anchored_urbs\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_kill_anchored_urbs\09"
module asm "\09.long\09__crc_usb_kill_anchored_urbs\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_poison_anchored_urbs\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_poison_anchored_urbs\09"
module asm "\09.long\09__crc_usb_poison_anchored_urbs\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_unpoison_anchored_urbs\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_unpoison_anchored_urbs\09"
module asm "\09.long\09__crc_usb_unpoison_anchored_urbs\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_unlink_anchored_urbs\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_unlink_anchored_urbs\09"
module asm "\09.long\09__crc_usb_unlink_anchored_urbs\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_anchor_suspend_wakeups\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_anchor_suspend_wakeups\09"
module asm "\09.long\09__crc_usb_anchor_suspend_wakeups\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_anchor_resume_wakeups\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_anchor_resume_wakeups\09"
module asm "\09.long\09__crc_usb_anchor_resume_wakeups\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_wait_anchor_empty_timeout\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_wait_anchor_empty_timeout\09"
module asm "\09.long\09__crc_usb_wait_anchor_empty_timeout\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_get_from_anchor\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_get_from_anchor\09"
module asm "\09.long\09__crc_usb_get_from_anchor\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_scuttle_anchored_urbs\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_scuttle_anchored_urbs\09"
module asm "\09.long\09__crc_usb_scuttle_anchored_urbs\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_anchor_empty\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_anchor_empty\09"
module asm "\09.long\09__crc_usb_anchor_empty\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_control_msg\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_control_msg\09"
module asm "\09.long\09__crc_usb_control_msg\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_interrupt_msg\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_interrupt_msg\09"
module asm "\09.long\09__crc_usb_interrupt_msg\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_bulk_msg\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_bulk_msg\09"
module asm "\09.long\09__crc_usb_bulk_msg\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_sg_init\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_sg_init\09"
module asm "\09.long\09__crc_usb_sg_init\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_sg_wait\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_sg_wait\09"
module asm "\09.long\09__crc_usb_sg_wait\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_sg_cancel\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_sg_cancel\09"
module asm "\09.long\09__crc_usb_sg_cancel\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_get_descriptor\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_get_descriptor\09"
module asm "\09.long\09__crc_usb_get_descriptor\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_string\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_string\09"
module asm "\09.long\09__crc_usb_string\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_get_status\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_get_status\09"
module asm "\09.long\09__crc_usb_get_status\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_clear_halt\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_clear_halt\09"
module asm "\09.long\09__crc_usb_clear_halt\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_reset_endpoint\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_reset_endpoint\09"
module asm "\09.long\09__crc_usb_reset_endpoint\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_set_interface\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_set_interface\09"
module asm "\09.long\09__crc_usb_set_interface\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_reset_configuration\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_reset_configuration\09"
module asm "\09.long\09__crc_usb_reset_configuration\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_set_configuration\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_set_configuration\09"
module asm "\09.long\09__crc_usb_set_configuration\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_driver_set_configuration\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_driver_set_configuration\09"
module asm "\09.long\09__crc_usb_driver_set_configuration\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+cdc_parse_cdc_header\22, \22a\22\09"
module asm "\09.weak\09__crc_cdc_parse_cdc_header\09"
module asm "\09.long\09__crc_cdc_parse_cdc_header\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_store_new_id\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_store_new_id\09"
module asm "\09.long\09__crc_usb_store_new_id\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_show_dynids\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_show_dynids\09"
module asm "\09.long\09__crc_usb_show_dynids\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_driver_claim_interface\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_driver_claim_interface\09"
module asm "\09.long\09__crc_usb_driver_claim_interface\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_driver_release_interface\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_driver_release_interface\09"
module asm "\09.long\09__crc_usb_driver_release_interface\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_match_one_id\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_match_one_id\09"
module asm "\09.long\09__crc_usb_match_one_id\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_match_id\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_match_id\09"
module asm "\09.long\09__crc_usb_match_id\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_register_device_driver\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_register_device_driver\09"
module asm "\09.long\09__crc_usb_register_device_driver\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_deregister_device_driver\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_deregister_device_driver\09"
module asm "\09.long\09__crc_usb_deregister_device_driver\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_register_driver\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_register_driver\09"
module asm "\09.long\09__crc_usb_register_driver\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_deregister\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_deregister\09"
module asm "\09.long\09__crc_usb_deregister\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_enable_autosuspend\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_enable_autosuspend\09"
module asm "\09.long\09__crc_usb_enable_autosuspend\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_disable_autosuspend\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_disable_autosuspend\09"
module asm "\09.long\09__crc_usb_disable_autosuspend\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_autopm_put_interface\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_autopm_put_interface\09"
module asm "\09.long\09__crc_usb_autopm_put_interface\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_autopm_put_interface_async\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_autopm_put_interface_async\09"
module asm "\09.long\09__crc_usb_autopm_put_interface_async\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_autopm_put_interface_no_suspend\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_autopm_put_interface_no_suspend\09"
module asm "\09.long\09__crc_usb_autopm_put_interface_no_suspend\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_autopm_get_interface\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_autopm_get_interface\09"
module asm "\09.long\09__crc_usb_autopm_get_interface\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_autopm_get_interface_async\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_autopm_get_interface_async\09"
module asm "\09.long\09__crc_usb_autopm_get_interface_async\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_autopm_get_interface_no_resume\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_autopm_get_interface_no_resume\09"
module asm "\09.long\09__crc_usb_autopm_get_interface_no_resume\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_register_dev\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_register_dev\09"
module asm "\09.long\09__crc_usb_register_dev\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_deregister_dev\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_deregister_dev\09"
module asm "\09.long\09__crc_usb_deregister_dev\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_register_notify\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_register_notify\09"
module asm "\09.long\09__crc_usb_register_notify\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_unregister_notify\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_unregister_notify\09"
module asm "\09.long\09__crc_usb_unregister_notify\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_choose_configuration\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_choose_configuration\09"
module asm "\09.long\09__crc_usb_choose_configuration\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_of_get_child_node\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_of_get_child_node\09"
module asm "\09.long\09__crc_usb_of_get_child_node\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_pci_probe\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_pci_probe\09"
module asm "\09.long\09__crc_usb_hcd_pci_probe\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_pci_remove\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_pci_remove\09"
module asm "\09.long\09__crc_usb_hcd_pci_remove\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_pci_shutdown\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_pci_shutdown\09"
module asm "\09.long\09__crc_usb_hcd_pci_shutdown\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_hcd_pci_pm_ops\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_hcd_pci_pm_ops\09"
module asm "\09.long\09__crc_usb_hcd_pci_pm_ops\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_acpi_power_manageable\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_acpi_power_manageable\09"
module asm "\09.long\09__crc_usb_acpi_power_manageable\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+usb_acpi_set_power_state\22, \22a\22\09"
module asm "\09.weak\09__crc_usb_acpi_set_power_state\09"
module asm "\09.long\09__crc_usb_acpi_set_power_state\09"
module asm "\09.previous\09\09\09\09\09"

%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.atomic_t*, %struct.atomic_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, %struct.delayed_work, i8 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.1 }
%union.anon.1 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qspinlock = type { %struct.atomic_t }
%struct.atomic_t = type { i32 }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.hlist_node, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.lockdep_map, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)*, %struct.lock_class_key }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %union.anon.3, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.0, %struct.list_head, %struct.list_head, %union.anon.50 }
%struct.seqcount = type { i32, %struct.lockdep_map }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%struct.lockref = type { %union.anon.47 }
%union.anon.47 = type { %struct.anon.48 }
%struct.anon.48 = type { %struct.spinlock, i32 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %union.anon.3, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, [32 x i8], %struct.list_lru, [40 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, %struct.kernel_symbol*, i32*, i32, i32, %struct.kernel_symbol*, i32*, i8, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [56 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, i32, i64*, i8, i8, %struct.klp_modinfo*, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, void ()**, i32, [36 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.module_param_attrs = type opaque
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.51 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.51 = type { i8* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32, i32 }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.qspinlock, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.klp_modinfo = type { %struct.elf64_hdr, %struct.elf64_shdr*, i8*, i32 }
%struct.elf64_hdr = type { [16 x i8], i16, i16, i32, i64, i64, i64, i32, i16, i16, i16, i16, i16, i16 }
%struct.elf64_shdr = type { i32, i32, i64, i64, i64, i64, i32, i32, i64, i64 }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %struct.qspinlock, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.6, %union.anon.3, %union.anon.3, %union.anon.0, %union.anon.3, %struct.mem_cgroup* }
%union.anon.6 = type { %struct.address_space* }
%struct.mem_cgroup = type opaque
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.atomic_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %union.anon.3, %struct.list_head, %struct.raw_spinlock, %struct.qspinlock, %struct.task_struct*, %struct.lockdep_map }
%struct.task_struct = type { %union.anon.3, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, %struct.hlist_head, i32, i32, i32, %struct.cpumask, i64, i8, %struct.list_head, i32, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %union.anon.0, i64, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.atomic_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, i32, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.callback_head, %struct.list_head, %struct.numa_group*, i64*, i64, [3 x i64], i64, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, i32, i32, i8*, %struct.kcov*, %struct.mem_cgroup*, i32, i32, i32, %struct.uprobe_task*, i32, i32, i64, i32, %struct.task_struct*, %struct.atomic_t, %struct.thread_struct }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [8 x i8], [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [128 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %union.anon.3*, %struct.atomic_t, %struct.atomic_t, %union.anon.3, %union.anon.3, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.task_struct*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, %struct.cpumask, i64, i64, i32, i8, %struct.uprobes_state, %union.anon.3, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %union.anon.3, i64, %struct.timerqueue_node, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.anon_vma = type opaque
%struct.vm_userfaultfd_ctx = type { %struct.userfaultfd_ctx* }
%struct.userfaultfd_ctx = type opaque
%struct.mm_rss_stat = type { [4 x %union.anon.3] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16, i8* }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type opaque
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.8 }
%union.anon.8 = type { %struct.anon.9 }
%struct.anon.9 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net*, %struct.cgroup_namespace* }
%struct.uts_namespace = type { %struct.kref, %struct.new_utsname, %struct.user_namespace*, %struct.ucounts*, %struct.ns_common }
%struct.new_utsname = type { [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8] }
%struct.ucounts = type { %struct.hlist_node, %struct.user_namespace*, %struct.atomic_t, i32, [9 x %struct.atomic_t] }
%struct.ns_common = type { %union.anon.3, %struct.proc_ns_operations*, i32 }
%struct.proc_ns_operations = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.net = type opaque
%struct.cgroup_namespace = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.list_head, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, i64, [2 x %struct.timespec], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, %struct.seqlock_t, i64, i64, i64, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.timespec], %struct.pacct_struct, %struct.taskstats*, i32, %struct.tty_audit_buf*, i8, i16, i16, %struct.mm_struct*, %struct.mutex }
%struct.timespec = type { i64, i64 }
%struct.thread_group_cputimer = type { %struct.task_cputime_atomic, i8, i8 }
%struct.task_cputime_atomic = type { %union.anon.3, %union.anon.3, %union.anon.3 }
%struct.tty_struct = type opaque
%struct.autogroup = type opaque
%struct.seqlock_t = type { %struct.seqcount, %struct.spinlock }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, %struct.ww_acquire_ctx*, i8* }
%struct.ww_acquire_ctx = type opaque
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.12 }
%union.anon.12 = type { %struct.anon.16, [80 x i8] }
%struct.anon.16 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %struct.atomic_t, i32, i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.numa_group = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.kcov = type opaque
%struct.uprobe_task = type { i32, %union.anon.22, %struct.uprobe*, i64, %struct.return_instance*, i32 }
%union.anon.22 = type { %struct.anon.23 }
%struct.anon.23 = type { %struct.arch_uprobe_task, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.uprobe = type opaque
%struct.return_instance = type { %struct.uprobe*, i64, i64, i64, i8, %struct.return_instance* }
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %union.anon.3, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.25 }
%union.anon.25 = type { %struct.anon.26 }
%struct.anon.26 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.28, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.31 }
%union.anon.28 = type { %struct.timespec }
%union.anon.31 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %union.anon.3* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type { %struct.uid_gid_map, %struct.uid_gid_map, %struct.uid_gid_map, %struct.atomic_t, %struct.user_namespace*, i32, %struct.atomic_t, %struct.atomic_t, %struct.ns_common, i64, %struct.key*, %struct.rw_semaphore, %struct.work_struct, %struct.ctl_table_set, %struct.ctl_table_header*, %struct.ucounts*, [9 x i32] }
%struct.uid_gid_map = type { i32, [5 x %struct.exception_table_entry] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.52, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.3, i64, %struct.atomic_t, %struct.atomic_t, i32, i16, i16, i64, %union.anon.54, %union.anon.56, i32 (%struct.key*, %struct.key_type*, %union.key_payload*)* }
%union.anon.52 = type { %struct.rb_node }
%struct.key_user = type opaque
%union.anon.54 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { %struct.key_type*, i8*, i64 }
%struct.key_type = type opaque
%union.anon.56 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.ctl_table_set = type { i32 (%struct.ctl_table_set*)*, %struct.ctl_dir }
%struct.ctl_dir = type { %struct.ctl_table_header, %struct.rb_root }
%struct.ctl_table_header = type { %union.anon.55, %struct.completion*, %struct.ctl_table*, %struct.ctl_table_root*, %struct.ctl_table_set*, %struct.ctl_dir*, %struct.ctl_node*, %struct.list_head }
%union.anon.55 = type { %struct.anon.56 }
%struct.anon.56 = type { %struct.ctl_table*, i32, i32, i32 }
%struct.ctl_table = type { i8*, i8*, i32, i16, %struct.ctl_table*, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)*, %struct.ctl_table_poll*, i8*, i8* }
%struct.ctl_table_poll = type { %struct.atomic_t, %struct.__wait_queue_head }
%struct.ctl_table_root = type { %struct.ctl_table_set, %struct.ctl_table_set* (%struct.ctl_table_root*)*, void (%struct.ctl_table_header*, %struct.ctl_table*, %struct.atomic_t*, %struct.atomic_t*)*, i32 (%struct.ctl_table_header*, %struct.ctl_table*)* }
%struct.ctl_node = type { %struct.rb_node, %struct.ctl_table_header* }
%struct.list_lru = type { %struct.list_lru_node*, %struct.list_head }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, %struct.list_lru_memcg*, [24 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.list_lru_memcg = type { [0 x %struct.list_lru_one*] }
%struct.work_struct = type { %union.anon.3, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%union.anon.0 = type { %struct.list_head }
%union.anon.50 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.atomic_t, %struct.atomic_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %struct.atomic_t, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.bdi_writeback*, i32, i16, i16, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.2, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.46, i32, i32, %struct.hlist_head, %struct.fscrypt_info*, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.atomic_t, %struct.atomic_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.atomic_t, %struct.atomic_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%struct.bdi_writeback = type opaque
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.0, [64 x i8*], [3 x [1 x i64]] }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type { i32, i64, i64, %union.anon.32, %union.anon.3 }
%union.anon.32 = type { %struct.iovec* }
%struct.iovec = type { i8*, i64 }
%struct.swap_info_struct = type opaque
%union.anon.46 = type { %struct.pipe_inode_info* }
%struct.fscrypt_info = type opaque
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%union.anon.3 = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.atomic_t, %struct.atomic_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %union.anon.3, i64, i64, i64, %union.anon.3, %struct.key*, %struct.key*, %struct.hlist_node, %struct.atomic_t, %union.anon.3 }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.atomic_t] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.mutex = type { %union.anon.3, %struct.spinlock, %struct.qspinlock, %struct.list_head, i8*, %struct.lockdep_map }
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %union.anon.3*, %union.anon.3*, %union.anon.3, %struct.page*, %struct.mem_cgroup*, %struct.page*, %union.anon.3*, %struct.spinlock*, %struct.page* }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.qspinlock }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32, %struct.lockdep_map }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.dev_pin_info*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.cma*, %union.anon.51, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.atomic_t, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head, %struct.pm_domain_data* }
%struct.pm_domain_data = type opaque
%struct.dev_pm_qos = type { %struct.pm_qos_constraints, %struct.pm_qos_constraints, %struct.pm_qos_flags, %struct.dev_pm_qos_request*, %struct.dev_pm_qos_request*, %struct.dev_pm_qos_request* }
%struct.pm_qos_constraints = type { %union.anon.0, i32, i32, i32, i32, %struct.blocking_notifier_head* }
%struct.blocking_notifier_head = type { %struct.rw_semaphore, %struct.notifier_block* }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.pm_qos_flags = type { %struct.list_head, i32 }
%struct.dev_pm_qos_request = type { i32, %union.anon.61, %struct.device* }
%union.anon.61 = type { %struct.plist_node }
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dev_pin_info = type { %struct.pinctrl*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state* }
%struct.pinctrl = type opaque
%struct.pinctrl_state = type opaque
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, i64)*, void (%struct.device*, i64, i8*, i64, i64)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, i64)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, i64 (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.cma = type opaque
%struct.device_node = type { i8*, i8*, i32, i8*, %struct.fwnode_handle, %struct.property*, %struct.property*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.kobject, i64, i8* }
%struct.fwnode_handle = type { i32, %struct.fwnode_handle* }
%struct.property = type { i8*, i32, i8*, %struct.property*, i64, i32, %struct.bin_attribute }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.usb_device_id = type { i16, i16, i16, i16, i16, i8, i8, i8, i8, i8, i8, i8, i64 }
%struct.usb_driver = type { i8*, i32 (%struct.usb_interface*, %struct.usb_device_id*)*, void (%struct.usb_interface*)*, i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, %struct.usb_device_id*, %struct.__wait_queue_head, %struct.usbdrv_wrap, i8 }
%struct.usb_interface = type { %struct.usb_host_interface*, %struct.usb_host_interface*, i32, %struct.usb_interface_assoc_descriptor*, i32, i32, i8, %struct.device, %struct.device*, %struct.atomic_t, %struct.work_struct }
%struct.usb_host_interface = type { %struct.usb_interface_descriptor, i32, i8*, %struct.usb_host_endpoint*, i8* }
%struct.usb_interface_descriptor = type { i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.usb_host_endpoint = type <{ %struct.usb_endpoint_descriptor, %struct.usb_ss_ep_comp_descriptor, %struct.usb_ssp_isoc_ep_comp_descriptor, i8, %struct.list_head, i8*, %struct.ep_device*, i8*, i32, i32, i32, [4 x i8] }>
%struct.usb_endpoint_descriptor = type <{ i8, i8, i8, i8, i16, i8, i8, i8 }>
%struct.usb_ss_ep_comp_descriptor = type { i8, i8, i8, i8, i16 }
%struct.usb_ssp_isoc_ep_comp_descriptor = type { i8, i8, i16, i32 }
%struct.ep_device = type { %struct.usb_endpoint_descriptor*, %struct.usb_device.3478*, %struct.device.3441 }
%struct.usb_device.3478 = type { i32, [16 x i8], i32, i32, i32, %struct.usb_tt*, i32, [2 x i32], %struct.usb_device.3478*, %struct.usb_bus.3480*, %struct.usb_host_endpoint, %struct.device.3441, %struct.usb_device_descriptor, %struct.usb_host_bos*, %struct.usb_host_config.3484*, %struct.usb_host_config.3484*, [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*], i8**, i16, i8, i8, i16, i32, i8*, i8*, i8*, %struct.list_head, i32, i32, %struct.atomic_t, i64, i64, i8, %struct.wusb_dev*, i32, i32, %struct.anon.26, %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters, i32 }
%struct.usb_tt = type { %struct.usb_device*, i32, i32, i8*, %struct.spinlock, %struct.list_head, %struct.work_struct }
%struct.usb_device = type { i32, [16 x i8], i32, i32, i32, %struct.usb_tt*, i32, [2 x i32], %struct.usb_device*, %struct.usb_bus*, %struct.usb_host_endpoint, %struct.device, %struct.usb_device_descriptor, %struct.usb_host_bos*, %struct.usb_host_config*, %struct.usb_host_config*, [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*], i8**, i16, i8, i8, i16, i32, i8*, i8*, i8*, %struct.list_head, i32, i32, %struct.atomic_t, i64, i64, i8, %struct.wusb_dev*, i32, i32, %struct.anon.26, %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters, i32 }
%struct.usb_bus = type { %struct.device*, i32, i8*, i8, i8, i8, i8, i32, i32, %struct.mutex, %struct.usb_devmap, %struct.usb_device*, %struct.usb_bus*, i32, i32, i32, i32, %struct.mon_bus*, i32 }
%struct.usb_devmap = type { [2 x i64] }
%struct.mon_bus = type opaque
%struct.usb_host_config = type { %struct.usb_config_descriptor, i8*, [16 x %struct.usb_interface_assoc_descriptor*], [32 x %struct.usb_interface*], [32 x %struct.usb_interface_cache*], i8*, i32 }
%struct.usb_config_descriptor = type <{ i8, i8, i16, i8, i8, i8, i8, i8 }>
%struct.usb_interface_cache = type { i32, %struct.kref, [0 x %struct.usb_host_interface] }
%struct.usb_bus.3480 = type { %struct.device.3441*, i32, i8*, i8, i8, i8, i8, i32, i32, %struct.mutex, %struct.usb_devmap, %struct.usb_device.3478*, %struct.usb_bus.3480*, i32, i32, i32, i32, %struct.mon_bus*, i32 }
%struct.usb_device_descriptor = type { i8, i8, i16, i8, i8, i8, i8, i16, i16, i16, i8, i8, i8, i8 }
%struct.usb_host_bos = type { %struct.usb_bos_descriptor*, %struct.usb_ext_cap_descriptor*, %struct.usb_ss_cap_descriptor*, %struct.usb_ssp_cap_descriptor*, %struct.usb_ss_container_id_descriptor*, %struct.usb_ptm_cap_descriptor* }
%struct.usb_bos_descriptor = type <{ i8, i8, i16, i8 }>
%struct.usb_ext_cap_descriptor = type <{ i8, i8, i8, i32 }>
%struct.usb_ss_cap_descriptor = type { i8, i8, i8, i8, i16, i8, i8, i16 }
%struct.usb_ssp_cap_descriptor = type { i8, i8, i8, i8, i32, i16, i16, [1 x i32] }
%struct.usb_ss_container_id_descriptor = type { i8, i8, i8, i8, [16 x i8] }
%struct.usb_ptm_cap_descriptor = type { i8, i8, i8 }
%struct.usb_host_config.3484 = type { %struct.usb_config_descriptor, i8*, [16 x %struct.usb_interface_assoc_descriptor*], [32 x %struct.usb_interface.3499*], [32 x %struct.usb_interface_cache*], i8*, i32 }
%struct.usb_interface.3499 = type { %struct.usb_host_interface*, %struct.usb_host_interface*, i32, %struct.usb_interface_assoc_descriptor*, i32, i32, i8, %struct.device.3441, %struct.device.3441*, %struct.atomic_t, %struct.work_struct }
%struct.wusb_dev = type opaque
%struct.usb3_lpm_parameters = type { i32, i32, i32, i32 }
%struct.device.3441 = type { %struct.device.3441*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type.3443*, %struct.mutex, %struct.bus_type.3444*, %struct.device_driver.3445*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info.3447, %struct.dev_pm_domain.3448*, %struct.irq_domain*, %struct.dev_pin_info*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.cma*, %union.anon.51, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class.3458*, %struct.attribute_group**, void (%struct.device.3441*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_type.3443 = type { i8*, %struct.attribute_group**, {}*, i8* (%struct.device.3441*, i16*, %struct.atomic_t*, %struct.atomic_t*)*, void (%struct.device.3441*)*, %struct.dev_pm_ops.3461* }
%struct.dev_pm_ops.3461 = type { i32 (%struct.device.3441*)*, void (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)* }
%struct.bus_type.3444 = type { i8*, i8*, %struct.device.3441*, %struct.device_attribute.3462*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device.3441*, %struct.device_driver.3445*)*, {}*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, void (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*, i32)*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, %struct.dev_pm_ops.3461*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute.3462 = type { %struct.attribute, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*)*, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*, i64)* }
%struct.device_driver.3445 = type { i8*, %struct.bus_type.3444*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device.3441*)*, i32 (%struct.device.3441*)*, void (%struct.device.3441*)*, i32 (%struct.device.3441*, i32)*, i32 (%struct.device.3441*)*, %struct.attribute_group**, %struct.dev_pm_ops.3461*, %struct.driver_private* }
%struct.dev_pm_info.3447 = type { %struct.atomic_t, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device.3441*, i32)*, %struct.dev_pm_qos* }
%struct.dev_pm_domain.3448 = type { %struct.dev_pm_ops.3461, void (%struct.device.3441*, i1)*, i32 (%struct.device.3441*)*, void (%struct.device.3441*)*, void (%struct.device.3441*)* }
%struct.class.3458 = type { i8*, %struct.module*, %struct.class_attribute.3475*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, {}*, i8* (%struct.device.3441*, i16*)*, void (%struct.class.3458*)*, void (%struct.device.3441*)*, i32 (%struct.device.3441*, i32)*, i32 (%struct.device.3441*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device.3441*)*, %struct.dev_pm_ops.3461*, %struct.subsys_private* }
%struct.class_attribute.3475 = type { %struct.attribute, i64 (%struct.class.3458*, %struct.class_attribute.3475*, i8*)*, i64 (%struct.class.3458*, %struct.class_attribute.3475*, i8*, i64)* }
%struct.usb_interface_assoc_descriptor = type { i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.usbdrv_wrap = type { %struct.device_driver, i32 }
%struct.idr = type { %struct.radix_tree_root, i32 }
%struct.usb_mon_operations = type { void (%struct.usb_bus*, %struct.urb*)*, void (%struct.usb_bus*, %struct.urb*, i32)*, void (%struct.usb_bus*, %struct.urb*, i32)* }
%struct.urb = type { %struct.kref, i8*, %struct.atomic_t, %struct.atomic_t, i32, %struct.list_head, %struct.list_head, %struct.usb_anchor*, %struct.usb_device*, %struct.usb_host_endpoint*, i32, i32, i32, i32, i8*, i64, %struct.scatterlist*, i32, i32, i32, i32, i8*, i64, i32, i32, i32, i32, i8*, void (%struct.urb*)*, [0 x %struct.usb3_lpm_parameters] }
%struct.usb_anchor = type { %struct.list_head, %struct.__wait_queue_head, %struct.spinlock, %struct.atomic_t, i8 }
%struct.pv_irq_ops = type { %union.anon.51, %union.anon.51, %union.anon.51, %union.anon.51, void ()*, void ()*, void ()* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.usb_class = type { %struct.kref, %struct.class* }
%struct.cdev = type { %struct.kobject, %struct.module*, %struct.file_operations*, %struct.list_head, i32, i32 }
%struct.usb_device_driver = type { i8*, i32 (%struct.usb_device*)*, void (%struct.usb_device*)*, i32 (%struct.usb_device*, i32)*, i32 (%struct.usb_device*, i32)*, %struct.usbdrv_wrap, i8 }
%struct.usbdevfs_disconnectsignal = type { i32, i8* }
%struct.device.5257 = type { %struct.device.5257*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type.5260*, %struct.mutex, %struct.bus_type.5262*, %struct.device_driver.5263*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info.5265, %struct.dev_pm_domain.5266*, %struct.irq_domain*, %struct.dev_pin_info*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.cma*, %union.anon.51, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class.5278*, %struct.attribute_group**, void (%struct.device.5257*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_type.5260 = type { i8*, %struct.attribute_group**, {}*, i8* (%struct.device.5257*, i16*, %struct.atomic_t*, %struct.atomic_t*)*, void (%struct.device.5257*)*, %struct.dev_pm_ops.5256* }
%struct.bus_type.5262 = type { i8*, i8*, %struct.device.5257*, %struct.device_attribute.5555*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device.5257*, %struct.device_driver.5263*)*, {}*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, void (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*, i32)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, %struct.dev_pm_ops.5256*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute.5555 = type { %struct.attribute, i64 (%struct.device.5257*, %struct.device_attribute.5555*, i8*)*, i64 (%struct.device.5257*, %struct.device_attribute.5555*, i8*, i64)* }
%struct.device_driver.5263 = type { i8*, %struct.bus_type.5262*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, void (%struct.device.5257*)*, i32 (%struct.device.5257*, i32)*, i32 (%struct.device.5257*)*, %struct.attribute_group**, %struct.dev_pm_ops.5256*, %struct.driver_private* }
%struct.dev_pm_info.5265 = type { %struct.atomic_t, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device.5257*, i32)*, %struct.dev_pm_qos.5564* }
%struct.dev_pm_qos.5564 = type { %struct.pm_qos_constraints, %struct.pm_qos_constraints, %struct.pm_qos_flags, %struct.dev_pm_qos_request.5568*, %struct.dev_pm_qos_request.5568*, %struct.dev_pm_qos_request.5568* }
%struct.dev_pm_qos_request.5568 = type { i32, %union.anon.61, %struct.device.5257* }
%struct.dev_pm_domain.5266 = type { %struct.dev_pm_ops.5256, void (%struct.device.5257*, i1)*, i32 (%struct.device.5257*)*, void (%struct.device.5257*)*, void (%struct.device.5257*)* }
%struct.dev_pm_ops.5256 = type { i32 (%struct.device.5257*)*, void (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)*, i32 (%struct.device.5257*)* }
%struct.class.5278 = type { i8*, %struct.module*, %struct.class_attribute.5574*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, {}*, i8* (%struct.device.5257*, i16*)*, void (%struct.class.5278*)*, void (%struct.device.5257*)*, i32 (%struct.device.5257*, i32)*, i32 (%struct.device.5257*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device.5257*)*, %struct.dev_pm_ops.5256*, %struct.subsys_private* }
%struct.class_attribute.5574 = type { %struct.attribute, i64 (%struct.class.5278*, %struct.class_attribute.5574*, i8*)*, i64 (%struct.class.5278*, %struct.class_attribute.5574*, i8*, i64)* }
%struct.resource = type { i64, i64, i8*, i64, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.acpi_bus_type = type { %struct.list_head, i8*, i1 (%struct.device*)*, %struct.acpi_device* (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.acpi_device = type { i32, i8*, %struct.fwnode_handle, %struct.acpi_device*, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.atomic_t, %struct.atomic_t, %struct.acpi_device_pnp, %struct.acpi_device_power, %struct.acpi_device_wakeup, %struct.acpi_device_perf, %struct.acpi_device_dir, %struct.acpi_device_data, %struct.acpi_scan_handler*, %struct.acpi_hotplug_context*, %struct.acpi_driver*, %struct.acpi_gpio_mapping*, i8*, %struct.device, i32, i32, %struct.list_head, %struct.mutex, void (%struct.acpi_device*)* }
%struct.acpi_device_pnp = type { [8 x i8], %struct.atomic_t, i64, i8*, %struct.list_head, [40 x i8], [20 x i8], %union.acpi_object* }
%union.acpi_object = type { %struct.anon.71 }
%struct.anon.71 = type { i32, i32, i64, i32 }
%struct.acpi_device_power = type { i32, %struct.atomic_t, [5 x %struct.acpi_device_power_state] }
%struct.acpi_device_power_state = type { %struct.lockdep_subclass_key, i32, i32, %struct.list_head }
%struct.acpi_device_wakeup = type { i8*, i64, i64, %struct.list_head, %struct.lockdep_subclass_key, %struct.acpi_device_wakeup_context, %struct.wakeup_source*, i32 }
%struct.acpi_device_wakeup_context = type { %struct.work_struct, %struct.device* }
%struct.acpi_device_perf = type { i32, %struct.lockdep_subclass_key, i32, %struct.acpi_device_perf_state* }
%struct.acpi_device_perf_state = type { %struct.lockdep_subclass_key, i8, i8, i32 }
%struct.acpi_device_dir = type { %struct.proc_dir_entry* }
%struct.proc_dir_entry = type opaque
%struct.acpi_device_data = type { %union.acpi_object*, %union.acpi_object*, %union.acpi_object*, %struct.list_head }
%struct.acpi_scan_handler = type { %struct.acpi_device_id*, %struct.list_head, i1 (i8*, %struct.acpi_device_id**)*, i32 (%struct.acpi_device*, %struct.acpi_device_id*)*, void (%struct.acpi_device*)*, void (%struct.device*)*, void (%struct.device*)*, %struct.acpi_hotplug_profile }
%struct.acpi_hotplug_profile = type { %struct.kobject, i32 (%struct.acpi_device*)*, void (%struct.acpi_device*)*, i8 }
%struct.acpi_hotplug_context = type { %struct.acpi_device*, i32 (%struct.acpi_device*, i32)*, void (%struct.acpi_device*, i32)*, void (%struct.acpi_device*)* }
%struct.acpi_driver = type { [80 x i8], [80 x i8], %struct.acpi_device_id*, i32, %struct.acpi_device_ops, %struct.device_driver, %struct.module* }
%struct.acpi_device_ops = type { i32 (%struct.acpi_device*)*, i32 (%struct.acpi_device*)*, void (%struct.acpi_device*, i32)* }
%struct.acpi_gpio_mapping = type { i8*, %struct.acpi_gpio_params*, i32 }
%struct.acpi_gpio_params = type { i32, i32, i8 }
%struct.usb_hcd = type { %struct.usb_bus, %struct.kref, i8*, i32, [24 x i8], %struct.timer_list, %struct.urb*, %struct.work_struct, %struct.hc_driver*, %struct.usb_phy*, %struct.phy*, i64, i16, i32, i8*, i64, i64, i32, %struct.giveback_urb_bh, %struct.giveback_urb_bh, %struct.mutex*, %struct.mutex*, %struct.usb_hcd*, %struct.usb_hcd*, [4 x %struct.dma_pool*], i32, [0 x i64] }
%struct.hc_driver = type { i8*, i8*, i64, i32 (%struct.usb_hcd*)*, i32, i32 (%struct.usb_hcd*)*, i32 (%struct.usb_hcd*)*, i32 (%struct.usb_hcd*, i1)*, i32 (%struct.usb_hcd*, i1)*, void (%struct.usb_hcd*)*, void (%struct.usb_hcd*)*, i32 (%struct.usb_hcd*)*, i32 (%struct.usb_hcd*, %struct.urb*, i32)*, i32 (%struct.usb_hcd*, %struct.urb*, i32)*, i32 (%struct.usb_hcd*, %struct.urb*, i32)*, void (%struct.usb_hcd*, %struct.urb*)*, void (%struct.usb_hcd*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd*, i8*)*, i32 (%struct.usb_hcd*, i16, i16, i16, i8*, i16)*, i32 (%struct.usb_hcd*)*, i32 (%struct.usb_hcd*)*, i32 (%struct.usb_hcd*, i32)*, void (%struct.usb_hcd*, i32)*, i32 (%struct.usb_hcd*, i32)*, void (%struct.usb_hcd*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)*, void (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)*, void (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, i32)*, i32 (%struct.usb_hcd*, i32, i1)* }
%struct.usb_phy = type { %struct.device*, i8*, i32, i32, i32, %struct.usb_otg*, %struct.device*, %struct.usb_phy_io_ops*, i8*, %struct.atomic_notifier_head, i16, i16, %struct.list_head, i32 (%struct.usb_phy*)*, void (%struct.usb_phy*)*, i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i1)*, i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32)* }
%struct.usb_otg = type { i8, %struct.phy*, %struct.usb_phy*, %struct.usb_bus*, %struct.usb_gadget*, i32, i32 (%struct.usb_otg*, %struct.usb_bus*)*, i32 (%struct.usb_otg*, %struct.usb_gadget*)*, i32 (%struct.usb_otg*, i1)*, i32 (%struct.usb_otg*)*, i32 (%struct.usb_otg*)* }
%struct.usb_gadget = type opaque
%struct.usb_phy_io_ops = type { i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32, i32)* }
%struct.atomic_notifier_head = type { %struct.spinlock, %struct.notifier_block* }
%struct.phy = type { %struct.device, i32, %struct.phy_ops*, %struct.mutex, i32, i32, %struct.atomic_t, %struct.regulator* }
%struct.phy_ops = type { i32 (%struct.phy*)*, i32 (%struct.phy*)*, i32 (%struct.phy*)*, i32 (%struct.phy*)*, i32 (%struct.phy*, i32)*, i32 (%struct.phy*)*, %struct.module* }
%struct.regulator = type opaque
%struct.giveback_urb_bh = type { i8, %struct.spinlock, %struct.list_head, %struct.tasklet_struct, %struct.usb_host_endpoint* }
%struct.tasklet_struct = type { %struct.tasklet_struct*, i64, %struct.atomic_t, void (i64)*, i64 }
%struct.dma_pool = type opaque
%struct.usb_descriptor_header = type { i8, i8 }
%union.anon.59 = type { %struct.list_head* }
%struct.each_dev_arg = type { i8*, i32 (%struct.usb_device*, i8*)* }
%struct.find_interface_arg = type { i32, %struct.device_driver* }
%struct.usb_hub = type { %struct.device*, %struct.usb_device*, %struct.kref, %struct.urb*, [8 x i8]*, %union.anon.62*, %struct.mutex, i32, i32, [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], %struct.usb_hub_descriptor*, %struct.usb_tt, i32, i32, i8, [31 x i8], %struct.delayed_work, %struct.delayed_work, %struct.work_struct, %struct.usb_port** }
%union.anon.62 = type { %struct.usb_port_status }
%struct.usb_port_status = type { i16, i16, i32 }
%struct.usb_hub_descriptor = type <{ i8, i8, i8, i16, i8, i8, %union.anon.63 }>
%union.anon.63 = type { %struct.anon.64 }
%struct.anon.64 = type { [4 x i8], [4 x i8] }
%struct.usb_port = type { %struct.usb_device*, %struct.device, %struct.usb_dev_state*, %struct.usb_port*, %struct.dev_pm_qos_request*, i32, i32, %struct.mutex, i8, i8 }
%struct.usb_dev_state = type { %struct.list_head, %struct.usb_device*, %struct.file*, %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head, %struct.__wait_queue_head, i32, %struct.pid*, %struct.cred*, i8*, i64, i32, i32, i8, i64 }
%struct._ddebug = type { i8*, i8*, i8*, i8*, i32 }
%struct.usb_set_sel_req = type { i8, i8, i16, i16 }
%struct.anon.65 = type <{ i8, i16, i16 }>
%struct.usb_tt_clear = type { %struct.list_head, i32, i16, %struct.usb_hcd*, %struct.usb_host_endpoint* }
%struct.usbdevfs_hub_portinfo = type { i8, [127 x i8] }
%struct.usb_hub_status = type { i16, i16 }
%struct.usb_qualifier_descriptor = type { i8, i8, i16, i8, i8, i8, i8, i8, i8 }
%struct.platform_device = type { i8*, i32, i8, %struct.device, i32, %struct.resource*, %struct.platform_device_id*, i8*, %struct.mfd_cell*, %struct.mod_arch_specific }
%struct.platform_device_id = type { [20 x i8], i64 }
%struct.mfd_cell = type opaque
%struct.usb_hcd.712 = type { %struct.usb_bus, %struct.kref, i8*, i32, [24 x i8], %struct.timer_list, %struct.urb*, %struct.work_struct, %struct.hc_driver.713*, %struct.usb_phy*, %struct.phy*, i64, i16, i32, i8*, i64, i64, i32, %struct.giveback_urb_bh, %struct.giveback_urb_bh, %struct.mutex*, %struct.mutex*, %struct.usb_hcd.712*, %struct.usb_hcd.712*, [4 x %struct.dma_pool*], i32, [0 x i64] }
%struct.hc_driver.713 = type { i8*, i8*, i64, i32 (%struct.usb_hcd.712*)*, i32, i32 (%struct.usb_hcd.712*)*, i32 (%struct.usb_hcd.712*)*, i32 (%struct.usb_hcd.712*, i1)*, i32 (%struct.usb_hcd.712*, i1)*, {}*, {}*, i32 (%struct.usb_hcd.712*)*, i32 (%struct.usb_hcd.712*, %struct.urb*, i32)*, i32 (%struct.usb_hcd.712*, %struct.urb*, i32)*, i32 (%struct.usb_hcd.712*, %struct.urb*, i32)*, void (%struct.usb_hcd.712*, %struct.urb*)*, void (%struct.usb_hcd.712*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd.712*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.712*, i8*)*, i32 (%struct.usb_hcd.712*, i16, i16, i16, i8*, i16)*, i32 (%struct.usb_hcd.712*)*, i32 (%struct.usb_hcd.712*)*, i32 (%struct.usb_hcd.712*, i32)*, void (%struct.usb_hcd.712*, i32)*, i32 (%struct.usb_hcd.712*, i32)*, void (%struct.usb_hcd.712*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*)*, void (%struct.usb_hcd.712*, %struct.usb_device*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32, i32)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*)*, void (%struct.usb_hcd.712*, %struct.usb_device*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_tt*, i32)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd.712*, i32)*, i32 (%struct.usb_hcd.712*, i32, i1)* }
%struct.usb_ctrlrequest = type { i8, i8, i16, i16, i16 }
%struct.urb.744 = type { %struct.kref, i8*, %struct.atomic_t, %struct.atomic_t, i32, %struct.list_head, %struct.list_head, %struct.usb_anchor*, %struct.usb_device*, %struct.usb_host_endpoint*, i32, i32, i32, i32, i8*, i64, %struct.scatterlist*, i32, i32, i32, i32, i8*, i64, i32, i32, i32, i32, i8*, {}*, [0 x %struct.usb3_lpm_parameters] }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }
%struct.usb_cdc_parsed_header = type { %struct.usb_cdc_union_desc*, %struct.usb_cdc_header_desc*, %struct.usb_cdc_union_desc*, %struct.usb_cdc_acm_descriptor*, %struct.usb_ss_ep_comp_descriptor*, %struct.usb_cdc_network_terminal_desc*, %struct.usb_cdc_ether_desc*, %struct.usb_cdc_dmm_desc*, %struct.usb_cdc_mdlm_desc*, %struct.usb_cdc_mdlm_detail_desc*, %struct.usb_cdc_header_desc*, %struct.usb_cdc_ncm_desc*, %struct.usb_cdc_mbim_desc*, %struct.usb_cdc_mbim_extended_desc*, i8 }
%struct.usb_cdc_union_desc = type { i8, i8, i8, i8, i8 }
%struct.usb_cdc_acm_descriptor = type { i8, i8, i8, i8 }
%struct.usb_cdc_network_terminal_desc = type { i8, i8, i8, i8, i8, i8, i8 }
%struct.usb_cdc_ether_desc = type <{ i8, i8, i8, i8, i32, i16, i16, i8 }>
%struct.usb_cdc_dmm_desc = type <{ i8, i8, i8, i16, i16 }>
%struct.usb_cdc_mdlm_desc = type <{ i8, i8, i8, i16, [16 x i8] }>
%struct.usb_cdc_mdlm_detail_desc = type { i8, i8, i8, i8, [0 x i8] }
%struct.usb_cdc_header_desc = type <{ i8, i8, i8, i16 }>
%struct.usb_cdc_ncm_desc = type <{ i8, i8, i8, i16, i8 }>
%struct.usb_cdc_mbim_desc = type <{ i8, i8, i8, i16, i16, i8, i8, i16, i8 }>
%struct.usb_cdc_mbim_extended_desc = type <{ i8, i8, i8, i16, i8, i16 }>
%struct.set_config_request = type { %struct.usb_device*, i32, %struct.work_struct, %struct.list_head }
%struct.api_context = type { %struct.completion, i32 }
%struct.usb_sg_request = type { i32, i64, %struct.spinlock, %struct.usb_device*, i32, i32, %struct.urb**, i32, %struct.completion }
%struct.usb_dynid = type { %struct.list_head, %struct.usb_device_id }
%struct.usb_class_driver = type { i8*, i8* (%struct.device*, i16*)*, %struct.file_operations*, i32 }
%struct.usb_hcd.2781 = type { %struct.usb_bus, %struct.kref, i8*, i32, [24 x i8], %struct.timer_list, %struct.urb*, %struct.work_struct, %struct.hc_driver.2784*, %struct.usb_phy*, %struct.phy*, i64, i16, i32, i8*, i64, i64, i32, %struct.giveback_urb_bh, %struct.giveback_urb_bh, %struct.mutex*, %struct.mutex*, %struct.usb_hcd.2781*, %struct.usb_hcd.2781*, [4 x %struct.dma_pool*], i32, [0 x i64] }
%struct.hc_driver.2784 = type { i8*, i8*, i64, i32 (%struct.usb_hcd.2781*)*, i32, {}*, {}*, i32 (%struct.usb_hcd.2781*, i1)*, i32 (%struct.usb_hcd.2781*, i1)*, void (%struct.usb_hcd.2781*)*, void (%struct.usb_hcd.2781*)*, {}*, i32 (%struct.usb_hcd.2781*, %struct.urb*, i32)*, i32 (%struct.usb_hcd.2781*, %struct.urb*, i32)*, i32 (%struct.usb_hcd.2781*, %struct.urb*, i32)*, void (%struct.usb_hcd.2781*, %struct.urb*)*, void (%struct.usb_hcd.2781*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd.2781*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.2781*, i8*)*, i32 (%struct.usb_hcd.2781*, i16, i16, i16, i8*, i16)*, {}*, {}*, i32 (%struct.usb_hcd.2781*, i32)*, void (%struct.usb_hcd.2781*, i32)*, i32 (%struct.usb_hcd.2781*, i32)*, void (%struct.usb_hcd.2781*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.2781*, %struct.usb_device*)*, void (%struct.usb_hcd.2781*, %struct.usb_device*)*, i32 (%struct.usb_hcd.2781*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32, i32)*, i32 (%struct.usb_hcd.2781*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32)*, i32 (%struct.usb_hcd.2781*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.2781*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.2781*, %struct.usb_device*)*, void (%struct.usb_hcd.2781*, %struct.usb_device*)*, i32 (%struct.usb_hcd.2781*, %struct.usb_device*)*, i32 (%struct.usb_hcd.2781*, %struct.usb_device*)*, i32 (%struct.usb_hcd.2781*, %struct.usb_device*, %struct.usb_tt*, i32)*, i32 (%struct.usb_hcd.2781*, %struct.usb_device*)*, i32 (%struct.usb_hcd.2781*, %struct.usb_device*)*, i32 (%struct.usb_hcd.2781*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd.2781*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd.2781*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd.2781*, i32)*, i32 (%struct.usb_hcd.2781*, i32, i1)* }
%struct.async = type { %struct.list_head, %struct.usb_dev_state*, %struct.pid*, %struct.cred*, i32, i32, i8*, i8*, %struct.urb*, %struct.usb_memory*, i32, i32, i32, i8, i8 }
%struct.usb_memory = type { %struct.list_head, i32, i32, i32, i8*, i64, i64, %struct.usb_dev_state* }
%struct.usbdevfs_bulktransfer = type { i32, i32, i32, i8* }
%struct.usbdevfs_getdriver = type { i32, [256 x i8] }
%struct.usbdevfs_connectinfo = type { i32, i8 }
%struct.usbdevfs_urb = type { i8, i8, i32, i32, i8*, i32, i32, i32, %struct.atomic_t, i32, i32, i8*, [0 x %struct.exception_table_entry] }
%struct.usbdevfs_ctrltransfer32 = type { i8, i8, i16, i16, i16, i32, i32 }
%struct.usbdevfs_ctrltransfer = type { i8, i8, i16, i16, i16, i32, i8* }
%struct.usbdevfs_urb32 = type { i8, i8, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [0 x %struct.exception_table_entry] }
%struct.usbdevfs_ioctl = type { i32, i32, i8* }
%struct.__large_struct = type { [100 x i64] }
%struct.usbdevfs_disconnect_claim = type { i32, i32, [256 x i8] }
%struct.usbdevfs_streams = type { i32, i32, [0 x i8] }
%struct.anon.17 = type { i8*, i16, %union.anon.18 }
%union.anon.18 = type { %struct.anon.19 }
%struct.anon.19 = type { i8*, i8* }
%struct.usb_port.5576 = type { %struct.usb_device.5577*, %struct.device.5257, %struct.usb_dev_state*, %struct.usb_port.5576*, %struct.dev_pm_qos_request.5568*, i32, i32, %struct.mutex, i8, i8 }
%struct.usb_device.5577 = type { i32, [16 x i8], i32, i32, i32, %struct.usb_tt.5579*, i32, [2 x i32], %struct.usb_device.5577*, %struct.usb_bus.5580*, %struct.usb_host_endpoint, %struct.device.5257, %struct.usb_device_descriptor, %struct.usb_host_bos*, %struct.usb_host_config.5584*, %struct.usb_host_config.5584*, [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*], i8**, i16, i8, i8, i16, i32, i8*, i8*, i8*, %struct.list_head, i32, i32, %struct.atomic_t, i64, i64, i8, %struct.wusb_dev*, i32, i32, %struct.anon.26, %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters, i32 }
%struct.usb_tt.5579 = type { %struct.usb_device.5577*, i32, i32, i8*, %struct.spinlock, %struct.list_head, %struct.work_struct }
%struct.usb_bus.5580 = type { %struct.device.5257*, i32, i8*, i8, i8, i8, i8, i32, i32, %struct.mutex, %struct.usb_devmap, %struct.usb_device.5577*, %struct.usb_bus.5580*, i32, i32, i32, i32, %struct.mon_bus*, i32 }
%struct.usb_host_config.5584 = type { %struct.usb_config_descriptor, i8*, [16 x %struct.usb_interface_assoc_descriptor*], [32 x %struct.usb_interface.5601*], [32 x %struct.usb_interface_cache*], i8*, i32 }
%struct.usb_interface.5601 = type { %struct.usb_host_interface*, %struct.usb_host_interface*, i32, %struct.usb_interface_assoc_descriptor*, i32, i32, i8, %struct.device.5257, %struct.device.5257*, %struct.atomic_t, %struct.work_struct }
%struct.usb_hub.5605 = type { %struct.device.5257*, %struct.usb_device.5577*, %struct.kref, %struct.urb.5606*, [8 x i8]*, %union.anon.62*, %struct.mutex, i32, i32, [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], %struct.usb_hub_descriptor*, %struct.usb_tt.5579, i32, i32, i8, [31 x i8], %struct.delayed_work, %struct.delayed_work, %struct.work_struct, %struct.usb_port.5576** }
%struct.urb.5606 = type { %struct.kref, i8*, %struct.atomic_t, %struct.atomic_t, i32, %struct.list_head, %struct.list_head, %struct.usb_anchor*, %struct.usb_device.5577*, %struct.usb_host_endpoint*, i32, i32, i32, i32, i8*, i64, %struct.scatterlist*, i32, i32, i32, i32, i8*, i64, i32, i32, i32, i32, i8*, void (%struct.urb.5606*)*, [0 x %struct.usb3_lpm_parameters] }
%struct.usb_hcd.5612 = type { %struct.usb_bus.5580, %struct.kref, i8*, i32, [24 x i8], %struct.timer_list, %struct.urb.5606*, %struct.work_struct, %struct.hc_driver.5613*, %struct.usb_phy*, %struct.phy*, i64, i16, i32, i8*, i64, i64, i32, %struct.giveback_urb_bh, %struct.giveback_urb_bh, %struct.mutex*, %struct.mutex*, %struct.usb_hcd.5612*, %struct.usb_hcd.5612*, [4 x %struct.dma_pool*], i32, [0 x i64] }
%struct.hc_driver.5613 = type { i8*, i8*, i64, i32 (%struct.usb_hcd.5612*)*, i32, i32 (%struct.usb_hcd.5612*)*, i32 (%struct.usb_hcd.5612*)*, i32 (%struct.usb_hcd.5612*, i1)*, i32 (%struct.usb_hcd.5612*, i1)*, void (%struct.usb_hcd.5612*)*, void (%struct.usb_hcd.5612*)*, i32 (%struct.usb_hcd.5612*)*, i32 (%struct.usb_hcd.5612*, %struct.urb.5606*, i32)*, i32 (%struct.usb_hcd.5612*, %struct.urb.5606*, i32)*, i32 (%struct.usb_hcd.5612*, %struct.urb.5606*, i32)*, void (%struct.usb_hcd.5612*, %struct.urb.5606*)*, void (%struct.usb_hcd.5612*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd.5612*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.5612*, i8*)*, i32 (%struct.usb_hcd.5612*, i16, i16, i16, i8*, i16)*, i32 (%struct.usb_hcd.5612*)*, i32 (%struct.usb_hcd.5612*)*, i32 (%struct.usb_hcd.5612*, i32)*, void (%struct.usb_hcd.5612*, i32)*, i32 (%struct.usb_hcd.5612*, i32)*, void (%struct.usb_hcd.5612*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.5612*, %struct.usb_device.5577*)*, void (%struct.usb_hcd.5612*, %struct.usb_device.5577*)*, i32 (%struct.usb_hcd.5612*, %struct.usb_device.5577*, %struct.usb_host_endpoint**, i32, i32, i32)*, i32 (%struct.usb_hcd.5612*, %struct.usb_device.5577*, %struct.usb_host_endpoint**, i32, i32)*, i32 (%struct.usb_hcd.5612*, %struct.usb_device.5577*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.5612*, %struct.usb_device.5577*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.5612*, %struct.usb_device.5577*)*, void (%struct.usb_hcd.5612*, %struct.usb_device.5577*)*, i32 (%struct.usb_hcd.5612*, %struct.usb_device.5577*)*, i32 (%struct.usb_hcd.5612*, %struct.usb_device.5577*)*, i32 (%struct.usb_hcd.5612*, %struct.usb_device.5577*, %struct.usb_tt.5579*, i32)*, i32 (%struct.usb_hcd.5612*, %struct.usb_device.5577*)*, i32 (%struct.usb_hcd.5612*, %struct.usb_device.5577*)*, i32 (%struct.usb_hcd.5612*, %struct.usb_device.5577*, i32)*, i32 (%struct.usb_hcd.5612*, %struct.usb_device.5577*, i32)*, i32 (%struct.usb_hcd.5612*, %struct.usb_device.5577*, i32)*, i32 (%struct.usb_hcd.5612*, i32)*, i32 (%struct.usb_hcd.5612*, i32, i1)* }
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i16, i8, i8, i8, i8, i8, i8, i16, [4 x i8], i64*, %struct.pci_driver*, i64, %struct.device_dma_parameters, i32, i8, [3 x i8], i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [17 x %struct.resource], i8, i32, i8, i16, %struct.atomic_t, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [17 x %struct.bin_attribute*], [17 x %struct.bin_attribute*], i8, i8, [6 x i8], %struct.attribute_group**, %struct.pci_vpd*, %union.anon.51.6169, i16, i8, i8, %struct.atomic_t, i64, i64, i8* }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, %struct.msi_controller*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.pci_ops = type { i32 (%struct.pci_bus*)*, void (%struct.pci_bus*)*, i8* (%struct.pci_bus*, i32, i32)*, i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.msi_controller = type opaque
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, {}*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.__wait_queue_head }
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*, i1)*, void (%struct.pci_dev*)* }
%struct.pcie_link_state = type opaque
%struct.pci_vpd = type opaque
%union.anon.51.6169 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.acpi_pld_info = type { i8, i8, i8, i8, i8, i16, i16, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i16, i16 }
%struct.acpi_object_list = type { i32, %union.acpi_object* }
%struct.anon.65.6589 = type { i32, i32, %union.acpi_object* }

@usbcore_name = global i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), align 8
@usb_device_type = global %struct.device_type { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.3.823, i32 0, i32 0), %struct.attribute_group** null, i32 (%struct.device*, %struct.kobj_uevent_env*)* @usb_dev_uevent, i8* (%struct.device*, i16*, %struct.atomic_t*, %struct.atomic_t*)* @usb_devnode, void (%struct.device*)* @usb_release_dev, %struct.dev_pm_ops* @usb_device_pm_ops }, align 8
@usb_device_pm_ops = internal constant %struct.dev_pm_ops { i32 (%struct.device*)* @usb_dev_prepare, void (%struct.device*)* @usb_dev_complete, i32 (%struct.device*)* @usb_dev_suspend, i32 (%struct.device*)* @usb_dev_resume, i32 (%struct.device*)* @usb_dev_freeze, i32 (%struct.device*)* @usb_dev_thaw, i32 (%struct.device*)* @usb_dev_poweroff, i32 (%struct.device*)* @usb_dev_restore, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* @usb_runtime_suspend, i32 (%struct.device*)* @usb_runtime_resume, i32 (%struct.device*)* @usb_runtime_idle }, align 8
@.str.10 = private unnamed_addr constant [18 x i8] c"bus/usb/%03d/%03d\00", align 1
@.str.8 = private unnamed_addr constant [12 x i8] c"BUSNUM=%03d\00", align 1
@.str.9 = private unnamed_addr constant [12 x i8] c"DEVNUM=%03d\00", align 1
@usb_debug_root = common global %struct.dentry* null, align 8
@llvm.used = appending global [162 x i8*] [i8* bitcast (%struct.kernel_param* @__param_nousb to i8*), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__UNIQUE_ID_nousbtype16, i32 0, i32 0), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_disabled to i8*), i8* bitcast (%struct.kernel_param* @__param_autosuspend to i8*), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__UNIQUE_ID_autosuspendtype17, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @__UNIQUE_ID_autosuspend18, i32 0, i32 0), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_find_alt_setting to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_ifnum_to_if to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_altnum_to_altsetting to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_find_interface to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_for_each_dev to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_alloc_dev to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_get_dev to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_put_dev to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_get_intf to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_put_intf to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_lock_device_for_reset to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_get_current_frame_number to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab___usb_get_extra_descriptor to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_alloc_coherent to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_free_coherent to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_debug_root to i8*), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license19, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_blinkenlights to i8*), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__UNIQUE_ID_blinkenlightstype16, i32 0, i32 0), i8* getelementptr inbounds ([46 x i8], [46 x i8]* @__UNIQUE_ID_blinkenlights17, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_initial_descriptor_timeout to i8*), i8* getelementptr inbounds ([40 x i8], [40 x i8]* @__UNIQUE_ID_initial_descriptor_timeouttype18, i32 0, i32 0), i8* getelementptr inbounds ([120 x i8], [120 x i8]* @__UNIQUE_ID_initial_descriptor_timeout19, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_old_scheme_first to i8*), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__UNIQUE_ID_old_scheme_firsttype20, i32 0, i32 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @__UNIQUE_ID_old_scheme_first21, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_use_both_schemes to i8*), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__UNIQUE_ID_use_both_schemestype22, i32 0, i32 0), i8* getelementptr inbounds ([88 x i8], [88 x i8]* @__UNIQUE_ID_use_both_schemes23, i32 0, i32 0), i8* bitcast (%struct.kernel_symbol* @__ksymtab_ehci_cf_port_reset_rwsem to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_wakeup_notification to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hub_clear_tt_buffer to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hub_claim_port to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hub_release_port to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_set_device_state to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_disable_ltm to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_enable_ltm to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_root_hub_lost_power to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_disable_lpm to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_unlocked_disable_lpm to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_enable_lpm to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_unlocked_enable_lpm to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_ep0_reinit to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_reset_device to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_queue_reset_device to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hub_find_child to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcds_loaded to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_bus_idr to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_bus_idr_lock to i8*), i8* bitcast (%struct.kernel_param* @__param_authorized_default to i8*), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__UNIQUE_ID_authorized_defaulttype16, i32 0, i32 0), i8* getelementptr inbounds ([161 x i8], [161 x i8]* @__UNIQUE_ID_authorized_default17, i32 0, i32 0), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_poll_rh_status to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_start_port_resume to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_end_port_resume to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_calc_bus_time to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_link_urb_to_ep to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_check_unlink_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_unlink_urb_from_ep to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_unmap_urb_setup_for_dma to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_unmap_urb_for_dma to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_map_urb_for_dma to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_giveback_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_alloc_streams to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_free_streams to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_resume_root_hub to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_bus_start_enum to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_irq to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hc_died to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_create_shared_hcd to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_create_hcd to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_get_hcd to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_put_hcd to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_is_primary_hcd to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_add_hcd to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_remove_hcd to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_platform_shutdown to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_mon_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_mon_deregister to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_init_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_alloc_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_free_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_get_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_anchor_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_unanchor_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_submit_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_unlink_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_kill_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_poison_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_unpoison_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_block_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_kill_anchored_urbs to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_poison_anchored_urbs to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_unpoison_anchored_urbs to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_unlink_anchored_urbs to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_anchor_suspend_wakeups to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_anchor_resume_wakeups to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_wait_anchor_empty_timeout to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_get_from_anchor to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_scuttle_anchored_urbs to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_anchor_empty to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_control_msg to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_interrupt_msg to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_bulk_msg to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_sg_init to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_sg_wait to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_sg_cancel to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_get_descriptor to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_string to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_get_status to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_clear_halt to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_reset_endpoint to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_set_interface to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_reset_configuration to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_set_configuration to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_driver_set_configuration to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_cdc_parse_cdc_header to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_store_new_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_show_dynids to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_driver_claim_interface to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_driver_release_interface to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_match_one_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_match_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_register_device_driver to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_deregister_device_driver to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_register_driver to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_deregister to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_enable_autosuspend to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_disable_autosuspend to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_autopm_put_interface to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_autopm_put_interface_async to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_autopm_put_interface_no_suspend to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_autopm_get_interface to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_autopm_get_interface_async to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_autopm_get_interface_no_resume to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_register_dev to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_deregister_dev to i8*), i8* bitcast (%struct.kernel_param* @__param_usbfs_snoop to i8*), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__UNIQUE_ID_usbfs_snooptype18, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @__UNIQUE_ID_usbfs_snoop19, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_usbfs_snoop_max to i8*), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__UNIQUE_ID_usbfs_snoop_maxtype20, i32 0, i32 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @__UNIQUE_ID_usbfs_snoop_max21, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_usbfs_memory_mb to i8*), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__UNIQUE_ID_usbfs_memory_mbtype22, i32 0, i32 0), i8* getelementptr inbounds ([73 x i8], [73 x i8]* @__UNIQUE_ID_usbfs_memory_mb23, i32 0, i32 0), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_register_notify to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_unregister_notify to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_choose_configuration to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_of_get_child_node to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_pci_probe to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_pci_remove to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_pci_shutdown to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_pci_pm_ops to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_acpi_power_manageable to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_acpi_set_power_state to i8*)], section "llvm.metadata"
@__param_nousb = internal constant %struct.kernel_param { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_nousb, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bool, i16 292, i8 -1, i8 0, %union.anon.51 { i8* @nousb } }, section "__param", align 8
@__UNIQUE_ID_nousbtype16 = internal constant [20 x i8] c"parmtype=nousb:bool\00", section ".modinfo", align 1
@__ksymtab_usb_disabled = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 ()* @usb_disabled to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_disabled, i32 0, i32 0) }, section "___ksymtab_gpl+usb_disabled", align 8
@__param_autosuspend = internal constant %struct.kernel_param { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.53.658, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 420, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @usb_autosuspend_delay to i8*) } }, section "__param", align 8
@__UNIQUE_ID_autosuspendtype17 = internal constant [25 x i8] c"parmtype=autosuspend:int\00", section ".modinfo", align 1
@__UNIQUE_ID_autosuspend18 = internal constant [43 x i8] c"parm=autosuspend:default autosuspend delay\00", section ".modinfo", align 1
@__ksymtab_usb_find_alt_setting = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_host_interface* (%struct.usb_host_config*, i32, i32)* @usb_find_alt_setting to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_usb_find_alt_setting, i32 0, i32 0) }, section "___ksymtab_gpl+usb_find_alt_setting", align 8
@__ksymtab_usb_ifnum_to_if = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_interface* (%struct.usb_device*, i32)* @usb_ifnum_to_if to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_usb_ifnum_to_if, i32 0, i32 0) }, section "___ksymtab_gpl+usb_ifnum_to_if", align 8
@__ksymtab_usb_altnum_to_altsetting = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_host_interface* (%struct.usb_interface*, i32)* @usb_altnum_to_altsetting to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_altnum_to_altsetting, i32 0, i32 0) }, section "___ksymtab_gpl+usb_altnum_to_altsetting", align 8
@__ksymtab_usb_find_interface = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_interface* (%struct.usb_driver*, i32)* @usb_find_interface to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_find_interface, i32 0, i32 0) }, section "___ksymtab_gpl+usb_find_interface", align 8
@__ksymtab_usb_for_each_dev = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i8*, i32 (%struct.usb_device*, i8*)*)* @usb_for_each_dev to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_for_each_dev, i32 0, i32 0) }, section "___ksymtab_gpl+usb_for_each_dev", align 8
@__ksymtab_usb_alloc_dev = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_device* (%struct.usb_device*, %struct.usb_bus*, i32)* @usb_alloc_dev to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_usb_alloc_dev, i32 0, i32 0) }, section "___ksymtab_gpl+usb_alloc_dev", align 8
@__ksymtab_usb_get_dev = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_device* (%struct.usb_device*)* @usb_get_dev to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_get_dev, i32 0, i32 0) }, section "___ksymtab_gpl+usb_get_dev", align 8
@__ksymtab_usb_put_dev = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*)* @usb_put_dev to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_put_dev, i32 0, i32 0) }, section "___ksymtab_gpl+usb_put_dev", align 8
@__ksymtab_usb_get_intf = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_interface* (%struct.usb_interface*)* @usb_get_intf to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_get_intf, i32 0, i32 0) }, section "___ksymtab_gpl+usb_get_intf", align 8
@__ksymtab_usb_put_intf = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_interface*)* @usb_put_intf to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_put_intf, i32 0, i32 0) }, section "___ksymtab_gpl+usb_put_intf", align 8
@__ksymtab_usb_lock_device_for_reset = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, %struct.usb_interface*)* @usb_lock_device_for_reset to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_usb_lock_device_for_reset, i32 0, i32 0) }, section "___ksymtab_gpl+usb_lock_device_for_reset", align 8
@__ksymtab_usb_get_current_frame_number = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*)* @usb_get_current_frame_number to i64), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__kstrtab_usb_get_current_frame_number, i32 0, i32 0) }, section "___ksymtab_gpl+usb_get_current_frame_number", align 8
@__ksymtab___usb_get_extra_descriptor = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i8*, i32, i8, i8**)* @__usb_get_extra_descriptor to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab___usb_get_extra_descriptor, i32 0, i32 0) }, section "___ksymtab_gpl+__usb_get_extra_descriptor", align 8
@__ksymtab_usb_alloc_coherent = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (%struct.usb_device*, i64, i32, i64*)* @usb_alloc_coherent to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_alloc_coherent, i32 0, i32 0) }, section "___ksymtab_gpl+usb_alloc_coherent", align 8
@__ksymtab_usb_free_coherent = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*, i64, i8*, i64)* @usb_free_coherent to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_usb_free_coherent, i32 0, i32 0) }, section "___ksymtab_gpl+usb_free_coherent", align 8
@__ksymtab_usb_debug_root = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.dentry** @usb_debug_root to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_debug_root, i32 0, i32 0) }, section "___ksymtab_gpl+usb_debug_root", align 8
@__UNIQUE_ID_license19 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__kstrtab_usb_debug_root = internal constant [15 x i8] c"usb_debug_root\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_free_coherent = internal constant [18 x i8] c"usb_free_coherent\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_alloc_coherent = internal constant [19 x i8] c"usb_alloc_coherent\00", section "__ksymtab_strings", align 1
@__kstrtab___usb_get_extra_descriptor = internal constant [27 x i8] c"__usb_get_extra_descriptor\00", section "__ksymtab_strings", align 1
@.str.7 = private unnamed_addr constant [43 x i8] c"\013%s: bogus descriptor, type %d length %d\0A\00", align 1
@__kstrtab_usb_get_current_frame_number = internal constant [29 x i8] c"usb_get_current_frame_number\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_lock_device_for_reset = internal constant [26 x i8] c"usb_lock_device_for_reset\00", section "__ksymtab_strings", align 1
@jiffies = external global i64, align 8
@__kstrtab_usb_put_intf = internal constant [13 x i8] c"usb_put_intf\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_get_intf = internal constant [13 x i8] c"usb_get_intf\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_put_dev = internal constant [12 x i8] c"usb_put_dev\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_get_dev = internal constant [12 x i8] c"usb_get_dev\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_alloc_dev = internal constant [14 x i8] c"usb_alloc_dev\00", section "__ksymtab_strings", align 1
@.str.3 = private unnamed_addr constant [6 x i8] c"usb%d\00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"%s.%d\00", align 1
@.str.6 = private unnamed_addr constant [6 x i8] c"%d-%s\00", align 1
@usb_autosuspend_delay = internal global i32 2, align 4
@__kstrtab_usb_for_each_dev = internal constant [17 x i8] c"usb_for_each_dev\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_find_interface = internal constant [19 x i8] c"usb_find_interface\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_altnum_to_altsetting = internal constant [25 x i8] c"usb_altnum_to_altsetting\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_ifnum_to_if = internal constant [16 x i8] c"usb_ifnum_to_if\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_find_alt_setting = internal constant [21 x i8] c"usb_find_alt_setting\00", section "__ksymtab_strings", align 1
@.str.1 = private unnamed_addr constant [54 x i8] c"\017Did not find alt setting %u for intf %u, config %u\0A\00", align 1
@__this_module = external global %struct.module, align 64
@param_ops_int = external constant %struct.kernel_param_ops, align 8
@__kstrtab_usb_disabled = internal constant [13 x i8] c"usb_disabled\00", section "__ksymtab_strings", align 1
@nousb = internal global i8 0, align 1
@__param_str_nousb = internal constant [6 x i8] c"nousb\00", align 1
@param_ops_bool = external constant %struct.kernel_param_ops, align 8
@.str.11 = private unnamed_addr constant [28 x i8] c"\016%s: USB support disabled\0A\00", align 1
@usb_bus_nb = internal global %struct.notifier_block { i32 (%struct.notifier_block*, i64, i8*)* @usb_bus_notify, %struct.notifier_block* null, i32 0 }, align 8
@usb_debug_devices = internal global %struct.dentry* null, align 8
@.str.13 = private unnamed_addr constant [8 x i8] c"devices\00", align 1
@usb_port_peer_mutex = global %struct.mutex { %union.anon.3 zeroinitializer, %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.14, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.qspinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usb_port_peer_mutex to i8*), i64 88) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usb_port_peer_mutex to i8*), i64 88) to %struct.list_head*) }, i8* bitcast (%struct.mutex* @usb_port_peer_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.1.15, i32 0, i32 0), i32 0, i64 0 } }, align 8
@.str.14 = private unnamed_addr constant [30 x i8] c"usb_port_peer_mutex.wait_lock\00", align 1
@.str.1.15 = private unnamed_addr constant [20 x i8] c"usb_port_peer_mutex\00", align 1
@ehci_cf_port_reset_rwsem = global %struct.rw_semaphore { %union.anon.3 zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rw_semaphore* @ehci_cf_port_reset_rwsem to i8*), i64 8) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rw_semaphore* @ehci_cf_port_reset_rwsem to i8*), i64 8) to %struct.list_head*) }, %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.2.16, i32 0, i32 0), i32 0, i64 0 } }, %struct.qspinlock zeroinitializer, %struct.task_struct* null, %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.3.17, i32 0, i32 0), i32 0, i64 0 } }, align 8
@.str.2.16 = private unnamed_addr constant [35 x i8] c"ehci_cf_port_reset_rwsem.wait_lock\00", align 1
@.str.3.17 = private unnamed_addr constant [25 x i8] c"ehci_cf_port_reset_rwsem\00", align 1
@__param_blinkenlights = internal constant %struct.kernel_param { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__param_str_blinkenlights, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bool, i16 292, i8 -1, i8 0, %union.anon.51 { i8* @blinkenlights } }, section "__param", align 8
@__UNIQUE_ID_blinkenlightstype16 = internal constant [28 x i8] c"parmtype=blinkenlights:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_blinkenlights17 = internal constant [46 x i8] c"parm=blinkenlights:true to cycle leds on hubs\00", section ".modinfo", align 1
@__param_initial_descriptor_timeout = internal constant %struct.kernel_param { i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__param_str_initial_descriptor_timeout, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 420, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @initial_descriptor_timeout to i8*) } }, section "__param", align 8
@__UNIQUE_ID_initial_descriptor_timeouttype18 = internal constant [40 x i8] c"parmtype=initial_descriptor_timeout:int\00", section ".modinfo", align 1
@__UNIQUE_ID_initial_descriptor_timeout19 = internal constant [120 x i8] c"parm=initial_descriptor_timeout:initial 64-byte descriptor request timeout in milliseconds (default 5000 - 5.0 seconds)\00", section ".modinfo", align 1
@__param_old_scheme_first = internal constant %struct.kernel_param { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__param_str_old_scheme_first, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bool, i16 420, i8 -1, i8 0, %union.anon.51 { i8* @old_scheme_first } }, section "__param", align 8
@__UNIQUE_ID_old_scheme_firsttype20 = internal constant [31 x i8] c"parmtype=old_scheme_first:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_old_scheme_first21 = internal constant [70 x i8] c"parm=old_scheme_first:start with the old device initialization scheme\00", section ".modinfo", align 1
@__param_use_both_schemes = internal constant %struct.kernel_param { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__param_str_use_both_schemes, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bool, i16 420, i8 -1, i8 0, %union.anon.51 { i8* @use_both_schemes } }, section "__param", align 8
@__UNIQUE_ID_use_both_schemestype22 = internal constant [31 x i8] c"parmtype=use_both_schemes:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_use_both_schemes23 = internal constant [88 x i8] c"parm=use_both_schemes:try the other device initialization scheme if the first one fails\00", section ".modinfo", align 1
@__ksymtab_ehci_cf_port_reset_rwsem = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rw_semaphore* @ehci_cf_port_reset_rwsem to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_ehci_cf_port_reset_rwsem, i32 0, i32 0) }, section "___ksymtab_gpl+ehci_cf_port_reset_rwsem", align 8
@__ksymtab_usb_wakeup_notification = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*, i32)* @usb_wakeup_notification to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_wakeup_notification, i32 0, i32 0) }, section "___ksymtab_gpl+usb_wakeup_notification", align 8
@__ksymtab_usb_hub_clear_tt_buffer = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.urb*)* @usb_hub_clear_tt_buffer to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_hub_clear_tt_buffer, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hub_clear_tt_buffer", align 8
@__ksymtab_usb_hub_claim_port = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32, %struct.usb_dev_state*)* @usb_hub_claim_port to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_hub_claim_port, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hub_claim_port", align 8
@__ksymtab_usb_hub_release_port = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32, %struct.usb_dev_state*)* @usb_hub_release_port to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_usb_hub_release_port, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hub_release_port", align 8
@__ksymtab_usb_set_device_state = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*, i32)* @usb_set_device_state to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_usb_set_device_state, i32 0, i32 0) }, section "___ksymtab_gpl+usb_set_device_state", align 8
@__ksymtab_usb_disable_ltm = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*)* @usb_disable_ltm to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_usb_disable_ltm, i32 0, i32 0) }, section "___ksymtab_gpl+usb_disable_ltm", align 8
@__ksymtab_usb_enable_ltm = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*)* @usb_enable_ltm to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_enable_ltm, i32 0, i32 0) }, section "___ksymtab_gpl+usb_enable_ltm", align 8
@__ksymtab_usb_root_hub_lost_power = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*)* @usb_root_hub_lost_power to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_root_hub_lost_power, i32 0, i32 0) }, section "___ksymtab_gpl+usb_root_hub_lost_power", align 8
@__ksymtab_usb_disable_lpm = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*)* @usb_disable_lpm to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_usb_disable_lpm, i32 0, i32 0) }, section "___ksymtab_gpl+usb_disable_lpm", align 8
@__ksymtab_usb_unlocked_disable_lpm = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*)* @usb_unlocked_disable_lpm to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_unlocked_disable_lpm, i32 0, i32 0) }, section "___ksymtab_gpl+usb_unlocked_disable_lpm", align 8
@__ksymtab_usb_enable_lpm = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*)* @usb_enable_lpm to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_enable_lpm, i32 0, i32 0) }, section "___ksymtab_gpl+usb_enable_lpm", align 8
@__ksymtab_usb_unlocked_enable_lpm = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*)* @usb_unlocked_enable_lpm to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_unlocked_enable_lpm, i32 0, i32 0) }, section "___ksymtab_gpl+usb_unlocked_enable_lpm", align 8
@__ksymtab_usb_ep0_reinit = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*)* @usb_ep0_reinit to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_ep0_reinit, i32 0, i32 0) }, section "___ksymtab_gpl+usb_ep0_reinit", align 8
@__ksymtab_usb_reset_device = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*)* @usb_reset_device to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_reset_device, i32 0, i32 0) }, section "___ksymtab_gpl+usb_reset_device", align 8
@__ksymtab_usb_queue_reset_device = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_interface*)* @usb_queue_reset_device to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_usb_queue_reset_device, i32 0, i32 0) }, section "___ksymtab_gpl+usb_queue_reset_device", align 8
@__ksymtab_usb_hub_find_child = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_device* (%struct.usb_device*, i32)* @usb_hub_find_child to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_hub_find_child, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hub_find_child", align 8
@__kstrtab_usb_hub_find_child = internal constant [19 x i8] c"usb_hub_find_child\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_queue_reset_device = internal constant [23 x i8] c"usb_queue_reset_device\00", section "__ksymtab_strings", align 1
@system_wq = external global %struct.workqueue_struct*, align 8
@__kstrtab_usb_reset_device = internal constant [17 x i8] c"usb_reset_device\00", section "__ksymtab_strings", align 1
@usb_reset_device.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.usb_reset_device, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.42, i32 0, i32 0), i8 -54, i8 21, i8 0, i8 0 }, section "__verbose", align 8
@.str.42 = private unnamed_addr constant [38 x i8] c"device reset not allowed in state %d\0A\00", align 1
@usb_reset_device.descriptor.43 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.usb_reset_device, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.44, i32 0, i32 0), i8 -48, i8 21, i8 0, i8 0 }, section "__verbose", align 8
@.str.44 = private unnamed_addr constant [18 x i8] c"%s for root hub!\0A\00", align 1
@__func__.usb_reset_device = private unnamed_addr constant [17 x i8] c"usb_reset_device\00", align 1
@current_task = external global %struct.task_struct*, align 8
@usb_reset_and_verify_device.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.usb_reset_and_verify_device, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.42, i32 0, i32 0), i8 30, i8 21, i8 0, i8 0 }, section "__verbose", align 8
@__func__.usb_reset_and_verify_device = private unnamed_addr constant [28 x i8] c"usb_reset_and_verify_device\00", align 1
@.str.262 = private unnamed_addr constant [27 x i8] c"%s Failed to disable LTM\0A.\00", align 1
@use_both_schemes = internal global i8 1, align 1
@.str.263 = private unnamed_addr constant [25 x i8] c"device firmware changed\0A\00", align 1
@.str.264 = private unnamed_addr constant [61 x i8] c"Busted HC?  Not enough HCD resources for old configuration.\0A\00", align 1
@.str.265 = private unnamed_addr constant [44 x i8] c"can't restore configuration #%d (error=%d)\0A\00", align 1
@.str.266 = private unnamed_addr constant [57 x i8] c"failed to restore interface %d altsetting %d (error=%d)\0A\00", align 1
@hub_port_logical_disconnect.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.hub_port_logical_disconnect, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.48, i32 0, i32 0), i8 -113, i8 3, i8 0, i8 0 }, section "__verbose", align 8
@.str.48 = private unnamed_addr constant [20 x i8] c"logical disconnect\0A\00", align 1
@hub_wq = internal global %struct.workqueue_struct* null, align 8
@.str.49 = private unnamed_addr constant [27 x i8] c"cannot disable (err = %d)\0A\00", align 1
@.str.50 = private unnamed_addr constant [41 x i8] c"Port disable: can't disable remote wake\0A\00", align 1
@__func__.hub_port_logical_disconnect = private unnamed_addr constant [28 x i8] c"hub_port_logical_disconnect\00", align 1
@.str.10.21 = private unnamed_addr constant [23 x i8] c"drivers/usb/core/hub.c\00", align 1
@usb3_lpm_names = internal constant [4 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.89, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.90, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.91, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.92, i32 0, i32 0)], align 16
@.str.93 = private unnamed_addr constant [41 x i8] c"Set SEL for device-initiated %s failed.\0A\00", align 1
@.str.94 = private unnamed_addr constant [48 x i8] c"Could not enable %s link state, xHCI error %i.\0A\00", align 1
@.str.83 = private unnamed_addr constant [7 x i8] c"enable\00", align 1
@.str.84 = private unnamed_addr constant [8 x i8] c"disable\00", align 1
@.str.82 = private unnamed_addr constant [34 x i8] c"%s: Can't %s non-U1 or U2 state.\0A\00", align 1
@__func__.usb_set_device_initiated_lpm = private unnamed_addr constant [29 x i8] c"usb_set_device_initiated_lpm\00", align 1
@usb_set_device_initiated_lpm.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__func__.usb_set_device_initiated_lpm, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.85, i32 0, i32 0), i8 -94, i8 14, i8 0, i8 0 }, section "__verbose", align 8
@.str.85 = private unnamed_addr constant [48 x i8] c"%s: Can't %s %s state for unconfigured device.\0A\00", align 1
@.str.87 = private unnamed_addr constant [7 x i8] c"Enable\00", align 1
@.str.88 = private unnamed_addr constant [8 x i8] c"Disable\00", align 1
@.str.86 = private unnamed_addr constant [35 x i8] c"%s of device-initiated %s failed.\0A\00", align 1
@.str.79 = private unnamed_addr constant [47 x i8] c"%s: Can't set timeout for non-U1 or U2 state.\0A\00", align 1
@__func__.usb_set_lpm_timeout = private unnamed_addr constant [20 x i8] c"usb_set_lpm_timeout\00", align 1
@.str.80 = private unnamed_addr constant [62 x i8] c"Failed to set %s timeout to 0x%x, which is a reserved value.\0A\00", align 1
@.str.81 = private unnamed_addr constant [48 x i8] c"Failed to set %s timeout to 0x%x,error code %i\0A\00", align 1
@.str.89 = private unnamed_addr constant [3 x i8] c"U0\00", align 1
@.str.90 = private unnamed_addr constant [3 x i8] c"U1\00", align 1
@.str.91 = private unnamed_addr constant [3 x i8] c"U2\00", align 1
@.str.92 = private unnamed_addr constant [3 x i8] c"U3\00", align 1
@usb_req_set_sel.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usb_req_set_sel, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.95, i32 0, i32 0), i8 91, i8 14, i8 0, i8 0 }, section "__verbose", align 8
@.str.95 = private unnamed_addr constant [69 x i8] c"Device-initiated %s disabled due to long SEL %llu us or PEL %llu us\0A\00", align 1
@__func__.usb_req_set_sel = private unnamed_addr constant [16 x i8] c"usb_req_set_sel\00", align 1
@device_state_lock = internal global %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.51, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@.str.51 = private unnamed_addr constant [18 x i8] c"device_state_lock\00", align 1
@descriptors_changed.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.descriptors_changed, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.267, i32 0, i32 0), i8 -49, i8 20, i8 0, i8 0 }, section "__verbose", align 8
@.str.267 = private unnamed_addr constant [27 x i8] c"config index %d, error %d\0A\00", align 1
@descriptors_changed.descriptor.268 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.descriptors_changed, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.269, i32 0, i32 0), i8 -40, i8 20, i8 0, i8 0 }, section "__verbose", align 8
@.str.269 = private unnamed_addr constant [31 x i8] c"config index %d changed (#%d)\0A\00", align 1
@descriptors_changed.descriptor.270 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.descriptors_changed, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.271, i32 0, i32 0), i8 -29, i8 20, i8 0, i8 0 }, section "__verbose", align 8
@.str.271 = private unnamed_addr constant [24 x i8] c"serial string error %d\0A\00", align 1
@descriptors_changed.descriptor.272 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.descriptors_changed, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.273, i32 0, i32 0), i8 -26, i8 20, i8 0, i8 0 }, section "__verbose", align 8
@.str.273 = private unnamed_addr constant [23 x i8] c"serial string changed\0A\00", align 1
@__func__.descriptors_changed = private unnamed_addr constant [20 x i8] c"descriptors_changed\00", align 1
@hub_port_init.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_port_init, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.165, i32 0, i32 0), i8 3, i8 17, i8 0, i8 0 }, section "__verbose", align 8
@.str.165 = private unnamed_addr constant [29 x i8] c"device reset changed speed!\0A\00", align 1
@.str.166 = private unnamed_addr constant [24 x i8] c"variable speed Wireless\00", align 1
@.str.168 = private unnamed_addr constant [6 x i8] c"reset\00", align 1
@.str.169 = private unnamed_addr constant [4 x i8] c"new\00", align 1
@.str.167 = private unnamed_addr constant [37 x i8] c"%s %s USB device number %d using %s\0A\00", align 1
@.str.170 = private unnamed_addr constant [22 x i8] c"parent hub has no TT\0A\00", align 1
@.str.171 = private unnamed_addr constant [39 x i8] c"hub failed to enable device, error %d\0A\00", align 1
@initial_descriptor_timeout = internal global i32 5000, align 4
@hub_port_init.descriptor.172 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_port_init, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.165, i32 0, i32 0), i8 -117, i8 17, i8 0, i8 0 }, section "__verbose", align 8
@.str.173 = private unnamed_addr constant [37 x i8] c"device descriptor read/64, error %d\0A\00", align 1
@.str.174 = private unnamed_addr constant [43 x i8] c"device not accepting address %d, error %d\0A\00", align 1
@.str.176 = private unnamed_addr constant [5 x i8] c"Plus\00", align 1
@.str.175 = private unnamed_addr constant [47 x i8] c"%s SuperSpeed%s USB device number %d using %s\0A\00", align 1
@.str.177 = private unnamed_addr constant [36 x i8] c"device descriptor read/8, error %d\0A\00", align 1
@.str.178 = private unnamed_addr constant [50 x i8] c"got a wrong device descriptor, warm reset device\0A\00", align 1
@.str.179 = private unnamed_addr constant [27 x i8] c"Invalid ep0 maxpacket: %d\0A\00", align 1
@hub_port_init.descriptor.180 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_port_init, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.181, i32 0, i32 0), i8 -18, i8 17, i8 0, i8 0 }, section "__verbose", align 8
@.str.181 = private unnamed_addr constant [20 x i8] c"ep0 maxpacket = %d\0A\00", align 1
@.str.182 = private unnamed_addr constant [25 x i8] c"Using ep0 maxpacket: %d\0A\00", align 1
@.str.183 = private unnamed_addr constant [38 x i8] c"device descriptor read/all, error %d\0A\00", align 1
@.str.4.23 = private unnamed_addr constant [48 x i8] c"No LPM exit latency info found, disabling LPM.\0A\00", align 1
@.str.5.24 = private unnamed_addr constant [44 x i8] c"LPM exit latency is zeroed, disabling LPM.\0A\00", align 1
@.str.6.25 = private unnamed_addr constant [68 x i8] c"We don't know the algorithms for LPM for this host, disabling LPM.\0A\00", align 1
@__func__.hub_port_init = private unnamed_addr constant [14 x i8] c"hub_port_init\00", align 1
@old_scheme_first = internal global i8 0, align 1
@.str.142 = private unnamed_addr constant [34 x i8] c"only USB3 hub support warm reset\0A\00", align 1
@.str.144 = private unnamed_addr constant [6 x i8] c"warm \00", align 1
@.str.143 = private unnamed_addr constant [27 x i8] c"cannot %sreset (err = %d)\0A\00", align 1
@hub_port_reset.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.hub_port_reset, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.145, i32 0, i32 0), i8 -53, i8 10, i8 0, i8 0 }, section "__verbose", align 8
@.str.145 = private unnamed_addr constant [27 x i8] c"port_wait_reset: err = %d\0A\00", align 1
@hub_port_reset.descriptor.146 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.hub_port_reset, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.147, i32 0, i32 0), i8 -17, i8 10, i8 0, i8 0 }, section "__verbose", align 8
@.str.147 = private unnamed_addr constant [30 x i8] c"hot reset failed, warm reset\0A\00", align 1
@hub_port_reset.descriptor.148 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.hub_port_reset, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.149, i32 0, i32 0), i8 -10, i8 10, i8 0, i8 0 }, section "__verbose", align 8
@.str.149 = private unnamed_addr constant [38 x i8] c"not enabled, trying %sreset again...\0A\00", align 1
@.str.150 = private unnamed_addr constant [44 x i8] c"Cannot enable. Maybe the USB cable is bad?\0A\00", align 1
@__func__.hub_port_reset = private unnamed_addr constant [15 x i8] c"hub_port_reset\00", align 1
@hub_port_wait_reset.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.hub_port_wait_reset, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.151, i32 0, i32 0), i8 112, i8 10, i8 0, i8 0 }, section "__verbose", align 8
@.str.151 = private unnamed_addr constant [31 x i8] c"not %sreset yet, waiting %dms\0A\00", align 1
@__func__.hub_port_wait_reset = private unnamed_addr constant [20 x i8] c"hub_port_wait_reset\00", align 1
@.str.65 = private unnamed_addr constant [22 x i8] c"%s failed (err = %d)\0A\00", align 1
@__func__.hub_ext_port_status = private unnamed_addr constant [20 x i8] c"hub_ext_port_status\00", align 1
@.str.77 = private unnamed_addr constant [39 x i8] c"%s: Can't disable non-U1 or U2 state.\0A\00", align 1
@__func__.usb_disable_link_state = private unnamed_addr constant [23 x i8] c"usb_disable_link_state\00", align 1
@.str.78 = private unnamed_addr constant [76 x i8] c"Could not disable xHCI %s timeout, bus schedule bandwidth may be impacted.\0A\00", align 1
@__kstrtab_usb_ep0_reinit = internal constant [15 x i8] c"usb_ep0_reinit\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_unlocked_enable_lpm = internal constant [24 x i8] c"usb_unlocked_enable_lpm\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_enable_lpm = internal constant [15 x i8] c"usb_enable_lpm\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_unlocked_disable_lpm = internal constant [25 x i8] c"usb_unlocked_disable_lpm\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_disable_lpm = internal constant [16 x i8] c"usb_disable_lpm\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_root_hub_lost_power = internal constant [24 x i8] c"usb_root_hub_lost_power\00", section "__ksymtab_strings", align 1
@.str.36 = private unnamed_addr constant [34 x i8] c"root hub lost power or was reset\0A\00", align 1
@__kstrtab_usb_enable_ltm = internal constant [15 x i8] c"usb_enable_ltm\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_disable_ltm = internal constant [16 x i8] c"usb_disable_ltm\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_set_device_state = internal constant [21 x i8] c"usb_set_device_state\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hub_release_port = internal constant [21 x i8] c"usb_hub_release_port\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hub_claim_port = internal constant [19 x i8] c"usb_hub_claim_port\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hub_clear_tt_buffer = internal constant [24 x i8] c"usb_hub_clear_tt_buffer\00", section "__ksymtab_strings", align 1
@.str.7.26 = private unnamed_addr constant [34 x i8] c"can't save CLEAR_TT_BUFFER state\0A\00", align 1
@__kstrtab_usb_wakeup_notification = internal constant [24 x i8] c"usb_wakeup_notification\00", section "__ksymtab_strings", align 1
@__kstrtab_ehci_cf_port_reset_rwsem = internal constant [25 x i8] c"ehci_cf_port_reset_rwsem\00", section "__ksymtab_strings", align 1
@__param_str_use_both_schemes = internal constant [17 x i8] c"use_both_schemes\00", align 16
@__param_str_old_scheme_first = internal constant [17 x i8] c"old_scheme_first\00", align 16
@__param_str_initial_descriptor_timeout = internal constant [27 x i8] c"initial_descriptor_timeout\00", align 16
@__param_str_blinkenlights = internal constant [14 x i8] c"blinkenlights\00", align 1
@blinkenlights = internal global i8 0, align 1
@.str.8.28 = private unnamed_addr constant [34 x i8] c"USB disconnect, device number %d\0A\00", align 1
@usb_disconnect.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.usb_disconnect, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.11.29, i32 0, i32 0), i8 47, i8 8, i8 0, i8 0 }, section "__verbose", align 8
@.str.11.29 = private unnamed_addr constant [22 x i8] c"unregistering device\0A\00", align 1
@.str.12.30 = private unnamed_addr constant [5 x i8] c"port\00", align 1
@.str.13.31 = private unnamed_addr constant [7 x i8] c"device\00", align 1
@__func__.usb_disconnect = private unnamed_addr constant [15 x i8] c"usb_disconnect\00", align 1
@usb_new_device.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.usb_new_device, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.14.32, i32 0, i32 0), i8 99, i8 9, i8 0, i8 0 }, section "__verbose", align 8
@.str.14.32 = private unnamed_addr constant [32 x i8] c"udev %d, busnum %d, minor = %d\0A\00", align 1
@.str.15 = private unnamed_addr constant [28 x i8] c"can't device_add, error %d\0A\00", align 1
@.str.59 = private unnamed_addr constant [53 x i8] c"New USB device found, idVendor=%04x, idProduct=%04x\0A\00", align 1
@.str.60 = private unnamed_addr constant [61 x i8] c"New USB device strings: Mfr=%d, Product=%d, SerialNumber=%d\0A\00", align 1
@.str.61 = private unnamed_addr constant [8 x i8] c"Product\00", align 1
@.str.62 = private unnamed_addr constant [13 x i8] c"Manufacturer\00", align 1
@.str.63 = private unnamed_addr constant [13 x i8] c"SerialNumber\00", align 1
@.str.64 = private unnamed_addr constant [8 x i8] c"%s: %s\0A\00", align 1
@__func__.usb_new_device = private unnamed_addr constant [15 x i8] c"usb_new_device\00", align 1
@.str.52 = private unnamed_addr constant [37 x i8] c"can't read configurations, error %d\0A\00", align 1
@usb_enumerate_device.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__func__.usb_enumerate_device, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.53, i32 0, i32 0), i8 -14, i8 8, i8 0, i8 0 }, section "__verbose", align 8
@.str.53 = private unnamed_addr constant [14 x i8] c"HNP fail, %d\0A\00", align 1
@__func__.usb_enumerate_device = private unnamed_addr constant [21 x i8] c"usb_enumerate_device\00", align 1
@usb_port_suspend.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.usb_port_suspend, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.20, i32 0, i32 0), i8 45, i8 12, i8 0, i8 0 }, section "__verbose", align 8
@.str.20 = private unnamed_addr constant [32 x i8] c"won't remote wakeup, status %d\0A\00", align 1
@.str.21 = private unnamed_addr constant [39 x i8] c"Failed to disable LTM before suspend\0A.\00", align 1
@.str.22 = private unnamed_addr constant [39 x i8] c"Failed to disable LPM before suspend\0A.\00", align 1
@usb_port_suspend.descriptor.23 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.usb_port_suspend, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.24, i32 0, i32 0), i8 92, i8 12, i8 0, i8 0 }, section "__verbose", align 8
@.str.24 = private unnamed_addr constant [26 x i8] c"can't suspend, status %d\0A\00", align 1
@usb_port_suspend.descriptor.25 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.usb_port_suspend, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.26, i32 0, i32 0), i8 113, i8 12, i8 0, i8 0 }, section "__verbose", align 8
@.str.26 = private unnamed_addr constant [26 x i8] c"usb %ssuspend, wakeup %d\0A\00", align 1
@__func__.usb_port_suspend = private unnamed_addr constant [17 x i8] c"usb_port_suspend\00", align 1
@whitelist_table = internal global [4 x %struct.usb_device_id] [%struct.usb_device_id { i16 112, i16 0, i16 0, i16 0, i16 0, i8 9, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 0 }, %struct.usb_device_id { i16 112, i16 0, i16 0, i16 0, i16 0, i8 9, i8 0, i8 1, i8 0, i8 0, i8 0, i8 0, i64 0 }, %struct.usb_device_id { i16 3, i16 1317, i16 -23392, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 0 }, %struct.usb_device_id zeroinitializer], align 16
@.str.58 = private unnamed_addr constant [37 x i8] c"device v%04x p%04x is not supported\0A\00", align 1
@.str.55 = private unnamed_addr constant [5 x i8] c"non-\00", align 1
@.str.54 = private unnamed_addr constant [36 x i8] c"Dual-Role OTG device on %sHNP port\0A\00", align 1
@.str.56 = private unnamed_addr constant [24 x i8] c"can't set HNP mode: %d\0A\00", align 1
@.str.57 = private unnamed_addr constant [34 x i8] c"set a_alt_hnp_support failed: %d\0A\00", align 1
@.str.16 = private unnamed_addr constant [40 x i8] c"can't autoresume for authorization: %d\0A\00", align 1
@.str.17 = private unnamed_addr constant [55 x i8] c"can't re-read device descriptor for authorization: %d\0A\00", align 1
@.str.19 = private unnamed_addr constant [23 x i8] c"authorized to connect\0A\00", align 1
@usb_port_resume.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usb_port_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.29, i32 0, i32 0), i8 58, i8 13, i8 0, i8 0 }, section "__verbose", align 8
@.str.29 = private unnamed_addr constant [34 x i8] c"can't resume usb port, status %d\0A\00", align 1
@usb_port_resume.descriptor.30 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usb_port_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.31, i32 0, i32 0), i8 77, i8 13, i8 0, i8 0 }, section "__verbose", align 8
@.str.31 = private unnamed_addr constant [25 x i8] c"can't resume, status %d\0A\00", align 1
@usb_port_resume.descriptor.32 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usb_port_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.24.148, i32 0, i32 0), i8 81, i8 13, i8 0, i8 0 }, section "__verbose", align 8
@usb_port_resume.descriptor.34 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usb_port_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.31, i32 0, i32 0), i8 117, i8 13, i8 0, i8 0 }, section "__verbose", align 8
@__func__.usb_port_resume = private unnamed_addr constant [16 x i8] c"usb_port_resume\00", align 1
@finish_port_resume.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.finish_port_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12.957, i32 0, i32 0), i8 -105, i8 12, i8 0, i8 0 }, section "__verbose", align 8
@.str.69 = private unnamed_addr constant [20 x i8] c"finish reset-resume\00", align 1
@.str.70 = private unnamed_addr constant [14 x i8] c"finish resume\00", align 1
@finish_port_resume.descriptor.71 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.finish_port_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.72, i32 0, i32 0), i8 -65, i8 12, i8 0, i8 0 }, section "__verbose", align 8
@.str.72 = private unnamed_addr constant [25 x i8] c"retry with reset-resume\0A\00", align 1
@finish_port_resume.descriptor.73 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.finish_port_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.74, i32 0, i32 0), i8 -57, i8 12, i8 0, i8 0 }, section "__verbose", align 8
@.str.74 = private unnamed_addr constant [34 x i8] c"gone after usb resume? status %d\0A\00", align 1
@finish_port_resume.descriptor.75 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.finish_port_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.76, i32 0, i32 0), i8 -35, i8 12, i8 0, i8 0 }, section "__verbose", align 8
@.str.76 = private unnamed_addr constant [34 x i8] c"disable remote wakeup, status %d\0A\00", align 1
@__func__.finish_port_resume = private unnamed_addr constant [19 x i8] c"finish_port_resume\00", align 1
@check_port_resume_type.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.check_port_resume_type, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.67, i32 0, i32 0), i8 115, i8 11, i8 0, i8 0 }, section "__verbose", align 8
@.str.67 = private unnamed_addr constant [35 x i8] c"status %04x.%04x after resume, %d\0A\00", align 1
@__func__.check_port_resume_type = private unnamed_addr constant [23 x i8] c"check_port_resume_type\00", align 1
@wait_for_connected.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.wait_for_connected, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.66, i32 0, i32 0), i8 8, i8 13, i8 0, i8 0 }, section "__verbose", align 8
@.str.66 = private unnamed_addr constant [25 x i8] c"Waited %dms for CONNECT\0A\00", align 1
@__func__.wait_for_connected = private unnamed_addr constant [19 x i8] c"wait_for_connected\00", align 1
@usb_remote_wakeup.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.usb_remote_wakeup, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.24.148, i32 0, i32 0), i8 -116, i8 13, i8 0, i8 0 }, section "__verbose", align 8
@.str.35 = private unnamed_addr constant [8 x i8] c"wakeup-\00", align 1
@__func__.usb_remote_wakeup = private unnamed_addr constant [18 x i8] c"usb_remote_wakeup\00", align 1
@hub_port_debounce.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.hub_port_debounce, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.37, i32 0, i32 0), i8 120, i8 16, i8 0, i8 0 }, section "__verbose", align 8
@.str.37 = private unnamed_addr constant [45 x i8] c"debounce total %dms stable %dms status 0x%x\0A\00", align 1
@__func__.hub_port_debounce = private unnamed_addr constant [18 x i8] c"hub_port_debounce\00", align 1
@hub_driver = internal global %struct.usb_driver { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17.909, i32 0, i32 0), i32 (%struct.usb_interface*, %struct.usb_device_id*)* @hub_probe, void (%struct.usb_interface*)* @hub_disconnect, i32 (%struct.usb_interface*, i32, i8*)* @hub_ioctl, i32 (%struct.usb_interface*, i32)* @hub_suspend, i32 (%struct.usb_interface*)* @hub_resume, i32 (%struct.usb_interface*)* @hub_reset_resume, i32 (%struct.usb_interface*)* @hub_pre_reset, i32 (%struct.usb_interface*)* @hub_post_reset, %struct.usb_device_id* getelementptr inbounds ([4 x %struct.usb_device_id], [4 x %struct.usb_device_id]* @hub_id_table, i32 0, i32 0), %struct.__wait_queue_head zeroinitializer, %struct.usbdrv_wrap zeroinitializer, i8 2 }, align 8
@.str.38 = private unnamed_addr constant [33 x i8] c"\013%s: can't register hub driver\0A\00", align 1
@.str.40 = private unnamed_addr constant [11 x i8] c"usb_hub_wq\00", align 1
@usb_hub_init.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.39 = private unnamed_addr constant [13 x i8] c"\22usb_hub_wq\22\00", align 1
@.str.41 = private unnamed_addr constant [44 x i8] c"\013%s: can't allocate workqueue for usb hub\0A\00", align 1
@hub_id_table = internal constant [4 x %struct.usb_device_id] [%struct.usb_device_id { i16 129, i16 1507, i16 0, i16 0, i16 0, i8 0, i8 0, i8 0, i8 9, i8 0, i8 0, i8 0, i64 1 }, %struct.usb_device_id { i16 16, i16 0, i16 0, i16 0, i16 0, i8 9, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 0 }, %struct.usb_device_id { i16 128, i16 0, i16 0, i16 0, i16 0, i8 0, i8 0, i8 0, i8 9, i8 0, i8 0, i8 0, i64 0 }, %struct.usb_device_id zeroinitializer], align 16
@.str.252 = private unnamed_addr constant [22 x i8] c"set hub depth failed\0A\00", align 1
@.str.105 = private unnamed_addr constant [27 x i8] c"(&(&hub->init_work)->work)\00", align 1
@hub_activate.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.107 = private unnamed_addr constant [28 x i8] c"(&(&hub->init_work)->timer)\00", align 1
@hub_activate.__key.253 = internal global %struct.lock_class_key zeroinitializer, align 1
@system_power_efficient_wq = external global %struct.workqueue_struct*, align 8
@.str.254 = private unnamed_addr constant [37 x i8] c"Host not accepting hub info update.\0A\00", align 1
@.str.255 = private unnamed_addr constant [53 x i8] c"LS/FS devices and hubs may not work under this hub\0A.\00", align 1
@hub_activate.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__func__.hub_activate, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.256, i32 0, i32 0), i8 47, i8 4, i8 0, i8 0 }, section "__verbose", align 8
@.str.256 = private unnamed_addr constant [25 x i8] c"status %04x change %04x\0A\00", align 1
@hub_activate.__key.257 = internal global %struct.lock_class_key zeroinitializer, align 1
@hub_activate.__key.258 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.259 = private unnamed_addr constant [17 x i8] c"activate --> %d\0A\00", align 1
@__func__.hub_activate = private unnamed_addr constant [13 x i8] c"hub_activate\00", align 1
@hub_power_on.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__func__.hub_power_on, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.187, i32 0, i32 0), i8 94, i8 3, i8 0, i8 0 }, section "__verbose", align 8
@.str.187 = private unnamed_addr constant [29 x i8] c"enabling power on all ports\0A\00", align 1
@hub_power_on.descriptor.188 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__func__.hub_power_on, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.189, i32 0, i32 0), i8 97, i8 3, i8 0, i8 0 }, section "__verbose", align 8
@.str.189 = private unnamed_addr constant [51 x i8] c"trying to enable port power on non-switchable hub\0A\00", align 1
@__func__.hub_power_on = private unnamed_addr constant [13 x i8] c"hub_power_on\00", align 1
@hub_reset_resume.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.hub_reset_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12.957, i32 0, i32 0), i8 19, i8 14, i8 0, i8 0 }, section "__verbose", align 8
@__func__.hub_reset_resume = private unnamed_addr constant [17 x i8] c"hub_reset_resume\00", align 1
@hub_resume.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.hub_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12.957, i32 0, i32 0), i8 10, i8 14, i8 0, i8 0 }, section "__verbose", align 8
@__func__.hub_resume = private unnamed_addr constant [11 x i8] c"hub_resume\00", align 1
@.str.260 = private unnamed_addr constant [29 x i8] c"device %s not suspended yet\0A\00", align 1
@hub_suspend.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.hub_suspend, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12.957, i32 0, i32 0), i8 -1, i8 13, i8 0, i8 0 }, section "__verbose", align 8
@__func__.hub_suspend = private unnamed_addr constant [12 x i8] c"hub_suspend\00", align 1
@highspeed_hubs = internal global i32 0, align 4
@.str.97 = private unnamed_addr constant [47 x i8] c"Unsupported bus topology: hub nested too deep\0A\00", align 1
@.str.98 = private unnamed_addr constant [23 x i8] c"ignoring external hub\0A\00", align 1
@.str.99 = private unnamed_addr constant [30 x i8] c"bad descriptor, ignoring hub\0A\00", align 1
@.str.100 = private unnamed_addr constant [15 x i8] c"USB hub found\0A\00", align 1
@.str.101 = private unnamed_addr constant [22 x i8] c"(&(&hub->leds)->work)\00", align 1
@hub_probe.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.103 = private unnamed_addr constant [23 x i8] c"(&(&hub->leds)->timer)\00", align 1
@hub_probe.__key.102 = internal global %struct.lock_class_key zeroinitializer, align 1
@hub_probe.__key.104 = internal global %struct.lock_class_key zeroinitializer, align 1
@hub_probe.__key.106 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.109 = private unnamed_addr constant [15 x i8] c"(&hub->events)\00", align 1
@hub_probe.__key.108 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.191 = private unnamed_addr constant [19 x i8] c"&hub->status_mutex\00", align 1
@hub_configure.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.195 = private unnamed_addr constant [20 x i8] c"%d port%s detected\0A\00", align 1
@hub_configure.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.197, i32 0, i32 0), i8 86, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.197 = private unnamed_addr constant [44 x i8] c"compound device; port removable status: %s\0A\00", align 1
@hub_configure.descriptor.198 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.199, i32 0, i32 0), i8 88, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.199 = private unnamed_addr constant [16 x i8] c"standalone hub\0A\00", align 1
@hub_configure.descriptor.200 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.201, i32 0, i32 0), i8 92, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.201 = private unnamed_addr constant [24 x i8] c"ganged power switching\0A\00", align 1
@hub_configure.descriptor.202 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.203, i32 0, i32 0), i8 95, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.203 = private unnamed_addr constant [33 x i8] c"individual port power switching\0A\00", align 1
@hub_configure.descriptor.204 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.205, i32 0, i32 0), i8 99, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.205 = private unnamed_addr constant [30 x i8] c"no power switching (usb 1.0)\0A\00", align 1
@hub_configure.descriptor.206 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.207, i32 0, i32 0), i8 105, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.207 = private unnamed_addr constant [32 x i8] c"global over-current protection\0A\00", align 1
@hub_configure.descriptor.208 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.209, i32 0, i32 0), i8 108, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.209 = private unnamed_addr constant [41 x i8] c"individual port over-current protection\0A\00", align 1
@hub_configure.descriptor.210 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.211, i32 0, i32 0), i8 112, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.211 = private unnamed_addr constant [28 x i8] c"no over-current protection\0A\00", align 1
@.str.213 = private unnamed_addr constant [24 x i8] c"&(&hub->tt.lock)->rlock\00", align 1
@hub_configure.__key.212 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.215 = private unnamed_addr constant [22 x i8] c"(&hub->tt.clear_work)\00", align 1
@hub_configure.__key.214 = internal global %struct.lock_class_key zeroinitializer, align 1
@hub_configure.descriptor.216 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.217, i32 0, i32 0), i8 123, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.217 = private unnamed_addr constant [11 x i8] c"Single TT\0A\00", align 1
@hub_configure.descriptor.218 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.219, i32 0, i32 0), i8 -127, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.219 = private unnamed_addr constant [13 x i8] c"TT per port\0A\00", align 1
@.str.220 = private unnamed_addr constant [26 x i8] c"Using single TT (err %d)\0A\00", align 1
@hub_configure.descriptor.221 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.222, i32 0, i32 0), i8 -115, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.222 = private unnamed_addr constant [30 x i8] c"Unrecognized hub protocol %d\0A\00", align 1
@hub_configure.descriptor.223 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.224, i32 0, i32 0), i8 -104, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.224 = private unnamed_addr constant [45 x i8] c"TT requires at most %d FS bit times (%d ns)\0A\00", align 1
@hub_configure.descriptor.225 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.224, i32 0, i32 0), i8 -97, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@hub_configure.descriptor.226 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.224, i32 0, i32 0), i8 -91, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@hub_configure.descriptor.227 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.224, i32 0, i32 0), i8 -85, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@hub_configure.descriptor.228 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.229, i32 0, i32 0), i8 -78, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.229 = private unnamed_addr constant [31 x i8] c"Port indicators are supported\0A\00", align 1
@hub_configure.descriptor.230 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.231, i32 0, i32 0), i8 -74, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.231 = private unnamed_addr constant [35 x i8] c"power on to power good time: %dms\0A\00", align 1
@hub_configure.descriptor.233 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.234, i32 0, i32 0), i8 -47, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.234 = private unnamed_addr constant [42 x i8] c"hub controller current requirement: %dmA\0A\00", align 1
@.str.235 = private unnamed_addr constant [58 x i8] c"insufficient power available to use all downstream ports\0A\00", align 1
@hub_configure.descriptor.236 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.237, i32 0, i32 0), i8 -31, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.237 = private unnamed_addr constant [38 x i8] c"%umA bus power budget for each child\0A\00", align 1
@hub_configure.descriptor.238 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.239, i32 0, i32 0), i8 -19, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.240 = private unnamed_addr constant [16 x i8] c"lost (inactive)\00", align 1
@.str.241 = private unnamed_addr constant [5 x i8] c"good\00", align 1
@.str.239 = private unnamed_addr constant [26 x i8] c"local power source is %s\0A\00", align 1
@hub_configure.descriptor.242 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.243, i32 0, i32 0), i8 -15, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.244 = private unnamed_addr constant [4 x i8] c"no \00", align 1
@.str.243 = private unnamed_addr constant [33 x i8] c"%sover-current condition exists\0A\00", align 1
@.str.245 = private unnamed_addr constant [32 x i8] c"couldn't create port%d device.\0A\00", align 1
@.str.190 = private unnamed_addr constant [14 x i8] c"out of memory\00", align 1
@.str.192 = private unnamed_addr constant [26 x i8] c"can't read hub descriptor\00", align 1
@.str.193 = private unnamed_addr constant [24 x i8] c"hub has too many ports!\00", align 1
@.str.194 = private unnamed_addr constant [28 x i8] c"hub doesn't have any ports!\00", align 1
@.str.232 = private unnamed_addr constant [21 x i8] c"can't get hub status\00", align 1
@.str.246 = private unnamed_addr constant [26 x i8] c"can't update HCD hub info\00", align 1
@.str.247 = private unnamed_addr constant [28 x i8] c"config failed, %s (err %d)\0A\00", align 1
@usb_hub_adjust_deviceremovable.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__func__.usb_hub_adjust_deviceremovable, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.45, i32 0, i32 0), i8 100, i8 22, i8 0, i8 0 }, section "__verbose", align 8
@.str.45 = private unnamed_addr constant [68 x i8] c"DeviceRemovable is changed to 1 according to platform information.\0A\00", align 1
@usb_hub_adjust_deviceremovable.descriptor.46 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__func__.usb_hub_adjust_deviceremovable, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.45, i32 0, i32 0), i8 116, i8 22, i8 0, i8 0 }, section "__verbose", align 8
@__func__.usb_hub_adjust_deviceremovable = private unnamed_addr constant [31 x i8] c"usb_hub_adjust_deviceremovable\00", align 1
@hub_irq.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @__func__.hub_irq, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.250, i32 0, i32 0), i8 -96, i8 2, i8 0, i8 0 }, section "__verbose", align 8
@.str.250 = private unnamed_addr constant [17 x i8] c"transfer --> %d\0A\00", align 1
@.str.251 = private unnamed_addr constant [17 x i8] c"resubmit --> %d\0A\00", align 1
@__func__.hub_irq = private unnamed_addr constant [8 x i8] c"hub_irq\00", align 1
@__func__.hub_configure = private unnamed_addr constant [14 x i8] c"hub_configure\00", align 1
@__func__.hub_hub_status = private unnamed_addr constant [15 x i8] c"hub_hub_status\00", align 1
@.str.248 = private unnamed_addr constant [29 x i8] c"clear tt %d (%04x) error %d\0A\00", align 1
@hub_event.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__func__.hub_event, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.116, i32 0, i32 0), i8 -17, i8 19, i8 0, i8 0 }, section "__verbose", align 8
@.str.116 = private unnamed_addr constant [37 x i8] c"state %d ports %d chg %04x evt %04x\0A\00", align 1
@hub_event.descriptor.117 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__func__.hub_event, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.118, i32 0, i32 0), i8 1, i8 20, i8 0, i8 0 }, section "__verbose", align 8
@.str.118 = private unnamed_addr constant [22 x i8] c"Can't autoresume: %d\0A\00", align 1
@hub_event.descriptor.119 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__func__.hub_event, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.120, i32 0, i32 0), i8 10, i8 20, i8 0, i8 0 }, section "__verbose", align 8
@.str.120 = private unnamed_addr constant [24 x i8] c"resetting for error %d\0A\00", align 1
@hub_event.descriptor.121 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__func__.hub_event, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.122, i32 0, i32 0), i8 14, i8 20, i8 0, i8 0 }, section "__verbose", align 8
@.str.122 = private unnamed_addr constant [25 x i8] c"error resetting hub: %d\0A\00", align 1
@.str.123 = private unnamed_addr constant [23 x i8] c"get_hub_status failed\0A\00", align 1
@hub_event.descriptor.124 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__func__.hub_event, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.125, i32 0, i32 0), i8 54, i8 20, i8 0, i8 0 }, section "__verbose", align 8
@.str.125 = private unnamed_addr constant [14 x i8] c"power change\0A\00", align 1
@hub_event.descriptor.126 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__func__.hub_event, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.127, i32 0, i32 0), i8 66, i8 20, i8 0, i8 0 }, section "__verbose", align 8
@.str.127 = private unnamed_addr constant [21 x i8] c"over-current change\0A\00", align 1
@.str.128 = private unnamed_addr constant [24 x i8] c"over-current condition\0A\00", align 1
@__func__.hub_event = private unnamed_addr constant [10 x i8] c"hub_event\00", align 1
@port_event.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.port_event, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.129, i32 0, i32 0), i8 -117, i8 19, i8 0, i8 0 }, section "__verbose", align 8
@.str.129 = private unnamed_addr constant [28 x i8] c"enable change, status %08x\0A\00", align 1
@.str.130 = private unnamed_addr constant [40 x i8] c"disabled by hub (EMI?), re-enabling...\0A\00", align 1
@port_event.descriptor.131 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.port_event, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.127, i32 0, i32 0), i8 -99, i8 19, i8 0, i8 0 }, section "__verbose", align 8
@port_event.descriptor.132 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.port_event, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.133, i32 0, i32 0), i8 -88, i8 19, i8 0, i8 0 }, section "__verbose", align 8
@.str.133 = private unnamed_addr constant [14 x i8] c"reset change\0A\00", align 1
@port_event.descriptor.134 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.port_event, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.135, i32 0, i32 0), i8 -83, i8 19, i8 0, i8 0 }, section "__verbose", align 8
@.str.135 = private unnamed_addr constant [19 x i8] c"warm reset change\0A\00", align 1
@port_event.descriptor.136 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.port_event, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.137, i32 0, i32 0), i8 -78, i8 19, i8 0, i8 0 }, section "__verbose", align 8
@.str.137 = private unnamed_addr constant [19 x i8] c"link state change\0A\00", align 1
@.str.138 = private unnamed_addr constant [14 x i8] c"config error\0A\00", align 1
@port_event.descriptor.139 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.port_event, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.140, i32 0, i32 0), i8 -56, i8 19, i8 0, i8 0 }, section "__verbose", align 8
@.str.140 = private unnamed_addr constant [15 x i8] c"do warm reset\0A\00", align 1
@hub_port_connect_change.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.hub_port_connect_change, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.152, i32 0, i32 0), i8 71, i8 19, i8 0, i8 0 }, section "__verbose", align 8
@.str.152 = private unnamed_addr constant [30 x i8] c"status %04x, change %04x, %s\0A\00", align 1
@hub_port_connect.unreliable_port = internal global i32 -1, align 4
@__func__.hub_port_connect = private unnamed_addr constant [17 x i8] c"hub_port_connect\00", align 1
@.str.158 = private unnamed_addr constant [25 x i8] c"connect-debounce failed\0A\00", align 1
@.str.159 = private unnamed_addr constant [30 x i8] c"couldn't allocate usb_device\0A\00", align 1
@hub_port_connect.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.hub_port_connect, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.160, i32 0, i32 0), i8 -41, i8 18, i8 0, i8 0 }, section "__verbose", align 8
@.str.160 = private unnamed_addr constant [17 x i8] c"get status %d ?\0A\00", align 1
@.str.161 = private unnamed_addr constant [44 x i8] c"can't connect bus-powered hub to this port\0A\00", align 1
@hub_port_connect.descriptor.162 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.hub_port_connect, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.163, i32 0, i32 0), i8 25, i8 19, i8 0, i8 0 }, section "__verbose", align 8
@.str.163 = private unnamed_addr constant [24 x i8] c"%dmA power budget left\0A\00", align 1
@.str.164 = private unnamed_addr constant [32 x i8] c"unable to enumerate USB device\0A\00", align 1
@.str.185 = private unnamed_addr constant [27 x i8] c"%dmA is over %umA budget!\0A\00", align 1
@.str.186 = private unnamed_addr constant [25 x i8] c"%dmA over power budget!\0A\00", align 1
@.str.184 = private unnamed_addr constant [55 x i8] c"not running at top speed; connect to a high speed hub\0A\00", align 1
@set_port_led.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__func__.set_port_led, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.110, i32 0, i32 0), i8 -66, i8 1, i8 0, i8 0 }, section "__verbose", align 8
@.str.110 = private unnamed_addr constant [24 x i8] c"indicator %s status %d\0A\00", align 1
@.str.111 = private unnamed_addr constant [6 x i8] c"amber\00", align 1
@.str.112 = private unnamed_addr constant [6 x i8] c"green\00", align 1
@.str.113 = private unnamed_addr constant [4 x i8] c"off\00", align 1
@.str.114 = private constant [5 x i8] c"auto\00", align 1
@__func__.set_port_led = private unnamed_addr constant [13 x i8] c"set_port_led\00", align 1
@.str.156 = private unnamed_addr constant [9 x i8] c"1.5 Mb/s\00", align 1
@.str.157 = private unnamed_addr constant [8 x i8] c"12 Mb/s\00", align 1
@.str.153 = private unnamed_addr constant [10 x i8] c"10.0 Gb/s\00", align 1
@.str.154 = private unnamed_addr constant [9 x i8] c"5.0 Gb/s\00", align 1
@.str.155 = private unnamed_addr constant [9 x i8] c"480 Mb/s\00", align 1
@__func__.hub_port_connect_change = private unnamed_addr constant [24 x i8] c"hub_port_connect_change\00", align 1
@__func__.port_event = private unnamed_addr constant [11 x i8] c"port_event\00", align 1
@hub_handle_remote_wakeup.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.hub_handle_remote_wakeup, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.141, i32 0, i32 0), i8 -68, i8 13, i8 0, i8 0 }, section "__verbose", align 8
@.str.141 = private unnamed_addr constant [19 x i8] c"resume, status %d\0A\00", align 1
@__func__.hub_handle_remote_wakeup = private unnamed_addr constant [25 x i8] c"hub_handle_remote_wakeup\00", align 1
@usb_hcds_loaded = common global i64 0, align 8
@usb_bus_idr = global %struct.idr { %struct.radix_tree_root { i32 100663296, %struct.radix_tree_node* null }, i32 0 }, align 8
@usb_bus_idr_lock = global %struct.mutex { %union.anon.3 zeroinitializer, %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.43, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.qspinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usb_bus_idr_lock to i8*), i64 88) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usb_bus_idr_lock to i8*), i64 88) to %struct.list_head*) }, i8* bitcast (%struct.mutex* @usb_bus_idr_lock to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.44, i32 0, i32 0), i32 0, i64 0 } }, align 8
@.str.43 = private unnamed_addr constant [27 x i8] c"usb_bus_idr_lock.wait_lock\00", align 1
@.str.1.44 = private unnamed_addr constant [17 x i8] c"usb_bus_idr_lock\00", align 1
@usb_kill_urb_queue = global %struct.__wait_queue_head { %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.2.45, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.__wait_queue_head* @usb_kill_urb_queue to i8*), i64 72) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.__wait_queue_head* @usb_kill_urb_queue to i8*), i64 72) to %struct.list_head*) } }, align 8
@.str.2.45 = private unnamed_addr constant [24 x i8] c"usb_kill_urb_queue.lock\00", align 1
@mon_ops = common global %struct.usb_mon_operations* null, align 8
@__ksymtab_usb_hcds_loaded = internal constant %struct.kernel_symbol { i64 ptrtoint (i64* @usb_hcds_loaded to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_usb_hcds_loaded, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcds_loaded", align 8
@__ksymtab_usb_bus_idr = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.idr* @usb_bus_idr to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_bus_idr, i32 0, i32 0) }, section "___ksymtab_gpl+usb_bus_idr", align 8
@__ksymtab_usb_bus_idr_lock = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.mutex* @usb_bus_idr_lock to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_bus_idr_lock, i32 0, i32 0) }, section "___ksymtab_gpl+usb_bus_idr_lock", align 8
@__param_authorized_default = internal constant %struct.kernel_param { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.80.62, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 420, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @authorized_default to i8*) } }, section "__param", align 8
@__UNIQUE_ID_authorized_defaulttype16 = internal constant [32 x i8] c"parmtype=authorized_default:int\00", section ".modinfo", align 1
@__UNIQUE_ID_authorized_default17 = internal constant [161 x i8] c"parm=authorized_default:Default USB device authorization: 0 is not authorized, 1 is authorized, -1 is authorized except for wireless USB (default, old behaviour\00", section ".modinfo", align 1
@__ksymtab_usb_hcd_poll_rh_status = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.712*)* @usb_hcd_poll_rh_status to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_usb_hcd_poll_rh_status, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_poll_rh_status", align 8
@__ksymtab_usb_hcd_start_port_resume = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_bus*, i32)* @usb_hcd_start_port_resume to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_usb_hcd_start_port_resume, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_start_port_resume", align 8
@__ksymtab_usb_hcd_end_port_resume = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_bus*, i32)* @usb_hcd_end_port_resume to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_hcd_end_port_resume, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_end_port_resume", align 8
@__ksymtab_usb_calc_bus_time = internal constant %struct.kernel_symbol { i64 ptrtoint (i64 (i32, i32, i32, i32)* @usb_calc_bus_time to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_usb_calc_bus_time, i32 0, i32 0) }, section "___ksymtab_gpl+usb_calc_bus_time", align 8
@__ksymtab_usb_hcd_link_urb_to_ep = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_hcd.712*, %struct.urb*)* @usb_hcd_link_urb_to_ep to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_usb_hcd_link_urb_to_ep, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_link_urb_to_ep", align 8
@__ksymtab_usb_hcd_check_unlink_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_hcd.712*, %struct.urb*, i32)* @usb_hcd_check_unlink_urb to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_hcd_check_unlink_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_check_unlink_urb", align 8
@__ksymtab_usb_hcd_unlink_urb_from_ep = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.712*, %struct.urb*)* @usb_hcd_unlink_urb_from_ep to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab_usb_hcd_unlink_urb_from_ep, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_unlink_urb_from_ep", align 8
@__ksymtab_usb_hcd_unmap_urb_setup_for_dma = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.712*, %struct.urb*)* @usb_hcd_unmap_urb_setup_for_dma to i64), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__kstrtab_usb_hcd_unmap_urb_setup_for_dma, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_unmap_urb_setup_for_dma", align 8
@__ksymtab_usb_hcd_unmap_urb_for_dma = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.712*, %struct.urb*)* @usb_hcd_unmap_urb_for_dma to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_usb_hcd_unmap_urb_for_dma, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_unmap_urb_for_dma", align 8
@__ksymtab_usb_hcd_map_urb_for_dma = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_hcd.712*, %struct.urb*, i32)* @usb_hcd_map_urb_for_dma to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_hcd_map_urb_for_dma, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_map_urb_for_dma", align 8
@__ksymtab_usb_hcd_giveback_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.712*, %struct.urb*, i32)* @usb_hcd_giveback_urb to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_usb_hcd_giveback_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_giveback_urb", align 8
@__ksymtab_usb_alloc_streams = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_interface*, %struct.usb_host_endpoint**, i32, i32, i32)* @usb_alloc_streams to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_usb_alloc_streams, i32 0, i32 0) }, section "___ksymtab_gpl+usb_alloc_streams", align 8
@__ksymtab_usb_free_streams = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_interface*, %struct.usb_host_endpoint**, i32, i32)* @usb_free_streams to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_free_streams, i32 0, i32 0) }, section "___ksymtab_gpl+usb_free_streams", align 8
@__ksymtab_usb_hcd_resume_root_hub = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.712*)* @usb_hcd_resume_root_hub to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_hcd_resume_root_hub, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_resume_root_hub", align 8
@__ksymtab_usb_bus_start_enum = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_bus*, i32)* @usb_bus_start_enum to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_bus_start_enum, i32 0, i32 0) }, section "___ksymtab_gpl+usb_bus_start_enum", align 8
@__ksymtab_usb_hcd_irq = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, i8*)* @usb_hcd_irq to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_hcd_irq, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_irq", align 8
@__ksymtab_usb_hc_died = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.712*)* @usb_hc_died to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_hc_died, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hc_died", align 8
@__ksymtab_usb_create_shared_hcd = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_hcd.712* (%struct.hc_driver.713*, %struct.device*, i8*, %struct.usb_hcd.712*)* @usb_create_shared_hcd to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_usb_create_shared_hcd, i32 0, i32 0) }, section "___ksymtab_gpl+usb_create_shared_hcd", align 8
@__ksymtab_usb_create_hcd = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_hcd.712* (%struct.hc_driver.713*, %struct.device*, i8*)* @usb_create_hcd to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_create_hcd, i32 0, i32 0) }, section "___ksymtab_gpl+usb_create_hcd", align 8
@__ksymtab_usb_get_hcd = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_hcd.712* (%struct.usb_hcd.712*)* @usb_get_hcd to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_get_hcd, i32 0, i32 0) }, section "___ksymtab_gpl+usb_get_hcd", align 8
@__ksymtab_usb_put_hcd = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.712*)* @usb_put_hcd to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_put_hcd, i32 0, i32 0) }, section "___ksymtab_gpl+usb_put_hcd", align 8
@__ksymtab_usb_hcd_is_primary_hcd = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_hcd.712*)* @usb_hcd_is_primary_hcd to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_usb_hcd_is_primary_hcd, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_is_primary_hcd", align 8
@__ksymtab_usb_add_hcd = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_hcd.712*, i32, i64)* @usb_add_hcd to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_add_hcd, i32 0, i32 0) }, section "___ksymtab_gpl+usb_add_hcd", align 8
@__ksymtab_usb_remove_hcd = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.712*)* @usb_remove_hcd to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_remove_hcd, i32 0, i32 0) }, section "___ksymtab_gpl+usb_remove_hcd", align 8
@__ksymtab_usb_hcd_platform_shutdown = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.platform_device*)* @usb_hcd_platform_shutdown to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_usb_hcd_platform_shutdown, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_platform_shutdown", align 8
@__ksymtab_usb_mon_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_mon_operations*)* @usb_mon_register to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_mon_register, i32 0, i32 0) }, section "___ksymtab_gpl+usb_mon_register", align 8
@__ksymtab_usb_mon_deregister = internal constant %struct.kernel_symbol { i64 ptrtoint (void ()* @usb_mon_deregister to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_mon_deregister, i32 0, i32 0) }, section "___ksymtab_gpl+usb_mon_deregister", align 8
@__kstrtab_usb_mon_deregister = internal constant [19 x i8] c"usb_mon_deregister\00", section "__ksymtab_strings", align 1
@.str.51.47 = private unnamed_addr constant [35 x i8] c"\013USB: monitor was not registered\0A\00", align 1
@__kstrtab_usb_mon_register = internal constant [17 x i8] c"usb_mon_register\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hcd_platform_shutdown = internal constant [26 x i8] c"usb_hcd_platform_shutdown\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_remove_hcd = internal constant [15 x i8] c"usb_remove_hcd\00", section "__ksymtab_strings", align 1
@.str.49.49 = private unnamed_addr constant [18 x i8] c"remove, state %x\0A\00", align 1
@usb_bus_attr_group = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([3 x %struct.attribute*], [3 x %struct.attribute*]* @usb_bus_attrs, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@usb_remove_hcd.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.usb_remove_hcd, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50.51, i32 0, i32 0), i8 -109, i8 11, i8 0, i8 0 }, section "__verbose", align 8
@.str.50.51 = private unnamed_addr constant [29 x i8] c"roothub graceful disconnect\0A\00", align 1
@hcd_root_hub_lock = internal global %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.52.55, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@.str.83.54 = private unnamed_addr constant [25 x i8] c"USB bus %d deregistered\0A\00", align 1
@.str.52.55 = private unnamed_addr constant [18 x i8] c"hcd_root_hub_lock\00", align 1
@__func__.usb_remove_hcd = private unnamed_addr constant [15 x i8] c"usb_remove_hcd\00", align 1
@.str.4.57 = private unnamed_addr constant [23 x i8] c"drivers/usb/core/hcd.c\00", align 1
@usb_bus_attrs = internal global [3 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_authorized_default, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_interface_authorized_default, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_authorized_default = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.80.62, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @authorized_default_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @authorized_default_store }, align 8
@dev_attr_interface_authorized_default = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.82.58, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @interface_authorized_default_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @interface_authorized_default_store }, align 8
@.str.82.58 = private unnamed_addr constant [29 x i8] c"interface_authorized_default\00", align 1
@.str.80.62 = private constant [19 x i8] c"authorized_default\00", align 16
@__kstrtab_usb_add_hcd = internal constant [12 x i8] c"usb_add_hcd\00", section "__ksymtab_strings", align 1
@authorized_default = internal global i32 -1, align 4
@usb_add_hcd.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.usb_add_hcd, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.42.65, i32 0, i32 0), i8 -29, i8 10, i8 0, i8 0 }, section "__verbose", align 8
@.str.42.65 = private unnamed_addr constant [19 x i8] c"pool alloc failed\0A\00", align 1
@.str.43.66 = private unnamed_addr constant [29 x i8] c"unable to allocate root hub\0A\00", align 1
@.str.44.67 = private unnamed_addr constant [17 x i8] c"can't setup: %d\0A\00", align 1
@usb_add_hcd.descriptor.45 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.usb_add_hcd, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.46, i32 0, i32 0), i8 38, i8 11, i8 0, i8 0 }, section "__verbose", align 8
@.str.46 = private unnamed_addr constant [28 x i8] c"supports USB remote wakeup\0A\00", align 1
@.str.47.68 = private unnamed_addr constant [18 x i8] c"startup error %d\0A\00", align 1
@.str.48.69 = private unnamed_addr constant [48 x i8] c"\013Cannot register USB bus sysfs attributes: %d\0A\00", align 1
@pv_irq_ops = external global %struct.pv_irq_ops, align 8
@dma_ops = external global %struct.dma_map_ops*, align 8
@hcd_urb_list_lock = internal global %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.53.82, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@.str.53.82 = private unnamed_addr constant [18 x i8] c"hcd_urb_list_lock\00", align 1
@register_root_hub.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.register_root_hub, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.76.84, i32 0, i32 0), i8 73, i8 4, i8 0, i8 0 }, section "__verbose", align 8
@.str.76.84 = private unnamed_addr constant [36 x i8] c"can't read %s device descriptor %d\0A\00", align 1
@register_root_hub.descriptor.77 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.register_root_hub, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.78.85, i32 0, i32 0), i8 84, i8 4, i8 0, i8 0 }, section "__verbose", align 8
@.str.78.85 = private unnamed_addr constant [33 x i8] c"can't read %s bos descriptor %d\0A\00", align 1
@.str.79.86 = private unnamed_addr constant [36 x i8] c"can't register root hub for %s, %d\0A\00", align 1
@.str.28.87 = private unnamed_addr constant [22 x i8] c"HC died; cleaning up\0A\00", align 1
@__func__.register_root_hub = private unnamed_addr constant [18 x i8] c"register_root_hub\00", align 1
@.str.70.89 = private unnamed_addr constant [9 x i8] c"%s:usb%d\00", align 1
@.str.71 = private unnamed_addr constant [29 x i8] c"request interrupt %d failed\0A\00", align 1
@.str.73 = private unnamed_addr constant [7 x i8] c"io mem\00", align 1
@.str.74.90 = private unnamed_addr constant [8 x i8] c"io base\00", align 1
@.str.72.91 = private unnamed_addr constant [21 x i8] c"irq %d, %s 0x%08llx\0A\00", align 1
@.str.75 = private unnamed_addr constant [13 x i8] c"%s 0x%08llx\0A\00", align 1
@.str.69.92 = private unnamed_addr constant [20 x i8] c"&(&bh->lock)->rlock\00", align 1
@init_giveback_urb_bh.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@__func__.usb_add_hcd = private unnamed_addr constant [12 x i8] c"usb_add_hcd\00", align 1
@.str.67.94 = private unnamed_addr constant [32 x i8] c"\013%s: failed to get bus number\0A\00", align 1
@.str.68.95 = private unnamed_addr constant [48 x i8] c"new USB bus registered, assigned bus number %d\0A\00", align 1
@__kstrtab_usb_hcd_is_primary_hcd = internal constant [23 x i8] c"usb_hcd_is_primary_hcd\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_put_hcd = internal constant [12 x i8] c"usb_put_hcd\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_get_hcd = internal constant [12 x i8] c"usb_get_hcd\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_create_hcd = internal constant [15 x i8] c"usb_create_hcd\00", section "__ksymtab_strings", align 1
@usb_create_shared_hcd.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.usb_create_shared_hcd, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.29.105, i32 0, i32 0), i8 -29, i8 9, i8 0, i8 0 }, section "__verbose", align 8
@.str.29.105 = private unnamed_addr constant [33 x i8] c"hcd address0 mutex alloc failed\0A\00", align 1
@.str.30 = private unnamed_addr constant [20 x i8] c"hcd->address0_mutex\00", align 1
@usb_create_shared_hcd.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@usb_create_shared_hcd.descriptor.31 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.usb_create_shared_hcd, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.32, i32 0, i32 0), i8 -21, i8 9, i8 0, i8 0 }, section "__verbose", align 8
@.str.32 = private unnamed_addr constant [34 x i8] c"hcd bandwidth mutex alloc failed\0A\00", align 1
@.str.34 = private unnamed_addr constant [21 x i8] c"hcd->bandwidth_mutex\00", align 1
@usb_create_shared_hcd.__key.33 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.36.108 = private unnamed_addr constant [17 x i8] c"(&hcd->rh_timer)\00", align 1
@usb_create_shared_hcd.__key.35 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.38.109 = private unnamed_addr constant [20 x i8] c"(&hcd->wakeup_work)\00", align 1
@usb_create_shared_hcd.__key.37 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.39.110 = private unnamed_addr constant [20 x i8] c"USB Host Controller\00", align 1
@.str.65.111 = private unnamed_addr constant [24 x i8] c"&bus->devnum_next_mutex\00", align 1
@usb_bus_init.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@__func__.usb_create_shared_hcd = private unnamed_addr constant [22 x i8] c"usb_create_shared_hcd\00", align 1
@__kstrtab_usb_create_shared_hcd = internal constant [22 x i8] c"usb_create_shared_hcd\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hc_died = internal constant [12 x i8] c"usb_hc_died\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hcd_irq = internal constant [12 x i8] c"usb_hcd_irq\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_bus_start_enum = internal constant [19 x i8] c"usb_bus_start_enum\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hcd_resume_root_hub = internal constant [24 x i8] c"usb_hcd_resume_root_hub\00", section "__ksymtab_strings", align 1
@pm_wq = external global %struct.workqueue_struct*, align 8
@__kstrtab_usb_free_streams = internal constant [17 x i8] c"usb_free_streams\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_alloc_streams = internal constant [18 x i8] c"usb_alloc_streams\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hcd_giveback_urb = internal constant [21 x i8] c"usb_hcd_giveback_urb\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hcd_map_urb_for_dma = internal constant [24 x i8] c"usb_hcd_map_urb_for_dma\00", section "__ksymtab_strings", align 1
@usb_hcd_map_urb_for_dma.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.6.117 = private unnamed_addr constant [33 x i8] c"transfer buffer not dma capable\0A\00", align 1
@vmalloc_base = external global i64, align 8
@vmemmap_base = external global i64, align 8
@page_offset_base = external global i64, align 8
@hcd_alloc_coherent.__warned = internal global i8 0, section ".data.unlikely", align 1
@__kstrtab_usb_hcd_unmap_urb_for_dma = internal constant [26 x i8] c"usb_hcd_unmap_urb_for_dma\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hcd_unmap_urb_setup_for_dma = internal constant [32 x i8] c"usb_hcd_unmap_urb_setup_for_dma\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hcd_unlink_urb_from_ep = internal constant [27 x i8] c"usb_hcd_unlink_urb_from_ep\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hcd_check_unlink_urb = internal constant [25 x i8] c"usb_hcd_check_unlink_urb\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hcd_link_urb_to_ep = internal constant [23 x i8] c"usb_hcd_link_urb_to_ep\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_calc_bus_time = internal constant [18 x i8] c"usb_calc_bus_time\00", section "__ksymtab_strings", align 1
@usb_calc_bus_time.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.usb_calc_bus_time, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.5.119, i32 0, i32 0), i8 -60, i8 4, i8 0, i8 0 }, section "__verbose", align 8
@.str.5.119 = private unnamed_addr constant [25 x i8] c"%s: bogus device speed!\0A\00", align 1
@__func__.usb_calc_bus_time = private unnamed_addr constant [18 x i8] c"usb_calc_bus_time\00", align 1
@__kstrtab_usb_hcd_end_port_resume = internal constant [24 x i8] c"usb_hcd_end_port_resume\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hcd_start_port_resume = internal constant [26 x i8] c"usb_hcd_start_port_resume\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hcd_poll_rh_status = internal constant [23 x i8] c"usb_hcd_poll_rh_status\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_bus_idr_lock = internal constant [17 x i8] c"usb_bus_idr_lock\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_bus_idr = internal constant [12 x i8] c"usb_bus_idr\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hcds_loaded = internal constant [16 x i8] c"usb_hcds_loaded\00", section "__ksymtab_strings", align 1
@usb31_rh_dev_descriptor = internal constant [18 x i8] c"\12\01\10\03\09\00\03\09k\1D\03\00\11\04\03\02\01\01", align 16
@usb3_rh_dev_descriptor = internal constant [18 x i8] c"\12\01\00\03\09\00\03\09k\1D\03\00\11\04\03\02\01\01", align 16
@usb25_rh_dev_descriptor = internal constant [18 x i8] c"\12\01P\02\09\00\00\FFk\1D\02\00\11\04\03\02\01\01", align 16
@usb2_rh_dev_descriptor = internal constant [18 x i8] c"\12\01\00\02\09\00\00@k\1D\02\00\11\04\03\02\01\01", align 16
@usb11_rh_dev_descriptor = internal constant [18 x i8] c"\12\01\10\01\09\00\00@k\1D\01\00\11\04\03\02\01\01", align 16
@ss_rh_config_descriptor = internal constant [31 x i8] c"\09\02\1F\00\01\01\00\C0\00\09\04\00\00\01\09\00\00\00\07\05\81\03\04\00\0C\060\00\00\02\00", align 16
@hs_rh_config_descriptor = internal constant [25 x i8] c"\09\02\19\00\01\01\00\C0\00\09\04\00\00\01\09\00\00\00\07\05\81\03\04\00\0C", align 16
@fs_rh_config_descriptor = internal constant [25 x i8] c"\09\02\19\00\01\01\00\C0\00\09\04\00\00\01\09\00\00\00\07\05\81\03\02\00\FF", align 16
@rh_call_control.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.rh_call_control, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.57.123, i32 0, i32 0), i8 -120, i8 2, i8 0, i8 0 }, section "__verbose", align 8
@.str.57.123 = private unnamed_addr constant [28 x i8] c"root hub device address %d\0A\00", align 1
@rh_call_control.descriptor.58 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.rh_call_control, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.59.124, i32 0, i32 0), i8 -105, i8 2, i8 0, i8 0 }, section "__verbose", align 8
@.str.59.124 = private unnamed_addr constant [26 x i8] c"no endpoint features yet\0A\00", align 1
@rh_call_control.descriptor.60 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.rh_call_control, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.61.125, i32 0, i32 0), i8 -59, i8 2, i8 0, i8 0 }, section "__verbose", align 8
@.str.61.125 = private unnamed_addr constant [52 x i8] c"CTRL: TypeReq=0x%x val=0x%x idx=0x%x len=%d ==> %d\0A\00", align 1
@__func__.rh_call_control = private unnamed_addr constant [16 x i8] c"rh_call_control\00", align 1
@rh_string.langids = internal constant [4 x i8] c"\04\03\09\04", align 1
@.str.62.126 = private unnamed_addr constant [9 x i8] c"%s %s %s\00", align 1
@init_uts_ns = external global %struct.uts_namespace, align 8
@rh_queue_status.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.rh_queue_status, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.56.127, i32 0, i32 0), i8 50, i8 3, i8 0, i8 0 }, section "__verbose", align 8
@.str.56.127 = private unnamed_addr constant [27 x i8] c"not queuing rh status urb\0A\00", align 1
@__func__.rh_queue_status = private unnamed_addr constant [16 x i8] c"rh_queue_status\00", align 1
@hcd_urb_unlink_lock = internal global %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.63.129, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@usb_hcd_unlink_urb.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.usb_hcd_unlink_urb, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.7.128, i32 0, i32 0), i8 -66, i8 6, i8 0, i8 0 }, section "__verbose", align 8
@.str.7.128 = private unnamed_addr constant [27 x i8] c"hcd_unlink_urb %p fail %d\0A\00", align 1
@__func__.usb_hcd_unlink_urb = private unnamed_addr constant [19 x i8] c"usb_hcd_unlink_urb\00", align 1
@.str.63.129 = private unnamed_addr constant [20 x i8] c"hcd_urb_unlink_lock\00", align 1
@usb_hcd_flush_endpoint.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.usb_hcd_flush_endpoint, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.8.136, i32 0, i32 0), i8 116, i8 7, i8 0, i8 0 }, section "__verbose", align 8
@.str.14.132 = private unnamed_addr constant [5 x i8] c"-iso\00", align 1
@.str.12.134 = private unnamed_addr constant [6 x i8] c"-bulk\00", align 1
@.str.13.135 = private unnamed_addr constant [6 x i8] c"-intr\00", align 1
@.str.8.136 = private unnamed_addr constant [26 x i8] c"shutdown urb %p ep%d%s%s\0A\00", align 1
@__func__.usb_hcd_flush_endpoint = private unnamed_addr constant [23 x i8] c"usb_hcd_flush_endpoint\00", align 1
@hcd_bus_suspend.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.hcd_bus_suspend, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.15.144, i32 0, i32 0), i8 -58, i8 8, i8 0, i8 0 }, section "__verbose", align 8
@.str.16.143 = private unnamed_addr constant [6 x i8] c"auto-\00", align 1
@.str.15.144 = private unnamed_addr constant [26 x i8] c"bus %ssuspend, wakeup %d\0A\00", align 1
@hcd_bus_suspend.descriptor.17 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.hcd_bus_suspend, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.18.145, i32 0, i32 0), i8 -56, i8 8, i8 0, i8 0 }, section "__verbose", align 8
@.str.18.145 = private unnamed_addr constant [24 x i8] c"skipped %s of dead bus\0A\00", align 1
@.str.19.146 = private unnamed_addr constant [8 x i8] c"suspend\00", align 1
@hcd_bus_suspend.descriptor.20 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.hcd_bus_suspend, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.21.147, i32 0, i32 0), i8 -35, i8 8, i8 0, i8 0 }, section "__verbose", align 8
@.str.21.147 = private unnamed_addr constant [33 x i8] c"suspend raced with wakeup event\0A\00", align 1
@hcd_bus_suspend.descriptor.22 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.hcd_bus_suspend, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.23, i32 0, i32 0), i8 -22, i8 8, i8 0, i8 0 }, section "__verbose", align 8
@.str.23 = private unnamed_addr constant [21 x i8] c"bus %s fail, err %d\0A\00", align 1
@__func__.hcd_bus_suspend = private unnamed_addr constant [16 x i8] c"hcd_bus_suspend\00", align 1
@hcd_bus_resume.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.hcd_bus_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.24.148, i32 0, i32 0), i8 -10, i8 8, i8 0, i8 0 }, section "__verbose", align 8
@.str.24.148 = private unnamed_addr constant [14 x i8] c"usb %sresume\0A\00", align 1
@hcd_bus_resume.descriptor.25 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.hcd_bus_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.18.145, i32 0, i32 0), i8 -8, i8 8, i8 0, i8 0 }, section "__verbose", align 8
@.str.26.149 = private unnamed_addr constant [7 x i8] c"resume\00", align 1
@hcd_bus_resume.descriptor.27 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.hcd_bus_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.23, i32 0, i32 0), i8 33, i8 9, i8 0, i8 0 }, section "__verbose", align 8
@__func__.hcd_bus_resume = private unnamed_addr constant [15 x i8] c"hcd_bus_resume\00", align 1
@__ksymtab_usb_init_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.urb.744*)* @usb_init_urb to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_init_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_init_urb", align 8
@__ksymtab_usb_alloc_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.urb.744* (i32, i32)* @usb_alloc_urb to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_usb_alloc_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_alloc_urb", align 8
@__ksymtab_usb_free_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.urb.744*)* @usb_free_urb to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_free_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_free_urb", align 8
@__ksymtab_usb_get_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.urb.744* (%struct.urb.744*)* @usb_get_urb to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_get_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_get_urb", align 8
@__ksymtab_usb_anchor_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.urb.744*, %struct.usb_anchor*)* @usb_anchor_urb to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_anchor_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_anchor_urb", align 8
@__ksymtab_usb_unanchor_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.urb.744*)* @usb_unanchor_urb to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_unanchor_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_unanchor_urb", align 8
@__ksymtab_usb_submit_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.urb.744*, i32)* @usb_submit_urb to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_submit_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_submit_urb", align 8
@__ksymtab_usb_unlink_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.urb.744*)* @usb_unlink_urb to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_unlink_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_unlink_urb", align 8
@__ksymtab_usb_kill_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.urb.744*)* @usb_kill_urb to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_kill_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_kill_urb", align 8
@__ksymtab_usb_poison_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.urb.744*)* @usb_poison_urb to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_poison_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_poison_urb", align 8
@__ksymtab_usb_unpoison_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.urb.744*)* @usb_unpoison_urb to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_unpoison_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_unpoison_urb", align 8
@__ksymtab_usb_block_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.urb.744*)* @usb_block_urb to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_usb_block_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_block_urb", align 8
@__ksymtab_usb_kill_anchored_urbs = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_anchor*)* @usb_kill_anchored_urbs to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_usb_kill_anchored_urbs, i32 0, i32 0) }, section "___ksymtab_gpl+usb_kill_anchored_urbs", align 8
@__ksymtab_usb_poison_anchored_urbs = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_anchor*)* @usb_poison_anchored_urbs to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_poison_anchored_urbs, i32 0, i32 0) }, section "___ksymtab_gpl+usb_poison_anchored_urbs", align 8
@__ksymtab_usb_unpoison_anchored_urbs = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_anchor*)* @usb_unpoison_anchored_urbs to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab_usb_unpoison_anchored_urbs, i32 0, i32 0) }, section "___ksymtab_gpl+usb_unpoison_anchored_urbs", align 8
@__ksymtab_usb_unlink_anchored_urbs = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_anchor*)* @usb_unlink_anchored_urbs to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_unlink_anchored_urbs, i32 0, i32 0) }, section "___ksymtab_gpl+usb_unlink_anchored_urbs", align 8
@__ksymtab_usb_anchor_suspend_wakeups = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_anchor*)* @usb_anchor_suspend_wakeups to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab_usb_anchor_suspend_wakeups, i32 0, i32 0) }, section "___ksymtab_gpl+usb_anchor_suspend_wakeups", align 8
@__ksymtab_usb_anchor_resume_wakeups = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_anchor*)* @usb_anchor_resume_wakeups to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_usb_anchor_resume_wakeups, i32 0, i32 0) }, section "___ksymtab_gpl+usb_anchor_resume_wakeups", align 8
@__ksymtab_usb_wait_anchor_empty_timeout = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_anchor*, i32)* @usb_wait_anchor_empty_timeout to i64), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__kstrtab_usb_wait_anchor_empty_timeout, i32 0, i32 0) }, section "___ksymtab_gpl+usb_wait_anchor_empty_timeout", align 8
@__ksymtab_usb_get_from_anchor = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.urb.744* (%struct.usb_anchor*)* @usb_get_from_anchor to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_usb_get_from_anchor, i32 0, i32 0) }, section "___ksymtab_gpl+usb_get_from_anchor", align 8
@__ksymtab_usb_scuttle_anchored_urbs = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_anchor*)* @usb_scuttle_anchored_urbs to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_usb_scuttle_anchored_urbs, i32 0, i32 0) }, section "___ksymtab_gpl+usb_scuttle_anchored_urbs", align 8
@__ksymtab_usb_anchor_empty = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_anchor*)* @usb_anchor_empty to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_anchor_empty, i32 0, i32 0) }, section "___ksymtab_gpl+usb_anchor_empty", align 8
@__kstrtab_usb_anchor_empty = internal constant [17 x i8] c"usb_anchor_empty\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_scuttle_anchored_urbs = internal constant [26 x i8] c"usb_scuttle_anchored_urbs\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_get_from_anchor = internal constant [20 x i8] c"usb_get_from_anchor\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_wait_anchor_empty_timeout = internal constant [30 x i8] c"usb_wait_anchor_empty_timeout\00", section "__ksymtab_strings", align 1
@.str.172 = private unnamed_addr constant [23 x i8] c"drivers/usb/core/urb.c\00", align 1
@__kstrtab_usb_anchor_resume_wakeups = internal constant [26 x i8] c"usb_anchor_resume_wakeups\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_anchor_suspend_wakeups = internal constant [27 x i8] c"usb_anchor_suspend_wakeups\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_unlink_anchored_urbs = internal constant [25 x i8] c"usb_unlink_anchored_urbs\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_unpoison_anchored_urbs = internal constant [27 x i8] c"usb_unpoison_anchored_urbs\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_poison_anchored_urbs = internal constant [25 x i8] c"usb_poison_anchored_urbs\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_kill_anchored_urbs = internal constant [23 x i8] c"usb_kill_anchored_urbs\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_block_urb = internal constant [14 x i8] c"usb_block_urb\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_unpoison_urb = internal constant [17 x i8] c"usb_unpoison_urb\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_poison_urb = internal constant [15 x i8] c"usb_poison_urb\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_kill_urb = internal constant [13 x i8] c"usb_kill_urb\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_unlink_urb = internal constant [15 x i8] c"usb_unlink_urb\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_submit_urb = internal constant [15 x i8] c"usb_submit_urb\00", section "__ksymtab_strings", align 1
@usb_submit_urb.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.1.185 = private unnamed_addr constant [31 x i8] c"URB %p submitted while active\0A\00", align 1
@usb_submit_urb.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.usb_submit_urb, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.172, i32 0, i32 0), i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.3.192, i32 0, i32 0), i8 -119, i8 1, i8 0, i8 0 }, section "__verbose", align 8
@.str.3.192 = private unnamed_addr constant [48 x i8] c"bogus endpoint ep%d%s in %s (bad maxpacket %d)\0A\00", align 1
@__func__.usb_submit_urb = private unnamed_addr constant [15 x i8] c"usb_submit_urb\00", align 1
@usb_submit_urb.pipetypes = internal global [4 x i32] [i32 2, i32 0, i32 3, i32 1], align 16
@.str.6.194 = private unnamed_addr constant [43 x i8] c"%s %s: BOGUS urb xfer, pipe %x != type %x\0A\00", align 1
@.str.7.195 = private unnamed_addr constant [35 x i8] c"%s %s: BOGUS urb flags, %x --> %x\0A\00", align 1
@__kstrtab_usb_unanchor_urb = internal constant [17 x i8] c"usb_unanchor_urb\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_anchor_urb = internal constant [15 x i8] c"usb_anchor_urb\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_get_urb = internal constant [12 x i8] c"usb_get_urb\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_free_urb = internal constant [13 x i8] c"usb_free_urb\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_alloc_urb = internal constant [14 x i8] c"usb_alloc_urb\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_init_urb = internal constant [13 x i8] c"usb_init_urb\00", section "__ksymtab_strings", align 1
@usb_if_device_type = global %struct.device_type { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.17.211, i32 0, i32 0), %struct.attribute_group** null, i32 (%struct.device*, %struct.kobj_uevent_env*)* @usb_if_uevent, i8* (%struct.device*, i16*, %struct.atomic_t*, %struct.atomic_t*)* null, void (%struct.device*)* @usb_release_interface, %struct.dev_pm_ops* null }, align 8
@.str.17.211 = private unnamed_addr constant [14 x i8] c"usb_interface\00", align 1
@.str.38.215 = private unnamed_addr constant [19 x i8] c"INTERFACE=%d/%d/%d\00", align 1
@.str.39.216 = private unnamed_addr constant [73 x i8] c"MODALIAS=usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02Xin%02X\00", align 1
@__ksymtab_usb_control_msg = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32, i8, i8, i16, i16, i8*, i16, i32)* @usb_control_msg to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_usb_control_msg, i32 0, i32 0) }, section "___ksymtab_gpl+usb_control_msg", align 8
@__ksymtab_usb_interrupt_msg = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32, i8*, i32, i32*, i32)* @usb_interrupt_msg to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_usb_interrupt_msg, i32 0, i32 0) }, section "___ksymtab_gpl+usb_interrupt_msg", align 8
@__ksymtab_usb_bulk_msg = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32, i8*, i32, i32*, i32)* @usb_bulk_msg to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_bulk_msg, i32 0, i32 0) }, section "___ksymtab_gpl+usb_bulk_msg", align 8
@__ksymtab_usb_sg_init = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_sg_request*, %struct.usb_device*, i32, i32, %struct.scatterlist*, i32, i64, i32)* @usb_sg_init to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_sg_init, i32 0, i32 0) }, section "___ksymtab_gpl+usb_sg_init", align 8
@__ksymtab_usb_sg_wait = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_sg_request*)* @usb_sg_wait to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_sg_wait, i32 0, i32 0) }, section "___ksymtab_gpl+usb_sg_wait", align 8
@__ksymtab_usb_sg_cancel = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_sg_request*)* @usb_sg_cancel to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_usb_sg_cancel, i32 0, i32 0) }, section "___ksymtab_gpl+usb_sg_cancel", align 8
@__ksymtab_usb_get_descriptor = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i8, i8, i8*, i32)* @usb_get_descriptor to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_get_descriptor, i32 0, i32 0) }, section "___ksymtab_gpl+usb_get_descriptor", align 8
@__ksymtab_usb_string = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32, i8*, i64)* @usb_string to i64), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__kstrtab_usb_string, i32 0, i32 0) }, section "___ksymtab_gpl+usb_string", align 8
@__ksymtab_usb_get_status = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32, i32, i8*)* @usb_get_status to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_get_status, i32 0, i32 0) }, section "___ksymtab_gpl+usb_get_status", align 8
@__ksymtab_usb_clear_halt = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32)* @usb_clear_halt to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_clear_halt, i32 0, i32 0) }, section "___ksymtab_gpl+usb_clear_halt", align 8
@__ksymtab_usb_reset_endpoint = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*, i32)* @usb_reset_endpoint to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_reset_endpoint, i32 0, i32 0) }, section "___ksymtab_gpl+usb_reset_endpoint", align 8
@__ksymtab_usb_set_interface = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32, i32)* @usb_set_interface to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_usb_set_interface, i32 0, i32 0) }, section "___ksymtab_gpl+usb_set_interface", align 8
@__ksymtab_usb_reset_configuration = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*)* @usb_reset_configuration to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_reset_configuration, i32 0, i32 0) }, section "___ksymtab_gpl+usb_reset_configuration", align 8
@__ksymtab_usb_set_configuration = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32)* @usb_set_configuration to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_usb_set_configuration, i32 0, i32 0) }, section "___ksymtab_gpl+usb_set_configuration", align 8
@__ksymtab_usb_driver_set_configuration = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32)* @usb_driver_set_configuration to i64), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__kstrtab_usb_driver_set_configuration, i32 0, i32 0) }, section "___ksymtab_gpl+usb_driver_set_configuration", align 8
@__ksymtab_cdc_parse_cdc_header = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_cdc_parsed_header*, %struct.usb_interface*, i8*, i32)* @cdc_parse_cdc_header to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_cdc_parse_cdc_header, i32 0, i32 0) }, section "___ksymtab+cdc_parse_cdc_header", align 8
@__kstrtab_cdc_parse_cdc_header = internal constant [21 x i8] c"cdc_parse_cdc_header\00", section "__ksymtab_strings", align 1
@.str.25 = private unnamed_addr constant [23 x i8] c"skipping garbage byte\0A\00", align 1
@.str.26.218 = private unnamed_addr constant [18 x i8] c"skipping garbage\0A\00", align 1
@.str.27.219 = private unnamed_addr constant [46 x i8] c"More than one union descriptor, skipping ...\0A\00", align 1
@cdc_parse_cdc_header.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__func__.cdc_parse_cdc_header, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.222, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28.220, i32 0, i32 0), i8 116, i8 8, i8 0, i8 0 }, section "__verbose", align 8
@.str.28.220 = private unnamed_addr constant [44 x i8] c"Ignoring descriptor: type %02x, length %ud\0A\00", align 1
@__func__.cdc_parse_cdc_header = private unnamed_addr constant [21 x i8] c"cdc_parse_cdc_header\00", align 1
@.str.2.222 = private unnamed_addr constant [27 x i8] c"drivers/usb/core/message.c\00", align 1
@__kstrtab_usb_driver_set_configuration = internal constant [29 x i8] c"usb_driver_set_configuration\00", section "__ksymtab_strings", align 1
@.str.24.224 = private unnamed_addr constant [13 x i8] c"(&req->work)\00", align 1
@usb_driver_set_configuration.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@set_config_lock = internal global %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.42.232, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@set_config_list = internal global %struct.list_head { %struct.list_head* @set_config_list, %struct.list_head* @set_config_list }, align 8
@.str.42.232 = private unnamed_addr constant [16 x i8] c"set_config_lock\00", align 1
@.str.18.239 = private unnamed_addr constant [23 x i8] c"config 0 descriptor??\0A\00", align 1
@.str.19.242 = private unnamed_addr constant [44 x i8] c"new config #%d exceeds power limit by %dmA\0A\00", align 1
@.str.13.245 = private unnamed_addr constant [27 x i8] c"%s Failed to disable LPM\0A.\00", align 1
@__func__.usb_set_configuration = private unnamed_addr constant [22 x i8] c"usb_set_configuration\00", align 1
@.str.20.249 = private unnamed_addr constant [18 x i8] c"(&intf->reset_ws)\00", align 1
@usb_set_configuration.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.21.250 = private unnamed_addr constant [12 x i8] c"%d-%s:%d.%d\00", align 1
@usb_set_configuration.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.usb_set_configuration, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.222, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.22.259, i32 0, i32 0), i8 -119, i8 7, i8 0, i8 0 }, section "__verbose", align 8
@.str.22.259 = private unnamed_addr constant [38 x i8] c"adding %s (config #%d, interface %d)\0A\00", align 1
@.str.23.261 = private unnamed_addr constant [23 x i8] c"device_add(%s) --> %d\0A\00", align 1
@usb_string.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.usb_string, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.222, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.5.265, i32 0, i32 0), i8 71, i8 3, i8 0, i8 0 }, section "__verbose", align 8
@.str.5.265 = private unnamed_addr constant [49 x i8] c"wrong descriptor type %02x for string %d (\22%s\22)\0A\00", align 1
@__func__.usb_string = private unnamed_addr constant [11 x i8] c"usb_string\00", align 1
@_ctype = external constant [0 x i8], align 1
@.str.35.266 = private unnamed_addr constant [69 x i8] c"language id specifier not provided by device, defaulting to English\0A\00", align 1
@.str.36.267 = private unnamed_addr constant [36 x i8] c"string descriptor 0 read error: %d\0A\00", align 1
@usb_get_langid.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.usb_get_langid, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.222, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.37.268, i32 0, i32 0), i8 20, i8 3, i8 0, i8 0 }, section "__verbose", align 8
@.str.37.268 = private unnamed_addr constant [25 x i8] c"default language 0x%04x\0A\00", align 1
@__func__.usb_get_langid = private unnamed_addr constant [15 x i8] c"usb_get_langid\00", align 1
@usb_start_wait_urb.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.usb_start_wait_urb, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.222, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.29.277, i32 0, i32 0), i8 71, i8 0, i8 0, i8 0 }, section "__verbose", align 8
@.str.29.277 = private unnamed_addr constant [34 x i8] c"%s timed out on ep%d%s len=%u/%u\0A\00", align 1
@__func__.usb_start_wait_urb = private unnamed_addr constant [19 x i8] c"usb_start_wait_urb\00", align 1
@.str.34.278 = private unnamed_addr constant [9 x i8] c"&x->wait\00", align 1
@init_completion.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.41.283 = private unnamed_addr constant [43 x i8] c"Interface #%d referenced by multiple IADs\0A\00", align 1
@usb_disable_device.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.usb_disable_device, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.222, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.6.284, i32 0, i32 0), i8 -113, i8 4, i8 0, i8 0 }, section "__verbose", align 8
@.str.6.284 = private unnamed_addr constant [28 x i8] c"unregistering interface %s\0A\00", align 1
@usb_disable_device.descriptor.7 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.usb_disable_device, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.222, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.8.287, i32 0, i32 0), i8 -89, i8 4, i8 0, i8 0 }, section "__verbose", align 8
@.str.9.285 = private unnamed_addr constant [8 x i8] c"non-ep0\00", align 1
@.str.8.287 = private unnamed_addr constant [19 x i8] c"%s nuking %s URBs\0A\00", align 1
@__func__.usb_disable_device = private unnamed_addr constant [19 x i8] c"usb_disable_device\00", align 1
@__kstrtab_usb_set_configuration = internal constant [22 x i8] c"usb_set_configuration\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_reset_configuration = internal constant [24 x i8] c"usb_reset_configuration\00", section "__ksymtab_strings", align 1
@__func__.usb_reset_configuration = private unnamed_addr constant [24 x i8] c"usb_reset_configuration\00", align 1
@__kstrtab_usb_set_interface = internal constant [18 x i8] c"usb_set_interface\00", section "__ksymtab_strings", align 1
@usb_set_interface.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.usb_set_interface, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.222, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.11.292, i32 0, i32 0), i8 21, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.11.292 = private unnamed_addr constant [32 x i8] c"selecting invalid interface %d\0A\00", align 1
@.str.12.293 = private unnamed_addr constant [33 x i8] c"selecting invalid altsetting %d\0A\00", align 1
@__func__.usb_set_interface = private unnamed_addr constant [18 x i8] c"usb_set_interface\00", align 1
@.str.14.294 = private unnamed_addr constant [40 x i8] c"Not enough bandwidth for altsetting %d\0A\00", align 1
@usb_set_interface.descriptor.15 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.usb_set_interface, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.222, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.16.295, i32 0, i32 0), i8 72, i8 5, i8 0, i8 0 }, section "__verbose", align 8
@.str.16.295 = private unnamed_addr constant [43 x i8] c"manual set_interface for iface %d, alt %d\0A\00", align 1
@__kstrtab_usb_reset_endpoint = internal constant [19 x i8] c"usb_reset_endpoint\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_clear_halt = internal constant [15 x i8] c"usb_clear_halt\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_get_status = internal constant [15 x i8] c"usb_get_status\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_string = internal constant [11 x i8] c"usb_string\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_get_descriptor = internal constant [19 x i8] c"usb_get_descriptor\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_sg_cancel = internal constant [14 x i8] c"usb_sg_cancel\00", section "__ksymtab_strings", align 1
@.str.4.302 = private unnamed_addr constant [19 x i8] c"%s, unlink --> %d\0A\00", align 1
@__func__.usb_sg_cancel = private unnamed_addr constant [14 x i8] c"usb_sg_cancel\00", align 1
@__kstrtab_usb_sg_wait = internal constant [12 x i8] c"usb_sg_wait\00", section "__ksymtab_strings", align 1
@usb_sg_wait.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.usb_sg_wait, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.222, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.305, i32 0, i32 0), i8 36, i8 2, i8 0, i8 0 }, section "__verbose", align 8
@.str.3.305 = private unnamed_addr constant [19 x i8] c"%s, submit --> %d\0A\00", align 1
@__func__.usb_sg_wait = private unnamed_addr constant [12 x i8] c"usb_sg_wait\00", align 1
@__kstrtab_usb_sg_init = internal constant [12 x i8] c"usb_sg_init\00", section "__ksymtab_strings", align 1
@.str.306 = private unnamed_addr constant [20 x i8] c"&(&io->lock)->rlock\00", align 1
@usb_sg_init.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.32.311 = private unnamed_addr constant [39 x i8] c"dev %s ep%d%s scatterlist error %d/%d\0A\00", align 1
@__func__.sg_complete = private unnamed_addr constant [12 x i8] c"sg_complete\00", align 1
@__kstrtab_usb_bulk_msg = internal constant [13 x i8] c"usb_bulk_msg\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_interrupt_msg = internal constant [18 x i8] c"usb_interrupt_msg\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_control_msg = internal constant [16 x i8] c"usb_control_msg\00", section "__ksymtab_strings", align 1
@usb_bus_type = global %struct.bus_type { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18.951, i32 0, i32 0), i8* null, %struct.device* null, %struct.device_attribute* null, %struct.attribute_group** null, %struct.attribute_group** null, %struct.attribute_group** null, i32 (%struct.device*, %struct.device_driver*)* @usb_device_match, i32 (%struct.device*, %struct.kobj_uevent_env*)* @usb_uevent, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, %struct.dev_pm_ops* null, %struct.iommu_ops* null, %struct.subsys_private* null, %struct.lock_class_key zeroinitializer }, align 8
@usb_uevent.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.usb_uevent, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12.328, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.32.323, i32 0, i32 0), i8 85, i8 3, i8 0, i8 0 }, section "__verbose", align 8
@.str.32.323 = private unnamed_addr constant [26 x i8] c"usb %s: already deleted?\0A\00", align 1
@usb_uevent.descriptor.33 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.usb_uevent, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12.328, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.34.324, i32 0, i32 0), i8 89, i8 3, i8 0, i8 0 }, section "__verbose", align 8
@.str.34.324 = private unnamed_addr constant [22 x i8] c"usb %s: bus removed?\0A\00", align 1
@.str.35.325 = private unnamed_addr constant [17 x i8] c"PRODUCT=%x/%x/%x\00", align 1
@.str.36.326 = private unnamed_addr constant [14 x i8] c"TYPE=%d/%d/%d\00", align 1
@__func__.usb_uevent = private unnamed_addr constant [11 x i8] c"usb_uevent\00", align 1
@.str.12.328 = private unnamed_addr constant [26 x i8] c"drivers/usb/core/driver.c\00", align 1
@__ksymtab_usb_store_new_id = internal constant %struct.kernel_symbol { i64 ptrtoint (i64 (%struct.__wait_queue_head*, %struct.usb_device_id*, %struct.device_driver*, i8*, i64)* @usb_store_new_id to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_store_new_id, i32 0, i32 0) }, section "___ksymtab_gpl+usb_store_new_id", align 8
@__ksymtab_usb_show_dynids = internal constant %struct.kernel_symbol { i64 ptrtoint (i64 (%struct.__wait_queue_head*, i8*)* @usb_show_dynids to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_usb_show_dynids, i32 0, i32 0) }, section "___ksymtab_gpl+usb_show_dynids", align 8
@__ksymtab_usb_driver_claim_interface = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_driver*, %struct.usb_interface*, i8*)* @usb_driver_claim_interface to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab_usb_driver_claim_interface, i32 0, i32 0) }, section "___ksymtab_gpl+usb_driver_claim_interface", align 8
@__ksymtab_usb_driver_release_interface = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_driver*, %struct.usb_interface*)* @usb_driver_release_interface to i64), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__kstrtab_usb_driver_release_interface, i32 0, i32 0) }, section "___ksymtab_gpl+usb_driver_release_interface", align 8
@__ksymtab_usb_match_one_id = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_interface*, %struct.usb_device_id*)* @usb_match_one_id to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_match_one_id, i32 0, i32 0) }, section "___ksymtab_gpl+usb_match_one_id", align 8
@__ksymtab_usb_match_id = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_device_id* (%struct.usb_interface*, %struct.usb_device_id*)* @usb_match_id to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_match_id, i32 0, i32 0) }, section "___ksymtab_gpl+usb_match_id", align 8
@__ksymtab_usb_register_device_driver = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device_driver*, %struct.module*)* @usb_register_device_driver to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab_usb_register_device_driver, i32 0, i32 0) }, section "___ksymtab_gpl+usb_register_device_driver", align 8
@__ksymtab_usb_deregister_device_driver = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device_driver*)* @usb_deregister_device_driver to i64), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__kstrtab_usb_deregister_device_driver, i32 0, i32 0) }, section "___ksymtab_gpl+usb_deregister_device_driver", align 8
@__ksymtab_usb_register_driver = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_driver*, %struct.module*, i8*)* @usb_register_driver to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_usb_register_driver, i32 0, i32 0) }, section "___ksymtab_gpl+usb_register_driver", align 8
@__ksymtab_usb_deregister = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_driver*)* @usb_deregister to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_deregister, i32 0, i32 0) }, section "___ksymtab_gpl+usb_deregister", align 8
@__ksymtab_usb_enable_autosuspend = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*)* @usb_enable_autosuspend to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_usb_enable_autosuspend, i32 0, i32 0) }, section "___ksymtab_gpl+usb_enable_autosuspend", align 8
@__ksymtab_usb_disable_autosuspend = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*)* @usb_disable_autosuspend to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_disable_autosuspend, i32 0, i32 0) }, section "___ksymtab_gpl+usb_disable_autosuspend", align 8
@__ksymtab_usb_autopm_put_interface = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_interface*)* @usb_autopm_put_interface to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_autopm_put_interface, i32 0, i32 0) }, section "___ksymtab_gpl+usb_autopm_put_interface", align 8
@__ksymtab_usb_autopm_put_interface_async = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_interface*)* @usb_autopm_put_interface_async to i64), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__kstrtab_usb_autopm_put_interface_async, i32 0, i32 0) }, section "___ksymtab_gpl+usb_autopm_put_interface_async", align 8
@__ksymtab_usb_autopm_put_interface_no_suspend = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_interface*)* @usb_autopm_put_interface_no_suspend to i64), i8* getelementptr inbounds ([36 x i8], [36 x i8]* @__kstrtab_usb_autopm_put_interface_no_suspend, i32 0, i32 0) }, section "___ksymtab_gpl+usb_autopm_put_interface_no_suspend", align 8
@__ksymtab_usb_autopm_get_interface = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_interface*)* @usb_autopm_get_interface to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_autopm_get_interface, i32 0, i32 0) }, section "___ksymtab_gpl+usb_autopm_get_interface", align 8
@__ksymtab_usb_autopm_get_interface_async = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_interface*)* @usb_autopm_get_interface_async to i64), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__kstrtab_usb_autopm_get_interface_async, i32 0, i32 0) }, section "___ksymtab_gpl+usb_autopm_get_interface_async", align 8
@__ksymtab_usb_autopm_get_interface_no_resume = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_interface*)* @usb_autopm_get_interface_no_resume to i64), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @__kstrtab_usb_autopm_get_interface_no_resume, i32 0, i32 0) }, section "___ksymtab_gpl+usb_autopm_get_interface_no_resume", align 8
@__kstrtab_usb_autopm_get_interface_no_resume = internal constant [35 x i8] c"usb_autopm_get_interface_no_resume\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_autopm_get_interface_async = internal constant [31 x i8] c"usb_autopm_get_interface_async\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_autopm_get_interface = internal constant [25 x i8] c"usb_autopm_get_interface\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_autopm_put_interface_no_suspend = internal constant [36 x i8] c"usb_autopm_put_interface_no_suspend\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_autopm_put_interface_async = internal constant [31 x i8] c"usb_autopm_put_interface_async\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_autopm_put_interface = internal constant [25 x i8] c"usb_autopm_put_interface\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_disable_autosuspend = internal constant [24 x i8] c"usb_disable_autosuspend\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_enable_autosuspend = internal constant [23 x i8] c"usb_enable_autosuspend\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_deregister = internal constant [15 x i8] c"usb_deregister\00", section "__ksymtab_strings", align 1
@.str.10.363 = private unnamed_addr constant [41 x i8] c"\016%s: deregistering interface driver %s\0A\00", align 1
@driver_attr_remove_id = internal global %struct.driver_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.21.377, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device_driver*, i8*)* @remove_id_show, i64 (%struct.device_driver*, i8*, i64)* @remove_id_store }, align 8
@driver_attr_new_id = internal global %struct.driver_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20.368, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device_driver*, i8*)* @new_id_show, i64 (%struct.device_driver*, i8*, i64)* @new_id_store }, align 8
@.str.20.368 = private unnamed_addr constant [7 x i8] c"new_id\00", align 1
@.str.369 = private unnamed_addr constant [15 x i8] c"%x %x %x %x %x\00", align 1
@.str.1.375 = private unnamed_addr constant [16 x i8] c"%04x %04x %02x\0A\00", align 1
@.str.2.376 = private unnamed_addr constant [11 x i8] c"%04x %04x\0A\00", align 1
@.str.21.377 = private unnamed_addr constant [10 x i8] c"remove_id\00", align 1
@.str.22.378 = private unnamed_addr constant [6 x i8] c"%x %x\00", align 1
@__kstrtab_usb_register_driver = internal constant [20 x i8] c"usb_register_driver\00", section "__ksymtab_strings", align 1
@.str.7.382 = private unnamed_addr constant [35 x i8] c"&(&new_driver->dynids.lock)->rlock\00", align 1
@usb_register_driver.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.8.383 = private unnamed_addr constant [42 x i8] c"\016%s: registered new interface driver %s\0A\00", align 1
@.str.9.384 = private unnamed_addr constant [49 x i8] c"\013%s: error %d registering interface \09driver %s\0A\00", align 1
@usb_probe_interface.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.usb_probe_interface, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12.328, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12.957, i32 0, i32 0), i8 36, i8 1, i8 0, i8 0 }, section "__verbose", align 8
@__func__.usb_probe_interface = private unnamed_addr constant [20 x i8] c"usb_probe_interface\00", align 1
@.str.17.397 = private unnamed_addr constant [42 x i8] c"Interface %d is not authorized for usage\0A\00", align 1
@usb_probe_interface.descriptor.18 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.usb_probe_interface, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12.328, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.19.398, i32 0, i32 0), i8 58, i8 1, i8 0, i8 0 }, section "__verbose", align 8
@.str.19.398 = private unnamed_addr constant [13 x i8] c"%s - got id\0A\00", align 1
@.str.3.401 = private unnamed_addr constant [41 x i8] c"%s Failed to disable LPM for driver %s\0A.\00", align 1
@__kstrtab_usb_deregister_device_driver = internal constant [29 x i8] c"usb_deregister_device_driver\00", section "__ksymtab_strings", align 1
@.str.6.404 = private unnamed_addr constant [38 x i8] c"\016%s: deregistering device driver %s\0A\00", align 1
@__kstrtab_usb_register_device_driver = internal constant [27 x i8] c"usb_register_device_driver\00", section "__ksymtab_strings", align 1
@.str.4.407 = private unnamed_addr constant [39 x i8] c"\016%s: registered new device driver %s\0A\00", align 1
@.str.5.408 = private unnamed_addr constant [46 x i8] c"\013%s: error %d registering device \09driver %s\0A\00", align 1
@usb_probe_device.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.usb_probe_device, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12.328, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12.957, i32 0, i32 0), i8 -1, i8 0, i8 0, i8 0 }, section "__verbose", align 8
@__func__.usb_probe_device = private unnamed_addr constant [17 x i8] c"usb_probe_device\00", align 1
@__kstrtab_usb_match_id = internal constant [13 x i8] c"usb_match_id\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_match_one_id = internal constant [17 x i8] c"usb_match_one_id\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_driver_release_interface = internal constant [29 x i8] c"usb_driver_release_interface\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_driver_claim_interface = internal constant [27 x i8] c"usb_driver_claim_interface\00", section "__ksymtab_strings", align 1
@__func__.usb_driver_claim_interface = private unnamed_addr constant [27 x i8] c"usb_driver_claim_interface\00", align 1
@__kstrtab_usb_show_dynids = internal constant [16 x i8] c"usb_show_dynids\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_store_new_id = internal constant [17 x i8] c"usb_store_new_id\00", section "__ksymtab_strings", align 1
@usb_forced_unbind_intf.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.usb_forced_unbind_intf, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12.328, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.13.414, i32 0, i32 0), i8 0, i8 4, i8 0, i8 0 }, section "__verbose", align 8
@.str.13.414 = private unnamed_addr constant [15 x i8] c"forced unbind\0A\00", align 1
@__func__.usb_forced_unbind_intf = private unnamed_addr constant [23 x i8] c"usb_forced_unbind_intf\00", align 1
@.str.23.417 = private unnamed_addr constant [19 x i8] c"rebind failed: %d\0A\00", align 1
@.str.25.420 = private unnamed_addr constant [13 x i8] c"%s error %d\0A\00", align 1
@.str.26.421 = private unnamed_addr constant [13 x i8] c"reset_resume\00", align 1
@usb_resume_interface.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__func__.usb_resume_interface, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12.328, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.27.422, i32 0, i32 0), i8 -23, i8 4, i8 0, i8 0 }, section "__verbose", align 8
@.str.27.422 = private unnamed_addr constant [32 x i8] c"no reset_resume for driver %s?\0A\00", align 1
@.str.28.423 = private unnamed_addr constant [17 x i8] c"resume error %d\0A\00", align 1
@__func__.usb_resume_interface = private unnamed_addr constant [21 x i8] c"usb_resume_interface\00", align 1
@.str.24.424 = private unnamed_addr constant [18 x i8] c"suspend error %d\0A\00", align 1
@autosuspend_check.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.autosuspend_check, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12.328, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.29.433, i32 0, i32 0), i8 8, i8 7, i8 0, i8 0 }, section "__verbose", align 8
@.str.29.433 = private unnamed_addr constant [38 x i8] c"remote wakeup needed for autosuspend\0A\00", align 1
@autosuspend_check.descriptor.30 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.autosuspend_check, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12.328, i32 0, i32 0), i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.31.435, i32 0, i32 0), i8 19, i8 7, i8 0, i8 0 }, section "__verbose", align 8
@.str.31.435 = private unnamed_addr constant [36 x i8] c"HCD doesn't handle wakeup requests\0A\00", align 1
@__func__.autosuspend_check = private unnamed_addr constant [18 x i8] c"autosuspend_check\00", align 1
@.str.450 = private unnamed_addr constant [56 x i8] c"too many configurations: %d, using maximum allowed: %d\0A\00", align 1
@.str.1.451 = private unnamed_addr constant [19 x i8] c"no configurations\0A\00", align 1
@.str.2.454 = private unnamed_addr constant [50 x i8] c"unable to read config index %d descriptor/%s: %d\0A\00", align 1
@.str.3.455 = private unnamed_addr constant [6 x i8] c"start\00", align 1
@.str.4.456 = private unnamed_addr constant [26 x i8] c"chopping to %d config(s)\0A\00", align 1
@.str.5.457 = private unnamed_addr constant [60 x i8] c"config index %d descriptor too short (expected %i, got %i)\0A\00", align 1
@.str.6.458 = private unnamed_addr constant [46 x i8] c"unable to read config index %d descriptor/%s\0A\00", align 1
@.str.7.459 = private unnamed_addr constant [4 x i8] c"all\00", align 1
@.str.8.460 = private unnamed_addr constant [15 x i8] c"out of memory\0A\00", align 1
@.str.13.461 = private unnamed_addr constant [66 x i8] c"invalid descriptor for config index %d: type = 0x%X, length = %d\0A\00", align 1
@.str.14.462 = private unnamed_addr constant [66 x i8] c"config %d has too many interfaces: %d, using maximum allowed: %d\0A\00", align 1
@.str.15.463 = private unnamed_addr constant [53 x i8] c"config %d descriptor has %d excess byte%s, ignoring\0A\00", align 1
@.str.16.464 = private unnamed_addr constant [84 x i8] c"config %d has an invalid descriptor of length %d, skipping remainder of the config\0A\00", align 1
@.str.17.465 = private unnamed_addr constant [70 x i8] c"config %d has an invalid interface descriptor of length %d, skipping\0A\00", align 1
@.str.18.466 = private unnamed_addr constant [109 x i8] c"config %d has more interface descriptors, than it declares in bNumInterfaces, ignoring interface number: %d\0A\00", align 1
@.str.19.467 = private unnamed_addr constant [61 x i8] c"config %d has an invalid interface number: %d but max is %d\0A\00", align 1
@.str.20.468 = private unnamed_addr constant [85 x i8] c"found more Interface Association Descriptors than allocated for in configuration %d\0A\00", align 1
@.str.21.469 = private unnamed_addr constant [68 x i8] c"config %d contains an unexpected descriptor of type 0x%X, skipping\0A\00", align 1
@.str.22.470 = private unnamed_addr constant [73 x i8] c"config %d has %d interface%s, different from the descriptor's value: %d\0A\00", align 1
@.str.23.471 = private unnamed_addr constant [30 x i8] c"config %d has no interfaces?\0A\00", align 1
@.str.24.472 = private unnamed_addr constant [38 x i8] c"config %d has no interface number %d\0A\00", align 1
@.str.25.473 = private unnamed_addr constant [87 x i8] c"too many alternate settings for config %d interface %d: %d, using maximum allowed: %d\0A\00", align 1
@usb_parse_configuration.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.usb_parse_configuration, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.27.498, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.28.475, i32 0, i32 0), i8 -53, i8 2, i8 0, i8 0 }, section "__verbose", align 8
@.str.28.475 = private unnamed_addr constant [34 x i8] c"skipped %d descriptor%s after %s\0A\00", align 1
@.str.30.477 = private unnamed_addr constant [45 x i8] c"config %d interface %d has no altsetting %d\0A\00", align 1
@.str.33.478 = private unnamed_addr constant [73 x i8] c"Duplicate descriptor for config %d interface %d altsetting %d, skipping\0A\00", align 1
@usb_parse_interface.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.usb_parse_interface, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.27.498, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.28.475, i32 0, i32 0), i8 -22, i8 1, i8 0, i8 0 }, section "__verbose", align 8
@.str.35.480 = private unnamed_addr constant [92 x i8] c"too many endpoints for config %d interface %d altsetting %d: %d, using maximum allowed: %d\0A\00", align 1
@.str.36.481 = private unnamed_addr constant [120 x i8] c"config %d interface %d altsetting %d has %d endpoint descriptor%s, different from the interface descriptor's value: %d\0A\00", align 1
@.str.37.482 = private unnamed_addr constant [96 x i8] c"config %d interface %d altsetting %d has an invalid endpoint descriptor of length %d, skipping\0A\00", align 1
@.str.38.483 = private unnamed_addr constant [90 x i8] c"config %d interface %d altsetting %d has an invalid endpoint with address 0x%X, skipping\0A\00", align 1
@.str.39.484 = private unnamed_addr constant [91 x i8] c"config %d interface %d altsetting %d has a duplicate endpoint with address 0x%X, skipping\0A\00", align 1
@.str.40.489 = private unnamed_addr constant [96 x i8] c"config %d interface %d altsetting %d endpoint 0x%X has an invalid bInterval %d, changing to %d\0A\00", align 1
@.str.41.491 = private unnamed_addr constant [83 x i8] c"config %d interface %d altsetting %d endpoint 0x%X is Bulk; changing to Interrupt\0A\00", align 1
@high_speed_maxpacket_maxes = internal constant [4 x i16] [i16 64, i16 1024, i16 512, i16 1024], align 2
@low_speed_maxpacket_maxes = internal constant [4 x i16] [i16 8, i16 0, i16 0, i16 8], align 2
@full_speed_maxpacket_maxes = internal constant [4 x i16] [i16 64, i16 1023, i16 64, i16 64], align 2
@super_speed_maxpacket_maxes = internal constant [4 x i16] [i16 512, i16 1024, i16 1024, i16 1024], align 2
@.str.42.494 = private unnamed_addr constant [92 x i8] c"config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\0A\00", align 1
@.str.43.495 = private unnamed_addr constant [82 x i8] c"config %d interface %d altsetting %d bulk endpoint 0x%X has invalid maxpacket %d\0A\00", align 1
@usb_parse_endpoint.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.usb_parse_endpoint, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.27.498, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.28.475, i32 0, i32 0), i8 -101, i8 1, i8 0, i8 0 }, section "__verbose", align 8
@.str.44.496 = private unnamed_addr constant [9 x i8] c"endpoint\00", align 1
@__func__.usb_parse_endpoint = private unnamed_addr constant [19 x i8] c"usb_parse_endpoint\00", align 1
@.str.27.498 = private unnamed_addr constant [26 x i8] c"drivers/usb/core/config.c\00", align 1
@.str.45.499 = private unnamed_addr constant [104 x i8] c"No SuperSpeed endpoint companion for config %d  interface %d altsetting %d ep %d: using minimum values\0A\00", align 1
@.str.46.501 = private unnamed_addr constant [101 x i8] c"Control endpoint with bMaxBurst = %d in config %d interface %d altsetting %d ep %d: setting to zero\0A\00", align 1
@.str.47.502 = private unnamed_addr constant [91 x i8] c"Endpoint with bMaxBurst = %d in config %d interface %d altsetting %d ep %d: setting to 15\0A\00", align 1
@.str.48.505 = private unnamed_addr constant [99 x i8] c"%s endpoint with bmAttributes = %d in config %d interface %d altsetting %d ep %d: setting to zero\0A\00", align 1
@.str.51.506 = private unnamed_addr constant [106 x i8] c"Bulk endpoint with more than 65536 streams in config %d interface %d altsetting %d ep %d: setting to max\0A\00", align 1
@.str.52.507 = private unnamed_addr constant [90 x i8] c"Isoc endpoint has Mult of %d in config %d interface %d altsetting %d ep %d: setting to 3\0A\00", align 1
@.str.55.509 = private unnamed_addr constant [4 x i8] c"Int\00", align 1
@.str.53.510 = private unnamed_addr constant [103 x i8] c"%s endpoint with wBytesPerInterval of %d in config %d interface %d altsetting %d ep %d: setting to %d\0A\00", align 1
@.str.56.511 = private unnamed_addr constant [95 x i8] c"Invalid SuperSpeedPlus isoc endpoint companionfor config %d interface %d altsetting %d ep %d.\0A\00", align 1
@__func__.usb_parse_interface = private unnamed_addr constant [20 x i8] c"usb_parse_interface\00", align 1
@__func__.usb_parse_configuration = private unnamed_addr constant [24 x i8] c"usb_parse_configuration\00", align 1
@.str.9.521 = private unnamed_addr constant [30 x i8] c"unable to get BOS descriptor\0A\00", align 1
@.str.10.522 = private unnamed_addr constant [34 x i8] c"unable to get BOS descriptor set\0A\00", align 1
@.str.11.523 = private unnamed_addr constant [31 x i8] c"descriptor type invalid, skip\0A\00", align 1
@__ksymtab_usb_register_dev = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_interface*, %struct.usb_class_driver*)* @usb_register_dev to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_register_dev, i32 0, i32 0) }, section "___ksymtab_gpl+usb_register_dev", align 8
@__ksymtab_usb_deregister_dev = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_interface*, %struct.usb_class_driver*)* @usb_deregister_dev to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_deregister_dev, i32 0, i32 0) }, section "___ksymtab_gpl+usb_deregister_dev", align 8
@__kstrtab_usb_deregister_dev = internal constant [19 x i8] c"usb_deregister_dev\00", section "__ksymtab_strings", align 1
@usb_deregister_dev.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.usb_deregister_dev, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.3.531, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.6.525, i32 0, i32 0), i8 -25, i8 0, i8 0, i8 0 }, section "__verbose", align 8
@.str.6.525 = private unnamed_addr constant [19 x i8] c"removing %d minor\0A\00", align 1
@minor_rwsem = internal global %struct.rw_semaphore { %union.anon.3 zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rw_semaphore* @minor_rwsem to i8*), i64 8) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rw_semaphore* @minor_rwsem to i8*), i64 8) to %struct.list_head*) }, %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.9.528, i32 0, i32 0), i32 0, i64 0 } }, %struct.qspinlock zeroinitializer, %struct.task_struct* null, %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.10.529, i32 0, i32 0), i32 0, i64 0 } }, align 8
@usb_minors = internal global [256 x %struct.file_operations*] zeroinitializer, align 16
@usb_class = internal global %struct.usb_class* null, align 8
@.str.11.527 = private unnamed_addr constant [23 x i8] c"./include/linux/kref.h\00", align 1
@.str.9.528 = private unnamed_addr constant [22 x i8] c"minor_rwsem.wait_lock\00", align 1
@.str.10.529 = private unnamed_addr constant [12 x i8] c"minor_rwsem\00", align 1
@__func__.usb_deregister_dev = private unnamed_addr constant [19 x i8] c"usb_deregister_dev\00", align 1
@.str.3.531 = private unnamed_addr constant [24 x i8] c"drivers/usb/core/file.c\00", align 1
@__kstrtab_usb_register_dev = internal constant [17 x i8] c"usb_register_dev\00", section "__ksymtab_strings", align 1
@usb_register_dev.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.usb_register_dev, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.3.531, i32 0, i32 0), i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.4.532, i32 0, i32 0), i8 -76, i8 0, i8 0, i8 0 }, section "__verbose", align 8
@.str.4.532 = private unnamed_addr constant [37 x i8] c"looking for a minor, starting at %d\0A\00", align 1
@.str.5.533 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@__func__.usb_register_dev = private unnamed_addr constant [17 x i8] c"usb_register_dev\00", align 1
@.str.7.539 = private unnamed_addr constant [8 x i8] c"usbmisc\00", align 1
@init_usb_class.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.8.540 = private unnamed_addr constant [39 x i8] c"\013class_create failed for usb devices\0A\00", align 1
@usb_fops = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @noop_llseek, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @usb_open, i32 (%struct.file*, i8*)* null, i32 (%struct.inode*, %struct.file*)* null, i32 (%struct.file*, i64, i64, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**, i8**)* null, i64 (%struct.file*, i32, i64, i64)* null, void (%struct.seq_file*, %struct.file*)* null, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i32 (%struct.file*, i64, %struct.file*, i64, i64)* null, i64 (%struct.file*, i64, i64, %struct.file*, i64)* null }, align 8
@.str.1.549 = private unnamed_addr constant [42 x i8] c"\013Unable to get major %d for usb devices\0A\00", align 1
@pool_max = internal global [4 x i64] [i64 32, i64 128, i64 512, i64 2048], align 16
@.str.556 = private unnamed_addr constant [10 x i8] c"buffer-%d\00", align 1
@.str.1.564 = private unnamed_addr constant [30 x i8] c"./include/linux/dma-mapping.h\00", align 1
@usb_device_groups = global [3 x %struct.attribute_group*] [%struct.attribute_group* @dev_attr_grp, %struct.attribute_group* @dev_string_attr_grp, %struct.attribute_group* null], align 16
@dev_attr_grp = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([28 x %struct.attribute*], [28 x %struct.attribute*]* @dev_attrs, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@dev_string_attr_grp = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* @dev_string_attrs_are_visible, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([4 x %struct.attribute*], [4 x %struct.attribute*]* @dev_string_attrs, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@dev_string_attrs = internal global [4 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_manufacturer, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_product, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_serial, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_manufacturer = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.48.577, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @manufacturer_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_product = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49.576, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @product_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_serial = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.50.573, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @serial_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.50.573 = private unnamed_addr constant [7 x i8] c"serial\00", align 1
@.str.49.576 = private unnamed_addr constant [8 x i8] c"product\00", align 1
@.str.48.577 = private unnamed_addr constant [13 x i8] c"manufacturer\00", align 1
@dev_attrs = internal global [28 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_configuration, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bNumInterfaces, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bConfigurationValue, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bmAttributes, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bMaxPower, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_urbnum, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_idVendor, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_idProduct, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bcdDevice, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bDeviceClass, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bDeviceSubClass, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bDeviceProtocol, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bNumConfigurations, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bMaxPacketSize0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_speed, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_busnum, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_devnum, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_devpath, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_version, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_maxchild, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_quirks, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_avoid_reset_quirk, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_authorized, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_remove, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_removable, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_ltm_capable, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_devspec, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_configuration = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.629, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @configuration_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bNumInterfaces = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.2.627, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @bNumInterfaces_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bConfigurationValue = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.4.626, i32 0, i32 0), i16 420, i8 1, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @bConfigurationValue_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @bConfigurationValue_store }, align 8
@dev_attr_bmAttributes = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.5.701, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @bmAttributes_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bMaxPower = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.9.621, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @bMaxPower_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_urbnum = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.11.618, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @urbnum_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_idVendor = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.13.617, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @idVendor_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_idProduct = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.15.616, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @idProduct_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bcdDevice = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.16.614, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @bcdDevice_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bDeviceClass = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.17.613, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @bDeviceClass_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bDeviceSubClass = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.19.612, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @bDeviceSubClass_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bDeviceProtocol = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.20.610, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @bDeviceProtocol_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bNumConfigurations = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.21.609, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @bNumConfigurations_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bMaxPacketSize0 = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.22.608, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @bMaxPacketSize0_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_speed = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.23.602, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @speed_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_busnum = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.30.601, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @busnum_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_devnum = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.31.600, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @devnum_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_devpath = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.32.599, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @devpath_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_version = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.33.597, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @version_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_maxchild = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.35.596, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @maxchild_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_quirks = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.36.594, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @quirks_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_avoid_reset_quirk = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.38.591, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @avoid_reset_quirk_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @avoid_reset_quirk_store }, align 8
@dev_attr_authorized = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.39.589, i32 0, i32 0), i16 420, i8 1, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @authorized_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @authorized_store }, align 8
@dev_attr_remove = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.40.587, i32 0, i32 0), i16 128, i8 1, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* null, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @remove_store }, align 8
@dev_attr_removable = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.41.584, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @removable_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_ltm_capable = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.43.580, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @ltm_capable_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_devspec = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.46.578, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @devspec_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.46.578 = private unnamed_addr constant [8 x i8] c"devspec\00", align 1
@.str.47.579 = private unnamed_addr constant [10 x i8] c"<no-node>\00", align 1
@.str.43.580 = private unnamed_addr constant [12 x i8] c"ltm_capable\00", align 1
@.str.44.582 = private unnamed_addr constant [4 x i8] c"yes\00", align 1
@.str.45.583 = private unnamed_addr constant [3 x i8] c"no\00", align 1
@.str.41.584 = private unnamed_addr constant [10 x i8] c"removable\00", align 1
@.str.42.586 = private unnamed_addr constant [6 x i8] c"fixed\00", align 1
@.str.40.587 = private unnamed_addr constant [7 x i8] c"remove\00", align 1
@.str.39.589 = private unnamed_addr constant [11 x i8] c"authorized\00", align 1
@.str.5.590 = private unnamed_addr constant [4 x i8] c"%u\0A\00", align 1
@.str.38.591 = private unnamed_addr constant [18 x i8] c"avoid_reset_quirk\00", align 1
@.str.6.592 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.12.593 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.36.594 = private unnamed_addr constant [7 x i8] c"quirks\00", align 1
@.str.37.595 = private unnamed_addr constant [6 x i8] c"0x%x\0A\00", align 1
@.str.35.596 = private unnamed_addr constant [9 x i8] c"maxchild\00", align 1
@.str.33.597 = private unnamed_addr constant [8 x i8] c"version\00", align 1
@.str.34.598 = private unnamed_addr constant [10 x i8] c"%2x.%02x\0A\00", align 1
@.str.32.599 = private unnamed_addr constant [8 x i8] c"devpath\00", align 1
@.str.31.600 = private unnamed_addr constant [7 x i8] c"devnum\00", align 1
@.str.30.601 = private unnamed_addr constant [7 x i8] c"busnum\00", align 1
@.str.23.602 = private unnamed_addr constant [6 x i8] c"speed\00", align 1
@.str.22.608 = private unnamed_addr constant [16 x i8] c"bMaxPacketSize0\00", align 1
@.str.21.609 = private unnamed_addr constant [19 x i8] c"bNumConfigurations\00", align 1
@.str.20.610 = private unnamed_addr constant [16 x i8] c"bDeviceProtocol\00", align 1
@.str.19.612 = private unnamed_addr constant [16 x i8] c"bDeviceSubClass\00", align 1
@.str.17.613 = private unnamed_addr constant [13 x i8] c"bDeviceClass\00", align 1
@.str.16.614 = private unnamed_addr constant [10 x i8] c"bcdDevice\00", align 1
@.str.15.616 = private unnamed_addr constant [10 x i8] c"idProduct\00", align 1
@.str.13.617 = private unnamed_addr constant [9 x i8] c"idVendor\00", align 1
@.str.11.618 = private unnamed_addr constant [7 x i8] c"urbnum\00", align 1
@.str.9.621 = private unnamed_addr constant [10 x i8] c"bMaxPower\00", align 1
@.str.10.623 = private unnamed_addr constant [6 x i8] c"%dmA\0A\00", align 1
@.str.8.625 = private unnamed_addr constant [5 x i8] c"%2x\0A\00", align 1
@.str.4.626 = private unnamed_addr constant [20 x i8] c"bConfigurationValue\00", align 1
@.str.2.627 = private unnamed_addr constant [15 x i8] c"bNumInterfaces\00", align 1
@.str.3.628 = private unnamed_addr constant [5 x i8] c"%2d\0A\00", align 1
@.str.629 = private unnamed_addr constant [14 x i8] c"configuration\00", align 1
@usb_interface_groups = global [3 x %struct.attribute_group*] [%struct.attribute_group* @intf_attr_grp, %struct.attribute_group* @intf_assoc_attr_grp, %struct.attribute_group* null], align 16
@intf_attr_grp = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([10 x %struct.attribute*], [10 x %struct.attribute*]* @intf_attrs, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@intf_assoc_attr_grp = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* @intf_assoc_attrs_are_visible, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([6 x %struct.attribute*], [6 x %struct.attribute*]* @intf_assoc_attrs, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@intf_assoc_attrs = internal global [6 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_iad_bFirstInterface, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_iad_bInterfaceCount, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_iad_bFunctionClass, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_iad_bFunctionSubClass, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_iad_bFunctionProtocol, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_iad_bFirstInterface = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.74.637, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @iad_bFirstInterface_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_iad_bInterfaceCount = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.75.635, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @iad_bInterfaceCount_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_iad_bFunctionClass = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.77.634, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @iad_bFunctionClass_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_iad_bFunctionSubClass = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.78.633, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @iad_bFunctionSubClass_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_iad_bFunctionProtocol = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.79.632, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @iad_bFunctionProtocol_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.79.632 = private unnamed_addr constant [22 x i8] c"iad_bFunctionProtocol\00", align 1
@.str.78.633 = private unnamed_addr constant [22 x i8] c"iad_bFunctionSubClass\00", align 1
@.str.77.634 = private unnamed_addr constant [19 x i8] c"iad_bFunctionClass\00", align 1
@.str.75.635 = private unnamed_addr constant [20 x i8] c"iad_bInterfaceCount\00", align 1
@.str.76.636 = private unnamed_addr constant [6 x i8] c"%02d\0A\00", align 1
@.str.74.637 = private unnamed_addr constant [20 x i8] c"iad_bFirstInterface\00", align 1
@intf_attrs = internal global [10 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bInterfaceNumber, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bAlternateSetting, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bNumEndpoints, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bInterfaceClass, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bInterfaceSubClass, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bInterfaceProtocol, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_modalias, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_supports_autosuspend, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_interface_authorized, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_bInterfaceNumber = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.65.648, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @bInterfaceNumber_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bAlternateSetting = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.66.647, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @bAlternateSetting_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bNumEndpoints = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.67.646, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @bNumEndpoints_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bInterfaceClass = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.68.645, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @bInterfaceClass_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bInterfaceSubClass = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.69.644, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @bInterfaceSubClass_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bInterfaceProtocol = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.70.643, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @bInterfaceProtocol_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_modalias = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.71.640, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @modalias_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_supports_autosuspend = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.73.639, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @supports_autosuspend_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_interface_authorized = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.39.589, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @interface_authorized_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @interface_authorized_store }, align 8
@.str.73.639 = private unnamed_addr constant [21 x i8] c"supports_autosuspend\00", align 1
@.str.71.640 = private unnamed_addr constant [9 x i8] c"modalias\00", align 1
@.str.72.642 = private unnamed_addr constant [65 x i8] c"usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02Xin%02X\0A\00", align 1
@.str.70.643 = private unnamed_addr constant [19 x i8] c"bInterfaceProtocol\00", align 1
@.str.69.644 = private unnamed_addr constant [19 x i8] c"bInterfaceSubClass\00", align 1
@.str.68.645 = private unnamed_addr constant [16 x i8] c"bInterfaceClass\00", align 1
@.str.67.646 = private unnamed_addr constant [14 x i8] c"bNumEndpoints\00", align 1
@.str.66.647 = private unnamed_addr constant [18 x i8] c"bAlternateSetting\00", align 1
@.str.65.648 = private unnamed_addr constant [17 x i8] c"bInterfaceNumber\00", align 1
@dev_bin_attr_descriptors = internal global %struct.bin_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.51.667, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 65553, i8* null, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)* @read_descriptors, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)* null, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* null }, align 8
@dev_attr_persist = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.52.653, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @persist_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @persist_store }, align 8
@power_group_name = external constant [0 x i8], align 1
@.str.52.653 = private unnamed_addr constant [8 x i8] c"persist\00", align 1
@usb2_hardware_lpm_attr_group = internal global %struct.attribute_group { i8* getelementptr inbounds ([0 x i8], [0 x i8]* @power_group_name, i32 0, i32 0), i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([4 x %struct.attribute*], [4 x %struct.attribute*]* @usb2_hardware_lpm_attr, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@power_attr_group = internal global %struct.attribute_group { i8* getelementptr inbounds ([0 x i8], [0 x i8]* @power_group_name, i32 0, i32 0), i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([5 x %struct.attribute*], [5 x %struct.attribute*]* @power_attrs, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@power_attrs = internal global [5 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_autosuspend, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_level, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_connected_duration, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_active_duration, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_autosuspend = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.53.658, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @autosuspend_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @autosuspend_store }, align 8
@dev_attr_level = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.54.656, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @level_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @level_store }, align 8
@dev_attr_connected_duration = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.56.655, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @connected_duration_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_active_duration = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.57.654, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @active_duration_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.57.654 = private unnamed_addr constant [16 x i8] c"active_duration\00", align 1
@.str.56.655 = private unnamed_addr constant [19 x i8] c"connected_duration\00", align 1
@.str.54.656 = private unnamed_addr constant [6 x i8] c"level\00", align 1
@on_string = internal constant [3 x i8] c"on\00", align 1
@warn_level.level_warned = internal global i32 0, align 4
@.str.55.657 = private unnamed_addr constant [65 x i8] c"\014WARNING! power/level is deprecated; use power/control instead\0A\00", align 1
@.str.53.658 = private constant [12 x i8] c"autosuspend\00", align 1
@usb2_hardware_lpm_attr = internal global [4 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_usb2_hardware_lpm, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_usb2_lpm_l1_timeout, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_usb2_lpm_besl, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_usb2_hardware_lpm = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.58.661, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @usb2_hardware_lpm_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @usb2_hardware_lpm_store }, align 8
@dev_attr_usb2_lpm_l1_timeout = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.61.660, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @usb2_lpm_l1_timeout_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @usb2_lpm_l1_timeout_store }, align 8
@dev_attr_usb2_lpm_besl = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.62.659, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @usb2_lpm_besl_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @usb2_lpm_besl_store }, align 8
@.str.62.659 = private unnamed_addr constant [14 x i8] c"usb2_lpm_besl\00", align 1
@.str.61.660 = private unnamed_addr constant [20 x i8] c"usb2_lpm_l1_timeout\00", align 1
@.str.58.661 = private unnamed_addr constant [18 x i8] c"usb2_hardware_lpm\00", align 1
@.str.59.662 = private unnamed_addr constant [8 x i8] c"enabled\00", align 1
@.str.60.663 = private unnamed_addr constant [9 x i8] c"disabled\00", align 1
@usb3_hardware_lpm_attr_group = internal global %struct.attribute_group { i8* getelementptr inbounds ([0 x i8], [0 x i8]* @power_group_name, i32 0, i32 0), i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([3 x %struct.attribute*], [3 x %struct.attribute*]* @usb3_hardware_lpm_attr, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@usb3_hardware_lpm_attr = internal global [3 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_usb3_hardware_lpm_u1, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_usb3_hardware_lpm_u2, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_usb3_hardware_lpm_u1 = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.63.666, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @usb3_hardware_lpm_u1_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_usb3_hardware_lpm_u2 = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.64.665, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @usb3_hardware_lpm_u2_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.64.665 = private unnamed_addr constant [21 x i8] c"usb3_hardware_lpm_u2\00", align 1
@.str.63.666 = private unnamed_addr constant [21 x i8] c"usb3_hardware_lpm_u1\00", align 1
@.str.51.667 = private unnamed_addr constant [12 x i8] c"descriptors\00", align 1
@dev_attr_interface = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.80.670, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @interface_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.80.670 = private unnamed_addr constant [10 x i8] c"interface\00", align 1
@usb_ep_device_type = global { i8*, %struct.attribute_group**, i32 (%struct.device.3441*, %struct.kobj_uevent_env*)*, i8* (%struct.device.3441*, i16*, %struct.atomic_t*, %struct.atomic_t*)*, void (%struct.device.3441*)*, %struct.dev_pm_ops.3461* } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.673, i32 0, i32 0), %struct.attribute_group** null, i32 (%struct.device.3441*, %struct.kobj_uevent_env*)* null, i8* (%struct.device.3441*, i16*, %struct.atomic_t*, %struct.atomic_t*)* null, void (%struct.device.3441*)* @ep_device_release, %struct.dev_pm_ops.3461* null }, align 8
@.str.673 = private unnamed_addr constant [13 x i8] c"usb_endpoint\00", align 1
@ep_dev_groups = internal global [2 x %struct.attribute_group*] [%struct.attribute_group* @ep_dev_attr_grp, %struct.attribute_group* null], align 16
@.str.1.677 = private unnamed_addr constant [8 x i8] c"ep_%02x\00", align 1
@ep_dev_attr_grp = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([9 x %struct.attribute*], [9 x %struct.attribute*]* @ep_dev_attrs, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@ep_dev_attrs = internal global [9 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute.3462, %struct.device_attribute.3462* @dev_attr_bLength, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute.3462, %struct.device_attribute.3462* @dev_attr_bEndpointAddress, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute.3462, %struct.device_attribute.3462* @dev_attr_bmAttributes.679, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute.3462, %struct.device_attribute.3462* @dev_attr_bInterval, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute.3462, %struct.device_attribute.3462* @dev_attr_wMaxPacketSize, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute.3462, %struct.device_attribute.3462* @dev_attr_interval, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute.3462, %struct.device_attribute.3462* @dev_attr_type, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute.3462, %struct.device_attribute.3462* @dev_attr_direction, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_bLength = internal global %struct.device_attribute.3462 { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.2.704, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*)* @bLength_show, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*, i64)* null }, align 8
@dev_attr_bEndpointAddress = internal global %struct.device_attribute.3462 { %struct.attribute { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.4.703, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*)* @bEndpointAddress_show, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*, i64)* null }, align 8
@dev_attr_bmAttributes.679 = internal global %struct.device_attribute.3462 { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.5.701, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*)* @bmAttributes_show.702, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*, i64)* null }, align 8
@dev_attr_bInterval = internal global %struct.device_attribute.3462 { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.6.699, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*)* @bInterval_show, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*, i64)* null }, align 8
@dev_attr_wMaxPacketSize = internal global %struct.device_attribute.3462 { %struct.attribute { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.7.696, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*)* @wMaxPacketSize_show, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*, i64)* null }, align 8
@dev_attr_interval = internal global %struct.device_attribute.3462 { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.694, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*)* @interval_show, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*, i64)* null }, align 8
@dev_attr_type = internal global %struct.device_attribute.3462 { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.11.687, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*)* @type_show, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*, i64)* null }, align 8
@dev_attr_direction = internal global %struct.device_attribute.3462 { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.18.680, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*)* @direction_show, i64 (%struct.device.3441*, %struct.device_attribute.3462*, i8*, i64)* null }, align 8
@.str.18.680 = private unnamed_addr constant [10 x i8] c"direction\00", align 1
@.str.19.685 = private unnamed_addr constant [5 x i8] c"both\00", align 1
@.str.11.687 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.13.690 = private unnamed_addr constant [8 x i8] c"Control\00", align 1
@.str.16.693 = private unnamed_addr constant [10 x i8] c"Interrupt\00", align 1
@.str.9.694 = private unnamed_addr constant [9 x i8] c"interval\00", align 1
@.str.10.695 = private unnamed_addr constant [7 x i8] c"%d%cs\0A\00", align 1
@.str.7.696 = private unnamed_addr constant [15 x i8] c"wMaxPacketSize\00", align 1
@.str.8.698 = private unnamed_addr constant [6 x i8] c"%04x\0A\00", align 1
@.str.6.699 = private unnamed_addr constant [10 x i8] c"bInterval\00", align 1
@.str.3.700 = private unnamed_addr constant [6 x i8] c"%02x\0A\00", align 1
@.str.5.701 = private unnamed_addr constant [13 x i8] c"bmAttributes\00", align 1
@.str.4.703 = private unnamed_addr constant [17 x i8] c"bEndpointAddress\00", align 1
@.str.2.704 = private unnamed_addr constant [8 x i8] c"bLength\00", align 1
@usbfs_mutex = global %struct.mutex { %union.anon.3 zeroinitializer, %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.708, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.qspinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usbfs_mutex to i8*), i64 88) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usbfs_mutex to i8*), i64 88) to %struct.list_head*) }, i8* bitcast (%struct.mutex* @usbfs_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.1.709, i32 0, i32 0), i32 0, i64 0 } }, align 8
@.str.708 = private unnamed_addr constant [22 x i8] c"usbfs_mutex.wait_lock\00", align 1
@.str.1.709 = private unnamed_addr constant [12 x i8] c"usbfs_mutex\00", align 1
@usbfs_driver = global %struct.usb_driver { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2.712, i32 0, i32 0), i32 (%struct.usb_interface*, %struct.usb_device_id*)* @driver_probe, void (%struct.usb_interface*)* @driver_disconnect, i32 (%struct.usb_interface*, i32, i8*)* null, i32 (%struct.usb_interface*, i32)* @driver_suspend, i32 (%struct.usb_interface*)* @driver_resume, i32 (%struct.usb_interface*)* null, i32 (%struct.usb_interface*)* null, i32 (%struct.usb_interface*)* null, %struct.usb_device_id* null, %struct.__wait_queue_head zeroinitializer, %struct.usbdrv_wrap zeroinitializer, i8 0 }, align 8
@.str.2.712 = private unnamed_addr constant [6 x i8] c"usbfs\00", align 1
@.str.6.715 = private unnamed_addr constant [34 x i8] c"interface number %u out of range\0A\00", align 1
@usbdev_file_operations = constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @no_seek_end_llseek, i64 (%struct.file*, i8*, i64, i64*)* @usbdev_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @usbdev_poll, i64 (%struct.file*, i32, i64)* @usbdev_ioctl, i64 (%struct.file*, i32, i64)* @usbdev_compat_ioctl, i32 (%struct.file*, %struct.vm_area_struct*)* @usbdev_mmap, i32 (%struct.inode*, %struct.file*)* @usbdev_open, i32 (%struct.file*, i8*)* null, i32 (%struct.inode*, %struct.file*)* @usbdev_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**, i8**)* null, i64 (%struct.file*, i32, i64, i64)* null, void (%struct.seq_file*, %struct.file*)* null, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i32 (%struct.file*, i64, %struct.file*, i64, i64)* null, i64 (%struct.file*, i64, i64, %struct.file*, i64)* null }, align 8
@usbfs_memory_usage = internal global %union.anon.3 zeroinitializer, align 8
@.str.37.737 = private unnamed_addr constant [30 x i8] c"./include/linux/scatterlist.h\00", align 1
@.str.38.738 = private unnamed_addr constant [23 x i8] c"./include/linux/cred.h\00", align 1
@.str.68.741 = private unnamed_addr constant [20 x i8] c"&(&ps->lock)->rlock\00", align 1
@usbdev_open.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.70.742 = private unnamed_addr constant [10 x i8] c"&ps->wait\00", align 1
@usbdev_open.__key.69 = internal global %struct.lock_class_key zeroinitializer, align 1
@usbfs_snoop = internal global i8 0, align 1
@.str.71.744 = private unnamed_addr constant [26 x i8] c"opened by process %d: %s\0A\00", align 1
@usbdev_vm_ops = internal global %struct.vm_operations_struct { void (%struct.vm_area_struct*)* @usbdev_vm_open, void (%struct.vm_area_struct*)* @usbdev_vm_close, i32 (%struct.vm_area_struct*)* null, i32 (%struct.vm_fault*)* null, i32 (%struct.vm_fault*, i32)* null, void (%struct.vm_fault*, i64, i64)* null, i32 (%struct.vm_fault*)* null, i32 (%struct.vm_fault*)* null, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)* null, i8* (%struct.vm_area_struct*)* null, i32 (%struct.vm_area_struct*, %struct.mempolicy*)* null, %struct.mempolicy* (%struct.vm_area_struct*, i64)* null, %struct.page* (%struct.vm_area_struct*, i64)* null }, align 8
@usbfs_memory_mb = internal global i32 16, align 4
@.str.9.747 = private unnamed_addr constant [13 x i8] c"%s: REAPURB\0A\00", align 1
@__func__.usbdev_do_ioctl = private unnamed_addr constant [16 x i8] c"usbdev_do_ioctl\00", align 1
@.str.10.748 = private unnamed_addr constant [19 x i8] c"%s: REAPURBNDELAY\0A\00", align 1
@.str.11.749 = private unnamed_addr constant [15 x i8] c"%s: REAPURB32\0A\00", align 1
@.str.12.750 = private unnamed_addr constant [21 x i8] c"%s: REAPURBNDELAY32\0A\00", align 1
@.str.13.751 = private unnamed_addr constant [13 x i8] c"%s: CONTROL\0A\00", align 1
@.str.14.752 = private unnamed_addr constant [10 x i8] c"%s: BULK\0A\00", align 1
@.str.15.753 = private unnamed_addr constant [13 x i8] c"%s: RESETEP\0A\00", align 1
@.str.16.754 = private unnamed_addr constant [11 x i8] c"%s: RESET\0A\00", align 1
@.str.17.755 = private unnamed_addr constant [16 x i8] c"%s: CLEAR_HALT\0A\00", align 1
@.str.18.756 = private unnamed_addr constant [15 x i8] c"%s: GETDRIVER\0A\00", align 1
@.str.19.757 = private unnamed_addr constant [17 x i8] c"%s: CONNECTINFO\0A\00", align 1
@.str.20.758 = private unnamed_addr constant [18 x i8] c"%s: SETINTERFACE\0A\00", align 1
@.str.21.759 = private unnamed_addr constant [22 x i8] c"%s: SETCONFIGURATION\0A\00", align 1
@.str.22.760 = private unnamed_addr constant [15 x i8] c"%s: SUBMITURB\0A\00", align 1
@.str.23.761 = private unnamed_addr constant [15 x i8] c"%s: CONTROL32\0A\00", align 1
@.str.24.762 = private unnamed_addr constant [12 x i8] c"%s: BULK32\0A\00", align 1
@.str.25.763 = private unnamed_addr constant [18 x i8] c"%s: DISCSIGNAL32\0A\00", align 1
@.str.26.764 = private unnamed_addr constant [17 x i8] c"%s: SUBMITURB32\0A\00", align 1
@.str.27.765 = private unnamed_addr constant [13 x i8] c"%s: IOCTL32\0A\00", align 1
@.str.28.766 = private unnamed_addr constant [19 x i8] c"%s: DISCARDURB %p\0A\00", align 1
@.str.29.767 = private unnamed_addr constant [16 x i8] c"%s: DISCSIGNAL\0A\00", align 1
@.str.30.768 = private unnamed_addr constant [20 x i8] c"%s: CLAIMINTERFACE\0A\00", align 1
@.str.31.769 = private unnamed_addr constant [22 x i8] c"%s: RELEASEINTERFACE\0A\00", align 1
@.str.32.770 = private unnamed_addr constant [11 x i8] c"%s: IOCTL\0A\00", align 1
@.str.33.771 = private unnamed_addr constant [16 x i8] c"%s: CLAIM_PORT\0A\00", align 1
@.str.34.772 = private unnamed_addr constant [18 x i8] c"%s: RELEASE_PORT\0A\00", align 1
@.str.36.775 = private unnamed_addr constant [25 x i8] c"drivers/usb/core/devio.c\00", align 1
@.str.43.776 = private unnamed_addr constant [62 x i8] c"usbfs: process %d (%s) did not claim interface %u before use\0A\00", align 1
@proc_disconnect_claim.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.proc_disconnect_claim, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.66.778, i32 0, i32 0), i8 -18, i8 8, i8 0, i8 0 }, section "__verbose", align 8
@.str.66.778 = private unnamed_addr constant [21 x i8] c"disconnect by usbfs\0A\00", align 1
@__func__.proc_disconnect_claim = private unnamed_addr constant [22 x i8] c"proc_disconnect_claim\00", align 1
@.str.67.780 = private unnamed_addr constant [35 x i8] c"port %d claimed by process %d: %s\0A\00", align 1
@proc_ioctl.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.proc_ioctl, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.66.778, i32 0, i32 0), i8 103, i8 8, i8 0, i8 0 }, section "__verbose", align 8
@__func__.proc_ioctl = private unnamed_addr constant [11 x i8] c"proc_ioctl\00", align 1
@proc_ioctl_compat.__warned = internal global i8 0, section ".data.unlikely", align 1
@__preempt_count = external global i32, align 4
@.str.39.782 = private unnamed_addr constant [83 x i8] c"control urb: bRequestType=%02x bRequest=%02x wValue=%04x wIndex=%04x wLength=%04x\0A\00", align 1
@proc_do_submiturb.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.40.793 = private unnamed_addr constant [3 x i8] c"\017\00", align 1
@.str.63.794 = private unnamed_addr constant [35 x i8] c"usbfs: usb_submit_urb returned %d\0A\00", align 1
@usbfs_snoop_max = internal global i32 65536, align 4
@.str.54.795 = private unnamed_addr constant [7 x i8] c"data: \00", align 1
@snoop_urb.types = internal global [4 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.44.802, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.45.803, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46.804, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47.805, i32 0, i32 0)], align 16
@snoop_urb.dirs = internal global [2 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.48.800, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.49.801, i32 0, i32 0)], align 16
@.str.50.796 = private unnamed_addr constant [35 x i8] c"userurb %p, ep%d %s-%s, length %u\0A\00", align 1
@.str.51.797 = private unnamed_addr constant [52 x i8] c"userurb %p, ep%d %s-%s, actual_length %u status %d\0A\00", align 1
@.str.52.798 = private unnamed_addr constant [35 x i8] c"ep%d %s-%s, length %u, timeout %d\0A\00", align 1
@.str.53.799 = private unnamed_addr constant [41 x i8] c"ep%d %s-%s, actual_length %u, status %d\0A\00", align 1
@.str.48.800 = private unnamed_addr constant [4 x i8] c"out\00", align 1
@.str.49.801 = private unnamed_addr constant [3 x i8] c"in\00", align 1
@.str.44.802 = private unnamed_addr constant [5 x i8] c"isoc\00", align 1
@.str.45.803 = private unnamed_addr constant [4 x i8] c"int\00", align 1
@.str.46.804 = private unnamed_addr constant [5 x i8] c"ctrl\00", align 1
@.str.47.805 = private unnamed_addr constant [5 x i8] c"bulk\00", align 1
@.str.64.807 = private unnamed_addr constant [14 x i8] c"urb complete\0A\00", align 1
@.str.42.809 = private unnamed_addr constant [55 x i8] c"%s: process %i (%s) requesting ep %02x but needs %02x\0A\00", align 1
@__func__.check_ctrlrecip = private unnamed_addr constant [16 x i8] c"check_ctrlrecip\00", align 1
@get_urb32.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.60.810 = private unnamed_addr constant [62 x i8] c"usbfs: interface %d claimed by %s while '%s' sets config #%d\0A\00", align 1
@.str.59.811 = private unnamed_addr constant [11 x i8] c"CLEAR_HALT\00", align 1
@.str.57.812 = private unnamed_addr constant [63 x i8] c"Process %d (%s) called USBDEVFS_%s for active endpoint 0x%02x\0A\00", align 1
@.str.58.813 = private unnamed_addr constant [60 x i8] c"usbfs: interface %d claimed by %s while '%s' resets device\0A\00", align 1
@.str.56.814 = private unnamed_addr constant [8 x i8] c"RESETEP\00", align 1
@proc_bulk.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.55.816 = private unnamed_addr constant [22 x i8] c"./include/linux/usb.h\00", align 1
@proc_control.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.41.818 = private unnamed_addr constant [66 x i8] c"usbfs: USBDEVFS_CONTROL failed cmd %s rqt %u rq %u len %u ret %d\0A\00", align 1
@.str.35.819 = private unnamed_addr constant [9 x i8] c"reap %p\0A\00", align 1
@__param_usbfs_snoop = internal constant %struct.kernel_param { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__param_str_usbfs_snoop, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bool, i16 420, i8 -1, i8 0, %union.anon.51 { i8* @usbfs_snoop } }, section "__param", align 8
@__UNIQUE_ID_usbfs_snooptype18 = internal constant [26 x i8] c"parmtype=usbfs_snoop:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_usbfs_snoop19 = internal constant [47 x i8] c"parm=usbfs_snoop:true to log all usbfs traffic\00", section ".modinfo", align 1
@__param_usbfs_snoop_max = internal constant %struct.kernel_param { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__param_str_usbfs_snoop_max, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_uint, i16 420, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @usbfs_snoop_max to i8*) } }, section "__param", align 8
@__UNIQUE_ID_usbfs_snoop_maxtype20 = internal constant [30 x i8] c"parmtype=usbfs_snoop_max:uint\00", section ".modinfo", align 1
@__UNIQUE_ID_usbfs_snoop_max21 = internal constant [69 x i8] c"parm=usbfs_snoop_max:maximum number of bytes to print while snooping\00", section ".modinfo", align 1
@__param_usbfs_memory_mb = internal constant %struct.kernel_param { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__param_str_usbfs_memory_mb, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_uint, i16 420, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @usbfs_memory_mb to i8*) } }, section "__param", align 8
@__UNIQUE_ID_usbfs_memory_mbtype22 = internal constant [30 x i8] c"parmtype=usbfs_memory_mb:uint\00", section ".modinfo", align 1
@__UNIQUE_ID_usbfs_memory_mb23 = internal constant [73 x i8] c"parm=usbfs_memory_mb:maximum MB allowed for usbfs buffers (0 = no limit)\00", section ".modinfo", align 1
@__param_str_usbfs_memory_mb = internal constant [16 x i8] c"usbfs_memory_mb\00", align 16
@param_ops_uint = external constant %struct.kernel_param_ops, align 8
@__param_str_usbfs_snoop_max = internal constant [16 x i8] c"usbfs_snoop_max\00", align 16
@__param_str_usbfs_snoop = internal constant [12 x i8] c"usbfs_snoop\00", align 1
@.str.3.823 = private unnamed_addr constant [11 x i8] c"usb_device\00", align 1
@.str.4.824 = private unnamed_addr constant [44 x i8] c"\013Unable to register minors for usb_device\0A\00", align 1
@usb_device_cdev = internal global %struct.cdev zeroinitializer, align 8
@.str.5.825 = private unnamed_addr constant [37 x i8] c"\013Unable to get usb_device major %d\0A\00", align 1
@usbdev_nb = internal global %struct.notifier_block { i32 (%struct.notifier_block*, i64, i8*)* @usbdev_notify, %struct.notifier_block* null, i32 0 }, align 8
@__ksymtab_usb_register_notify = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.notifier_block*)* @usb_register_notify to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_usb_register_notify, i32 0, i32 0) }, section "___ksymtab_gpl+usb_register_notify", align 8
@__ksymtab_usb_unregister_notify = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.notifier_block*)* @usb_unregister_notify to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_usb_unregister_notify, i32 0, i32 0) }, section "___ksymtab_gpl+usb_unregister_notify", align 8
@__kstrtab_usb_unregister_notify = internal constant [22 x i8] c"usb_unregister_notify\00", section "__ksymtab_strings", align 1
@usb_notifier_list = internal global %struct.blocking_notifier_head { %struct.rw_semaphore { %union.anon.3 zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.blocking_notifier_head* @usb_notifier_list to i8*), i64 8) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.blocking_notifier_head* @usb_notifier_list to i8*), i64 8) to %struct.list_head*) }, %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.831, i32 0, i32 0), i32 0, i64 0 } }, %struct.qspinlock zeroinitializer, %struct.task_struct* null, %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1.832, i32 0, i32 0), i32 0, i64 0 } }, %struct.notifier_block* null }, align 8
@.str.831 = private unnamed_addr constant [36 x i8] c"(usb_notifier_list).rwsem.wait_lock\00", align 1
@.str.1.832 = private unnamed_addr constant [26 x i8] c"(usb_notifier_list).rwsem\00", align 1
@__kstrtab_usb_register_notify = internal constant [20 x i8] c"usb_register_notify\00", section "__ksymtab_strings", align 1
@usb_generic_driver = global %struct.usb_device_driver { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18.951, i32 0, i32 0), i32 (%struct.usb_device*)* @generic_probe, void (%struct.usb_device*)* @generic_disconnect, i32 (%struct.usb_device*, i32)* @generic_suspend, i32 (%struct.usb_device*, i32)* @generic_resume, %struct.usbdrv_wrap zeroinitializer, i8 1 }, align 8
@.str.8.842 = private unnamed_addr constant [36 x i8] c"Device is not authorized for usage\0A\00", align 1
@.str.9.845 = private unnamed_addr constant [32 x i8] c"can't set config #%d, error %d\0A\00", align 1
@.str.848 = private unnamed_addr constant [69 x i8] c"rejected %d configuration%s due to insufficient available bus power\0A\00", align 1
@usb_choose_configuration.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.usb_choose_configuration, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.852, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.3.849, i32 0, i32 0), i8 -105, i8 0, i8 0, i8 0 }, section "__verbose", align 8
@.str.3.849 = private unnamed_addr constant [43 x i8] c"configuration #%d chosen from %d choice%s\0A\00", align 1
@.str.4.850 = private unnamed_addr constant [42 x i8] c"no configuration chosen from %d choice%s\0A\00", align 1
@__func__.usb_choose_configuration = private unnamed_addr constant [25 x i8] c"usb_choose_configuration\00", align 1
@.str.2.852 = private unnamed_addr constant [27 x i8] c"drivers/usb/core/generic.c\00", align 1
@.str.7.854 = private unnamed_addr constant [2 x i8] c"s\00", align 1
@__ksymtab_usb_choose_configuration = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*)* @usb_choose_configuration to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_choose_configuration, i32 0, i32 0) }, section "___ksymtab_gpl+usb_choose_configuration", align 8
@__kstrtab_usb_choose_configuration = internal constant [25 x i8] c"usb_choose_configuration\00", section "__ksymtab_strings", align 1
@usb_quirk_list = internal constant [62 x %struct.usb_device_id] [%struct.usb_device_id { i16 3, i16 516, i16 24613, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 536, i16 1025, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 8 }, %struct.usb_device_id { i16 3, i16 1008, i16 1793, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 1 }, %struct.usb_device_id { i16 3, i16 1054, i16 12320, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1060, i16 13571, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1118, i16 225, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1118, i16 1904, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1133, i16 2093, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 64 }, %struct.usb_device_id { i16 3, i16 1133, i16 2115, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 64 }, %struct.usb_device_id { i16 3, i16 1133, i16 2119, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 64 }, %struct.usb_device_id { i16 3, i16 1133, i16 2120, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 64 }, %struct.usb_device_id { i16 3, i16 1133, i16 2131, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 64 }, %struct.usb_device_id { i16 3, i16 1133, i16 2241, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1133, i16 2242, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1133, i16 2243, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1133, i16 2245, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1133, i16 2246, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1133, i16 2247, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1133, i16 -16094, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 64 }, %struct.usb_device_id { i16 3, i16 1137, i16 341, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1151, i16 -16376, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1151, i16 -16365, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1204, i16 1318, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 8 }, %struct.usb_device_id { i16 3, i16 1240, i16 12, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 8 }, %struct.usb_device_id { i16 3, i16 1255, i16 9, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1255, i16 48, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1256, i16 26113, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 8 }, %struct.usb_device_id { i16 3, i16 1267, i16 137, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 256 }, %struct.usb_device_id { i16 3, i16 1267, i16 155, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 256 }, %struct.usb_device_id { i16 3, i16 1267, i16 268, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 256 }, %struct.usb_device_id { i16 3, i16 1267, i16 293, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 256 }, %struct.usb_device_id { i16 3, i16 1267, i16 367, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 256 }, %struct.usb_device_id { i16 3, i16 1267, i16 897, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 1024 }, %struct.usb_device_id { i16 3, i16 1267, i16 8632, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 256 }, %struct.usb_device_id { i16 3, i16 1410, i16 7, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1410, i16 39, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1423, i16 -28076, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1452, i16 538, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1592, i16 2579, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 1 }, %struct.usb_device_id { i16 3, i16 1699, i16 6, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 8 }, %struct.usb_device_id { i16 3, i16 1784, i16 2052, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1784, i16 12293, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1891, i16 402, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 2284, i16 4096, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 2308, i16 24833, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2048 }, %struct.usb_device_id { i16 3, i16 2308, i16 24834, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2048 }, %struct.usb_device_id { i16 3, i16 2308, i16 24835, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2048 }, %struct.usb_device_id { i16 3, i16 2342, i16 13107, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 8 }, %struct.usb_device_id { i16 3, i16 2417, i16 8192, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 4 }, %struct.usb_device_id { i16 3, i16 2652, i16 8225, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 2706, i16 145, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 2821, i16 6112, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 512 }, %struct.usb_device_id { i16 3, i16 4310, i16 8704, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 1 }, %struct.usb_device_id { i16 3, i16 5398, i16 -31192, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 5426, i16 278, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 128 }, %struct.usb_device_id { i16 3, i16 6408, i16 4885, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 32 }, %struct.usb_device_id { i16 3, i16 6666, i16 512, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 128 }, %struct.usb_device_id { i16 3, i16 7649, i16 -16126, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 1024 }, %struct.usb_device_id { i16 3, i16 7899, i16 -17093, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 1024 }, %struct.usb_device_id { i16 3, i16 7899, i16 -17073, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 1024 }, %struct.usb_device_id { i16 3, i16 -32634, i16 -3675, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id zeroinitializer], align 16
@usb_amd_resume_quirk_list = internal constant [6 x %struct.usb_device_id] [%struct.usb_device_id { i16 3, i16 6127, i16 24622, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 2362, i16 9472, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 2362, i16 9488, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 2362, i16 9505, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1133, i16 -16294, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id zeroinitializer], align 16
@usb_detect_quirks.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.usb_detect_quirks, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1.860, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.2.858, i32 0, i32 0), i8 73, i8 1, i8 0, i8 0 }, section "__verbose", align 8
@.str.2.858 = private unnamed_addr constant [32 x i8] c"USB quirks for this device: %x\0A\00", align 1
@__func__.usb_detect_quirks = private unnamed_addr constant [18 x i8] c"usb_detect_quirks\00", align 1
@.str.1.860 = private unnamed_addr constant [26 x i8] c"drivers/usb/core/quirks.c\00", align 1
@usb_interface_quirk_list = internal constant [2 x %struct.usb_device_id] [%struct.usb_device_id { i16 897, i16 1133, i16 0, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 2 }, %struct.usb_device_id zeroinitializer], align 16
@usb_detect_interface_quirks.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.usb_detect_interface_quirks, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1.860, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.3.864, i32 0, i32 0), i8 94, i8 1, i8 0, i8 0 }, section "__verbose", align 8
@.str.3.864 = private unnamed_addr constant [42 x i8] c"USB interface quirks for this device: %x\0A\00", align 1
@__func__.usb_detect_interface_quirks = private unnamed_addr constant [28 x i8] c"usb_detect_interface_quirks\00", align 1
@usbfs_devices_fops = constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @no_seek_end_llseek, i64 (%struct.file*, i8*, i64, i64*)* @usb_device_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @usb_device_poll, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* null, i32 (%struct.file*, i8*)* null, i32 (%struct.inode*, %struct.file*)* null, i32 (%struct.file*, i64, i64, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**, i8**)* null, i64 (%struct.file*, i32, i64, i64)* null, void (%struct.seq_file*, %struct.file*)* null, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i32 (%struct.file*, i64, %struct.file*, i64, i64)* null, i64 (%struct.file*, i64, i64, %struct.file*, i64)* null }, align 8
@device_event = internal global %struct.ctl_table_poll { %struct.atomic_t { i32 1 }, %struct.__wait_queue_head { %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.870, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.ctl_table_poll* @device_event to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.ctl_table_poll* @device_event to i8*), i64 80) to %struct.list_head*) } } }, align 8
@.str.870 = private unnamed_addr constant [23 x i8] c"device_event.wait.lock\00", align 1
@usb_device_read.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.1.872 = private unnamed_addr constant [27 x i8] c"drivers/usb/core/devices.c\00", align 1
@.str.3.878 = private unnamed_addr constant [3 x i8] c"12\00", align 1
@.str.7.879 = private unnamed_addr constant [3 x i8] c"??\00", align 1
@.str.2.880 = private unnamed_addr constant [4 x i8] c"1.5\00", align 1
@.str.4.881 = private unnamed_addr constant [4 x i8] c"480\00", align 1
@.str.5.882 = private unnamed_addr constant [5 x i8] c"5000\00", align 1
@.str.6.883 = private unnamed_addr constant [6 x i8] c"10000\00", align 1
@format_topo = internal constant [85 x i8] c"\0AT:  Bus=%2.2d Lev=%2.2d Prnt=%2.2d Port=%2.2d Cnt=%2.2d Dev#=%3d Spd=%-4s MxCh=%2d\0A\00", align 16
@format_bandwidth = internal constant [50 x i8] c"B:  Alloc=%3d/%3d us (%2d%%), #Int=%3d, #Iso=%3d\0A\00", align 16
@.str.8.884 = private unnamed_addr constant [13 x i8] c"(truncated)\0A\00", align 1
@.str.34.886 = private unnamed_addr constant [33 x i8] c"./arch/x86/include/asm/uaccess.h\00", align 1
@.str.35.889 = private unnamed_addr constant [38 x i8] c"Buffer overflow detected (%d < %lu)!\0A\00", align 1
@.str.27.890 = private unnamed_addr constant [19 x i8] c"(null Cfg. desc.)\0A\00", align 1
@.str.31.894 = private unnamed_addr constant [5 x i8] c"Isoc\00", align 1
@.str.30.895 = private unnamed_addr constant [5 x i8] c"Ctrl\00", align 1
@.str.32.896 = private unnamed_addr constant [5 x i8] c"Bulk\00", align 1
@.str.33.897 = private unnamed_addr constant [5 x i8] c"Int.\00", align 1
@format_endpt = internal constant [51 x i8] c"E:  Ad=%02x(%c) Atr=%02x(%-4s) MxPS=%4d Ivl=%d%cs\0A\00", align 16
@.str.29.899 = private unnamed_addr constant [7 x i8] c"(none)\00", align 1
@.str.28.900 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@format_iface = internal constant [75 x i8] c"I:%c If#=%2d Alt=%2d #EPs=%2d Cls=%02x(%-5s) Sub=%02x Prot=%02x Driver=%s\0A\00", align 16
@clas_info = internal constant [18 x %struct.usbdevfs_disconnectsignal] [%struct.usbdevfs_disconnectsignal { i32 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.9.901, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10.902, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11.903, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12.904, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 5, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.13.905, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 6, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.14.906, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 7, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.15.907, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 8, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.16.908, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 9, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17.909, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 10, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.18.910, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 11, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.19.911, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 13, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.20.912, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 14, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.21.913, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 224, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.22.914, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 239, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.23.915, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 254, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.24.916, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 255, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.25.917, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 -1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.26.918, i32 0, i32 0) }], align 16
@.str.9.901 = private unnamed_addr constant [5 x i8] c">ifc\00", align 1
@.str.10.902 = private unnamed_addr constant [6 x i8] c"audio\00", align 1
@.str.11.903 = private unnamed_addr constant [6 x i8] c"comm.\00", align 1
@.str.12.904 = private unnamed_addr constant [4 x i8] c"HID\00", align 1
@.str.13.905 = private unnamed_addr constant [4 x i8] c"PID\00", align 1
@.str.14.906 = private unnamed_addr constant [6 x i8] c"still\00", align 1
@.str.15.907 = private unnamed_addr constant [6 x i8] c"print\00", align 1
@.str.16.908 = private unnamed_addr constant [6 x i8] c"stor.\00", align 1
@.str.17.909 = private unnamed_addr constant [4 x i8] c"hub\00", align 1
@.str.18.910 = private unnamed_addr constant [5 x i8] c"data\00", align 1
@.str.19.911 = private unnamed_addr constant [6 x i8] c"scard\00", align 1
@.str.20.912 = private unnamed_addr constant [6 x i8] c"c-sec\00", align 1
@.str.21.913 = private unnamed_addr constant [6 x i8] c"video\00", align 1
@.str.22.914 = private unnamed_addr constant [6 x i8] c"wlcon\00", align 1
@.str.23.915 = private unnamed_addr constant [5 x i8] c"misc\00", align 1
@.str.24.916 = private unnamed_addr constant [5 x i8] c"app.\00", align 1
@.str.25.917 = private unnamed_addr constant [6 x i8] c"vend.\00", align 1
@.str.26.918 = private unnamed_addr constant [5 x i8] c"unk.\00", align 1
@format_iad = internal constant [64 x i8] c"A:  FirstIf#=%2d IfCount=%2d Cls=%02x(%-5s) Sub=%02x Prot=%02x\0A\00", align 16
@format_config = internal constant [45 x i8] c"C:%c #Ifs=%2d Cfg#=%2d Atr=%02x MxPwr=%3dmA\0A\00", align 16
@format_string_manufacturer = internal constant [25 x i8] c"S:  Manufacturer=%.100s\0A\00", align 16
@format_string_product = internal constant [20 x i8] c"S:  Product=%.100s\0A\00", align 16
@format_string_serialnumber = internal constant [25 x i8] c"S:  SerialNumber=%.100s\0A\00", align 16
@format_device1 = internal constant [71 x i8] c"D:  Ver=%2x.%02x Cls=%02x(%-5s) Sub=%02x Prot=%02x MxPS=%2d #Cfgs=%3d\0A\00", align 16
@format_device2 = internal constant [42 x i8] c"P:  Vendor=%04x ProdID=%04x Rev=%2x.%02x\0A\00", align 16
@usb_port_device_type = global { i8*, %struct.attribute_group**, i32 (%struct.device.5257*, %struct.kobj_uevent_env*)*, i8* (%struct.device.5257*, i16*, %struct.atomic_t*, %struct.atomic_t*)*, void (%struct.device.5257*)*, %struct.dev_pm_ops.5256* } { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.919, i32 0, i32 0), %struct.attribute_group** null, i32 (%struct.device.5257*, %struct.kobj_uevent_env*)* null, i8* (%struct.device.5257*, i16*, %struct.atomic_t*, %struct.atomic_t*)* null, void (%struct.device.5257*)* @usb_port_device_release, %struct.dev_pm_ops.5256* @usb_port_pm_ops }, align 8
@.str.919 = private unnamed_addr constant [9 x i8] c"usb_port\00", align 1
@usb_port_pm_ops = internal constant %struct.dev_pm_ops.5256 { i32 (%struct.device.5257*)* null, void (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* @usb_port_runtime_suspend, i32 (%struct.device.5257*)* @usb_port_runtime_resume, i32 (%struct.device.5257*)* null }, align 8
@usb_port_runtime_resume.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.usb_port_runtime_resume, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.5.929, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.6.923, i32 0, i32 0), i8 -60, i8 0, i8 0, i8 0 }, section "__verbose", align 8
@.str.6.923 = private unnamed_addr constant [19 x i8] c"reconnect timeout\0A\00", align 1
@__func__.usb_port_runtime_resume = private unnamed_addr constant [24 x i8] c"usb_port_runtime_resume\00", align 1
@.str.5.929 = private unnamed_addr constant [24 x i8] c"drivers/usb/core/port.c\00", align 1
@usb_port_block_power_off = internal global i32 0, align 4
@port_dev_usb3_group = internal global [3 x %struct.attribute_group*] [%struct.attribute_group* @port_dev_attr_grp, %struct.attribute_group* @port_dev_usb3_attr_grp, %struct.attribute_group* null], align 16
@port_dev_group = internal global [2 x %struct.attribute_group*] [%struct.attribute_group* @port_dev_attr_grp, %struct.attribute_group* null], align 16
@usb_port_driver = internal global %struct.device_driver.5263 { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18.951, i32 0, i32 0), %struct.bus_type.5262* null, %struct.module* @__this_module, i8* null, i8 0, i32 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device.5257*)* null, i32 (%struct.device.5257*)* null, void (%struct.device.5257*)* null, i32 (%struct.device.5257*, i32)* null, i32 (%struct.device.5257*)* null, %struct.attribute_group** null, %struct.dev_pm_ops.5256* null, %struct.driver_private* null }, align 8
@.str.1.935 = private unnamed_addr constant [10 x i8] c"%s-port%d\00", align 1
@.str.2.936 = private unnamed_addr constant [23 x i8] c"&port_dev->status_lock\00", align 1
@usb_hub_create_port_device.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.3.940 = private unnamed_addr constant [37 x i8] c"failed to expose pm_qos_no_poweroff\0A\00", align 1
@link_peers_report.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.link_peers_report, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.5.929, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.19.942, i32 0, i32 0), i8 91, i8 1, i8 0, i8 0 }, section "__verbose", align 8
@.str.19.942 = private unnamed_addr constant [14 x i8] c"peered to %s\0A\00", align 1
@link_peers_report.descriptor.20 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.link_peers_report, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.5.929, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.21.943, i32 0, i32 0), i8 94, i8 1, i8 0, i8 0 }, section "__verbose", align 8
@.str.21.943 = private unnamed_addr constant [27 x i8] c"failed to peer to %s (%d)\0A\00", align 1
@link_peers_report.__print_once = internal global i8 0, section ".data..read_mostly", align 1
@.str.22.944 = private unnamed_addr constant [48 x i8] c"\014usb: port power management may be unreliable\0A\00", align 1
@__func__.link_peers_report = private unnamed_addr constant [18 x i8] c"link_peers_report\00", align 1
@.str.24.945 = private unnamed_addr constant [8 x i8] c"default\00", align 1
@.str.23.946 = private unnamed_addr constant [9 x i8] c"location\00", align 1
@link_peers.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.link_peers, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.5.929, i32 0, i32 0), i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.25.948, i32 0, i32 0), i8 39, i8 1, i8 0, i8 0 }, section "__verbose", align 8
@.str.26.947 = private unnamed_addr constant [5 x i8] c"none\00", align 1
@.str.25.948 = private unnamed_addr constant [53 x i8] c"usb: failed to peer %s and %s by %s (%s:%s) (%s:%s)\0A\00", align 1
@.str.27.949 = private unnamed_addr constant [5 x i8] c"peer\00", align 1
@__func__.link_peers = private unnamed_addr constant [11 x i8] c"link_peers\00", align 1
@.str.18.951 = private unnamed_addr constant [4 x i8] c"usb\00", align 1
@port_dev_attr_grp = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([2 x %struct.attribute*], [2 x %struct.attribute*]* @port_dev_attrs, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@port_dev_attrs = internal global [2 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute.5555, %struct.device_attribute.5555* @dev_attr_connect_type, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_connect_type = internal global %struct.device_attribute.5555 { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.7.952, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.5257*, %struct.device_attribute.5555*, i8*)* @connect_type_show, i64 (%struct.device.5257*, %struct.device_attribute.5555*, i8*, i64)* null }, align 8
@.str.7.952 = private unnamed_addr constant [13 x i8] c"connect_type\00", align 1
@.str.11.953 = private unnamed_addr constant [8 x i8] c"unknown\00", align 1
@.str.8.954 = private unnamed_addr constant [8 x i8] c"hotplug\00", align 1
@.str.9.955 = private unnamed_addr constant [10 x i8] c"hardwired\00", align 1
@.str.10.956 = private unnamed_addr constant [9 x i8] c"not used\00", align 1
@.str.12.957 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@port_dev_usb3_attr_grp = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([2 x %struct.attribute*], [2 x %struct.attribute*]* @port_dev_usb3_attrs, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@port_dev_usb3_attrs = internal global [2 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute.5555, %struct.device_attribute.5555* @dev_attr_usb3_lpm_permit, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_usb3_lpm_permit = internal global %struct.device_attribute.5555 { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.13.958, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.5257*, %struct.device_attribute.5555*, i8*)* @usb3_lpm_permit_show, i64 (%struct.device.5257*, %struct.device_attribute.5555*, i8*, i64)* @usb3_lpm_permit_store }, align 8
@.str.13.958 = private unnamed_addr constant [16 x i8] c"usb3_lpm_permit\00", align 1
@.str.14.959 = private unnamed_addr constant [6 x i8] c"u1_u2\00", align 1
@.str.15.960 = private unnamed_addr constant [3 x i8] c"u1\00", align 1
@.str.16.961 = private unnamed_addr constant [3 x i8] c"u2\00", align 1
@.str.17.962 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.28.968 = private unnamed_addr constant [26 x i8] c"%s and %s are not peers?\0A\00", align 1
@__ksymtab_usb_of_get_child_node = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.device_node* (%struct.device_node*, i32)* @usb_of_get_child_node to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_usb_of_get_child_node, i32 0, i32 0) }, section "___ksymtab_gpl+usb_of_get_child_node", align 8
@__kstrtab_usb_of_get_child_node = internal constant [22 x i8] c"usb_of_get_child_node\00", section "__ksymtab_strings", align 1
@.str.972 = private unnamed_addr constant [4 x i8] c"reg\00", align 1
@usb_hcd_pci_pm_ops = constant %struct.dev_pm_ops { i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*)* @hcd_pci_suspend, i32 (%struct.device*)* @hcd_pci_resume, i32 (%struct.device*)* @check_root_hub_suspended, i32 (%struct.device*)* null, i32 (%struct.device*)* @hcd_pci_suspend, i32 (%struct.device*)* @hcd_pci_restore, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* @hcd_pci_suspend_noirq, i32 (%struct.device*)* @hcd_pci_resume_noirq, i32 (%struct.device*)* @check_root_hub_suspended, i32 (%struct.device*)* null, i32 (%struct.device*)* @hcd_pci_suspend_noirq, i32 (%struct.device*)* @hcd_pci_resume_noirq, i32 (%struct.device*)* @hcd_pci_runtime_suspend, i32 (%struct.device*)* @hcd_pci_runtime_resume, i32 (%struct.device*)* null }, align 8
@hcd_pci_runtime_resume.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.hcd_pci_runtime_resume, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.975, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.25.973, i32 0, i32 0), i8 121, i8 2, i8 0, i8 0 }, section "__verbose", align 8
@.str.25.973 = private unnamed_addr constant [28 x i8] c"hcd_pci_runtime_resume: %d\0A\00", align 1
@__func__.hcd_pci_runtime_resume = private unnamed_addr constant [23 x i8] c"hcd_pci_runtime_resume\00", align 1
@.str.2.975 = private unnamed_addr constant [27 x i8] c"drivers/usb/core/hcd-pci.c\00", align 1
@resume_common.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.resume_common, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.975, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.14.976, i32 0, i32 0), i8 -8, i8 1, i8 0, i8 0 }, section "__verbose", align 8
@.str.14.976 = private unnamed_addr constant [30 x i8] c"can't resume, not suspended!\0A\00", align 1
@.str.15.977 = private unnamed_addr constant [35 x i8] c"can't re-enable after resume, %d!\0A\00", align 1
@.str.16.978 = private unnamed_addr constant [27 x i8] c"PCI post-resume error %d!\0A\00", align 1
@__func__.resume_common = private unnamed_addr constant [14 x i8] c"resume_common\00", align 1
@hcd_pci_runtime_suspend.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.hcd_pci_runtime_suspend, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.975, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.24.980, i32 0, i32 0), i8 111, i8 2, i8 0, i8 0 }, section "__verbose", align 8
@.str.24.980 = private unnamed_addr constant [29 x i8] c"hcd_pci_runtime_suspend: %d\0A\00", align 1
@__func__.hcd_pci_runtime_suspend = private unnamed_addr constant [24 x i8] c"hcd_pci_runtime_suspend\00", align 1
@__func__.suspend_common = private unnamed_addr constant [15 x i8] c"suspend_common\00", align 1
@hcd_pci_suspend_noirq.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.hcd_pci_suspend_noirq, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.975, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.19.982, i32 0, i32 0), i8 52, i8 2, i8 0, i8 0 }, section "__verbose", align 8
@.str.19.982 = private unnamed_addr constant [12 x i8] c"wakeup: %d\0A\00", align 1
@hcd_pci_suspend_noirq.descriptor.20 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.hcd_pci_suspend_noirq, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.975, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.21.983, i32 0, i32 0), i8 59, i8 2, i8 0, i8 0 }, section "__verbose", align 8
@.str.21.983 = private unnamed_addr constant [19 x i8] c"--> PCI D0 legacy\0A\00", align 1
@hcd_pci_suspend_noirq.descriptor.22 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.hcd_pci_suspend_noirq, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.975, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23.984, i32 0, i32 0), i8 63, i8 2, i8 0, i8 0 }, section "__verbose", align 8
@.str.23.984 = private unnamed_addr constant [12 x i8] c"--> PCI %s\0A\00", align 1
@__func__.hcd_pci_suspend_noirq = private unnamed_addr constant [22 x i8] c"hcd_pci_suspend_noirq\00", align 1
@pci_power_names = external global [0 x i8*], align 8
@.str.17.985 = private unnamed_addr constant [27 x i8] c"Root hub is not suspended\0A\00", align 1
@.str.18.986 = private unnamed_addr constant [37 x i8] c"Secondary root hub is not suspended\0A\00", align 1
@__ksymtab_usb_hcd_pci_probe = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.pci_dev*, %struct.pci_device_id*)* @usb_hcd_pci_probe to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_usb_hcd_pci_probe, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_pci_probe", align 8
@__ksymtab_usb_hcd_pci_remove = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.pci_dev*)* @usb_hcd_pci_remove to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_hcd_pci_remove, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_pci_remove", align 8
@__ksymtab_usb_hcd_pci_shutdown = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.pci_dev*)* @usb_hcd_pci_shutdown to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_usb_hcd_pci_shutdown, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_pci_shutdown", align 8
@__ksymtab_usb_hcd_pci_pm_ops = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.dev_pm_ops* @usb_hcd_pci_pm_ops to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_hcd_pci_pm_ops, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_pci_pm_ops", align 8
@__kstrtab_usb_hcd_pci_pm_ops = internal constant [19 x i8] c"usb_hcd_pci_pm_ops\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hcd_pci_shutdown = internal constant [21 x i8] c"usb_hcd_pci_shutdown\00", section "__ksymtab_strings", align 1
@__kstrtab_usb_hcd_pci_remove = internal constant [19 x i8] c"usb_hcd_pci_remove\00", section "__ksymtab_strings", align 1
@companions_rwsem = internal global %struct.rw_semaphore { %union.anon.3 zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rw_semaphore* @companions_rwsem to i8*), i64 8) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rw_semaphore* @companions_rwsem to i8*), i64 8) to %struct.list_head*) }, %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.9.992, i32 0, i32 0), i32 0, i64 0 } }, %struct.qspinlock zeroinitializer, %struct.task_struct* null, %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.10.993, i32 0, i32 0), i32 0, i64 0 } }, align 8
@iomem_resource = external global %struct.resource, align 8
@ioport_resource = external global %struct.resource, align 8
@.str.9.992 = private unnamed_addr constant [27 x i8] c"companions_rwsem.wait_lock\00", align 1
@.str.10.993 = private unnamed_addr constant [17 x i8] c"companions_rwsem\00", align 1
@.str.13.994 = private unnamed_addr constant [34 x i8] c"./arch/x86/include/asm/paravirt.h\00", align 1
@__kstrtab_usb_hcd_pci_probe = internal constant [18 x i8] c"usb_hcd_pci_probe\00", section "__ksymtab_strings", align 1
@.str.996 = private unnamed_addr constant [48 x i8] c"Found HC with no IRQ. Check BIOS/PCI %s setup!\0A\00", align 1
@usb_hcd_pci_probe.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.usb_hcd_pci_probe, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.975, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3.997, i32 0, i32 0), i8 -22, i8 0, i8 0, i8 0 }, section "__verbose", align 8
@.str.3.997 = private unnamed_addr constant [27 x i8] c"controller already in use\0A\00", align 1
@usb_hcd_pci_probe.descriptor.4 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.usb_hcd_pci_probe, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.975, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5.998, i32 0, i32 0), i8 -16, i8 0, i8 0, i8 0 }, section "__verbose", align 8
@.str.5.998 = private unnamed_addr constant [22 x i8] c"error mapping memory\0A\00", align 1
@usb_hcd_pci_probe.descriptor.6 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.usb_hcd_pci_probe, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.975, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7.999, i32 0, i32 0), i8 5, i8 1, i8 0, i8 0 }, section "__verbose", align 8
@.str.7.999 = private unnamed_addr constant [26 x i8] c"no i/o regions available\0A\00", align 1
@.str.8.1001 = private unnamed_addr constant [18 x i8] c"init %s fail, %d\0A\00", align 1
@non_ehci_add.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__func__.non_ehci_add, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.975, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.12.1008, i32 0, i32 0), i8 -115, i8 0, i8 0, i8 0 }, section "__verbose", align 8
@.str.12.1008 = private unnamed_addr constant [24 x i8] c"FS/LS companion for %s\0A\00", align 1
@__func__.non_ehci_add = private unnamed_addr constant [13 x i8] c"non_ehci_add\00", align 1
@ehci_post_add.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.ehci_post_add, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.975, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.11.1010, i32 0, i32 0), i8 123, i8 0, i8 0, i8 0 }, section "__verbose", align 8
@.str.11.1010 = private unnamed_addr constant [21 x i8] c"HS companion for %s\0A\00", align 1
@__func__.ehci_post_add = private unnamed_addr constant [14 x i8] c"ehci_post_add\00", align 1
@__func__.usb_hcd_pci_probe = private unnamed_addr constant [18 x i8] c"usb_hcd_pci_probe\00", align 1
@__ksymtab_usb_acpi_power_manageable = internal constant %struct.kernel_symbol { i64 ptrtoint (i1 (%struct.usb_device*, i32)* @usb_acpi_power_manageable to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_usb_acpi_power_manageable, i32 0, i32 0) }, section "___ksymtab_gpl+usb_acpi_power_manageable", align 8
@__ksymtab_usb_acpi_set_power_state = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32, i1)* @usb_acpi_set_power_state to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_acpi_set_power_state, i32 0, i32 0) }, section "___ksymtab_gpl+usb_acpi_set_power_state", align 8
@__kstrtab_usb_acpi_set_power_state = internal constant [25 x i8] c"usb_acpi_set_power_state\00", section "__ksymtab_strings", align 1
@usb_acpi_set_power_state.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.usb_acpi_set_power_state, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.1.1017, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.1014, i32 0, i32 0), i8 80, i8 0, i8 0, i8 0 }, section "__verbose", align 8
@.str.2.1014 = private unnamed_addr constant [27 x i8] c"acpi: power was set to %d\0A\00", align 1
@usb_acpi_set_power_state.descriptor.3 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.usb_acpi_set_power_state, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.1.1017, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.4.1015, i32 0, i32 0), i8 82, i8 0, i8 0, i8 0 }, section "__verbose", align 8
@.str.4.1015 = private unnamed_addr constant [30 x i8] c"acpi: power failed to be set\0A\00", align 1
@.str.1016 = private unnamed_addr constant [8 x i8] c"usbcore\00", align 1
@__func__.usb_acpi_set_power_state = private unnamed_addr constant [25 x i8] c"usb_acpi_set_power_state\00", align 1
@.str.1.1017 = private unnamed_addr constant [28 x i8] c"drivers/usb/core/usb-acpi.c\00", align 1
@__kstrtab_usb_acpi_power_manageable = internal constant [26 x i8] c"usb_acpi_power_manageable\00", section "__ksymtab_strings", align 1
@usb_acpi_bus = internal global %struct.acpi_bus_type { %struct.list_head zeroinitializer, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.1020, i32 0, i32 0), i1 (%struct.device*)* @usb_acpi_bus_match, %struct.acpi_device* (%struct.device*)* @usb_acpi_find_companion, void (%struct.device*)* null, void (%struct.device*)* null }, align 8
@.str.5.1020 = private unnamed_addr constant [4 x i8] c"USB\00", align 1
@usb_acpi_get_connect_type.buffer = private unnamed_addr constant %struct.kernel_symbol { i64 -1, i8* null }, align 8
@.str.6.1024 = private unnamed_addr constant [5 x i8] c"_UPC\00", align 1

@init_module = alias i32 (), i32 ()* @usb_init
@cleanup_module = alias void (), void ()* @usb_exit
@__mod_usb__hub_id_table_device_table = alias [4 x %struct.usb_device_id], [4 x %struct.usb_device_id]* @hub_id_table

; Function Attrs: nounwind uwtable
define internal i32 @usb_dev_uevent(%struct.device* %dev, %struct.kobj_uevent_env* %env) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %busnum = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %2, i32 0, i32 1
  %3 = load i32, i32* %busnum, align 8, !tbaa !41
  %call = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.8, i32 0, i32 0), i32 %3)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 0
  %4 = load i32, i32* %devnum, align 8, !tbaa !44
  %call1 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.9, i32 0, i32 0), i32 %4)
  %tobool2 = icmp ne i32 %call1, 0
  %. = select i1 %tobool2, i32 -12, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ -12, %entry ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_devnode(%struct.device* %dev, i16* %mode, %struct.atomic_t* %uid, %struct.atomic_t* %gid) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %busnum = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %2, i32 0, i32 1
  %3 = load i32, i32* %busnum, align 8, !tbaa !41
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 0
  %4 = load i32, i32* %devnum, align 8, !tbaa !44
  %call = call noalias i8* (i32, i8*, ...) @kasprintf(i32 20971712, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.10, i32 0, i32 0), i32 %3, i32 %4)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define internal void @usb_release_dev(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd(%struct.usb_bus* %2)
  call void @usb_destroy_configuration(%struct.usb_device* %1)
  call void @usb_release_bos_descriptor(%struct.usb_device* %1)
  call void bitcast (void (%struct.usb_hcd.712*)* @usb_put_hcd to void (%struct.usb_hcd*)*)(%struct.usb_hcd* %call)
  %product = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 24
  %3 = load i8*, i8** %product, align 8, !tbaa !45
  call void @kfree(i8* %3)
  %manufacturer = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 25
  %4 = load i8*, i8** %manufacturer, align 8, !tbaa !46
  call void @kfree(i8* %4)
  %serial = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 26
  %5 = load i8*, i8** %serial, align 8, !tbaa !47
  call void @kfree(i8* %5)
  %6 = bitcast %struct.usb_device* %1 to i8*
  call void @kfree(i8* %6)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_dev_prepare(%struct.device* %dev) #0 {
entry:
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @usb_dev_complete(%struct.device* %dev) #0 {
entry:
  %call = call i32 @usb_resume_complete(%struct.device* %dev)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_dev_suspend(%struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %struct.atomic_t, align 4
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  store i32 2, i32* %event, align 4, !tbaa !48
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  %0 = load i32, i32* %coerce.dive, align 4
  %call = call i32 @usb_suspend(%struct.device* %dev, i32 %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_dev_resume(%struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %struct.atomic_t, align 4
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  store i32 16, i32* %event, align 4, !tbaa !48
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  %0 = load i32, i32* %coerce.dive, align 4
  %call = call i32 @usb_resume(%struct.device* %dev, i32 %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_dev_freeze(%struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %struct.atomic_t, align 4
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  store i32 1, i32* %event, align 4, !tbaa !48
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  %0 = load i32, i32* %coerce.dive, align 4
  %call = call i32 @usb_suspend(%struct.device* %dev, i32 %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_dev_thaw(%struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %struct.atomic_t, align 4
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  store i32 32, i32* %event, align 4, !tbaa !48
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  %0 = load i32, i32* %coerce.dive, align 4
  %call = call i32 @usb_resume(%struct.device* %dev, i32 %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_dev_poweroff(%struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %struct.atomic_t, align 4
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  store i32 4, i32* %event, align 4, !tbaa !48
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  %0 = load i32, i32* %coerce.dive, align 4
  %call = call i32 @usb_suspend(%struct.device* %dev, i32 %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_dev_restore(%struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %struct.atomic_t, align 4
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  store i32 64, i32* %event, align 4, !tbaa !48
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  %0 = load i32, i32* %coerce.dive, align 4
  %call = call i32 @usb_resume(%struct.device* %dev, i32 %0)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd* @bus_to_hcd(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd*
  ret %struct.usb_hcd* %1
}

declare void @kfree(i8*) #2

declare noalias i8* @kasprintf(i32, i8*, ...) #2

declare i32 @add_uevent_var(%struct.kobj_uevent_env*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define void @usb_free_coherent(%struct.usb_device* %dev, i64 %size, i8* %addr, i64 %dma) #0 {
entry:
  %tobool = icmp ne %struct.usb_device* %dev, null
  br i1 %tobool, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %entry
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %tobool1 = icmp ne %struct.usb_bus* %0, null
  %tobool2 = icmp ne i8* %addr, null
  %or.cond = and i1 %tobool1, %tobool2
  br i1 %or.cond, label %if.end4, label %return

if.end4:                                          ; preds = %lor.lhs.false
  %bus5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus5, align 8, !tbaa !2
  call void @hcd_buffer_free(%struct.usb_bus* %1, i64 %size, i8* %addr, i64 %dma)
  br label %return

return:                                           ; preds = %if.end4, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @usb_alloc_coherent(%struct.usb_device* %dev, i64 %size, i32 %mem_flags, i64* %dma) #0 {
entry:
  %tobool = icmp ne %struct.usb_device* %dev, null
  br i1 %tobool, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %entry
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %tobool1 = icmp ne %struct.usb_bus* %0, null
  br i1 %tobool1, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  %bus2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus2, align 8, !tbaa !2
  %call = call i8* @hcd_buffer_alloc(%struct.usb_bus* %1, i64 %size, i32 %mem_flags, i64* %dma)
  br label %return

return:                                           ; preds = %if.end, %lor.lhs.false, %entry
  %retval.0 = phi i8* [ %call, %if.end ], [ null, %lor.lhs.false ], [ null, %entry ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @__usb_get_extra_descriptor(i8* %buffer, i32 %size, i8 zeroext %type, i8** %ptr) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %if.end14, %entry
  %size.addr.0 = phi i32 [ %size, %entry ], [ %sub, %if.end14 ]
  %buffer.addr.0 = phi i8* [ %buffer, %entry ], [ %add.ptr, %if.end14 ]
  %conv = zext i32 %size.addr.0 to i64
  %cmp = icmp uge i64 %conv, 2
  br i1 %cmp, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %0 = bitcast i8* %buffer.addr.0 to %struct.usb_descriptor_header*
  %bLength = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %0, i32 0, i32 0
  %1 = load i8, i8* %bLength, align 1, !tbaa !49
  %conv2 = zext i8 %1 to i32
  %cmp3 = icmp slt i32 %conv2, 2
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %while.body
  %bDescriptorType8 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %0, i32 0, i32 1
  %3 = load i8, i8* %bDescriptorType8, align 1, !tbaa !51
  %conv9 = zext i8 %3 to i32
  %conv10 = zext i8 %type to i32
  %cmp11 = icmp eq i32 %conv9, %conv10
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end
  %4 = bitcast %struct.usb_descriptor_header* %0 to i8*
  store i8* %4, i8** %ptr, align 8, !tbaa !52
  br label %cleanup

if.end14:                                         ; preds = %if.end
  %bLength15 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %0, i32 0, i32 0
  %5 = load i8, i8* %bLength15, align 1, !tbaa !49
  %conv16 = zext i8 %5 to i32
  %idx.ext = sext i32 %conv16 to i64
  %add.ptr = getelementptr inbounds i8, i8* %buffer.addr.0, i64 %idx.ext
  %bLength17 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %0, i32 0, i32 0
  %6 = load i8, i8* %bLength17, align 1, !tbaa !49
  %conv18 = zext i8 %6 to i32
  %sub = sub i32 %size.addr.0, %conv18
  br label %while.cond

cleanup:                                          ; preds = %if.then13, %if.then, %while.cond
  %retval.0 = phi i32 [ -1, %if.then ], [ 0, %if.then13 ], [ -1, %while.cond ]
  ret i32 %retval.0
}

declare i32 @printk(i8*, ...) #2

; Function Attrs: nounwind uwtable
define i32 @usb_get_current_frame_number(%struct.usb_device* %dev) #0 {
entry:
  %call = call i32 @usb_hcd_get_frame_number(%struct.usb_device* %dev)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @usb_lock_device_for_reset(%struct.usb_device* %udev, %struct.usb_interface* %iface) #0 {
entry:
  %0 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  %add = add i64 %0, 250
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %state1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %2 = load i32, i32* %state1, align 8, !tbaa !54
  %cmp2 = icmp eq i32 %2, 8
  br i1 %cmp2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %tobool = icmp ne %struct.usb_interface* %iface, null
  br i1 %tobool, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %if.end4
  %condition = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 5
  %3 = load i32, i32* %condition, align 4, !tbaa !55
  %cmp5 = icmp eq i32 %3, 3
  br i1 %cmp5, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %condition6 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 5
  %4 = load i32, i32* %condition6, align 4, !tbaa !55
  %cmp7 = icmp eq i32 %4, 0
  br i1 %cmp7, label %cleanup, label %if.end9

if.end9:                                          ; preds = %lor.lhs.false, %if.end4
  br label %while.cond

while.cond:                                       ; preds = %if.end45, %if.end9
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call = call i32 @device_trylock(%struct.device* %dev)
  %tobool10 = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool10, true
  br i1 %lnot, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %tobool12 = icmp ne i32 1, 0
  br i1 %tobool12, label %land.lhs.true13, label %if.end24

land.lhs.true13:                                  ; preds = %while.body
  %5 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  %sub = sub i64 %add, %5
  %cmp21 = icmp slt i64 %sub, 0
  br i1 %cmp21, label %cleanup, label %if.end24

if.end24:                                         ; preds = %land.lhs.true13, %while.body
  call void @msleep(i32 15)
  %state25 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %6 = load i32, i32* %state25, align 8, !tbaa !54
  %cmp26 = icmp eq i32 %6, 0
  br i1 %cmp26, label %cleanup, label %if.end29

if.end29:                                         ; preds = %if.end24
  %state30 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %7 = load i32, i32* %state30, align 8, !tbaa !54
  %cmp31 = icmp eq i32 %7, 8
  br i1 %cmp31, label %cleanup, label %if.end34

if.end34:                                         ; preds = %if.end29
  %tobool35 = icmp ne %struct.usb_interface* %iface, null
  br i1 %tobool35, label %land.lhs.true36, label %if.end45

land.lhs.true36:                                  ; preds = %if.end34
  %condition37 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 5
  %8 = load i32, i32* %condition37, align 4, !tbaa !55
  %cmp38 = icmp eq i32 %8, 3
  br i1 %cmp38, label %cleanup, label %lor.lhs.false40

lor.lhs.false40:                                  ; preds = %land.lhs.true36
  %condition41 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 5
  %9 = load i32, i32* %condition41, align 4, !tbaa !55
  %cmp42 = icmp eq i32 %9, 0
  br i1 %cmp42, label %cleanup, label %if.end45

if.end45:                                         ; preds = %lor.lhs.false40, %if.end34
  br label %while.cond

cleanup:                                          ; preds = %lor.lhs.false40, %land.lhs.true36, %if.end29, %if.end24, %land.lhs.true13, %while.cond, %lor.lhs.false, %land.lhs.true, %if.end, %entry
  %retval.0 = phi i32 [ -19, %entry ], [ -113, %if.end ], [ -4, %lor.lhs.false ], [ -4, %land.lhs.true ], [ -16, %land.lhs.true13 ], [ -19, %if.end24 ], [ -113, %if.end29 ], [ -4, %lor.lhs.false40 ], [ -4, %land.lhs.true36 ], [ 0, %while.cond ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @device_trylock(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  %call = call i32 @mutex_trylock(%struct.mutex* %mutex)
  ret i32 %call
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #3

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #3

declare void @msleep(i32) #2

declare i32 @mutex_trylock(%struct.mutex*) #2

; Function Attrs: nounwind uwtable
define void @usb_put_intf(%struct.usb_interface* %intf) #0 {
entry:
  %tobool = icmp ne %struct.usb_interface* %intf, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @put_device(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @put_device(%struct.device*) #2

; Function Attrs: nounwind uwtable
define %struct.usb_interface* @usb_get_intf(%struct.usb_interface* %intf) #0 {
entry:
  %tobool = icmp ne %struct.usb_interface* %intf, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call %struct.device* @get_device(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.usb_interface* %intf
}

declare %struct.device* @get_device(%struct.device*) #2

; Function Attrs: nounwind uwtable
define void @usb_put_dev(%struct.usb_device* %dev) #0 {
entry:
  %tobool = icmp ne %struct.usb_device* %dev, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  call void @put_device(%struct.device* %dev1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.usb_device* @usb_get_dev(%struct.usb_device* %dev) #0 {
entry:
  %tobool = icmp ne %struct.usb_device* %dev, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %call = call %struct.device* @get_device(%struct.device* %dev1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.usb_device* %dev
}

; Function Attrs: nounwind uwtable
define %struct.usb_device* @usb_alloc_dev(%struct.usb_device* %parent, %struct.usb_bus* %bus, i32 %port1) #0 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %call = call %struct.usb_hcd* @bus_to_hcd(%struct.usb_bus* %bus)
  %call1 = call i8* @kzalloc(i64 2048, i32 20971712)
  %0 = bitcast i8* %call1 to %struct.usb_device*
  %tobool = icmp ne %struct.usb_device* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call2 = call %struct.usb_hcd* bitcast (%struct.usb_hcd.712* (%struct.usb_hcd.712*)* @usb_get_hcd to %struct.usb_hcd* (%struct.usb_hcd*)*)(%struct.usb_hcd* %call)
  %tobool3 = icmp ne %struct.usb_hcd* %call2, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  %1 = bitcast %struct.usb_device* %0 to i8*
  call void @kfree(i8* %1)
  br label %cleanup

if.end5:                                          ; preds = %if.end
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %2 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %alloc_dev = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %2, i32 0, i32 26
  %3 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %alloc_dev, align 8, !tbaa !61
  %tobool6 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*)* %3, null
  %tobool7 = icmp ne %struct.usb_device* %parent, null
  %or.cond = and i1 %tobool6, %tobool7
  br i1 %or.cond, label %land.lhs.true8, label %if.end15

land.lhs.true8:                                   ; preds = %if.end5
  %driver9 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %4 = load %struct.hc_driver*, %struct.hc_driver** %driver9, align 8, !tbaa !57
  %alloc_dev10 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %4, i32 0, i32 26
  %5 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %alloc_dev10, align 8, !tbaa !61
  %call11 = call i32 %5(%struct.usb_hcd* %call, %struct.usb_device* %0)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.end15, label %if.then13

if.then13:                                        ; preds = %land.lhs.true8
  %call14 = call %struct.usb_hcd* @bus_to_hcd(%struct.usb_bus* %bus)
  call void bitcast (void (%struct.usb_hcd.712*)* @usb_put_hcd to void (%struct.usb_hcd*)*)(%struct.usb_hcd* %call14)
  %6 = bitcast %struct.usb_device* %0 to i8*
  call void @kfree(i8* %6)
  br label %cleanup

if.end15:                                         ; preds = %land.lhs.true8, %if.end5
  %dev16 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_initialize(%struct.device* %dev16)
  %dev17 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %bus18 = getelementptr inbounds %struct.device, %struct.device* %dev17, i32 0, i32 6
  store %struct.bus_type* @usb_bus_type, %struct.bus_type** %bus18, align 8, !tbaa !63
  %dev19 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %type = getelementptr inbounds %struct.device, %struct.device* %dev19, i32 0, i32 4
  store %struct.device_type* @usb_device_type, %struct.device_type** %type, align 8, !tbaa !64
  %dev20 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %groups = getelementptr inbounds %struct.device, %struct.device* %dev20, i32 0, i32 34
  store %struct.attribute_group** getelementptr inbounds ([3 x %struct.attribute_group*], [3 x %struct.attribute_group*]* @usb_device_groups, i32 0, i32 0), %struct.attribute_group*** %groups, align 8, !tbaa !65
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 0
  %7 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !66
  %dma_mask = getelementptr inbounds %struct.device, %struct.device* %7, i32 0, i32 18
  %8 = load i64*, i64** %dma_mask, align 8, !tbaa !67
  %dev21 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %dma_mask22 = getelementptr inbounds %struct.device, %struct.device* %dev21, i32 0, i32 18
  store i64* %8, i64** %dma_mask22, align 8, !tbaa !68
  %controller23 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 0
  %9 = load %struct.device*, %struct.device** %controller23, align 8, !tbaa !66
  %dma_pfn_offset = getelementptr inbounds %struct.device, %struct.device* %9, i32 0, i32 20
  %10 = load i64, i64* %dma_pfn_offset, align 8, !tbaa !69
  %dev24 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %dma_pfn_offset25 = getelementptr inbounds %struct.device, %struct.device* %dev24, i32 0, i32 20
  store i64 %10, i64* %dma_pfn_offset25, align 8, !tbaa !70
  %dev26 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %controller27 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 0
  %11 = load %struct.device*, %struct.device** %controller27, align 8, !tbaa !66
  %call28 = call i32 @dev_to_node(%struct.device* %11)
  call void @set_dev_node(%struct.device* %dev26, i32 %call28)
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 3
  store i32 1, i32* %state, align 8, !tbaa !54
  %lpm_disable_count = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 40
  store i32 1, i32* %lpm_disable_count, align 8, !tbaa !71
  %urbnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 30
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  store i32 0, i32* %__val.i, align 4, !tbaa !72
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %urbnum, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %12 = bitcast i8* %arraydecay.i to i32*
  %13 = load i32, i32* %12, align 4, !tbaa !73
  store volatile i32 %13, i32* %counter.i, align 4, !tbaa !73
  %ep0 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 10
  %urb_list = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep0, i32 0, i32 4
  call void @INIT_LIST_HEAD(%struct.list_head* %urb_list)
  %ep029 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 10
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep029, i32 0, i32 0
  %bLength = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc, i32 0, i32 0
  store i8 7, i8* %bLength, align 8, !tbaa !74
  %ep030 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 10
  %desc31 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep030, i32 0, i32 0
  %bDescriptorType = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc31, i32 0, i32 1
  store i8 5, i8* %bDescriptorType, align 1, !tbaa !75
  %ep032 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 10
  call void @usb_enable_endpoint(%struct.usb_device* %0, %struct.usb_host_endpoint* %ep032, i1 zeroext false)
  %can_submit = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 22
  %bf.load = load i16, i16* %can_submit, align 4
  %bf.clear = and i16 %bf.load, -2
  %bf.set = or i16 %bf.clear, 1
  store i16 %bf.set, i16* %can_submit, align 4
  %tobool33 = icmp ne %struct.usb_device* %parent, null
  %lnot = xor i1 %tobool33, true
  %lnot34 = xor i1 %lnot, true
  %lnot35 = xor i1 %lnot34, true
  %lnot.ext = zext i1 %lnot35 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool36 = icmp ne i64 %expval, 0
  br i1 %tobool36, label %if.then37, label %if.else

if.then37:                                        ; preds = %if.end15
  %devpath = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 1
  %arrayidx = getelementptr inbounds [16 x i8], [16 x i8]* %devpath, i64 0, i64 0
  store i8 48, i8* %arrayidx, align 4, !tbaa !72
  %route = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 2
  store i32 0, i32* %route, align 4, !tbaa !76
  %controller38 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 0
  %14 = load %struct.device*, %struct.device** %controller38, align 8, !tbaa !66
  %dev39 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %parent40 = getelementptr inbounds %struct.device, %struct.device* %dev39, i32 0, i32 0
  store %struct.device* %14, %struct.device** %parent40, align 8, !tbaa !77
  %dev41 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %busnum = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 1
  %15 = load i32, i32* %busnum, align 8, !tbaa !41
  %call42 = call i32 (%struct.device*, i8*, ...) @dev_set_name(%struct.device* %dev41, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0), i32 %15)
  br label %if.end91

if.else:                                          ; preds = %if.end15
  %devpath43 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %parent, i32 0, i32 1
  %arrayidx44 = getelementptr inbounds [16 x i8], [16 x i8]* %devpath43, i64 0, i64 0
  %16 = load i8, i8* %arrayidx44, align 4, !tbaa !72
  %conv45 = sext i8 %16 to i32
  %cmp = icmp eq i32 %conv45, 48
  %devpath48 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %devpath48, i32 0, i32 0
  br i1 %cmp, label %if.then47, label %if.else51

if.then47:                                        ; preds = %if.else
  %call49 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 16, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.6.592, i32 0, i32 0), i32 %port1)
  br label %if.end73

if.else51:                                        ; preds = %if.else
  %devpath54 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %parent, i32 0, i32 1
  %arraydecay55 = getelementptr inbounds [16 x i8], [16 x i8]* %devpath54, i32 0, i32 0
  %call56 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 16, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0), i8* %arraydecay55, i32 %port1)
  %cmp57 = icmp ult i32 %port1, 15
  %route60 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %parent, i32 0, i32 2
  %17 = load i32, i32* %route60, align 4, !tbaa !76
  %level = getelementptr inbounds %struct.usb_device, %struct.usb_device* %parent, i32 0, i32 21
  %18 = load i8, i8* %level, align 1, !tbaa !78
  %conv61 = zext i8 %18 to i32
  %sub = sub nsw i32 %conv61, 1
  %mul = mul nsw i32 %sub, 4
  %.sink = select i1 %cmp57, i32 %port1, i32 15
  %shl69 = shl i32 %.sink, %mul
  %add70 = add i32 %17, %shl69
  br label %if.end73

if.end73:                                         ; preds = %if.else51, %if.then47
  %add70.sink = phi i32 [ %add70, %if.else51 ], [ 0, %if.then47 ]
  %route71 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 2
  store i32 %add70.sink, i32* %route71, align 4, !tbaa !76
  %dev74 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %parent, i32 0, i32 11
  %dev75 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %parent76 = getelementptr inbounds %struct.device, %struct.device* %dev75, i32 0, i32 0
  store %struct.device* %dev74, %struct.device** %parent76, align 8, !tbaa !77
  %dev77 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %busnum78 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 1
  %19 = load i32, i32* %busnum78, align 8, !tbaa !41
  %devpath79 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 1
  %arraydecay80 = getelementptr inbounds [16 x i8], [16 x i8]* %devpath79, i32 0, i32 0
  %call81 = call i32 (%struct.device*, i8*, ...) @dev_set_name(%struct.device* %dev77, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.6, i32 0, i32 0), i32 %19, i8* %arraydecay80)
  %parent82 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %parent, i32 0, i32 8
  %20 = load %struct.usb_device*, %struct.usb_device** %parent82, align 8, !tbaa !79
  %tobool83 = icmp ne %struct.usb_device* %20, null
  br i1 %tobool83, label %if.end86, label %if.then84

if.then84:                                        ; preds = %if.end73
  %call85 = call i32 bitcast (i32 (%struct.usb_hcd.712*, i32)* @usb_hcd_find_raw_port_number to i32 (%struct.usb_hcd*, i32)*)(%struct.usb_hcd* %call, i32 %port1)
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %if.end73
  %raw_port.0 = phi i32 [ %port1, %if.end73 ], [ %call85, %if.then84 ]
  %dev87 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %parent, i32 0, i32 11
  %of_node = getelementptr inbounds %struct.device, %struct.device* %dev87, i32 0, i32 26
  %21 = load %struct.device_node*, %struct.device_node** %of_node, align 8, !tbaa !80
  %call88 = call %struct.device_node* @usb_of_get_child_node(%struct.device_node* %21, i32 %raw_port.0)
  %dev89 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %of_node90 = getelementptr inbounds %struct.device, %struct.device* %dev89, i32 0, i32 26
  store %struct.device_node* %call88, %struct.device_node** %of_node90, align 8, !tbaa !80
  br label %if.end91

if.end91:                                         ; preds = %if.end86, %if.then37
  %root_hub.0 = phi i32 [ 1, %if.then37 ], [ 0, %if.end86 ]
  %conv92 = trunc i32 %port1 to i8
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 20
  store i8 %conv92, i8* %portnum, align 2, !tbaa !81
  %bus93 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  store %struct.usb_bus* %bus, %struct.usb_bus** %bus93, align 8, !tbaa !2
  %parent94 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  store %struct.usb_device* %parent, %struct.usb_device** %parent94, align 8, !tbaa !79
  %filelist = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 27
  call void @INIT_LIST_HEAD(%struct.list_head* %filelist)
  %dev95 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %22 = load i32, i32* @usb_autosuspend_delay, align 4, !tbaa !73
  %mul96 = mul nsw i32 %22, 1000
  call void @pm_runtime_set_autosuspend_delay(%struct.device* %dev95, i32 %mul96)
  %23 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  %connect_time = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 32
  store i64 %23, i64* %connect_time, align 8, !tbaa !82
  %24 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  %sub97 = sub i64 0, %24
  %active_duration = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 31
  store i64 %sub97, i64* %active_duration, align 8, !tbaa !83
  %tobool98 = icmp ne i32 %root_hub.0, 0
  br i1 %tobool98, label %if.then99, label %if.else103

if.then99:                                        ; preds = %if.end91
  %authorized = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 22
  %bf.load100 = load i16, i16* %authorized, align 4
  %bf.clear101 = and i16 %bf.load100, -9
  %bf.set102 = or i16 %bf.clear101, 8
  store i16 %bf.set102, i16* %authorized, align 4
  br label %cleanup

if.else103:                                       ; preds = %if.end91
  %flags = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 11
  %25 = load i64, i64* %flags, align 8, !tbaa !84
  %and = and i64 %25, 256
  %tobool104 = icmp ne i64 %and, 0
  %lnot105 = xor i1 %tobool104, true
  %lnot107 = xor i1 %lnot105, true
  %lnot.ext108 = zext i1 %lnot107 to i32
  %authorized109 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 22
  %26 = trunc i32 %lnot.ext108 to i16
  %bf.load110 = load i16, i16* %authorized109, align 4
  %bf.value = and i16 %26, 1
  %bf.shl = shl i16 %bf.value, 3
  %bf.clear111 = and i16 %bf.load110, -9
  %bf.set112 = or i16 %bf.clear111, %bf.shl
  store i16 %bf.set112, i16* %authorized109, align 4
  %call113 = call i32 @usb_bus_is_wusb(%struct.usb_bus* %bus)
  %tobool114 = icmp ne i32 %call113, 0
  %cond = select i1 %tobool114, i32 1, i32 0
  %wusb = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 22
  %27 = trunc i32 %cond to i16
  %bf.load115 = load i16, i16* %wusb, align 4
  %bf.value116 = and i16 %27, 1
  %bf.shl117 = shl i16 %bf.value116, 5
  %bf.clear118 = and i16 %bf.load115, -33
  %bf.set119 = or i16 %bf.clear118, %bf.shl117
  store i16 %bf.set119, i16* %wusb, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.else103, %if.then99, %if.then13, %if.then4, %entry
  %retval.0 = phi %struct.usb_device* [ null, %if.then13 ], [ null, %if.then4 ], [ null, %entry ], [ %0, %if.else103 ], [ %0, %if.then99 ]
  ret %struct.usb_device* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call noalias i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

declare void @device_initialize(%struct.device*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @dev_to_node(%struct.device* %dev) #1 {
entry:
  %numa_node = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 16
  %0 = load i32, i32* %numa_node, align 8, !tbaa !85
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @set_dev_node(%struct.device* %dev, i32 %node) #1 {
entry:
  %numa_node = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 16
  store i32 %node, i32* %numa_node, align 8, !tbaa !85
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !72
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !87
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #4

declare i32 @dev_set_name(%struct.device*, i8*, ...) #2

declare i32 @snprintf(i8*, i64, i8*, ...) #2

declare void @pm_runtime_set_autosuspend_delay(%struct.device*, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @usb_bus_is_wusb(%struct.usb_bus* %bus) #0 {
entry:
  %call = call %struct.usb_hcd* @bus_to_hcd(%struct.usb_bus* %bus)
  %wireless = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 12
  %bf.load = load i16, i16* %wireless, align 8
  %bf.lshr = lshr i16 %bf.load, 5
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  ret i32 %bf.cast
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #3

declare noalias i8* @__kmalloc(i64, i32) #2

; Function Attrs: nounwind uwtable
define i32 @usb_for_each_dev(i8* %data, i32 (%struct.usb_device*, i8*)* %fn) #0 {
entry:
  %arg = alloca %struct.each_dev_arg, align 8
  %data1 = getelementptr inbounds %struct.each_dev_arg, %struct.each_dev_arg* %arg, i32 0, i32 0
  store i8* %data, i8** %data1, align 8, !tbaa !88
  %fn2 = getelementptr inbounds %struct.each_dev_arg, %struct.each_dev_arg* %arg, i32 0, i32 1
  store i32 (%struct.usb_device*, i8*)* %fn, i32 (%struct.usb_device*, i8*)** %fn2, align 8, !tbaa !90
  %0 = bitcast %struct.each_dev_arg* %arg to i8*
  %call = call i32 @bus_for_each_dev(%struct.bus_type* @usb_bus_type, %struct.device* null, i8* %0, i32 (%struct.device*, i8*)* @__each_dev)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @__each_dev(%struct.device* %dev, i8* %data) #0 {
entry:
  %0 = bitcast i8* %data to %struct.each_dev_arg*
  %call = call i32 @is_usb_device(%struct.device* %dev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %fn = getelementptr inbounds %struct.each_dev_arg, %struct.each_dev_arg* %0, i32 0, i32 1
  %1 = load i32 (%struct.usb_device*, i8*)*, i32 (%struct.usb_device*, i8*)** %fn, align 8, !tbaa !90
  %2 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -152
  %3 = bitcast i8* %add.ptr to %struct.usb_device*
  %data1 = getelementptr inbounds %struct.each_dev_arg, %struct.each_dev_arg* %0, i32 0, i32 0
  %4 = load i8*, i8** %data1, align 8, !tbaa !88
  %call2 = call i32 %1(%struct.usb_device* %3, i8* %4)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call2, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

declare i32 @bus_for_each_dev(%struct.bus_type*, %struct.device*, i8*, i32 (%struct.device*, i8*)*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_usb_device(%struct.device* %dev) #1 {
entry:
  %type = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 4
  %0 = load %struct.device_type*, %struct.device_type** %type, align 8, !tbaa !91
  %cmp = icmp eq %struct.device_type* %0, @usb_device_type
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define %struct.usb_interface* @usb_find_interface(%struct.usb_driver* %drv, i32 %minor) #0 {
entry:
  %argb = alloca %struct.find_interface_arg, align 8
  %minor1 = getelementptr inbounds %struct.find_interface_arg, %struct.find_interface_arg* %argb, i32 0, i32 0
  store i32 %minor, i32* %minor1, align 8, !tbaa !92
  %drvwrap = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %drv, i32 0, i32 11
  %driver = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 0
  %drv2 = getelementptr inbounds %struct.find_interface_arg, %struct.find_interface_arg* %argb, i32 0, i32 1
  store %struct.device_driver* %driver, %struct.device_driver** %drv2, align 8, !tbaa !94
  %0 = bitcast %struct.find_interface_arg* %argb to i8*
  %call = call %struct.device* @bus_find_device(%struct.bus_type* @usb_bus_type, %struct.device* null, i8* %0, i32 (%struct.device*, i8*)* @__find_interface)
  call void @put_device(%struct.device* %call)
  %tobool = icmp ne %struct.device* %call, null
  %1 = bitcast %struct.device* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -48
  %2 = bitcast i8* %add.ptr to %struct.usb_interface*
  %cond = select i1 %tobool, %struct.usb_interface* %2, %struct.usb_interface* null
  ret %struct.usb_interface* %cond
}

; Function Attrs: nounwind uwtable
define internal i32 @__find_interface(%struct.device* %dev, i8* %data) #0 {
entry:
  %0 = bitcast i8* %data to %struct.find_interface_arg*
  %call = call i32 @is_usb_interface(%struct.device* %dev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %1 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !95
  %drv = getelementptr inbounds %struct.find_interface_arg, %struct.find_interface_arg* %0, i32 0, i32 1
  %2 = load %struct.device_driver*, %struct.device_driver** %drv, align 8, !tbaa !94
  %cmp = icmp ne %struct.device_driver* %1, %2
  br i1 %cmp, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -48
  %4 = bitcast i8* %add.ptr to %struct.usb_interface*
  %minor = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 4
  %5 = load i32, i32* %minor, align 8, !tbaa !96
  %minor3 = getelementptr inbounds %struct.find_interface_arg, %struct.find_interface_arg* %0, i32 0, i32 0
  %6 = load i32, i32* %minor3, align 8, !tbaa !92
  %cmp4 = icmp eq i32 %5, %6
  %conv = zext i1 %cmp4 to i32
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i32 [ %conv, %if.end2 ], [ 0, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare %struct.device* @bus_find_device(%struct.bus_type*, %struct.device*, i8*, i32 (%struct.device*, i8*)*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_usb_interface(%struct.device* %dev) #1 {
entry:
  %type = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 4
  %0 = load %struct.device_type*, %struct.device_type** %type, align 8, !tbaa !91
  %cmp = icmp eq %struct.device_type* %0, @usb_if_device_type
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define %struct.usb_host_interface* @usb_altnum_to_altsetting(%struct.usb_interface* %intf, i32 %altnum) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %num_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 2
  %0 = load i32, i32* %num_altsetting, align 8, !tbaa !97
  %cmp = icmp ult i32 %i.0, %0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 0
  %1 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !98
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i64 %idxprom
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bAlternateSetting = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 3
  %2 = load i8, i8* %bAlternateSetting, align 1, !tbaa !99
  %conv = zext i8 %2 to i32
  %cmp1 = icmp eq i32 %conv, %altnum
  br i1 %cmp1, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %altsetting3 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 0
  %3 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting3, align 8, !tbaa !98
  %idxprom4 = sext i32 %i.0 to i64
  %arrayidx5 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %3, i64 %idxprom4
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond
  %retval.0 = phi %struct.usb_host_interface* [ %arrayidx5, %if.then ], [ null, %for.cond ]
  ret %struct.usb_host_interface* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %dev, i32 %ifnum) #0 {
entry:
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %1 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %2 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !52
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %2, i32 0, i32 0
  %3 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !98
  %arrayidx2 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %3, i64 0
  %desc3 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx2, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc3, i32 0, i32 2
  %4 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !106
  %conv4 = zext i8 %4 to i32
  %cmp5 = icmp eq i32 %conv4, %ifnum
  br i1 %cmp5, label %if.then7, label %for.inc

if.then7:                                         ; preds = %for.body
  %interface8 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 3
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface8, i64 0, i64 %idxprom9
  %5 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx10, align 8, !tbaa !52
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.then7, %for.cond, %entry
  %retval.0 = phi %struct.usb_interface* [ %5, %if.then7 ], [ null, %entry ], [ null, %for.cond ]
  ret %struct.usb_interface* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.usb_host_interface* @usb_find_alt_setting(%struct.usb_host_config* %config, i32 %iface_num, i32 %alt_num) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %0 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv = zext i8 %0 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %intf_cache2 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 4
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache2, i64 0, i64 %idxprom
  %1 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx, align 8, !tbaa !52
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %1, i32 0, i32 2
  %arrayidx3 = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i64 0, i64 0
  %desc4 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx3, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc4, i32 0, i32 2
  %2 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !106
  %conv5 = zext i8 %2 to i32
  %cmp6 = icmp eq i32 %conv5, %iface_num
  br i1 %cmp6, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %intf_cache8 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 4
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache8, i64 0, i64 %idxprom9
  %3 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx10, align 8, !tbaa !52
  br label %for.end

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %intf_cache.0 = phi %struct.usb_interface_cache* [ %3, %if.then ], [ null, %for.cond ]
  %tobool = icmp ne %struct.usb_interface_cache* %intf_cache.0, null
  br i1 %tobool, label %if.end12, label %cleanup

if.end12:                                         ; preds = %for.end
  br label %for.cond13

for.cond13:                                       ; preds = %for.inc29, %if.end12
  %i.1 = phi i32 [ 0, %if.end12 ], [ %inc30, %for.inc29 ]
  %num_altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intf_cache.0, i32 0, i32 0
  %4 = load i32, i32* %num_altsetting, align 8, !tbaa !107
  %cmp14 = icmp ult i32 %i.1, %4
  br i1 %cmp14, label %for.body16, label %for.end31

for.body16:                                       ; preds = %for.cond13
  %altsetting17 = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intf_cache.0, i32 0, i32 2
  %idxprom18 = sext i32 %i.1 to i64
  %arrayidx19 = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting17, i64 0, i64 %idxprom18
  %desc20 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx19, i32 0, i32 0
  %bAlternateSetting = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc20, i32 0, i32 3
  %5 = load i8, i8* %bAlternateSetting, align 1, !tbaa !99
  %conv21 = zext i8 %5 to i32
  %cmp22 = icmp eq i32 %conv21, %alt_num
  br i1 %cmp22, label %if.then24, label %for.inc29

if.then24:                                        ; preds = %for.body16
  %altsetting25 = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intf_cache.0, i32 0, i32 2
  %idxprom26 = sext i32 %i.1 to i64
  %arrayidx27 = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting25, i64 0, i64 %idxprom26
  br label %cleanup

for.inc29:                                        ; preds = %for.body16
  %inc30 = add nsw i32 %i.1, 1
  br label %for.cond13

for.end31:                                        ; preds = %for.cond13
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %for.end31, %if.then24, %for.end
  %retval.0 = phi %struct.usb_host_interface* [ %arrayidx27, %if.then24 ], [ null, %for.end31 ], [ null, %for.end ]
  ret %struct.usb_host_interface* %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_disabled() #0 {
entry:
  %0 = load i8, i8* @nousb, align 1, !tbaa !109, !range !110
  %tobool = trunc i8 %0 to i1
  %conv = zext i1 %tobool to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_init() #5 section ".init.text" {
entry:
  %call = call i32 @usb_disabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @usb_init_pool_max()
  %call3 = call i32 @usb_debugfs_init()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %call7 = call i32 @usb_acpi_register()
  %call8 = call i32 @bus_register(%struct.bus_type* @usb_bus_type)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %bus_register_failed, label %if.end11

if.end11:                                         ; preds = %if.end6
  %call12 = call i32 @bus_register_notifier(%struct.bus_type* @usb_bus_type, %struct.notifier_block* @usb_bus_nb)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %bus_notifier_failed, label %if.end15

if.end15:                                         ; preds = %if.end11
  %call16 = call i32 @usb_major_init()
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %major_init_failed, label %if.end19

if.end19:                                         ; preds = %if.end15
  %call20 = call i32 @usb_register_driver(%struct.usb_driver* @usbfs_driver, %struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0))
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %driver_register_failed, label %if.end23

if.end23:                                         ; preds = %if.end19
  %call24 = call i32 @usb_devio_init()
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %usb_devio_init_failed, label %if.end27

if.end27:                                         ; preds = %if.end23
  %call28 = call i32 @usb_hub_init()
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %hub_init_failed, label %if.end31

if.end31:                                         ; preds = %if.end27
  %call32 = call i32 @usb_register_device_driver(%struct.usb_device_driver* @usb_generic_driver, %struct.module* @__this_module)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.end35, label %cleanup

if.end35:                                         ; preds = %if.end31
  call void @usb_hub_cleanup()
  br label %hub_init_failed

hub_init_failed:                                  ; preds = %if.end35, %if.end27
  %retval1.0 = phi i32 [ %call32, %if.end35 ], [ %call28, %if.end27 ]
  call void @usb_devio_cleanup()
  br label %usb_devio_init_failed

usb_devio_init_failed:                            ; preds = %hub_init_failed, %if.end23
  %retval1.1 = phi i32 [ %retval1.0, %hub_init_failed ], [ %call24, %if.end23 ]
  call void @usb_deregister(%struct.usb_driver* @usbfs_driver)
  br label %driver_register_failed

driver_register_failed:                           ; preds = %usb_devio_init_failed, %if.end19
  %retval1.2 = phi i32 [ %retval1.1, %usb_devio_init_failed ], [ %call20, %if.end19 ]
  call void @usb_major_cleanup()
  br label %major_init_failed

major_init_failed:                                ; preds = %driver_register_failed, %if.end15
  %retval1.3 = phi i32 [ %retval1.2, %driver_register_failed ], [ %call16, %if.end15 ]
  %call36 = call i32 @bus_unregister_notifier(%struct.bus_type* @usb_bus_type, %struct.notifier_block* @usb_bus_nb)
  br label %bus_notifier_failed

bus_notifier_failed:                              ; preds = %major_init_failed, %if.end11
  %retval1.4 = phi i32 [ %retval1.3, %major_init_failed ], [ %call12, %if.end11 ]
  call void @bus_unregister(%struct.bus_type* @usb_bus_type)
  br label %bus_register_failed

bus_register_failed:                              ; preds = %bus_notifier_failed, %if.end6
  %retval1.5 = phi i32 [ %retval1.4, %bus_notifier_failed ], [ %call8, %if.end6 ]
  call void @usb_acpi_unregister()
  call void @usb_debugfs_cleanup()
  br label %cleanup

cleanup:                                          ; preds = %bus_register_failed, %if.end31, %if.end, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ %retval1.5, %bus_register_failed ], [ %call3, %if.end ], [ %call32, %if.end31 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_debugfs_init() #0 {
entry:
  %call = call %struct.dentry* @debugfs_create_dir(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18.951, i32 0, i32 0), %struct.dentry* null)
  store %struct.dentry* %call, %struct.dentry** @usb_debug_root, align 8, !tbaa !52
  %0 = load %struct.dentry*, %struct.dentry** @usb_debug_root, align 8, !tbaa !52
  %tobool = icmp ne %struct.dentry* %0, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.dentry*, %struct.dentry** @usb_debug_root, align 8, !tbaa !52
  %call1 = call %struct.dentry* @debugfs_create_file(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.13, i32 0, i32 0), i16 zeroext 292, %struct.dentry* %1, i8* null, %struct.file_operations* @usbfs_devices_fops)
  store %struct.dentry* %call1, %struct.dentry** @usb_debug_devices, align 8, !tbaa !52
  %2 = load %struct.dentry*, %struct.dentry** @usb_debug_devices, align 8, !tbaa !52
  %tobool2 = icmp ne %struct.dentry* %2, null
  br i1 %tobool2, label %return, label %if.then3

if.then3:                                         ; preds = %if.end
  %3 = load %struct.dentry*, %struct.dentry** @usb_debug_root, align 8, !tbaa !52
  call void @debugfs_remove(%struct.dentry* %3)
  store %struct.dentry* null, %struct.dentry** @usb_debug_root, align 8, !tbaa !52
  br label %return

return:                                           ; preds = %if.then3, %if.end, %entry
  %retval.0 = phi i32 [ -2, %if.then3 ], [ -2, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare i32 @bus_register(%struct.bus_type*) #2

declare i32 @bus_register_notifier(%struct.bus_type*, %struct.notifier_block*) #2

declare i32 @bus_unregister_notifier(%struct.bus_type*, %struct.notifier_block*) #2

declare void @bus_unregister(%struct.bus_type*) #2

; Function Attrs: nounwind uwtable
define internal void @usb_debugfs_cleanup() #0 {
entry:
  %0 = load %struct.dentry*, %struct.dentry** @usb_debug_devices, align 8, !tbaa !52
  call void @debugfs_remove(%struct.dentry* %0)
  %1 = load %struct.dentry*, %struct.dentry** @usb_debug_root, align 8, !tbaa !52
  call void @debugfs_remove(%struct.dentry* %1)
  ret void
}

declare void @debugfs_remove(%struct.dentry*) #2

; Function Attrs: nounwind uwtable
define internal i32 @usb_bus_notify(%struct.notifier_block* %nb, i64 %action, i8* %data) #0 {
entry:
  %0 = bitcast i8* %data to %struct.device*
  %Pivot = icmp slt i64 %action, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i64 %action, 2
  br i1 %SwitchLeaf2, label %sw.bb8, label %sw.epilog

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i64 %action, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %type = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 4
  %1 = load %struct.device_type*, %struct.device_type** %type, align 8, !tbaa !91
  %cmp = icmp eq %struct.device_type* %1, @usb_device_type
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %2 = bitcast %struct.device* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -152
  %3 = bitcast i8* %add.ptr to %struct.usb_device*
  %call = call i32 @usb_create_sysfs_dev_files(%struct.usb_device* %3)
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb
  %type1 = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 4
  %4 = load %struct.device_type*, %struct.device_type** %type1, align 8, !tbaa !91
  %cmp2 = icmp eq %struct.device_type* %4, @usb_if_device_type
  br i1 %cmp2, label %if.then3, label %sw.epilog

if.then3:                                         ; preds = %if.else
  %5 = bitcast %struct.device* %0 to i8*
  %add.ptr6 = getelementptr inbounds i8, i8* %5, i64 -48
  %6 = bitcast i8* %add.ptr6 to %struct.usb_interface*
  call void @usb_create_sysfs_intf_files(%struct.usb_interface* %6)
  br label %sw.epilog

sw.bb8:                                           ; preds = %LeafBlock1
  %type9 = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 4
  %7 = load %struct.device_type*, %struct.device_type** %type9, align 8, !tbaa !91
  %cmp10 = icmp eq %struct.device_type* %7, @usb_device_type
  br i1 %cmp10, label %if.then11, label %if.else15

if.then11:                                        ; preds = %sw.bb8
  %8 = bitcast %struct.device* %0 to i8*
  %add.ptr14 = getelementptr inbounds i8, i8* %8, i64 -152
  %9 = bitcast i8* %add.ptr14 to %struct.usb_device*
  call void @usb_remove_sysfs_dev_files(%struct.usb_device* %9)
  br label %sw.epilog

if.else15:                                        ; preds = %sw.bb8
  %type16 = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 4
  %10 = load %struct.device_type*, %struct.device_type** %type16, align 8, !tbaa !91
  %cmp17 = icmp eq %struct.device_type* %10, @usb_if_device_type
  br i1 %cmp17, label %if.then18, label %sw.epilog

if.then18:                                        ; preds = %if.else15
  %11 = bitcast %struct.device* %0 to i8*
  %add.ptr21 = getelementptr inbounds i8, i8* %11, i64 -48
  %12 = bitcast i8* %add.ptr21 to %struct.usb_interface*
  call void @usb_remove_sysfs_intf_files(%struct.usb_interface* %12)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then18, %if.else15, %if.then11, %if.then3, %if.else, %if.then, %LeafBlock, %LeafBlock1
  ret i32 0
}

declare %struct.dentry* @debugfs_create_dir(i8*, %struct.dentry*) #2

declare %struct.dentry* @debugfs_create_file(i8*, i16 zeroext, %struct.dentry*, i8*, %struct.file_operations*) #2

; Function Attrs: nounwind uwtable
define internal void @usb_exit() #5 section ".exit.text" {
entry:
  %call = call i32 @usb_disabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @usb_deregister_device_driver(%struct.usb_device_driver* @usb_generic_driver)
  call void @usb_major_cleanup()
  call void @usb_deregister(%struct.usb_driver* @usbfs_driver)
  call void @usb_devio_cleanup()
  call void @usb_hub_cleanup()
  %call1 = call i32 @bus_unregister_notifier(%struct.bus_type* @usb_bus_type, %struct.notifier_block* @usb_bus_nb)
  call void @bus_unregister(%struct.bus_type* @usb_bus_type)
  call void @usb_acpi_unregister()
  call void @usb_debugfs_cleanup()
  call void @idr_destroy(%struct.idr* @usb_bus_idr)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare void @idr_destroy(%struct.idr*) #2

; Function Attrs: nounwind uwtable
define %struct.usb_device* @usb_hub_find_child(%struct.usb_device* %hdev, i32 %port1) #0 {
entry:
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  %cmp = icmp slt i32 %port1, 1
  br i1 %cmp, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 28
  %0 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp1 = icmp sgt i32 %port1, %0
  br i1 %cmp1, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %1 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %1, i64 %idxprom
  %2 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %2, i32 0, i32 0
  %3 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !115
  br label %cleanup

cleanup:                                          ; preds = %if.end, %lor.lhs.false, %entry
  %retval.0 = phi %struct.usb_device* [ %3, %if.end ], [ null, %lor.lhs.false ], [ null, %entry ]
  ret %struct.usb_device* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev) #0 {
entry:
  %tobool = icmp ne %struct.usb_device* %hdev, null
  br i1 %tobool, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %entry
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool1 = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool1, label %lor.lhs.false2, label %return

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 28
  %1 = load i32, i32* %maxchild, align 8, !tbaa !111
  %tobool3 = icmp ne i32 %1, 0
  br i1 %tobool3, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false2
  %actconfig4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig4, align 8, !tbaa !102
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 3
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 0
  %3 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !52
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %3)
  %4 = bitcast i8* %call to %struct.usb_hub*
  br label %return

return:                                           ; preds = %if.end, %lor.lhs.false2, %lor.lhs.false, %entry
  %retval.0 = phi %struct.usb_hub* [ %4, %if.end ], [ null, %lor.lhs.false2 ], [ null, %lor.lhs.false ], [ null, %entry ]
  ret %struct.usb_hub* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @usb_get_intfdata(%struct.usb_interface* %intf) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_get_drvdata(%struct.device* %dev) #1 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !117
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define void @usb_queue_reset_device(%struct.usb_interface* %iface) #0 {
entry:
  %reset_ws = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 10
  %call = call zeroext i1 @schedule_work(%struct.work_struct* %reset_ws)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call %struct.usb_interface* @usb_get_intf(%struct.usb_interface* %iface)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @schedule_work(%struct.work_struct* %work) #1 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8, !tbaa !52
  %call = call zeroext i1 @queue_work(%struct.workqueue_struct* %0, %struct.work_struct* %work)
  ret i1 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @queue_work(%struct.workqueue_struct* %wq, %struct.work_struct* %work) #1 {
entry:
  %call = call zeroext i1 @queue_work_on(i32 8192, %struct.workqueue_struct* %wq, %struct.work_struct* %work)
  ret i1 %call
}

declare zeroext i1 @queue_work_on(i32, %struct.workqueue_struct*, %struct.work_struct*) #2

; Function Attrs: nounwind uwtable
define i32 @usb_reset_device(%struct.usb_device* %udev) #0 {
entry:
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %1 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %1)
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %2 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %do.body3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %state1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %3 = load i32, i32* %state1, align 8, !tbaa !54
  %cmp2 = icmp eq i32 %3, 8
  br i1 %cmp2, label %do.body3, label %if.end10

do.body3:                                         ; preds = %lor.lhs.false, %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_reset_device.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then6, label %cleanup

if.then6:                                         ; preds = %do.body3
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %state7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %4 = load i32, i32* %state7, align 8, !tbaa !54
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_reset_device.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.42, i32 0, i32 0), i32 %4)
  br label %cleanup

if.end10:                                         ; preds = %lor.lhs.false
  %parent11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %5 = load %struct.usb_device*, %struct.usb_device** %parent11, align 8, !tbaa !79
  %tobool12 = icmp ne %struct.usb_device* %5, null
  br i1 %tobool12, label %if.end35, label %do.body15

do.body15:                                        ; preds = %if.end10
  %bf.load16 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_reset_device.descriptor.43 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr17 = lshr i32 %bf.load16, 18
  %bf.clear18 = and i32 %bf.lshr17, 255
  %and19 = and i32 %bf.clear18, 1
  %tobool20 = icmp ne i32 %and19, 0
  %lnot21 = xor i1 %tobool20, true
  %lnot23 = xor i1 %lnot21, true
  %lnot.ext24 = zext i1 %lnot23 to i32
  %conv25 = sext i32 %lnot.ext24 to i64
  %expval26 = call i64 @llvm.expect.i64(i64 %conv25, i64 0)
  %tobool27 = icmp ne i64 %expval26, 0
  br i1 %tobool27, label %if.then28, label %cleanup

if.then28:                                        ; preds = %do.body15
  %dev29 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_reset_device.descriptor.43 to %struct._ddebug*), %struct.device* %dev29, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.44, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.usb_reset_device, i32 0, i32 0))
  br label %cleanup

if.end35:                                         ; preds = %if.end10
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %6 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %7 = load i8, i8* %portnum, align 2, !tbaa !81
  %conv36 = zext i8 %7 to i32
  %sub = sub nsw i32 %conv36, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %6, i64 %idxprom
  %8 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %call37 = call i32 @memalloc_noio_save()
  %call38 = call i32 @usb_autoresume_device(%struct.usb_device* %udev)
  %tobool39 = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool39, label %if.then40, label %if.end65

if.then40:                                        ; preds = %if.end35
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then40
  %i.0 = phi i32 [ 0, %if.then40 ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %9 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv41 = zext i8 %9 to i32
  %cmp42 = icmp slt i32 %i.0, %conv41
  br i1 %cmp42, label %for.body, label %if.end65

for.body:                                         ; preds = %for.cond
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 3
  %idxprom44 = sext i32 %i.0 to i64
  %arrayidx45 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom44
  %10 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx45, align 8, !tbaa !52
  %dev46 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %10, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev46, i32 0, i32 7
  %11 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !118
  %tobool47 = icmp ne %struct.device_driver* %11, null
  br i1 %tobool47, label %if.then48, label %for.inc

if.then48:                                        ; preds = %for.body
  %dev49 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %10, i32 0, i32 7
  %driver50 = getelementptr inbounds %struct.device, %struct.device* %dev49, i32 0, i32 7
  %12 = load %struct.device_driver*, %struct.device_driver** %driver50, align 8, !tbaa !118
  %13 = bitcast %struct.device_driver* %12 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %13, i64 -168
  %14 = bitcast i8* %add.ptr to %struct.usb_driver*
  %pre_reset = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %14, i32 0, i32 7
  %15 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %pre_reset, align 8, !tbaa !119
  %tobool51 = icmp ne i32 (%struct.usb_interface*)* %15, null
  br i1 %tobool51, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then48
  %post_reset = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %14, i32 0, i32 8
  %16 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %post_reset, align 8, !tbaa !124
  %tobool52 = icmp ne i32 (%struct.usb_interface*)* %16, null
  br i1 %tobool52, label %if.then53, label %if.else

if.then53:                                        ; preds = %land.lhs.true
  %pre_reset54 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %14, i32 0, i32 7
  %17 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %pre_reset54, align 8, !tbaa !119
  %call55 = call i32 %17(%struct.usb_interface* %10)
  br label %if.end60

if.else:                                          ; preds = %land.lhs.true, %if.then48
  %condition = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %10, i32 0, i32 5
  %18 = load i32, i32* %condition, align 4, !tbaa !55
  %cmp56 = icmp eq i32 %18, 2
  %. = select i1 %cmp56, i32 1, i32 0
  br label %if.end60

if.end60:                                         ; preds = %if.else, %if.then53
  %unbind.1 = phi i32 [ %call55, %if.then53 ], [ %., %if.else ]
  %tobool61 = icmp ne i32 %unbind.1, 0
  br i1 %tobool61, label %if.then62, label %for.inc

if.then62:                                        ; preds = %if.end60
  call void @usb_forced_unbind_intf(%struct.usb_interface* %10)
  br label %for.inc

for.inc:                                          ; preds = %if.then62, %if.end60, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end65:                                         ; preds = %for.cond, %if.end35
  call void @usb_lock_port(%struct.usb_port* %8)
  %call66 = call i32 @usb_reset_and_verify_device(%struct.usb_device* %udev)
  call void @usb_unlock_port(%struct.usb_port* %8)
  %tobool67 = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool67, label %if.then68, label %if.end117

if.then68:                                        ; preds = %if.end65
  %desc69 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 0
  %bNumInterfaces70 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc69, i32 0, i32 3
  %19 = load i8, i8* %bNumInterfaces70, align 4, !tbaa !103
  %conv71 = zext i8 %19 to i32
  %sub72 = sub nsw i32 %conv71, 1
  br label %for.cond73

for.cond73:                                       ; preds = %for.inc115, %if.then68
  %i.1 = phi i32 [ %sub72, %if.then68 ], [ %dec, %for.inc115 ]
  %cmp74 = icmp sge i32 %i.1, 0
  br i1 %cmp74, label %for.body76, label %for.end116

for.body76:                                       ; preds = %for.cond73
  %interface78 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 3
  %idxprom79 = sext i32 %i.1 to i64
  %arrayidx80 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface78, i64 0, i64 %idxprom79
  %20 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx80, align 8, !tbaa !52
  %needs_binding = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %20, i32 0, i32 6
  %bf.load82 = load i8, i8* %needs_binding, align 8
  %bf.lshr83 = lshr i8 %bf.load82, 5
  %bf.clear84 = and i8 %bf.lshr83, 1
  %bf.cast = zext i8 %bf.clear84 to i32
  %tobool85 = icmp ne i32 %bf.cast, 0
  br i1 %tobool85, label %for.inc115, label %land.lhs.true86

land.lhs.true86:                                  ; preds = %for.body76
  %dev87 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %20, i32 0, i32 7
  %driver88 = getelementptr inbounds %struct.device, %struct.device* %dev87, i32 0, i32 7
  %21 = load %struct.device_driver*, %struct.device_driver** %driver88, align 8, !tbaa !118
  %tobool89 = icmp ne %struct.device_driver* %21, null
  br i1 %tobool89, label %if.then90, label %for.inc115

if.then90:                                        ; preds = %land.lhs.true86
  %dev92 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %20, i32 0, i32 7
  %driver93 = getelementptr inbounds %struct.device, %struct.device* %dev92, i32 0, i32 7
  %22 = load %struct.device_driver*, %struct.device_driver** %driver93, align 8, !tbaa !118
  %23 = bitcast %struct.device_driver* %22 to i8*
  %add.ptr95 = getelementptr inbounds i8, i8* %23, i64 -168
  %24 = bitcast i8* %add.ptr95 to %struct.usb_driver*
  %post_reset96 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %24, i32 0, i32 8
  %25 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %post_reset96, align 8, !tbaa !124
  %tobool97 = icmp ne i32 (%struct.usb_interface*)* %25, null
  br i1 %tobool97, label %if.then98, label %if.else101

if.then98:                                        ; preds = %if.then90
  %post_reset99 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %24, i32 0, i32 8
  %26 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %post_reset99, align 8, !tbaa !124
  %call100 = call i32 %26(%struct.usb_interface* %20)
  br label %if.end107

if.else101:                                       ; preds = %if.then90
  %condition102 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %20, i32 0, i32 5
  %27 = load i32, i32* %condition102, align 4, !tbaa !55
  %cmp103 = icmp eq i32 %27, 2
  %.bf.cast = select i1 %cmp103, i32 1, i32 %bf.cast
  br label %if.end107

if.end107:                                        ; preds = %if.else101, %if.then98
  %rebind.1 = phi i32 [ %call100, %if.then98 ], [ %.bf.cast, %if.else101 ]
  %tobool108 = icmp ne i32 %rebind.1, 0
  br i1 %tobool108, label %if.then109, label %for.inc115

if.then109:                                       ; preds = %if.end107
  %needs_binding110 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %20, i32 0, i32 6
  %bf.load111 = load i8, i8* %needs_binding110, align 8
  %bf.clear112 = and i8 %bf.load111, -33
  %bf.set = or i8 %bf.clear112, 32
  store i8 %bf.set, i8* %needs_binding110, align 8
  br label %for.inc115

for.inc115:                                       ; preds = %if.then109, %if.end107, %land.lhs.true86, %for.body76
  %dec = add nsw i32 %i.1, -1
  br label %for.cond73

for.end116:                                       ; preds = %for.cond73
  call void @usb_unbind_and_rebind_marked_interfaces(%struct.usb_device* %udev)
  br label %if.end117

if.end117:                                        ; preds = %for.end116, %if.end65
  call void @usb_autosuspend_device(%struct.usb_device* %udev)
  call void @memalloc_noio_restore(i32 %call37)
  br label %cleanup

cleanup:                                          ; preds = %if.end117, %if.then28, %do.body15, %if.then6, %do.body3
  %retval.0 = phi i32 [ %call66, %if.end117 ], [ -22, %if.then6 ], [ -22, %do.body3 ], [ -21, %if.then28 ], [ -21, %do.body15 ]
  ret i32 %retval.0
}

declare void @__dynamic_dev_dbg(%struct._ddebug*, %struct.device*, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @memalloc_noio_save() #1 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !125
  %flags1 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 4
  %1 = load i32, i32* %flags1, align 4, !tbaa !126
  %and = and i32 %1, 524288
  %2 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !125
  %flags3 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %2, i32 0, i32 4
  %3 = load i32, i32* %flags3, align 4, !tbaa !126
  %or = or i32 %3, 524288
  store i32 %or, i32* %flags3, align 4, !tbaa !126
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal void @usb_lock_port(%struct.usb_port* %port_dev) #0 {
entry:
  %status_lock = getelementptr inbounds %struct.usb_port, %struct.usb_port* %port_dev, i32 0, i32 7
  call void @mutex_lock_nested(%struct.mutex* %status_lock, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_reset_and_verify_device(%struct.usb_device* %udev) #0 {
entry:
  %descriptor = alloca %struct.usb_device_descriptor, align 1
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %1)
  %descriptor1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %2 = bitcast %struct.usb_device_descriptor* %descriptor to i8*
  %3 = bitcast %struct.usb_device_descriptor* %descriptor1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 18, i32 1, i1 false), !tbaa.struct !164
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %4 = load i8, i8* %portnum, align 2, !tbaa !81
  %conv = zext i8 %4 to i32
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %5 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %5, 0
  br i1 %cmp, label %do.body6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %state3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %6 = load i32, i32* %state3, align 8, !tbaa !54
  %cmp4 = icmp eq i32 %6, 8
  br i1 %cmp4, label %do.body6, label %if.end14

do.body6:                                         ; preds = %lor.lhs.false, %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_reset_and_verify_device.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv8 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %cleanup144

if.then10:                                        ; preds = %do.body6
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %state11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %7 = load i32, i32* %state11, align 8, !tbaa !54
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_reset_and_verify_device.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.42, i32 0, i32 0), i32 %7)
  br label %cleanup144

if.end14:                                         ; preds = %lor.lhs.false
  %tobool15 = icmp ne %struct.usb_device* %0, null
  br i1 %tobool15, label %if.end17, label %cleanup144

if.end17:                                         ; preds = %if.end14
  %call18 = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %0)
  %usb2_hw_lpm_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load19 = load i16, i16* %usb2_hw_lpm_enabled, align 4
  %bf.lshr20 = lshr i16 %bf.load19, 9
  %bf.clear21 = and i16 %bf.lshr20, 1
  %bf.cast = zext i16 %bf.clear21 to i32
  %cmp22 = icmp eq i32 %bf.cast, 1
  br i1 %cmp22, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end17
  %call25 = call i32 @usb_set_usb2_hardware_lpm(%struct.usb_device* %udev, i32 0)
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end17
  %call27 = call i32 @usb_unlocked_disable_lpm(%struct.usb_device* %udev)
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end26
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %re_enumerate_no_bos

if.end31:                                         ; preds = %if.end26
  %call32 = call i32 @usb_disable_ltm(%struct.usb_device* %udev)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end31
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %re_enumerate_no_bos

if.end36:                                         ; preds = %if.end31
  %bos37 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %8 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos37, align 8, !tbaa !166
  %bos38 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  store %struct.usb_host_bos* null, %struct.usb_host_bos** %bos38, align 8, !tbaa !166
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end36
  %i.0 = phi i32 [ 0, %if.end36 ], [ %inc, %for.inc ]
  %ret.0 = phi i32 [ %call32, %if.end36 ], [ %call43, %for.inc ]
  %9 = load i8, i8* @use_both_schemes, align 1, !tbaa !109, !range !110
  %tobool39 = trunc i8 %9 to i1
  %conv40 = zext i1 %tobool39 to i32
  %add = add nsw i32 %conv40, 1
  %mul = mul nsw i32 2, %add
  %cmp41 = icmp slt i32 %i.0, %mul
  br i1 %cmp41, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @usb_ep0_reinit(%struct.usb_device* %udev)
  %call43 = call i32 @hub_port_init(%struct.usb_hub* %call18, %struct.usb_device* %udev, i32 %conv, i32 %i.0)
  %cmp44 = icmp sge i32 %call43, 0
  br i1 %cmp44, label %for.end, label %switch.early.test

switch.early.test:                                ; preds = %for.body
  switch i32 %call43, label %for.inc [
    i32 -19, label %for.end
    i32 -107, label %for.end
  ]

for.inc:                                          ; preds = %switch.early.test
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %switch.early.test, %switch.early.test, %for.body, %for.cond
  %ret.1 = phi i32 [ %call43, %switch.early.test ], [ %ret.0, %for.cond ], [ %call43, %for.body ], [ %call43, %switch.early.test ]
  %cmp54 = icmp slt i32 %ret.1, 0
  br i1 %cmp54, label %re_enumerate, label %if.end57

if.end57:                                         ; preds = %for.end
  %call58 = call i32 @descriptors_changed(%struct.usb_device* %udev, %struct.usb_device_descriptor* %descriptor, %struct.usb_host_bos* %8)
  %tobool59 = icmp ne i32 %call58, 0
  br i1 %tobool59, label %if.then60, label %if.end63

if.then60:                                        ; preds = %if.end57
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %descriptor62 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %10 = bitcast %struct.usb_device_descriptor* %descriptor62 to i8*
  %11 = bitcast %struct.usb_device_descriptor* %descriptor to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 18, i32 1, i1 false), !tbaa.struct !164
  br label %re_enumerate

if.end63:                                         ; preds = %if.end57
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %12 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool64 = icmp ne %struct.usb_host_config* %12, null
  br i1 %tobool64, label %if.end66, label %done

if.end66:                                         ; preds = %if.end63
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %13 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !167
  call void @mutex_lock_nested(%struct.mutex* %13, i32 0)
  %actconfig67 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %14 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig67, align 8, !tbaa !102
  %call68 = call i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %udev, %struct.usb_host_config* %14, %struct.usb_host_interface* null, %struct.usb_host_interface* null)
  %cmp69 = icmp slt i32 %call68, 0
  br i1 %cmp69, label %if.then71, label %if.end74

if.then71:                                        ; preds = %if.end66
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %bandwidth_mutex73 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %15 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex73, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %15)
  br label %re_enumerate

if.end74:                                         ; preds = %if.end66
  %call75 = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or = or i32 -2147483648, %call75
  %actconfig76 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %16 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig76, align 8, !tbaa !102
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %16, i32 0, i32 0
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 4
  %17 = load i8, i8* %bConfigurationValue, align 1, !tbaa !168
  %conv77 = zext i8 %17 to i16
  %call78 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext 9, i8 zeroext 0, i16 zeroext %conv77, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  %cmp79 = icmp slt i32 %call78, 0
  br i1 %cmp79, label %if.then81, label %if.end88

if.then81:                                        ; preds = %if.end74
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %bandwidth_mutex87 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %18 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex87, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %18)
  br label %re_enumerate

if.end88:                                         ; preds = %if.end74
  %bandwidth_mutex89 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %19 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex89, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %19)
  call void @usb_set_device_state(%struct.usb_device* %udev, i32 7)
  br label %for.cond90

for.cond90:                                       ; preds = %for.inc138, %if.end88
  %i.1 = phi i32 [ 0, %if.end88 ], [ %inc139, %for.inc138 ]
  %actconfig91 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %20 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig91, align 8, !tbaa !102
  %desc92 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %20, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc92, i32 0, i32 3
  %21 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv93 = zext i8 %21 to i32
  %cmp94 = icmp slt i32 %i.1, %conv93
  br i1 %cmp94, label %for.body96, label %done

for.body96:                                       ; preds = %for.cond90
  %actconfig97 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %22 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig97, align 8, !tbaa !102
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %22, i32 0, i32 3
  %idxprom = sext i32 %i.1 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %23 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !52
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %23, i32 0, i32 1
  %24 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !169
  %desc99 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %24, i32 0, i32 0
  %bAlternateSetting = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc99, i32 0, i32 3
  %25 = load i8, i8* %bAlternateSetting, align 1, !tbaa !170
  %conv100 = zext i8 %25 to i32
  %cmp101 = icmp eq i32 %conv100, 0
  br i1 %cmp101, label %if.then103, label %if.else

if.then103:                                       ; preds = %for.body96
  call void @usb_disable_interface(%struct.usb_device* %udev, %struct.usb_interface* %23, i1 zeroext true)
  call void @usb_enable_interface(%struct.usb_device* %udev, %struct.usb_interface* %23, i1 zeroext true)
  br label %if.end113

if.else:                                          ; preds = %for.body96
  %resetting_device = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %23, i32 0, i32 6
  %bf.load104 = load i8, i8* %resetting_device, align 8
  %bf.clear105 = and i8 %bf.load104, -65
  %bf.set = or i8 %bf.clear105, 64
  store i8 %bf.set, i8* %resetting_device, align 8
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc99, i32 0, i32 2
  %26 = load i8, i8* %bInterfaceNumber, align 1, !tbaa !171
  %conv106 = zext i8 %26 to i32
  %bAlternateSetting107 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc99, i32 0, i32 3
  %27 = load i8, i8* %bAlternateSetting107, align 1, !tbaa !170
  %conv108 = zext i8 %27 to i32
  %call109 = call i32 @usb_set_interface(%struct.usb_device* %udev, i32 %conv106, i32 %conv108)
  %resetting_device110 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %23, i32 0, i32 6
  %bf.load111 = load i8, i8* %resetting_device110, align 8
  %bf.clear112 = and i8 %bf.load111, -65
  store i8 %bf.clear112, i8* %resetting_device110, align 8
  br label %if.end113

if.end113:                                        ; preds = %if.else, %if.then103
  %ret.2 = phi i32 [ 0, %if.then103 ], [ %call109, %if.else ]
  %cmp114 = icmp slt i32 %ret.2, 0
  br i1 %cmp114, label %if.then116, label %if.end122

if.then116:                                       ; preds = %if.end113
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %NodeBlock

if.end122:                                        ; preds = %if.end113
  br label %for.cond123

for.cond123:                                      ; preds = %for.body129, %if.end122
  %j.0 = phi i32 [ 0, %if.end122 ], [ %inc134, %for.body129 ]
  %cur_altsetting124 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %23, i32 0, i32 1
  %28 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting124, align 8, !tbaa !169
  %desc125 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %28, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc125, i32 0, i32 4
  %29 = load i8, i8* %bNumEndpoints, align 4, !tbaa !172
  %conv126 = zext i8 %29 to i32
  %cmp127 = icmp slt i32 %j.0, %conv126
  br i1 %cmp127, label %for.body129, label %NodeBlock

for.body129:                                      ; preds = %for.cond123
  %cur_altsetting130 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %23, i32 0, i32 1
  %30 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting130, align 8, !tbaa !169
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %30, i32 0, i32 3
  %31 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !173
  %idxprom131 = sext i32 %j.0 to i64
  %arrayidx132 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %31, i64 %idxprom131
  %streams = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx132, i32 0, i32 10
  store i32 0, i32* %streams, align 8, !tbaa !174
  %inc134 = add nsw i32 %j.0, 1
  br label %for.cond123

NodeBlock:                                        ; preds = %for.cond123, %if.then116
  %cleanup.dest.slot.0 = phi i32 [ 10, %if.then116 ], [ 0, %for.cond123 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 10
  br i1 %SwitchLeaf2, label %re_enumerate, label %cleanup144

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc138, label %cleanup144

for.inc138:                                       ; preds = %LeafBlock
  %inc139 = add nsw i32 %i.1, 1
  br label %for.cond90

done:                                             ; preds = %for.cond90, %if.end63
  %call141 = call i32 @usb_set_usb2_hardware_lpm(%struct.usb_device* %udev, i32 1)
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %udev)
  call void @usb_enable_ltm(%struct.usb_device* %udev)
  call void @usb_release_bos_descriptor(%struct.usb_device* %udev)
  %bos142 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  store %struct.usb_host_bos* %8, %struct.usb_host_bos** %bos142, align 8, !tbaa !166
  br label %cleanup144

re_enumerate:                                     ; preds = %LeafBlock1, %if.then81, %if.then71, %if.then60, %for.end
  call void @usb_release_bos_descriptor(%struct.usb_device* %udev)
  %bos143 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  store %struct.usb_host_bos* %8, %struct.usb_host_bos** %bos143, align 8, !tbaa !166
  br label %re_enumerate_no_bos

re_enumerate_no_bos:                              ; preds = %re_enumerate, %if.then34, %if.then29
  call void @hub_port_logical_disconnect(%struct.usb_hub* %call18, i32 %conv)
  br label %cleanup144

cleanup144:                                       ; preds = %re_enumerate_no_bos, %done, %LeafBlock, %LeafBlock1, %if.end14, %if.then10, %do.body6
  %retval.0 = phi i32 [ -19, %re_enumerate_no_bos ], [ 0, %done ], [ -22, %if.then10 ], [ -22, %do.body6 ], [ -21, %if.end14 ], [ undef, %LeafBlock ], [ undef, %LeafBlock1 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @usb_unlock_port(%struct.usb_port* %port_dev) #0 {
entry:
  %status_lock = getelementptr inbounds %struct.usb_port, %struct.usb_port* %port_dev, i32 0, i32 7
  call void @mutex_unlock(%struct.mutex* %status_lock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @memalloc_noio_restore(i32 %flags) #1 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !125
  %flags1 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 4
  %1 = load i32, i32* %flags1, align 4, !tbaa !126
  %and = and i32 %1, -524289
  %or = or i32 %and, %flags
  %2 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !125
  %flags3 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %2, i32 0, i32 4
  store i32 %or, i32* %flags3, align 4, !tbaa !126
  ret void
}

declare void @mutex_unlock(%struct.mutex*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd*
  ret %struct.usb_hcd* %1
}

; Function Attrs: nounwind uwtable
define i32 @usb_unlocked_disable_lpm(%struct.usb_device* %udev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %0)
  %tobool = icmp ne %struct.usb_hcd* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %1 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !167
  call void @mutex_lock_nested(%struct.mutex* %1, i32 0)
  %call1 = call i32 @usb_disable_lpm(%struct.usb_device* %udev)
  %bandwidth_mutex2 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %2 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex2, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %2)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call1, %if.end ], [ -22, %entry ]
  ret i32 %retval.0
}

declare void @dev_err(%struct.device*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define i32 @usb_disable_ltm(%struct.usb_device* %udev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %0)
  %self = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 11
  %1 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !175
  %call1 = call zeroext i1 @usb_device_supports_ltm(%struct.usb_device* %1)
  br i1 %call1, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %call2 = call zeroext i1 @usb_device_supports_ltm(%struct.usb_device* %udev)
  br i1 %call2, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or = or i32 -2147483648, %call5
  %call6 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext 1, i8 zeroext 0, i16 zeroext 50, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ %call6, %if.end4 ], [ 0, %lor.lhs.false ], [ 0, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_ep0_reinit(%struct.usb_device* %udev) #0 {
entry:
  call void @usb_disable_endpoint(%struct.usb_device* %udev, i32 128, i1 zeroext true)
  call void @usb_disable_endpoint(%struct.usb_device* %udev, i32 0, i1 zeroext true)
  %ep0 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 10
  call void @usb_enable_endpoint(%struct.usb_device* %udev, %struct.usb_host_endpoint* %ep0, i1 zeroext true)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_port_init(%struct.usb_hub* %hub, %struct.usb_device* %udev, i32 %port1, i32 %retry_counter) #0 {
entry:
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !176
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %1)
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %2 = load i32, i32* %speed, align 4, !tbaa !177
  %devnum4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  %3 = load i32, i32* %devnum4, align 8, !tbaa !44
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  %4 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool = icmp ne %struct.usb_device* %4, null
  br i1 %tobool, label %if.end9, label %if.then

if.then:                                          ; preds = %entry
  %bus5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %5 = load %struct.usb_bus*, %struct.usb_bus** %bus5, align 8, !tbaa !2
  %otg_port = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %5, i32 0, i32 5
  %6 = load i8, i8* %otg_port, align 2, !tbaa !178
  %conv = zext i8 %6 to i32
  %cmp = icmp eq i32 %port1, %conv
  br i1 %cmp, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.then
  %bus8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %7 = load %struct.usb_bus*, %struct.usb_bus** %bus8, align 8, !tbaa !2
  %b_hnp_enable = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %7, i32 0, i32 6
  %bf.load = load i8, i8* %b_hnp_enable, align 1
  %bf.clear = and i8 %bf.load, -3
  store i8 %bf.clear, i8* %b_hnp_enable, align 1
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.then, %entry
  %delay.0 = phi i32 [ 10, %entry ], [ 50, %if.then7 ], [ 50, %if.then ]
  %cmp10 = icmp eq i32 %2, 1
  %.delay.0 = select i1 %cmp10, i32 200, i32 %delay.0
  %address0_mutex = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 20
  %8 = load %struct.mutex*, %struct.mutex** %address0_mutex, align 8, !tbaa !179
  call void @mutex_lock_nested(%struct.mutex* %8, i32 0)
  %call14 = call i32 @hub_port_reset(%struct.usb_hub* %hub, i32 %port1, %struct.usb_device* %udev, i32 %.delay.0, i1 zeroext false)
  %cmp15 = icmp slt i32 %call14, 0
  br i1 %cmp15, label %fail, label %if.end18

if.end18:                                         ; preds = %if.end9
  %cmp19 = icmp ne i32 %2, 0
  br i1 %cmp19, label %land.lhs.true, label %if.end43

land.lhs.true:                                    ; preds = %if.end18
  %speed21 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %9 = load i32, i32* %speed21, align 4, !tbaa !177
  %cmp22 = icmp ne i32 %2, %9
  br i1 %cmp22, label %land.lhs.true24, label %if.end43

land.lhs.true24:                                  ; preds = %land.lhs.true
  %cmp25 = icmp eq i32 %2, 5
  br i1 %cmp25, label %land.lhs.true27, label %do.body32

land.lhs.true27:                                  ; preds = %land.lhs.true24
  %speed28 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %10 = load i32, i32* %speed28, align 4, !tbaa !177
  %cmp29 = icmp ugt i32 %10, %2
  br i1 %cmp29, label %if.end43, label %do.body32

do.body32:                                        ; preds = %land.lhs.true27, %land.lhs.true24
  %bf.load33 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_init.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load33, 18
  %bf.clear34 = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear34, 1
  %tobool35 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool35, true
  %lnot36 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot36 to i32
  %conv37 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv37, i64 0)
  %tobool38 = icmp ne i64 %expval, 0
  br i1 %tobool38, label %if.then39, label %fail

if.then39:                                        ; preds = %do.body32
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_init.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.165, i32 0, i32 0))
  br label %fail

if.end43:                                         ; preds = %land.lhs.true27, %land.lhs.true, %if.end18
  %speed44 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %11 = load i32, i32* %speed44, align 4, !tbaa !177
  %speed45 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %12 = load i32, i32* %speed45, align 4, !tbaa !177
  %Pivot6 = icmp slt i32 %12, 3
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %if.end43
  %Pivot4 = icmp slt i32 %12, 4
  br i1 %Pivot4, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %.off = add i32 %12, -4
  %SwitchLeaf2 = icmp ule i32 %.off, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %fail

NodeBlock:                                        ; preds = %if.end43
  %Pivot = icmp slt i32 %12, 2
  br i1 %Pivot, label %LeafBlock, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %12, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %fail

sw.epilog:                                        ; preds = %LeafBlock, %NodeBlock, %LeafBlock1, %NodeBlock3
  %.sink = phi i16 [ 64, %NodeBlock3 ], [ 64, %NodeBlock ], [ 8, %LeafBlock ], [ 512, %LeafBlock1 ]
  %ep055 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 10
  %desc56 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep055, i32 0, i32 0
  %wMaxPacketSize57 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc56, i32 0, i32 4
  store i16 %.sink, i16* %wMaxPacketSize57, align 4, !tbaa !180
  %speed58 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %13 = load i32, i32* %speed58, align 4, !tbaa !177
  %cmp59 = icmp eq i32 %13, 4
  br i1 %cmp59, label %if.end64, label %if.else

if.else:                                          ; preds = %sw.epilog
  %speed62 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %14 = load i32, i32* %speed62, align 4, !tbaa !177
  %call63 = call i8* @usb_speed_string(i32 %14)
  br label %if.end64

if.end64:                                         ; preds = %if.else, %sw.epilog
  %speed65 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %15 = load i32, i32* %speed65, align 4, !tbaa !177
  %cmp66 = icmp ult i32 %15, 5
  br i1 %cmp66, label %if.then68, label %if.end72

if.then68:                                        ; preds = %if.end64
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %if.end72

if.end72:                                         ; preds = %if.then68, %if.end64
  %tt = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 5
  %16 = load %struct.usb_tt*, %struct.usb_tt** %tt, align 8, !tbaa !181
  %tobool73 = icmp ne %struct.usb_tt* %16, null
  br i1 %tobool73, label %if.then74, label %if.else78

if.then74:                                        ; preds = %if.end72
  %tt75 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 5
  %17 = load %struct.usb_tt*, %struct.usb_tt** %tt75, align 8, !tbaa !181
  %tt76 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 5
  store %struct.usb_tt* %17, %struct.usb_tt** %tt76, align 8, !tbaa !181
  %ttport = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 6
  %18 = load i32, i32* %ttport, align 8, !tbaa !182
  %ttport77 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 6
  store i32 %18, i32* %ttport77, align 8, !tbaa !182
  br label %if.end97

if.else78:                                        ; preds = %if.end72
  %speed79 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %19 = load i32, i32* %speed79, align 4, !tbaa !177
  %cmp80 = icmp ne i32 %19, 3
  br i1 %cmp80, label %land.lhs.true82, label %if.end97

land.lhs.true82:                                  ; preds = %if.else78
  %speed83 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 4
  %20 = load i32, i32* %speed83, align 4, !tbaa !177
  %cmp84 = icmp eq i32 %20, 3
  br i1 %cmp84, label %if.then86, label %if.end97

if.then86:                                        ; preds = %land.lhs.true82
  %tt87 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %hub88 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt87, i32 0, i32 0
  %21 = load %struct.usb_device*, %struct.usb_device** %hub88, align 8, !tbaa !183
  %tobool89 = icmp ne %struct.usb_device* %21, null
  br i1 %tobool89, label %if.end92, label %if.then90

if.then90:                                        ; preds = %if.then86
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %fail

if.end92:                                         ; preds = %if.then86
  %tt93 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %tt94 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 5
  store %struct.usb_tt* %tt93, %struct.usb_tt** %tt94, align 8, !tbaa !181
  %ttport95 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 6
  store i32 %port1, i32* %ttport95, align 8, !tbaa !182
  br label %if.end97

if.end97:                                         ; preds = %if.end92, %land.lhs.true82, %if.else78, %if.then74
  br label %for.cond

for.cond:                                         ; preds = %for.inc250, %if.end97
  %retval2.0 = phi i32 [ -19, %if.end97 ], [ %retval2.6, %for.inc250 ]
  %retries.0 = phi i32 [ 0, %if.end97 ], [ %inc251, %for.inc250 ]
  %devnum.0 = phi i32 [ %3, %if.end97 ], [ %devnum.3, %for.inc250 ]
  %cmp98 = icmp slt i32 %retries.0, 2
  br i1 %cmp98, label %for.body, label %for.end252

for.body:                                         ; preds = %for.cond
  %call100 = call zeroext i1 @use_new_scheme(%struct.usb_device* %udev, i32 %retry_counter)
  br i1 %call100, label %if.then101, label %if.end182

if.then101:                                       ; preds = %for.body
  %call102 = call i32 @hub_enable_device(%struct.usb_device* %udev)
  %cmp103 = icmp slt i32 %call102, 0
  br i1 %cmp103, label %if.then105, label %if.end107

if.then105:                                       ; preds = %if.then101
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %LeafBlock27

if.end107:                                        ; preds = %if.then101
  %call.i = call noalias i8* @__kmalloc(i64 64, i32 20971520) #8
  %22 = bitcast i8* %call.i to %struct.usb_device_descriptor*
  %tobool109 = icmp ne %struct.usb_device_descriptor* %22, null
  br i1 %tobool109, label %if.end111, label %LeafBlock27

if.end111:                                        ; preds = %if.end107
  br label %for.cond112

for.cond112:                                      ; preds = %for.inc, %if.end111
  %operations.0 = phi i32 [ 0, %if.end111 ], [ %inc, %for.inc ]
  %r.0 = phi i32 [ 0, %if.end111 ], [ %r.2, %for.inc ]
  %cmp113 = icmp slt i32 %operations.0, 3
  br i1 %cmp113, label %for.body115, label %for.end

for.body115:                                      ; preds = %for.cond112
  %bMaxPacketSize0 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %22, i32 0, i32 6
  store i8 0, i8* %bMaxPacketSize0, align 1, !tbaa !184
  %23 = bitcast %struct.usb_device_descriptor* %22 to i8*
  %24 = load i32, i32* @initial_descriptor_timeout, align 4, !tbaa !73
  %call116 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 -2147483520, i8 zeroext 6, i8 zeroext -128, i16 zeroext 256, i16 zeroext 0, i8* %23, i16 zeroext 64, i32 %24)
  %bMaxPacketSize0117 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %22, i32 0, i32 6
  %25 = load i8, i8* %bMaxPacketSize0117, align 1, !tbaa !184
  %conv118 = zext i8 %25 to i32
  %Pivot25 = icmp slt i32 %conv118, 32
  br i1 %Pivot25, label %NodeBlock12, label %NodeBlock22

NodeBlock22:                                      ; preds = %for.body115
  %Pivot23 = icmp slt i32 %conv118, 64
  br i1 %Pivot23, label %LeafBlock14, label %NodeBlock20

NodeBlock20:                                      ; preds = %NodeBlock22
  %Pivot21 = icmp slt i32 %conv118, 255
  br i1 %Pivot21, label %LeafBlock16, label %LeafBlock18

LeafBlock18:                                      ; preds = %NodeBlock20
  %SwitchLeaf19 = icmp eq i32 %conv118, 255
  br i1 %SwitchLeaf19, label %sw.bb119, label %sw.default125

LeafBlock16:                                      ; preds = %NodeBlock20
  %SwitchLeaf17 = icmp eq i32 %conv118, 64
  br i1 %SwitchLeaf17, label %sw.bb119, label %sw.default125

LeafBlock14:                                      ; preds = %NodeBlock22
  %SwitchLeaf15 = icmp eq i32 %conv118, 32
  br i1 %SwitchLeaf15, label %sw.bb119, label %sw.default125

NodeBlock12:                                      ; preds = %for.body115
  %Pivot13 = icmp slt i32 %conv118, 16
  br i1 %Pivot13, label %LeafBlock8, label %LeafBlock10

LeafBlock10:                                      ; preds = %NodeBlock12
  %SwitchLeaf11 = icmp eq i32 %conv118, 16
  br i1 %SwitchLeaf11, label %sw.bb119, label %sw.default125

LeafBlock8:                                       ; preds = %NodeBlock12
  %SwitchLeaf9 = icmp eq i32 %conv118, 8
  br i1 %SwitchLeaf9, label %sw.bb119, label %sw.default125

sw.bb119:                                         ; preds = %LeafBlock8, %LeafBlock10, %LeafBlock14, %LeafBlock16, %LeafBlock18
  %bDescriptorType = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %22, i32 0, i32 1
  %26 = load i8, i8* %bDescriptorType, align 1, !tbaa !185
  %conv120 = zext i8 %26 to i32
  %cmp121 = icmp eq i32 %conv120, 1
  br i1 %cmp121, label %sw.epilog130, label %sw.default125

sw.default125:                                    ; preds = %sw.bb119, %LeafBlock8, %LeafBlock10, %LeafBlock14, %LeafBlock16, %LeafBlock18
  %cmp126 = icmp eq i32 %call116, 0
  %.call116 = select i1 %cmp126, i32 -71, i32 %call116
  br label %sw.epilog130

sw.epilog130:                                     ; preds = %sw.default125, %sw.bb119
  %r.2 = phi i32 [ %.call116, %sw.default125 ], [ 0, %sw.bb119 ]
  switch i32 %r.2, label %for.inc [
    i32 0, label %for.end
    i32 -110, label %land.lhs.true135
  ]

land.lhs.true135:                                 ; preds = %sw.epilog130
  %cmp136 = icmp eq i32 %retries.0, 0
  br i1 %cmp136, label %for.end, label %for.inc

for.inc:                                          ; preds = %land.lhs.true135, %sw.epilog130
  %inc = add nsw i32 %operations.0, 1
  br label %for.cond112

for.end:                                          ; preds = %land.lhs.true135, %sw.epilog130, %for.cond112
  %r.3 = phi i32 [ %r.2, %sw.epilog130 ], [ %r.2, %land.lhs.true135 ], [ %r.0, %for.cond112 ]
  %bMaxPacketSize0140 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %22, i32 0, i32 6
  %27 = load i8, i8* %bMaxPacketSize0140, align 1, !tbaa !184
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bMaxPacketSize0141 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 6
  store i8 %27, i8* %bMaxPacketSize0141, align 1, !tbaa !186
  %28 = bitcast %struct.usb_device_descriptor* %22 to i8*
  call void @kfree(i8* %28)
  %call142 = call i32 @hub_port_reset(%struct.usb_hub* %hub, i32 %port1, %struct.usb_device* %udev, i32 %.delay.0, i1 zeroext false)
  %cmp143 = icmp slt i32 %call142, 0
  br i1 %cmp143, label %LeafBlock27, label %if.end146

if.end146:                                        ; preds = %for.end
  %speed147 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %29 = load i32, i32* %speed147, align 4, !tbaa !177
  %cmp148 = icmp ne i32 %11, %29
  br i1 %cmp148, label %do.body152, label %if.end172

do.body152:                                       ; preds = %if.end146
  %bf.load153 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_init.descriptor.172 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr154 = lshr i32 %bf.load153, 18
  %bf.clear155 = and i32 %bf.lshr154, 255
  %and156 = and i32 %bf.clear155, 1
  %tobool157 = icmp ne i32 %and156, 0
  %lnot158 = xor i1 %tobool157, true
  %lnot160 = xor i1 %lnot158, true
  %lnot.ext161 = zext i1 %lnot160 to i32
  %conv162 = sext i32 %lnot.ext161 to i64
  %expval163 = call i64 @llvm.expect.i64(i64 %conv162, i64 0)
  %tobool164 = icmp ne i64 %expval163, 0
  br i1 %tobool164, label %if.then165, label %LeafBlock27

if.then165:                                       ; preds = %do.body152
  %dev166 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_init.descriptor.172 to %struct._ddebug*), %struct.device* %dev166, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.165, i32 0, i32 0))
  br label %LeafBlock27

if.end172:                                        ; preds = %if.end146
  switch i32 %r.3, label %if.then177 [
    i32 0, label %if.end180
    i32 -19, label %LeafBlock27
  ]

if.then177:                                       ; preds = %if.end172
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %LeafBlock27

if.end180:                                        ; preds = %if.end172
  br label %LeafBlock27

LeafBlock27:                                      ; preds = %if.end180, %if.then177, %if.end172, %if.then165, %do.body152, %for.end, %if.end107, %if.then105
  %retval2.1 = phi i32 [ %call102, %if.then105 ], [ %call142, %if.end180 ], [ -12, %if.end107 ], [ %call142, %for.end ], [ -19, %if.then165 ], [ -19, %do.body152 ], [ -90, %if.end172 ], [ -90, %if.then177 ]
  %cleanup.dest.slot.0 = phi i32 [ 2, %if.then105 ], [ 0, %if.end180 ], [ 10, %if.end107 ], [ 2, %for.end ], [ 2, %if.then165 ], [ 2, %do.body152 ], [ 10, %if.end172 ], [ 10, %if.then177 ]
  %SwitchLeaf28 = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf28, label %if.end182, label %NodeBlock42

if.end182:                                        ; preds = %LeafBlock27, %for.body
  %retval2.2 = phi i32 [ %retval2.0, %for.body ], [ %retval2.1, %LeafBlock27 ]
  %did_new_scheme.0 = phi i8 [ 0, %for.body ], [ 1, %LeafBlock27 ]
  %wusb = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load183 = load i16, i16* %wusb, align 4
  %bf.lshr184 = lshr i16 %bf.load183, 5
  %bf.clear185 = and i16 %bf.lshr184, 1
  %bf.cast = zext i16 %bf.clear185 to i32
  %cmp186 = icmp eq i32 %bf.cast, 0
  br i1 %cmp186, label %if.then188, label %if.end231

if.then188:                                       ; preds = %if.end182
  br label %for.cond189

for.cond189:                                      ; preds = %if.end197, %if.then188
  %retval2.3 = phi i32 [ %retval2.2, %if.then188 ], [ %call193, %if.end197 ]
  %operations.1 = phi i32 [ 0, %if.then188 ], [ %inc199, %if.end197 ]
  %cmp190 = icmp slt i32 %operations.1, 2
  br i1 %cmp190, label %for.body192, label %for.end200

for.body192:                                      ; preds = %for.cond189
  %call193 = call i32 @hub_set_address(%struct.usb_device* %udev, i32 %devnum.0)
  %cmp194 = icmp sge i32 %call193, 0
  br i1 %cmp194, label %for.end200, label %if.end197

if.end197:                                        ; preds = %for.body192
  call void @msleep(i32 200)
  %inc199 = add nsw i32 %operations.1, 1
  br label %for.cond189

for.end200:                                       ; preds = %for.body192, %for.cond189
  %retval2.4 = phi i32 [ %call193, %for.body192 ], [ %retval2.3, %for.cond189 ]
  %cmp201 = icmp slt i32 %retval2.4, 0
  br i1 %cmp201, label %if.then203, label %if.end209

if.then203:                                       ; preds = %for.end200
  %cmp204 = icmp ne i32 %retval2.4, -19
  br i1 %cmp204, label %if.then206, label %NodeBlock42

if.then206:                                       ; preds = %if.then203
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %NodeBlock42

if.end209:                                        ; preds = %for.end200
  %speed210 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %30 = load i32, i32* %speed210, align 4, !tbaa !177
  %cmp211 = icmp uge i32 %30, 5
  br i1 %cmp211, label %if.then213, label %if.end227

if.then213:                                       ; preds = %if.end209
  %devnum214 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  %31 = load i32, i32* %devnum214, align 8, !tbaa !44
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %if.end227

if.end227:                                        ; preds = %if.then213, %if.end209
  %devnum.1 = phi i32 [ %31, %if.then213 ], [ %devnum.0, %if.end209 ]
  call void @msleep(i32 10)
  %tobool228 = trunc i8 %did_new_scheme.0 to i1
  br i1 %tobool228, label %NodeBlock42, label %if.end231

if.end231:                                        ; preds = %if.end227, %if.end182
  %devnum.2 = phi i32 [ %devnum.0, %if.end182 ], [ %devnum.1, %if.end227 ]
  %call232 = call i32 @usb_get_device_descriptor(%struct.usb_device* %udev, i32 8)
  %cmp233 = icmp slt i32 %call232, 8
  br i1 %cmp233, label %if.then235, label %NodeBlock42

if.then235:                                       ; preds = %if.end231
  %cmp236 = icmp ne i32 %call232, -19
  br i1 %cmp236, label %if.then238, label %if.end240

if.then238:                                       ; preds = %if.then235
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end240

if.end240:                                        ; preds = %if.then238, %if.then235
  %cmp241 = icmp sge i32 %call232, 0
  %.call232 = select i1 %cmp241, i32 -90, i32 %call232
  br label %NodeBlock42

NodeBlock42:                                      ; preds = %if.end240, %if.end231, %if.end227, %if.then206, %if.then203, %LeafBlock27
  %retval2.6 = phi i32 [ %.call232, %if.end240 ], [ %retval2.4, %if.then206 ], [ %retval2.4, %if.then203 ], [ %retval2.4, %if.end227 ], [ 0, %if.end231 ], [ %retval2.1, %LeafBlock27 ]
  %devnum.3 = phi i32 [ %devnum.2, %if.end240 ], [ %devnum.0, %if.then206 ], [ %devnum.0, %if.then203 ], [ %devnum.1, %if.end227 ], [ %devnum.2, %if.end231 ], [ %devnum.0, %LeafBlock27 ]
  %cleanup.dest.slot.1 = phi i32 [ 0, %if.end240 ], [ 2, %if.then206 ], [ 2, %if.then203 ], [ 8, %if.end227 ], [ 8, %if.end231 ], [ %cleanup.dest.slot.0, %LeafBlock27 ]
  %Pivot43 = icmp slt i32 %cleanup.dest.slot.1, 8
  br i1 %Pivot43, label %NodeBlock34, label %NodeBlock40

NodeBlock40:                                      ; preds = %NodeBlock42
  %Pivot41 = icmp slt i32 %cleanup.dest.slot.1, 10
  br i1 %Pivot41, label %LeafBlock36, label %LeafBlock38

LeafBlock38:                                      ; preds = %NodeBlock40
  %SwitchLeaf39 = icmp eq i32 %cleanup.dest.slot.1, 10
  br i1 %SwitchLeaf39, label %for.inc250, label %cleanup388

LeafBlock36:                                      ; preds = %NodeBlock40
  %SwitchLeaf37 = icmp eq i32 %cleanup.dest.slot.1, 8
  br i1 %SwitchLeaf37, label %for.end252, label %cleanup388

NodeBlock34:                                      ; preds = %NodeBlock42
  %Pivot35 = icmp slt i32 %cleanup.dest.slot.1, 2
  br i1 %Pivot35, label %LeafBlock30, label %LeafBlock32

LeafBlock32:                                      ; preds = %NodeBlock34
  %SwitchLeaf33 = icmp eq i32 %cleanup.dest.slot.1, 2
  br i1 %SwitchLeaf33, label %fail, label %cleanup388

LeafBlock30:                                      ; preds = %NodeBlock34
  %SwitchLeaf31 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf31, label %for.inc250, label %cleanup388

for.inc250:                                       ; preds = %LeafBlock30, %LeafBlock38
  %inc251 = add nsw i32 %retries.0, 1
  call void @msleep(i32 100)
  br label %for.cond

for.end252:                                       ; preds = %LeafBlock36, %for.cond
  %retval2.7 = phi i32 [ %retval2.6, %LeafBlock36 ], [ %retval2.0, %for.cond ]
  %devnum.4 = phi i32 [ %devnum.3, %LeafBlock36 ], [ %devnum.0, %for.cond ]
  %tobool253 = icmp ne i32 %retval2.7, 0
  br i1 %tobool253, label %fail, label %if.end255

if.end255:                                        ; preds = %for.end252
  %speed256 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %32 = load i32, i32* %speed256, align 4, !tbaa !177
  %cmp257 = icmp uge i32 %32, 5
  br i1 %cmp257, label %land.lhs.true259, label %if.end267

land.lhs.true259:                                 ; preds = %if.end255
  %descriptor260 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bcdUSB = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor260, i32 0, i32 2
  %33 = load i16, i16* %bcdUSB, align 2, !tbaa !187
  %conv261 = zext i16 %33 to i32
  %cmp262 = icmp slt i32 %conv261, 768
  br i1 %cmp262, label %if.then264, label %if.end267

if.then264:                                       ; preds = %land.lhs.true259
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %call266 = call i32 @hub_port_reset(%struct.usb_hub* %hub, i32 %port1, %struct.usb_device* %udev, i32 50, i1 zeroext true)
  br label %fail

if.end267:                                        ; preds = %land.lhs.true259, %if.end255
  %descriptor268 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bMaxPacketSize0269 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor268, i32 0, i32 6
  %34 = load i8, i8* %bMaxPacketSize0269, align 1, !tbaa !186
  %conv270 = zext i8 %34 to i32
  %cmp271 = icmp eq i32 %conv270, 255
  br i1 %cmp271, label %if.end282, label %lor.lhs.false273

lor.lhs.false273:                                 ; preds = %if.end267
  %speed274 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %35 = load i32, i32* %speed274, align 4, !tbaa !177
  %cmp275 = icmp uge i32 %35, 5
  br i1 %cmp275, label %if.end282, label %if.else278

if.else278:                                       ; preds = %lor.lhs.false273
  %descriptor279 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bMaxPacketSize0280 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor279, i32 0, i32 6
  %36 = load i8, i8* %bMaxPacketSize0280, align 1, !tbaa !186
  %conv281 = zext i8 %36 to i32
  br label %if.end282

if.end282:                                        ; preds = %if.else278, %lor.lhs.false273, %if.end267
  %i.0 = phi i32 [ %conv281, %if.else278 ], [ 512, %lor.lhs.false273 ], [ 512, %if.end267 ]
  %ep0283 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 10
  %desc284 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep0283, i32 0, i32 0
  %call285 = call i32 @usb_endpoint_maxp(%struct.usb_endpoint_descriptor* %desc284)
  %cmp286 = icmp ne i32 %call285, %i.0
  br i1 %cmp286, label %if.then288, label %if.end339

if.then288:                                       ; preds = %if.end282
  %speed289 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %37 = load i32, i32* %speed289, align 4, !tbaa !177
  %cmp290 = icmp eq i32 %37, 1
  br i1 %cmp290, label %if.then304, label %lor.lhs.false292

lor.lhs.false292:                                 ; preds = %if.then288
  %38 = sub i32 %i.0, 8
  %39 = lshr i32 %38, 3
  %40 = shl i32 %38, 29
  %41 = or i32 %39, %40
  switch i32 %41, label %if.then304 [
    i32 0, label %if.end306
    i32 1, label %if.end306
    i32 3, label %if.end306
    i32 7, label %if.end306
  ]

if.then304:                                       ; preds = %lor.lhs.false292, %if.then288
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %fail

if.end306:                                        ; preds = %lor.lhs.false292, %lor.lhs.false292, %lor.lhs.false292, %lor.lhs.false292
  %speed307 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %42 = load i32, i32* %speed307, align 4, !tbaa !177
  %cmp308 = icmp eq i32 %42, 2
  br i1 %cmp308, label %do.body312, label %if.else332

do.body312:                                       ; preds = %if.end306
  %bf.load313 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_init.descriptor.180 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr314 = lshr i32 %bf.load313, 18
  %bf.clear315 = and i32 %bf.lshr314, 255
  %and316 = and i32 %bf.clear315, 1
  %tobool317 = icmp ne i32 %and316, 0
  %lnot318 = xor i1 %tobool317, true
  %lnot320 = xor i1 %lnot318, true
  %lnot.ext321 = zext i1 %lnot320 to i32
  %conv322 = sext i32 %lnot.ext321 to i64
  %expval323 = call i64 @llvm.expect.i64(i64 %conv322, i64 0)
  %tobool324 = icmp ne i64 %expval323, 0
  br i1 %tobool324, label %if.then325, label %if.end334

if.then325:                                       ; preds = %do.body312
  %dev326 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_init.descriptor.180 to %struct._ddebug*), %struct.device* %dev326, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.181, i32 0, i32 0), i32 %i.0)
  br label %if.end334

if.else332:                                       ; preds = %if.end306
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end334

if.end334:                                        ; preds = %if.else332, %if.then325, %do.body312
  %conv335 = trunc i32 %i.0 to i16
  %ep0336 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 10
  %desc337 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep0336, i32 0, i32 0
  %wMaxPacketSize338 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc337, i32 0, i32 4
  store i16 %conv335, i16* %wMaxPacketSize338, align 4, !tbaa !180
  call void @usb_ep0_reinit(%struct.usb_device* %udev)
  br label %if.end339

if.end339:                                        ; preds = %if.end334, %if.end282
  %call340 = call i32 @usb_get_device_descriptor(%struct.usb_device* %udev, i32 18)
  %cmp341 = icmp slt i32 %call340, 18
  br i1 %cmp341, label %if.then343, label %if.end353

if.then343:                                       ; preds = %if.end339
  %cmp344 = icmp ne i32 %call340, -19
  br i1 %cmp344, label %if.then346, label %if.end348

if.then346:                                       ; preds = %if.then343
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end348

if.end348:                                        ; preds = %if.then346, %if.then343
  %cmp349 = icmp sge i32 %call340, 0
  %.call340 = select i1 %cmp349, i32 -42, i32 %call340
  br label %fail

if.end353:                                        ; preds = %if.end339
  call void @usb_detect_quirks(%struct.usb_device* %udev)
  %wusb354 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load355 = load i16, i16* %wusb354, align 4
  %bf.lshr356 = lshr i16 %bf.load355, 5
  %bf.clear357 = and i16 %bf.lshr356, 1
  %bf.cast358 = zext i16 %bf.clear357 to i32
  %cmp359 = icmp eq i32 %bf.cast358, 0
  br i1 %cmp359, label %land.lhs.true361, label %if.end375

land.lhs.true361:                                 ; preds = %if.end353
  %descriptor362 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bcdUSB363 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor362, i32 0, i32 2
  %43 = load i16, i16* %bcdUSB363, align 2, !tbaa !187
  %conv364 = zext i16 %43 to i32
  %cmp365 = icmp sge i32 %conv364, 513
  br i1 %cmp365, label %if.then367, label %if.end375

if.then367:                                       ; preds = %land.lhs.true361
  %call368 = call i32 @usb_get_bos_descriptor(%struct.usb_device* %udev)
  %tobool369 = icmp ne i32 %call368, 0
  br i1 %tobool369, label %if.end375, label %if.then370

if.then370:                                       ; preds = %if.then367
  %call371 = call i32 @usb_device_supports_lpm(%struct.usb_device* %udev)
  %lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %44 = trunc i32 %call371 to i16
  %bf.load372 = load i16, i16* %lpm_capable, align 4
  %bf.value = and i16 %44, 1
  %bf.shl = shl i16 %bf.value, 6
  %bf.clear373 = and i16 %bf.load372, -65
  %bf.set = or i16 %bf.clear373, %bf.shl
  store i16 %bf.set, i16* %lpm_capable, align 4
  call void @usb_set_lpm_parameters(%struct.usb_device* %udev)
  br label %if.end375

if.end375:                                        ; preds = %if.then370, %if.then367, %land.lhs.true361, %if.end353
  %driver376 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %45 = load %struct.hc_driver*, %struct.hc_driver** %driver376, align 8, !tbaa !57
  %update_device = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %45, i32 0, i32 38
  %46 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %update_device, align 8, !tbaa !188
  %tobool377 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*)* %46, null
  br i1 %tobool377, label %if.then378, label %if.end382

if.then378:                                       ; preds = %if.end375
  %driver379 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %47 = load %struct.hc_driver*, %struct.hc_driver** %driver379, align 8, !tbaa !57
  %update_device380 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %47, i32 0, i32 38
  %48 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %update_device380, align 8, !tbaa !188
  %call381 = call i32 %48(%struct.usb_hcd* %call, %struct.usb_device* %udev)
  br label %if.end382

if.end382:                                        ; preds = %if.then378, %if.end375
  call void @hub_set_initial_usb2_lpm_policy(%struct.usb_device* %udev)
  br label %fail

fail:                                             ; preds = %if.end382, %if.end348, %if.then304, %if.then264, %for.end252, %LeafBlock32, %if.then90, %LeafBlock, %LeafBlock1, %if.then39, %do.body32, %if.end9
  %retval2.9 = phi i32 [ %retval2.6, %LeafBlock32 ], [ -22, %if.then264 ], [ -90, %if.then304 ], [ %.call340, %if.end348 ], [ 0, %if.end382 ], [ -22, %if.then90 ], [ %call14, %if.end9 ], [ -19, %if.then39 ], [ -19, %do.body32 ], [ -19, %LeafBlock ], [ -19, %LeafBlock1 ], [ %retval2.7, %for.end252 ]
  %devnum.5 = phi i32 [ %devnum.3, %LeafBlock32 ], [ %devnum.4, %if.then264 ], [ %devnum.4, %if.then304 ], [ %devnum.4, %if.end348 ], [ %devnum.4, %if.end382 ], [ %3, %if.then90 ], [ %3, %if.end9 ], [ %3, %if.then39 ], [ %3, %do.body32 ], [ %3, %LeafBlock ], [ %3, %LeafBlock1 ], [ %devnum.4, %for.end252 ]
  %tobool383 = icmp ne i32 %retval2.9, 0
  br i1 %tobool383, label %if.then384, label %if.end386

if.then384:                                       ; preds = %fail
  call void @hub_port_disable(%struct.usb_hub* %hub, i32 %port1, i32 0)
  call void @update_devnum(%struct.usb_device* %udev, i32 %devnum.5)
  br label %if.end386

if.end386:                                        ; preds = %if.then384, %fail
  %address0_mutex387 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 20
  %49 = load %struct.mutex*, %struct.mutex** %address0_mutex387, align 8, !tbaa !179
  call void @mutex_unlock(%struct.mutex* %49)
  br label %cleanup388

cleanup388:                                       ; preds = %if.end386, %LeafBlock30, %LeafBlock32, %LeafBlock36, %LeafBlock38
  %retval.0 = phi i32 [ %retval2.9, %if.end386 ], [ undef, %LeafBlock38 ], [ undef, %LeafBlock30 ], [ undef, %LeafBlock36 ], [ undef, %LeafBlock32 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @descriptors_changed(%struct.usb_device* %udev, %struct.usb_device_descriptor* %old_device_descriptor, %struct.usb_host_bos* %old_bos) #0 {
entry:
  %__UNIQUE_ID_max1_24 = alloca i32, align 4
  %__UNIQUE_ID_max2_25 = alloca i32, align 4
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %0 = bitcast %struct.usb_device_descriptor* %descriptor to i8*
  %1 = bitcast %struct.usb_device_descriptor* %old_device_descriptor to i8*
  %call = call i32 @memcmp(i8* %0, i8* %1, i64 18)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %magicptr = ptrtoint %struct.usb_host_bos* %old_bos to i64
  %cond1 = icmp eq i64 %magicptr, 0
  br i1 %cond1, label %land.lhs.true3, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %bos = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %2 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos, align 8, !tbaa !166
  %tobool1 = icmp ne %struct.usb_host_bos* %2, null
  br i1 %tobool1, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %land.lhs.true
  %tobool2 = icmp ne %struct.usb_host_bos* %old_bos, null
  br i1 %tobool2, label %if.end7, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %lor.lhs.false, %if.end
  %bos4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %3 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos4, align 8, !tbaa !166
  %tobool5 = icmp ne %struct.usb_host_bos* %3, null
  br i1 %tobool5, label %cleanup, label %if.end7

if.end7:                                          ; preds = %land.lhs.true3, %lor.lhs.false
  %bos8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %4 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos8, align 8, !tbaa !166
  %tobool9 = icmp ne %struct.usb_host_bos* %4, null
  br i1 %tobool9, label %if.then10, label %if.end27

if.then10:                                        ; preds = %if.end7
  %bos11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %5 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos11, align 8, !tbaa !166
  %desc = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %5, i32 0, i32 0
  %6 = load %struct.usb_bos_descriptor*, %struct.usb_bos_descriptor** %desc, align 8, !tbaa !189
  %wTotalLength = getelementptr inbounds %struct.usb_bos_descriptor, %struct.usb_bos_descriptor* %6, i32 0, i32 2
  %7 = load i16, i16* %wTotalLength, align 1, !tbaa !191
  %conv = zext i16 %7 to i32
  %desc12 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %old_bos, i32 0, i32 0
  %8 = load %struct.usb_bos_descriptor*, %struct.usb_bos_descriptor** %desc12, align 8, !tbaa !189
  %wTotalLength13 = getelementptr inbounds %struct.usb_bos_descriptor, %struct.usb_bos_descriptor* %8, i32 0, i32 2
  %9 = load i16, i16* %wTotalLength13, align 1, !tbaa !191
  %conv14 = zext i16 %9 to i32
  %cmp15 = icmp ne i32 %conv, %conv14
  br i1 %cmp15, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.then10
  %bos19 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %10 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos19, align 8, !tbaa !166
  %desc20 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %10, i32 0, i32 0
  %11 = load %struct.usb_bos_descriptor*, %struct.usb_bos_descriptor** %desc20, align 8, !tbaa !189
  %12 = bitcast %struct.usb_bos_descriptor* %11 to i8*
  %desc21 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %old_bos, i32 0, i32 0
  %13 = load %struct.usb_bos_descriptor*, %struct.usb_bos_descriptor** %desc21, align 8, !tbaa !189
  %14 = bitcast %struct.usb_bos_descriptor* %13 to i8*
  %conv22 = zext i32 %conv to i64
  %call23 = call i32 @memcmp(i8* %12, i8* %14, i64 %conv22)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %cleanup, label %if.end27

if.end27:                                         ; preds = %if.end18, %if.end7
  %serial = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 26
  %15 = load i8*, i8** %serial, align 8, !tbaa !47
  %tobool28 = icmp ne i8* %15, null
  br i1 %tobool28, label %if.then29, label %if.end33

if.then29:                                        ; preds = %if.end27
  %serial30 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 26
  %16 = load i8*, i8** %serial30, align 8, !tbaa !47
  %call31 = call i64 @strlen(i8* %16)
  %add = add i64 %call31, 1
  %conv32 = trunc i64 %add to i32
  br label %if.end33

if.end33:                                         ; preds = %if.then29, %if.end27
  %serial_len.0 = phi i32 [ %conv32, %if.then29 ], [ 0, %if.end27 ]
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end33
  %len.0 = phi i32 [ %serial_len.0, %if.end33 ], [ %cond, %for.body ]
  %index.0 = phi i32 [ 0, %if.end33 ], [ %inc, %for.body ]
  %descriptor34 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor34, i32 0, i32 13
  %17 = load i8, i8* %bNumConfigurations, align 1, !tbaa !193
  %conv35 = zext i8 %17 to i32
  %cmp36 = icmp ult i32 %index.0, %conv35
  br i1 %cmp36, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 14
  %18 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !194
  %idxprom = zext i32 %index.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %18, i64 %idxprom
  %desc38 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx, i32 0, i32 0
  %wTotalLength39 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc38, i32 0, i32 2
  %19 = load i16, i16* %wTotalLength39, align 2, !tbaa !195
  %conv40 = zext i16 %19 to i32
  store i32 %len.0, i32* %__UNIQUE_ID_max1_24, align 4, !tbaa !73
  store i32 %conv40, i32* %__UNIQUE_ID_max2_25, align 4, !tbaa !73
  %20 = load i32, i32* %__UNIQUE_ID_max1_24, align 4, !tbaa !73
  %21 = load i32, i32* %__UNIQUE_ID_max2_25, align 4, !tbaa !73
  %cmp43 = icmp ugt i32 %20, %21
  %22 = load i32, i32* %__UNIQUE_ID_max1_24, align 4
  %23 = load i32, i32* %__UNIQUE_ID_max2_25, align 4
  %cond = select i1 %cmp43, i32 %22, i32 %23
  %inc = add i32 %index.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %conv45 = zext i32 %len.0 to i64
  %call.i = call noalias i8* @__kmalloc(i64 %conv45, i32 20971520) #8
  %tobool47 = icmp ne i8* %call.i, null
  br i1 %tobool47, label %if.end49, label %cleanup

if.end49:                                         ; preds = %for.end
  br label %for.cond50

for.cond50:                                       ; preds = %for.inc108, %if.end49
  %index.1 = phi i32 [ 0, %if.end49 ], [ %inc109, %for.inc108 ]
  %descriptor51 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bNumConfigurations52 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor51, i32 0, i32 13
  %24 = load i8, i8* %bNumConfigurations52, align 1, !tbaa !193
  %conv53 = zext i8 %24 to i32
  %cmp54 = icmp ult i32 %index.1, %conv53
  br i1 %cmp54, label %for.body56, label %for.end110

for.body56:                                       ; preds = %for.cond50
  %config57 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 14
  %25 = load %struct.usb_host_config*, %struct.usb_host_config** %config57, align 8, !tbaa !194
  %idxprom58 = zext i32 %index.1 to i64
  %arrayidx59 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %25, i64 %idxprom58
  %desc60 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx59, i32 0, i32 0
  %wTotalLength61 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc60, i32 0, i32 2
  %26 = load i16, i16* %wTotalLength61, align 2, !tbaa !195
  %conv62 = zext i16 %26 to i32
  %conv63 = trunc i32 %index.1 to i8
  %call64 = call i32 @usb_get_descriptor(%struct.usb_device* %udev, i8 zeroext 2, i8 zeroext %conv63, i8* %call.i, i32 %conv62)
  %cmp65 = icmp ne i32 %call64, %conv62
  br i1 %cmp65, label %do.body68, label %if.end77

do.body68:                                        ; preds = %for.body56
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @descriptors_changed.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool69 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool69, true
  %lnot70 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot70 to i32
  %conv71 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv71, i64 0)
  %tobool72 = icmp ne i64 %expval, 0
  br i1 %tobool72, label %if.then73, label %for.end110

if.then73:                                        ; preds = %do.body68
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @descriptors_changed.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.267, i32 0, i32 0), i32 %index.1, i32 %call64)
  br label %for.end110

if.end77:                                         ; preds = %for.body56
  %rawdescriptors = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 18
  %27 = load i8**, i8*** %rawdescriptors, align 8, !tbaa !196
  %idxprom78 = zext i32 %index.1 to i64
  %arrayidx79 = getelementptr inbounds i8*, i8** %27, i64 %idxprom78
  %28 = load i8*, i8** %arrayidx79, align 8, !tbaa !52
  %conv80 = zext i32 %conv62 to i64
  %call81 = call i32 @memcmp(i8* %call.i, i8* %28, i64 %conv80)
  %cmp82 = icmp ne i32 %call81, 0
  br i1 %cmp82, label %do.body86, label %for.inc108

do.body86:                                        ; preds = %if.end77
  %bf.load87 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @descriptors_changed.descriptor.268 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr88 = lshr i32 %bf.load87, 18
  %bf.clear89 = and i32 %bf.lshr88, 255
  %and90 = and i32 %bf.clear89, 1
  %tobool91 = icmp ne i32 %and90, 0
  %lnot92 = xor i1 %tobool91, true
  %lnot94 = xor i1 %lnot92, true
  %lnot.ext95 = zext i1 %lnot94 to i32
  %conv96 = sext i32 %lnot.ext95 to i64
  %expval97 = call i64 @llvm.expect.i64(i64 %conv96, i64 0)
  %tobool98 = icmp ne i64 %expval97, 0
  br i1 %tobool98, label %if.then99, label %for.end110

if.then99:                                        ; preds = %do.body86
  %dev100 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %29 = bitcast i8* %call.i to %struct.usb_config_descriptor*
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %29, i32 0, i32 4
  %30 = load i8, i8* %bConfigurationValue, align 1, !tbaa !197
  %conv101 = zext i8 %30 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @descriptors_changed.descriptor.268 to %struct._ddebug*), %struct.device* %dev100, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.269, i32 0, i32 0), i32 %index.1, i32 %conv101)
  br label %for.end110

for.inc108:                                       ; preds = %if.end77
  %inc109 = add i32 %index.1, 1
  br label %for.cond50

for.end110:                                       ; preds = %if.then99, %do.body86, %if.then73, %do.body68, %for.cond50
  %changed.0 = phi i32 [ 1, %if.then73 ], [ 1, %do.body68 ], [ 1, %if.then99 ], [ 1, %do.body86 ], [ 0, %for.cond50 ]
  %tobool111 = icmp eq i32 %changed.0, 0
  %tobool113 = icmp ne i32 %serial_len.0, 0
  %or.cond = and i1 %tobool111, %tobool113
  br i1 %or.cond, label %if.then114, label %if.end173

if.then114:                                       ; preds = %for.end110
  %descriptor115 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %iSerialNumber = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor115, i32 0, i32 12
  %31 = load i8, i8* %iSerialNumber, align 8, !tbaa !198
  %conv116 = zext i8 %31 to i32
  %conv117 = zext i32 %serial_len.0 to i64
  %call118 = call i32 @usb_string(%struct.usb_device* %udev, i32 %conv116, i8* %call.i, i64 %conv117)
  %add119 = add nsw i32 %call118, 1
  %cmp120 = icmp ne i32 %add119, %serial_len.0
  br i1 %cmp120, label %do.body124, label %if.else

do.body124:                                       ; preds = %if.then114
  %bf.load125 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @descriptors_changed.descriptor.270 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr126 = lshr i32 %bf.load125, 18
  %bf.clear127 = and i32 %bf.lshr126, 255
  %and128 = and i32 %bf.clear127, 1
  %tobool129 = icmp ne i32 %and128, 0
  %lnot130 = xor i1 %tobool129, true
  %lnot132 = xor i1 %lnot130, true
  %lnot.ext133 = zext i1 %lnot132 to i32
  %conv134 = sext i32 %lnot.ext133 to i64
  %expval135 = call i64 @llvm.expect.i64(i64 %conv134, i64 0)
  %tobool136 = icmp ne i64 %expval135, 0
  br i1 %tobool136, label %if.then137, label %if.end173

if.then137:                                       ; preds = %do.body124
  %dev138 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @descriptors_changed.descriptor.270 to %struct._ddebug*), %struct.device* %dev138, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.271, i32 0, i32 0), i32 %call118)
  br label %if.end173

if.else:                                          ; preds = %if.then114
  %serial144 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 26
  %32 = load i8*, i8** %serial144, align 8, !tbaa !47
  %conv145 = sext i32 %call118 to i64
  %call146 = call i32 @memcmp(i8* %call.i, i8* %32, i64 %conv145)
  %cmp147 = icmp ne i32 %call146, 0
  br i1 %cmp147, label %do.body151, label %if.end173

do.body151:                                       ; preds = %if.else
  %bf.load152 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @descriptors_changed.descriptor.272 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr153 = lshr i32 %bf.load152, 18
  %bf.clear154 = and i32 %bf.lshr153, 255
  %and155 = and i32 %bf.clear154, 1
  %tobool156 = icmp ne i32 %and155, 0
  %lnot157 = xor i1 %tobool156, true
  %lnot159 = xor i1 %lnot157, true
  %lnot.ext160 = zext i1 %lnot159 to i32
  %conv161 = sext i32 %lnot.ext160 to i64
  %expval162 = call i64 @llvm.expect.i64(i64 %conv161, i64 0)
  %tobool163 = icmp ne i64 %expval162, 0
  br i1 %tobool163, label %if.then164, label %if.end173

if.then164:                                       ; preds = %do.body151
  %dev165 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @descriptors_changed.descriptor.272 to %struct._ddebug*), %struct.device* %dev165, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.273, i32 0, i32 0))
  br label %if.end173

if.end173:                                        ; preds = %if.then164, %do.body151, %if.else, %if.then137, %do.body124, %for.end110
  %changed.3 = phi i32 [ %changed.0, %for.end110 ], [ 1, %if.then137 ], [ 1, %do.body124 ], [ %changed.0, %if.else ], [ 1, %if.then164 ], [ 1, %do.body151 ]
  call void @kfree(i8* %call.i)
  br label %cleanup

cleanup:                                          ; preds = %if.end173, %for.end, %if.end18, %if.then10, %land.lhs.true3, %land.lhs.true, %entry
  %retval.0 = phi i32 [ %changed.3, %if.end173 ], [ 1, %entry ], [ 1, %land.lhs.true3 ], [ 1, %land.lhs.true ], [ 1, %if.then10 ], [ 1, %if.end18 ], [ 1, %for.end ]
  ret i32 %retval.0
}

declare void @_dev_info(%struct.device*, i8*, ...) #2

declare void @mutex_lock_nested(%struct.mutex*, i32) #2

declare void @dev_warn(%struct.device*, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__create_pipe(%struct.usb_device* %dev, i32 %endpoint) #1 {
entry:
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 0
  %0 = load i32, i32* %devnum, align 8, !tbaa !44
  %shl = shl i32 %0, 8
  %shl1 = shl i32 %endpoint, 15
  %or = or i32 %shl, %shl1
  ret i32 %or
}

; Function Attrs: nounwind uwtable
define void @usb_set_device_state(%struct.usb_device* %udev, i32 %new_state) #0 {
entry:
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @device_state_lock, i32 0, i32 0, i32 0))
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !54
  %cmp5 = icmp eq i32 %0, 0
  br i1 %cmp5, label %if.end48, label %if.else

if.else:                                          ; preds = %entry
  %cmp7 = icmp ne i32 %new_state, 0
  br i1 %cmp7, label %if.then9, label %if.else46

if.then9:                                         ; preds = %if.else
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %1 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool = icmp ne %struct.usb_device* %1, null
  br i1 %tobool, label %if.then10, label %if.end27

if.then10:                                        ; preds = %if.then9
  %state11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %2 = load i32, i32* %state11, align 8, !tbaa !54
  %cmp12 = icmp eq i32 %2, 8
  %cmp14 = icmp eq i32 %new_state, 8
  %or.cond = or i1 %cmp12, %cmp14
  br i1 %or.cond, label %if.end27, label %if.else17

if.else17:                                        ; preds = %if.then10
  %cmp18 = icmp eq i32 %new_state, 7
  br i1 %cmp18, label %if.then20, label %if.end27

if.then20:                                        ; preds = %if.else17
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %3 = load i32, i32* %quirks, align 4, !tbaa !199
  %conv21 = zext i32 %3 to i64
  %and = and i64 %conv21, 512
  %tobool22 = icmp ne i64 %and, 0
  br i1 %tobool22, label %if.end27, label %cond.false

cond.false:                                       ; preds = %if.then20
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %4 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %4, i32 0, i32 0
  %bmAttributes = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 6
  %5 = load i8, i8* %bmAttributes, align 1, !tbaa !200
  %conv23 = zext i8 %5 to i32
  %and24 = and i32 %conv23, 32
  br label %if.end27

if.end27:                                         ; preds = %cond.false, %if.then20, %if.else17, %if.then10, %if.then9
  %wakeup.2 = phi i32 [ -1, %if.then9 ], [ -1, %if.then10 ], [ %and24, %cond.false ], [ 0, %if.then20 ], [ 0, %if.else17 ]
  %state28 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %6 = load i32, i32* %state28, align 8, !tbaa !54
  %cmp29 = icmp eq i32 %6, 8
  %cmp31 = icmp ne i32 %new_state, 8
  %or.cond1 = and i1 %cmp29, %cmp31
  br i1 %or.cond1, label %if.then33, label %if.else34

if.then33:                                        ; preds = %if.end27
  %7 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  %active_duration = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 31
  %8 = load i64, i64* %active_duration, align 8, !tbaa !83
  %sub = sub i64 %8, %7
  store i64 %sub, i64* %active_duration, align 8, !tbaa !83
  br label %if.end44

if.else34:                                        ; preds = %if.end27
  %cmp35 = icmp eq i32 %new_state, 8
  br i1 %cmp35, label %land.lhs.true37, label %if.end44

land.lhs.true37:                                  ; preds = %if.else34
  %state38 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %9 = load i32, i32* %state38, align 8, !tbaa !54
  %cmp39 = icmp ne i32 %9, 8
  br i1 %cmp39, label %if.then41, label %if.end44

if.then41:                                        ; preds = %land.lhs.true37
  %10 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  %active_duration42 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 31
  %11 = load i64, i64* %active_duration42, align 8, !tbaa !83
  %add = add i64 %11, %10
  store i64 %add, i64* %active_duration42, align 8, !tbaa !83
  br label %if.end44

if.end44:                                         ; preds = %if.then41, %land.lhs.true37, %if.else34, %if.then33
  %state45 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  store i32 %new_state, i32* %state45, align 8, !tbaa !54
  br label %if.end48

if.else46:                                        ; preds = %if.else
  call void @recursively_mark_NOTATTACHED(%struct.usb_device* %udev)
  br label %if.end48

if.end48:                                         ; preds = %if.else46, %if.end44, %entry
  %wakeup.4 = phi i32 [ -1, %entry ], [ %wakeup.2, %if.end44 ], [ -1, %if.else46 ]
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @device_state_lock, i32 0, i32 0, i32 0), i64 %call2) #8
  %cmp49 = icmp sge i32 %wakeup.4, 0
  br i1 %cmp49, label %if.then51, label %if.end53

if.then51:                                        ; preds = %if.end48
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %tobool52 = icmp ne i32 %wakeup.4, 0
  call void @device_set_wakeup_capable(%struct.device* %dev, i1 zeroext %tobool52)
  br label %if.end53

if.end53:                                         ; preds = %if.then51, %if.end48
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_unlocked_enable_lpm(%struct.usb_device* %udev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %0)
  %tobool = icmp ne %struct.usb_hcd* %call, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %1 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !167
  call void @mutex_lock_nested(%struct.mutex* %1, i32 0)
  call void @usb_enable_lpm(%struct.usb_device* %udev)
  %bandwidth_mutex1 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %2 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex1, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %2)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_enable_ltm(%struct.usb_device* %udev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %0)
  %self = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 11
  %1 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !175
  %call1 = call zeroext i1 @usb_device_supports_ltm(%struct.usb_device* %1)
  br i1 %call1, label %lor.lhs.false, label %cleanup.cont

lor.lhs.false:                                    ; preds = %entry
  %call2 = call zeroext i1 @usb_device_supports_ltm(%struct.usb_device* %udev)
  br i1 %call2, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %lor.lhs.false
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %if.end4, label %cleanup.cont

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or = or i32 -2147483648, %call5
  %call6 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext 3, i8 zeroext 0, i16 zeroext 50, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end4, %if.end, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_port_logical_disconnect(%struct.usb_hub* %hub, i32 %port1) #0 {
entry:
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_logical_disconnect.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end4

if.then:                                          ; preds = %entry
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %0 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %0, i64 %idxprom
  %1 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %dev = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_logical_disconnect.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.48, i32 0, i32 0))
  br label %do.end4

do.end4:                                          ; preds = %if.then, %entry
  call void @hub_port_disable(%struct.usb_hub* %hub, i32 %port1, i32 1)
  %conv5 = sext i32 %port1 to i64
  %change_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 10
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i64 %conv5, i64* %arraydecay) #8, !srcloc !201
  call void @kick_hub_wq(%struct.usb_hub* %hub)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_port_disable(%struct.usb_hub* %hub, i32 %port1, i32 %set_state) #0 {
entry:
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %0 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %0, i64 %idxprom
  %1 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !176
  %error = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 7
  %3 = load i32, i32* %error, align 8, !tbaa !202
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end7, label %if.then

if.then:                                          ; preds = %entry
  %hdev2 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %hdev2, align 8, !tbaa !176
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %4)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  call void @hub_usb3_port_prepare_disable(%struct.usb_hub* %hub, %struct.usb_port* %1)
  %portnum = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 8
  %5 = load i8, i8* %portnum, align 8, !tbaa !203
  %conv = zext i8 %5 to i32
  %call5 = call i32 @hub_set_port_link_state(%struct.usb_hub* %hub, i32 %conv, i32 96)
  br label %if.end7

if.else:                                          ; preds = %if.then
  %call6 = call i32 @usb_clear_port_feature(%struct.usb_device* %2, i32 %port1, i32 1)
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then4, %entry
  %ret.1 = phi i32 [ 0, %entry ], [ %call5, %if.then4 ], [ %call6, %if.else ]
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 0
  %6 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !115
  %tobool8 = icmp ne %struct.usb_device* %6, null
  %tobool9 = icmp ne i32 %set_state, 0
  %or.cond = and i1 %tobool8, %tobool9
  br i1 %or.cond, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end7
  %child11 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 0
  %7 = load %struct.usb_device*, %struct.usb_device** %child11, align 8, !tbaa !115
  call void @usb_set_device_state(%struct.usb_device* %7, i32 0)
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end7
  switch i32 %ret.1, label %if.then16 [
    i32 0, label %if.end17
    i32 -19, label %if.end17
  ]

if.then16:                                        ; preds = %if.end12
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.end12, %if.end12
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @kick_hub_wq(%struct.usb_hub* %hub) #0 {
entry:
  %disconnected = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  %bf.load = load i8, i8* %disconnected, align 8
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %cleanup.cont, label %cond.true

cond.true:                                        ; preds = %entry
  %events = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 24
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %events, i32 0, i32 0
  %0 = bitcast %union.anon.3* %data to i64*
  %1 = load volatile i64, i64* %0, align 8, !tbaa !53
  %and1.i = and i64 1, %1
  %cmp.i = icmp ne i64 %and1.i, 0
  br i1 %cmp.i, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %cond.true
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %2 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !204
  %3 = bitcast %struct.device* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -48
  %4 = bitcast i8* %add.ptr to %struct.usb_interface*
  call void @usb_autopm_get_interface_no_resume(%struct.usb_interface* %4)
  %kref = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 2
  call void @kref_get(%struct.kref* %kref)
  %5 = load %struct.workqueue_struct*, %struct.workqueue_struct** @hub_wq, align 8, !tbaa !52
  %events4 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 24
  %call5 = call zeroext i1 @queue_work(%struct.workqueue_struct* %5, %struct.work_struct* %events4)
  br i1 %call5, label %cleanup.cont, label %if.end7

if.end7:                                          ; preds = %if.end
  call void @usb_autopm_put_interface_async(%struct.usb_interface* %4)
  %kref8 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 2
  call void @kref_put(%struct.kref* %kref8, void (%struct.kref*)* @hub_release)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end7, %if.end, %cond.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_get(%struct.kref* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  call void @refcount_inc(%struct.qspinlock* %refcount)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_release(%struct.kref* %kref) #0 {
entry:
  %0 = bitcast %struct.kref* %kref to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.usb_hub*
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  call void @usb_put_dev(%struct.usb_device* %2)
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 0
  %3 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !204
  %4 = bitcast %struct.device* %3 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %4, i64 -48
  %5 = bitcast i8* %add.ptr3 to %struct.usb_interface*
  call void @usb_put_intf(%struct.usb_interface* %5)
  %6 = bitcast %struct.usb_hub* %1 to i8*
  call void @kfree(i8* %6)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put(%struct.kref* %kref, void (%struct.kref*)* %release) #1 {
entry:
  %cmp = icmp eq void (%struct.kref*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.11.527, i32 0, i32 0), i32 69)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  %call = call zeroext i1 @refcount_dec_and_test(%struct.qspinlock* %refcount)
  br i1 %call, label %if.then14, label %return

if.then14:                                        ; preds = %if.end
  call void %release(%struct.kref* %kref)
  br label %return

return:                                           ; preds = %if.then14, %if.end
  ret void
}

declare void @warn_slowpath_null(i8*, i32) #2

declare zeroext i1 @refcount_dec_and_test(%struct.qspinlock*) #2

declare void @refcount_inc(%struct.qspinlock*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hub_is_superspeed(%struct.usb_device* %hdev) #1 {
entry:
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 12
  %bDeviceProtocol = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 5
  %0 = load i8, i8* %bDeviceProtocol, align 2, !tbaa !205
  %conv = zext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 3
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define internal void @hub_usb3_port_prepare_disable(%struct.usb_hub* %hub, %struct.usb_port* %port_dev) #0 {
entry:
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %port_dev, i32 0, i32 0
  %0 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !115
  %tobool = icmp ne %struct.usb_device* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %entry
  %port_is_suspended = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 33
  %bf.load = load i8, i8* %port_is_suspended, align 8
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool1 = icmp ne i32 %bf.cast, 0
  br i1 %tobool1, label %land.lhs.true2, label %if.end16

land.lhs.true2:                                   ; preds = %land.lhs.true
  %do_remote_wakeup = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 33
  %bf.load3 = load i8, i8* %do_remote_wakeup, align 8
  %bf.clear4 = and i8 %bf.load3, 1
  %bf.cast5 = zext i8 %bf.clear4 to i32
  %tobool6 = icmp ne i32 %bf.cast5, 0
  br i1 %tobool6, label %if.then, label %if.end16

if.then:                                          ; preds = %land.lhs.true2
  %portnum = getelementptr inbounds %struct.usb_port, %struct.usb_port* %port_dev, i32 0, i32 8
  %1 = load i8, i8* %portnum, align 8, !tbaa !203
  %conv = zext i8 %1 to i32
  %call = call i32 @hub_set_port_link_state(%struct.usb_hub* %hub, i32 %conv, i32 0)
  %tobool7 = icmp ne i32 %call, 0
  br i1 %tobool7, label %if.end, label %if.then8

if.then8:                                         ; preds = %if.then
  call void @msleep(i32 40)
  %call9 = call i32 @usb_disable_remote_wakeup(%struct.usb_device* %0)
  br label %if.end

if.end:                                           ; preds = %if.then8, %if.then
  %ret.0 = phi i32 [ %call, %if.then ], [ %call9, %if.then8 ]
  %tobool10 = icmp ne i32 %ret.0, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end
  %do_remote_wakeup13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 33
  %bf.load14 = load i8, i8* %do_remote_wakeup13, align 8
  %bf.clear15 = and i8 %bf.load14, -2
  store i8 %bf.clear15, i8* %do_remote_wakeup13, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.end12, %land.lhs.true2, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_set_port_link_state(%struct.usb_hub* %hub, i32 %port1, i32 %link_status) #0 {
entry:
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %shl = shl i32 %link_status, 3
  %or = or i32 %port1, %shl
  %call = call i32 @set_port_feature(%struct.usb_device* %0, i32 %or, i32 5)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @usb_clear_port_feature(%struct.usb_device* %hdev, i32 %port1, i32 %feature) #0 {
entry:
  %call = call i32 @__create_pipe(%struct.usb_device* %hdev, i32 0)
  %or = or i32 -2147483648, %call
  %conv = trunc i32 %feature to i16
  %conv1 = trunc i32 %port1 to i16
  %call2 = call i32 @usb_control_msg(%struct.usb_device* %hdev, i32 %or, i8 zeroext 1, i8 zeroext 35, i16 zeroext %conv, i16 zeroext %conv1, i8* null, i16 zeroext 0, i32 1000)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @set_port_feature(%struct.usb_device* %hdev, i32 %port1, i32 %feature) #0 {
entry:
  %call = call i32 @__create_pipe(%struct.usb_device* %hdev, i32 0)
  %or = or i32 -2147483648, %call
  %conv = trunc i32 %feature to i16
  %conv1 = trunc i32 %port1 to i16
  %call2 = call i32 @usb_control_msg(%struct.usb_device* %hdev, i32 %or, i8 zeroext 3, i8 zeroext 35, i16 zeroext %conv, i16 zeroext %conv1, i8* null, i16 zeroext 0, i32 1000)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_disable_remote_wakeup(%struct.usb_device* %udev) #0 {
entry:
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp ult i32 %0, 5
  %call = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or = or i32 -2147483648, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext 1, i8 zeroext 0, i16 zeroext 1, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  br label %return

if.else:                                          ; preds = %entry
  %call4 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext 3, i8 zeroext 1, i16 zeroext 0, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  br label %return

return:                                           ; preds = %if.else, %if.then
  %retval.0 = phi i32 [ %call1, %if.then ], [ %call4, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @usb_device_supports_ltm(%struct.usb_device* %udev) #1 {
entry:
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp ult i32 %0, 5
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %bos = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %1 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos, align 8, !tbaa !166
  %tobool = icmp ne %struct.usb_host_bos* %1, null
  br i1 %tobool, label %lor.lhs.false1, label %return

lor.lhs.false1:                                   ; preds = %lor.lhs.false
  %bos2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %2 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos2, align 8, !tbaa !166
  %ss_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %2, i32 0, i32 2
  %3 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap, align 8, !tbaa !206
  %tobool3 = icmp ne %struct.usb_ss_cap_descriptor* %3, null
  br i1 %tobool3, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false1
  %bos4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %4 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos4, align 8, !tbaa !166
  %ss_cap5 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %4, i32 0, i32 2
  %5 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap5, align 8, !tbaa !206
  %bmAttributes = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %5, i32 0, i32 3
  %6 = load i8, i8* %bmAttributes, align 1, !tbaa !207
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 2
  %tobool6 = icmp ne i32 %and, 0
  br label %return

return:                                           ; preds = %if.end, %lor.lhs.false1, %lor.lhs.false, %entry
  %retval.0 = phi i1 [ %tobool6, %if.end ], [ false, %lor.lhs.false1 ], [ false, %lor.lhs.false ], [ false, %entry ]
  ret i1 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_enable_lpm(%struct.usb_device* %udev) #0 {
entry:
  %tobool = icmp ne %struct.usb_device* %udev, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup.cont

lor.lhs.false:                                    ; preds = %entry
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool1 = icmp ne %struct.usb_device* %0, null
  br i1 %tobool1, label %lor.lhs.false2, label %cleanup.cont

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %1 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp ult i32 %1, 5
  br i1 %cmp, label %cleanup.cont, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false2
  %lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %lpm_capable, align 4
  %bf.lshr = lshr i16 %bf.load, 6
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool4 = icmp ne i32 %bf.cast, 0
  br i1 %tobool4, label %lor.lhs.false5, label %cleanup.cont

lor.lhs.false5:                                   ; preds = %lor.lhs.false3
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %2 = load i32, i32* %state, align 8, !tbaa !54
  %cmp6 = icmp ult i32 %2, 5
  br i1 %cmp6, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %lor.lhs.false5
  %lpm_disable_count = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 40
  %3 = load i32, i32* %lpm_disable_count, align 8, !tbaa !71
  %dec = add i32 %3, -1
  store i32 %dec, i32* %lpm_disable_count, align 8, !tbaa !71
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %4 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %4)
  %tobool7 = icmp ne %struct.usb_hcd* %call, null
  br i1 %tobool7, label %lor.lhs.false8, label %cleanup.cont

lor.lhs.false8:                                   ; preds = %if.end
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %5 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %enable_usb3_lpm_timeout = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %5, i32 0, i32 40
  %6 = load i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)** %enable_usb3_lpm_timeout, align 8, !tbaa !209
  %tobool9 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*, i32)* %6, null
  br i1 %tobool9, label %lor.lhs.false10, label %cleanup.cont

lor.lhs.false10:                                  ; preds = %lor.lhs.false8
  %driver11 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %7 = load %struct.hc_driver*, %struct.hc_driver** %driver11, align 8, !tbaa !57
  %disable_usb3_lpm_timeout = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %7, i32 0, i32 41
  %8 = load i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)** %disable_usb3_lpm_timeout, align 8, !tbaa !210
  %tobool12 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*, i32)* %8, null
  br i1 %tobool12, label %if.end14, label %cleanup.cont

if.end14:                                         ; preds = %lor.lhs.false10
  %lpm_disable_count15 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 40
  %9 = load i32, i32* %lpm_disable_count15, align 8, !tbaa !71
  %cmp16 = icmp ugt i32 %9, 0
  br i1 %cmp16, label %cleanup.cont, label %if.end18

if.end18:                                         ; preds = %if.end14
  %parent19 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %10 = load %struct.usb_device*, %struct.usb_device** %parent19, align 8, !tbaa !79
  %call20 = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %10)
  %tobool21 = icmp ne %struct.usb_hub* %call20, null
  br i1 %tobool21, label %if.end23, label %cleanup.cont

if.end23:                                         ; preds = %if.end18
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call20, i32 0, i32 25
  %11 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %12 = load i8, i8* %portnum, align 2, !tbaa !81
  %conv = zext i8 %12 to i32
  %sub = sub nsw i32 %conv, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %11, i64 %idxprom
  %13 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %usb3_lpm_u1_permit = getelementptr inbounds %struct.usb_port, %struct.usb_port* %13, i32 0, i32 9
  %bf.load24 = load i8, i8* %usb3_lpm_u1_permit, align 1
  %bf.lshr25 = lshr i8 %bf.load24, 1
  %bf.clear26 = and i8 %bf.lshr25, 1
  %bf.cast27 = zext i8 %bf.clear26 to i32
  %tobool28 = icmp ne i32 %bf.cast27, 0
  br i1 %tobool28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.end23
  call void @usb_enable_link_state(%struct.usb_hcd* %call, %struct.usb_device* %udev, i32 1)
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %if.end23
  %usb3_lpm_u2_permit = getelementptr inbounds %struct.usb_port, %struct.usb_port* %13, i32 0, i32 9
  %bf.load31 = load i8, i8* %usb3_lpm_u2_permit, align 1
  %bf.lshr32 = lshr i8 %bf.load31, 2
  %bf.clear33 = and i8 %bf.lshr32, 1
  %bf.cast34 = zext i8 %bf.clear33 to i32
  %tobool35 = icmp ne i32 %bf.cast34, 0
  br i1 %tobool35, label %if.then36, label %cleanup.cont

if.then36:                                        ; preds = %if.end30
  call void @usb_enable_link_state(%struct.usb_hcd* %call, %struct.usb_device* %udev, i32 2)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then36, %if.end30, %if.end18, %if.end14, %lor.lhs.false10, %lor.lhs.false8, %if.end, %lor.lhs.false5, %lor.lhs.false3, %lor.lhs.false2, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usb_enable_link_state(%struct.usb_hcd* %hcd, %struct.usb_device* %udev, i32 %state) #0 {
entry:
  %bos = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %0 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos, align 8, !tbaa !166
  %ss_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %0, i32 0, i32 2
  %1 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap, align 8, !tbaa !206
  %bU1devExitLat = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %1, i32 0, i32 6
  %2 = load i8, i8* %bU1devExitLat, align 1, !tbaa !211
  %bos1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %3 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos1, align 8, !tbaa !166
  %ss_cap2 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %3, i32 0, i32 2
  %4 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap2, align 8, !tbaa !206
  %bU2DevExitLat = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %4, i32 0, i32 7
  %5 = load i16, i16* %bU2DevExitLat, align 1, !tbaa !212
  %cmp = icmp eq i32 %state, 1
  %conv = zext i8 %2 to i32
  %cmp3 = icmp eq i32 %conv, 0
  %or.cond = and i1 %cmp, %cmp3
  br i1 %or.cond, label %cleanup.cont, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %cmp5 = icmp eq i32 %state, 2
  %conv8 = zext i16 %5 to i32
  %cmp9 = icmp eq i32 %conv8, 0
  %or.cond1 = and i1 %cmp5, %cmp9
  br i1 %or.cond1, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %call = call i32 @usb_req_set_sel(%struct.usb_device* %udev, i32 %state)
  %cmp11 = icmp slt i32 %call, 0
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup.cont

if.end14:                                         ; preds = %if.end
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %hcd, i32 0, i32 8
  %6 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %enable_usb3_lpm_timeout = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %6, i32 0, i32 40
  %7 = load i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)** %enable_usb3_lpm_timeout, align 8, !tbaa !209
  %call15 = call i32 %7(%struct.usb_hcd* %hcd, %struct.usb_device* %udev, i32 %state)
  %cmp16 = icmp eq i32 %call15, 0
  br i1 %cmp16, label %cleanup.cont, label %if.end19

if.end19:                                         ; preds = %if.end14
  %cmp20 = icmp slt i32 %call15, 0
  br i1 %cmp20, label %if.then22, label %if.end26

if.then22:                                        ; preds = %if.end19
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup.cont

if.end26:                                         ; preds = %if.end19
  %call27 = call i32 @usb_set_lpm_timeout(%struct.usb_device* %udev, i32 %state, i32 %call15)
  %tobool = icmp ne i32 %call27, 0
  br i1 %tobool, label %if.then28, label %if.else

if.then28:                                        ; preds = %if.end26
  %driver29 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %hcd, i32 0, i32 8
  %8 = load %struct.hc_driver*, %struct.hc_driver** %driver29, align 8, !tbaa !57
  %disable_usb3_lpm_timeout = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %8, i32 0, i32 41
  %9 = load i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)** %disable_usb3_lpm_timeout, align 8, !tbaa !210
  %call30 = call i32 %9(%struct.usb_hcd* %hcd, %struct.usb_device* %udev, i32 %state)
  br label %cleanup.cont

if.else:                                          ; preds = %if.end26
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %10 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool31 = icmp ne %struct.usb_host_config* %10, null
  br i1 %tobool31, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.else
  call void @usb_set_device_initiated_lpm(%struct.usb_device* %udev, i32 %state, i1 zeroext true)
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %if.else
  switch i32 %state, label %cleanup.cont [
    i32 1, label %if.then37
    i32 2, label %if.then41
  ]

if.then37:                                        ; preds = %if.end34
  %usb3_lpm_u1_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %usb3_lpm_u1_enabled, align 4
  %bf.clear = and i16 %bf.load, -2049
  %bf.set = or i16 %bf.clear, 2048
  store i16 %bf.set, i16* %usb3_lpm_u1_enabled, align 4
  br label %cleanup.cont

if.then41:                                        ; preds = %if.end34
  %usb3_lpm_u2_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load42 = load i16, i16* %usb3_lpm_u2_enabled, align 4
  %bf.clear43 = and i16 %bf.load42, -4097
  %bf.set44 = or i16 %bf.clear43, 4096
  store i16 %bf.set44, i16* %usb3_lpm_u2_enabled, align 4
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then41, %if.then37, %if.end34, %if.then28, %if.then22, %if.end14, %if.then13, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_req_set_sel(%struct.usb_device* %udev, i32 %state) #0 {
entry:
  %state1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state1, align 8, !tbaa !54
  %cmp = icmp ne i32 %0, 7
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %u1_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 38
  %sel = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %u1_params, i32 0, i32 2
  %1 = load i32, i32* %sel, align 8, !tbaa !213
  %add = add i32 %1, 1000
  %sub = sub i32 %add, 1
  %div = udiv i32 %sub, 1000
  %conv = zext i32 %div to i64
  %u1_params2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 38
  %pel = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %u1_params2, i32 0, i32 1
  %2 = load i32, i32* %pel, align 4, !tbaa !214
  %add3 = add i32 %2, 1000
  %sub4 = sub i32 %add3, 1
  %div5 = udiv i32 %sub4, 1000
  %conv6 = zext i32 %div5 to i64
  %u2_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 39
  %sel7 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %u2_params, i32 0, i32 2
  %3 = load i32, i32* %sel7, align 8, !tbaa !215
  %add8 = add i32 %3, 1000
  %sub9 = sub i32 %add8, 1
  %div10 = udiv i32 %sub9, 1000
  %conv11 = zext i32 %div10 to i64
  %u2_params12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 39
  %pel13 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %u2_params12, i32 0, i32 1
  %4 = load i32, i32* %pel13, align 4, !tbaa !216
  %add14 = add i32 %4, 1000
  %sub15 = sub i32 %add14, 1
  %div16 = udiv i32 %sub15, 1000
  %conv17 = zext i32 %div16 to i64
  switch i32 %state, label %if.end42 [
    i32 1, label %land.lhs.true
    i32 2, label %land.lhs.true27
  ]

land.lhs.true:                                    ; preds = %if.end
  %cmp20 = icmp ugt i64 %conv, 255
  %cmp22 = icmp ugt i64 %conv6, 255
  %or.cond = or i1 %cmp20, %cmp22
  br i1 %or.cond, label %do.body34, label %lor.lhs.false24

lor.lhs.false24:                                  ; preds = %land.lhs.true
  %cmp25 = icmp eq i32 %state, 2
  br i1 %cmp25, label %land.lhs.true27, label %if.end42

land.lhs.true27:                                  ; preds = %lor.lhs.false24, %if.end
  %cmp28 = icmp ugt i64 %conv11, 65535
  %cmp31 = icmp ugt i64 %conv17, 65535
  %or.cond1 = or i1 %cmp28, %cmp31
  br i1 %or.cond1, label %do.body34, label %if.end42

do.body34:                                        ; preds = %land.lhs.true27, %land.lhs.true
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_req_set_sel.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot35 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot35 to i32
  %conv36 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv36, i64 0)
  %tobool37 = icmp ne i64 %expval, 0
  br i1 %tobool37, label %if.then38, label %cleanup

if.then38:                                        ; preds = %do.body34
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %idxprom = zext i32 %state to i64
  %arrayidx = getelementptr inbounds [4 x i8*], [4 x i8*]* @usb3_lpm_names, i64 0, i64 %idxprom
  %5 = load i8*, i8** %arrayidx, align 8, !tbaa !52
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_req_set_sel.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.95, i32 0, i32 0), i8* %5, i64 %conv, i64 %conv6)
  br label %cleanup

if.end42:                                         ; preds = %land.lhs.true27, %lor.lhs.false24, %if.end
  %cmp43 = icmp ugt i64 %conv, 255
  %.conv = select i1 %cmp43, i64 255, i64 %conv
  %cmp47 = icmp ugt i64 %conv6, 255
  %u1_pel.0 = select i1 %cmp47, i64 255, i64 %conv6
  %cmp51 = icmp ugt i64 %conv11, 65535
  %.conv11 = select i1 %cmp51, i64 65535, i64 %conv11
  %cmp55 = icmp ugt i64 %conv17, 65535
  %u2_pel.0 = select i1 %cmp55, i64 65535, i64 %conv17
  %call.i = call noalias i8* @__kmalloc(i64 6, i32 20971520) #8
  %6 = bitcast i8* %call.i to %struct.usb_set_sel_req*
  %tobool59 = icmp ne %struct.usb_set_sel_req* %6, null
  br i1 %tobool59, label %if.end61, label %cleanup

if.end61:                                         ; preds = %if.end42
  %conv62 = trunc i64 %.conv to i8
  %u1_sel63 = getelementptr inbounds %struct.usb_set_sel_req, %struct.usb_set_sel_req* %6, i32 0, i32 0
  store i8 %conv62, i8* %u1_sel63, align 1, !tbaa !217
  %conv64 = trunc i64 %u1_pel.0 to i8
  %u1_pel65 = getelementptr inbounds %struct.usb_set_sel_req, %struct.usb_set_sel_req* %6, i32 0, i32 1
  store i8 %conv64, i8* %u1_pel65, align 1, !tbaa !219
  %conv66 = trunc i64 %.conv11 to i16
  %u2_sel67 = getelementptr inbounds %struct.usb_set_sel_req, %struct.usb_set_sel_req* %6, i32 0, i32 2
  store i16 %conv66, i16* %u2_sel67, align 1, !tbaa !220
  %conv68 = trunc i64 %u2_pel.0 to i16
  %u2_pel69 = getelementptr inbounds %struct.usb_set_sel_req, %struct.usb_set_sel_req* %6, i32 0, i32 3
  store i16 %conv68, i16* %u2_pel69, align 1, !tbaa !221
  %call70 = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or = or i32 -2147483648, %call70
  %7 = bitcast %struct.usb_set_sel_req* %6 to i8*
  %call71 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext 48, i8 zeroext 0, i16 zeroext 0, i16 zeroext 0, i8* %7, i16 zeroext 6, i32 5000)
  %8 = bitcast %struct.usb_set_sel_req* %6 to i8*
  call void @kfree(i8* %8)
  br label %cleanup

cleanup:                                          ; preds = %if.end61, %if.end42, %if.then38, %do.body34, %entry
  %retval.0 = phi i32 [ %call71, %if.end61 ], [ 0, %entry ], [ -22, %if.then38 ], [ -22, %do.body34 ], [ -12, %if.end42 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_set_lpm_timeout(%struct.usb_device* %udev, i32 %state, i32 %timeout) #0 {
entry:
  %Pivot = icmp slt i32 %state, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %state, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %state, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1
  %feature.0 = phi i32 [ 23, %LeafBlock ], [ 24, %LeafBlock1 ]
  %cmp = icmp eq i32 %state, 1
  %cmp2 = icmp sgt i32 %timeout, 127
  %or.cond = and i1 %cmp, %cmp2
  %cmp4 = icmp ne i32 %timeout, 255
  %or.cond3 = and i1 %or.cond, %cmp4
  br i1 %or.cond3, label %if.then, label %if.end

if.then:                                          ; preds = %sw.epilog
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

if.end:                                           ; preds = %sw.epilog
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %and = and i32 %timeout, 255
  %shl = shl i32 %and, 8
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %1 = load i8, i8* %portnum, align 2, !tbaa !81
  %conv = zext i8 %1 to i32
  %or = or i32 %shl, %conv
  %call = call i32 @set_port_feature(%struct.usb_device* %0, i32 %or, i32 %feature.0)
  %cmp6 = icmp slt i32 %call, 0
  br i1 %cmp6, label %if.then8, label %if.end12

if.then8:                                         ; preds = %if.end
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

if.end12:                                         ; preds = %if.end
  %cmp13 = icmp eq i32 %state, 1
  %u2_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 39
  %u1_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 38
  %u2_params.sink = select i1 %cmp13, %struct.usb3_lpm_parameters* %u1_params, %struct.usb3_lpm_parameters* %u2_params
  %timeout17 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %u2_params.sink, i32 0, i32 3
  store i32 %timeout, i32* %timeout17, align 4, !tbaa !73
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %if.then8, %if.then, %sw.default
  %retval.0 = phi i32 [ -22, %if.then ], [ -16, %if.then8 ], [ 0, %if.end12 ], [ -22, %sw.default ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @usb_set_device_initiated_lpm(%struct.usb_device* %udev, i32 %state, i1 zeroext %enable) #0 {
entry:
  %frombool = zext i1 %enable to i8
  %Pivot = icmp slt i32 %state, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %state, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %state, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1
  %feature.0 = phi i32 [ 48, %LeafBlock ], [ 49, %LeafBlock1 ]
  %state2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state2, align 8, !tbaa !54
  %cmp = icmp ne i32 %0, 7
  br i1 %cmp, label %do.body3, label %if.end14

do.body3:                                         ; preds = %sw.epilog
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_set_device_initiated_lpm.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool4 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool4, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then7, label %cleanup

if.then7:                                         ; preds = %do.body3
  %dev8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %tobool9 = trunc i8 %frombool to i1
  %cond11 = select i1 %tobool9, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.83, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.84, i32 0, i32 0)
  %idxprom = zext i32 %state to i64
  %arrayidx = getelementptr inbounds [4 x i8*], [4 x i8*]* @usb3_lpm_names, i64 0, i64 %idxprom
  %1 = load i8*, i8** %arrayidx, align 8, !tbaa !52
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_set_device_initiated_lpm.descriptor to %struct._ddebug*), %struct.device* %dev8, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.85, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__func__.usb_set_device_initiated_lpm, i32 0, i32 0), i8* %cond11, i8* %1)
  br label %cleanup

if.end14:                                         ; preds = %sw.epilog
  %tobool15 = trunc i8 %frombool to i1
  %call = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or = or i32 -2147483648, %call
  %conv17 = trunc i32 %feature.0 to i16
  %.sink = select i1 %tobool15, i8 3, i8 1
  %call22 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext %.sink, i8 zeroext 0, i16 zeroext %conv17, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  %cmp24 = icmp slt i32 %call22, 0
  br i1 %cmp24, label %if.then26, label %cleanup

if.then26:                                        ; preds = %if.end14
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then26, %if.end14, %if.then7, %do.body3, %sw.default
  ret void
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #2 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal void @recursively_mark_NOTATTACHED(%struct.usb_device* %udev) #0 {
entry:
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %udev)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 28
  %0 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp = icmp slt i32 %i.0, %0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %1 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %1, i64 %idxprom
  %2 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %2, i32 0, i32 0
  %3 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !115
  %tobool = icmp ne %struct.usb_device* %3, null
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %ports1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %4 = load %struct.usb_port**, %struct.usb_port*** %ports1, align 8, !tbaa !112
  %idxprom2 = sext i32 %i.0 to i64
  %arrayidx3 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %4, i64 %idxprom2
  %5 = load %struct.usb_port*, %struct.usb_port** %arrayidx3, align 8, !tbaa !52
  %child4 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %5, i32 0, i32 0
  %6 = load %struct.usb_device*, %struct.usb_device** %child4, align 8, !tbaa !115
  call void @recursively_mark_NOTATTACHED(%struct.usb_device* %6)
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %7 = load i32, i32* %state, align 8, !tbaa !54
  %cmp5 = icmp eq i32 %7, 8
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.end
  %8 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  %active_duration = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 31
  %9 = load i64, i64* %active_duration, align 8, !tbaa !83
  %sub = sub i64 %9, %8
  store i64 %sub, i64* %active_duration, align 8, !tbaa !83
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %for.end
  %state8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  store i32 0, i32* %state8, align 8, !tbaa !54
  ret void
}

declare void @device_set_wakeup_capable(%struct.device*, i1 zeroext) #2

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #2 section ".spinlock.text"

declare i32 @memcmp(i8*, i8*, i64) #2

declare i64 @strlen(i8*) #2

; Function Attrs: nounwind uwtable
define internal i32 @hub_port_reset(%struct.usb_hub* %hub, i32 %port1, %struct.usb_device* %udev, i32 %delay, i1 zeroext %warm) #0 {
entry:
  %portchange = alloca i16, align 2
  %portstatus = alloca i16, align 2
  %frombool = zext i1 %warm to i8
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %0 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %0, i64 %idxprom
  %1 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %2)
  %tobool = icmp ne i32 %call, 0
  %tobool3 = trunc i8 %frombool to i1
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  br i1 %tobool3, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end:                                           ; preds = %if.then
  call void @down_read(%struct.rw_semaphore* @ehci_cf_port_reset_rwsem)
  br label %if.end12

if.else:                                          ; preds = %entry
  br i1 %tobool3, label %if.end12, label %if.then4

if.then4:                                         ; preds = %if.else
  %call5 = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1, i16* %portstatus, i16* %portchange)
  %cmp = icmp eq i32 %call5, 0
  br i1 %cmp, label %if.then6, label %if.end12

if.then6:                                         ; preds = %if.then4
  %3 = load i16, i16* %portstatus, align 2, !tbaa !165
  %call7 = call zeroext i1 @hub_port_warm_reset_required(%struct.usb_hub* %hub, i32 %port1, i16 zeroext %3)
  %.frombool = select i1 %call7, i8 1, i8 %frombool
  br label %if.end12

if.end12:                                         ; preds = %if.then6, %if.then4, %if.else, %if.end
  %warm.addr.3 = phi i8 [ %frombool, %if.end ], [ %frombool, %if.else ], [ %.frombool, %if.then6 ], [ %frombool, %if.then4 ]
  %conv = sext i32 %port1 to i64
  %warm_reset_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %warm_reset_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i64 %conv, i64* %arraydecay) #8, !srcloc !222
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end12
  %warm.addr.4 = phi i8 [ %warm.addr.3, %if.end12 ], [ %warm.addr.6, %for.inc ]
  %delay.addr.0 = phi i32 [ %delay, %if.end12 ], [ 200, %for.inc ]
  %i.0 = phi i32 [ 0, %if.end12 ], [ %inc, %for.inc ]
  %status.0 = phi i32 [ undef, %if.end12 ], [ %status.2, %for.inc ]
  %cmp13 = icmp slt i32 %i.0, 5
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %hdev15 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %hdev15, align 8, !tbaa !176
  %tobool16 = trunc i8 %warm.addr.4 to i1
  %cond = select i1 %tobool16, i32 28, i32 4
  %call18 = call i32 @set_port_feature(%struct.usb_device* %4, i32 %port1, i32 %cond)
  switch i32 %call18, label %if.then24 [
    i32 -19, label %if.end50
    i32 0, label %if.else28
  ]

if.then24:                                        ; preds = %for.body
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end50

if.else28:                                        ; preds = %for.body
  %tobool29 = trunc i8 %warm.addr.4 to i1
  %call30 = call i32 @hub_port_wait_reset(%struct.usb_hub* %hub, i32 %port1, %struct.usb_device* %udev, i32 %delay.addr.0, i1 zeroext %tobool29)
  switch i32 %call30, label %do.body38 [
    i32 0, label %if.end50
    i32 -107, label %if.end50
    i32 -19, label %if.end50
  ]

do.body38:                                        ; preds = %if.else28
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_reset.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool39 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool39, true
  %lnot40 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot40 to i32
  %conv41 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv41, i64 0)
  %tobool42 = icmp ne i64 %expval, 0
  br i1 %tobool42, label %if.then43, label %if.end50

if.then43:                                        ; preds = %do.body38
  %intfdev44 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %5 = load %struct.device*, %struct.device** %intfdev44, align 8, !tbaa !204
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_reset.descriptor to %struct._ddebug*), %struct.device* %5, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.145, i32 0, i32 0), i32 %call30)
  br label %if.end50

if.end50:                                         ; preds = %if.then43, %do.body38, %if.else28, %if.else28, %if.else28, %if.then24, %for.body
  %status.2 = phi i32 [ %call18, %for.body ], [ %call18, %if.then24 ], [ %call30, %do.body38 ], [ %call30, %if.then43 ], [ %call30, %if.else28 ], [ %call30, %if.else28 ], [ %call30, %if.else28 ]
  switch i32 %status.2, label %do.body106 [
    i32 0, label %if.then58
    i32 -107, label %if.then58
    i32 -19, label %if.then58
  ]

if.then58:                                        ; preds = %if.end50, %if.end50, %if.end50
  %hdev59 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %hdev59, align 8, !tbaa !176
  %call60 = call i32 @usb_clear_port_feature(%struct.usb_device* %6, i32 %port1, i32 20)
  %hdev61 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %7 = load %struct.usb_device*, %struct.usb_device** %hdev61, align 8, !tbaa !176
  %call62 = call i32 @hub_is_superspeed(%struct.usb_device* %7)
  %tobool63 = icmp ne i32 %call62, 0
  br i1 %tobool63, label %if.end65, label %done

if.end65:                                         ; preds = %if.then58
  %hdev66 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %8 = load %struct.usb_device*, %struct.usb_device** %hdev66, align 8, !tbaa !176
  %call67 = call i32 @usb_clear_port_feature(%struct.usb_device* %8, i32 %port1, i32 29)
  %hdev68 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %hdev68, align 8, !tbaa !176
  %call69 = call i32 @usb_clear_port_feature(%struct.usb_device* %9, i32 %port1, i32 25)
  %hdev70 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %hdev70, align 8, !tbaa !176
  %call71 = call i32 @usb_clear_port_feature(%struct.usb_device* %10, i32 %port1, i32 16)
  %call72 = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1, i16* %portstatus, i16* %portchange)
  %cmp73 = icmp slt i32 %call72, 0
  br i1 %cmp73, label %done, label %if.end76

if.end76:                                         ; preds = %if.end65
  %11 = load i16, i16* %portstatus, align 2, !tbaa !165
  %call77 = call zeroext i1 @hub_port_warm_reset_required(%struct.usb_hub* %hub, i32 %port1, i16 zeroext %11)
  br i1 %call77, label %if.end79, label %done

if.end79:                                         ; preds = %if.end76
  %tobool80 = trunc i8 %warm.addr.4 to i1
  br i1 %tobool80, label %do.body106, label %do.body83

do.body83:                                        ; preds = %if.end79
  %bf.load84 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_reset.descriptor.146 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr85 = lshr i32 %bf.load84, 18
  %bf.clear86 = and i32 %bf.lshr85, 255
  %and87 = and i32 %bf.clear86, 1
  %tobool88 = icmp ne i32 %and87, 0
  %lnot89 = xor i1 %tobool88, true
  %lnot91 = xor i1 %lnot89, true
  %lnot.ext92 = zext i1 %lnot91 to i32
  %conv93 = sext i32 %lnot.ext92 to i64
  %expval94 = call i64 @llvm.expect.i64(i64 %conv93, i64 0)
  %tobool95 = icmp ne i64 %expval94, 0
  br i1 %tobool95, label %if.then96, label %do.body106

if.then96:                                        ; preds = %do.body83
  %dev97 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_reset.descriptor.146 to %struct._ddebug*), %struct.device* %dev97, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.147, i32 0, i32 0))
  br label %do.body106

do.body106:                                       ; preds = %if.then96, %do.body83, %if.end79, %if.end50
  %warm.addr.6 = phi i8 [ %warm.addr.4, %if.end50 ], [ %warm.addr.4, %if.end79 ], [ 1, %if.then96 ], [ 1, %do.body83 ]
  %bf.load107 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_reset.descriptor.148 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr108 = lshr i32 %bf.load107, 18
  %bf.clear109 = and i32 %bf.lshr108, 255
  %and110 = and i32 %bf.clear109, 1
  %tobool111 = icmp ne i32 %and110, 0
  %lnot112 = xor i1 %tobool111, true
  %lnot114 = xor i1 %lnot112, true
  %lnot.ext115 = zext i1 %lnot114 to i32
  %conv116 = sext i32 %lnot.ext115 to i64
  %expval117 = call i64 @llvm.expect.i64(i64 %conv116, i64 0)
  %tobool118 = icmp ne i64 %expval117, 0
  br i1 %tobool118, label %if.then119, label %for.inc

if.then119:                                       ; preds = %do.body106
  %dev120 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  %tobool121 = trunc i8 %warm.addr.6 to i1
  %cond123 = select i1 %tobool121, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.144, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.28.900, i32 0, i32 0)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_reset.descriptor.148 to %struct._ddebug*), %struct.device* %dev120, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.149, i32 0, i32 0), i8* %cond123)
  br label %for.inc

for.inc:                                          ; preds = %if.then119, %do.body106
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %done

done:                                             ; preds = %for.end, %if.end76, %if.end65, %if.then58
  %status.3 = phi i32 [ %status.0, %for.end ], [ %status.2, %if.then58 ], [ %status.2, %if.end65 ], [ %status.2, %if.end76 ]
  %cmp130 = icmp eq i32 %status.3, 0
  br i1 %cmp130, label %if.then132, label %if.else143

if.then132:                                       ; preds = %done
  call void @msleep(i32 50)
  %tobool133 = icmp ne %struct.usb_device* %udev, null
  br i1 %tobool133, label %if.then134, label %if.end147

if.then134:                                       ; preds = %if.then132
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %12 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call135 = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %12)
  call void @update_devnum(%struct.usb_device* %udev, i32 0)
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call135, i32 0, i32 8
  %13 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %reset_device = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %13, i32 0, i32 37
  %14 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %reset_device, align 8, !tbaa !223
  %tobool136 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*)* %14, null
  br i1 %tobool136, label %if.then137, label %if.end141

if.then137:                                       ; preds = %if.then134
  %driver138 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call135, i32 0, i32 8
  %15 = load %struct.hc_driver*, %struct.hc_driver** %driver138, align 8, !tbaa !57
  %reset_device139 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %15, i32 0, i32 37
  %16 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %reset_device139, align 8, !tbaa !223
  %call140 = call i32 %16(%struct.usb_hcd* %call135, %struct.usb_device* %udev)
  br label %if.end141

if.end141:                                        ; preds = %if.then137, %if.then134
  call void @usb_set_device_state(%struct.usb_device* %udev, i32 5)
  br label %if.end147

if.else143:                                       ; preds = %done
  %tobool144 = icmp ne %struct.usb_device* %udev, null
  br i1 %tobool144, label %if.then145, label %if.end147

if.then145:                                       ; preds = %if.else143
  call void @usb_set_device_state(%struct.usb_device* %udev, i32 0)
  br label %if.end147

if.end147:                                        ; preds = %if.then145, %if.else143, %if.end141, %if.then132
  %hdev148 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %17 = load %struct.usb_device*, %struct.usb_device** %hdev148, align 8, !tbaa !176
  %call149 = call i32 @hub_is_superspeed(%struct.usb_device* %17)
  %tobool150 = icmp ne i32 %call149, 0
  br i1 %tobool150, label %cleanup, label %if.then151

if.then151:                                       ; preds = %if.end147
  call void @up_read(%struct.rw_semaphore* @ehci_cf_port_reset_rwsem)
  br label %cleanup

cleanup:                                          ; preds = %if.then151, %if.end147, %if.then2
  %retval.0 = phi i32 [ -22, %if.then2 ], [ %status.3, %if.then151 ], [ %status.3, %if.end147 ]
  ret i32 %retval.0
}

declare i8* @usb_speed_string(i32) #2

; Function Attrs: nounwind uwtable
define internal zeroext i1 @use_new_scheme(%struct.usb_device* %udev, i32 %retry) #0 {
entry:
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp uge i32 %0, 5
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %div = sdiv i32 %retry, 2
  %1 = load i8, i8* @old_scheme_first, align 1, !tbaa !109, !range !110
  %tobool = trunc i8 %1 to i1
  %conv = zext i1 %tobool to i32
  %cmp1 = icmp eq i32 %div, %conv
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i1 [ %cmp1, %if.end ], [ false, %entry ]
  ret i1 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_enable_device(%struct.usb_device* %udev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %0)
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %1 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %enable_device = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 35
  %2 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %enable_device, align 8, !tbaa !224
  %tobool = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*)* %2, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %3 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %3, 6
  br i1 %cmp, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %state3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %4 = load i32, i32* %state3, align 8, !tbaa !54
  %cmp4 = icmp ne i32 %4, 5
  br i1 %cmp4, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end2
  %driver7 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %5 = load %struct.hc_driver*, %struct.hc_driver** %driver7, align 8, !tbaa !57
  %enable_device8 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %5, i32 0, i32 35
  %6 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %enable_device8, align 8, !tbaa !224
  %call9 = call i32 %6(%struct.usb_hcd* %call, %struct.usb_device* %udev)
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.end2, %if.end, %entry
  %retval.0 = phi i32 [ %call9, %if.end6 ], [ 0, %entry ], [ 0, %if.end ], [ -22, %if.end2 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_set_address(%struct.usb_device* %udev, i32 %devnum) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %0)
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %1 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %address_device = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 34
  %2 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %address_device, align 8, !tbaa !225
  %tobool = icmp eq i32 (%struct.usb_hcd*, %struct.usb_device*)* %2, null
  %cmp = icmp sle i32 %devnum, 1
  %or.cond = and i1 %tobool, %cmp
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %3 = load i32, i32* %state, align 8, !tbaa !54
  %cmp2 = icmp eq i32 %3, 6
  br i1 %cmp2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %state5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %4 = load i32, i32* %state5, align 8, !tbaa !54
  %cmp6 = icmp ne i32 %4, 5
  br i1 %cmp6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end4
  %driver9 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %5 = load %struct.hc_driver*, %struct.hc_driver** %driver9, align 8, !tbaa !57
  %address_device10 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %5, i32 0, i32 34
  %6 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %address_device10, align 8, !tbaa !225
  %tobool11 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*)* %6, null
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end8
  %driver13 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %7 = load %struct.hc_driver*, %struct.hc_driver** %driver13, align 8, !tbaa !57
  %address_device14 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %7, i32 0, i32 34
  %8 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %address_device14, align 8, !tbaa !225
  %call15 = call i32 %8(%struct.usb_hcd* %call, %struct.usb_device* %udev)
  br label %if.end17

if.else:                                          ; preds = %if.end8
  %conv = trunc i32 %devnum to i16
  %call16 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 -2147483648, i8 zeroext 5, i8 zeroext 0, i16 zeroext %conv, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.then12
  %retval1.0 = phi i32 [ %call15, %if.then12 ], [ %call16, %if.else ]
  %cmp18 = icmp eq i32 %retval1.0, 0
  br i1 %cmp18, label %if.then20, label %cleanup

if.then20:                                        ; preds = %if.end17
  call void @update_devnum(%struct.usb_device* %udev, i32 %devnum)
  call void @usb_set_device_state(%struct.usb_device* %udev, i32 6)
  call void @usb_ep0_reinit(%struct.usb_device* %udev)
  br label %cleanup

cleanup:                                          ; preds = %if.then20, %if.end17, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ 0, %if.end ], [ -22, %if.end4 ], [ %retval1.0, %if.then20 ], [ %retval1.0, %if.end17 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_maxp(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 4
  %0 = load i16, i16* %wMaxPacketSize, align 1, !tbaa !226
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 2047
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define i32 @usb_device_supports_lpm(%struct.usb_device* %udev) #0 {
entry:
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %0 = load i32, i32* %quirks, align 4, !tbaa !199
  %conv = zext i32 %0 to i64
  %and = and i64 %conv, 1024
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %1 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp eq i32 %1, 3
  br i1 %cmp, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %speed2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %2 = load i32, i32* %speed2, align 4, !tbaa !177
  %cmp3 = icmp eq i32 %2, 2
  br i1 %cmp3, label %if.then5, label %if.end13

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %bos = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %3 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos, align 8, !tbaa !166
  %ext_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %3, i32 0, i32 1
  %4 = load %struct.usb_ext_cap_descriptor*, %struct.usb_ext_cap_descriptor** %ext_cap, align 8, !tbaa !227
  %tobool6 = icmp ne %struct.usb_ext_cap_descriptor* %4, null
  br i1 %tobool6, label %land.lhs.true, label %if.end12

land.lhs.true:                                    ; preds = %if.then5
  %bos7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %5 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos7, align 8, !tbaa !166
  %ext_cap8 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %5, i32 0, i32 1
  %6 = load %struct.usb_ext_cap_descriptor*, %struct.usb_ext_cap_descriptor** %ext_cap8, align 8, !tbaa !227
  %bmAttributes = getelementptr inbounds %struct.usb_ext_cap_descriptor, %struct.usb_ext_cap_descriptor* %6, i32 0, i32 3
  %7 = load i32, i32* %bmAttributes, align 1, !tbaa !228
  %and9 = and i32 2, %7
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %return, label %if.end12

if.end12:                                         ; preds = %land.lhs.true, %if.then5
  br label %return

if.end13:                                         ; preds = %lor.lhs.false
  %bos14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %8 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos14, align 8, !tbaa !166
  %ss_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %8, i32 0, i32 2
  %9 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap, align 8, !tbaa !206
  %tobool15 = icmp ne %struct.usb_ss_cap_descriptor* %9, null
  br i1 %tobool15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %if.end13
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %return

if.end17:                                         ; preds = %if.end13
  %bos18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %10 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos18, align 8, !tbaa !166
  %ss_cap19 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %10, i32 0, i32 2
  %11 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap19, align 8, !tbaa !206
  %bU1devExitLat = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %11, i32 0, i32 6
  %12 = load i8, i8* %bU1devExitLat, align 1, !tbaa !211
  %conv20 = zext i8 %12 to i32
  %cmp21 = icmp eq i32 %conv20, 0
  br i1 %cmp21, label %land.lhs.true23, label %if.end35

land.lhs.true23:                                  ; preds = %if.end17
  %bos24 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %13 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos24, align 8, !tbaa !166
  %ss_cap25 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %13, i32 0, i32 2
  %14 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap25, align 8, !tbaa !206
  %bU2DevExitLat = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %14, i32 0, i32 7
  %15 = load i16, i16* %bU2DevExitLat, align 1, !tbaa !212
  %conv26 = zext i16 %15 to i32
  %cmp27 = icmp eq i32 %conv26, 0
  br i1 %cmp27, label %if.then29, label %if.end35

if.then29:                                        ; preds = %land.lhs.true23
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %16 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool30 = icmp ne %struct.usb_device* %16, null
  br i1 %tobool30, label %if.then31, label %if.else

if.then31:                                        ; preds = %if.then29
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %return

if.else:                                          ; preds = %if.then29
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %return

if.end35:                                         ; preds = %land.lhs.true23, %if.end17
  %parent36 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %17 = load %struct.usb_device*, %struct.usb_device** %parent36, align 8, !tbaa !79
  %tobool37 = icmp ne %struct.usb_device* %17, null
  br i1 %tobool37, label %lor.lhs.false38, label %return

lor.lhs.false38:                                  ; preds = %if.end35
  %parent39 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %18 = load %struct.usb_device*, %struct.usb_device** %parent39, align 8, !tbaa !79
  %lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 22
  %bf.load = load i16, i16* %lpm_capable, align 4
  %bf.lshr = lshr i16 %bf.load, 6
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool40 = icmp ne i32 %bf.cast, 0
  %. = select i1 %tobool40, i32 1, i32 0
  ret i32 %.

return:                                           ; preds = %if.end35, %if.else, %if.then31, %if.then16, %if.end12, %land.lhs.true, %entry
  %retval.0 = phi i32 [ 0, %if.end12 ], [ 0, %if.then16 ], [ 0, %entry ], [ 1, %land.lhs.true ], [ 0, %if.else ], [ 0, %if.then31 ], [ 1, %if.end35 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @usb_set_lpm_parameters(%struct.usb_device* %udev) #0 {
entry:
  %lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %lpm_capable, align 4
  %bf.lshr = lshr i16 %bf.load, 6
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %lor.lhs.false, label %cleanup.cont

lor.lhs.false:                                    ; preds = %entry
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp ult i32 %0, 5
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %1 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %1)
  %tobool1 = icmp ne %struct.usb_hub* %call, null
  br i1 %tobool1, label %if.end3, label %cleanup.cont

if.end3:                                          ; preds = %if.end
  %bos = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %2 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos, align 8, !tbaa !166
  %ss_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %2, i32 0, i32 2
  %3 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap, align 8, !tbaa !206
  %bU1devExitLat = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %3, i32 0, i32 6
  %4 = load i8, i8* %bU1devExitLat, align 1, !tbaa !211
  %conv = zext i8 %4 to i32
  %bos4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %5 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos4, align 8, !tbaa !166
  %ss_cap5 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %5, i32 0, i32 2
  %6 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap5, align 8, !tbaa !206
  %bU2DevExitLat = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %6, i32 0, i32 7
  %7 = load i16, i16* %bU2DevExitLat, align 1, !tbaa !212
  %conv6 = zext i16 %7 to i32
  %parent7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %8 = load %struct.usb_device*, %struct.usb_device** %parent7, align 8, !tbaa !79
  %bos8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 13
  %9 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos8, align 8, !tbaa !166
  %ss_cap9 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %9, i32 0, i32 2
  %10 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap9, align 8, !tbaa !206
  %bU1devExitLat10 = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %10, i32 0, i32 6
  %11 = load i8, i8* %bU1devExitLat10, align 1, !tbaa !211
  %conv11 = zext i8 %11 to i32
  %parent12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %12 = load %struct.usb_device*, %struct.usb_device** %parent12, align 8, !tbaa !79
  %bos13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 13
  %13 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos13, align 8, !tbaa !166
  %ss_cap14 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %13, i32 0, i32 2
  %14 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap14, align 8, !tbaa !206
  %bU2DevExitLat15 = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %14, i32 0, i32 7
  %15 = load i16, i16* %bU2DevExitLat15, align 1, !tbaa !212
  %conv16 = zext i16 %15 to i32
  %u1_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 38
  %parent17 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %16 = load %struct.usb_device*, %struct.usb_device** %parent17, align 8, !tbaa !79
  %u1_params18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %16, i32 0, i32 38
  call void @usb_set_lpm_mel(%struct.usb3_lpm_parameters* %u1_params, i32 %conv, %struct.usb_hub* %call, %struct.usb3_lpm_parameters* %u1_params18, i32 %conv11)
  %u2_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 39
  %parent19 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %17 = load %struct.usb_device*, %struct.usb_device** %parent19, align 8, !tbaa !79
  %u2_params20 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %17, i32 0, i32 39
  call void @usb_set_lpm_mel(%struct.usb3_lpm_parameters* %u2_params, i32 %conv6, %struct.usb_hub* %call, %struct.usb3_lpm_parameters* %u2_params20, i32 %conv16)
  %u1_params21 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 38
  %parent22 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %18 = load %struct.usb_device*, %struct.usb_device** %parent22, align 8, !tbaa !79
  %u1_params23 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 38
  call void @usb_set_lpm_pel(%struct.usb3_lpm_parameters* %u1_params21, i32 %conv, %struct.usb3_lpm_parameters* %u1_params23, i32 %conv11, i32 1)
  %cmp24 = icmp ugt i32 %conv16, %conv11
  %add = add i32 1, %conv16
  %sub = sub i32 %add, %conv11
  %add27 = add i32 1, %conv11
  %port_to_port_delay.0 = select i1 %cmp24, i32 %sub, i32 %add27
  %u2_params29 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 39
  %parent30 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %19 = load %struct.usb_device*, %struct.usb_device** %parent30, align 8, !tbaa !79
  %u2_params31 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %19, i32 0, i32 39
  call void @usb_set_lpm_pel(%struct.usb3_lpm_parameters* %u2_params29, i32 %conv6, %struct.usb3_lpm_parameters* %u2_params31, i32 %conv16, i32 %port_to_port_delay.0)
  %u1_params32 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 38
  call void @usb_set_lpm_sel(%struct.usb_device* %udev, %struct.usb3_lpm_parameters* %u1_params32)
  %u2_params33 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 39
  call void @usb_set_lpm_sel(%struct.usb_device* %udev, %struct.usb3_lpm_parameters* %u2_params33)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end3, %if.end, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_set_initial_usb2_lpm_policy(%struct.usb_device* %udev) #0 {
entry:
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %0)
  %usb2_hw_lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %usb2_hw_lpm_capable, align 4
  %bf.lshr = lshr i16 %bf.load, 7
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %lor.lhs.false, label %cleanup.cont

lor.lhs.false:                                    ; preds = %entry
  %bos = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %1 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos, align 8, !tbaa !166
  %tobool1 = icmp ne %struct.usb_host_bos* %1, null
  br i1 %tobool1, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %lor.lhs.false
  %tobool2 = icmp ne %struct.usb_hub* %call, null
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %2 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %3 = load i8, i8* %portnum, align 2, !tbaa !81
  %conv = zext i8 %3 to i32
  %sub = sub nsw i32 %conv, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %2, i64 %idxprom
  %4 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %connect_type4 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %4, i32 0, i32 5
  %5 = load i32, i32* %connect_type4, align 8, !tbaa !230
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %connect_type.0 = phi i32 [ %5, %if.then3 ], [ 0, %if.end ]
  %bos6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %6 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos6, align 8, !tbaa !166
  %ext_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %6, i32 0, i32 1
  %7 = load %struct.usb_ext_cap_descriptor*, %struct.usb_ext_cap_descriptor** %ext_cap, align 8, !tbaa !227
  %bmAttributes = getelementptr inbounds %struct.usb_ext_cap_descriptor, %struct.usb_ext_cap_descriptor* %7, i32 0, i32 3
  %8 = load i32, i32* %bmAttributes, align 1, !tbaa !228
  %and = and i32 %8, 4
  %tobool7 = icmp ne i32 %and, 0
  %cmp = icmp eq i32 %connect_type.0, 2
  %or.cond = or i1 %tobool7, %cmp
  br i1 %or.cond, label %if.then10, label %cleanup.cont

if.then10:                                        ; preds = %if.end5
  %usb2_hw_lpm_allowed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load11 = load i16, i16* %usb2_hw_lpm_allowed, align 4
  %bf.clear12 = and i16 %bf.load11, -1025
  %bf.set = or i16 %bf.clear12, 1024
  store i16 %bf.set, i16* %usb2_hw_lpm_allowed, align 4
  %call13 = call i32 @usb_set_usb2_hardware_lpm(%struct.usb_device* %udev, i32 1)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then10, %if.end5, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @update_devnum(%struct.usb_device* %udev, i32 %devnum) #0 {
entry:
  %wusb = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %wusb, align 4
  %bf.lshr = lshr i16 %bf.load, 5
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %devnum1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  store i32 %devnum, i32* %devnum1, align 8, !tbaa !44
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usb_set_lpm_mel(%struct.usb3_lpm_parameters* %udev_lpm_params, i32 %udev_exit_latency, %struct.usb_hub* %hub, %struct.usb3_lpm_parameters* %hub_lpm_params, i32 %hub_exit_latency) #0 {
entry:
  %mel = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %hub_lpm_params, i32 0, i32 0
  %0 = load i32, i32* %mel, align 4, !tbaa !231
  %descriptor = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %1 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !232
  %u = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %1, i32 0, i32 6
  %ss = bitcast %union.anon.63* %u to %struct.anon.65*
  %bHubHdrDecLat = getelementptr inbounds %struct.anon.65, %struct.anon.65* %ss, i32 0, i32 0
  %2 = load i8, i8* %bHubHdrDecLat, align 1, !tbaa !72
  %conv = zext i8 %2 to i32
  %mul = mul nsw i32 %conv, 100
  %add = add i32 %0, %mul
  %mul1 = mul i32 %udev_exit_latency, 1000
  %mul2 = mul i32 %hub_exit_latency, 1000
  %cmp = icmp ugt i32 %mul1, %mul2
  %mul2.sink = select i1 %cmp, i32 %mul1, i32 %mul2
  %add5 = add i32 %add, %mul2.sink
  %mel6 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %udev_lpm_params, i32 0, i32 0
  store i32 %add5, i32* %mel6, align 4, !tbaa !231
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usb_set_lpm_pel(%struct.usb3_lpm_parameters* %udev_lpm_params, i32 %udev_exit_latency, %struct.usb3_lpm_parameters* %hub_lpm_params, i32 %hub_exit_latency, i32 %port_to_port_exit_latency) #0 {
entry:
  %cmp = icmp ugt i32 %udev_exit_latency, %hub_exit_latency
  %hub_exit_latency.sink = select i1 %cmp, i32 %udev_exit_latency, i32 %hub_exit_latency
  %mul1 = mul i32 %hub_exit_latency.sink, 1000
  %mul2 = mul i32 %port_to_port_exit_latency, 1000
  %pel = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %hub_lpm_params, i32 0, i32 1
  %0 = load i32, i32* %pel, align 4, !tbaa !233
  %add = add i32 %mul2, %0
  %cmp3 = icmp ugt i32 %mul1, %add
  %pel5 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %udev_lpm_params, i32 0, i32 1
  %add.sink = select i1 %cmp3, i32 %mul1, i32 %add
  store i32 %add.sink, i32* %pel5, align 4, !tbaa !233
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usb_set_lpm_sel(%struct.usb_device* %udev, %struct.usb3_lpm_parameters* %udev_lpm_params) #0 {
entry:
  %pel = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %udev_lpm_params, i32 0, i32 1
  %0 = load i32, i32* %pel, align 4, !tbaa !233
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %.sink = phi %struct.usb_device* [ %1, %for.body ], [ %udev, %entry ]
  %num_hubs.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %parent3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %.sink, i32 0, i32 8
  %1 = load %struct.usb_device*, %struct.usb_device** %parent3, align 8, !tbaa !79
  %parent2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 8
  %2 = load %struct.usb_device*, %struct.usb_device** %parent2, align 8, !tbaa !79
  %tobool = icmp ne %struct.usb_device* %2, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %inc = add i32 %num_hubs.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %cmp = icmp ugt i32 %num_hubs.0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %sub = sub i32 %num_hubs.0, 1
  %mul = mul i32 250, %sub
  %add = add i32 2100, %mul
  %add4 = add i32 %0, %add
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  %total_sel.0 = phi i32 [ %add4, %if.then ], [ %0, %for.end ]
  %mul5 = mul i32 250, %num_hubs.0
  %add6 = add i32 %total_sel.0, %mul5
  %sel = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %udev_lpm_params, i32 0, i32 2
  store i32 %add6, i32* %sel, align 4, !tbaa !234
  ret void
}

declare void @down_read(%struct.rw_semaphore*) #2

; Function Attrs: nounwind uwtable
define internal i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1, i16* %status, i16* %change) #0 {
entry:
  %call = call i32 @hub_ext_port_status(%struct.usb_hub* %hub, i32 %port1, i32 0, i16* %status, i16* %change, i32* null)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @hub_port_warm_reset_required(%struct.usb_hub* %hub, i32 %port1, i16 zeroext %portstatus) #0 {
entry:
  %oldbit.i = alloca i8, align 1
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cond.false, label %cleanup

cond.false:                                       ; preds = %entry
  %conv3 = sext i32 %port1 to i64
  %warm_reset_bits4 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %arraydecay5 = getelementptr inbounds [1 x i64], [1 x i64]* %warm_reset_bits4, i32 0, i32 0
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %arraydecay5, i64 %conv3) #8, !srcloc !235
  %1 = load i8, i8* %oldbit.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %1 to i1
  br i1 %tobool.i, label %cleanup, label %if.end9

if.end9:                                          ; preds = %cond.false
  %conv10 = zext i16 %portstatus to i32
  %and = and i32 %conv10, 480
  %conv11 = trunc i32 %and to i16
  %conv12 = zext i16 %conv11 to i32
  %cmp = icmp eq i32 %conv12, 192
  %conv14 = zext i16 %conv11 to i32
  %cmp15 = icmp eq i32 %conv14, 320
  %2 = select i1 %cmp, i1 true, i1 %cmp15
  br label %cleanup

cleanup:                                          ; preds = %if.end9, %cond.false, %entry
  %retval.0 = phi i1 [ false, %entry ], [ true, %cond.false ], [ %2, %if.end9 ]
  ret i1 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_port_wait_reset(%struct.usb_hub* %hub, i32 %port1, %struct.usb_device* %udev, i32 %delay, i1 zeroext %warm) #0 {
entry:
  %portstatus = alloca i16, align 2
  %portchange = alloca i16, align 2
  %ext_portstatus = alloca i32, align 4
  %frombool = zext i1 %warm to i8
  store i32 0, i32* %ext_portstatus, align 4, !tbaa !73
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %delay.addr.0 = phi i32 [ %delay, %entry ], [ %.delay.addr.0, %for.inc ]
  %delay_time.0 = phi i32 [ 0, %entry ], [ %add, %for.inc ]
  %cmp = icmp slt i32 %delay_time.0, 800
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @msleep(i32 %delay.addr.0)
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %call = call i32 @hub_is_superspeedplus(%struct.usb_device* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %call1 = call i32 @hub_ext_port_status(%struct.usb_hub* %hub, i32 %port1, i32 2, i16* %portstatus, i16* %portchange, i32* %ext_portstatus)
  br label %if.end

if.else:                                          ; preds = %for.body
  %call2 = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1, i16* %portstatus, i16* %portchange)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %ret.0 = phi i32 [ %call1, %if.then ], [ %call2, %if.else ]
  %cmp3 = icmp slt i32 %ret.0, 0
  br i1 %cmp3, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %1 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv = zext i16 %1 to i32
  %and = and i32 %conv, 16
  %tobool6 = icmp ne i32 %and, 0
  br i1 %tobool6, label %if.end11, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end5
  %2 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv7 = zext i16 %2 to i32
  %and8 = and i32 %conv7, 1
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %for.end, label %if.end11

if.end11:                                         ; preds = %land.lhs.true, %if.end5
  %cmp12 = icmp sge i32 %delay_time.0, 20
  %.delay.addr.0 = select i1 %cmp12, i32 200, i32 %delay.addr.0
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_wait_reset.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and17 = and i32 %bf.clear, 1
  %tobool18 = icmp ne i32 %and17, 0
  %lnot = xor i1 %tobool18, true
  %lnot19 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot19 to i32
  %conv20 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv20, i64 0)
  %tobool21 = icmp ne i64 %expval, 0
  br i1 %tobool21, label %if.then22, label %for.inc

if.then22:                                        ; preds = %if.end11
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %3 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %3, i64 %idxprom
  %4 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %dev = getelementptr inbounds %struct.usb_port, %struct.usb_port* %4, i32 0, i32 1
  %tobool23 = trunc i8 %frombool to i1
  %cond = select i1 %tobool23, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.144, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.28.900, i32 0, i32 0)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_wait_reset.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.151, i32 0, i32 0), i8* %cond, i32 %.delay.addr.0)
  br label %for.inc

for.inc:                                          ; preds = %if.then22, %if.end11
  %add = add i32 %delay_time.0, %.delay.addr.0
  br label %for.cond

for.end:                                          ; preds = %land.lhs.true, %for.cond
  %5 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv28 = zext i16 %5 to i32
  %and29 = and i32 %conv28, 16
  %tobool30 = icmp ne i32 %and29, 0
  br i1 %tobool30, label %cleanup, label %if.end32

if.end32:                                         ; preds = %for.end
  %6 = load i16, i16* %portstatus, align 2, !tbaa !165
  %call33 = call zeroext i1 @hub_port_warm_reset_required(%struct.usb_hub* %hub, i32 %port1, i16 zeroext %6)
  br i1 %call33, label %cleanup, label %if.end35

if.end35:                                         ; preds = %if.end32
  %7 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv36 = zext i16 %7 to i32
  %and37 = and i32 %conv36, 1
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %if.end40, label %cleanup

if.end40:                                         ; preds = %if.end35
  %hdev41 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %8 = load %struct.usb_device*, %struct.usb_device** %hdev41, align 8, !tbaa !176
  %call42 = call i32 @hub_is_superspeed(%struct.usb_device* %8)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.end49, label %land.lhs.true44

land.lhs.true44:                                  ; preds = %if.end40
  %9 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv45 = zext i16 %9 to i32
  %and46 = and i32 %conv45, 1
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %cleanup, label %if.end49

if.end49:                                         ; preds = %land.lhs.true44, %if.end40
  %10 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv50 = zext i16 %10 to i32
  %and51 = and i32 %conv50, 2
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %if.end54, label %cleanup

if.end54:                                         ; preds = %if.end49
  %tobool55 = icmp ne %struct.usb_device* %udev, null
  br i1 %tobool55, label %if.end57, label %cleanup

if.end57:                                         ; preds = %if.end54
  %call58 = call i32 @hub_is_wusb(%struct.usb_hub* %hub)
  %tobool59 = icmp ne i32 %call58, 0
  br i1 %tobool59, label %if.then60, label %if.else61

if.then60:                                        ; preds = %if.end57
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  store i32 4, i32* %speed, align 4, !tbaa !177
  br label %cleanup

if.else61:                                        ; preds = %if.end57
  %hdev62 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %11 = load %struct.usb_device*, %struct.usb_device** %hdev62, align 8, !tbaa !176
  %call63 = call i32 @hub_is_superspeedplus(%struct.usb_device* %11)
  %tobool64 = icmp ne i32 %call63, 0
  br i1 %tobool64, label %land.lhs.true65, label %if.else72

land.lhs.true65:                                  ; preds = %if.else61
  %hdev66 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %12 = load %struct.usb_device*, %struct.usb_device** %hdev66, align 8, !tbaa !176
  %13 = load i32, i32* %ext_portstatus, align 4, !tbaa !73
  %and67 = and i32 %13, 15
  %call68 = call i32 @port_speed_is_ssp(%struct.usb_device* %12, i32 %and67)
  %tobool69 = icmp ne i32 %call68, 0
  br i1 %tobool69, label %if.then70, label %if.else72

if.then70:                                        ; preds = %land.lhs.true65
  %speed71 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  store i32 6, i32* %speed71, align 4, !tbaa !177
  br label %cleanup

if.else72:                                        ; preds = %land.lhs.true65, %if.else61
  %hdev73 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %14 = load %struct.usb_device*, %struct.usb_device** %hdev73, align 8, !tbaa !176
  %call74 = call i32 @hub_is_superspeed(%struct.usb_device* %14)
  %tobool75 = icmp ne i32 %call74, 0
  br i1 %tobool75, label %if.then76, label %if.else78

if.then76:                                        ; preds = %if.else72
  %speed77 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  store i32 5, i32* %speed77, align 4, !tbaa !177
  br label %cleanup

if.else78:                                        ; preds = %if.else72
  %15 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv79 = zext i16 %15 to i32
  %and80 = and i32 %conv79, 1024
  %tobool81 = icmp ne i32 %and80, 0
  br i1 %tobool81, label %if.then82, label %if.else84

if.then82:                                        ; preds = %if.else78
  %speed83 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  store i32 3, i32* %speed83, align 4, !tbaa !177
  br label %cleanup

if.else84:                                        ; preds = %if.else78
  %16 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv85 = zext i16 %16 to i32
  %and86 = and i32 %conv85, 512
  %tobool87 = icmp ne i32 %and86, 0
  %speed89 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %.sink = select i1 %tobool87, i32 1, i32 2
  store i32 %.sink, i32* %speed89, align 4, !tbaa !177
  br label %cleanup

cleanup:                                          ; preds = %if.else84, %if.then82, %if.then76, %if.then70, %if.then60, %if.end54, %if.end49, %land.lhs.true44, %if.end35, %if.end32, %for.end, %if.end
  %retval.0 = phi i32 [ %ret.0, %if.end ], [ -16, %for.end ], [ -107, %if.end32 ], [ -107, %if.end35 ], [ -107, %land.lhs.true44 ], [ -16, %if.end49 ], [ 0, %if.end54 ], [ 0, %if.then70 ], [ 0, %if.then82 ], [ 0, %if.else84 ], [ 0, %if.then76 ], [ 0, %if.then60 ]
  ret i32 %retval.0
}

declare void @up_read(%struct.rw_semaphore*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hub_is_superspeedplus(%struct.usb_device* %hdev) #1 {
entry:
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 12
  %bDeviceProtocol = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 5
  %0 = load i8, i8* %bDeviceProtocol, align 2, !tbaa !205
  %conv = zext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %descriptor2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 12
  %bcdUSB = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor2, i32 0, i32 2
  %1 = load i16, i16* %bcdUSB, align 2, !tbaa !187
  %conv3 = zext i16 %1 to i32
  %cmp4 = icmp sge i32 %conv3, 784
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %bos = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 13
  %2 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos, align 8, !tbaa !166
  %ssp_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %2, i32 0, i32 3
  %3 = load %struct.usb_ssp_cap_descriptor*, %struct.usb_ssp_cap_descriptor** %ssp_cap, align 8, !tbaa !236
  %tobool = icmp ne %struct.usb_ssp_cap_descriptor* %3, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %4 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %tobool, %land.rhs ]
  %land.ext = zext i1 %4 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_ext_port_status(%struct.usb_hub* %hub, i32 %port1, i32 %type, i16* %status, i16* %change, i32* %ext_status) #0 {
entry:
  %cmp = icmp ne i32 %type, 0
  %. = select i1 %cmp, i32 8, i32 4
  %status_mutex = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 6
  call void @mutex_lock_nested(%struct.mutex* %status_mutex, i32 0)
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %status1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  %1 = load %union.anon.62*, %union.anon.62** %status1, align 8, !tbaa !237
  %port = bitcast %union.anon.62* %1 to %struct.usb_port_status*
  %2 = bitcast %struct.usb_port_status* %port to i8*
  %conv = trunc i32 %type to i16
  %conv2 = trunc i32 %. to i16
  %call = call i32 @get_port_status(%struct.usb_device* %0, i32 %port1, i8* %2, i16 zeroext %conv, i16 zeroext %conv2)
  %cmp3 = icmp slt i32 %call, %.
  br i1 %cmp3, label %if.then5, label %if.else

if.then5:                                         ; preds = %entry
  %cmp6 = icmp ne i32 %call, -19
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.then5
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.then5
  %cmp10 = icmp sge i32 %call, 0
  %.call = select i1 %cmp10, i32 -5, i32 %call
  br label %if.end24

if.else:                                          ; preds = %entry
  %status14 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  %3 = load %union.anon.62*, %union.anon.62** %status14, align 8, !tbaa !237
  %port15 = bitcast %union.anon.62* %3 to %struct.usb_port_status*
  %wPortStatus = getelementptr inbounds %struct.usb_port_status, %struct.usb_port_status* %port15, i32 0, i32 0
  %4 = load i16, i16* %wPortStatus, align 1, !tbaa !72
  store i16 %4, i16* %status, align 2, !tbaa !165
  %status16 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  %5 = load %union.anon.62*, %union.anon.62** %status16, align 8, !tbaa !237
  %port17 = bitcast %union.anon.62* %5 to %struct.usb_port_status*
  %wPortChange = getelementptr inbounds %struct.usb_port_status, %struct.usb_port_status* %port17, i32 0, i32 1
  %6 = load i16, i16* %wPortChange, align 1, !tbaa !72
  store i16 %6, i16* %change, align 2, !tbaa !165
  %cmp18 = icmp ne i32 %type, 0
  %tobool = icmp ne i32* %ext_status, null
  %or.cond = and i1 %cmp18, %tobool
  br i1 %or.cond, label %if.then20, label %if.end24

if.then20:                                        ; preds = %if.else
  %status21 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  %7 = load %union.anon.62*, %union.anon.62** %status21, align 8, !tbaa !237
  %port22 = bitcast %union.anon.62* %7 to %struct.usb_port_status*
  %dwExtPortStatus = getelementptr inbounds %struct.usb_port_status, %struct.usb_port_status* %port22, i32 0, i32 2
  %8 = load i32, i32* %dwExtPortStatus, align 1, !tbaa !72
  store i32 %8, i32* %ext_status, align 4, !tbaa !73
  br label %if.end24

if.end24:                                         ; preds = %if.then20, %if.else, %if.end9
  %ret.1 = phi i32 [ %.call, %if.end9 ], [ 0, %if.then20 ], [ 0, %if.else ]
  %status_mutex25 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 6
  call void @mutex_unlock(%struct.mutex* %status_mutex25)
  ret i32 %ret.1
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_is_wusb(%struct.usb_hub* %hub) #0 {
entry:
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  %1 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %cmp = icmp ne %struct.usb_device* %1, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !176
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 9
  %3 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %3)
  %wireless = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 12
  %bf.load = load i16, i16* %wireless, align 8
  %bf.lshr = lshr i16 %bf.load, 5
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %bf.cast, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @port_speed_is_ssp(%struct.usb_device* %hdev, i32 %speed_id) #0 {
entry:
  %bos = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 13
  %0 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos, align 8, !tbaa !166
  %ssp_cap1 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %0, i32 0, i32 3
  %1 = load %struct.usb_ssp_cap_descriptor*, %struct.usb_ssp_cap_descriptor** %ssp_cap1, align 8, !tbaa !236
  %tobool = icmp ne %struct.usb_ssp_cap_descriptor* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %bmAttributes = getelementptr inbounds %struct.usb_ssp_cap_descriptor, %struct.usb_ssp_cap_descriptor* %1, i32 0, i32 4
  %2 = load i32, i32* %bmAttributes, align 1, !tbaa !238
  %and = and i32 %2, 31
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %cmp = icmp sle i32 %i.0, %and
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %bmSublinkSpeedAttr = getelementptr inbounds %struct.usb_ssp_cap_descriptor, %struct.usb_ssp_cap_descriptor* %1, i32 0, i32 7
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [1 x i32], [1 x i32]* %bmSublinkSpeedAttr, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 1, !tbaa !73
  %and2 = and i32 %3, 15
  %cmp3 = icmp eq i32 %speed_id, %and2
  br i1 %cmp3, label %if.then4, label %for.inc

if.then4:                                         ; preds = %for.body
  %and5 = and i32 %3, 49152
  %tobool6 = icmp ne i32 %and5, 0
  %lnot = xor i1 %tobool6, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.then4, %for.cond, %entry
  %retval.0 = phi i32 [ %lnot.ext, %if.then4 ], [ 0, %entry ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @get_port_status(%struct.usb_device* %hdev, i32 %port1, i8* %data, i16 zeroext %value, i16 zeroext %length) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %status.0 = phi i32 [ -110, %entry ], [ %call4, %for.body ]
  %cmp = icmp slt i32 %i.0, 5
  br i1 %cmp, label %land.rhs, label %for.end

land.rhs:                                         ; preds = %for.cond
  %cmp1 = icmp eq i32 %status.0, -110
  %cmp2 = icmp eq i32 %status.0, -32
  %.cmp2 = select i1 %cmp1, i1 true, i1 %cmp2
  br i1 %.cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %land.rhs
  %call = call i32 @__create_pipe(%struct.usb_device* %hdev, i32 0)
  %or = or i32 -2147483648, %call
  %or3 = or i32 %or, 128
  %conv = trunc i32 %port1 to i16
  %call4 = call i32 @usb_control_msg(%struct.usb_device* %hdev, i32 %or3, i8 zeroext 0, i8 zeroext -93, i16 zeroext %value, i16 zeroext %conv, i8* %data, i16 zeroext %length, i32 1000)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %land.rhs, %for.cond
  ret i32 %status.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_disable_lpm(%struct.usb_device* %udev) #0 {
entry:
  %tobool = icmp ne %struct.usb_device* %udev, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool1 = icmp ne %struct.usb_device* %0, null
  br i1 %tobool1, label %lor.lhs.false2, label %cleanup

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %1 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp ult i32 %1, 5
  br i1 %cmp, label %cleanup, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false2
  %lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %lpm_capable, align 4
  %bf.lshr = lshr i16 %bf.load, 6
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool4 = icmp ne i32 %bf.cast, 0
  br i1 %tobool4, label %lor.lhs.false5, label %cleanup

lor.lhs.false5:                                   ; preds = %lor.lhs.false3
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %2 = load i32, i32* %state, align 8, !tbaa !54
  %cmp6 = icmp ult i32 %2, 5
  br i1 %cmp6, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false5
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %3 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %3)
  %tobool7 = icmp ne %struct.usb_hcd* %call, null
  br i1 %tobool7, label %lor.lhs.false8, label %cleanup

lor.lhs.false8:                                   ; preds = %if.end
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %4 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %disable_usb3_lpm_timeout = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %4, i32 0, i32 41
  %5 = load i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)** %disable_usb3_lpm_timeout, align 8, !tbaa !210
  %tobool9 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*, i32)* %5, null
  br i1 %tobool9, label %if.end11, label %cleanup

if.end11:                                         ; preds = %lor.lhs.false8
  %lpm_disable_count = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 40
  %6 = load i32, i32* %lpm_disable_count, align 8, !tbaa !71
  %inc = add i32 %6, 1
  store i32 %inc, i32* %lpm_disable_count, align 8, !tbaa !71
  %u1_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 38
  %timeout = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %u1_params, i32 0, i32 3
  %7 = load i32, i32* %timeout, align 4, !tbaa !240
  %cmp12 = icmp eq i32 %7, 0
  br i1 %cmp12, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %if.end11
  %u2_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 39
  %timeout13 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %u2_params, i32 0, i32 3
  %8 = load i32, i32* %timeout13, align 4, !tbaa !241
  %cmp14 = icmp eq i32 %8, 0
  br i1 %cmp14, label %cleanup, label %if.end16

if.end16:                                         ; preds = %land.lhs.true, %if.end11
  %call17 = call i32 @usb_disable_link_state(%struct.usb_hcd* %call, %struct.usb_device* %udev, i32 1)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %enable_lpm, label %if.end20

if.end20:                                         ; preds = %if.end16
  %call21 = call i32 @usb_disable_link_state(%struct.usb_hcd* %call, %struct.usb_device* %udev, i32 2)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %enable_lpm, label %cleanup

enable_lpm:                                       ; preds = %if.end20, %if.end16
  call void @usb_enable_lpm(%struct.usb_device* %udev)
  br label %cleanup

cleanup:                                          ; preds = %enable_lpm, %if.end20, %land.lhs.true, %lor.lhs.false8, %if.end, %lor.lhs.false5, %lor.lhs.false3, %lor.lhs.false2, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ -16, %enable_lpm ], [ 0, %lor.lhs.false5 ], [ 0, %lor.lhs.false3 ], [ 0, %lor.lhs.false2 ], [ 0, %lor.lhs.false ], [ 0, %entry ], [ 0, %lor.lhs.false8 ], [ 0, %if.end ], [ 0, %land.lhs.true ], [ 0, %if.end20 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_disable_link_state(%struct.usb_hcd* %hcd, %struct.usb_device* %udev, i32 %state) #0 {
entry:
  %.off = add i32 %state, -1
  %SwitchLeaf = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %entry
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %return

sw.epilog:                                        ; preds = %entry
  %call = call i32 @usb_set_lpm_timeout(%struct.usb_device* %udev, i32 %state, i32 0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %sw.epilog
  call void @usb_set_device_initiated_lpm(%struct.usb_device* %udev, i32 %state, i1 zeroext false)
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %hcd, i32 0, i32 8
  %0 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %disable_usb3_lpm_timeout = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %0, i32 0, i32 41
  %1 = load i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)** %disable_usb3_lpm_timeout, align 8, !tbaa !210
  %call2 = call i32 %1(%struct.usb_hcd* %hcd, %struct.usb_device* %udev, i32 %state)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end
  switch i32 %state, label %return [
    i32 1, label %if.then7
    i32 2, label %if.then9
  ]

if.then7:                                         ; preds = %if.end6
  %usb3_lpm_u1_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %usb3_lpm_u1_enabled, align 4
  %bf.clear = and i16 %bf.load, -2049
  store i16 %bf.clear, i16* %usb3_lpm_u1_enabled, align 4
  br label %return

if.then9:                                         ; preds = %if.end6
  %usb3_lpm_u2_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load10 = load i16, i16* %usb3_lpm_u2_enabled, align 4
  %bf.clear11 = and i16 %bf.load10, -4097
  store i16 %bf.clear11, i16* %usb3_lpm_u2_enabled, align 4
  br label %return

return:                                           ; preds = %if.then9, %if.then7, %if.end6, %sw.epilog, %sw.default
  %retval.0 = phi i32 [ -22, %sw.default ], [ -16, %sw.epilog ], [ 0, %if.then9 ], [ 0, %if.end6 ], [ 0, %if.then7 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_root_hub_lost_power(%struct.usb_device* %rhdev) #0 {
entry:
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %reset_resume = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 33
  %bf.load = load i8, i8* %reset_resume, align 8
  %bf.clear = and i8 %bf.load, -3
  %bf.set = or i8 %bf.clear, 2
  store i8 %bf.set, i8* %reset_resume, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_hub_release_port(%struct.usb_device* %hdev, i32 %port1, %struct.usb_dev_state* %owner) #0 {
entry:
  %powner = alloca %struct.usb_dev_state**, align 8
  %call = call i32 @find_port_owner(%struct.usb_device* %hdev, i32 %port1, %struct.usb_dev_state*** %powner)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %0 = load %struct.usb_dev_state**, %struct.usb_dev_state*** %powner, align 8, !tbaa !52
  %1 = load %struct.usb_dev_state*, %struct.usb_dev_state** %0, align 8, !tbaa !52
  %cmp = icmp ne %struct.usb_dev_state* %1, %owner
  br i1 %cmp, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %2 = load %struct.usb_dev_state**, %struct.usb_dev_state*** %powner, align 8, !tbaa !52
  store %struct.usb_dev_state* null, %struct.usb_dev_state** %2, align 8, !tbaa !52
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i32 [ %call, %if.end2 ], [ %call, %entry ], [ -2, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @find_port_owner(%struct.usb_device* %hdev, i32 %port1, %struct.usb_dev_state*** %ppowner) #0 {
entry:
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp eq i32 %port1, 0
  br i1 %cmp1, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 28
  %1 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp2 = icmp ugt i32 %port1, %1
  br i1 %cmp2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %lor.lhs.false
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %2 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub i32 %port1, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %2, i64 %idxprom
  %3 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %port_owner = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 2
  store %struct.usb_dev_state** %port_owner, %struct.usb_dev_state*** %ppowner, align 8, !tbaa !52
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %lor.lhs.false, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end4 ], [ -19, %entry ], [ -22, %lor.lhs.false ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_hub_claim_port(%struct.usb_device* %hdev, i32 %port1, %struct.usb_dev_state* %owner) #0 {
entry:
  %powner = alloca %struct.usb_dev_state**, align 8
  %call = call i32 @find_port_owner(%struct.usb_device* %hdev, i32 %port1, %struct.usb_dev_state*** %powner)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %0 = load %struct.usb_dev_state**, %struct.usb_dev_state*** %powner, align 8, !tbaa !52
  %1 = load %struct.usb_dev_state*, %struct.usb_dev_state** %0, align 8, !tbaa !52
  %tobool1 = icmp ne %struct.usb_dev_state* %1, null
  br i1 %tobool1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %2 = load %struct.usb_dev_state**, %struct.usb_dev_state*** %powner, align 8, !tbaa !52
  store %struct.usb_dev_state* %owner, %struct.usb_dev_state** %2, align 8, !tbaa !52
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry
  %retval.0 = phi i32 [ %call, %if.end3 ], [ %call, %entry ], [ -16, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_hub_clear_tt_buffer(%struct.urb* %urb) #0 {
entry:
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !242
  %pipe1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 10
  %1 = load i32, i32* %pipe1, align 8, !tbaa !244
  %tt2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 5
  %2 = load %struct.usb_tt*, %struct.usb_tt** %tt2, align 8, !tbaa !181
  %call.i = call noalias i8* @__kmalloc(i64 40, i32 17301536) #8
  %3 = bitcast i8* %call.i to %struct.usb_tt_clear*
  %cmp = icmp eq %struct.usb_tt_clear* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  %multi = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %2, i32 0, i32 1
  %4 = load i32, i32* %multi, align 8, !tbaa !245
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end
  %ttport = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 6
  %5 = load i32, i32* %ttport, align 8, !tbaa !182
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.end
  %cond = phi i32 [ %5, %cond.true ], [ 1, %if.end ]
  %tt4 = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %3, i32 0, i32 1
  store i32 %cond, i32* %tt4, align 8, !tbaa !246
  %shr = ashr i32 %1, 15
  %and = and i32 %shr, 15
  %conv = trunc i32 %and to i16
  %devinfo = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %3, i32 0, i32 2
  store i16 %conv, i16* %devinfo, align 4, !tbaa !248
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 0
  %6 = load i32, i32* %devnum, align 8, !tbaa !44
  %shl = shl i32 %6, 4
  %devinfo5 = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %3, i32 0, i32 2
  %7 = load i16, i16* %devinfo5, align 4, !tbaa !248
  %conv6 = zext i16 %7 to i32
  %or = or i32 %conv6, %shl
  %conv7 = trunc i32 %or to i16
  store i16 %conv7, i16* %devinfo5, align 4, !tbaa !248
  %shr8 = ashr i32 %1, 30
  %and9 = and i32 %shr8, 3
  %cmp10 = icmp eq i32 %and9, 2
  %cond12 = select i1 %cmp10, i32 0, i32 4096
  %devinfo13 = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %3, i32 0, i32 2
  %8 = load i16, i16* %devinfo13, align 4, !tbaa !248
  %conv14 = zext i16 %8 to i32
  %or15 = or i32 %conv14, %cond12
  %conv16 = trunc i32 %or15 to i16
  store i16 %conv16, i16* %devinfo13, align 4, !tbaa !248
  %and17 = and i32 %1, 128
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then19, label %if.end24

if.then19:                                        ; preds = %cond.end
  %devinfo20 = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %3, i32 0, i32 2
  %9 = load i16, i16* %devinfo20, align 4, !tbaa !248
  %conv21 = zext i16 %9 to i32
  %or22 = or i32 %conv21, 32768
  %conv23 = trunc i32 %or22 to i16
  store i16 %conv23, i16* %devinfo20, align 4, !tbaa !248
  br label %if.end24

if.end24:                                         ; preds = %if.then19, %cond.end
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %10 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call25 = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %10)
  %hcd = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %3, i32 0, i32 3
  store %struct.usb_hcd* %call25, %struct.usb_hcd** %hcd, align 8, !tbaa !249
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %11 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !250
  %ep26 = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %3, i32 0, i32 4
  store %struct.usb_host_endpoint* %11, %struct.usb_host_endpoint** %ep26, align 8, !tbaa !251
  %lock = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %2, i32 0, i32 4
  %12 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %12 to %struct.raw_spinlock*
  %call31 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %clear_list = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %3, i32 0, i32 0
  %clear_list34 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %2, i32 0, i32 5
  call void @list_add_tail(%struct.list_head* %clear_list, %struct.list_head* %clear_list34)
  %clear_work = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %2, i32 0, i32 6
  %call35 = call zeroext i1 @schedule_work(%struct.work_struct* %clear_work)
  %lock36 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %2, i32 0, i32 4
  %13 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock36, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %13 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call31) #8
  br label %cleanup

cleanup:                                          ; preds = %if.end24, %if.then
  %retval.0 = phi i32 [ -12, %if.then ], [ 0, %if.end24 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #1 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !87
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !87
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !252
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !87
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !72
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare zeroext i1 @__list_add_valid(%struct.list_head*, %struct.list_head*, %struct.list_head*) #2

; Function Attrs: nounwind uwtable
define void @usb_wakeup_notification(%struct.usb_device* %hdev, i32 %portnum) #0 {
entry:
  %tobool = icmp ne %struct.usb_device* %hdev, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  %tobool1 = icmp ne %struct.usb_hub* %call, null
  br i1 %tobool1, label %if.then2, label %cleanup.cont

if.then2:                                         ; preds = %if.end
  %conv = zext i32 %portnum to i64
  %wakeup_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 12
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %wakeup_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i64 %conv, i64* %arraydecay) #8, !srcloc !201
  call void @kick_hub_wq(%struct.usb_hub* %call)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then2, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_kick_hub_wq(%struct.usb_device* %hdev) #0 {
entry:
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  %tobool = icmp ne %struct.usb_hub* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @kick_hub_wq(%struct.usb_hub* %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_hub_set_port_power(%struct.usb_device* %hdev, %struct.usb_hub* %hub, i32 %port1, i1 zeroext %set) #0 {
entry:
  %frombool = zext i1 %set to i8
  %tobool = trunc i8 %frombool to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i32 @set_port_feature(%struct.usb_device* %hdev, i32 %port1, i32 8)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 @usb_clear_port_feature(%struct.usb_device* %hdev, i32 %port1, i32 8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %ret.0 = phi i32 [ %call, %if.then ], [ %call1, %if.else ]
  %tobool2 = icmp ne i32 %ret.0, 0
  br i1 %tobool2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %tobool5 = trunc i8 %frombool to i1
  %conv = sext i32 %port1 to i64
  %power_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 13
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %power_bits, i32 0, i32 0
  br i1 %tobool5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.end4
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i64 %conv, i64* %arraydecay) #8, !srcloc !201
  br label %cleanup

if.else7:                                         ; preds = %if.end4
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i64 %conv, i64* %arraydecay) #8, !srcloc !222
  br label %cleanup

cleanup:                                          ; preds = %if.else7, %if.then6, %if.end
  %retval.0 = phi i32 [ %ret.0, %if.end ], [ 0, %if.else7 ], [ 0, %if.then6 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_remove_device(%struct.usb_device* %udev) #0 {
entry:
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool = icmp ne %struct.usb_device* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %parent1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %1 = load %struct.usb_device*, %struct.usb_device** %parent1, align 8, !tbaa !79
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %1)
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 0
  %2 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !204
  %3 = bitcast %struct.device* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -48
  %4 = bitcast i8* %add.ptr to %struct.usb_interface*
  %call2 = call i32 @usb_autopm_get_interface(%struct.usb_interface* %4)
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %5 = load i8, i8* %portnum, align 2, !tbaa !81
  %conv = zext i8 %5 to i64
  %removed_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 11
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %removed_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i64 %conv, i64* %arraydecay) #8, !srcloc !201
  %portnum3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %6 = load i8, i8* %portnum3, align 2, !tbaa !81
  %conv4 = zext i8 %6 to i32
  call void @hub_port_logical_disconnect(%struct.usb_hub* %call, i32 %conv4)
  call void @usb_autopm_put_interface(%struct.usb_interface* %4)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_hub_release_all_ports(%struct.usb_device* %hdev, %struct.usb_dev_state* %owner) #0 {
entry:
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %n.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 28
  %0 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp = icmp slt i32 %n.0, %0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %1 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %idxprom = sext i32 %n.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %1, i64 %idxprom
  %2 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %port_owner = getelementptr inbounds %struct.usb_port, %struct.usb_port* %2, i32 0, i32 2
  %3 = load %struct.usb_dev_state*, %struct.usb_dev_state** %port_owner, align 8, !tbaa !253
  %cmp1 = icmp eq %struct.usb_dev_state* %3, %owner
  br i1 %cmp1, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %ports2 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %4 = load %struct.usb_port**, %struct.usb_port*** %ports2, align 8, !tbaa !112
  %idxprom3 = sext i32 %n.0 to i64
  %arrayidx4 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %4, i64 %idxprom3
  %5 = load %struct.usb_port*, %struct.usb_port** %arrayidx4, align 8, !tbaa !52
  %port_owner5 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %5, i32 0, i32 2
  store %struct.usb_dev_state* null, %struct.usb_dev_state** %port_owner5, align 8, !tbaa !253
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %inc = add nsw i32 %n.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define zeroext i1 @usb_device_is_owned(%struct.usb_device* %udev) #0 {
entry:
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %1 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool = icmp ne %struct.usb_device* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %parent1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %2 = load %struct.usb_device*, %struct.usb_device** %parent1, align 8, !tbaa !79
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %2)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %3 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %4 = load i8, i8* %portnum, align 2, !tbaa !81
  %conv = zext i8 %4 to i32
  %sub = sub nsw i32 %conv, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %3, i64 %idxprom
  %5 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %port_owner = getelementptr inbounds %struct.usb_port, %struct.usb_port* %5, i32 0, i32 2
  %6 = load %struct.usb_dev_state*, %struct.usb_dev_state** %port_owner, align 8, !tbaa !253
  %tobool2 = icmp ne %struct.usb_dev_state* %6, null
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  br label %cleanup

cleanup:                                          ; preds = %if.end, %lor.lhs.false, %entry
  %retval.0 = phi i1 [ %lnot3, %if.end ], [ false, %lor.lhs.false ], [ false, %entry ]
  ret i1 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_disconnect(%struct.usb_device** %pdev) #0 {
entry:
  %c.i1 = alloca i8, align 1
  %c.i = alloca i8, align 1
  %0 = load %struct.usb_device*, %struct.usb_device** %pdev, align 8, !tbaa !52
  call void @usb_set_device_state(%struct.usb_device* %0, i32 0)
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock(%struct.device* %dev1)
  call void @hub_disconnect_children(%struct.usb_device* %0)
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_disconnect.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %do.end7

if.then:                                          ; preds = %entry
  %dev5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_disconnect.descriptor to %struct._ddebug*), %struct.device* %dev5, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.11.29, i32 0, i32 0))
  br label %do.end7

do.end7:                                          ; preds = %if.then, %entry
  call void @usb_disable_device(%struct.usb_device* %0, i32 0)
  call void @usb_hcd_synchronize_unlinks(%struct.usb_device* undef)
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  %1 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool8 = icmp ne %struct.usb_device* %1, null
  br i1 %tobool8, label %if.then9, label %if.end21

if.then9:                                         ; preds = %do.end7
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 20
  %2 = load i8, i8* %portnum, align 2, !tbaa !81
  %conv10 = zext i8 %2 to i32
  %parent11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  %3 = load %struct.usb_device*, %struct.usb_device** %parent11, align 8, !tbaa !79
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %3)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %4 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %conv10, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %4, i64 %idxprom
  %5 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %dev12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev12, i32 0, i32 2
  call void @sysfs_remove_link(%struct.kobject* %kobj, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12.30, i32 0, i32 0))
  %dev13 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %5, i32 0, i32 1
  %kobj14 = getelementptr inbounds %struct.device, %struct.device* %dev13, i32 0, i32 2
  call void @sysfs_remove_link(%struct.kobject* %kobj14, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.13.31, i32 0, i32 0))
  %conv15 = sext i32 %conv10 to i64
  %child_usage_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 14
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %child_usage_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $2, $0;\0A\09setc $1\0A", "=*m,=*qm,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i8* %c.i, i64 %conv15, i64* %arraydecay) #8, !srcloc !254
  %6 = load i8, i8* %c.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %6 to i1
  br i1 %tobool.i, label %if.end21, label %if.then17

if.then17:                                        ; preds = %if.then9
  %dev18 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %5, i32 0, i32 1
  %call19 = call i32 @pm_runtime_get_sync(%struct.device* %dev18)
  br label %if.end21

if.end21:                                         ; preds = %if.then17, %if.then9, %do.end7
  %hub.0 = phi %struct.usb_hub* [ null, %do.end7 ], [ %call, %if.then17 ], [ %call, %if.then9 ]
  %port_dev.0 = phi %struct.usb_port* [ null, %do.end7 ], [ %5, %if.then17 ], [ %5, %if.then9 ]
  %port1.0 = phi i32 [ 1, %do.end7 ], [ %conv10, %if.then17 ], [ %conv10, %if.then9 ]
  %ep0 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 10
  call void @usb_remove_ep_devs(%struct.usb_host_endpoint* %ep0)
  %dev22 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev22)
  %dev23 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_del(%struct.device* %dev23)
  call void @release_devnum(%struct.usb_device* %0)
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @device_state_lock, i32 0, i32 0, i32 0)) #8
  store %struct.usb_device* null, %struct.usb_device** %pdev, align 8, !tbaa !52
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @device_state_lock, i32 0, i32 0, i32 0)) #8
  %tobool24 = icmp ne %struct.usb_port* %port_dev.0, null
  br i1 %tobool24, label %land.lhs.true, label %if.end33

land.lhs.true:                                    ; preds = %if.end21
  %conv25 = sext i32 %port1.0 to i64
  %child_usage_bits26 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub.0, i32 0, i32 14
  %arraydecay27 = getelementptr inbounds [1 x i64], [1 x i64]* %child_usage_bits26, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2, $0;\0A\09setc $1\0A", "=*m,=*qm,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay27, i8* %c.i1, i64 %conv25, i64* %arraydecay27) #8, !srcloc !255
  %7 = load i8, i8* %c.i1, align 1, !tbaa !109, !range !110
  %tobool.i2 = trunc i8 %7 to i1
  br i1 %tobool.i2, label %if.then30, label %if.end33

if.then30:                                        ; preds = %land.lhs.true
  %dev31 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %port_dev.0, i32 0, i32 1
  call void @pm_runtime_put(%struct.device* %dev31)
  br label %if.end33

if.end33:                                         ; preds = %if.then30, %land.lhs.true, %if.end21
  call void @hub_free_dev(%struct.usb_device* %0)
  %dev34 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @put_device(%struct.device* %dev34)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_disconnect_children(%struct.usb_device* %udev) #0 {
entry:
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %udev)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 28
  %0 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp = icmp slt i32 %i.0, %0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %1 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %1, i64 %idxprom
  %2 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %2, i32 0, i32 0
  %3 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !115
  %tobool = icmp ne %struct.usb_device* %3, null
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %ports1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %4 = load %struct.usb_port**, %struct.usb_port*** %ports1, align 8, !tbaa !112
  %idxprom2 = sext i32 %i.0 to i64
  %arrayidx3 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %4, i64 %idxprom2
  %5 = load %struct.usb_port*, %struct.usb_port** %arrayidx3, align 8, !tbaa !52
  %child4 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %5, i32 0, i32 0
  call void @usb_disconnect(%struct.usb_device** %child4)
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @sysfs_remove_link(%struct.kobject*, i8*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pm_runtime_get_sync(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_resume(%struct.device* %dev, i32 4)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

declare void @device_del(%struct.device*) #2

; Function Attrs: nounwind uwtable
define internal void @release_devnum(%struct.usb_device* %udev) #0 {
entry:
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  %0 = load i32, i32* %devnum, align 8, !tbaa !44
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %devnum1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  %1 = load i32, i32* %devnum1, align 8, !tbaa !44
  %conv = sext i32 %1 to i64
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %devmap = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %2, i32 0, i32 10
  %devicemap = getelementptr inbounds %struct.usb_devmap, %struct.usb_devmap* %devmap, i32 0, i32 0
  %arraydecay = getelementptr inbounds [2 x i64], [2 x i64]* %devicemap, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i64 %conv, i64* %arraydecay) #8, !srcloc !222
  %devnum2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  store i32 -1, i32* %devnum2, align 8, !tbaa !44
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_idle(%struct.device* %dev, i32 5)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_free_dev(%struct.usb_device* %udev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %0)
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %1 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %free_dev = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 27
  %2 = load void (%struct.usb_hcd*, %struct.usb_device*)*, void (%struct.usb_hcd*, %struct.usb_device*)** %free_dev, align 8, !tbaa !256
  %tobool = icmp ne void (%struct.usb_hcd*, %struct.usb_device*)* %2, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %3 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool1 = icmp ne %struct.usb_device* %3, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %driver2 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %4 = load %struct.hc_driver*, %struct.hc_driver** %driver2, align 8, !tbaa !57
  %free_dev3 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %4, i32 0, i32 27
  %5 = load void (%struct.usb_hcd*, %struct.usb_device*)*, void (%struct.usb_hcd*, %struct.usb_device*)** %free_dev3, align 8, !tbaa !256
  call void %5(%struct.usb_hcd* %call, %struct.usb_device* %udev)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

declare i32 @__pm_runtime_idle(%struct.device*, i32) #2

declare void @_raw_spin_unlock_irq(%struct.raw_spinlock*) #2 section ".spinlock.text"

declare void @_raw_spin_lock_irq(%struct.raw_spinlock*) #2 section ".spinlock.text"

declare i32 @__pm_runtime_resume(%struct.device*, i32) #2

; Function Attrs: nounwind uwtable
define i32 @usb_new_device(%struct.usb_device* %udev) #0 {
entry:
  %c.i = alloca i8, align 1
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool = icmp ne %struct.usb_device* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call = call i32 @device_init_wakeup(%struct.device* %dev, i1 zeroext false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_set_active(%struct.device* %dev1)
  %dev3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_get_noresume(%struct.device* %dev3)
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_use_autosuspend(%struct.device* %dev4)
  %dev5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_enable(%struct.device* %dev5)
  call void @usb_disable_autosuspend(%struct.usb_device* %udev)
  %call6 = call i32 @usb_enumerate_device(%struct.usb_device* %udev)
  %cmp = icmp slt i32 %call6, 0
  br i1 %cmp, label %fail, label %do.body9

do.body9:                                         ; preds = %if.end
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_new_device.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool10 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.then13, label %do.end21

if.then13:                                        ; preds = %do.body9
  %dev14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  %1 = load i32, i32* %devnum, align 8, !tbaa !44
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %busnum = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %2, i32 0, i32 1
  %3 = load i32, i32* %busnum, align 8, !tbaa !41
  %bus15 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %4 = load %struct.usb_bus*, %struct.usb_bus** %bus15, align 8, !tbaa !2
  %busnum16 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %4, i32 0, i32 1
  %5 = load i32, i32* %busnum16, align 8, !tbaa !41
  %sub = sub nsw i32 %5, 1
  %mul = mul nsw i32 %sub, 128
  %devnum17 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  %6 = load i32, i32* %devnum17, align 8, !tbaa !44
  %sub18 = sub nsw i32 %6, 1
  %add = add nsw i32 %mul, %sub18
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_new_device.descriptor to %struct._ddebug*), %struct.device* %dev14, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.14.32, i32 0, i32 0), i32 %1, i32 %3, i32 %add)
  br label %do.end21

do.end21:                                         ; preds = %if.then13, %do.body9
  %bus22 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %7 = load %struct.usb_bus*, %struct.usb_bus** %bus22, align 8, !tbaa !2
  %busnum23 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %7, i32 0, i32 1
  %8 = load i32, i32* %busnum23, align 8, !tbaa !41
  %sub24 = sub nsw i32 %8, 1
  %mul25 = mul nsw i32 %sub24, 128
  %devnum26 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  %9 = load i32, i32* %devnum26, align 8, !tbaa !44
  %sub27 = sub nsw i32 %9, 1
  %add28 = add nsw i32 %mul25, %sub27
  %or = or i32 198180864, %add28
  %dev29 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %devt = getelementptr inbounds %struct.device, %struct.device* %dev29, i32 0, i32 28
  store i32 %or, i32* %devt, align 8, !tbaa !257
  call void @announce_device(%struct.usb_device* %udev)
  %serial = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 26
  %10 = load i8*, i8** %serial, align 8, !tbaa !47
  %tobool30 = icmp ne i8* %10, null
  br i1 %tobool30, label %if.then31, label %if.end36

if.then31:                                        ; preds = %do.end21
  %serial32 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 26
  %11 = load i8*, i8** %serial32, align 8, !tbaa !47
  %serial33 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 26
  %12 = load i8*, i8** %serial33, align 8, !tbaa !47
  %call34 = call i64 @strlen(i8* %12)
  %conv35 = trunc i64 %call34 to i32
  call void @add_device_randomness(i8* %11, i32 %conv35)
  br label %if.end36

if.end36:                                         ; preds = %if.then31, %do.end21
  %product = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 24
  %13 = load i8*, i8** %product, align 8, !tbaa !45
  %tobool37 = icmp ne i8* %13, null
  br i1 %tobool37, label %if.then38, label %if.end43

if.then38:                                        ; preds = %if.end36
  %product39 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 24
  %14 = load i8*, i8** %product39, align 8, !tbaa !45
  %product40 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 24
  %15 = load i8*, i8** %product40, align 8, !tbaa !45
  %call41 = call i64 @strlen(i8* %15)
  %conv42 = trunc i64 %call41 to i32
  call void @add_device_randomness(i8* %14, i32 %conv42)
  br label %if.end43

if.end43:                                         ; preds = %if.then38, %if.end36
  %manufacturer = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 25
  %16 = load i8*, i8** %manufacturer, align 8, !tbaa !46
  %tobool44 = icmp ne i8* %16, null
  br i1 %tobool44, label %if.then45, label %if.end50

if.then45:                                        ; preds = %if.end43
  %manufacturer46 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 25
  %17 = load i8*, i8** %manufacturer46, align 8, !tbaa !46
  %manufacturer47 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 25
  %18 = load i8*, i8** %manufacturer47, align 8, !tbaa !46
  %call48 = call i64 @strlen(i8* %18)
  %conv49 = trunc i64 %call48 to i32
  call void @add_device_randomness(i8* %17, i32 %conv49)
  br label %if.end50

if.end50:                                         ; preds = %if.then45, %if.end43
  %dev51 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @device_enable_async_suspend(%struct.device* %dev51)
  %parent52 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %19 = load %struct.usb_device*, %struct.usb_device** %parent52, align 8, !tbaa !79
  %tobool53 = icmp ne %struct.usb_device* %19, null
  br i1 %tobool53, label %if.then54, label %if.end55

if.then54:                                        ; preds = %if.end50
  call void @set_usb_port_removable(%struct.usb_device* %udev)
  br label %if.end55

if.end55:                                         ; preds = %if.then54, %if.end50
  %dev56 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call57 = call i32 @device_add(%struct.device* %dev56)
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.then59, label %if.end61

if.then59:                                        ; preds = %if.end55
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %fail

if.end61:                                         ; preds = %if.end55
  %parent62 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %20 = load %struct.usb_device*, %struct.usb_device** %parent62, align 8, !tbaa !79
  %tobool63 = icmp ne %struct.usb_device* %20, null
  br i1 %tobool63, label %if.then64, label %if.end94

if.then64:                                        ; preds = %if.end61
  %parent65 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %21 = load %struct.usb_device*, %struct.usb_device** %parent65, align 8, !tbaa !79
  %call66 = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %21)
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %22 = load i8, i8* %portnum, align 2, !tbaa !81
  %conv67 = zext i8 %22 to i32
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call66, i32 0, i32 25
  %23 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub68 = sub nsw i32 %conv67, 1
  %idxprom = sext i32 %sub68 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %23, i64 %idxprom
  %24 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %dev69 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev69, i32 0, i32 2
  %dev70 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %24, i32 0, i32 1
  %kobj71 = getelementptr inbounds %struct.device, %struct.device* %dev70, i32 0, i32 2
  %call72 = call i32 @sysfs_create_link(%struct.kobject* %kobj, %struct.kobject* %kobj71, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12.30, i32 0, i32 0))
  %tobool73 = icmp ne i32 %call72, 0
  br i1 %tobool73, label %NodeBlock, label %if.end75

if.end75:                                         ; preds = %if.then64
  %dev76 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %24, i32 0, i32 1
  %kobj77 = getelementptr inbounds %struct.device, %struct.device* %dev76, i32 0, i32 2
  %dev78 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %kobj79 = getelementptr inbounds %struct.device, %struct.device* %dev78, i32 0, i32 2
  %call80 = call i32 @sysfs_create_link(%struct.kobject* %kobj77, %struct.kobject* %kobj79, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.13.31, i32 0, i32 0))
  %tobool81 = icmp ne i32 %call80, 0
  br i1 %tobool81, label %if.then82, label %if.end85

if.then82:                                        ; preds = %if.end75
  %dev83 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %kobj84 = getelementptr inbounds %struct.device, %struct.device* %dev83, i32 0, i32 2
  call void @sysfs_remove_link(%struct.kobject* %kobj84, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12.30, i32 0, i32 0))
  br label %NodeBlock

if.end85:                                         ; preds = %if.end75
  %conv86 = sext i32 %conv67 to i64
  %child_usage_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call66, i32 0, i32 14
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %child_usage_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $2, $0;\0A\09setc $1\0A", "=*m,=*qm,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i8* %c.i, i64 %conv86, i64* %arraydecay) #8, !srcloc !254
  %25 = load i8, i8* %c.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %25 to i1
  br i1 %tobool.i, label %NodeBlock, label %if.then88

if.then88:                                        ; preds = %if.end85
  %dev89 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %24, i32 0, i32 1
  %call90 = call i32 @pm_runtime_get_sync(%struct.device* %dev89)
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.then88, %if.end85, %if.then82, %if.then64
  %err.0 = phi i32 [ %call80, %if.then82 ], [ %call72, %if.then64 ], [ %call80, %if.then88 ], [ %call80, %if.end85 ]
  %cleanup.dest.slot.0 = phi i32 [ 2, %if.then82 ], [ 2, %if.then64 ], [ 0, %if.then88 ], [ 0, %if.end85 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf2, label %fail, label %cleanup102

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end94, label %cleanup102

if.end94:                                         ; preds = %LeafBlock, %if.end61
  %err.1 = phi i32 [ %call57, %if.end61 ], [ %err.0, %LeafBlock ]
  %dev95 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %ep0 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 10
  %call96 = call i32 bitcast (i32 (%struct.device.3441*, %struct.usb_host_endpoint*, %struct.usb_device.3478*)* @usb_create_ep_devs to i32 (%struct.device*, %struct.usb_host_endpoint*, %struct.usb_device*)*)(%struct.device* %dev95, %struct.usb_host_endpoint* %ep0, %struct.usb_device* %udev)
  call void @usb_mark_last_busy(%struct.usb_device* %udev)
  %dev97 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_put_sync_autosuspend(%struct.device* %dev97)
  br label %cleanup102

fail:                                             ; preds = %LeafBlock1, %if.then59, %if.end
  %err.2 = phi i32 [ %call57, %if.then59 ], [ %err.0, %LeafBlock1 ], [ %call6, %if.end ]
  call void @usb_set_device_state(%struct.usb_device* %udev, i32 0)
  %dev99 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_disable(%struct.device* %dev99)
  %dev100 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_set_suspended(%struct.device* %dev100)
  br label %cleanup102

cleanup102:                                       ; preds = %fail, %if.end94, %LeafBlock, %LeafBlock1
  %retval.0 = phi i32 [ %err.2, %fail ], [ %err.1, %if.end94 ], [ undef, %LeafBlock1 ], [ undef, %LeafBlock ]
  ret i32 %retval.0
}

declare i32 @device_init_wakeup(%struct.device*, i1 zeroext) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_set_active(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_set_status(%struct.device* %dev, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_get_noresume(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %usage_count = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 12
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %usage_count, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !258
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_use_autosuspend(%struct.device* %dev) #1 {
entry:
  call void @__pm_runtime_use_autosuspend(%struct.device* %dev, i1 zeroext true)
  ret void
}

declare void @pm_runtime_enable(%struct.device*) #2

; Function Attrs: nounwind uwtable
define internal i32 @usb_enumerate_device(%struct.usb_device* %udev) #0 {
entry:
  %.compoundliteral = alloca %struct.atomic_t, align 4
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %0)
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 14
  %1 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !194
  %cmp = icmp eq %struct.usb_host_config* %1, null
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %call1 = call i32 @usb_get_configuration(%struct.usb_device* %udev)
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.then
  %cmp4 = icmp ne i32 %call1, -19
  br i1 %cmp4, label %if.then5, label %cleanup

if.then5:                                         ; preds = %if.then3
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end7:                                          ; preds = %if.then, %entry
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %iProduct = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 11
  %2 = load i8, i8* %iProduct, align 1, !tbaa !259
  %conv = zext i8 %2 to i32
  %call8 = call i8* @usb_cache_string(%struct.usb_device* %udev, i32 %conv)
  %product = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 24
  store i8* %call8, i8** %product, align 8, !tbaa !45
  %descriptor9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %iManufacturer = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor9, i32 0, i32 10
  %3 = load i8, i8* %iManufacturer, align 2, !tbaa !260
  %conv10 = zext i8 %3 to i32
  %call11 = call i8* @usb_cache_string(%struct.usb_device* %udev, i32 %conv10)
  %manufacturer = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 25
  store i8* %call11, i8** %manufacturer, align 8, !tbaa !46
  %descriptor12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %iSerialNumber = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor12, i32 0, i32 12
  %4 = load i8, i8* %iSerialNumber, align 8, !tbaa !198
  %conv13 = zext i8 %4 to i32
  %call14 = call i8* @usb_cache_string(%struct.usb_device* %udev, i32 %conv13)
  %serial = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 26
  store i8* %call14, i8** %serial, align 8, !tbaa !47
  %call15 = call i32 @usb_enumerate_device_otg(%struct.usb_device* %udev)
  %cmp16 = icmp slt i32 %call15, 0
  br i1 %cmp16, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end7
  %tpl_support = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 12
  %bf.load = load i16, i16* %tpl_support, align 8
  %bf.lshr = lshr i16 %bf.load, 9
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %land.lhs.true, label %if.end54

land.lhs.true:                                    ; preds = %if.end19
  %call20 = call i32 @is_targeted(%struct.usb_device* %udev)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.end54, label %if.then22

if.then22:                                        ; preds = %land.lhs.true
  %bus23 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %5 = load %struct.usb_bus*, %struct.usb_bus** %bus23, align 8, !tbaa !2
  %b_hnp_enable = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %5, i32 0, i32 6
  %bf.load24 = load i8, i8* %b_hnp_enable, align 1
  %bf.lshr25 = lshr i8 %bf.load24, 1
  %bf.clear26 = and i8 %bf.lshr25, 1
  %bf.cast27 = zext i8 %bf.clear26 to i32
  %tobool28 = icmp ne i32 %bf.cast27, 0
  br i1 %tobool28, label %if.then34, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then22
  %bus29 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %6 = load %struct.usb_bus*, %struct.usb_bus** %bus29, align 8, !tbaa !2
  %is_b_host = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %6, i32 0, i32 6
  %bf.load30 = load i8, i8* %is_b_host, align 1
  %bf.clear31 = and i8 %bf.load30, 1
  %bf.cast32 = zext i8 %bf.clear31 to i32
  %tobool33 = icmp ne i32 %bf.cast32, 0
  br i1 %tobool33, label %if.then34, label %cleanup

if.then34:                                        ; preds = %lor.lhs.false, %if.then22
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  store i32 1026, i32* %event, align 4, !tbaa !48
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  %7 = load i32, i32* %coerce.dive, align 4
  %call35 = call i32 @usb_port_suspend(%struct.usb_device* %udev, i32 %7)
  %cmp36 = icmp slt i32 %call35, 0
  br i1 %cmp36, label %do.body39, label %cleanup

do.body39:                                        ; preds = %if.then34
  %bf.load40 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_enumerate_device.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr41 = lshr i32 %bf.load40, 18
  %bf.clear42 = and i32 %bf.lshr41, 255
  %and = and i32 %bf.clear42, 1
  %tobool43 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool43, true
  %lnot44 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot44 to i32
  %conv45 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv45, i64 0)
  %tobool46 = icmp ne i64 %expval, 0
  br i1 %tobool46, label %if.then47, label %cleanup

if.then47:                                        ; preds = %do.body39
  %dev48 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_enumerate_device.descriptor to %struct._ddebug*), %struct.device* %dev48, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.53, i32 0, i32 0), i32 %call35)
  br label %cleanup

if.end54:                                         ; preds = %land.lhs.true, %if.end19
  call void @usb_detect_interface_quirks(%struct.usb_device* %udev)
  br label %cleanup

cleanup:                                          ; preds = %if.end54, %if.then47, %do.body39, %if.then34, %lor.lhs.false, %if.end7, %if.then5, %if.then3
  %retval.0 = phi i32 [ 0, %if.end54 ], [ %call1, %if.then5 ], [ %call1, %if.then3 ], [ %call15, %if.end7 ], [ -524, %if.then34 ], [ -524, %if.then47 ], [ -524, %do.body39 ], [ -524, %lor.lhs.false ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @announce_device(%struct.usb_device* %udev) #0 {
entry:
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %product = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 24
  %0 = load i8*, i8** %product, align 8, !tbaa !45
  call void @show_string(i8* %0)
  %manufacturer = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 25
  %1 = load i8*, i8** %manufacturer, align 8, !tbaa !46
  call void @show_string(i8* %1)
  %serial = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 26
  %2 = load i8*, i8** %serial, align 8, !tbaa !47
  call void @show_string(i8* %2)
  ret void
}

declare void @add_device_randomness(i8*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_enable_async_suspend(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %is_prepared = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i16, i16* %is_prepared, align 4
  %bf.lshr = lshr i16 %bf.load, 3
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = trunc i16 %bf.clear to i1
  br i1 %bf.cast, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %power1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %async_suspend = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power1, i32 0, i32 1
  %bf.load2 = load i16, i16* %async_suspend, align 4
  %bf.clear3 = and i16 %bf.load2, -3
  %bf.set = or i16 %bf.clear3, 2
  store i16 %bf.set, i16* %async_suspend, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @set_usb_port_removable(%struct.usb_device* %udev) #0 {
entry:
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %1 = load i8, i8* %portnum, align 2, !tbaa !81
  %tobool = icmp ne %struct.usb_device* %0, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %parent1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %2 = load %struct.usb_device*, %struct.usb_device** %parent1, align 8, !tbaa !79
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %2)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %3 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %portnum2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %4 = load i8, i8* %portnum2, align 2, !tbaa !81
  %conv = zext i8 %4 to i32
  %sub = sub nsw i32 %conv, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %3, i64 %idxprom
  %5 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %connect_type = getelementptr inbounds %struct.usb_port, %struct.usb_port* %5, i32 0, i32 5
  %6 = load i32, i32* %connect_type, align 8, !tbaa !230
  %Pivot = icmp slt i32 %6, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end
  %.off = add i32 %6, -2
  %SwitchLeaf2 = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf2, label %sw.bb4, label %sw.epilog

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %6, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %removable3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 36
  store i32 1, i32* %removable3, align 4, !tbaa !261
  br label %cleanup.cont

sw.bb4:                                           ; preds = %LeafBlock1
  %removable5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 36
  store i32 2, i32* %removable5, align 4, !tbaa !261
  br label %cleanup.cont

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1
  %descriptor = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 16
  %7 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !232
  %wHubCharacteristics6 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %7, i32 0, i32 3
  %8 = load i16, i16* %wHubCharacteristics6, align 1, !tbaa !262
  %conv7 = zext i16 %8 to i32
  %and = and i32 %conv7, 4
  %tobool8 = icmp ne i32 %and, 0
  br i1 %tobool8, label %if.end10, label %cleanup.cont

if.end10:                                         ; preds = %sw.epilog
  %call11 = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool12 = icmp ne i32 %call11, 0
  %descriptor14 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 16
  %9 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor14, align 8, !tbaa !232
  %u = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %9, i32 0, i32 6
  br i1 %tobool12, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end10
  %ss = bitcast %union.anon.63* %u to %struct.anon.65*
  %DeviceRemovable = getelementptr inbounds %struct.anon.65, %struct.anon.65* %ss, i32 0, i32 2
  %10 = load i16, i16* %DeviceRemovable, align 1, !tbaa !72
  %conv15 = zext i16 %10 to i32
  %conv16 = zext i8 %1 to i32
  br label %if.end34

if.else:                                          ; preds = %if.end10
  %hs = bitcast %union.anon.63* %u to %struct.anon.64*
  %DeviceRemovable23 = getelementptr inbounds %struct.anon.64, %struct.anon.64* %hs, i32 0, i32 0
  %conv24 = zext i8 %1 to i32
  %div = sdiv i32 %conv24, 8
  %idxprom25 = sext i32 %div to i64
  %arrayidx26 = getelementptr inbounds [4 x i8], [4 x i8]* %DeviceRemovable23, i64 0, i64 %idxprom25
  %11 = load i8, i8* %arrayidx26, align 1, !tbaa !72
  %conv27 = zext i8 %11 to i32
  %conv28 = zext i8 %1 to i32
  %rem = srem i32 %conv28, 8
  br label %if.end34

if.end34:                                         ; preds = %if.else, %if.then13
  %rem.sink = phi i32 [ %rem, %if.else ], [ %conv16, %if.then13 ]
  %conv27.sink = phi i32 [ %conv27, %if.else ], [ %conv15, %if.then13 ]
  %shl29 = shl i32 1, %rem.sink
  %and30 = and i32 %conv27.sink, %shl29
  %tobool31 = icmp ne i32 %and30, 0
  %.3 = select i1 %tobool31, i8 0, i8 1
  %tobool35 = trunc i8 %.3 to i1
  %removable37 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 36
  %.sink = select i1 %tobool35, i32 1, i32 2
  store i32 %.sink, i32* %removable37, align 4, !tbaa !261
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end34, %sw.epilog, %sw.bb4, %sw.bb, %entry
  ret void
}

declare i32 @device_add(%struct.device*) #2

declare i32 @sysfs_create_link(%struct.kobject*, %struct.kobject*, i8*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_mark_last_busy(%struct.usb_device* %udev) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_mark_last_busy(%struct.device* %dev)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put_sync_autosuspend(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_suspend(%struct.device* %dev, i32 12)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_disable(%struct.device* %dev) #1 {
entry:
  call void @__pm_runtime_disable(%struct.device* %dev, i1 zeroext true)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_set_suspended(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_set_status(%struct.device* %dev, i32 2)
  ret void
}

declare i32 @__pm_runtime_set_status(%struct.device*, i32) #2

declare void @__pm_runtime_disable(%struct.device*, i1 zeroext) #2

declare i32 @__pm_runtime_suspend(%struct.device*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_mark_last_busy(%struct.device* %dev) #1 {
entry:
  %0 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %last_busy = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 20
  store volatile i64 %0, i64* %last_busy, align 8, !tbaa !53
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @show_string(i8* %string) #0 {
entry:
  %tobool = icmp ne i8* %string, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_enumerate_device_otg(%struct.usb_device* %udev) #0 {
entry:
  %desc = alloca %struct.usb_ptm_cap_descriptor*, align 8
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %is_b_host = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 6
  %bf.load = load i8, i8* %is_b_host, align 1
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %cleanup51, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 14
  %1 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !194
  %tobool1 = icmp ne %struct.usb_host_config* %1, null
  br i1 %tobool1, label %land.lhs.true2, label %cleanup51

land.lhs.true2:                                   ; preds = %land.lhs.true
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %2 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %bus3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %3 = load %struct.usb_bus*, %struct.usb_bus** %bus3, align 8, !tbaa !2
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %3, i32 0, i32 11
  %4 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !264
  %cmp = icmp eq %struct.usb_device* %2, %4
  br i1 %cmp, label %if.then, label %cleanup51

if.then:                                          ; preds = %land.lhs.true2
  store %struct.usb_ptm_cap_descriptor* null, %struct.usb_ptm_cap_descriptor** %desc, align 8, !tbaa !52
  %bus5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %5 = load %struct.usb_bus*, %struct.usb_bus** %bus5, align 8, !tbaa !2
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %6 = load i8, i8* %portnum, align 2, !tbaa !81
  %conv = zext i8 %6 to i32
  %rawdescriptors = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 18
  %7 = load i8**, i8*** %rawdescriptors, align 8, !tbaa !196
  %arrayidx = getelementptr inbounds i8*, i8** %7, i64 0
  %8 = load i8*, i8** %arrayidx, align 8, !tbaa !52
  %config6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 14
  %9 = load %struct.usb_host_config*, %struct.usb_host_config** %config6, align 8, !tbaa !194
  %arrayidx7 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %9, i64 0
  %desc8 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx7, i32 0, i32 0
  %wTotalLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc8, i32 0, i32 2
  %10 = load i16, i16* %wTotalLength, align 2, !tbaa !195
  %conv9 = zext i16 %10 to i32
  %11 = bitcast %struct.usb_ptm_cap_descriptor** %desc to i8**
  %call = call i32 @__usb_get_extra_descriptor(i8* %8, i32 %conv9, i8 zeroext 9, i8** %11)
  %tobool10 = icmp ne i32 %call, 0
  br i1 %tobool10, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %12 = load %struct.usb_ptm_cap_descriptor*, %struct.usb_ptm_cap_descriptor** %desc, align 8, !tbaa !52
  %bmAttributes = getelementptr inbounds %struct.usb_ptm_cap_descriptor, %struct.usb_ptm_cap_descriptor* %12, i32 0, i32 2
  %13 = load i8, i8* %bmAttributes, align 1, !tbaa !265
  %conv11 = zext i8 %13 to i32
  %and = and i32 %conv11, 2
  %tobool12 = icmp ne i32 %and, 0
  br i1 %tobool12, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %otg_port17 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %5, i32 0, i32 5
  %14 = load i8, i8* %otg_port17, align 2, !tbaa !178
  %conv18 = zext i8 %14 to i32
  %cmp19 = icmp eq i32 %conv, %conv18
  br i1 %cmp19, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.end
  %b_hnp_enable = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %5, i32 0, i32 6
  %bf.load22 = load i8, i8* %b_hnp_enable, align 1
  %bf.clear23 = and i8 %bf.load22, -3
  %bf.set = or i8 %bf.clear23, 2
  store i8 %bf.set, i8* %b_hnp_enable, align 1
  %call24 = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or = or i32 -2147483648, %call24
  %call25 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext 3, i8 zeroext 0, i16 zeroext 3, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  %cmp26 = icmp slt i32 %call25, 0
  br i1 %cmp26, label %if.then28, label %cleanup

if.then28:                                        ; preds = %if.then21
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %b_hnp_enable30 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %5, i32 0, i32 6
  %bf.load31 = load i8, i8* %b_hnp_enable30, align 1
  %bf.clear32 = and i8 %bf.load31, -3
  store i8 %bf.clear32, i8* %b_hnp_enable30, align 1
  br label %cleanup

if.else:                                          ; preds = %if.end
  %15 = load %struct.usb_ptm_cap_descriptor*, %struct.usb_ptm_cap_descriptor** %desc, align 8, !tbaa !52
  %bLength = getelementptr inbounds %struct.usb_ptm_cap_descriptor, %struct.usb_ptm_cap_descriptor* %15, i32 0, i32 0
  %16 = load i8, i8* %bLength, align 1, !tbaa !267
  %conv34 = zext i8 %16 to i64
  %cmp35 = icmp eq i64 %conv34, 3
  br i1 %cmp35, label %if.then37, label %cleanup

if.then37:                                        ; preds = %if.else
  %call38 = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or39 = or i32 -2147483648, %call38
  %call40 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or39, i8 zeroext 3, i8 zeroext 0, i16 zeroext 5, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  %cmp41 = icmp slt i32 %call40, 0
  br i1 %cmp41, label %if.then43, label %cleanup

if.then43:                                        ; preds = %if.then37
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then43, %if.then37, %if.else, %if.then28, %if.then21, %lor.lhs.false, %if.then
  %err.2 = phi i32 [ %call, %lor.lhs.false ], [ %call, %if.then ], [ %call25, %if.then28 ], [ %call25, %if.then21 ], [ %call, %if.else ], [ %call40, %if.then43 ], [ %call40, %if.then37 ]
  %cleanup.dest.slot.0 = phi i32 [ 1, %lor.lhs.false ], [ 1, %if.then ], [ 0, %if.else ], [ 0, %if.then43 ], [ 0, %if.then37 ], [ 0, %if.then21 ], [ 0, %if.then28 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  %err.2. = select i1 %SwitchLeaf, i32 %err.2, i32 0
  ret i32 %err.2.

cleanup51:                                        ; preds = %land.lhs.true2, %land.lhs.true, %entry
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @is_targeted(%struct.usb_device* %dev) #0 {
entry:
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %idVendor = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 7
  %0 = load i16, i16* %idVendor, align 8, !tbaa !268
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 6666
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %descriptor2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %idProduct = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor2, i32 0, i32 8
  %1 = load i16, i16* %idProduct, align 2, !tbaa !269
  %conv3 = zext i16 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 47837
  br i1 %cmp4, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %descriptor6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %idVendor7 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor6, i32 0, i32 7
  %2 = load i16, i16* %idVendor7, align 8, !tbaa !268
  %conv8 = zext i16 %2 to i32
  %cmp9 = icmp eq i32 %conv8, 6666
  br i1 %cmp9, label %land.lhs.true11, label %if.end18

land.lhs.true11:                                  ; preds = %if.end
  %descriptor12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %idProduct13 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor12, i32 0, i32 8
  %3 = load i16, i16* %idProduct13, align 2, !tbaa !269
  %conv14 = zext i16 %3 to i32
  %cmp15 = icmp eq i32 %conv14, 512
  br i1 %cmp15, label %cleanup, label %if.end18

if.end18:                                         ; preds = %land.lhs.true11, %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end18
  %id.0 = phi %struct.usb_device_id* [ getelementptr inbounds ([4 x %struct.usb_device_id], [4 x %struct.usb_device_id]* @whitelist_table, i32 0, i32 0), %if.end18 ], [ %incdec.ptr, %for.inc ]
  %match_flags = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 0
  %4 = load i16, i16* %match_flags, align 8, !tbaa !270
  %tobool = icmp ne i16 %4, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %match_flags19 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 0
  %5 = load i16, i16* %match_flags19, align 8, !tbaa !270
  %conv20 = zext i16 %5 to i32
  %and = and i32 %conv20, 1
  %tobool21 = icmp ne i32 %and, 0
  br i1 %tobool21, label %land.lhs.true22, label %if.end31

land.lhs.true22:                                  ; preds = %for.body
  %idVendor23 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 1
  %6 = load i16, i16* %idVendor23, align 2, !tbaa !272
  %conv24 = zext i16 %6 to i32
  %descriptor25 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %idVendor26 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor25, i32 0, i32 7
  %7 = load i16, i16* %idVendor26, align 8, !tbaa !268
  %conv27 = zext i16 %7 to i32
  %cmp28 = icmp ne i32 %conv24, %conv27
  br i1 %cmp28, label %for.inc, label %if.end31

if.end31:                                         ; preds = %land.lhs.true22, %for.body
  %match_flags32 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 0
  %8 = load i16, i16* %match_flags32, align 8, !tbaa !270
  %conv33 = zext i16 %8 to i32
  %and34 = and i32 %conv33, 2
  %tobool35 = icmp ne i32 %and34, 0
  br i1 %tobool35, label %land.lhs.true36, label %if.end45

land.lhs.true36:                                  ; preds = %if.end31
  %idProduct37 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 2
  %9 = load i16, i16* %idProduct37, align 4, !tbaa !273
  %conv38 = zext i16 %9 to i32
  %descriptor39 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %idProduct40 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor39, i32 0, i32 8
  %10 = load i16, i16* %idProduct40, align 2, !tbaa !269
  %conv41 = zext i16 %10 to i32
  %cmp42 = icmp ne i32 %conv38, %conv41
  br i1 %cmp42, label %for.inc, label %if.end45

if.end45:                                         ; preds = %land.lhs.true36, %if.end31
  %match_flags46 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 0
  %11 = load i16, i16* %match_flags46, align 8, !tbaa !270
  %conv47 = zext i16 %11 to i32
  %and48 = and i32 %conv47, 4
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool49, label %land.lhs.true50, label %if.end57

land.lhs.true50:                                  ; preds = %if.end45
  %bcdDevice_lo = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 3
  %12 = load i16, i16* %bcdDevice_lo, align 2, !tbaa !274
  %conv51 = zext i16 %12 to i32
  %descriptor52 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bcdDevice = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor52, i32 0, i32 9
  %13 = load i16, i16* %bcdDevice, align 4, !tbaa !275
  %conv53 = zext i16 %13 to i32
  %cmp54 = icmp sgt i32 %conv51, %conv53
  br i1 %cmp54, label %for.inc, label %if.end57

if.end57:                                         ; preds = %land.lhs.true50, %if.end45
  %match_flags58 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 0
  %14 = load i16, i16* %match_flags58, align 8, !tbaa !270
  %conv59 = zext i16 %14 to i32
  %and60 = and i32 %conv59, 8
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %land.lhs.true62, label %if.end70

land.lhs.true62:                                  ; preds = %if.end57
  %bcdDevice_hi = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 4
  %15 = load i16, i16* %bcdDevice_hi, align 8, !tbaa !276
  %conv63 = zext i16 %15 to i32
  %descriptor64 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bcdDevice65 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor64, i32 0, i32 9
  %16 = load i16, i16* %bcdDevice65, align 4, !tbaa !275
  %conv66 = zext i16 %16 to i32
  %cmp67 = icmp slt i32 %conv63, %conv66
  br i1 %cmp67, label %for.inc, label %if.end70

if.end70:                                         ; preds = %land.lhs.true62, %if.end57
  %match_flags71 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 0
  %17 = load i16, i16* %match_flags71, align 8, !tbaa !270
  %conv72 = zext i16 %17 to i32
  %and73 = and i32 %conv72, 16
  %tobool74 = icmp ne i32 %and73, 0
  br i1 %tobool74, label %land.lhs.true75, label %if.end83

land.lhs.true75:                                  ; preds = %if.end70
  %bDeviceClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 5
  %18 = load i8, i8* %bDeviceClass, align 2, !tbaa !277
  %conv76 = zext i8 %18 to i32
  %descriptor77 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bDeviceClass78 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor77, i32 0, i32 3
  %19 = load i8, i8* %bDeviceClass78, align 4, !tbaa !278
  %conv79 = zext i8 %19 to i32
  %cmp80 = icmp ne i32 %conv76, %conv79
  br i1 %cmp80, label %for.inc, label %if.end83

if.end83:                                         ; preds = %land.lhs.true75, %if.end70
  %match_flags84 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 0
  %20 = load i16, i16* %match_flags84, align 8, !tbaa !270
  %conv85 = zext i16 %20 to i32
  %and86 = and i32 %conv85, 32
  %tobool87 = icmp ne i32 %and86, 0
  br i1 %tobool87, label %land.lhs.true88, label %if.end96

land.lhs.true88:                                  ; preds = %if.end83
  %bDeviceSubClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 6
  %21 = load i8, i8* %bDeviceSubClass, align 1, !tbaa !279
  %conv89 = zext i8 %21 to i32
  %descriptor90 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bDeviceSubClass91 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor90, i32 0, i32 4
  %22 = load i8, i8* %bDeviceSubClass91, align 1, !tbaa !280
  %conv92 = zext i8 %22 to i32
  %cmp93 = icmp ne i32 %conv89, %conv92
  br i1 %cmp93, label %for.inc, label %if.end96

if.end96:                                         ; preds = %land.lhs.true88, %if.end83
  %match_flags97 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 0
  %23 = load i16, i16* %match_flags97, align 8, !tbaa !270
  %conv98 = zext i16 %23 to i32
  %and99 = and i32 %conv98, 64
  %tobool100 = icmp ne i32 %and99, 0
  br i1 %tobool100, label %land.lhs.true101, label %cleanup

land.lhs.true101:                                 ; preds = %if.end96
  %bDeviceProtocol = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 7
  %24 = load i8, i8* %bDeviceProtocol, align 4, !tbaa !281
  %conv102 = zext i8 %24 to i32
  %descriptor103 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bDeviceProtocol104 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor103, i32 0, i32 5
  %25 = load i8, i8* %bDeviceProtocol104, align 2, !tbaa !205
  %conv105 = zext i8 %25 to i32
  %cmp106 = icmp ne i32 %conv102, %conv105
  br i1 %cmp106, label %for.inc, label %cleanup

for.inc:                                          ; preds = %land.lhs.true101, %land.lhs.true88, %land.lhs.true75, %land.lhs.true62, %land.lhs.true50, %land.lhs.true36, %land.lhs.true22
  %incdec.ptr = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %land.lhs.true101, %if.end96, %land.lhs.true11, %land.lhs.true
  %retval.0 = phi i32 [ 0, %for.end ], [ 0, %land.lhs.true ], [ 1, %land.lhs.true11 ], [ 1, %land.lhs.true101 ], [ 1, %if.end96 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_port_suspend(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %c.i = alloca i8, align 1
  %msg = alloca %struct.atomic_t, align 4
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %0)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %1 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %2 = load i8, i8* %portnum, align 2, !tbaa !81
  %conv = zext i8 %2 to i32
  %sub = sub nsw i32 %conv, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %1, i64 %idxprom
  %3 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %portnum1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %4 = load i8, i8* %portnum1, align 2, !tbaa !81
  %conv2 = zext i8 %4 to i32
  call void @usb_lock_port(%struct.usb_port* %3)
  %do_remote_wakeup = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load = load i8, i8* %do_remote_wakeup, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.end21

if.then:                                          ; preds = %entry
  %call3 = call i32 @usb_enable_remote_wakeup(%struct.usb_device* %udev)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.body6, label %if.end21

do.body6:                                         ; preds = %if.then
  %bf.load7 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_suspend.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load7, 18
  %bf.clear8 = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear8, 1
  %tobool9 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool9, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv11 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.then13, label %do.end15

if.then13:                                        ; preds = %do.body6
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_suspend.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.20, i32 0, i32 0), i32 %call3)
  br label %do.end15

do.end15:                                         ; preds = %if.then13, %do.body6
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %5 = load i32, i32* %event, align 4, !tbaa !48
  %and16 = and i32 %5, 1024
  %cmp = icmp ne i32 %and16, 0
  br i1 %cmp, label %err_wakeup, label %if.end21

if.end21:                                         ; preds = %do.end15, %if.then, %entry
  %usb2_hw_lpm_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load22 = load i16, i16* %usb2_hw_lpm_enabled, align 4
  %bf.lshr23 = lshr i16 %bf.load22, 9
  %bf.clear24 = and i16 %bf.lshr23, 1
  %bf.cast25 = zext i16 %bf.clear24 to i32
  %cmp26 = icmp eq i32 %bf.cast25, 1
  br i1 %cmp26, label %if.then28, label %if.end30

if.then28:                                        ; preds = %if.end21
  %call29 = call i32 @usb_set_usb2_hardware_lpm(%struct.usb_device* %udev, i32 0)
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %if.end21
  %call31 = call i32 @usb_disable_ltm(%struct.usb_device* %udev)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %if.then33, label %if.end41

if.then33:                                        ; preds = %if.end30
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %event35 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %6 = load i32, i32* %event35, align 4, !tbaa !48
  %and36 = and i32 %6, 1024
  %cmp37 = icmp ne i32 %and36, 0
  br i1 %cmp37, label %err_ltm, label %if.end41

if.end41:                                         ; preds = %if.then33, %if.end30
  %call42 = call i32 @usb_unlocked_disable_lpm(%struct.usb_device* %udev)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.then44, label %if.end52

if.then44:                                        ; preds = %if.end41
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %event46 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %7 = load i32, i32* %event46, align 4, !tbaa !48
  %and47 = and i32 %7, 1024
  %cmp48 = icmp ne i32 %and47, 0
  br i1 %cmp48, label %err_lpm3, label %if.end52

if.end52:                                         ; preds = %if.then44, %if.end41
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %8 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %call53 = call i32 @hub_is_superspeed(%struct.usb_device* %8)
  %tobool54 = icmp ne i32 %call53, 0
  br i1 %tobool54, label %if.then55, label %if.else

if.then55:                                        ; preds = %if.end52
  %call56 = call i32 @hub_set_port_link_state(%struct.usb_hub* %call, i32 %conv2, i32 96)
  br label %if.end69

if.else:                                          ; preds = %if.end52
  %event57 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %9 = load i32, i32* %event57, align 4, !tbaa !48
  %and58 = and i32 %9, 1024
  %cmp59 = icmp ne i32 %and58, 0
  br i1 %cmp59, label %if.then64, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %call61 = call i32 @wakeup_enabled_descendants(%struct.usb_device* %udev)
  %cmp62 = icmp ugt i32 %call61, 0
  br i1 %cmp62, label %if.then64, label %if.end69

if.then64:                                        ; preds = %lor.lhs.false, %if.else
  %hdev65 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %hdev65, align 8, !tbaa !176
  %call66 = call i32 @set_port_feature(%struct.usb_device* %10, i32 %conv2, i32 2)
  br label %if.end69

if.end69:                                         ; preds = %if.then64, %lor.lhs.false, %if.then55
  %status.1 = phi i32 [ %call56, %if.then55 ], [ %call66, %if.then64 ], [ 0, %lor.lhs.false ]
  %really_suspend.1 = phi i8 [ 1, %if.then55 ], [ 1, %if.then64 ], [ 0, %lor.lhs.false ]
  %tobool70 = icmp ne i32 %status.1, 0
  br i1 %tobool70, label %do.body73, label %do.body118

do.body73:                                        ; preds = %if.end69
  %bf.load74 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_suspend.descriptor.23 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr75 = lshr i32 %bf.load74, 18
  %bf.clear76 = and i32 %bf.lshr75, 255
  %and77 = and i32 %bf.clear76, 1
  %tobool78 = icmp ne i32 %and77, 0
  %lnot79 = xor i1 %tobool78, true
  %lnot81 = xor i1 %lnot79, true
  %lnot.ext82 = zext i1 %lnot81 to i32
  %conv83 = sext i32 %lnot.ext82 to i64
  %expval84 = call i64 @llvm.expect.i64(i64 %conv83, i64 0)
  %tobool85 = icmp ne i64 %expval84, 0
  br i1 %tobool85, label %if.then86, label %do.end92

if.then86:                                        ; preds = %do.body73
  %dev87 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 1
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_suspend.descriptor.23 to %struct._ddebug*), %struct.device* %dev87, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.24, i32 0, i32 0), i32 %status.1)
  br label %do.end92

do.end92:                                         ; preds = %if.then86, %do.body73
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %udev)
  br label %err_lpm3

err_lpm3:                                         ; preds = %do.end92, %if.then44
  %status.2 = phi i32 [ %status.1, %do.end92 ], [ -12, %if.then44 ]
  call void @usb_enable_ltm(%struct.usb_device* %udev)
  br label %err_ltm

err_ltm:                                          ; preds = %err_lpm3, %if.then33
  %status.3 = phi i32 [ %status.2, %err_lpm3 ], [ -12, %if.then33 ]
  %usb2_hw_lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load93 = load i16, i16* %usb2_hw_lpm_capable, align 4
  %bf.lshr94 = lshr i16 %bf.load93, 7
  %bf.clear95 = and i16 %bf.lshr94, 1
  %bf.cast96 = zext i16 %bf.clear95 to i32
  %cmp97 = icmp eq i32 %bf.cast96, 1
  br i1 %cmp97, label %if.then99, label %if.end101

if.then99:                                        ; preds = %err_ltm
  %call100 = call i32 @usb_set_usb2_hardware_lpm(%struct.usb_device* %udev, i32 1)
  br label %if.end101

if.end101:                                        ; preds = %if.then99, %err_ltm
  %do_remote_wakeup102 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load103 = load i8, i8* %do_remote_wakeup102, align 8
  %bf.clear104 = and i8 %bf.load103, 1
  %bf.cast105 = zext i8 %bf.clear104 to i32
  %tobool106 = icmp ne i32 %bf.cast105, 0
  br i1 %tobool106, label %if.then107, label %err_wakeup

if.then107:                                       ; preds = %if.end101
  %call108 = call i32 @usb_disable_remote_wakeup(%struct.usb_device* %udev)
  br label %err_wakeup

err_wakeup:                                       ; preds = %if.then107, %if.end101, %do.end15
  %status.4 = phi i32 [ %call3, %do.end15 ], [ %status.3, %if.then107 ], [ %status.3, %if.end101 ]
  %event110 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %11 = load i32, i32* %event110, align 4, !tbaa !48
  %and111 = and i32 %11, 1024
  %cmp112 = icmp ne i32 %and111, 0
  %status.4. = select i1 %cmp112, i32 %status.4, i32 0
  br label %if.end151

do.body118:                                       ; preds = %if.end69
  %bf.load119 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_suspend.descriptor.25 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr120 = lshr i32 %bf.load119, 18
  %bf.clear121 = and i32 %bf.lshr120, 255
  %and122 = and i32 %bf.clear121, 1
  %tobool123 = icmp ne i32 %and122, 0
  %lnot124 = xor i1 %tobool123, true
  %lnot126 = xor i1 %lnot124, true
  %lnot.ext127 = zext i1 %lnot126 to i32
  %conv128 = sext i32 %lnot.ext127 to i64
  %expval129 = call i64 @llvm.expect.i64(i64 %conv128, i64 0)
  %tobool130 = icmp ne i64 %expval129, 0
  br i1 %tobool130, label %if.then131, label %do.end145

if.then131:                                       ; preds = %do.body118
  %dev132 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %event133 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %12 = load i32, i32* %event133, align 4, !tbaa !48
  %and134 = and i32 %12, 1024
  %cmp135 = icmp ne i32 %and134, 0
  %cond = select i1 %cmp135, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.16.143, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.28.900, i32 0, i32 0)
  %do_remote_wakeup137 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load138 = load i8, i8* %do_remote_wakeup137, align 8
  %bf.clear139 = and i8 %bf.load138, 1
  %bf.cast140 = zext i8 %bf.clear139 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_suspend.descriptor.25 to %struct._ddebug*), %struct.device* %dev132, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.26, i32 0, i32 0), i8* %cond, i32 %bf.cast140)
  br label %do.end145

do.end145:                                        ; preds = %if.then131, %do.body118
  %tobool146 = trunc i8 %really_suspend.1 to i1
  br i1 %tobool146, label %if.then147, label %if.end150

if.then147:                                       ; preds = %do.end145
  %port_is_suspended = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load148 = load i8, i8* %port_is_suspended, align 8
  %bf.clear149 = and i8 %bf.load148, -5
  %bf.set = or i8 %bf.clear149, 4
  store i8 %bf.set, i8* %port_is_suspended, align 8
  call void @msleep(i32 10)
  br label %if.end150

if.end150:                                        ; preds = %if.then147, %do.end145
  call void @usb_set_device_state(%struct.usb_device* %udev, i32 8)
  br label %if.end151

if.end151:                                        ; preds = %if.end150, %err_wakeup
  %status.6 = phi i32 [ %status.4., %err_wakeup ], [ %status.1, %if.end150 ]
  %cmp152 = icmp eq i32 %status.6, 0
  br i1 %cmp152, label %land.lhs.true, label %if.end172

land.lhs.true:                                    ; preds = %if.end151
  %do_remote_wakeup154 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load155 = load i8, i8* %do_remote_wakeup154, align 8
  %bf.clear156 = and i8 %bf.load155, 1
  %bf.cast157 = zext i8 %bf.clear156 to i32
  %tobool158 = icmp ne i32 %bf.cast157, 0
  br i1 %tobool158, label %if.end172, label %land.lhs.true159

land.lhs.true159:                                 ; preds = %land.lhs.true
  %persist_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load160 = load i16, i16* %persist_enabled, align 4
  %bf.lshr161 = lshr i16 %bf.load160, 1
  %bf.clear162 = and i16 %bf.lshr161, 1
  %bf.cast163 = zext i16 %bf.clear162 to i32
  %tobool164 = icmp ne i32 %bf.cast163, 0
  br i1 %tobool164, label %land.lhs.true165, label %if.end172

land.lhs.true165:                                 ; preds = %land.lhs.true159
  %conv166 = sext i32 %conv2 to i64
  %child_usage_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 14
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %child_usage_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2, $0;\0A\09setc $1\0A", "=*m,=*qm,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i8* %c.i, i64 %conv166, i64* %arraydecay) #8, !srcloc !255
  %13 = load i8, i8* %c.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %13 to i1
  br i1 %tobool.i, label %if.then169, label %if.end172

if.then169:                                       ; preds = %land.lhs.true165
  %dev170 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 1
  call void @pm_runtime_put_sync(%struct.device* %dev170)
  br label %if.end172

if.end172:                                        ; preds = %if.then169, %land.lhs.true165, %land.lhs.true159, %land.lhs.true, %if.end151
  %hdev173 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %14 = load %struct.usb_device*, %struct.usb_device** %hdev173, align 8, !tbaa !176
  call void @usb_mark_last_busy(%struct.usb_device* %14)
  call void @usb_unlock_port(%struct.usb_port* %3)
  ret i32 %status.6
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_enable_remote_wakeup(%struct.usb_device* %udev) #0 {
entry:
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp ult i32 %0, 5
  %call = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or = or i32 -2147483648, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext 3, i8 zeroext 0, i16 zeroext 1, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  br label %return

if.else:                                          ; preds = %entry
  %call4 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext 3, i8 zeroext 1, i16 zeroext 0, i16 zeroext 768, i8* null, i16 zeroext 0, i32 5000)
  br label %return

return:                                           ; preds = %if.else, %if.then
  %retval.0 = phi i32 [ %call1, %if.then ], [ %call4, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @wakeup_enabled_descendants(%struct.usb_device* %udev) #0 {
entry:
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %udev)
  %do_remote_wakeup = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load = load i8, i8* %do_remote_wakeup, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne %struct.usb_hub* %call, null
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %wakeup_enabled_descendants = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 19
  %0 = load i32, i32* %wakeup_enabled_descendants, align 4, !tbaa !282
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi i32 [ %0, %cond.true ], [ 0, %entry ]
  %add = add i32 %bf.cast, %cond
  ret i32 %add
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put_sync(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_idle(%struct.device* %dev, i32 4)
  ret void
}

declare void @__pm_runtime_use_autosuspend(%struct.device*, i1 zeroext) #2

; Function Attrs: nounwind uwtable
define i32 @usb_deauthorize_device(%struct.usb_device* %usb_dev) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 11
  call void @device_lock(%struct.device* %dev)
  %authorized = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 22
  %bf.load = load i16, i16* %authorized, align 4
  %bf.lshr = lshr i16 %bf.load, 3
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 0
  br i1 %cmp, label %out_unauthorized, label %if.end

if.end:                                           ; preds = %entry
  %authorized1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 22
  %bf.load2 = load i16, i16* %authorized1, align 4
  %bf.clear3 = and i16 %bf.load2, -9
  store i16 %bf.clear3, i16* %authorized1, align 4
  %call = call i32 @usb_set_configuration(%struct.usb_device* %usb_dev, i32 -1)
  br label %out_unauthorized

out_unauthorized:                                 ; preds = %if.end, %entry
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev4)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @usb_authorize_device(%struct.usb_device* %usb_dev) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 11
  call void @device_lock(%struct.device* %dev)
  %authorized = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 22
  %bf.load = load i16, i16* %authorized, align 4
  %bf.lshr = lshr i16 %bf.load, 3
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 1
  br i1 %cmp, label %out_authorized, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @usb_autoresume_device(%struct.usb_device* %usb_dev)
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %out_authorized

if.end4:                                          ; preds = %if.end
  %wusb = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 22
  %bf.load5 = load i16, i16* %wusb, align 4
  %bf.lshr6 = lshr i16 %bf.load5, 5
  %bf.clear7 = and i16 %bf.lshr6, 1
  %bf.cast8 = zext i16 %bf.clear7 to i32
  %tobool = icmp ne i32 %bf.cast8, 0
  br i1 %tobool, label %if.then9, label %if.end15

if.then9:                                         ; preds = %if.end4
  %call10 = call i32 @usb_get_device_descriptor(%struct.usb_device* %usb_dev, i32 18)
  %cmp11 = icmp slt i32 %call10, 0
  br i1 %cmp11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.then9
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %error_device_descriptor

if.end15:                                         ; preds = %if.then9, %if.end4
  %result.0 = phi i32 [ %call, %if.end4 ], [ %call10, %if.then9 ]
  %authorized16 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 22
  %bf.load17 = load i16, i16* %authorized16, align 4
  %bf.clear18 = and i16 %bf.load17, -9
  %bf.set = or i16 %bf.clear18, 8
  store i16 %bf.set, i16* %authorized16, align 4
  %call19 = call i32 @usb_choose_configuration(%struct.usb_device* %usb_dev)
  %cmp20 = icmp sge i32 %call19, 0
  br i1 %cmp20, label %if.then21, label %if.end27

if.then21:                                        ; preds = %if.end15
  %call22 = call i32 @usb_set_configuration(%struct.usb_device* %usb_dev, i32 %call19)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.then24, label %if.end27

if.then24:                                        ; preds = %if.then21
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end27

if.end27:                                         ; preds = %if.then24, %if.then21, %if.end15
  %result.1 = phi i32 [ %result.0, %if.end15 ], [ %call22, %if.then24 ], [ %call22, %if.then21 ]
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %error_device_descriptor

error_device_descriptor:                          ; preds = %if.end27, %if.then12
  %result.2 = phi i32 [ %call10, %if.then12 ], [ %result.1, %if.end27 ]
  call void @usb_autosuspend_device(%struct.usb_device* %usb_dev)
  br label %out_authorized

out_authorized:                                   ; preds = %error_device_descriptor, %if.then2, %entry
  %result.4 = phi i32 [ 0, %entry ], [ %call, %if.then2 ], [ %result.2, %error_device_descriptor ]
  %dev29 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev29)
  ret i32 %result.4
}

; Function Attrs: nounwind uwtable
define i32 @usb_port_resume(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %c.i = alloca i8, align 1
  %msg = alloca %struct.atomic_t, align 4
  %port1 = alloca i32, align 4
  %portchange = alloca i16, align 2
  %portstatus = alloca i16, align 2
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %0)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %1 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %2 = load i8, i8* %portnum, align 2, !tbaa !81
  %conv = zext i8 %2 to i32
  %sub = sub nsw i32 %conv, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %1, i64 %idxprom
  %3 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %portnum1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %4 = load i8, i8* %portnum1, align 2, !tbaa !81
  %conv2 = zext i8 %4 to i32
  store i32 %conv2, i32* %port1, align 4, !tbaa !73
  %5 = load i32, i32* %port1, align 4, !tbaa !73
  %conv3 = sext i32 %5 to i64
  %child_usage_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 14
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %child_usage_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $2, $0;\0A\09setc $1\0A", "=*m,=*qm,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i8* %c.i, i64 %conv3, i64* %arraydecay) #8, !srcloc !254
  %6 = load i8, i8* %c.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %6 to i1
  br i1 %tobool.i, label %if.end17, label %if.then

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 1
  %call5 = call i32 @pm_runtime_get_sync(%struct.device* %dev)
  %cmp = icmp slt i32 %call5, 0
  br i1 %cmp, label %do.body8, label %if.end17

do.body8:                                         ; preds = %if.then
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_resume.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot9 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv10 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv10, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %if.then12, label %cleanup

if.then12:                                        ; preds = %do.body8
  %dev13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_resume.descriptor to %struct._ddebug*), %struct.device* %dev13, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.29, i32 0, i32 0), i32 %call5)
  br label %cleanup

if.end17:                                         ; preds = %if.then, %entry
  call void @usb_lock_port(%struct.usb_port* %3)
  %7 = load i32, i32* %port1, align 4, !tbaa !73
  %call18 = call i32 @hub_port_status(%struct.usb_hub* %call, i32 %7, i16* %portstatus, i16* %portchange)
  %cmp19 = icmp eq i32 %call18, 0
  br i1 %cmp19, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %if.end17
  %8 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv21 = zext i16 %8 to i32
  %call22 = call i32 @port_is_suspended(%struct.usb_hub* %call, i32 %conv21)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.end25, label %SuspendCleared

if.end25:                                         ; preds = %land.lhs.true, %if.end17
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %call26 = call i32 @hub_is_superspeed(%struct.usb_device* %9)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %if.then28, label %if.else

if.then28:                                        ; preds = %if.end25
  %10 = load i32, i32* %port1, align 4, !tbaa !73
  %call29 = call i32 @hub_set_port_link_state(%struct.usb_hub* %call, i32 %10, i32 0)
  br label %if.end32

if.else:                                          ; preds = %if.end25
  %hdev30 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %11 = load %struct.usb_device*, %struct.usb_device** %hdev30, align 8, !tbaa !176
  %12 = load i32, i32* %port1, align 4, !tbaa !73
  %call31 = call i32 @usb_clear_port_feature(%struct.usb_device* %11, i32 %12, i32 2)
  br label %if.end32

if.end32:                                         ; preds = %if.else, %if.then28
  %status.0 = phi i32 [ %call29, %if.then28 ], [ %call31, %if.else ]
  %tobool33 = icmp ne i32 %status.0, 0
  br i1 %tobool33, label %do.body36, label %do.body58

do.body36:                                        ; preds = %if.end32
  %bf.load37 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_resume.descriptor.30 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr38 = lshr i32 %bf.load37, 18
  %bf.clear39 = and i32 %bf.lshr38, 255
  %and40 = and i32 %bf.clear39, 1
  %tobool41 = icmp ne i32 %and40, 0
  %lnot42 = xor i1 %tobool41, true
  %lnot44 = xor i1 %lnot42, true
  %lnot.ext45 = zext i1 %lnot44 to i32
  %conv46 = sext i32 %lnot.ext45 to i64
  %expval47 = call i64 @llvm.expect.i64(i64 %conv46, i64 0)
  %tobool48 = icmp ne i64 %expval47, 0
  br i1 %tobool48, label %if.then49, label %SuspendCleared

if.then49:                                        ; preds = %do.body36
  %dev50 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 1
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_resume.descriptor.30 to %struct._ddebug*), %struct.device* %dev50, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.31, i32 0, i32 0), i32 %status.0)
  br label %SuspendCleared

do.body58:                                        ; preds = %if.end32
  %bf.load59 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_resume.descriptor.32 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr60 = lshr i32 %bf.load59, 18
  %bf.clear61 = and i32 %bf.lshr60, 255
  %and62 = and i32 %bf.clear61, 1
  %tobool63 = icmp ne i32 %and62, 0
  %lnot64 = xor i1 %tobool63, true
  %lnot66 = xor i1 %lnot64, true
  %lnot.ext67 = zext i1 %lnot66 to i32
  %conv68 = sext i32 %lnot.ext67 to i64
  %expval69 = call i64 @llvm.expect.i64(i64 %conv68, i64 0)
  %tobool70 = icmp ne i64 %expval69, 0
  br i1 %tobool70, label %if.then71, label %do.end80

if.then71:                                        ; preds = %do.body58
  %dev72 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %13 = load i32, i32* %event, align 4, !tbaa !48
  %and73 = and i32 %13, 1024
  %cmp74 = icmp ne i32 %and73, 0
  %cond = select i1 %cmp74, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.16.143, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.28.900, i32 0, i32 0)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_resume.descriptor.32 to %struct._ddebug*), %struct.device* %dev72, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.24.148, i32 0, i32 0), i8* %cond)
  br label %do.end80

do.end80:                                         ; preds = %if.then71, %do.body58
  call void @msleep(i32 40)
  %14 = load i32, i32* %port1, align 4, !tbaa !73
  %call81 = call i32 @hub_port_status(%struct.usb_hub* %call, i32 %14, i16* %portstatus, i16* %portchange)
  call void @msleep(i32 10)
  br label %SuspendCleared

SuspendCleared:                                   ; preds = %do.end80, %if.then49, %do.body36, %land.lhs.true
  %status.2 = phi i32 [ %call18, %land.lhs.true ], [ %call81, %do.end80 ], [ %status.0, %if.then49 ], [ %status.0, %do.body36 ]
  %cmp83 = icmp eq i32 %status.2, 0
  br i1 %cmp83, label %if.then85, label %if.end108

if.then85:                                        ; preds = %SuspendCleared
  %port_is_suspended = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load86 = load i8, i8* %port_is_suspended, align 8
  %bf.clear87 = and i8 %bf.load86, -5
  store i8 %bf.clear87, i8* %port_is_suspended, align 8
  %hdev88 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %15 = load %struct.usb_device*, %struct.usb_device** %hdev88, align 8, !tbaa !176
  %call89 = call i32 @hub_is_superspeed(%struct.usb_device* %15)
  %tobool90 = icmp ne i32 %call89, 0
  %16 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv92 = zext i16 %16 to i32
  br i1 %tobool90, label %if.then91, label %if.else99

if.then91:                                        ; preds = %if.then85
  %and93 = and i32 %conv92, 64
  %tobool94 = icmp ne i32 %and93, 0
  br i1 %tobool94, label %if.then95, label %if.end108

if.then95:                                        ; preds = %if.then91
  %hdev96 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %17 = load %struct.usb_device*, %struct.usb_device** %hdev96, align 8, !tbaa !176
  %18 = load i32, i32* %port1, align 4, !tbaa !73
  %call97 = call i32 @usb_clear_port_feature(%struct.usb_device* %17, i32 %18, i32 25)
  br label %if.end108

if.else99:                                        ; preds = %if.then85
  %and101 = and i32 %conv92, 4
  %tobool102 = icmp ne i32 %and101, 0
  br i1 %tobool102, label %if.then103, label %if.end108

if.then103:                                       ; preds = %if.else99
  %hdev104 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %19 = load %struct.usb_device*, %struct.usb_device** %hdev104, align 8, !tbaa !176
  %20 = load i32, i32* %port1, align 4, !tbaa !73
  %call105 = call i32 @usb_clear_port_feature(%struct.usb_device* %19, i32 %20, i32 18)
  br label %if.end108

if.end108:                                        ; preds = %if.then103, %if.else99, %if.then95, %if.then91, %SuspendCleared
  %persist_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load109 = load i16, i16* %persist_enabled, align 4
  %bf.lshr110 = lshr i16 %bf.load109, 1
  %bf.clear111 = and i16 %bf.lshr110, 1
  %bf.cast = zext i16 %bf.clear111 to i32
  %tobool112 = icmp ne i32 %bf.cast, 0
  br i1 %tobool112, label %if.then113, label %if.end115

if.then113:                                       ; preds = %if.end108
  %call114 = call i32 @wait_for_connected(%struct.usb_device* %udev, %struct.usb_hub* %call, i32* %port1, i16* %portchange, i16* %portstatus)
  br label %if.end115

if.end115:                                        ; preds = %if.then113, %if.end108
  %status.3 = phi i32 [ %call114, %if.then113 ], [ %status.2, %if.end108 ]
  %21 = load i32, i32* %port1, align 4, !tbaa !73
  %22 = load i16, i16* %portchange, align 2, !tbaa !165
  %23 = load i16, i16* %portstatus, align 2, !tbaa !165
  %call116 = call i32 @check_port_resume_type(%struct.usb_device* %udev, %struct.usb_hub* %call, i32 %21, i32 %status.3, i16 zeroext %22, i16 zeroext %23)
  %cmp117 = icmp eq i32 %call116, 0
  br i1 %cmp117, label %if.then119, label %if.end121

if.then119:                                       ; preds = %if.end115
  %call120 = call i32 @finish_port_resume(%struct.usb_device* %udev)
  br label %if.end121

if.end121:                                        ; preds = %if.then119, %if.end115
  %status.4 = phi i32 [ %call120, %if.then119 ], [ %call116, %if.end115 ]
  %cmp122 = icmp slt i32 %status.4, 0
  br i1 %cmp122, label %do.body126, label %if.else146

do.body126:                                       ; preds = %if.end121
  %bf.load127 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_resume.descriptor.34 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr128 = lshr i32 %bf.load127, 18
  %bf.clear129 = and i32 %bf.lshr128, 255
  %and130 = and i32 %bf.clear129, 1
  %tobool131 = icmp ne i32 %and130, 0
  %lnot132 = xor i1 %tobool131, true
  %lnot134 = xor i1 %lnot132, true
  %lnot.ext135 = zext i1 %lnot134 to i32
  %conv136 = sext i32 %lnot.ext135 to i64
  %expval137 = call i64 @llvm.expect.i64(i64 %conv136, i64 0)
  %tobool138 = icmp ne i64 %expval137, 0
  br i1 %tobool138, label %if.then139, label %do.end145

if.then139:                                       ; preds = %do.body126
  %dev140 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_resume.descriptor.34 to %struct._ddebug*), %struct.device* %dev140, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.31, i32 0, i32 0), i32 %status.4)
  br label %do.end145

do.end145:                                        ; preds = %if.then139, %do.body126
  %24 = load i32, i32* %port1, align 4, !tbaa !73
  call void @hub_port_logical_disconnect(%struct.usb_hub* %call, i32 %24)
  br label %if.end156

if.else146:                                       ; preds = %if.end121
  %usb2_hw_lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load147 = load i16, i16* %usb2_hw_lpm_capable, align 4
  %bf.lshr148 = lshr i16 %bf.load147, 7
  %bf.clear149 = and i16 %bf.lshr148, 1
  %bf.cast150 = zext i16 %bf.clear149 to i32
  %cmp151 = icmp eq i32 %bf.cast150, 1
  br i1 %cmp151, label %if.then153, label %if.end155

if.then153:                                       ; preds = %if.else146
  %call154 = call i32 @usb_set_usb2_hardware_lpm(%struct.usb_device* %udev, i32 1)
  br label %if.end155

if.end155:                                        ; preds = %if.then153, %if.else146
  call void @usb_enable_ltm(%struct.usb_device* %udev)
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %udev)
  br label %if.end156

if.end156:                                        ; preds = %if.end155, %do.end145
  call void @usb_unlock_port(%struct.usb_port* %3)
  br label %cleanup

cleanup:                                          ; preds = %if.end156, %if.then12, %do.body8
  %retval.0 = phi i32 [ %status.4, %if.end156 ], [ %call5, %if.then12 ], [ %call5, %do.body8 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @port_is_suspended(%struct.usb_hub* %hub, i32 %portstatus) #0 {
entry:
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool = icmp ne i32 %call, 0
  %and2 = and i32 %portstatus, 4
  %tobool3 = icmp ne i32 %and2, 0
  %and = and i32 %portstatus, 480
  %cmp = icmp eq i32 %and, 96
  %tobool3.sink = select i1 %tobool, i1 %cmp, i1 %tobool3
  %.1 = select i1 %tobool3.sink, i32 1, i32 0
  ret i32 %.1
}

; Function Attrs: nounwind uwtable
define internal i32 @wait_for_connected(%struct.usb_device* %udev, %struct.usb_hub* %hub, i32* %port1, i16* %portchange, i16* %portstatus) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %status.0 = phi i32 [ 0, %entry ], [ %call, %if.end ]
  %delay_ms.0 = phi i32 [ 0, %entry ], [ %add, %if.end ]
  %cmp = icmp sge i32 %delay_ms.0, 2000
  %tobool = icmp ne i32 %status.0, 0
  %or.cond = or i1 %cmp, %tobool
  br i1 %or.cond, label %do.body2, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.cond
  %0 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 1
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %do.body2, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  call void @msleep(i32 20)
  %add = add nsw i32 %delay_ms.0, 20
  %1 = load i32, i32* %port1, align 4, !tbaa !73
  %call = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %1, i16* %portstatus, i16* %portchange)
  br label %while.cond

do.body2:                                         ; preds = %lor.lhs.false, %while.cond
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @wait_for_connected.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and3 = and i32 %bf.clear, 1
  %tobool4 = icmp ne i32 %and3, 0
  %lnot = xor i1 %tobool4, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then8, label %do.end11

if.then8:                                         ; preds = %do.body2
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @wait_for_connected.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.66, i32 0, i32 0), i32 %delay_ms.0)
  br label %do.end11

do.end11:                                         ; preds = %if.then8, %do.body2
  ret i32 %status.0
}

; Function Attrs: nounwind uwtable
define internal i32 @check_port_resume_type(%struct.usb_device* %udev, %struct.usb_hub* %hub, i32 %port1, i32 %status, i16 zeroext %portchange, i16 zeroext %portstatus) #0 {
entry:
  %portchange.addr = alloca i16, align 2
  %portstatus.addr = alloca i16, align 2
  store i16 %portchange, i16* %portchange.addr, align 2, !tbaa !165
  store i16 %portstatus, i16* %portstatus.addr, align 2, !tbaa !165
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %0 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %0, i64 %idxprom
  %1 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  br label %retry

retry:                                            ; preds = %if.then18, %entry
  %status.addr.0 = phi i32 [ %status, %entry ], [ %call19, %if.then18 ]
  %retries.0 = phi i32 [ 3, %entry ], [ %dec, %if.then18 ]
  %cond = icmp eq i32 %status.addr.0, 0
  br i1 %cond, label %land.lhs.true, label %if.then9

land.lhs.true:                                    ; preds = %retry
  %reset_resume = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load = load i8, i8* %reset_resume, align 8
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %land.lhs.true1, label %if.else

land.lhs.true1:                                   ; preds = %land.lhs.true
  %2 = load i16, i16* %portstatus.addr, align 2, !tbaa !165
  %call = call zeroext i1 @hub_port_warm_reset_required(%struct.usb_hub* %hub, i32 %port1, i16 zeroext %2)
  br i1 %call, label %if.end47, label %if.else

if.else:                                          ; preds = %land.lhs.true1, %land.lhs.true
  %tobool2 = icmp ne i32 %status.addr.0, 0
  br i1 %tobool2, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %3 = load i16, i16* %portstatus.addr, align 2, !tbaa !165
  %conv = zext i16 %3 to i32
  %call3 = call i32 @port_is_suspended(%struct.usb_hub* %hub, i32 %conv)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then9, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %4 = load i16, i16* %portstatus.addr, align 2, !tbaa !165
  %conv6 = zext i16 %4 to i32
  %call7 = call i32 @port_is_power_on(%struct.usb_hub* %hub, i32 %conv6)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.else13, label %if.then9

if.then9:                                         ; preds = %lor.lhs.false5, %lor.lhs.false, %if.else, %retry
  %cmp10 = icmp sge i32 %status.addr.0, 0
  %.status.addr.0 = select i1 %cmp10, i32 -19, i32 %status.addr.0
  br label %if.end47

if.else13:                                        ; preds = %lor.lhs.false5
  %5 = load i16, i16* %portstatus.addr, align 2, !tbaa !165
  %conv14 = zext i16 %5 to i32
  %and = and i32 %conv14, 1
  %tobool15 = icmp ne i32 %and, 0
  br i1 %tobool15, label %if.else21, label %if.then16

if.then16:                                        ; preds = %if.else13
  %dec = add nsw i32 %retries.0, -1
  %tobool17 = icmp ne i32 %retries.0, 0
  br i1 %tobool17, label %if.then18, label %if.end47

if.then18:                                        ; preds = %if.then16
  call void @usleep_range(i64 200, i64 300)
  %call19 = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1, i16* %portstatus.addr, i16* %portchange.addr)
  br label %retry

if.else21:                                        ; preds = %if.else13
  %6 = load i16, i16* %portstatus.addr, align 2, !tbaa !165
  %conv22 = zext i16 %6 to i32
  %and23 = and i32 %conv22, 2
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.end47, label %land.lhs.true25

land.lhs.true25:                                  ; preds = %if.else21
  %reset_resume26 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load27 = load i8, i8* %reset_resume26, align 8
  %bf.lshr28 = lshr i8 %bf.load27, 1
  %bf.clear29 = and i8 %bf.lshr28, 1
  %bf.cast30 = zext i8 %bf.clear29 to i32
  %tobool31 = icmp ne i32 %bf.cast30, 0
  br i1 %tobool31, label %if.end47, label %if.then32

if.then32:                                        ; preds = %land.lhs.true25
  %persist_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load33 = load i16, i16* %persist_enabled, align 4
  %bf.lshr34 = lshr i16 %bf.load33, 1
  %bf.clear35 = and i16 %bf.lshr34, 1
  %bf.cast36 = zext i16 %bf.clear35 to i32
  %tobool37 = icmp ne i32 %bf.cast36, 0
  br i1 %tobool37, label %if.then38, label %if.end47

if.then38:                                        ; preds = %if.then32
  %reset_resume39 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load40 = load i8, i8* %reset_resume39, align 8
  %bf.clear41 = and i8 %bf.load40, -3
  %bf.set = or i8 %bf.clear41, 2
  store i8 %bf.set, i8* %reset_resume39, align 8
  br label %if.end47

if.end47:                                         ; preds = %if.then38, %if.then32, %land.lhs.true25, %if.else21, %if.then16, %if.then9, %land.lhs.true1
  %status.addr.6 = phi i32 [ %status.addr.0, %land.lhs.true1 ], [ %.status.addr.0, %if.then9 ], [ -19, %if.then16 ], [ %status.addr.0, %if.else21 ], [ %status.addr.0, %land.lhs.true25 ], [ %status.addr.0, %if.then38 ], [ -19, %if.then32 ]
  %tobool48 = icmp ne i32 %status.addr.6, 0
  br i1 %tobool48, label %do.body50, label %if.else65

do.body50:                                        ; preds = %if.end47
  %bf.load51 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @check_port_resume_type.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr52 = lshr i32 %bf.load51, 18
  %bf.clear53 = and i32 %bf.lshr52, 255
  %and54 = and i32 %bf.clear53, 1
  %tobool55 = icmp ne i32 %and54, 0
  %lnot = xor i1 %tobool55, true
  %lnot56 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot56 to i32
  %conv57 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv57, i64 0)
  %tobool58 = icmp ne i64 %expval, 0
  br i1 %tobool58, label %if.then59, label %if.end87

if.then59:                                        ; preds = %do.body50
  %dev = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  %7 = load i16, i16* %portchange.addr, align 2, !tbaa !165
  %conv60 = zext i16 %7 to i32
  %8 = load i16, i16* %portstatus.addr, align 2, !tbaa !165
  %conv61 = zext i16 %8 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @check_port_resume_type.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.67, i32 0, i32 0), i32 %conv60, i32 %conv61, i32 %status.addr.6)
  br label %if.end87

if.else65:                                        ; preds = %if.end47
  %reset_resume66 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load67 = load i8, i8* %reset_resume66, align 8
  %bf.lshr68 = lshr i8 %bf.load67, 1
  %bf.clear69 = and i8 %bf.lshr68, 1
  %bf.cast70 = zext i8 %bf.clear69 to i32
  %tobool71 = icmp ne i32 %bf.cast70, 0
  br i1 %tobool71, label %if.then72, label %if.end87

if.then72:                                        ; preds = %if.else65
  %9 = load i16, i16* %portchange.addr, align 2, !tbaa !165
  %conv73 = zext i16 %9 to i32
  %and74 = and i32 %conv73, 1
  %tobool75 = icmp ne i32 %and74, 0
  br i1 %tobool75, label %if.then76, label %if.end78

if.then76:                                        ; preds = %if.then72
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %call77 = call i32 @usb_clear_port_feature(%struct.usb_device* %10, i32 %port1, i32 16)
  br label %if.end78

if.end78:                                         ; preds = %if.then76, %if.then72
  %11 = load i16, i16* %portchange.addr, align 2, !tbaa !165
  %conv79 = zext i16 %11 to i32
  %and80 = and i32 %conv79, 2
  %tobool81 = icmp ne i32 %and80, 0
  br i1 %tobool81, label %if.then82, label %if.end87

if.then82:                                        ; preds = %if.end78
  %hdev83 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %12 = load %struct.usb_device*, %struct.usb_device** %hdev83, align 8, !tbaa !176
  %call84 = call i32 @usb_clear_port_feature(%struct.usb_device* %12, i32 %port1, i32 17)
  br label %if.end87

if.end87:                                         ; preds = %if.then82, %if.end78, %if.else65, %if.then59, %do.body50
  ret i32 %status.addr.6
}

; Function Attrs: nounwind uwtable
define internal i32 @finish_port_resume(%struct.usb_device* %udev) #0 {
entry:
  %devstatus = alloca i16, align 2
  store i16 0, i16* %devstatus, align 2, !tbaa !165
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @finish_port_resume.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end9

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %reset_resume = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load4 = load i8, i8* %reset_resume, align 8
  %bf.lshr5 = lshr i8 %bf.load4, 1
  %bf.clear6 = and i8 %bf.lshr5, 1
  %bf.cast = zext i8 %bf.clear6 to i32
  %tobool7 = icmp ne i32 %bf.cast, 0
  %cond = select i1 %tobool7, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.69, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.70, i32 0, i32 0)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @finish_port_resume.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12.957, i32 0, i32 0), i8* %cond)
  br label %do.end9

do.end9:                                          ; preds = %if.then, %entry
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool10 = icmp ne %struct.usb_host_config* %0, null
  %cond11 = select i1 %tobool10, i32 7, i32 6
  call void @usb_set_device_state(%struct.usb_device* %udev, i32 %cond11)
  %reset_resume12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load13 = load i8, i8* %reset_resume12, align 8
  %bf.lshr14 = lshr i8 %bf.load13, 1
  %bf.clear15 = and i8 %bf.lshr14, 1
  %bf.cast16 = zext i8 %bf.clear15 to i32
  %tobool17 = icmp ne i32 %bf.cast16, 0
  br i1 %tobool17, label %if.then18, label %if.end24

if.then18:                                        ; preds = %do.end9
  br label %retry_reset_resume

retry_reset_resume:                               ; preds = %do.end62, %if.then18
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %1 = load i32, i32* %quirks, align 4, !tbaa !199
  %conv19 = zext i32 %1 to i64
  %and20 = and i64 %conv19, 16
  %tobool21 = icmp ne i64 %and20, 0
  br i1 %tobool21, label %if.end24, label %if.else

if.else:                                          ; preds = %retry_reset_resume
  %call = call i32 @usb_reset_and_verify_device(%struct.usb_device* %udev)
  br label %if.end24

if.end24:                                         ; preds = %if.else, %retry_reset_resume, %do.end9
  %status.1 = phi i32 [ 0, %do.end9 ], [ %call, %if.else ], [ -19, %retry_reset_resume ]
  %cmp = icmp eq i32 %status.1, 0
  br i1 %cmp, label %if.then26, label %if.end67

if.then26:                                        ; preds = %if.end24
  store i16 0, i16* %devstatus, align 2, !tbaa !165
  %2 = bitcast i16* %devstatus to i8*
  %call27 = call i32 @usb_get_status(%struct.usb_device* %udev, i32 0, i32 0, i8* %2)
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %land.lhs.true, label %if.end67

land.lhs.true:                                    ; preds = %if.then26
  %reset_resume29 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load30 = load i8, i8* %reset_resume29, align 8
  %bf.lshr31 = lshr i8 %bf.load30, 1
  %bf.clear32 = and i8 %bf.lshr31, 1
  %bf.cast33 = zext i8 %bf.clear32 to i32
  %tobool34 = icmp ne i32 %bf.cast33, 0
  br i1 %tobool34, label %if.end67, label %land.lhs.true35

land.lhs.true35:                                  ; preds = %land.lhs.true
  %persist_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load36 = load i16, i16* %persist_enabled, align 4
  %bf.lshr37 = lshr i16 %bf.load36, 1
  %bf.clear38 = and i16 %bf.lshr37, 1
  %bf.cast39 = zext i16 %bf.clear38 to i32
  %tobool40 = icmp ne i32 %bf.cast39, 0
  br i1 %tobool40, label %do.body43, label %if.end67

do.body43:                                        ; preds = %land.lhs.true35
  %bf.load44 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @finish_port_resume.descriptor.71 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr45 = lshr i32 %bf.load44, 18
  %bf.clear46 = and i32 %bf.lshr45, 255
  %and47 = and i32 %bf.clear46, 1
  %tobool48 = icmp ne i32 %and47, 0
  %lnot49 = xor i1 %tobool48, true
  %lnot51 = xor i1 %lnot49, true
  %lnot.ext52 = zext i1 %lnot51 to i32
  %conv53 = sext i32 %lnot.ext52 to i64
  %expval54 = call i64 @llvm.expect.i64(i64 %conv53, i64 0)
  %tobool55 = icmp ne i64 %expval54, 0
  br i1 %tobool55, label %if.then56, label %do.end62

if.then56:                                        ; preds = %do.body43
  %dev57 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @finish_port_resume.descriptor.71 to %struct._ddebug*), %struct.device* %dev57, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.72, i32 0, i32 0))
  br label %do.end62

do.end62:                                         ; preds = %if.then56, %do.body43
  %reset_resume63 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load64 = load i8, i8* %reset_resume63, align 8
  %bf.clear65 = and i8 %bf.load64, -3
  %bf.set = or i8 %bf.clear65, 2
  store i8 %bf.set, i8* %reset_resume63, align 8
  br label %retry_reset_resume

if.end67:                                         ; preds = %land.lhs.true35, %land.lhs.true, %if.then26, %if.end24
  %status.2 = phi i32 [ %status.1, %if.end24 ], [ %call27, %land.lhs.true35 ], [ %call27, %land.lhs.true ], [ %call27, %if.then26 ]
  %tobool68 = icmp ne i32 %status.2, 0
  br i1 %tobool68, label %do.body71, label %if.else91

do.body71:                                        ; preds = %if.end67
  %bf.load72 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @finish_port_resume.descriptor.73 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr73 = lshr i32 %bf.load72, 18
  %bf.clear74 = and i32 %bf.lshr73, 255
  %and75 = and i32 %bf.clear74, 1
  %tobool76 = icmp ne i32 %and75, 0
  %lnot77 = xor i1 %tobool76, true
  %lnot79 = xor i1 %lnot77, true
  %lnot.ext80 = zext i1 %lnot79 to i32
  %conv81 = sext i32 %lnot.ext80 to i64
  %expval82 = call i64 @llvm.expect.i64(i64 %conv81, i64 0)
  %tobool83 = icmp ne i64 %expval82, 0
  br i1 %tobool83, label %if.then84, label %if.end147

if.then84:                                        ; preds = %do.body71
  %dev85 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @finish_port_resume.descriptor.73 to %struct._ddebug*), %struct.device* %dev85, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.74, i32 0, i32 0), i32 %status.2)
  br label %if.end147

if.else91:                                        ; preds = %if.end67
  %actconfig92 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %3 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig92, align 8, !tbaa !102
  %tobool93 = icmp ne %struct.usb_host_config* %3, null
  br i1 %tobool93, label %land.lhs.true94, label %if.end147

land.lhs.true94:                                  ; preds = %if.else91
  %reset_resume95 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load96 = load i8, i8* %reset_resume95, align 8
  %bf.lshr97 = lshr i8 %bf.load96, 1
  %bf.clear98 = and i8 %bf.lshr97, 1
  %bf.cast99 = zext i8 %bf.clear98 to i32
  %tobool100 = icmp ne i32 %bf.cast99, 0
  br i1 %tobool100, label %if.end147, label %if.then101

if.then101:                                       ; preds = %land.lhs.true94
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %4 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp102 = icmp ult i32 %4, 5
  br i1 %cmp102, label %if.then104, label %if.else111

if.then104:                                       ; preds = %if.then101
  %5 = load i16, i16* %devstatus, align 2, !tbaa !165
  %conv105 = zext i16 %5 to i32
  %and106 = and i32 %conv105, 2
  %tobool107 = icmp ne i32 %and106, 0
  br i1 %tobool107, label %if.then108, label %if.end121

if.then108:                                       ; preds = %if.then104
  %call109 = call i32 @usb_disable_remote_wakeup(%struct.usb_device* %udev)
  br label %if.end121

if.else111:                                       ; preds = %if.then101
  %6 = bitcast i16* %devstatus to i8*
  %call112 = call i32 @usb_get_status(%struct.usb_device* %udev, i32 1, i32 0, i8* %6)
  %tobool113 = icmp ne i32 %call112, 0
  br i1 %tobool113, label %if.end121, label %land.lhs.true114

land.lhs.true114:                                 ; preds = %if.else111
  %7 = load i16, i16* %devstatus, align 2, !tbaa !165
  %conv115 = zext i16 %7 to i32
  %and116 = and i32 %conv115, 3
  %tobool117 = icmp ne i32 %and116, 0
  br i1 %tobool117, label %if.then118, label %if.end121

if.then118:                                       ; preds = %land.lhs.true114
  %call119 = call i32 @usb_disable_remote_wakeup(%struct.usb_device* %udev)
  br label %if.end121

if.end121:                                        ; preds = %if.then118, %land.lhs.true114, %if.else111, %if.then108, %if.then104
  %status.5 = phi i32 [ %call109, %if.then108 ], [ %status.2, %if.then104 ], [ %call112, %if.else111 ], [ %call119, %if.then118 ], [ %call112, %land.lhs.true114 ]
  %tobool122 = icmp ne i32 %status.5, 0
  br i1 %tobool122, label %do.body125, label %if.end147

do.body125:                                       ; preds = %if.end121
  %bf.load126 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @finish_port_resume.descriptor.75 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr127 = lshr i32 %bf.load126, 18
  %bf.clear128 = and i32 %bf.lshr127, 255
  %and129 = and i32 %bf.clear128, 1
  %tobool130 = icmp ne i32 %and129, 0
  %lnot131 = xor i1 %tobool130, true
  %lnot133 = xor i1 %lnot131, true
  %lnot.ext134 = zext i1 %lnot133 to i32
  %conv135 = sext i32 %lnot.ext134 to i64
  %expval136 = call i64 @llvm.expect.i64(i64 %conv135, i64 0)
  %tobool137 = icmp ne i64 %expval136, 0
  br i1 %tobool137, label %if.then138, label %if.end147

if.then138:                                       ; preds = %do.body125
  %dev139 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @finish_port_resume.descriptor.75 to %struct._ddebug*), %struct.device* %dev139, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.76, i32 0, i32 0), i32 %status.5)
  br label %if.end147

if.end147:                                        ; preds = %if.then138, %do.body125, %if.end121, %land.lhs.true94, %if.else91, %if.then84, %do.body71
  %status.7 = phi i32 [ %status.2, %if.then84 ], [ %status.2, %do.body71 ], [ %status.2, %land.lhs.true94 ], [ %status.2, %if.else91 ], [ 0, %do.body125 ], [ 0, %if.then138 ], [ 0, %if.end121 ]
  ret i32 %status.7
}

; Function Attrs: nounwind uwtable
define internal i32 @port_is_power_on(%struct.usb_hub* %hub, i32 %portstatus) #0 {
entry:
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool = icmp ne i32 %call, 0
  %.sink = select i1 %tobool, i32 512, i32 256
  %and3 = and i32 %portstatus, %.sink
  %tobool4 = icmp ne i32 %and3, 0
  %.1 = select i1 %tobool4, i32 1, i32 0
  ret i32 %.1
}

declare void @usleep_range(i64, i64) #2

; Function Attrs: nounwind uwtable
define i32 @usb_remote_wakeup(%struct.usb_device* %udev) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @device_lock(%struct.device* %dev)
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %0, 8
  br i1 %cmp, label %do.body1, label %if.end12

do.body1:                                         ; preds = %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_remote_wakeup.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.end7

if.then4:                                         ; preds = %do.body1
  %dev5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_remote_wakeup.descriptor to %struct._ddebug*), %struct.device* %dev5, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.24.148, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.35, i32 0, i32 0))
  br label %do.end7

do.end7:                                          ; preds = %if.then4, %do.body1
  %call = call i32 @usb_autoresume_device(%struct.usb_device* %udev)
  %cmp8 = icmp eq i32 %call, 0
  br i1 %cmp8, label %if.then10, label %if.end12

if.then10:                                        ; preds = %do.end7
  call void @usb_autosuspend_device(%struct.usb_device* %udev)
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %do.end7, %entry
  %status.0 = phi i32 [ 0, %entry ], [ %call, %if.then10 ], [ %call, %do.end7 ]
  %dev13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev13)
  ret i32 %status.0
}

; Function Attrs: nounwind uwtable
define i32 @hub_port_debounce(%struct.usb_hub* %hub, i32 %port1, i1 zeroext %must_be_connected) #0 {
entry:
  %portchange = alloca i16, align 2
  %portstatus = alloca i16, align 2
  %frombool = zext i1 %must_be_connected to i8
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %0 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %0, i64 %idxprom
  %1 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  br label %for.cond

for.cond:                                         ; preds = %if.end27, %entry
  %connection.0 = phi i32 [ 65535, %entry ], [ %connection.1, %if.end27 ]
  %total_time.0 = phi i32 [ 0, %entry ], [ %add28, %if.end27 ]
  %stable_time.0 = phi i32 [ 0, %entry ], [ %stable_time.2, %if.end27 ]
  %call = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1, i16* %portstatus, i16* %portchange)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %for.cond
  %2 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv = zext i16 %2 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %3 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv1 = zext i16 %3 to i32
  %and2 = and i32 %conv1, 1
  %cmp3 = icmp eq i32 %and2, %connection.0
  br i1 %cmp3, label %if.then5, label %if.else

if.then5:                                         ; preds = %land.lhs.true
  %tobool6 = trunc i8 %frombool to i1
  %tobool6.not = xor i1 %tobool6, true
  %cmp7 = icmp eq i32 %connection.0, 1
  %or.cond = or i1 %tobool6.not, %cmp7
  %add = add nsw i32 %stable_time.0, 25
  %stable_time.1 = select i1 %or.cond, i32 %add, i32 %stable_time.0
  %cmp11 = icmp sge i32 %stable_time.1, 100
  br i1 %cmp11, label %do.body29, label %if.end17

if.else:                                          ; preds = %land.lhs.true, %if.end
  %4 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv15 = zext i16 %4 to i32
  %and16 = and i32 %conv15, 1
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.then5
  %connection.1 = phi i32 [ %and16, %if.else ], [ %connection.0, %if.then5 ]
  %stable_time.2 = phi i32 [ 0, %if.else ], [ %stable_time.1, %if.then5 ]
  %5 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv18 = zext i16 %5 to i32
  %and19 = and i32 %conv18, 1
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.end17
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %call22 = call i32 @usb_clear_port_feature(%struct.usb_device* %6, i32 %port1, i32 16)
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end17
  %cmp24 = icmp sge i32 %total_time.0, 2000
  br i1 %cmp24, label %do.body29, label %if.end27

if.end27:                                         ; preds = %if.end23
  call void @msleep(i32 25)
  %add28 = add nsw i32 %total_time.0, 25
  br label %for.cond

do.body29:                                        ; preds = %if.end23, %if.then5
  %stable_time.3 = phi i32 [ %stable_time.1, %if.then5 ], [ %stable_time.2, %if.end23 ]
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_debounce.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and30 = and i32 %bf.clear, 1
  %tobool31 = icmp ne i32 %and30, 0
  %lnot = xor i1 %tobool31, true
  %lnot32 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot32 to i32
  %conv33 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv33, i64 0)
  %tobool34 = icmp ne i64 %expval, 0
  br i1 %tobool34, label %if.then35, label %do.end39

if.then35:                                        ; preds = %do.body29
  %dev = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  %7 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv36 = zext i16 %7 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_debounce.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.37, i32 0, i32 0), i32 %total_time.0, i32 %stable_time.3, i32 %conv36)
  br label %do.end39

do.end39:                                         ; preds = %if.then35, %do.body29
  %cmp40 = icmp slt i32 %stable_time.3, 100
  br i1 %cmp40, label %cleanup, label %if.end43

if.end43:                                         ; preds = %do.end39
  %8 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv44 = zext i16 %8 to i32
  br label %cleanup

cleanup:                                          ; preds = %if.end43, %do.end39, %for.cond
  %retval.0 = phi i32 [ %conv44, %if.end43 ], [ %call, %for.cond ], [ -110, %do.end39 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_hub_init() #0 {
entry:
  %call = call i32 @usb_register_driver(%struct.usb_driver* @hub_driver, %struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1016, i32 0, i32 0))
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = call i32 (i8*, ...) @printk(i8* null)
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call %struct.workqueue_struct* (i8*, i32, i32, %struct.lock_class_key*, i8*, ...) @__alloc_workqueue_key(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.40, i32 0, i32 0), i32 4, i32 0, %struct.lock_class_key* @usb_hub_init.__key, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.39, i32 0, i32 0))
  store %struct.workqueue_struct* %call2, %struct.workqueue_struct** @hub_wq, align 8, !tbaa !52
  %1 = load %struct.workqueue_struct*, %struct.workqueue_struct** @hub_wq, align 8, !tbaa !52
  %tobool = icmp ne %struct.workqueue_struct* %1, null
  br i1 %tobool, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  call void @usb_deregister(%struct.usb_driver* @hub_driver)
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %return

return:                                           ; preds = %if.end4, %if.end, %if.then
  %retval.0 = phi i32 [ -1, %if.then ], [ -1, %if.end4 ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare %struct.workqueue_struct* @__alloc_workqueue_key(i8*, i32, i32, %struct.lock_class_key*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define internal i32 @hub_probe(%struct.usb_interface* %intf, %struct.usb_device_id* %id) #0 {
entry:
  %.compoundliteral = alloca %union.anon.3, align 8
  %.compoundliteral82 = alloca %union.anon.3, align 8
  %.compoundliteral115 = alloca %union.anon.3, align 8
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %0 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !169
  %call = call %struct.usb_device* @interface_to_usbdev(%struct.usb_interface* %intf)
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 11
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %autosuspend_delay = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 19
  %1 = load i32, i32* %autosuspend_delay, align 4, !tbaa !283
  %cmp = icmp sge i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 11
  call void @pm_runtime_set_autosuspend_delay(%struct.device* %dev1, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 8
  %2 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool = icmp ne %struct.usb_device* %2, null
  br i1 %tobool, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  call void @usb_enable_autosuspend(%struct.usb_device* %call)
  br label %if.end8

if.else:                                          ; preds = %if.end
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 9
  %3 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call3 = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %3)
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call3, i32 0, i32 8
  %4 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %bus_suspend = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %4, i32 0, i32 20
  %5 = load i32 (%struct.usb_hcd*)*, i32 (%struct.usb_hcd*)** %bus_suspend, align 8, !tbaa !284
  %tobool4 = icmp ne i32 (%struct.usb_hcd*)* %5, null
  br i1 %tobool4, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %if.else
  %bus_resume = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %4, i32 0, i32 21
  %6 = load i32 (%struct.usb_hcd*)*, i32 (%struct.usb_hcd*)** %bus_resume, align 8, !tbaa !285
  %tobool5 = icmp ne i32 (%struct.usb_hcd*)* %6, null
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %land.lhs.true
  call void @usb_enable_autosuspend(%struct.usb_device* %call)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %land.lhs.true, %if.else, %if.then2
  %level = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 21
  %7 = load i8, i8* %level, align 1, !tbaa !78
  %conv = zext i8 %7 to i32
  %cmp9 = icmp eq i32 %conv, 6
  br i1 %cmp9, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end8
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end13:                                         ; preds = %if.end8
  %parent14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 8
  %8 = load %struct.usb_device*, %struct.usb_device** %parent14, align 8, !tbaa !79
  %tobool15 = icmp ne %struct.usb_device* %8, null
  br i1 %tobool15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end13
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

if.end18:                                         ; preds = %if.end13
  %desc19 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 0
  %bInterfaceSubClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc19, i32 0, i32 6
  %9 = load i8, i8* %bInterfaceSubClass, align 2, !tbaa !286
  %conv20 = zext i8 %9 to i32
  %cmp21 = icmp ne i32 %conv20, 0
  br i1 %cmp21, label %land.lhs.true23, label %if.end31

land.lhs.true23:                                  ; preds = %if.end18
  %desc24 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 0
  %bInterfaceSubClass25 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc24, i32 0, i32 6
  %10 = load i8, i8* %bInterfaceSubClass25, align 2, !tbaa !286
  %conv26 = zext i8 %10 to i32
  %cmp27 = icmp ne i32 %conv26, 1
  br i1 %cmp27, label %descriptor_error, label %if.end31

descriptor_error:                                 ; preds = %if.end37, %if.end31, %land.lhs.true23
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end31:                                         ; preds = %land.lhs.true23, %if.end18
  %desc32 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc32, i32 0, i32 4
  %11 = load i8, i8* %bNumEndpoints, align 4, !tbaa !172
  %conv33 = zext i8 %11 to i32
  %cmp34 = icmp ne i32 %conv33, 1
  br i1 %cmp34, label %descriptor_error, label %if.end37

if.end37:                                         ; preds = %if.end31
  %endpoint38 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 3
  %12 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint38, align 8, !tbaa !173
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %12, i64 0
  %desc39 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 0
  %call40 = call i32 @usb_endpoint_is_int_in(%struct.usb_endpoint_descriptor* %desc39)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.end43, label %descriptor_error

if.end43:                                         ; preds = %if.end37
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %call45 = call i8* @kzalloc.36(i64 984, i32 20971712)
  %13 = bitcast i8* %call45 to %struct.usb_hub*
  %tobool46 = icmp ne %struct.usb_hub* %13, null
  br i1 %tobool46, label %if.end48, label %cleanup

if.end48:                                         ; preds = %if.end43
  %kref = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 2
  call void @kref_init(%struct.kref* %kref)
  %dev49 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 0
  store %struct.device* %dev49, %struct.device** %intfdev, align 8, !tbaa !204
  %hdev50 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 1
  store %struct.usb_device* %call, %struct.usb_device** %hdev50, align 8, !tbaa !176
  %leds = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 22
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %leds, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work, i32 0)
  %leds52 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 22
  %work53 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %leds52, i32 0, i32 0
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work53, i32 0, i32 0
  %counter = getelementptr inbounds %union.anon.3, %union.anon.3* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !287
  %14 = bitcast %union.anon.3* %data to i8*
  %15 = bitcast %union.anon.3* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %15, i64 8, i32 8, i1 false), !tbaa.struct !288
  %leds54 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 22
  %work55 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %leds54, i32 0, i32 0
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work55, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.101, i32 0, i32 0), %struct.lock_class_key* @hub_probe.__key, i32 0)
  %leds56 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 22
  %work57 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %leds56, i32 0, i32 0
  %entry58 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work57, i32 0, i32 1
  call void @INIT_LIST_HEAD.35(%struct.list_head* %entry58)
  %leds59 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 22
  %work60 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %leds59, i32 0, i32 0
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work60, i32 0, i32 2
  store void (%struct.work_struct*)* @led_work, void (%struct.work_struct*)** %func, align 8, !tbaa !289
  %leds63 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 22
  %timer = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %leds63, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer, i32 2097152, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.103, i32 0, i32 0), %struct.lock_class_key* @hub_probe.__key.102)
  %leds66 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 22
  %timer67 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %leds66, i32 0, i32 1
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer67, i32 0, i32 2
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function, align 8, !tbaa !290
  %leds68 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 22
  %16 = ptrtoint %struct.delayed_work* %leds68 to i64
  %leds69 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 22
  %timer70 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %leds69, i32 0, i32 1
  %data71 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer70, i32 0, i32 3
  store i64 %16, i64* %data71, align 8, !tbaa !291
  %init_work = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 23
  %work78 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work78, i32 0)
  %init_work79 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 23
  %work80 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work79, i32 0, i32 0
  %data81 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work80, i32 0, i32 0
  %counter83 = getelementptr inbounds %union.anon.3, %union.anon.3* %.compoundliteral82, i32 0, i32 0
  store i64 137438953408, i64* %counter83, align 8, !tbaa !287
  %17 = bitcast %union.anon.3* %data81 to i8*
  %18 = bitcast %union.anon.3* %.compoundliteral82 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 8, i32 8, i1 false), !tbaa.struct !288
  %init_work84 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 23
  %work85 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work84, i32 0, i32 0
  %lockdep_map86 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work85, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map86, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.105, i32 0, i32 0), %struct.lock_class_key* @hub_probe.__key.104, i32 0)
  %init_work87 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 23
  %work88 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work87, i32 0, i32 0
  %entry89 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work88, i32 0, i32 1
  call void @INIT_LIST_HEAD.35(%struct.list_head* %entry89)
  %init_work90 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 23
  %work91 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work90, i32 0, i32 0
  %func92 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work91, i32 0, i32 2
  store void (%struct.work_struct*)* null, void (%struct.work_struct*)** %func92, align 8, !tbaa !289
  %init_work97 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 23
  %timer98 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work97, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer98, i32 2097152, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.107, i32 0, i32 0), %struct.lock_class_key* @hub_probe.__key.106)
  %init_work101 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 23
  %timer102 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work101, i32 0, i32 1
  %function103 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer102, i32 0, i32 2
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function103, align 8, !tbaa !290
  %init_work104 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 23
  %19 = ptrtoint %struct.delayed_work* %init_work104 to i64
  %init_work105 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 23
  %timer106 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work105, i32 0, i32 1
  %data107 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer106, i32 0, i32 3
  store i64 %19, i64* %data107, align 8, !tbaa !291
  %events = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 24
  call void @__init_work(%struct.work_struct* %events, i32 0)
  %events113 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 24
  %data114 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %events113, i32 0, i32 0
  %counter116 = getelementptr inbounds %union.anon.3, %union.anon.3* %.compoundliteral115, i32 0, i32 0
  store i64 137438953408, i64* %counter116, align 8, !tbaa !287
  %20 = bitcast %union.anon.3* %data114 to i8*
  %21 = bitcast %union.anon.3* %.compoundliteral115 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %20, i8* %21, i64 8, i32 8, i1 false), !tbaa.struct !288
  %events117 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 24
  %lockdep_map118 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %events117, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map118, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.109, i32 0, i32 0), %struct.lock_class_key* @hub_probe.__key.108, i32 0)
  %events119 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 24
  %entry120 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %events119, i32 0, i32 1
  call void @INIT_LIST_HEAD.35(%struct.list_head* %entry120)
  %events121 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 24
  %func122 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %events121, i32 0, i32 2
  store void (%struct.work_struct*)* @hub_event, void (%struct.work_struct*)** %func122, align 8, !tbaa !289
  %call125 = call %struct.usb_interface* @usb_get_intf(%struct.usb_interface* %intf)
  %call126 = call %struct.usb_device* @usb_get_dev(%struct.usb_device* %call)
  %22 = bitcast %struct.usb_hub* %13 to i8*
  call void @usb_set_intfdata(%struct.usb_interface* %intf, i8* %22)
  %needs_remote_wakeup = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load = load i8, i8* %needs_remote_wakeup, align 8
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, 8
  store i8 %bf.set, i8* %needs_remote_wakeup, align 8
  %dev127 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @pm_suspend_ignore_children(%struct.device* %dev127, i1 zeroext true)
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 4
  %23 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp128 = icmp eq i32 %23, 3
  br i1 %cmp128, label %if.then130, label %if.end131

if.then130:                                       ; preds = %if.end48
  %24 = load i32, i32* @highspeed_hubs, align 4, !tbaa !73
  %inc = add i32 %24, 1
  store i32 %inc, i32* @highspeed_hubs, align 4, !tbaa !73
  br label %if.end131

if.end131:                                        ; preds = %if.then130, %if.end48
  %driver_info = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 12
  %25 = load i64, i64* %driver_info, align 8, !tbaa !292
  %and = and i64 %25, 1
  %tobool132 = icmp ne i64 %and, 0
  br i1 %tobool132, label %if.then133, label %if.end137

if.then133:                                       ; preds = %if.end131
  %quirk_check_port_auto_suspend = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %13, i32 0, i32 20
  %bf.load134 = load i8, i8* %quirk_check_port_auto_suspend, align 8
  %bf.clear135 = and i8 %bf.load134, -17
  %bf.set136 = or i8 %bf.clear135, 16
  store i8 %bf.set136, i8* %quirk_check_port_auto_suspend, align 8
  br label %if.end137

if.end137:                                        ; preds = %if.then133, %if.end131
  %call138 = call i32 @hub_configure(%struct.usb_hub* %13, %struct.usb_endpoint_descriptor* %desc39)
  %cmp139 = icmp sge i32 %call138, 0
  br i1 %cmp139, label %cleanup, label %if.end142

if.end142:                                        ; preds = %if.end137
  call void @hub_disconnect(%struct.usb_interface* %intf)
  br label %cleanup

cleanup:                                          ; preds = %if.end142, %if.end137, %if.end43, %descriptor_error, %if.then16, %if.then11
  %retval.0 = phi i32 [ -7, %if.then11 ], [ -19, %if.then16 ], [ -5, %descriptor_error ], [ -19, %if.end142 ], [ -12, %if.end43 ], [ 0, %if.end137 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @hub_disconnect(%struct.usb_interface* %intf) #0 {
entry:
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.usb_hub*
  %call1 = call %struct.usb_device* @interface_to_usbdev(%struct.usb_interface* %intf)
  %disconnected = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 20
  %bf.load = load i8, i8* %disconnected, align 8
  %bf.clear = and i8 %bf.load, -5
  %bf.set = or i8 %bf.clear, 4
  store i8 %bf.set, i8* %disconnected, align 8
  %error = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 7
  store i32 0, i32* %error, align 8, !tbaa !202
  call void @hub_quiesce(%struct.usb_hub* %0, i32 0)
  call void @mutex_lock_nested(%struct.mutex* @usb_port_peer_mutex, i32 0)
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @device_state_lock, i32 0, i32 0, i32 0)) #8
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call1, i32 0, i32 28
  %1 = load i32, i32* %maxchild, align 8, !tbaa !111
  %maxchild2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call1, i32 0, i32 28
  store i32 0, i32* %maxchild2, align 8, !tbaa !111
  call void @usb_set_intfdata(%struct.usb_interface* %intf, i8* null)
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @device_state_lock, i32 0, i32 0, i32 0)) #8
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %port1.0 = phi i32 [ %1, %entry ], [ %dec, %for.body ]
  %cmp = icmp sgt i32 %port1.0, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void bitcast (void (%struct.usb_hub.5605*, i32)* @usb_hub_remove_port_device to void (%struct.usb_hub*, i32)*)(%struct.usb_hub* %0, i32 %port1.0)
  %dec = add nsw i32 %port1.0, -1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @mutex_unlock(%struct.mutex* @usb_port_peer_mutex)
  %hdev3 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %hdev3, align 8, !tbaa !176
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 4
  %3 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp4 = icmp eq i32 %3, 3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %4 = load i32, i32* @highspeed_hubs, align 4, !tbaa !73
  %dec5 = add i32 %4, -1
  store i32 %dec5, i32* @highspeed_hubs, align 4, !tbaa !73
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  %urb = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 3
  %5 = load %struct.urb*, %struct.urb** %urb, align 8, !tbaa !293
  call void bitcast (void (%struct.urb.744*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %5)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 25
  %6 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %7 = bitcast %struct.usb_port** %6 to i8*
  call void @kfree(i8* %7)
  %descriptor = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 16
  %8 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !232
  %9 = bitcast %struct.usb_hub_descriptor* %8 to i8*
  call void @kfree(i8* %9)
  %status = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 5
  %10 = load %union.anon.62*, %union.anon.62** %status, align 8, !tbaa !237
  %11 = bitcast %union.anon.62* %10 to i8*
  call void @kfree(i8* %11)
  %buffer = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 4
  %12 = load [8 x i8]*, [8 x i8]** %buffer, align 8, !tbaa !294
  %13 = bitcast [8 x i8]* %12 to i8*
  call void @kfree(i8* %13)
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @pm_suspend_ignore_children(%struct.device* %dev, i1 zeroext false)
  %kref = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 2
  call void @kref_put(%struct.kref* %kref, void (%struct.kref*)* @hub_release)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_ioctl(%struct.usb_interface* %intf, i32 %code, i8* %user_data) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev(%struct.usb_interface* %intf)
  %call1 = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %call)
  %SwitchLeaf = icmp eq i32 %code, -2139073261
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %entry
  %0 = bitcast i8* %user_data to %struct.usbdevfs_hub_portinfo*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @device_state_lock, i32 0, i32 0, i32 0)) #8
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 0
  %1 = load i32, i32* %devnum, align 8, !tbaa !44
  %cmp = icmp sle i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %nports = getelementptr inbounds %struct.usbdevfs_hub_portinfo, %struct.usbdevfs_hub_portinfo* %0, i32 0, i32 0
  store i8 0, i8* %nports, align 1, !tbaa !295
  br label %if.end22

if.else:                                          ; preds = %sw.bb
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 28
  %2 = load i32, i32* %maxchild, align 8, !tbaa !111
  %conv = trunc i32 %2 to i8
  %nports2 = getelementptr inbounds %struct.usbdevfs_hub_portinfo, %struct.usbdevfs_hub_portinfo* %0, i32 0, i32 0
  store i8 %conv, i8* %nports2, align 1, !tbaa !295
  br label %for.cond

for.cond:                                         ; preds = %if.end, %if.else
  %i.0 = phi i32 [ 0, %if.else ], [ %inc, %if.end ]
  %nports3 = getelementptr inbounds %struct.usbdevfs_hub_portinfo, %struct.usbdevfs_hub_portinfo* %0, i32 0, i32 0
  %3 = load i8, i8* %nports3, align 1, !tbaa !295
  %conv4 = sext i8 %3 to i32
  %cmp5 = icmp slt i32 %i.0, %conv4
  br i1 %cmp5, label %for.body, label %if.end22

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call1, i32 0, i32 25
  %4 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %4, i64 %idxprom
  %5 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %5, i32 0, i32 0
  %6 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !115
  %cmp7 = icmp eq %struct.usb_device* %6, null
  br i1 %cmp7, label %if.end, label %if.else12

if.else12:                                        ; preds = %for.body
  %ports13 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call1, i32 0, i32 25
  %7 = load %struct.usb_port**, %struct.usb_port*** %ports13, align 8, !tbaa !112
  %idxprom14 = sext i32 %i.0 to i64
  %arrayidx15 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %7, i64 %idxprom14
  %8 = load %struct.usb_port*, %struct.usb_port** %arrayidx15, align 8, !tbaa !52
  %child16 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %8, i32 0, i32 0
  %9 = load %struct.usb_device*, %struct.usb_device** %child16, align 8, !tbaa !115
  %devnum17 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %9, i32 0, i32 0
  %10 = load i32, i32* %devnum17, align 8, !tbaa !44
  %conv18 = trunc i32 %10 to i8
  br label %if.end

if.end:                                           ; preds = %if.else12, %for.body
  %conv18.sink = phi i8 [ %conv18, %if.else12 ], [ 0, %for.body ]
  %port19 = getelementptr inbounds %struct.usbdevfs_hub_portinfo, %struct.usbdevfs_hub_portinfo* %0, i32 0, i32 1
  %idxprom20 = sext i32 %i.0 to i64
  %arrayidx21 = getelementptr inbounds [127 x i8], [127 x i8]* %port19, i64 0, i64 %idxprom20
  store i8 %conv18.sink, i8* %arrayidx21, align 1, !tbaa !72
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end22:                                         ; preds = %for.cond, %if.then
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @device_state_lock, i32 0, i32 0, i32 0)) #8
  %nports23 = getelementptr inbounds %struct.usbdevfs_hub_portinfo, %struct.usbdevfs_hub_portinfo* %0, i32 0, i32 0
  %11 = load i8, i8* %nports23, align 1, !tbaa !295
  %conv24 = sext i8 %11 to i32
  %add = add nsw i32 %conv24, 1
  br label %cleanup

cleanup:                                          ; preds = %if.end22, %entry
  %retval.0 = phi i32 [ %add, %if.end22 ], [ -38, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_suspend(%struct.usb_interface* %intf, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.atomic_t, align 4
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.usb_hub*
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !176
  %wakeup_enabled_descendants = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 19
  store i32 0, i32* %wakeup_enabled_descendants, align 4, !tbaa !282
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %port1.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %retval.0 = phi i32 [ undef, %entry ], [ %retval.1, %for.inc ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 28
  %2 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp = icmp ule i32 %port1.0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 25
  %3 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub i32 %port1.0, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %3, i64 %idxprom
  %4 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %4, i32 0, i32 0
  %5 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !115
  %magicptr = ptrtoint %struct.usb_device* %5 to i64
  %cond = icmp eq i64 %magicptr, 0
  br i1 %cond, label %LeafBlock, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %can_submit = getelementptr inbounds %struct.usb_device, %struct.usb_device* %5, i32 0, i32 22
  %bf.load = load i16, i16* %can_submit, align 4
  %bf.clear = and i16 %bf.load, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool2 = icmp ne i32 %bf.cast, 0
  br i1 %tobool2, label %if.then, label %if.end7

if.then:                                          ; preds = %land.lhs.true
  %dev3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %5, i32 0, i32 11
  call void @dev_name(%struct.device* %dev3)
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %6 = load i32, i32* %event, align 4, !tbaa !48
  %and = and i32 %6, 1024
  %cmp5 = icmp ne i32 %and, 0
  br i1 %cmp5, label %LeafBlock, label %if.end7

if.end7:                                          ; preds = %if.then, %land.lhs.true
  %tobool8 = icmp ne %struct.usb_device* %5, null
  br i1 %tobool8, label %if.then9, label %LeafBlock

if.then9:                                         ; preds = %if.end7
  %call10 = call i32 @wakeup_enabled_descendants(%struct.usb_device* %5)
  %wakeup_enabled_descendants11 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 19
  %7 = load i32, i32* %wakeup_enabled_descendants11, align 4, !tbaa !282
  %add = add i32 %7, %call10
  store i32 %add, i32* %wakeup_enabled_descendants11, align 4, !tbaa !282
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.then9, %if.end7, %if.then, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then ], [ 0, %for.body ], [ 0, %if.then9 ], [ 0, %if.end7 ]
  %retval.1 = phi i32 [ -16, %if.then ], [ %retval.0, %for.body ], [ %retval.0, %if.then9 ], [ %retval.0, %if.end7 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup68

for.inc:                                          ; preds = %LeafBlock
  %inc = add i32 %port1.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %do_remote_wakeup = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 33
  %bf.load14 = load i8, i8* %do_remote_wakeup, align 8
  %bf.clear15 = and i8 %bf.load14, 1
  %bf.cast16 = zext i8 %bf.clear15 to i32
  %tobool17 = icmp ne i32 %bf.cast16, 0
  br i1 %tobool17, label %land.lhs.true18, label %if.end34

land.lhs.true18:                                  ; preds = %for.end
  %quirk_check_port_auto_suspend = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 20
  %bf.load19 = load i8, i8* %quirk_check_port_auto_suspend, align 8
  %bf.lshr = lshr i8 %bf.load19, 4
  %bf.clear20 = and i8 %bf.lshr, 1
  %bf.cast21 = zext i8 %bf.clear20 to i32
  %tobool22 = icmp ne i32 %bf.cast21, 0
  br i1 %tobool22, label %if.then23, label %if.end34

if.then23:                                        ; preds = %land.lhs.true18
  %call24 = call i32 @check_ports_changed(%struct.usb_hub* %0)
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %if.then26, label %if.end34

if.then26:                                        ; preds = %if.then23
  %event27 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %8 = load i32, i32* %event27, align 4, !tbaa !48
  %and28 = and i32 %8, 1024
  %cmp29 = icmp ne i32 %and28, 0
  br i1 %cmp29, label %cleanup68, label %if.end31

if.end31:                                         ; preds = %if.then26
  %dev32 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @pm_wakeup_event(%struct.device* %dev32, i32 2000)
  br label %if.end34

if.end34:                                         ; preds = %if.end31, %if.then23, %land.lhs.true18, %for.end
  %call35 = call i32 @hub_is_superspeed(%struct.usb_device* %1)
  %tobool36 = icmp ne i32 %call35, 0
  br i1 %tobool36, label %land.lhs.true37, label %do.body55

land.lhs.true37:                                  ; preds = %if.end34
  %do_remote_wakeup38 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 33
  %bf.load39 = load i8, i8* %do_remote_wakeup38, align 8
  %bf.clear40 = and i8 %bf.load39, 1
  %bf.cast41 = zext i8 %bf.clear40 to i32
  %tobool42 = icmp ne i32 %bf.cast41, 0
  br i1 %tobool42, label %if.then43, label %do.body55

if.then43:                                        ; preds = %land.lhs.true37
  br label %for.cond44

for.cond44:                                       ; preds = %for.body47, %if.then43
  %port1.1 = phi i32 [ 1, %if.then43 ], [ %inc52, %for.body47 ]
  %maxchild45 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 28
  %9 = load i32, i32* %maxchild45, align 8, !tbaa !111
  %cmp46 = icmp ule i32 %port1.1, %9
  br i1 %cmp46, label %for.body47, label %do.body55

for.body47:                                       ; preds = %for.cond44
  %or = or i32 %port1.1, 256
  %or48 = or i32 %or, 512
  %or49 = or i32 %or48, 1024
  %call50 = call i32 @set_port_feature(%struct.usb_device* %1, i32 %or49, i32 27)
  %inc52 = add i32 %port1.1, 1
  br label %for.cond44

do.body55:                                        ; preds = %for.cond44, %land.lhs.true37, %if.end34
  %bf.load56 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_suspend.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr57 = lshr i32 %bf.load56, 18
  %bf.clear58 = and i32 %bf.lshr57, 255
  %and59 = and i32 %bf.clear58, 1
  %tobool60 = icmp ne i32 %and59, 0
  %lnot = xor i1 %tobool60, true
  %lnot61 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot61 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool62 = icmp ne i64 %expval, 0
  br i1 %tobool62, label %if.then63, label %do.end67

if.then63:                                        ; preds = %do.body55
  %dev64 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_suspend.descriptor to %struct._ddebug*), %struct.device* %dev64, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12.957, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.hub_suspend, i32 0, i32 0))
  br label %do.end67

do.end67:                                         ; preds = %if.then63, %do.body55
  call void @hub_quiesce(%struct.usb_hub* %0, i32 2)
  br label %cleanup68

cleanup68:                                        ; preds = %do.end67, %if.then26, %LeafBlock
  %retval.2 = phi i32 [ 0, %do.end67 ], [ -16, %if.then26 ], [ %retval.1, %LeafBlock ]
  ret i32 %retval.2
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_resume(%struct.usb_interface* %intf) #0 {
entry:
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.usb_hub*
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_resume.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end5

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_resume.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12.957, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.hub_resume, i32 0, i32 0))
  br label %do.end5

do.end5:                                          ; preds = %if.then, %entry
  call void @hub_activate(%struct.usb_hub* %0, i32 4)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_reset_resume(%struct.usb_interface* %intf) #0 {
entry:
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.usb_hub*
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_reset_resume.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end5

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_reset_resume.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12.957, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.hub_reset_resume, i32 0, i32 0))
  br label %do.end5

do.end5:                                          ; preds = %if.then, %entry
  call void @hub_activate(%struct.usb_hub* %0, i32 5)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_pre_reset(%struct.usb_interface* %intf) #0 {
entry:
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.usb_hub*
  call void @hub_quiesce(%struct.usb_hub* %0, i32 1)
  %in_reset = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 20
  %bf.load = load i8, i8* %in_reset, align 8
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, 8
  store i8 %bf.set, i8* %in_reset, align 8
  call void @hub_pm_barrier_for_all_ports(%struct.usb_hub* %0)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_post_reset(%struct.usb_interface* %intf) #0 {
entry:
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.usb_hub*
  %in_reset = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 20
  %bf.load = load i8, i8* %in_reset, align 8
  %bf.clear = and i8 %bf.load, -9
  store i8 %bf.clear, i8* %in_reset, align 8
  call void @hub_pm_barrier_for_all_ports(%struct.usb_hub* %0)
  call void @hub_activate(%struct.usb_hub* %0, i32 3)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @hub_pm_barrier_for_all_ports(%struct.usb_hub* %hub) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %1 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp = icmp slt i32 %i.0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %2 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %2, i64 %idxprom
  %3 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %dev = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 1
  %call = call i32 @pm_runtime_barrier(%struct.device* %dev)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_activate(%struct.usb_hub* %hub, i32 %type) #0 {
entry:
  %oldbit.i = alloca i8, align 1
  %.compoundliteral = alloca %union.anon.3, align 8
  %portstatus = alloca i16, align 2
  %portchange = alloca i16, align 2
  %.compoundliteral254 = alloca %union.anon.3, align 8
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !176
  %type.off = add i32 %type, -1
  %switch = icmp ult i32 %type.off, 2
  br i1 %switch, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock(%struct.device* %dev)
  %disconnected = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  %bf.load = load i8, i8* %disconnected, align 8
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %disconnected316, label %if.end

if.end:                                           ; preds = %if.then
  %cmp4 = icmp eq i32 %type, 1
  br i1 %cmp4, label %init2, label %init3

if.end7:                                          ; preds = %entry
  %kref = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 2
  call void @kref_get(%struct.kref* %kref)
  %cmp8 = icmp ne i32 %type, 4
  br i1 %cmp8, label %if.then9, label %init2

if.then9:                                         ; preds = %if.end7
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  %1 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool10 = icmp ne %struct.usb_device* %1, null
  br i1 %tobool10, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.then9
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool11 = icmp ne i32 %call, 0
  br i1 %tobool11, label %if.then12, label %if.end20

if.then12:                                        ; preds = %land.lhs.true
  %call13 = call i32 @__create_pipe(%struct.usb_device* %0, i32 0)
  %or = or i32 -2147483648, %call13
  %level = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 21
  %2 = load i8, i8* %level, align 1, !tbaa !78
  %conv = zext i8 %2 to i32
  %sub = sub nsw i32 %conv, 1
  %conv14 = trunc i32 %sub to i16
  %call15 = call i32 @usb_control_msg(%struct.usb_device* %0, i32 %or, i8 zeroext 12, i8 zeroext 32, i16 zeroext %conv14, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  %cmp16 = icmp slt i32 %call15, 0
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.then12
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.then12, %land.lhs.true, %if.then9
  switch i32 %type, label %if.else70 [
    i32 0, label %if.then23
    i32 5, label %if.then56
  ]

if.then23:                                        ; preds = %if.end20
  %call24 = call i32 @hub_power_on_good_delay(%struct.usb_hub* %hub)
  call void @hub_power_on(%struct.usb_hub* %hub, i1 zeroext false)
  %init_work = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work, i32 0)
  %init_work26 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %work27 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work26, i32 0, i32 0
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work27, i32 0, i32 0
  %counter = getelementptr inbounds %union.anon.3, %union.anon.3* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !287
  %3 = bitcast %union.anon.3* %data to i8*
  %4 = bitcast %union.anon.3* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 8, i32 8, i1 false), !tbaa.struct !288
  %init_work28 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %work29 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work28, i32 0, i32 0
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work29, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.105, i32 0, i32 0), %struct.lock_class_key* @hub_activate.__key, i32 0)
  %init_work30 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %work31 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work30, i32 0, i32 0
  %entry32 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work31, i32 0, i32 1
  call void @INIT_LIST_HEAD.35(%struct.list_head* %entry32)
  %init_work33 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %work34 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work33, i32 0, i32 0
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work34, i32 0, i32 2
  store void (%struct.work_struct*)* @hub_init_func2, void (%struct.work_struct*)** %func, align 8, !tbaa !289
  %init_work37 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %timer = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work37, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer, i32 2097152, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.107, i32 0, i32 0), %struct.lock_class_key* @hub_activate.__key.253)
  %init_work40 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %timer41 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work40, i32 0, i32 1
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer41, i32 0, i32 2
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function, align 8, !tbaa !290
  %init_work42 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %5 = ptrtoint %struct.delayed_work* %init_work42 to i64
  %init_work43 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %timer44 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work43, i32 0, i32 1
  %data45 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer44, i32 0, i32 3
  store i64 %5, i64* %data45, align 8, !tbaa !291
  %6 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_power_efficient_wq, align 8, !tbaa !52
  %init_work50 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %call.i1 = call i64 @__msecs_to_jiffies(i32 %call24) #8
  call void @queue_delayed_work(%struct.workqueue_struct* %6, %struct.delayed_work* %init_work50, i64 %call.i1)
  %intfdev53 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %7 = load %struct.device*, %struct.device** %intfdev53, align 8, !tbaa !204
  %8 = bitcast %struct.device* %7 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 -48
  %9 = bitcast i8* %add.ptr to %struct.usb_interface*
  call void @usb_autopm_get_interface_no_resume(%struct.usb_interface* %9)
  br label %cleanup.cont

if.then56:                                        ; preds = %if.end20
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %10 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call57 = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %10)
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call57, i32 0, i32 8
  %11 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %update_hub_device = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %11, i32 0, i32 36
  %12 = load i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)** %update_hub_device, align 8, !tbaa !297
  %tobool58 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)* %12, null
  br i1 %tobool58, label %if.then59, label %if.end69

if.then59:                                        ; preds = %if.then56
  %driver60 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call57, i32 0, i32 8
  %13 = load %struct.hc_driver*, %struct.hc_driver** %driver60, align 8, !tbaa !57
  %update_hub_device61 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %13, i32 0, i32 36
  %14 = load i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)** %update_hub_device61, align 8, !tbaa !297
  %tt = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %call62 = call i32 %14(%struct.usb_hcd* %call57, %struct.usb_device* %0, %struct.usb_tt* %tt, i32 20971520)
  %cmp63 = icmp slt i32 %call62, 0
  br i1 %cmp63, label %if.then65, label %if.end69

if.then65:                                        ; preds = %if.then59
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end69

if.end69:                                         ; preds = %if.then65, %if.then59, %if.then56
  call void @hub_power_on(%struct.usb_hub* %hub, i1 zeroext true)
  br label %init2

if.else70:                                        ; preds = %if.end20
  call void @hub_power_on(%struct.usb_hub* %hub, i1 zeroext true)
  br label %init2

init2:                                            ; preds = %if.else70, %if.end69, %if.end7, %if.end
  br label %for.cond

for.cond:                                         ; preds = %if.end241, %init2
  %port1.0 = phi i32 [ 1, %init2 ], [ %inc, %if.end241 ]
  %need_debounce_delay.0 = phi i8 [ 0, %init2 ], [ %need_debounce_delay.4, %if.end241 ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %15 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp74 = icmp sle i32 %port1.0, %15
  br i1 %cmp74, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %16 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub76 = sub nsw i32 %port1.0, 1
  %idxprom = sext i32 %sub76 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %16, i64 %idxprom
  %17 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %17, i32 0, i32 0
  %18 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !115
  store i16 0, i16* %portchange, align 2, !tbaa !165
  store i16 0, i16* %portstatus, align 2, !tbaa !165
  %call77 = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1.0, i16* %portstatus, i16* %portchange)
  %tobool78 = icmp ne %struct.usb_device* %18, null
  br i1 %tobool78, label %do.body84, label %lor.lhs.false79

lor.lhs.false79:                                  ; preds = %for.body
  %19 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv80 = zext i16 %19 to i32
  %and = and i32 %conv80, 1
  %tobool81 = icmp ne i32 %and, 0
  br i1 %tobool81, label %do.body84, label %if.end102

do.body84:                                        ; preds = %lor.lhs.false79, %for.body
  %bf.load85 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_activate.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr86 = lshr i32 %bf.load85, 18
  %bf.clear87 = and i32 %bf.lshr86, 255
  %and88 = and i32 %bf.clear87, 1
  %tobool89 = icmp ne i32 %and88, 0
  %lnot = xor i1 %tobool89, true
  %lnot90 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot90 to i32
  %conv91 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv91, i64 0)
  %tobool92 = icmp ne i64 %expval, 0
  br i1 %tobool92, label %if.then93, label %if.end102

if.then93:                                        ; preds = %do.body84
  %dev94 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %17, i32 0, i32 1
  %20 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv95 = zext i16 %20 to i32
  %21 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv96 = zext i16 %21 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_activate.descriptor to %struct._ddebug*), %struct.device* %dev94, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.256, i32 0, i32 0), i32 %conv95, i32 %conv96)
  br label %if.end102

if.end102:                                        ; preds = %if.then93, %do.body84, %lor.lhs.false79
  %22 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv103 = zext i16 %22 to i32
  %and104 = and i32 %conv103, 2
  %tobool105 = icmp ne i32 %and104, 0
  br i1 %tobool105, label %land.lhs.true106, label %if.end127

land.lhs.true106:                                 ; preds = %if.end102
  %cmp107 = icmp ne i32 %type, 4
  br i1 %cmp107, label %if.then118, label %lor.lhs.false109

lor.lhs.false109:                                 ; preds = %land.lhs.true106
  %23 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv110 = zext i16 %23 to i32
  %and111 = and i32 %conv110, 1
  %tobool112 = icmp ne i32 %and111, 0
  %tobool114 = icmp ne %struct.usb_device* %18, null
  %or.cond = and i1 %tobool112, %tobool114
  br i1 %or.cond, label %lor.lhs.false115, label %if.then118

lor.lhs.false115:                                 ; preds = %lor.lhs.false109
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 3
  %24 = load i32, i32* %state, align 8, !tbaa !54
  %cmp116 = icmp eq i32 %24, 0
  br i1 %cmp116, label %if.then118, label %if.end127

if.then118:                                       ; preds = %lor.lhs.false115, %lor.lhs.false109, %land.lhs.true106
  %25 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv119 = zext i16 %25 to i32
  %and120 = and i32 %conv119, -3
  %conv121 = trunc i32 %and120 to i16
  store i16 %conv121, i16* %portstatus, align 2, !tbaa !165
  %call122 = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool123 = icmp ne i32 %call122, 0
  br i1 %tobool123, label %if.end127, label %if.then124

if.then124:                                       ; preds = %if.then118
  %call125 = call i32 @usb_clear_port_feature(%struct.usb_device* %0, i32 %port1.0, i32 1)
  br label %if.end127

if.end127:                                        ; preds = %if.then124, %if.then118, %lor.lhs.false115, %if.end102
  %26 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv128 = zext i16 %26 to i32
  %and129 = and i32 %conv128, 1
  %tobool130 = icmp ne i32 %and129, 0
  br i1 %tobool130, label %if.then131, label %if.end134

if.then131:                                       ; preds = %if.end127
  %hdev132 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %27 = load %struct.usb_device*, %struct.usb_device** %hdev132, align 8, !tbaa !176
  %call133 = call i32 @usb_clear_port_feature(%struct.usb_device* %27, i32 %port1.0, i32 16)
  br label %if.end134

if.end134:                                        ; preds = %if.then131, %if.end127
  %need_debounce_delay.1 = phi i8 [ 1, %if.then131 ], [ %need_debounce_delay.0, %if.end127 ]
  %28 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv135 = zext i16 %28 to i32
  %and136 = and i32 %conv135, 2
  %tobool137 = icmp ne i32 %and136, 0
  br i1 %tobool137, label %if.then138, label %if.end141

if.then138:                                       ; preds = %if.end134
  %hdev139 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %29 = load %struct.usb_device*, %struct.usb_device** %hdev139, align 8, !tbaa !176
  %call140 = call i32 @usb_clear_port_feature(%struct.usb_device* %29, i32 %port1.0, i32 17)
  br label %if.end141

if.end141:                                        ; preds = %if.then138, %if.end134
  %need_debounce_delay.2 = phi i8 [ 1, %if.then138 ], [ %need_debounce_delay.1, %if.end134 ]
  %30 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv142 = zext i16 %30 to i32
  %and143 = and i32 %conv142, 16
  %tobool144 = icmp ne i32 %and143, 0
  br i1 %tobool144, label %if.then145, label %if.end148

if.then145:                                       ; preds = %if.end141
  %hdev146 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %31 = load %struct.usb_device*, %struct.usb_device** %hdev146, align 8, !tbaa !176
  %call147 = call i32 @usb_clear_port_feature(%struct.usb_device* %31, i32 %port1.0, i32 20)
  br label %if.end148

if.end148:                                        ; preds = %if.then145, %if.end141
  %need_debounce_delay.3 = phi i8 [ 1, %if.then145 ], [ %need_debounce_delay.2, %if.end141 ]
  %32 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv149 = zext i16 %32 to i32
  %and150 = and i32 %conv149, 32
  %tobool151 = icmp ne i32 %and150, 0
  br i1 %tobool151, label %land.lhs.true152, label %if.end159

land.lhs.true152:                                 ; preds = %if.end148
  %hdev153 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %33 = load %struct.usb_device*, %struct.usb_device** %hdev153, align 8, !tbaa !176
  %call154 = call i32 @hub_is_superspeed(%struct.usb_device* %33)
  %tobool155 = icmp ne i32 %call154, 0
  br i1 %tobool155, label %if.then156, label %if.end159

if.then156:                                       ; preds = %land.lhs.true152
  %hdev157 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %34 = load %struct.usb_device*, %struct.usb_device** %hdev157, align 8, !tbaa !176
  %call158 = call i32 @usb_clear_port_feature(%struct.usb_device* %34, i32 %port1.0, i32 29)
  br label %if.end159

if.end159:                                        ; preds = %if.then156, %land.lhs.true152, %if.end148
  %need_debounce_delay.4 = phi i8 [ 1, %if.then156 ], [ %need_debounce_delay.3, %land.lhs.true152 ], [ %need_debounce_delay.3, %if.end148 ]
  %35 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv160 = zext i16 %35 to i32
  %and161 = and i32 %conv160, 1
  %tobool162 = icmp ne i32 %and161, 0
  br i1 %tobool162, label %lor.lhs.false163, label %if.then167

lor.lhs.false163:                                 ; preds = %if.end159
  %36 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv164 = zext i16 %36 to i32
  %and165 = and i32 %conv164, 1
  %tobool166 = icmp ne i32 %and165, 0
  br i1 %tobool166, label %if.then167, label %if.end169

if.then167:                                       ; preds = %lor.lhs.false163, %if.end159
  %conv168 = sext i32 %port1.0 to i64
  %removed_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 11
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %removed_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i64 %conv168, i64* %arraydecay) #8, !srcloc !222
  br label %if.end169

if.end169:                                        ; preds = %if.then167, %lor.lhs.false163
  %magicptr = ptrtoint %struct.usb_device* %18 to i64
  %cond = icmp eq i64 %magicptr, 0
  br i1 %cond, label %lor.lhs.false177, label %lor.lhs.false171

lor.lhs.false171:                                 ; preds = %if.end169
  %state172 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 3
  %37 = load i32, i32* %state172, align 8, !tbaa !54
  %cmp173 = icmp eq i32 %37, 0
  br i1 %cmp173, label %if.then175, label %if.else189

if.then175:                                       ; preds = %lor.lhs.false171
  %tobool176 = icmp ne %struct.usb_device* %18, null
  br i1 %tobool176, label %if.then185, label %lor.lhs.false177

lor.lhs.false177:                                 ; preds = %if.then175, %if.end169
  %38 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv178 = zext i16 %38 to i32
  %and179 = and i32 %conv178, 1
  %tobool180 = icmp ne i32 %and179, 0
  br i1 %tobool180, label %if.then185, label %lor.lhs.false181

lor.lhs.false181:                                 ; preds = %lor.lhs.false177
  %39 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv182 = zext i16 %39 to i32
  %and183 = and i32 %conv182, 8
  %tobool184 = icmp ne i32 %and183, 0
  br i1 %tobool184, label %if.then185, label %if.end241

if.then185:                                       ; preds = %lor.lhs.false181, %lor.lhs.false177, %if.then175
  %conv186 = sext i32 %port1.0 to i64
  %change_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 10
  %arraydecay187 = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay187, i64 %conv186, i64* %arraydecay187) #8, !srcloc !201
  br label %if.end241

if.else189:                                       ; preds = %lor.lhs.false171
  %40 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv190 = zext i16 %40 to i32
  %and191 = and i32 %conv190, 2
  %tobool192 = icmp ne i32 %and191, 0
  br i1 %tobool192, label %if.then193, label %if.else212

if.then193:                                       ; preds = %if.else189
  %41 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv194 = zext i16 %41 to i32
  %and195 = and i32 %conv194, 480
  %cmp196 = icmp eq i32 %and195, 0
  %frombool = zext i1 %cmp196 to i8
  %42 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv198 = zext i16 %42 to i32
  %tobool199 = icmp ne i32 %conv198, 0
  br i1 %tobool199, label %if.then207, label %lor.lhs.false200

lor.lhs.false200:                                 ; preds = %if.then193
  %hdev201 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %43 = load %struct.usb_device*, %struct.usb_device** %hdev201, align 8, !tbaa !176
  %call202 = call i32 @hub_is_superspeed(%struct.usb_device* %43)
  %tobool203 = icmp ne i32 %call202, 0
  br i1 %tobool203, label %land.lhs.true204, label %if.end241

land.lhs.true204:                                 ; preds = %lor.lhs.false200
  %tobool205 = trunc i8 %frombool to i1
  br i1 %tobool205, label %if.then207, label %if.end241

if.then207:                                       ; preds = %land.lhs.true204, %if.then193
  %conv208 = sext i32 %port1.0 to i64
  %change_bits209 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 10
  %arraydecay210 = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits209, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay210, i64 %conv208, i64* %arraydecay210) #8, !srcloc !201
  br label %if.end241

if.else212:                                       ; preds = %if.else189
  %persist_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 22
  %bf.load213 = load i16, i16* %persist_enabled, align 4
  %bf.lshr214 = lshr i16 %bf.load213, 1
  %bf.clear215 = and i16 %bf.lshr214, 1
  %bf.cast216 = zext i16 %bf.clear215 to i32
  %tobool217 = icmp ne i32 %bf.cast216, 0
  br i1 %tobool217, label %if.then218, label %if.else235

if.then218:                                       ; preds = %if.else212
  %reset_resume = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 33
  %bf.load219 = load i8, i8* %reset_resume, align 8
  %bf.clear220 = and i8 %bf.load219, -3
  %bf.set = or i8 %bf.clear220, 2
  store i8 %bf.set, i8* %reset_resume, align 8
  %conv225 = sext i32 %port1.0 to i64
  %power_bits226 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 13
  %arraydecay227 = getelementptr inbounds [1 x i64], [1 x i64]* %power_bits226, i32 0, i32 0
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %arraydecay227, i64 %conv225) #8, !srcloc !235
  %44 = load i8, i8* %oldbit.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %44 to i1
  br i1 %tobool.i, label %if.then230, label %if.end241

if.then230:                                       ; preds = %if.then218
  %conv231 = sext i32 %port1.0 to i64
  %change_bits232 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 10
  %arraydecay233 = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits232, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay233, i64 %conv231, i64* %arraydecay233) #8, !srcloc !201
  br label %if.end241

if.else235:                                       ; preds = %if.else212
  call void @usb_set_device_state(%struct.usb_device* %18, i32 0)
  %conv236 = sext i32 %port1.0 to i64
  %change_bits237 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 10
  %arraydecay238 = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits237, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay238, i64 %conv236, i64* %arraydecay238) #8, !srcloc !201
  br label %if.end241

if.end241:                                        ; preds = %if.else235, %if.then230, %if.then218, %if.then207, %land.lhs.true204, %lor.lhs.false200, %if.then185, %lor.lhs.false181
  %inc = add nsw i32 %port1.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool242 = trunc i8 %need_debounce_delay.0 to i1
  br i1 %tobool242, label %if.then243, label %init3

if.then243:                                       ; preds = %for.end
  %cmp244 = icmp eq i32 %type, 1
  br i1 %cmp244, label %do.body248, label %if.else288

do.body248:                                       ; preds = %if.then243
  %init_work249 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %work250 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work249, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work250, i32 0)
  %init_work251 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %work252 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work251, i32 0, i32 0
  %data253 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work252, i32 0, i32 0
  %counter255 = getelementptr inbounds %union.anon.3, %union.anon.3* %.compoundliteral254, i32 0, i32 0
  store i64 137438953408, i64* %counter255, align 8, !tbaa !287
  %45 = bitcast %union.anon.3* %data253 to i8*
  %46 = bitcast %union.anon.3* %.compoundliteral254 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %45, i8* %46, i64 8, i32 8, i1 false), !tbaa.struct !288
  %init_work256 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %work257 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work256, i32 0, i32 0
  %lockdep_map258 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work257, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map258, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.105, i32 0, i32 0), %struct.lock_class_key* @hub_activate.__key.257, i32 0)
  %init_work259 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %work260 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work259, i32 0, i32 0
  %entry261 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work260, i32 0, i32 1
  call void @INIT_LIST_HEAD.35(%struct.list_head* %entry261)
  %init_work262 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %work263 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work262, i32 0, i32 0
  %func264 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work263, i32 0, i32 2
  store void (%struct.work_struct*)* @hub_init_func3, void (%struct.work_struct*)** %func264, align 8, !tbaa !289
  %init_work269 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %timer270 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work269, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer270, i32 2097152, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.107, i32 0, i32 0), %struct.lock_class_key* @hub_activate.__key.258)
  %init_work273 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %timer274 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work273, i32 0, i32 1
  %function275 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer274, i32 0, i32 2
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function275, align 8, !tbaa !290
  %init_work276 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %47 = ptrtoint %struct.delayed_work* %init_work276 to i64
  %init_work277 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %timer278 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work277, i32 0, i32 1
  %data279 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer278, i32 0, i32 3
  store i64 %47, i64* %data279, align 8, !tbaa !291
  %48 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_power_efficient_wq, align 8, !tbaa !52
  %init_work284 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 23
  %call.i = call i64 @__msecs_to_jiffies(i32 100) #8
  call void @queue_delayed_work(%struct.workqueue_struct* %48, %struct.delayed_work* %init_work284, i64 %call.i)
  %dev287 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev287)
  br label %cleanup.cont

if.else288:                                       ; preds = %if.then243
  call void @msleep(i32 100)
  br label %init3

init3:                                            ; preds = %if.else288, %for.end, %if.end
  %quiescing = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  %bf.load291 = load i8, i8* %quiescing, align 8
  %bf.clear292 = and i8 %bf.load291, -3
  store i8 %bf.clear292, i8* %quiescing, align 8
  %urb = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 3
  %49 = load %struct.urb*, %struct.urb** %urb, align 8, !tbaa !293
  %call293 = call i32 bitcast (i32 (%struct.urb.744*, i32)* @usb_submit_urb to i32 (%struct.urb*, i32)*)(%struct.urb* %49, i32 20971520)
  %cmp294 = icmp slt i32 %call293, 0
  br i1 %cmp294, label %if.then296, label %if.end298

if.then296:                                       ; preds = %init3
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end298

if.end298:                                        ; preds = %if.then296, %init3
  %has_indicators = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  %bf.load299 = load i8, i8* %has_indicators, align 8
  %bf.lshr300 = lshr i8 %bf.load299, 5
  %bf.clear301 = and i8 %bf.lshr300, 1
  %bf.cast302 = zext i8 %bf.clear301 to i32
  %tobool303 = icmp ne i32 %bf.cast302, 0
  br i1 %tobool303, label %land.lhs.true304, label %if.end309

land.lhs.true304:                                 ; preds = %if.end298
  %50 = load i8, i8* @blinkenlights, align 1, !tbaa !109, !range !110
  %tobool305 = trunc i8 %50 to i1
  br i1 %tobool305, label %if.then307, label %if.end309

if.then307:                                       ; preds = %land.lhs.true304
  %51 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_power_efficient_wq, align 8, !tbaa !52
  %leds = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  call void @queue_delayed_work(%struct.workqueue_struct* %51, %struct.delayed_work* %leds, i64 166)
  br label %if.end309

if.end309:                                        ; preds = %if.then307, %land.lhs.true304, %if.end298
  call void @kick_hub_wq(%struct.usb_hub* %hub)
  %type.off1 = add i32 %type, -1
  %switch2 = icmp ult i32 %type.off1, 2
  br i1 %switch2, label %disconnected316, label %if.end322

disconnected316:                                  ; preds = %if.end309, %if.then
  %intfdev318 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %52 = load %struct.device*, %struct.device** %intfdev318, align 8, !tbaa !204
  %53 = bitcast %struct.device* %52 to i8*
  %add.ptr320 = getelementptr inbounds i8, i8* %53, i64 -48
  %54 = bitcast i8* %add.ptr320 to %struct.usb_interface*
  call void @usb_autopm_put_interface_async(%struct.usb_interface* %54)
  %dev321 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev321)
  br label %if.end322

if.end322:                                        ; preds = %disconnected316, %if.end309
  %kref323 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 2
  call void @kref_put(%struct.kref* %kref323, void (%struct.kref*)* @hub_release)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end322, %do.body248, %if.then23
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hub_power_on_good_delay(%struct.usb_hub* %hub) #1 {
entry:
  %__UNIQUE_ID_max1_14 = alloca i32, align 4
  %__UNIQUE_ID_max2_15 = alloca i32, align 4
  %descriptor = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %0 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !232
  %bPwrOn2PwrGood = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %0, i32 0, i32 4
  %1 = load i8, i8* %bPwrOn2PwrGood, align 1, !tbaa !298
  %conv = zext i8 %1 to i32
  %mul = mul nsw i32 %conv, 2
  store i32 %mul, i32* %__UNIQUE_ID_max1_14, align 4, !tbaa !73
  store i32 100, i32* %__UNIQUE_ID_max2_15, align 4, !tbaa !73
  %2 = load i32, i32* %__UNIQUE_ID_max1_14, align 4, !tbaa !73
  %3 = load i32, i32* %__UNIQUE_ID_max2_15, align 4, !tbaa !73
  %cmp2 = icmp ugt i32 %2, %3
  %4 = load i32, i32* %__UNIQUE_ID_max1_14, align 4
  %5 = load i32, i32* %__UNIQUE_ID_max2_15, align 4
  %cond = select i1 %cmp2, i32 %4, i32 %5
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define internal void @hub_power_on(%struct.usb_hub* %hub, i1 zeroext %do_delay) #0 {
entry:
  %oldbit.i = alloca i8, align 1
  %frombool = zext i1 %do_delay to i8
  %call = call zeroext i1 @hub_is_port_power_switchable(%struct.usb_hub* %hub)
  br i1 %call, label %do.body1, label %do.body8

do.body1:                                         ; preds = %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_power_on.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %if.end28

if.then4:                                         ; preds = %do.body1
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !204
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_power_on.descriptor to %struct._ddebug*), %struct.device* %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.187, i32 0, i32 0))
  br label %if.end28

do.body8:                                         ; preds = %entry
  %bf.load9 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_power_on.descriptor.188 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr10 = lshr i32 %bf.load9, 18
  %bf.clear11 = and i32 %bf.lshr10, 255
  %and12 = and i32 %bf.clear11, 1
  %tobool13 = icmp ne i32 %and12, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  %expval19 = call i64 @llvm.expect.i64(i64 %conv18, i64 0)
  %tobool20 = icmp ne i64 %expval19, 0
  br i1 %tobool20, label %if.then21, label %if.end28

if.then21:                                        ; preds = %do.body8
  %intfdev22 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %1 = load %struct.device*, %struct.device** %intfdev22, align 8, !tbaa !204
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_power_on.descriptor.188 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.189, i32 0, i32 0))
  br label %if.end28

if.end28:                                         ; preds = %if.then21, %do.body8, %if.then4, %do.body1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end28
  %port1.0 = phi i32 [ 1, %if.end28 ], [ %inc, %for.inc ]
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 28
  %3 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp = icmp sle i32 %port1.0, %3
  br i1 %cmp, label %cond.false, label %for.end

cond.false:                                       ; preds = %for.cond
  %conv33 = sext i32 %port1.0 to i64
  %power_bits34 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 13
  %arraydecay35 = getelementptr inbounds [1 x i64], [1 x i64]* %power_bits34, i32 0, i32 0
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %arraydecay35, i64 %conv33) #8, !srcloc !235
  %4 = load i8, i8* %oldbit.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %4 to i1
  %hdev39 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %hdev39, align 8, !tbaa !176
  br i1 %tobool.i, label %if.then38, label %if.else41

if.then38:                                        ; preds = %cond.false
  %call40 = call i32 @set_port_feature(%struct.usb_device* %5, i32 %port1.0, i32 8)
  br label %for.inc

if.else41:                                        ; preds = %cond.false
  %call43 = call i32 @usb_clear_port_feature(%struct.usb_device* %5, i32 %port1.0, i32 8)
  br label %for.inc

for.inc:                                          ; preds = %if.else41, %if.then38
  %inc = add nsw i32 %port1.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool45 = trunc i8 %frombool to i1
  br i1 %tobool45, label %if.then46, label %if.end48

if.then46:                                        ; preds = %for.end
  %call47 = call i32 @hub_power_on_good_delay(%struct.usb_hub* %hub)
  call void @msleep(i32 %call47)
  br label %if.end48

if.end48:                                         ; preds = %if.then46, %for.end
  ret void
}

declare void @__init_work(%struct.work_struct*, i32) #2

declare void @lockdep_init_map(%struct.lockdep_map*, i8*, %struct.lock_class_key*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.35(%struct.list_head* %list) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !72
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !87
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_init_func2(%struct.work_struct* %ws) #0 {
entry:
  %0 = bitcast %struct.work_struct* %ws to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -704
  %1 = bitcast i8* %add.ptr to %struct.usb_hub*
  call void @hub_activate(%struct.usb_hub* %1, i32 1)
  ret void
}

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) #2

declare void @delayed_work_timer_fn(i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_delayed_work(%struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay) #1 {
entry:
  %call = call zeroext i1 @queue_delayed_work_on(i32 8192, %struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_init_func3(%struct.work_struct* %ws) #0 {
entry:
  %0 = bitcast %struct.work_struct* %ws to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -704
  %1 = bitcast i8* %add.ptr to %struct.usb_hub*
  call void @hub_activate(%struct.usb_hub* %1, i32 2)
  ret void
}

declare zeroext i1 @queue_delayed_work_on(i32, %struct.workqueue_struct*, %struct.delayed_work*, i64) #2

declare i64 @__msecs_to_jiffies(i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @hub_is_port_power_switchable(%struct.usb_hub* %hub) #1 {
entry:
  %tobool = icmp ne %struct.usb_hub* %hub, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %descriptor = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %0 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !232
  %wHubCharacteristics = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %0, i32 0, i32 3
  %1 = load i16, i16* %wHubCharacteristics, align 1, !tbaa !262
  %conv = zext i16 %1 to i32
  %and = and i32 %conv, 3
  %cmp = icmp slt i32 %and, 2
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i1 [ %cmp, %if.end ], [ false, %entry ]
  ret i1 %retval.0
}

declare i32 @pm_runtime_barrier(%struct.device*) #2

; Function Attrs: nounwind uwtable
define internal void @hub_quiesce(%struct.usb_hub* %hub, i32 %type) #0 {
entry:
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !176
  %quiescing = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  %bf.load = load i8, i8* %quiescing, align 8
  %bf.clear = and i8 %bf.load, -3
  %bf.set = or i8 %bf.clear, 2
  store i8 %bf.set, i8* %quiescing, align 8
  %cmp = icmp ne i32 %type, 2
  br i1 %cmp, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.inc ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %1 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp2 = icmp slt i32 %i.0, %1
  br i1 %cmp2, label %for.body, label %if.end8

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %2 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %2, i64 %idxprom
  %3 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 0
  %4 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !115
  %tobool = icmp ne %struct.usb_device* %4, null
  br i1 %tobool, label %if.then3, label %for.inc

if.then3:                                         ; preds = %for.body
  %ports4 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %5 = load %struct.usb_port**, %struct.usb_port*** %ports4, align 8, !tbaa !112
  %idxprom5 = sext i32 %i.0 to i64
  %arrayidx6 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %5, i64 %idxprom5
  %6 = load %struct.usb_port*, %struct.usb_port** %arrayidx6, align 8, !tbaa !52
  %child7 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %6, i32 0, i32 0
  call void @usb_disconnect(%struct.usb_device** %child7)
  br label %for.inc

for.inc:                                          ; preds = %if.then3, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end8:                                          ; preds = %for.cond, %entry
  %urb = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 3
  %7 = load %struct.urb*, %struct.urb** %urb, align 8, !tbaa !293
  call void bitcast (void (%struct.urb.744*)* @usb_kill_urb to void (%struct.urb*)*)(%struct.urb* %7)
  %has_indicators = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  %bf.load9 = load i8, i8* %has_indicators, align 8
  %bf.lshr = lshr i8 %bf.load9, 5
  %bf.clear10 = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear10 to i32
  %tobool11 = icmp ne i32 %bf.cast, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end8
  %leds = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  %call = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* %leds)
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end8
  %tt = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %hub14 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt, i32 0, i32 0
  %8 = load %struct.usb_device*, %struct.usb_device** %hub14, align 8, !tbaa !183
  %tobool15 = icmp ne %struct.usb_device* %8, null
  br i1 %tobool15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end13
  %tt17 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %clear_work = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt17, i32 0, i32 6
  %call18 = call zeroext i1 @flush_work(%struct.work_struct* %clear_work)
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end13
  ret void
}

declare zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work*) #2

declare zeroext i1 @flush_work(%struct.work_struct*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @dev_name(%struct.device* %dev) #1 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !299
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  call void @kobject_name()
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @check_ports_changed(%struct.usb_hub* %hub) #0 {
entry:
  %portstatus = alloca i16, align 2
  %portchange = alloca i16, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %port1.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %retval.0 = phi i32 [ undef, %entry ], [ %retval.1, %for.inc ]
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %1 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp = icmp sle i32 %port1.0, %1
  br i1 %cmp, label %for.body, label %cleanup4

for.body:                                         ; preds = %for.cond
  %call = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1.0, i16* %portstatus, i16* %portchange)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %2 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv = zext i16 %2 to i32
  %tobool1 = icmp ne i32 %conv, 0
  br i1 %tobool1, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %for.body
  br label %cleanup

cleanup:                                          ; preds = %if.end, %land.lhs.true
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end ], [ 1, %land.lhs.true ]
  %retval.1 = phi i32 [ %retval.0, %if.end ], [ 1, %land.lhs.true ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup4

for.inc:                                          ; preds = %cleanup
  %inc = add nsw i32 %port1.0, 1
  br label %for.cond

cleanup4:                                         ; preds = %cleanup, %for.cond
  %retval.2 = phi i32 [ 0, %for.cond ], [ %retval.1, %cleanup ]
  ret i32 %retval.2
}

declare void @pm_wakeup_event(%struct.device*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @kobject_name() #1 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_device* @interface_to_usbdev(%struct.usb_interface* %intf) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %parent, align 8, !tbaa !300
  %1 = bitcast %struct.device* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -152
  %2 = bitcast i8* %add.ptr to %struct.usb_device*
  ret %struct.usb_device* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_set_intfdata(%struct.usb_interface* %intf, i8* %data) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_suspend_ignore_children(%struct.device* %dev, i1 zeroext %enable) #1 {
entry:
  %frombool = zext i1 %enable to i8
  %tobool = trunc i8 %frombool to i1
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %ignore_children = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 14
  %0 = zext i1 %tobool to i16
  %bf.load = load i16, i16* %ignore_children, align 8
  %bf.shl = shl i16 %0, 8
  %bf.clear = and i16 %bf.load, -257
  %bf.set = or i16 %bf.clear, %bf.shl
  store i16 %bf.set, i16* %ignore_children, align 8
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @dev_set_drvdata(%struct.device* %dev, i8* %data) #1 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  store i8* %data, i8** %driver_data, align 8, !tbaa !117
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_is_int_in(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %call = call i32 @usb_endpoint_xfer_int(%struct.usb_endpoint_descriptor* %epd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %call1 = call i32 @usb_endpoint_dir_in(%struct.usb_endpoint_descriptor* %epd)
  %tobool2 = icmp ne i32 %call1, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %0 = phi i1 [ false, %entry ], [ %tobool2, %land.rhs ]
  %land.ext = zext i1 %0 to i32
  ret i32 %land.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.36(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call noalias i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_init(%struct.kref* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  call void @refcount_set(%struct.qspinlock* %refcount, i32 1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @led_work(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -512
  %1 = bitcast i8* %add.ptr to %struct.usb_hub*
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !176
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 3
  %3 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp ne i32 %3, 7
  br i1 %cmp, label %cleanup.cont39, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %quiescing = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 20
  %bf.load = load i8, i8* %quiescing, align 8
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %cleanup.cont39, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock14, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %LeafBlock14 ]
  %changed.0 = phi i32 [ 0, %if.end ], [ %changed.2, %LeafBlock14 ]
  %cursor.0 = phi i32 [ -1, %if.end ], [ %cursor.2, %LeafBlock14 ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 28
  %4 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp2 = icmp ult i32 %i.0, %4
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %indicator = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 21
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [31 x i8], [31 x i8]* %indicator, i64 0, i64 %idxprom
  %5 = load i8, i8* %arrayidx, align 1, !tbaa !72
  %conv = zext i8 %5 to i32
  %Pivot12 = icmp slt i32 %conv, 4
  br i1 %Pivot12, label %NodeBlock1, label %NodeBlock9

NodeBlock9:                                       ; preds = %for.body
  %Pivot10 = icmp slt i32 %conv, 6
  br i1 %Pivot10, label %NodeBlock3, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %conv, 7
  br i1 %Pivot8, label %sw.epilog, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %conv, 7
  br i1 %SwitchLeaf6, label %sw.epilog, label %LeafBlock14

NodeBlock3:                                       ; preds = %NodeBlock9
  %Pivot4 = icmp slt i32 %conv, 5
  %. = select i1 %Pivot4, i32 1, i32 3
  %.16 = select i1 %Pivot4, i32 5, i32 4
  br label %sw.epilog

NodeBlock1:                                       ; preds = %for.body
  %Pivot2 = icmp slt i32 %conv, 2
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %conv, 3
  %.17 = select i1 %Pivot, i32 2, i32 3
  %.18 = select i1 %Pivot, i32 3, i32 2
  br label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %conv, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %LeafBlock14

sw.epilog:                                        ; preds = %LeafBlock, %NodeBlock, %NodeBlock3, %LeafBlock5, %NodeBlock7
  %cursor.1 = phi i32 [ %cursor.0, %NodeBlock3 ], [ %cursor.0, %NodeBlock ], [ %i.0, %LeafBlock ], [ %cursor.0, %NodeBlock7 ], [ %cursor.0, %LeafBlock5 ]
  %selector.0 = phi i32 [ %., %NodeBlock3 ], [ %.17, %NodeBlock ], [ 0, %LeafBlock ], [ 2, %NodeBlock7 ], [ 1, %LeafBlock5 ]
  %mode.0 = phi i32 [ %.16, %NodeBlock3 ], [ %.18, %NodeBlock ], [ 0, %LeafBlock ], [ 7, %NodeBlock7 ], [ 6, %LeafBlock5 ]
  %cmp9 = icmp ne i32 %selector.0, 0
  %.changed.0 = select i1 %cmp9, i32 1, i32 %changed.0
  %add = add i32 %i.0, 1
  call void @set_port_led(%struct.usb_hub* %1, i32 %add, i32 %selector.0)
  %conv13 = trunc i32 %mode.0 to i8
  %indicator14 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 21
  %idxprom15 = zext i32 %i.0 to i64
  %arrayidx16 = getelementptr inbounds [31 x i8], [31 x i8]* %indicator14, i64 0, i64 %idxprom15
  store i8 %conv13, i8* %arrayidx16, align 1, !tbaa !72
  br label %LeafBlock14

LeafBlock14:                                      ; preds = %sw.epilog, %LeafBlock, %LeafBlock5
  %changed.2 = phi i32 [ %.changed.0, %sw.epilog ], [ %changed.0, %LeafBlock ], [ %changed.0, %LeafBlock5 ]
  %cursor.2 = phi i32 [ %cursor.1, %sw.epilog ], [ %cursor.0, %LeafBlock ], [ %cursor.0, %LeafBlock5 ]
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool18 = icmp ne i32 %changed.0, 0
  br i1 %tobool18, label %if.end29, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.end
  %6 = load i8, i8* @blinkenlights, align 1, !tbaa !109, !range !110
  %tobool19 = trunc i8 %6 to i1
  br i1 %tobool19, label %if.then21, label %if.end29

if.then21:                                        ; preds = %land.lhs.true
  %inc22 = add nsw i32 %cursor.0, 1
  %maxchild23 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 28
  %7 = load i32, i32* %maxchild23, align 8, !tbaa !111
  %rem = srem i32 %inc22, %7
  %add24 = add nsw i32 %rem, 1
  call void @set_port_led(%struct.usb_hub* %1, i32 %add24, i32 2)
  %indicator25 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 21
  %idxprom26 = sext i32 %rem to i64
  %arrayidx27 = getelementptr inbounds [31 x i8], [31 x i8]* %indicator25, i64 0, i64 %idxprom26
  store i8 1, i8* %arrayidx27, align 1, !tbaa !72
  %inc28 = add i32 %changed.0, 1
  br label %if.end29

if.end29:                                         ; preds = %if.then21, %land.lhs.true, %for.end
  %changed.3 = phi i32 [ %changed.0, %for.end ], [ %inc28, %if.then21 ], [ %changed.0, %land.lhs.true ]
  %tobool30 = icmp ne i32 %changed.3, 0
  br i1 %tobool30, label %if.then31, label %cleanup.cont39

if.then31:                                        ; preds = %if.end29
  %8 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_power_efficient_wq, align 8, !tbaa !52
  %leds = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 22
  call void @queue_delayed_work(%struct.workqueue_struct* %8, %struct.delayed_work* %leds, i64 166)
  br label %cleanup.cont39

cleanup.cont39:                                   ; preds = %if.then31, %if.end29, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_event(%struct.work_struct* %work) #0 {
entry:
  %c.i = alloca i8, align 1
  %oldbit.i3 = alloca i8, align 1
  %oldbit.i1 = alloca i8, align 1
  %oldbit.i = alloca i8, align 1
  %hubstatus = alloca i16, align 2
  %hubchange = alloca i16, align 2
  %status = alloca i16, align 2
  %unused = alloca i16, align 2
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -896
  %1 = bitcast i8* %add.ptr to %struct.usb_hub*
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !176
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 0
  %3 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !204
  %4 = bitcast %struct.device* %3 to i8*
  %add.ptr4 = getelementptr inbounds i8, i8* %4, i64 -48
  %5 = bitcast i8* %add.ptr4 to %struct.usb_interface*
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_event.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then, label %do.end14

if.then:                                          ; preds = %entry
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 3
  %6 = load i32, i32* %state, align 8, !tbaa !54
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 28
  %7 = load i32, i32* %maxchild, align 8, !tbaa !111
  %change_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 10
  %arrayidx = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits, i64 0, i64 0
  %8 = load i64, i64* %arrayidx, align 8, !tbaa !53
  %conv8 = trunc i64 %8 to i16
  %conv9 = zext i16 %conv8 to i32
  %event_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 9
  %arrayidx10 = getelementptr inbounds [1 x i64], [1 x i64]* %event_bits, i64 0, i64 0
  %9 = load i64, i64* %arrayidx10, align 8, !tbaa !53
  %conv11 = trunc i64 %9 to i16
  %conv12 = zext i16 %conv11 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_event.descriptor to %struct._ddebug*), %struct.device* %3, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.116, i32 0, i32 0), i32 %6, i32 %7, i32 %conv9, i32 %conv12)
  br label %do.end14

do.end14:                                         ; preds = %if.then, %entry
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock(%struct.device* %dev)
  %disconnected = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 20
  %bf.load15 = load i8, i8* %disconnected, align 8
  %bf.lshr16 = lshr i8 %bf.load15, 2
  %bf.clear17 = and i8 %bf.lshr16, 1
  %bf.cast = zext i8 %bf.clear17 to i32
  %tobool18 = icmp ne i32 %bf.cast, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %out_hdev_lock, label %if.end27

if.end27:                                         ; preds = %do.end14
  %state28 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 3
  %10 = load i32, i32* %state28, align 8, !tbaa !54
  %cmp = icmp eq i32 %10, 0
  br i1 %cmp, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end27
  %error = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 7
  store i32 -19, i32* %error, align 8, !tbaa !202
  call void @hub_quiesce(%struct.usb_hub* %1, i32 0)
  br label %out_hdev_lock

if.end31:                                         ; preds = %if.end27
  %call = call i32 @usb_autopm_get_interface(%struct.usb_interface* %5)
  %tobool32 = icmp ne i32 %call, 0
  br i1 %tobool32, label %do.body35, label %if.end54

do.body35:                                        ; preds = %if.end31
  %bf.load36 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_event.descriptor.117 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr37 = lshr i32 %bf.load36, 18
  %bf.clear38 = and i32 %bf.lshr37, 255
  %and39 = and i32 %bf.clear38, 1
  %tobool40 = icmp ne i32 %and39, 0
  %lnot41 = xor i1 %tobool40, true
  %lnot43 = xor i1 %lnot41, true
  %lnot.ext44 = zext i1 %lnot43 to i32
  %conv45 = sext i32 %lnot.ext44 to i64
  %expval46 = call i64 @llvm.expect.i64(i64 %conv45, i64 0)
  %tobool47 = icmp ne i64 %expval46, 0
  br i1 %tobool47, label %if.then48, label %out_hdev_lock

if.then48:                                        ; preds = %do.body35
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_event.descriptor.117 to %struct._ddebug*), %struct.device* %3, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.118, i32 0, i32 0), i32 %call)
  br label %out_hdev_lock

if.end54:                                         ; preds = %if.end31
  %quiescing = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 20
  %bf.load55 = load i8, i8* %quiescing, align 8
  %bf.lshr56 = lshr i8 %bf.load55, 1
  %bf.clear57 = and i8 %bf.lshr56, 1
  %bf.cast58 = zext i8 %bf.clear57 to i32
  %tobool59 = icmp ne i32 %bf.cast58, 0
  br i1 %tobool59, label %out_autopm, label %if.end61

if.end61:                                         ; preds = %if.end54
  %error62 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 7
  %11 = load i32, i32* %error62, align 8, !tbaa !202
  %tobool63 = icmp ne i32 %11, 0
  br i1 %tobool63, label %do.body66, label %if.end111

do.body66:                                        ; preds = %if.end61
  %bf.load67 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_event.descriptor.119 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr68 = lshr i32 %bf.load67, 18
  %bf.clear69 = and i32 %bf.lshr68, 255
  %and70 = and i32 %bf.clear69, 1
  %tobool71 = icmp ne i32 %and70, 0
  %lnot72 = xor i1 %tobool71, true
  %lnot74 = xor i1 %lnot72, true
  %lnot.ext75 = zext i1 %lnot74 to i32
  %conv76 = sext i32 %lnot.ext75 to i64
  %expval77 = call i64 @llvm.expect.i64(i64 %conv76, i64 0)
  %tobool78 = icmp ne i64 %expval77, 0
  br i1 %tobool78, label %if.then79, label %do.end85

if.then79:                                        ; preds = %do.body66
  %error80 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 7
  %12 = load i32, i32* %error80, align 8, !tbaa !202
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_event.descriptor.119 to %struct._ddebug*), %struct.device* %3, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.120, i32 0, i32 0), i32 %12)
  br label %do.end85

do.end85:                                         ; preds = %if.then79, %do.body66
  %call86 = call i32 @usb_reset_device(%struct.usb_device* %2)
  %tobool87 = icmp ne i32 %call86, 0
  br i1 %tobool87, label %do.body90, label %if.end109

do.body90:                                        ; preds = %do.end85
  %bf.load91 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_event.descriptor.121 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr92 = lshr i32 %bf.load91, 18
  %bf.clear93 = and i32 %bf.lshr92, 255
  %and94 = and i32 %bf.clear93, 1
  %tobool95 = icmp ne i32 %and94, 0
  %lnot96 = xor i1 %tobool95, true
  %lnot98 = xor i1 %lnot96, true
  %lnot.ext99 = zext i1 %lnot98 to i32
  %conv100 = sext i32 %lnot.ext99 to i64
  %expval101 = call i64 @llvm.expect.i64(i64 %conv100, i64 0)
  %tobool102 = icmp ne i64 %expval101, 0
  br i1 %tobool102, label %if.then103, label %out_autopm

if.then103:                                       ; preds = %do.body90
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_event.descriptor.121 to %struct._ddebug*), %struct.device* %3, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.122, i32 0, i32 0), i32 %call86)
  br label %out_autopm

if.end109:                                        ; preds = %do.end85
  %nerrors = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 8
  store i32 0, i32* %nerrors, align 4, !tbaa !301
  %error110 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 7
  store i32 0, i32* %error110, align 8, !tbaa !202
  br label %if.end111

if.end111:                                        ; preds = %if.end109, %if.end61
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end111
  %i.0 = phi i32 [ 1, %if.end111 ], [ %inc, %for.inc ]
  %maxchild112 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 28
  %13 = load i32, i32* %maxchild112, align 8, !tbaa !111
  %cmp113 = icmp sle i32 %i.0, %13
  br i1 %cmp113, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 25
  %14 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %i.0, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx115 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %14, i64 %idxprom
  %15 = load %struct.usb_port*, %struct.usb_port** %arrayidx115, align 8, !tbaa !52
  %conv120 = sext i32 %i.0 to i64
  %event_bits121 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 9
  %arraydecay122 = getelementptr inbounds [1 x i64], [1 x i64]* %event_bits121, i32 0, i32 0
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i3, i64* %arraydecay122, i64 %conv120) #8, !srcloc !235
  %16 = load i8, i8* %oldbit.i3, align 1, !tbaa !109, !range !110
  %tobool.i4 = trunc i8 %16 to i1
  br i1 %tobool.i4, label %if.then149, label %cond.false131

cond.false131:                                    ; preds = %for.body
  %conv132 = sext i32 %i.0 to i64
  %change_bits133 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 10
  %arraydecay134 = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits133, i32 0, i32 0
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i1, i64* %arraydecay134, i64 %conv132) #8, !srcloc !235
  %17 = load i8, i8* %oldbit.i1, align 1, !tbaa !109, !range !110
  %tobool.i2 = trunc i8 %17 to i1
  br i1 %tobool.i2, label %if.then149, label %cond.false143

cond.false143:                                    ; preds = %cond.false131
  %conv144 = sext i32 %i.0 to i64
  %wakeup_bits145 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 12
  %arraydecay146 = getelementptr inbounds [1 x i64], [1 x i64]* %wakeup_bits145, i32 0, i32 0
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %arraydecay146, i64 %conv144) #8, !srcloc !235
  %18 = load i8, i8* %oldbit.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %18 to i1
  br i1 %tobool.i, label %if.then149, label %for.inc

if.then149:                                       ; preds = %cond.false143, %cond.false131, %for.body
  %dev150 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %15, i32 0, i32 1
  call void @pm_runtime_get_noresume(%struct.device* %dev150)
  %dev151 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %15, i32 0, i32 1
  %call152 = call i32 @pm_runtime_barrier(%struct.device* %dev151)
  call void @usb_lock_port(%struct.usb_port* %15)
  call void @port_event(%struct.usb_hub* %1, i32 %i.0)
  call void @usb_unlock_port(%struct.usb_port* %15)
  %dev153 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %15, i32 0, i32 1
  call void @pm_runtime_put_sync(%struct.device* %dev153)
  br label %for.inc

for.inc:                                          ; preds = %if.then149, %cond.false143
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %event_bits156 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 9
  %arraydecay157 = getelementptr inbounds [1 x i64], [1 x i64]* %event_bits156, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2, $0;\0A\09setc $1\0A", "=*m,=*qm,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay157, i8* %c.i, i64 0, i64* %arraydecay157) #8, !srcloc !255
  %19 = load i8, i8* %c.i, align 1, !tbaa !109, !range !110
  %tobool.i5 = trunc i8 %19 to i1
  %conv159 = zext i1 %tobool.i5 to i32
  %cmp160 = icmp eq i32 %conv159, 0
  br i1 %cmp160, label %out_autopm, label %if.else

if.else:                                          ; preds = %for.end
  %call163 = call i32 @hub_hub_status(%struct.usb_hub* %1, i16* %hubstatus, i16* %hubchange)
  %cmp164 = icmp slt i32 %call163, 0
  br i1 %cmp164, label %if.then166, label %if.else167

if.then166:                                       ; preds = %if.else
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %out_autopm

if.else167:                                       ; preds = %if.else
  %20 = load i16, i16* %hubchange, align 2, !tbaa !165
  %conv168 = zext i16 %20 to i32
  %and169 = and i32 %conv168, 1
  %tobool170 = icmp ne i32 %and169, 0
  br i1 %tobool170, label %do.body173, label %if.end204

do.body173:                                       ; preds = %if.else167
  %bf.load174 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_event.descriptor.124 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr175 = lshr i32 %bf.load174, 18
  %bf.clear176 = and i32 %bf.lshr175, 255
  %and177 = and i32 %bf.clear176, 1
  %tobool178 = icmp ne i32 %and177, 0
  %lnot179 = xor i1 %tobool178, true
  %lnot181 = xor i1 %lnot179, true
  %lnot.ext182 = zext i1 %lnot181 to i32
  %conv183 = sext i32 %lnot.ext182 to i64
  %expval184 = call i64 @llvm.expect.i64(i64 %conv183, i64 0)
  %tobool185 = icmp ne i64 %expval184, 0
  br i1 %tobool185, label %if.then186, label %do.end191

if.then186:                                       ; preds = %do.body173
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_event.descriptor.124 to %struct._ddebug*), %struct.device* %3, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.125, i32 0, i32 0))
  br label %do.end191

do.end191:                                        ; preds = %if.then186, %do.body173
  call void @clear_hub_feature(%struct.usb_device* %2, i32 0)
  %21 = load i16, i16* %hubstatus, align 2, !tbaa !165
  %conv193 = zext i16 %21 to i32
  %and194 = and i32 %conv193, 1
  %tobool195 = icmp ne i32 %and194, 0
  %limited_power = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 20
  %bf.load197 = load i8, i8* %limited_power, align 8
  %bf.clear198 = and i8 %bf.load197, -2
  %bf.set = or i8 %bf.clear198, 1
  %bf.clear198.sink = select i1 %tobool195, i8 %bf.set, i8 %bf.clear198
  store i8 %bf.clear198.sink, i8* %limited_power, align 8
  br label %if.end204

if.end204:                                        ; preds = %do.end191, %if.else167
  %22 = load i16, i16* %hubchange, align 2, !tbaa !165
  %conv205 = zext i16 %22 to i32
  %and206 = and i32 %conv205, 2
  %tobool207 = icmp ne i32 %and206, 0
  br i1 %tobool207, label %if.then208, label %out_autopm

if.then208:                                       ; preds = %if.end204
  store i16 0, i16* %status, align 2, !tbaa !165
  %bf.load211 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_event.descriptor.126 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr212 = lshr i32 %bf.load211, 18
  %bf.clear213 = and i32 %bf.lshr212, 255
  %and214 = and i32 %bf.clear213, 1
  %tobool215 = icmp ne i32 %and214, 0
  %lnot216 = xor i1 %tobool215, true
  %lnot218 = xor i1 %lnot216, true
  %lnot.ext219 = zext i1 %lnot218 to i32
  %conv220 = sext i32 %lnot.ext219 to i64
  %expval221 = call i64 @llvm.expect.i64(i64 %conv220, i64 0)
  %tobool222 = icmp ne i64 %expval221, 0
  br i1 %tobool222, label %if.then223, label %do.end228

if.then223:                                       ; preds = %if.then208
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_event.descriptor.126 to %struct._ddebug*), %struct.device* %3, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.127, i32 0, i32 0))
  br label %do.end228

do.end228:                                        ; preds = %if.then223, %if.then208
  call void @clear_hub_feature(%struct.usb_device* %2, i32 1)
  call void @msleep(i32 500)
  call void @hub_power_on(%struct.usb_hub* %1, i1 zeroext true)
  %call230 = call i32 @hub_hub_status(%struct.usb_hub* %1, i16* %status, i16* %unused)
  %23 = load i16, i16* %status, align 2, !tbaa !165
  %conv231 = zext i16 %23 to i32
  %and232 = and i32 %conv231, 2
  %tobool233 = icmp ne i32 %and232, 0
  br i1 %tobool233, label %if.then234, label %if.end235

if.then234:                                       ; preds = %do.end228
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end235

if.end235:                                        ; preds = %if.then234, %do.end228
  br label %out_autopm

out_autopm:                                       ; preds = %if.end235, %if.end204, %if.then166, %for.end, %if.then103, %do.body90, %if.end54
  call void @usb_autopm_put_interface_no_suspend(%struct.usb_interface* %5)
  br label %out_hdev_lock

out_hdev_lock:                                    ; preds = %out_autopm, %if.then48, %do.body35, %if.then30, %do.end14
  %dev239 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev239)
  call void @usb_autopm_put_interface(%struct.usb_interface* %5)
  %kref = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 2
  call void @kref_put(%struct.kref* %kref, void (%struct.kref*)* @hub_release)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_configure(%struct.usb_hub* %hub, %struct.usb_endpoint_descriptor* %endpoint) #0 {
entry:
  %hubstatus = alloca i16, align 2
  %hubchange = alloca i16, align 2
  %portstr = alloca [32 x i8], align 16
  %.compoundliteral = alloca %union.anon.3, align 8
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !176
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %1 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !204
  %call.i2 = call noalias i8* @__kmalloc(i64 8, i32 20971712) #8
  %2 = bitcast i8* %call.i2 to [8 x i8]*
  %buffer = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 4
  store [8 x i8]* %2, [8 x i8]** %buffer, align 8, !tbaa !294
  %buffer2 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 4
  %3 = load [8 x i8]*, [8 x i8]** %buffer2, align 8, !tbaa !294
  %tobool = icmp ne [8 x i8]* %3, null
  br i1 %tobool, label %if.end, label %fail

if.end:                                           ; preds = %entry
  %call.i1 = call noalias i8* @__kmalloc(i64 8, i32 20971712) #8
  %4 = bitcast i8* %call.i1 to %union.anon.62*
  %status = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  store %union.anon.62* %4, %union.anon.62** %status, align 8, !tbaa !237
  %status4 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  %5 = load %union.anon.62*, %union.anon.62** %status4, align 8, !tbaa !237
  %tobool5 = icmp ne %union.anon.62* %5, null
  br i1 %tobool5, label %do.body, label %fail

do.body:                                          ; preds = %if.end
  %status_mutex = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 6
  call void @__mutex_init(%struct.mutex* %status_mutex, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.191, i32 0, i32 0), %struct.lock_class_key* @hub_configure.__key)
  %call.i = call noalias i8* @__kmalloc(i64 15, i32 20971712) #8
  %6 = bitcast i8* %call.i to %struct.usb_hub_descriptor*
  %descriptor = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  store %struct.usb_hub_descriptor* %6, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !232
  %descriptor9 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %7 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor9, align 8, !tbaa !232
  %tobool10 = icmp ne %struct.usb_hub_descriptor* %7, null
  br i1 %tobool10, label %if.end12, label %fail

if.end12:                                         ; preds = %do.body
  %descriptor13 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %8 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor13, align 8, !tbaa !232
  %9 = bitcast %struct.usb_hub_descriptor* %8 to i8*
  %call14 = call i32 @get_hub_descriptor(%struct.usb_device* %0, i8* %9)
  %cmp = icmp slt i32 %call14, 0
  br i1 %cmp, label %fail, label %if.else

if.else:                                          ; preds = %if.end12
  %descriptor16 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %10 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor16, align 8, !tbaa !232
  %bNbrPorts = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %10, i32 0, i32 2
  %11 = load i8, i8* %bNbrPorts, align 1, !tbaa !302
  %conv = zext i8 %11 to i32
  %cmp17 = icmp sgt i32 %conv, 31
  br i1 %cmp17, label %fail, label %if.else20

if.else20:                                        ; preds = %if.else
  %descriptor21 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %12 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor21, align 8, !tbaa !232
  %bNbrPorts22 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %12, i32 0, i32 2
  %13 = load i8, i8* %bNbrPorts22, align 1, !tbaa !302
  %conv23 = zext i8 %13 to i32
  %cmp24 = icmp eq i32 %conv23, 0
  br i1 %cmp24, label %fail, label %if.end29

if.end29:                                         ; preds = %if.else20
  %descriptor30 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %14 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor30, align 8, !tbaa !232
  %bNbrPorts31 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %14, i32 0, i32 2
  %15 = load i8, i8* %bNbrPorts31, align 1, !tbaa !302
  %conv32 = zext i8 %15 to i32
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %conv35 = zext i32 %conv32 to i64
  %mul = mul i64 %conv35, 8
  %call36 = call i8* @kzalloc.36(i64 %mul, i32 20971712)
  %16 = bitcast i8* %call36 to %struct.usb_port**
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  store %struct.usb_port** %16, %struct.usb_port*** %ports, align 8, !tbaa !112
  %ports37 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %17 = load %struct.usb_port**, %struct.usb_port*** %ports37, align 8, !tbaa !112
  %tobool38 = icmp ne %struct.usb_port** %17, null
  br i1 %tobool38, label %if.end40, label %fail

if.end40:                                         ; preds = %if.end29
  %descriptor41 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %18 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor41, align 8, !tbaa !232
  %wHubCharacteristics42 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %18, i32 0, i32 3
  %19 = load i16, i16* %wHubCharacteristics42, align 1, !tbaa !262
  %call43 = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool44 = icmp ne i32 %call43, 0
  %. = select i1 %tobool44, i32 150, i32 100
  %.46 = select i1 %tobool44, i32 900, i32 500
  %conv48 = zext i16 %19 to i32
  %and = and i32 %conv48, 4
  %tobool49 = icmp ne i32 %and, 0
  br i1 %tobool49, label %land.lhs.true, label %do.body81

land.lhs.true:                                    ; preds = %if.end40
  %call50 = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool51 = icmp ne i32 %call50, 0
  br i1 %tobool51, label %do.body81, label %if.then52

if.then52:                                        ; preds = %land.lhs.true
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then52
  %i.0 = phi i32 [ 0, %if.then52 ], [ %inc, %for.body ]
  %cmp53 = icmp ult i32 %i.0, %conv32
  br i1 %cmp53, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %descriptor55 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %20 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor55, align 8, !tbaa !232
  %u = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %20, i32 0, i32 6
  %hs = bitcast %union.anon.63* %u to %struct.anon.64*
  %DeviceRemovable = getelementptr inbounds %struct.anon.64, %struct.anon.64* %hs, i32 0, i32 0
  %add = add nsw i32 %i.0, 1
  %div = sdiv i32 %add, 8
  %idxprom = sext i32 %div to i64
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* %DeviceRemovable, i64 0, i64 %idxprom
  %21 = load i8, i8* %arrayidx, align 1, !tbaa !72
  %conv56 = zext i8 %21 to i32
  %add57 = add nsw i32 %i.0, 1
  %rem = srem i32 %add57, 8
  %shl = shl i32 1, %rem
  %and58 = and i32 %conv56, %shl
  %tobool59 = icmp ne i32 %and58, 0
  %cond60 = select i1 %tobool59, i32 70, i32 82
  %conv61 = trunc i32 %cond60 to i8
  %idxprom62 = sext i32 %i.0 to i64
  %arrayidx63 = getelementptr inbounds [32 x i8], [32 x i8]* %portstr, i64 0, i64 %idxprom62
  store i8 %conv61, i8* %arrayidx63, align 1, !tbaa !72
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %idxprom64 = zext i32 %conv32 to i64
  %arrayidx65 = getelementptr inbounds [32 x i8], [32 x i8]* %portstr, i64 0, i64 %idxprom64
  store i8 0, i8* %arrayidx65, align 1, !tbaa !72
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and68 = and i32 %bf.clear, 1
  %tobool69 = icmp ne i32 %and68, 0
  %lnot = xor i1 %tobool69, true
  %lnot70 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot70 to i32
  %conv71 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv71, i64 0)
  %tobool72 = icmp ne i64 %expval, 0
  br i1 %tobool72, label %if.then73, label %do.end78

if.then73:                                        ; preds = %for.end
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %portstr, i32 0, i32 0
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.197, i32 0, i32 0), i8* %arraydecay)
  br label %do.end78

do.end78:                                         ; preds = %if.then73, %for.end
  br label %if.end100

do.body81:                                        ; preds = %land.lhs.true, %if.end40
  %bf.load82 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.198 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr83 = lshr i32 %bf.load82, 18
  %bf.clear84 = and i32 %bf.lshr83, 255
  %and85 = and i32 %bf.clear84, 1
  %tobool86 = icmp ne i32 %and85, 0
  %lnot87 = xor i1 %tobool86, true
  %lnot89 = xor i1 %lnot87, true
  %lnot.ext90 = zext i1 %lnot89 to i32
  %conv91 = sext i32 %lnot.ext90 to i64
  %expval92 = call i64 @llvm.expect.i64(i64 %conv91, i64 0)
  %tobool93 = icmp ne i64 %expval92, 0
  br i1 %tobool93, label %if.then94, label %if.end100

if.then94:                                        ; preds = %do.body81
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.198 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.199, i32 0, i32 0))
  br label %if.end100

if.end100:                                        ; preds = %if.then94, %do.body81, %do.end78
  %conv101 = zext i16 %19 to i32
  %and102 = and i32 %conv101, 3
  %Pivot4 = icmp slt i32 %and102, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end100
  %Pivot = icmp slt i32 %and102, 2
  br i1 %Pivot, label %do.body125, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %and102.off = add i32 %and102, -2
  %SwitchLeaf2 = icmp ule i32 %and102.off, 1
  br i1 %SwitchLeaf2, label %do.body146, label %sw.epilog

LeafBlock:                                        ; preds = %if.end100
  %SwitchLeaf = icmp eq i32 %and102, 0
  br i1 %SwitchLeaf, label %do.body104, label %sw.epilog

do.body104:                                       ; preds = %LeafBlock
  %bf.load105 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.200 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr106 = lshr i32 %bf.load105, 18
  %bf.clear107 = and i32 %bf.lshr106, 255
  %and108 = and i32 %bf.clear107, 1
  %tobool109 = icmp ne i32 %and108, 0
  %lnot110 = xor i1 %tobool109, true
  %lnot112 = xor i1 %lnot110, true
  %lnot.ext113 = zext i1 %lnot112 to i32
  %conv114 = sext i32 %lnot.ext113 to i64
  %expval115 = call i64 @llvm.expect.i64(i64 %conv114, i64 0)
  %tobool116 = icmp ne i64 %expval115, 0
  br i1 %tobool116, label %if.then117, label %sw.epilog

if.then117:                                       ; preds = %do.body104
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.200 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.201, i32 0, i32 0))
  br label %sw.epilog

do.body125:                                       ; preds = %NodeBlock
  %bf.load126 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.202 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr127 = lshr i32 %bf.load126, 18
  %bf.clear128 = and i32 %bf.lshr127, 255
  %and129 = and i32 %bf.clear128, 1
  %tobool130 = icmp ne i32 %and129, 0
  %lnot131 = xor i1 %tobool130, true
  %lnot133 = xor i1 %lnot131, true
  %lnot.ext134 = zext i1 %lnot133 to i32
  %conv135 = sext i32 %lnot.ext134 to i64
  %expval136 = call i64 @llvm.expect.i64(i64 %conv135, i64 0)
  %tobool137 = icmp ne i64 %expval136, 0
  br i1 %tobool137, label %if.then138, label %sw.epilog

if.then138:                                       ; preds = %do.body125
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.202 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.203, i32 0, i32 0))
  br label %sw.epilog

do.body146:                                       ; preds = %LeafBlock1
  %bf.load147 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.204 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr148 = lshr i32 %bf.load147, 18
  %bf.clear149 = and i32 %bf.lshr148, 255
  %and150 = and i32 %bf.clear149, 1
  %tobool151 = icmp ne i32 %and150, 0
  %lnot152 = xor i1 %tobool151, true
  %lnot154 = xor i1 %lnot152, true
  %lnot.ext155 = zext i1 %lnot154 to i32
  %conv156 = sext i32 %lnot.ext155 to i64
  %expval157 = call i64 @llvm.expect.i64(i64 %conv156, i64 0)
  %tobool158 = icmp ne i64 %expval157, 0
  br i1 %tobool158, label %if.then159, label %sw.epilog

if.then159:                                       ; preds = %do.body146
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.204 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.205, i32 0, i32 0))
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then159, %do.body146, %if.then138, %do.body125, %if.then117, %do.body104, %LeafBlock, %LeafBlock1
  %conv165 = zext i16 %19 to i32
  %and166 = and i32 %conv165, 24
  %Pivot19 = icmp slt i32 %and166, 16
  br i1 %Pivot19, label %NodeBlock10, label %NodeBlock16

NodeBlock16:                                      ; preds = %sw.epilog
  %Pivot17 = icmp slt i32 %and166, 24
  br i1 %Pivot17, label %LeafBlock12, label %LeafBlock14

LeafBlock14:                                      ; preds = %NodeBlock16
  %SwitchLeaf15 = icmp eq i32 %and166, 24
  br i1 %SwitchLeaf15, label %do.body211, label %do.body231

LeafBlock12:                                      ; preds = %NodeBlock16
  %SwitchLeaf13 = icmp eq i32 %and166, 16
  br i1 %SwitchLeaf13, label %do.body211, label %do.body231

NodeBlock10:                                      ; preds = %sw.epilog
  %Pivot11 = icmp slt i32 %and166, 8
  br i1 %Pivot11, label %LeafBlock6, label %LeafBlock8

LeafBlock8:                                       ; preds = %NodeBlock10
  %SwitchLeaf9 = icmp eq i32 %and166, 8
  br i1 %SwitchLeaf9, label %do.body190, label %do.body231

LeafBlock6:                                       ; preds = %NodeBlock10
  %SwitchLeaf7 = icmp eq i32 %and166, 0
  br i1 %SwitchLeaf7, label %do.body169, label %do.body231

do.body169:                                       ; preds = %LeafBlock6
  %bf.load170 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.206 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr171 = lshr i32 %bf.load170, 18
  %bf.clear172 = and i32 %bf.lshr171, 255
  %and173 = and i32 %bf.clear172, 1
  %tobool174 = icmp ne i32 %and173, 0
  %lnot175 = xor i1 %tobool174, true
  %lnot177 = xor i1 %lnot175, true
  %lnot.ext178 = zext i1 %lnot177 to i32
  %conv179 = sext i32 %lnot.ext178 to i64
  %expval180 = call i64 @llvm.expect.i64(i64 %conv179, i64 0)
  %tobool181 = icmp ne i64 %expval180, 0
  br i1 %tobool181, label %if.then182, label %do.body231

if.then182:                                       ; preds = %do.body169
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.206 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.207, i32 0, i32 0))
  br label %do.body231

do.body190:                                       ; preds = %LeafBlock8
  %bf.load191 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.208 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr192 = lshr i32 %bf.load191, 18
  %bf.clear193 = and i32 %bf.lshr192, 255
  %and194 = and i32 %bf.clear193, 1
  %tobool195 = icmp ne i32 %and194, 0
  %lnot196 = xor i1 %tobool195, true
  %lnot198 = xor i1 %lnot196, true
  %lnot.ext199 = zext i1 %lnot198 to i32
  %conv200 = sext i32 %lnot.ext199 to i64
  %expval201 = call i64 @llvm.expect.i64(i64 %conv200, i64 0)
  %tobool202 = icmp ne i64 %expval201, 0
  br i1 %tobool202, label %if.then203, label %do.body231

if.then203:                                       ; preds = %do.body190
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.208 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.209, i32 0, i32 0))
  br label %do.body231

do.body211:                                       ; preds = %LeafBlock12, %LeafBlock14
  %bf.load212 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.210 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr213 = lshr i32 %bf.load212, 18
  %bf.clear214 = and i32 %bf.lshr213, 255
  %and215 = and i32 %bf.clear214, 1
  %tobool216 = icmp ne i32 %and215, 0
  %lnot217 = xor i1 %tobool216, true
  %lnot219 = xor i1 %lnot217, true
  %lnot.ext220 = zext i1 %lnot219 to i32
  %conv221 = sext i32 %lnot.ext220 to i64
  %expval222 = call i64 @llvm.expect.i64(i64 %conv221, i64 0)
  %tobool223 = icmp ne i64 %expval222, 0
  br i1 %tobool223, label %if.then224, label %do.body231

if.then224:                                       ; preds = %do.body211
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.210 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.211, i32 0, i32 0))
  br label %do.body231

do.body231:                                       ; preds = %if.then224, %do.body211, %if.then203, %do.body190, %if.then182, %do.body169, %LeafBlock6, %LeafBlock8, %LeafBlock12, %LeafBlock14
  %tt234 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %lock235 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt234, i32 0, i32 4
  %22 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock235, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %22 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.213, i32 0, i32 0), %struct.lock_class_key* @hub_configure.__key.212)
  %tt240 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %clear_list = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt240, i32 0, i32 5
  call void @INIT_LIST_HEAD.35(%struct.list_head* %clear_list)
  %tt242 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %clear_work = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt242, i32 0, i32 6
  call void @__init_work(%struct.work_struct* %clear_work, i32 0)
  %tt243 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %clear_work244 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt243, i32 0, i32 6
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %clear_work244, i32 0, i32 0
  %counter = getelementptr inbounds %union.anon.3, %union.anon.3* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !287
  %23 = bitcast %union.anon.3* %data to i8*
  %24 = bitcast %union.anon.3* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %23, i8* %24, i64 8, i32 8, i1 false), !tbaa.struct !288
  %tt245 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %clear_work246 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt245, i32 0, i32 6
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %clear_work246, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.215, i32 0, i32 0), %struct.lock_class_key* @hub_configure.__key.214, i32 0)
  %tt247 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %clear_work248 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt247, i32 0, i32 6
  %entry249 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %clear_work248, i32 0, i32 1
  call void @INIT_LIST_HEAD.35(%struct.list_head* %entry249)
  %tt250 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %clear_work251 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt250, i32 0, i32 6
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %clear_work251, i32 0, i32 2
  store void (%struct.work_struct*)* @hub_tt_work, void (%struct.work_struct*)** %func, align 8, !tbaa !289
  %descriptor254 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 12
  %bDeviceProtocol = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor254, i32 0, i32 5
  %25 = load i8, i8* %bDeviceProtocol, align 2, !tbaa !205
  %conv255 = zext i8 %25 to i32
  %Pivot30 = icmp slt i32 %conv255, 2
  br i1 %Pivot30, label %NodeBlock23, label %NodeBlock27

NodeBlock27:                                      ; preds = %do.body231
  %Pivot28 = icmp slt i32 %conv255, 3
  br i1 %Pivot28, label %sw.bb279, label %LeafBlock25

LeafBlock25:                                      ; preds = %NodeBlock27
  %SwitchLeaf26 = icmp eq i32 %conv255, 3
  br i1 %SwitchLeaf26, label %sw.epilog332, label %do.body310

NodeBlock23:                                      ; preds = %do.body231
  %Pivot24 = icmp slt i32 %conv255, 1
  br i1 %Pivot24, label %LeafBlock21, label %do.body258

LeafBlock21:                                      ; preds = %NodeBlock23
  %SwitchLeaf22 = icmp eq i32 %conv255, 0
  br i1 %SwitchLeaf22, label %sw.epilog332, label %do.body310

do.body258:                                       ; preds = %NodeBlock23
  %bf.load259 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.216 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr260 = lshr i32 %bf.load259, 18
  %bf.clear261 = and i32 %bf.lshr260, 255
  %and262 = and i32 %bf.clear261, 1
  %tobool263 = icmp ne i32 %and262, 0
  %lnot264 = xor i1 %tobool263, true
  %lnot266 = xor i1 %lnot264, true
  %lnot.ext267 = zext i1 %lnot266 to i32
  %conv268 = sext i32 %lnot.ext267 to i64
  %expval269 = call i64 @llvm.expect.i64(i64 %conv268, i64 0)
  %tobool270 = icmp ne i64 %expval269, 0
  br i1 %tobool270, label %if.then271, label %do.end276

if.then271:                                       ; preds = %do.body258
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.216 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.217, i32 0, i32 0))
  br label %do.end276

do.end276:                                        ; preds = %if.then271, %do.body258
  %tt277 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %hub278 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt277, i32 0, i32 0
  store %struct.usb_device* %0, %struct.usb_device** %hub278, align 8, !tbaa !183
  br label %sw.epilog332

sw.bb279:                                         ; preds = %NodeBlock27
  %call280 = call i32 @usb_set_interface(%struct.usb_device* %0, i32 0, i32 1)
  %cmp281 = icmp eq i32 %call280, 0
  br i1 %cmp281, label %do.body285, label %if.else305

do.body285:                                       ; preds = %sw.bb279
  %bf.load286 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.218 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr287 = lshr i32 %bf.load286, 18
  %bf.clear288 = and i32 %bf.lshr287, 255
  %and289 = and i32 %bf.clear288, 1
  %tobool290 = icmp ne i32 %and289, 0
  %lnot291 = xor i1 %tobool290, true
  %lnot293 = xor i1 %lnot291, true
  %lnot.ext294 = zext i1 %lnot293 to i32
  %conv295 = sext i32 %lnot.ext294 to i64
  %expval296 = call i64 @llvm.expect.i64(i64 %conv295, i64 0)
  %tobool297 = icmp ne i64 %expval296, 0
  br i1 %tobool297, label %if.then298, label %do.end303

if.then298:                                       ; preds = %do.body285
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.218 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.219, i32 0, i32 0))
  br label %do.end303

do.end303:                                        ; preds = %if.then298, %do.body285
  %tt304 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %multi = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt304, i32 0, i32 1
  store i32 1, i32* %multi, align 8, !tbaa !303
  br label %if.end306

if.else305:                                       ; preds = %sw.bb279
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end306

if.end306:                                        ; preds = %if.else305, %do.end303
  %tt307 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %hub308 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt307, i32 0, i32 0
  store %struct.usb_device* %0, %struct.usb_device** %hub308, align 8, !tbaa !183
  br label %sw.epilog332

do.body310:                                       ; preds = %LeafBlock21, %LeafBlock25
  %bf.load311 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.221 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr312 = lshr i32 %bf.load311, 18
  %bf.clear313 = and i32 %bf.lshr312, 255
  %and314 = and i32 %bf.clear313, 1
  %tobool315 = icmp ne i32 %and314, 0
  %lnot316 = xor i1 %tobool315, true
  %lnot318 = xor i1 %lnot316, true
  %lnot.ext319 = zext i1 %lnot318 to i32
  %conv320 = sext i32 %lnot.ext319 to i64
  %expval321 = call i64 @llvm.expect.i64(i64 %conv320, i64 0)
  %tobool322 = icmp ne i64 %expval321, 0
  br i1 %tobool322, label %if.then323, label %sw.epilog332

if.then323:                                       ; preds = %do.body310
  %descriptor324 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 12
  %bDeviceProtocol325 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor324, i32 0, i32 5
  %26 = load i8, i8* %bDeviceProtocol325, align 2, !tbaa !205
  %conv326 = zext i8 %26 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.221 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.222, i32 0, i32 0), i32 %conv326)
  br label %sw.epilog332

sw.epilog332:                                     ; preds = %if.then323, %do.body310, %if.end306, %do.end276, %LeafBlock21, %LeafBlock25
  %conv333 = zext i16 %19 to i32
  %and334 = and i32 %conv333, 96
  %Pivot45 = icmp slt i32 %and334, 64
  br i1 %Pivot45, label %NodeBlock36, label %NodeBlock42

NodeBlock42:                                      ; preds = %sw.epilog332
  %Pivot43 = icmp slt i32 %and334, 96
  br i1 %Pivot43, label %LeafBlock38, label %LeafBlock40

LeafBlock40:                                      ; preds = %NodeBlock42
  %SwitchLeaf41 = icmp eq i32 %and334, 96
  br i1 %SwitchLeaf41, label %sw.bb416, label %sw.epilog441

LeafBlock38:                                      ; preds = %NodeBlock42
  %SwitchLeaf39 = icmp eq i32 %and334, 64
  br i1 %SwitchLeaf39, label %sw.bb391, label %sw.epilog441

NodeBlock36:                                      ; preds = %sw.epilog332
  %Pivot37 = icmp slt i32 %and334, 32
  br i1 %Pivot37, label %LeafBlock32, label %LeafBlock34

LeafBlock34:                                      ; preds = %NodeBlock36
  %SwitchLeaf35 = icmp eq i32 %and334, 32
  br i1 %SwitchLeaf35, label %sw.bb366, label %sw.epilog441

LeafBlock32:                                      ; preds = %NodeBlock36
  %SwitchLeaf33 = icmp eq i32 %and334, 0
  br i1 %SwitchLeaf33, label %sw.bb335, label %sw.epilog441

sw.bb335:                                         ; preds = %LeafBlock32
  %descriptor336 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 12
  %bDeviceProtocol337 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor336, i32 0, i32 5
  %27 = load i8, i8* %bDeviceProtocol337, align 2, !tbaa !205
  %conv338 = zext i8 %27 to i32
  %cmp339 = icmp ne i32 %conv338, 0
  br i1 %cmp339, label %if.then341, label %sw.epilog441

if.then341:                                       ; preds = %sw.bb335
  %tt342 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %think_time = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt342, i32 0, i32 2
  store i32 666, i32* %think_time, align 4, !tbaa !304
  %bf.load345 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.223 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr346 = lshr i32 %bf.load345, 18
  %bf.clear347 = and i32 %bf.lshr346, 255
  %and348 = and i32 %bf.clear347, 1
  %tobool349 = icmp ne i32 %and348, 0
  %lnot350 = xor i1 %tobool349, true
  %lnot352 = xor i1 %lnot350, true
  %lnot.ext353 = zext i1 %lnot352 to i32
  %conv354 = sext i32 %lnot.ext353 to i64
  %expval355 = call i64 @llvm.expect.i64(i64 %conv354, i64 0)
  %tobool356 = icmp ne i64 %expval355, 0
  br i1 %tobool356, label %if.then357, label %sw.epilog441

if.then357:                                       ; preds = %if.then341
  %tt358 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %think_time359 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt358, i32 0, i32 2
  %28 = load i32, i32* %think_time359, align 4, !tbaa !304
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.223 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.224, i32 0, i32 0), i32 8, i32 %28)
  br label %sw.epilog441

sw.bb366:                                         ; preds = %LeafBlock34
  %tt367 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %think_time368 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt367, i32 0, i32 2
  store i32 1332, i32* %think_time368, align 4, !tbaa !304
  %bf.load371 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.225 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr372 = lshr i32 %bf.load371, 18
  %bf.clear373 = and i32 %bf.lshr372, 255
  %and374 = and i32 %bf.clear373, 1
  %tobool375 = icmp ne i32 %and374, 0
  %lnot376 = xor i1 %tobool375, true
  %lnot378 = xor i1 %lnot376, true
  %lnot.ext379 = zext i1 %lnot378 to i32
  %conv380 = sext i32 %lnot.ext379 to i64
  %expval381 = call i64 @llvm.expect.i64(i64 %conv380, i64 0)
  %tobool382 = icmp ne i64 %expval381, 0
  br i1 %tobool382, label %if.then383, label %sw.epilog441

if.then383:                                       ; preds = %sw.bb366
  %tt384 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %think_time385 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt384, i32 0, i32 2
  %29 = load i32, i32* %think_time385, align 4, !tbaa !304
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.225 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.224, i32 0, i32 0), i32 16, i32 %29)
  br label %sw.epilog441

sw.bb391:                                         ; preds = %LeafBlock38
  %tt392 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %think_time393 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt392, i32 0, i32 2
  store i32 1998, i32* %think_time393, align 4, !tbaa !304
  %bf.load396 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.226 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr397 = lshr i32 %bf.load396, 18
  %bf.clear398 = and i32 %bf.lshr397, 255
  %and399 = and i32 %bf.clear398, 1
  %tobool400 = icmp ne i32 %and399, 0
  %lnot401 = xor i1 %tobool400, true
  %lnot403 = xor i1 %lnot401, true
  %lnot.ext404 = zext i1 %lnot403 to i32
  %conv405 = sext i32 %lnot.ext404 to i64
  %expval406 = call i64 @llvm.expect.i64(i64 %conv405, i64 0)
  %tobool407 = icmp ne i64 %expval406, 0
  br i1 %tobool407, label %if.then408, label %sw.epilog441

if.then408:                                       ; preds = %sw.bb391
  %tt409 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %think_time410 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt409, i32 0, i32 2
  %30 = load i32, i32* %think_time410, align 4, !tbaa !304
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.226 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.224, i32 0, i32 0), i32 24, i32 %30)
  br label %sw.epilog441

sw.bb416:                                         ; preds = %LeafBlock40
  %tt417 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %think_time418 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt417, i32 0, i32 2
  store i32 2664, i32* %think_time418, align 4, !tbaa !304
  %bf.load421 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.227 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr422 = lshr i32 %bf.load421, 18
  %bf.clear423 = and i32 %bf.lshr422, 255
  %and424 = and i32 %bf.clear423, 1
  %tobool425 = icmp ne i32 %and424, 0
  %lnot426 = xor i1 %tobool425, true
  %lnot428 = xor i1 %lnot426, true
  %lnot.ext429 = zext i1 %lnot428 to i32
  %conv430 = sext i32 %lnot.ext429 to i64
  %expval431 = call i64 @llvm.expect.i64(i64 %conv430, i64 0)
  %tobool432 = icmp ne i64 %expval431, 0
  br i1 %tobool432, label %if.then433, label %sw.epilog441

if.then433:                                       ; preds = %sw.bb416
  %tt434 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %think_time435 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt434, i32 0, i32 2
  %31 = load i32, i32* %think_time435, align 4, !tbaa !304
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.227 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.224, i32 0, i32 0), i32 32, i32 %31)
  br label %sw.epilog441

sw.epilog441:                                     ; preds = %if.then433, %sw.bb416, %if.then408, %sw.bb391, %if.then383, %sw.bb366, %if.then357, %if.then341, %sw.bb335, %LeafBlock32, %LeafBlock34, %LeafBlock38, %LeafBlock40
  %conv442 = zext i16 %19 to i32
  %and443 = and i32 %conv442, 128
  %tobool444 = icmp ne i32 %and443, 0
  br i1 %tobool444, label %if.then445, label %do.body470

if.then445:                                       ; preds = %sw.epilog441
  %has_indicators = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  %bf.load446 = load i8, i8* %has_indicators, align 8
  %bf.clear447 = and i8 %bf.load446, -33
  %bf.set = or i8 %bf.clear447, 32
  store i8 %bf.set, i8* %has_indicators, align 8
  %bf.load450 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.228 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr451 = lshr i32 %bf.load450, 18
  %bf.clear452 = and i32 %bf.lshr451, 255
  %and453 = and i32 %bf.clear452, 1
  %tobool454 = icmp ne i32 %and453, 0
  %lnot455 = xor i1 %tobool454, true
  %lnot457 = xor i1 %lnot455, true
  %lnot.ext458 = zext i1 %lnot457 to i32
  %conv459 = sext i32 %lnot.ext458 to i64
  %expval460 = call i64 @llvm.expect.i64(i64 %conv459, i64 0)
  %tobool461 = icmp ne i64 %expval460, 0
  br i1 %tobool461, label %if.then462, label %do.body470

if.then462:                                       ; preds = %if.then445
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.228 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.229, i32 0, i32 0))
  br label %do.body470

do.body470:                                       ; preds = %if.then462, %if.then445, %sw.epilog441
  %bf.load471 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.230 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr472 = lshr i32 %bf.load471, 18
  %bf.clear473 = and i32 %bf.lshr472, 255
  %and474 = and i32 %bf.clear473, 1
  %tobool475 = icmp ne i32 %and474, 0
  %lnot476 = xor i1 %tobool475, true
  %lnot478 = xor i1 %lnot476, true
  %lnot.ext479 = zext i1 %lnot478 to i32
  %conv480 = sext i32 %lnot.ext479 to i64
  %expval481 = call i64 @llvm.expect.i64(i64 %conv480, i64 0)
  %tobool482 = icmp ne i64 %expval481, 0
  br i1 %tobool482, label %if.then483, label %do.end491

if.then483:                                       ; preds = %do.body470
  %descriptor484 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %32 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor484, align 8, !tbaa !232
  %bPwrOn2PwrGood = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %32, i32 0, i32 4
  %33 = load i8, i8* %bPwrOn2PwrGood, align 1, !tbaa !298
  %conv485 = zext i8 %33 to i32
  %mul486 = mul nsw i32 %conv485, 2
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.230 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.231, i32 0, i32 0), i32 %mul486)
  br label %do.end491

do.end491:                                        ; preds = %if.then483, %do.body470
  %34 = bitcast i16* %hubstatus to i8*
  %call492 = call i32 @usb_get_status(%struct.usb_device* %0, i32 0, i32 0, i8* %34)
  %tobool493 = icmp ne i32 %call492, 0
  br i1 %tobool493, label %fail, label %if.end495

if.end495:                                        ; preds = %do.end491
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %35 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call496 = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %35)
  %bus497 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %36 = load %struct.usb_bus*, %struct.usb_bus** %bus497, align 8, !tbaa !2
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %36, i32 0, i32 11
  %37 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !264
  %cmp498 = icmp eq %struct.usb_device* %0, %37
  br i1 %cmp498, label %if.then500, label %if.else524

if.then500:                                       ; preds = %if.end495
  %power_budget = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call496, i32 0, i32 17
  %38 = load i32, i32* %power_budget, align 8, !tbaa !305
  %cmp501 = icmp ugt i32 %38, 0
  br i1 %cmp501, label %if.then503, label %if.else506

if.then503:                                       ; preds = %if.then500
  %power_budget504 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call496, i32 0, i32 17
  %39 = load i32, i32* %power_budget504, align 8, !tbaa !305
  br label %if.end510

if.else506:                                       ; preds = %if.then500
  %mul507 = mul i32 %.46, %conv32
  br label %if.end510

if.end510:                                        ; preds = %if.else506, %if.then503
  %mul507.sink = phi i32 [ %mul507, %if.else506 ], [ %39, %if.then503 ]
  %conv508 = trunc i32 %mul507.sink to i16
  %bus_mA509 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 19
  store i16 %conv508, i16* %bus_mA509, align 8, !tbaa !306
  %bus_mA511 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 19
  %40 = load i16, i16* %bus_mA511, align 8, !tbaa !306
  %conv512 = zext i16 %40 to i32
  %cmp513 = icmp uge i32 %conv512, %.46
  br i1 %cmp513, label %if.then515, label %if.else516

if.then515:                                       ; preds = %if.end510
  %mA_per_port = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  store i32 %.46, i32* %mA_per_port, align 8, !tbaa !307
  br label %if.end570

if.else516:                                       ; preds = %if.end510
  %bus_mA517 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 19
  %41 = load i16, i16* %bus_mA517, align 8, !tbaa !306
  %conv518 = zext i16 %41 to i32
  %mA_per_port519 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  store i32 %conv518, i32* %mA_per_port519, align 8, !tbaa !307
  %limited_power = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  %bf.load520 = load i8, i8* %limited_power, align 8
  %bf.clear521 = and i8 %bf.load520, -2
  %bf.set522 = or i8 %bf.clear521, 1
  store i8 %bf.set522, i8* %limited_power, align 8
  br label %if.end570

if.else524:                                       ; preds = %if.end495
  %42 = load i16, i16* %hubstatus, align 2, !tbaa !165
  %conv525 = zext i16 %42 to i32
  %and526 = and i32 %conv525, 1
  %cmp527 = icmp eq i32 %and526, 0
  br i1 %cmp527, label %if.then529, label %if.end569

if.then529:                                       ; preds = %if.else524
  %bus_mA530 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 19
  %43 = load i16, i16* %bus_mA530, align 8, !tbaa !306
  %conv531 = zext i16 %43 to i32
  %descriptor532 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %44 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor532, align 8, !tbaa !232
  %bHubContrCurrent = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %44, i32 0, i32 5
  %45 = load i8, i8* %bHubContrCurrent, align 1, !tbaa !308
  %conv533 = zext i8 %45 to i32
  %sub = sub nsw i32 %conv531, %conv533
  %bf.load536 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.233 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr537 = lshr i32 %bf.load536, 18
  %bf.clear538 = and i32 %bf.lshr537, 255
  %and539 = and i32 %bf.clear538, 1
  %tobool540 = icmp ne i32 %and539, 0
  %lnot541 = xor i1 %tobool540, true
  %lnot543 = xor i1 %lnot541, true
  %lnot.ext544 = zext i1 %lnot543 to i32
  %conv545 = sext i32 %lnot.ext544 to i64
  %expval546 = call i64 @llvm.expect.i64(i64 %conv545, i64 0)
  %tobool547 = icmp ne i64 %expval546, 0
  br i1 %tobool547, label %if.then548, label %do.end556

if.then548:                                       ; preds = %if.then529
  %descriptor549 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %46 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor549, align 8, !tbaa !232
  %bHubContrCurrent550 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %46, i32 0, i32 5
  %47 = load i8, i8* %bHubContrCurrent550, align 1, !tbaa !308
  %conv551 = zext i8 %47 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.233 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.234, i32 0, i32 0), i32 %conv551)
  br label %do.end556

do.end556:                                        ; preds = %if.then548, %if.then529
  %limited_power557 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  %bf.load558 = load i8, i8* %limited_power557, align 8
  %bf.clear559 = and i8 %bf.load558, -2
  %bf.set560 = or i8 %bf.clear559, 1
  store i8 %bf.set560, i8* %limited_power557, align 8
  %mul561 = mul i32 %conv32, %.
  %cmp562 = icmp ult i32 %sub, %mul561
  br i1 %cmp562, label %if.then564, label %if.end569

if.then564:                                       ; preds = %do.end556
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end569

if.end569:                                        ; preds = %if.then564, %do.end556, %if.else524
  %.46.sink = phi i32 [ %.46, %if.else524 ], [ %., %if.then564 ], [ %., %do.end556 ]
  %mA_per_port568 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  store i32 %.46.sink, i32* %mA_per_port568, align 8, !tbaa !307
  br label %if.end570

if.end570:                                        ; preds = %if.end569, %if.else516, %if.then515
  %mA_per_port571 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %48 = load i32, i32* %mA_per_port571, align 8, !tbaa !307
  %cmp572 = icmp ult i32 %48, %.46
  br i1 %cmp572, label %do.body576, label %if.end596

do.body576:                                       ; preds = %if.end570
  %bf.load577 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.236 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr578 = lshr i32 %bf.load577, 18
  %bf.clear579 = and i32 %bf.lshr578, 255
  %and580 = and i32 %bf.clear579, 1
  %tobool581 = icmp ne i32 %and580, 0
  %lnot582 = xor i1 %tobool581, true
  %lnot584 = xor i1 %lnot582, true
  %lnot.ext585 = zext i1 %lnot584 to i32
  %conv586 = sext i32 %lnot.ext585 to i64
  %expval587 = call i64 @llvm.expect.i64(i64 %conv586, i64 0)
  %tobool588 = icmp ne i64 %expval587, 0
  br i1 %tobool588, label %if.then589, label %if.end596

if.then589:                                       ; preds = %do.body576
  %mA_per_port590 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %49 = load i32, i32* %mA_per_port590, align 8, !tbaa !307
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.236 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.237, i32 0, i32 0), i32 %49)
  br label %if.end596

if.end596:                                        ; preds = %if.then589, %do.body576, %if.end570
  %call597 = call i32 @hub_hub_status(%struct.usb_hub* %hub, i16* %hubstatus, i16* %hubchange)
  %cmp598 = icmp slt i32 %call597, 0
  br i1 %cmp598, label %fail, label %if.end601

if.end601:                                        ; preds = %if.end596
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 15
  %50 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %50, i32 0, i32 0
  %bmAttributes = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 6
  %51 = load i8, i8* %bmAttributes, align 1, !tbaa !200
  %conv602 = zext i8 %51 to i32
  %and603 = and i32 %conv602, 64
  %tobool604 = icmp ne i32 %and603, 0
  br i1 %tobool604, label %do.body607, label %if.end630

do.body607:                                       ; preds = %if.end601
  %bf.load608 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.238 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr609 = lshr i32 %bf.load608, 18
  %bf.clear610 = and i32 %bf.lshr609, 255
  %and611 = and i32 %bf.clear610, 1
  %tobool612 = icmp ne i32 %and611, 0
  %lnot613 = xor i1 %tobool612, true
  %lnot615 = xor i1 %lnot613, true
  %lnot.ext616 = zext i1 %lnot615 to i32
  %conv617 = sext i32 %lnot.ext616 to i64
  %expval618 = call i64 @llvm.expect.i64(i64 %conv617, i64 0)
  %tobool619 = icmp ne i64 %expval618, 0
  br i1 %tobool619, label %if.then620, label %if.end630

if.then620:                                       ; preds = %do.body607
  %52 = load i16, i16* %hubstatus, align 2, !tbaa !165
  %conv621 = zext i16 %52 to i32
  %and622 = and i32 %conv621, 1
  %tobool623 = icmp ne i32 %and622, 0
  %cond624 = select i1 %tobool623, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.240, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.241, i32 0, i32 0)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.238 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.239, i32 0, i32 0), i8* %cond624)
  br label %if.end630

if.end630:                                        ; preds = %if.then620, %do.body607, %if.end601
  %conv631 = zext i16 %19 to i32
  %and632 = and i32 %conv631, 24
  %cmp633 = icmp eq i32 %and632, 0
  br i1 %cmp633, label %do.body637, label %if.end660

do.body637:                                       ; preds = %if.end630
  %bf.load638 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.242 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr639 = lshr i32 %bf.load638, 18
  %bf.clear640 = and i32 %bf.lshr639, 255
  %and641 = and i32 %bf.clear640, 1
  %tobool642 = icmp ne i32 %and641, 0
  %lnot643 = xor i1 %tobool642, true
  %lnot645 = xor i1 %lnot643, true
  %lnot.ext646 = zext i1 %lnot645 to i32
  %conv647 = sext i32 %lnot.ext646 to i64
  %expval648 = call i64 @llvm.expect.i64(i64 %conv647, i64 0)
  %tobool649 = icmp ne i64 %expval648, 0
  br i1 %tobool649, label %if.then650, label %if.end660

if.then650:                                       ; preds = %do.body637
  %53 = load i16, i16* %hubstatus, align 2, !tbaa !165
  %conv651 = zext i16 %53 to i32
  %and652 = and i32 %conv651, 2
  %tobool653 = icmp ne i32 %and652, 0
  %cond654 = select i1 %tobool653, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.28.900, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.244, i32 0, i32 0)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.242 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.243, i32 0, i32 0), i8* %cond654)
  br label %if.end660

if.end660:                                        ; preds = %if.then650, %do.body637, %if.end630
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %endpoint, i32 0, i32 2
  %54 = load i8, i8* %bEndpointAddress, align 1, !tbaa !309
  %conv661 = zext i8 %54 to i32
  %call662 = call i32 @__create_pipe(%struct.usb_device* %0, i32 %conv661)
  %or = or i32 1073741824, %call662
  %or663 = or i32 %or, 128
  %and664 = and i32 %or663, 128
  %tobool665 = icmp ne i32 %and664, 0
  %lnot666 = xor i1 %tobool665, true
  %lnot.ext667 = zext i1 %lnot666 to i32
  %call668 = call zeroext i16 @usb_maxpacket(%struct.usb_device* %0, i32 %or663, i32 %lnot.ext667)
  %conv669 = zext i16 %call668 to i32
  %conv670 = sext i32 %conv669 to i64
  %cmp671 = icmp ugt i64 %conv670, 8
  %.conv669 = select i1 %cmp671, i32 8, i32 %conv669
  %call675 = call %struct.urb* bitcast (%struct.urb.744* (i32, i32)* @usb_alloc_urb to %struct.urb* (i32, i32)*)(i32 0, i32 20971712)
  %urb = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 3
  store %struct.urb* %call675, %struct.urb** %urb, align 8, !tbaa !293
  %urb676 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 3
  %55 = load %struct.urb*, %struct.urb** %urb676, align 8, !tbaa !293
  %tobool677 = icmp ne %struct.urb* %55, null
  br i1 %tobool677, label %if.end679, label %fail

if.end679:                                        ; preds = %if.end660
  %urb680 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 3
  %56 = load %struct.urb*, %struct.urb** %urb680, align 8, !tbaa !293
  %buffer681 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 4
  %57 = load [8 x i8]*, [8 x i8]** %buffer681, align 8, !tbaa !294
  %arraydecay682 = getelementptr inbounds [8 x i8], [8 x i8]* %57, i32 0, i32 0
  %58 = bitcast %struct.usb_hub* %hub to i8*
  %bInterval = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %endpoint, i32 0, i32 5
  %59 = load i8, i8* %bInterval, align 1, !tbaa !310
  %conv683 = zext i8 %59 to i32
  call void @usb_fill_int_urb(%struct.urb* %56, %struct.usb_device* %0, i32 %or663, i8* %arraydecay682, i32 %.conv669, void (%struct.urb*)* @hub_irq, i8* %58, i32 %conv683)
  %has_indicators684 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  %bf.load685 = load i8, i8* %has_indicators684, align 8
  %bf.lshr686 = lshr i8 %bf.load685, 5
  %bf.clear687 = and i8 %bf.lshr686, 1
  %bf.cast = zext i8 %bf.clear687 to i32
  %tobool688 = icmp ne i32 %bf.cast, 0
  br i1 %tobool688, label %land.lhs.true689, label %if.end694

land.lhs.true689:                                 ; preds = %if.end679
  %60 = load i8, i8* @blinkenlights, align 1, !tbaa !109, !range !110
  %tobool690 = trunc i8 %60 to i1
  br i1 %tobool690, label %if.then692, label %if.end694

if.then692:                                       ; preds = %land.lhs.true689
  %indicator = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 21
  %arrayidx693 = getelementptr inbounds [31 x i8], [31 x i8]* %indicator, i64 0, i64 0
  store i8 1, i8* %arrayidx693, align 1, !tbaa !72
  br label %if.end694

if.end694:                                        ; preds = %if.then692, %land.lhs.true689, %if.end679
  call void @mutex_lock_nested(%struct.mutex* @usb_port_peer_mutex, i32 0)
  br label %for.cond695

for.cond695:                                      ; preds = %for.inc707, %if.end694
  %ret.0 = phi i32 [ %call597, %if.end694 ], [ %call700, %for.inc707 ]
  %i.1 = phi i32 [ 0, %if.end694 ], [ %inc708, %for.inc707 ]
  %cmp696 = icmp ult i32 %i.1, %conv32
  br i1 %cmp696, label %for.body698, label %for.end709

for.body698:                                      ; preds = %for.cond695
  %add699 = add nsw i32 %i.1, 1
  %call700 = call i32 bitcast (i32 (%struct.usb_hub.5605*, i32)* @usb_hub_create_port_device to i32 (%struct.usb_hub*, i32)*)(%struct.usb_hub* %hub, i32 %add699)
  %cmp701 = icmp slt i32 %call700, 0
  br i1 %cmp701, label %if.then703, label %for.inc707

if.then703:                                       ; preds = %for.body698
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %for.end709

for.inc707:                                       ; preds = %for.body698
  %inc708 = add nsw i32 %i.1, 1
  br label %for.cond695

for.end709:                                       ; preds = %if.then703, %for.cond695
  %ret.1 = phi i32 [ %call700, %if.then703 ], [ %ret.0, %for.cond695 ]
  %maxchild710 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  store i32 %i.1, i32* %maxchild710, align 8, !tbaa !111
  br label %for.cond711

for.cond711:                                      ; preds = %for.body715, %for.end709
  %i.2 = phi i32 [ 0, %for.end709 ], [ %inc721, %for.body715 ]
  %maxchild712 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %61 = load i32, i32* %maxchild712, align 8, !tbaa !111
  %cmp713 = icmp slt i32 %i.2, %61
  br i1 %cmp713, label %for.body715, label %for.end722

for.body715:                                      ; preds = %for.cond711
  %ports716 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %62 = load %struct.usb_port**, %struct.usb_port*** %ports716, align 8, !tbaa !112
  %idxprom717 = sext i32 %i.2 to i64
  %arrayidx718 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %62, i64 %idxprom717
  %63 = load %struct.usb_port*, %struct.usb_port** %arrayidx718, align 8, !tbaa !52
  %dev = getelementptr inbounds %struct.usb_port, %struct.usb_port* %63, i32 0, i32 1
  call void @pm_runtime_put(%struct.device* %dev)
  %inc721 = add nsw i32 %i.2, 1
  br label %for.cond711

for.end722:                                       ; preds = %for.cond711
  call void @mutex_unlock(%struct.mutex* @usb_port_peer_mutex)
  %cmp723 = icmp slt i32 %ret.1, 0
  br i1 %cmp723, label %fail, label %if.end726

if.end726:                                        ; preds = %for.end722
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call496, i32 0, i32 8
  %64 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %update_hub_device = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %64, i32 0, i32 36
  %65 = load i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)** %update_hub_device, align 8, !tbaa !297
  %tobool727 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)* %65, null
  br i1 %tobool727, label %if.then728, label %if.end737

if.then728:                                       ; preds = %if.end726
  %driver729 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call496, i32 0, i32 8
  %66 = load %struct.hc_driver*, %struct.hc_driver** %driver729, align 8, !tbaa !57
  %update_hub_device730 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %66, i32 0, i32 36
  %67 = load i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)** %update_hub_device730, align 8, !tbaa !297
  %tt731 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %call732 = call i32 %67(%struct.usb_hcd* %call496, %struct.usb_device* %0, %struct.usb_tt* %tt731, i32 20971712)
  %cmp733 = icmp slt i32 %call732, 0
  br i1 %cmp733, label %fail, label %if.end737

if.end737:                                        ; preds = %if.then728, %if.end726
  %descriptor738 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %68 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor738, align 8, !tbaa !232
  call void @usb_hub_adjust_deviceremovable(%struct.usb_device* %0, %struct.usb_hub_descriptor* %68)
  call void @hub_activate(%struct.usb_hub* %hub, i32 0)
  br label %cleanup

fail:                                             ; preds = %if.then728, %for.end722, %if.end660, %if.end596, %do.end491, %if.end29, %if.else20, %if.else, %if.end12, %do.body, %if.end, %entry
  %ret.2 = phi i32 [ -12, %entry ], [ -12, %if.end ], [ -12, %do.body ], [ %call14, %if.end12 ], [ -19, %if.else ], [ -19, %if.else20 ], [ -12, %if.end29 ], [ %call492, %do.end491 ], [ %call597, %if.end596 ], [ -12, %if.end660 ], [ %ret.1, %for.end722 ], [ %call732, %if.then728 ]
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %fail, %if.end737
  %retval.0 = phi i32 [ %ret.2, %fail ], [ 0, %if.end737 ]
  ret i32 %retval.0
}

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #2

; Function Attrs: nounwind uwtable
define internal i32 @get_hub_descriptor(%struct.usb_device* %hdev, i8* %data) #0 {
entry:
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %hdev)
  %tobool = icmp ne i32 %call, 0
  %. = select i1 %tobool, i32 12, i32 15
  %.1 = select i1 %tobool, i32 42, i32 41
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 3
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %call1 = call i32 @__create_pipe(%struct.usb_device* %hdev, i32 0)
  %or = or i32 -2147483648, %call1
  %or2 = or i32 %or, 128
  %shl = shl i32 %.1, 8
  %conv = trunc i32 %shl to i16
  %conv3 = trunc i32 %. to i16
  %call4 = call i32 @usb_control_msg(%struct.usb_device* %hdev, i32 %or2, i8 zeroext 6, i8 zeroext -96, i16 zeroext %conv, i16 zeroext 0, i8* %data, i16 zeroext %conv3, i32 5000)
  %cmp5 = icmp sge i32 %call4, 9
  br i1 %cmp5, label %cleanup, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.body, %for.cond
  %retval.0 = phi i32 [ %call4, %for.body ], [ -22, %for.cond ]
  ret i32 %retval.0
}

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #2

; Function Attrs: nounwind uwtable
define internal void @hub_tt_work(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -392
  %1 = bitcast i8* %add.ptr to %struct.usb_hub*
  br label %while.cond

while.cond:                                       ; preds = %if.end31, %entry
  %tt39 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 17
  %lock40 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt39, i32 0, i32 4
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock40, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  %call42 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %tt6 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 17
  %clear_list = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt6, i32 0, i32 5
  %call7 = call i32 @list_empty(%struct.list_head* %clear_list)
  %tobool = icmp ne i32 %call7, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %hdev8 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %hdev8, align 8, !tbaa !176
  %tt9 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 17
  %clear_list10 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt9, i32 0, i32 5
  %next11 = getelementptr inbounds %struct.list_head, %struct.list_head* %clear_list10, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next11, align 8, !tbaa !311
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr14 = getelementptr inbounds i8, i8* %5, i64 0
  %6 = bitcast i8* %add.ptr14 to %struct.usb_tt_clear*
  %clear_list15 = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %6, i32 0, i32 0
  call void @list_del(%struct.list_head* %clear_list15)
  %tt16 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 17
  %lock17 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt16, i32 0, i32 4
  %7 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock17, i32 0, i32 0
  %rlock.i4 = bitcast %union.anon.1* %7 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i4, i64 %call42) #8
  %devinfo = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %6, i32 0, i32 2
  %8 = load i16, i16* %devinfo, align 4, !tbaa !248
  %tt18 = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %6, i32 0, i32 1
  %9 = load i32, i32* %tt18, align 8, !tbaa !246
  %conv19 = trunc i32 %9 to i16
  %call20 = call i32 @hub_clear_tt_buffer(%struct.usb_device* %3, i16 zeroext %8, i16 zeroext %conv19)
  switch i32 %call20, label %if.then [
    i32 0, label %if.end
    i32 -19, label %if.end
  ]

if.then:                                          ; preds = %while.body
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body, %while.body
  %hcd = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %6, i32 0, i32 3
  %10 = load %struct.usb_hcd*, %struct.usb_hcd** %hcd, align 8, !tbaa !249
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %10, i32 0, i32 8
  %11 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %clear_tt_buffer_complete = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %11, i32 0, i32 25
  %12 = load void (%struct.usb_hcd*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd*, %struct.usb_host_endpoint*)** %clear_tt_buffer_complete, align 8, !tbaa !312
  %tobool27 = icmp ne void (%struct.usb_hcd*, %struct.usb_host_endpoint*)* %12, null
  br i1 %tobool27, label %if.then28, label %if.end31

if.then28:                                        ; preds = %if.end
  %clear_tt_buffer_complete29 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %11, i32 0, i32 25
  %13 = load void (%struct.usb_hcd*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd*, %struct.usb_host_endpoint*)** %clear_tt_buffer_complete29, align 8, !tbaa !312
  %hcd30 = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %6, i32 0, i32 3
  %14 = load %struct.usb_hcd*, %struct.usb_hcd** %hcd30, align 8, !tbaa !249
  %ep = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %6, i32 0, i32 4
  %15 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !251
  call void %13(%struct.usb_hcd* %14, %struct.usb_host_endpoint* %15)
  br label %if.end31

if.end31:                                         ; preds = %if.then28, %if.end
  %16 = bitcast %struct.usb_tt_clear* %6 to i8*
  call void @kfree(i8* %16)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %tt47 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 17
  %lock48 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt47, i32 0, i32 4
  %17 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock48, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %17 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call42) #8
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_hub_status(%struct.usb_hub* %hub, i16* %status, i16* %change) #0 {
entry:
  %status_mutex = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 6
  call void @mutex_lock_nested(%struct.mutex* %status_mutex, i32 0)
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %status1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  %1 = load %union.anon.62*, %union.anon.62** %status1, align 8, !tbaa !237
  %hub2 = bitcast %union.anon.62* %1 to %struct.usb_hub_status*
  %call = call i32 @get_hub_status(%struct.usb_device* %0, %struct.usb_hub_status* %hub2)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %cmp3 = icmp ne i32 %call, -19
  br i1 %cmp3, label %if.then4, label %if.end9

if.then4:                                         ; preds = %if.then
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end9

if.else:                                          ; preds = %entry
  %status5 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  %2 = load %union.anon.62*, %union.anon.62** %status5, align 8, !tbaa !237
  %hub6 = bitcast %union.anon.62* %2 to %struct.usb_hub_status*
  %wHubStatus = getelementptr inbounds %struct.usb_hub_status, %struct.usb_hub_status* %hub6, i32 0, i32 0
  %3 = load i16, i16* %wHubStatus, align 1, !tbaa !72
  store i16 %3, i16* %status, align 2, !tbaa !165
  %status7 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  %4 = load %union.anon.62*, %union.anon.62** %status7, align 8, !tbaa !237
  %hub8 = bitcast %union.anon.62* %4 to %struct.usb_hub_status*
  %wHubChange = getelementptr inbounds %struct.usb_hub_status, %struct.usb_hub_status* %hub8, i32 0, i32 1
  %5 = load i16, i16* %wHubChange, align 1, !tbaa !72
  store i16 %5, i16* %change, align 2, !tbaa !165
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then4, %if.then
  %ret.0 = phi i32 [ 0, %if.else ], [ %call, %if.then4 ], [ %call, %if.then ]
  %status_mutex10 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 6
  call void @mutex_unlock(%struct.mutex* %status_mutex10)
  ret i32 %ret.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @usb_maxpacket(%struct.usb_device* %udev, i32 %pipe, i32 %is_out) #1 {
entry:
  %shr = ashr i32 %pipe, 15
  %and = and i32 %shr, 15
  %tobool = icmp ne i32 %is_out, 0
  %and1 = and i32 %pipe, 128
  %tobool2 = icmp ne i32 %and1, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.55.816, i32 0, i32 0), i32 1854)
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.then
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 17
  br label %if.end47

if.else:                                          ; preds = %entry
  %lnot25 = xor i1 %lnot3, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %tobool27 = icmp ne i32 %lnot.ext26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.else
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.55.816, i32 0, i32 0), i32 1857)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.else
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 16
  br label %if.end47

if.end47:                                         ; preds = %if.end36, %if.end
  %ep_in.sink = phi [16 x %struct.usb_host_endpoint*]* [ %ep_in, %if.end36 ], [ %ep_out, %if.end ]
  %idxprom45 = zext i32 %and to i64
  %arrayidx46 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in.sink, i64 0, i64 %idxprom45
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx46, align 8, !tbaa !52
  %tobool48 = icmp ne %struct.usb_host_endpoint* %0, null
  br i1 %tobool48, label %if.end50, label %cleanup

if.end50:                                         ; preds = %if.end47
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %0, i32 0, i32 0
  %call = call i32 @usb_endpoint_maxp(%struct.usb_endpoint_descriptor* %desc)
  %conv51 = trunc i32 %call to i16
  br label %cleanup

cleanup:                                          ; preds = %if.end50, %if.end47
  %retval.0 = phi i16 [ %conv51, %if.end50 ], [ 0, %if.end47 ]
  ret i16 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @hub_irq(%struct.urb* %urb) #0 {
entry:
  %context = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  %0 = load i8*, i8** %context, align 8, !tbaa !313
  %1 = bitcast i8* %0 to %struct.usb_hub*
  %status1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 12
  %2 = load i32, i32* %status1, align 8, !tbaa !314
  %Pivot10 = icmp slt i32 %2, -2
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %2, 0
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %2, 0
  br i1 %SwitchLeaf6, label %sw.bb12, label %do.body2

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %2, -2
  br i1 %SwitchLeaf4, label %cleanup.cont, label %do.body2

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %2, -104
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %2, -104
  br i1 %SwitchLeaf2, label %cleanup.cont, label %do.body2

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %2, -108
  br i1 %SwitchLeaf, label %cleanup.cont, label %do.body2

do.body2:                                         ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_irq.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %do.end6

if.then:                                          ; preds = %do.body2
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 0
  %3 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !204
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_irq.descriptor to %struct._ddebug*), %struct.device* %3, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.250, i32 0, i32 0), i32 %2)
  br label %do.end6

do.end6:                                          ; preds = %if.then, %do.body2
  %nerrors = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 8
  %4 = load i32, i32* %nerrors, align 4, !tbaa !301
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %nerrors, align 4, !tbaa !301
  %cmp = icmp slt i32 %inc, 10
  br i1 %cmp, label %resubmit, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end6
  %error = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 7
  %5 = load i32, i32* %error, align 8, !tbaa !202
  %tobool8 = icmp ne i32 %5, 0
  br i1 %tobool8, label %resubmit, label %if.end10

if.end10:                                         ; preds = %lor.lhs.false
  %error11 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 7
  store i32 %2, i32* %error11, align 8, !tbaa !202
  br label %sw.bb12

sw.bb12:                                          ; preds = %if.end10, %LeafBlock5
  br label %for.cond

for.cond:                                         ; preds = %for.body, %sw.bb12
  %i.0 = phi i32 [ 0, %sw.bb12 ], [ %inc16, %for.body ]
  %bits.0 = phi i64 [ 0, %sw.bb12 ], [ %or, %for.body ]
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %6 = load i32, i32* %actual_length, align 4, !tbaa !315
  %cmp13 = icmp ult i32 %i.0, %6
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %buffer = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 4
  %7 = load [8 x i8]*, [8 x i8]** %buffer, align 8, !tbaa !294
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [8 x i8], [8 x i8]* %7, i64 0, i64 %idxprom
  %8 = load i8, i8* %arrayidx, align 1, !tbaa !72
  %conv15 = zext i8 %8 to i64
  %mul = mul i32 %i.0, 8
  %sh_prom = zext i32 %mul to i64
  %shl = shl i64 %conv15, %sh_prom
  %or = or i64 %bits.0, %shl
  %inc16 = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %event_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 9
  %arrayidx17 = getelementptr inbounds [1 x i64], [1 x i64]* %event_bits, i64 0, i64 0
  store i64 %bits.0, i64* %arrayidx17, align 8, !tbaa !53
  %nerrors18 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 8
  store i32 0, i32* %nerrors18, align 4, !tbaa !301
  call void @kick_hub_wq(%struct.usb_hub* %1)
  br label %resubmit

resubmit:                                         ; preds = %for.end, %lor.lhs.false, %do.end6
  %quiescing = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 20
  %bf.load19 = load i8, i8* %quiescing, align 8
  %bf.lshr20 = lshr i8 %bf.load19, 1
  %bf.clear21 = and i8 %bf.lshr20, 1
  %bf.cast = zext i8 %bf.clear21 to i32
  %tobool22 = icmp ne i32 %bf.cast, 0
  br i1 %tobool22, label %cleanup.cont, label %if.end24

if.end24:                                         ; preds = %resubmit
  %urb25 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 3
  %9 = load %struct.urb*, %struct.urb** %urb25, align 8, !tbaa !293
  %call = call i32 bitcast (i32 (%struct.urb.744*, i32)* @usb_submit_urb to i32 (%struct.urb*, i32)*)(%struct.urb* %9, i32 17301536)
  switch i32 %call, label %if.then33 [
    i32 0, label %cleanup.cont
    i32 -19, label %cleanup.cont
    i32 -1, label %cleanup.cont
  ]

if.then33:                                        ; preds = %if.end24
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then33, %if.end24, %if.end24, %if.end24, %resubmit, %LeafBlock, %LeafBlock1, %LeafBlock3
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_fill_int_urb(%struct.urb* %urb, %struct.usb_device* %dev, i32 %pipe, i8* %transfer_buffer, i32 %buffer_length, void (%struct.urb*)* %complete_fn, i8* %context, i32 %interval) #1 {
entry:
  %__UNIQUE_ID_min1_10 = alloca i32, align 4
  %__UNIQUE_ID_max1_8 = alloca i32, align 4
  %__UNIQUE_ID_max2_9 = alloca i32, align 4
  %__UNIQUE_ID_min2_11 = alloca i32, align 4
  %dev1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  store %struct.usb_device* %dev, %struct.usb_device** %dev1, align 8, !tbaa !242
  %pipe2 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 10
  store i32 %pipe, i32* %pipe2, align 8, !tbaa !244
  %transfer_buffer3 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  store i8* %transfer_buffer, i8** %transfer_buffer3, align 8, !tbaa !316
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  store i32 %buffer_length, i32* %transfer_buffer_length, align 8, !tbaa !317
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 28
  store void (%struct.urb*)* %complete_fn, void (%struct.urb*)** %complete, align 8, !tbaa !318
  %context4 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  store i8* %context, i8** %context4, align 8, !tbaa !313
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp eq i32 %0, 3
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %speed5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 4
  %1 = load i32, i32* %speed5, align 4, !tbaa !177
  %cmp6 = icmp uge i32 %1, 5
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 %interval, i32* %__UNIQUE_ID_max1_8, align 4, !tbaa !73
  store i32 1, i32* %__UNIQUE_ID_max2_9, align 4, !tbaa !73
  %2 = load i32, i32* %__UNIQUE_ID_max1_8, align 4, !tbaa !73
  %3 = load i32, i32* %__UNIQUE_ID_max2_9, align 4, !tbaa !73
  %cmp8 = icmp sgt i32 %2, %3
  %4 = load i32, i32* %__UNIQUE_ID_max1_8, align 4
  %5 = load i32, i32* %__UNIQUE_ID_max2_9, align 4
  %cond = select i1 %cmp8, i32 %4, i32 %5
  store i32 %cond, i32* %__UNIQUE_ID_min1_10, align 4, !tbaa !73
  store i32 16, i32* %__UNIQUE_ID_min2_11, align 4, !tbaa !73
  %6 = load i32, i32* %__UNIQUE_ID_min1_10, align 4, !tbaa !73
  %7 = load i32, i32* %__UNIQUE_ID_min2_11, align 4, !tbaa !73
  %cmp13 = icmp slt i32 %6, %7
  %8 = load i32, i32* %__UNIQUE_ID_min1_10, align 4
  %9 = load i32, i32* %__UNIQUE_ID_min2_11, align 4
  %cond18 = select i1 %cmp13, i32 %8, i32 %9
  %sub = sub nsw i32 %cond18, 1
  %shl = shl i32 1, %sub
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %interval.sink = phi i32 [ %shl, %if.then ], [ %interval, %lor.lhs.false ]
  %interval20 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 25
  store i32 %interval.sink, i32* %interval20, align 8, !tbaa !319
  %start_frame = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 23
  store i32 -1, i32* %start_frame, align 8, !tbaa !320
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_hub_adjust_deviceremovable(%struct.usb_device* %hdev, %struct.usb_hub_descriptor* %desc) #0 {
entry:
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  %tobool = icmp ne %struct.usb_hub* %call, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %call1 = call i32 @hub_is_superspeed(%struct.usb_device* %hdev)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.else, label %if.then3

if.then3:                                         ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then3
  %i.0 = phi i32 [ 1, %if.then3 ], [ %inc, %for.inc ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 28
  %0 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp = icmp sle i32 %i.0, %0
  br i1 %cmp, label %for.body, label %cleanup.cont

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %1 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %i.0, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %1, i64 %idxprom
  %2 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %connect_type4 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %2, i32 0, i32 5
  %3 = load i32, i32* %connect_type4, align 8, !tbaa !230
  %cmp5 = icmp eq i32 %3, 2
  br i1 %cmp5, label %if.then6, label %for.inc

if.then6:                                         ; preds = %for.body
  %rem = srem i32 %i.0, 8
  %shl = shl i32 1, %rem
  %conv = trunc i32 %shl to i8
  %u = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %desc, i32 0, i32 6
  %hs = bitcast %union.anon.63* %u to %struct.anon.64*
  %DeviceRemovable = getelementptr inbounds %struct.anon.64, %struct.anon.64* %hs, i32 0, i32 0
  %div = sdiv i32 %i.0, 8
  %idxprom7 = sext i32 %div to i64
  %arrayidx8 = getelementptr inbounds [4 x i8], [4 x i8]* %DeviceRemovable, i64 0, i64 %idxprom7
  %4 = load i8, i8* %arrayidx8, align 1, !tbaa !72
  %conv9 = zext i8 %4 to i32
  %conv10 = zext i8 %conv to i32
  %and = and i32 %conv9, %conv10
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %for.inc, label %do.body13

do.body13:                                        ; preds = %if.then6
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hub_adjust_deviceremovable.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and14 = and i32 %bf.clear, 1
  %tobool15 = icmp ne i32 %and14, 0
  %lnot = xor i1 %tobool15, true
  %lnot16 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot16 to i32
  %conv17 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv17, i64 0)
  %tobool18 = icmp ne i64 %expval, 0
  br i1 %tobool18, label %if.then19, label %do.end22

if.then19:                                        ; preds = %do.body13
  %dev = getelementptr inbounds %struct.usb_port, %struct.usb_port* %2, i32 0, i32 1
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hub_adjust_deviceremovable.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.45, i32 0, i32 0))
  br label %do.end22

do.end22:                                         ; preds = %if.then19, %do.body13
  %conv23 = zext i8 %conv to i32
  %u24 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %desc, i32 0, i32 6
  %hs25 = bitcast %union.anon.63* %u24 to %struct.anon.64*
  %DeviceRemovable26 = getelementptr inbounds %struct.anon.64, %struct.anon.64* %hs25, i32 0, i32 0
  %div27 = sdiv i32 %i.0, 8
  %idxprom28 = sext i32 %div27 to i64
  %arrayidx29 = getelementptr inbounds [4 x i8], [4 x i8]* %DeviceRemovable26, i64 0, i64 %idxprom28
  %5 = load i8, i8* %arrayidx29, align 1, !tbaa !72
  %conv30 = zext i8 %5 to i32
  %or = or i32 %conv30, %conv23
  %conv31 = trunc i32 %or to i8
  store i8 %conv31, i8* %arrayidx29, align 1, !tbaa !72
  br label %for.inc

for.inc:                                          ; preds = %do.end22, %if.then6, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.else:                                          ; preds = %if.end
  %u34 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %desc, i32 0, i32 6
  %ss = bitcast %union.anon.63* %u34 to %struct.anon.65*
  %DeviceRemovable35 = getelementptr inbounds %struct.anon.65, %struct.anon.65* %ss, i32 0, i32 2
  %6 = load i16, i16* %DeviceRemovable35, align 1, !tbaa !72
  br label %for.cond36

for.cond36:                                       ; preds = %for.inc85, %if.else
  %i.1 = phi i32 [ 1, %if.else ], [ %inc86, %for.inc85 ]
  %port_removable.0 = phi i16 [ %6, %if.else ], [ %port_removable.2, %for.inc85 ]
  %maxchild37 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 28
  %7 = load i32, i32* %maxchild37, align 8, !tbaa !111
  %cmp38 = icmp sle i32 %i.1, %7
  br i1 %cmp38, label %for.body40, label %for.end87

for.body40:                                       ; preds = %for.cond36
  %ports42 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %8 = load %struct.usb_port**, %struct.usb_port*** %ports42, align 8, !tbaa !112
  %sub43 = sub nsw i32 %i.1, 1
  %idxprom44 = sext i32 %sub43 to i64
  %arrayidx45 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %8, i64 %idxprom44
  %9 = load %struct.usb_port*, %struct.usb_port** %arrayidx45, align 8, !tbaa !52
  %connect_type46 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %9, i32 0, i32 5
  %10 = load i32, i32* %connect_type46, align 8, !tbaa !230
  %cmp47 = icmp eq i32 %10, 2
  br i1 %cmp47, label %if.then49, label %for.inc85

if.then49:                                        ; preds = %for.body40
  %shl51 = shl i32 1, %i.1
  %conv52 = trunc i32 %shl51 to i16
  %conv53 = zext i16 %port_removable.0 to i32
  %conv54 = zext i16 %conv52 to i32
  %and55 = and i32 %conv53, %conv54
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %for.inc85, label %do.body59

do.body59:                                        ; preds = %if.then49
  %bf.load60 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hub_adjust_deviceremovable.descriptor.46 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr61 = lshr i32 %bf.load60, 18
  %bf.clear62 = and i32 %bf.lshr61, 255
  %and63 = and i32 %bf.clear62, 1
  %tobool64 = icmp ne i32 %and63, 0
  %lnot65 = xor i1 %tobool64, true
  %lnot67 = xor i1 %lnot65, true
  %lnot.ext68 = zext i1 %lnot67 to i32
  %conv69 = sext i32 %lnot.ext68 to i64
  %expval70 = call i64 @llvm.expect.i64(i64 %conv69, i64 0)
  %tobool71 = icmp ne i64 %expval70, 0
  br i1 %tobool71, label %if.then72, label %do.end78

if.then72:                                        ; preds = %do.body59
  %dev73 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %9, i32 0, i32 1
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hub_adjust_deviceremovable.descriptor.46 to %struct._ddebug*), %struct.device* %dev73, i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.45, i32 0, i32 0))
  br label %do.end78

do.end78:                                         ; preds = %if.then72, %do.body59
  %conv79 = zext i16 %conv52 to i32
  %conv80 = zext i16 %port_removable.0 to i32
  %or81 = or i32 %conv80, %conv79
  %conv82 = trunc i32 %or81 to i16
  br label %for.inc85

for.inc85:                                        ; preds = %do.end78, %if.then49, %for.body40
  %port_removable.2 = phi i16 [ %port_removable.0, %for.body40 ], [ %port_removable.0, %if.then49 ], [ %conv82, %do.end78 ]
  %inc86 = add nsw i32 %i.1, 1
  br label %for.cond36

for.end87:                                        ; preds = %for.cond36
  %u88 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %desc, i32 0, i32 6
  %ss89 = bitcast %union.anon.63* %u88 to %struct.anon.65*
  %DeviceRemovable90 = getelementptr inbounds %struct.anon.65, %struct.anon.65* %ss89, i32 0, i32 2
  store i16 %port_removable.0, i16* %DeviceRemovable90, align 1, !tbaa !72
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end87, %for.cond, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @get_hub_status(%struct.usb_device* %hdev, %struct.usb_hub_status* %data) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %status.0 = phi i32 [ -110, %entry ], [ %call4, %for.body ]
  %cmp = icmp slt i32 %i.0, 5
  br i1 %cmp, label %land.rhs, label %for.end

land.rhs:                                         ; preds = %for.cond
  %cmp1 = icmp eq i32 %status.0, -110
  %cmp2 = icmp eq i32 %status.0, -32
  %.cmp2 = select i1 %cmp1, i1 true, i1 %cmp2
  br i1 %.cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %land.rhs
  %call = call i32 @__create_pipe(%struct.usb_device* %hdev, i32 0)
  %or = or i32 -2147483648, %call
  %or3 = or i32 %or, 128
  %0 = bitcast %struct.usb_hub_status* %data to i8*
  %call4 = call i32 @usb_control_msg(%struct.usb_device* %hdev, i32 %or3, i8 zeroext 0, i8 zeroext -96, i16 zeroext 0, i16 zeroext 0, i8* %0, i16 zeroext 4, i32 1000)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %land.rhs, %for.cond
  ret i32 %status.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty(%struct.list_head* %head) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %0 to i64*
  %2 = load volatile i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %arraydecay to i64*
  store i64 %2, i64* %3, align 8, !tbaa !86
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  %4 = load %struct.list_head*, %struct.list_head** %__val, align 8, !tbaa !72
  %cmp = icmp eq %struct.list_head* %4, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del(%struct.list_head* %entry1) #1 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8, !tbaa !252
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8, !tbaa !87
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hub_clear_tt_buffer(%struct.usb_device* %hdev, i16 zeroext %devinfo, i16 zeroext %tt) #1 {
entry:
  %conv = zext i16 %devinfo to i32
  %shr = ashr i32 %conv, 11
  %and = and i32 %shr, 3
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %call = call i32 @__create_pipe(%struct.usb_device* %hdev, i32 0)
  %or = or i32 -2147483648, %call
  %conv2 = zext i16 %devinfo to i32
  %xor = xor i32 %conv2, 32768
  %conv3 = trunc i32 %xor to i16
  %call4 = call i32 @usb_control_msg(%struct.usb_device* %hdev, i32 %or, i8 zeroext 8, i8 zeroext 35, i16 zeroext %conv3, i16 zeroext %tt, i8* null, i16 zeroext 0, i32 1000)
  %tobool = icmp ne i32 %call4, 0
  %. = select i1 %tobool, i32 1, i32 0
  %SwitchLeaf = icmp eq i32 %., 1
  br i1 %SwitchLeaf, label %return, label %if.end6

if.end6:                                          ; preds = %if.then, %entry
  %call7 = call i32 @__create_pipe(%struct.usb_device* %hdev, i32 0)
  %or8 = or i32 -2147483648, %call7
  %call9 = call i32 @usb_control_msg(%struct.usb_device* %hdev, i32 %or8, i8 zeroext 8, i8 zeroext 35, i16 zeroext %devinfo, i16 zeroext %tt, i8* null, i16 zeroext 0, i32 1000)
  br label %return

return:                                           ; preds = %if.end6, %if.then
  %retval.1 = phi i32 [ %call4, %if.then ], [ %call9, %if.end6 ]
  ret i32 %retval.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry(%struct.list_head* %entry1) #1 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !87
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !252
  call void @__list_del(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare zeroext i1 @__list_del_entry_valid(%struct.list_head*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del(%struct.list_head* %prev, %struct.list_head* %next) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !87
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !72
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @port_event(%struct.usb_hub* %hub, i32 %port1) #0 {
entry:
  %oldbit.i = alloca i8, align 1
  %portstatus = alloca i16, align 2
  %portchange = alloca i16, align 2
  %status = alloca i16, align 2
  %unused = alloca i16, align 2
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %0 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %0, i64 %idxprom
  %1 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 0
  %2 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !115
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !176
  %conv = sext i32 %port1 to i64
  %change_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 10
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits, i32 0, i32 0
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %arraydecay, i64 %conv) #8, !srcloc !235
  %4 = load i8, i8* %oldbit.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %4 to i1
  %conv2 = zext i1 %tobool.i to i32
  %conv3 = sext i32 %port1 to i64
  %event_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 9
  %arraydecay4 = getelementptr inbounds [1 x i64], [1 x i64]* %event_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay4, i64 %conv3, i64* %arraydecay4) #8, !srcloc !222
  %conv5 = sext i32 %port1 to i64
  %wakeup_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 12
  %arraydecay6 = getelementptr inbounds [1 x i64], [1 x i64]* %wakeup_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay6, i64 %conv5, i64* %arraydecay6) #8, !srcloc !222
  %call7 = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1, i16* %portstatus, i16* %portchange)
  %cmp = icmp slt i32 %call7, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %5 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv9 = zext i16 %5 to i32
  %and = and i32 %conv9, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end
  %call11 = call i32 @usb_clear_port_feature(%struct.usb_device* %3, i32 %port1, i32 16)
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end
  %connect_change.0 = phi i32 [ 1, %if.then10 ], [ %conv2, %if.end ]
  %6 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv13 = zext i16 %6 to i32
  %and14 = and i32 %conv13, 2
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.then16, label %if.end41

if.then16:                                        ; preds = %if.end12
  %tobool17 = icmp ne i32 %connect_change.0, 0
  br i1 %tobool17, label %if.end30, label %do.body19

do.body19:                                        ; preds = %if.then16
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @port_event.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and20 = and i32 %bf.clear, 1
  %tobool21 = icmp ne i32 %and20, 0
  %lnot = xor i1 %tobool21, true
  %lnot22 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot22 to i32
  %conv23 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool24 = icmp ne i64 %expval, 0
  br i1 %tobool24, label %if.then25, label %if.end30

if.then25:                                        ; preds = %do.body19
  %dev = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  %7 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv26 = zext i16 %7 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @port_event.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.129, i32 0, i32 0), i32 %conv26)
  br label %if.end30

if.end30:                                         ; preds = %if.then25, %do.body19, %if.then16
  %call31 = call i32 @usb_clear_port_feature(%struct.usb_device* %3, i32 %port1, i32 17)
  %8 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv32 = zext i16 %8 to i32
  %and33 = and i32 %conv32, 2
  %tobool34 = icmp ne i32 %and33, 0
  %tobool35 = icmp ne i32 %connect_change.0, 0
  %or.cond = or i1 %tobool34, %tobool35
  %or.cond.not = xor i1 %or.cond, true
  %tobool37 = icmp ne %struct.usb_device* %2, null
  %or.cond1 = and i1 %or.cond.not, %tobool37
  br i1 %or.cond1, label %if.then38, label %if.end41

if.then38:                                        ; preds = %if.end30
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end41

if.end41:                                         ; preds = %if.then38, %if.end30, %if.end12
  %connect_change.2 = phi i32 [ %connect_change.0, %if.end12 ], [ %connect_change.0, %if.end30 ], [ 1, %if.then38 ]
  %9 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv42 = zext i16 %9 to i32
  %and43 = and i32 %conv42, 8
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %if.then45, label %if.end75

if.then45:                                        ; preds = %if.end41
  store i16 0, i16* %status, align 2, !tbaa !165
  %bf.load48 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @port_event.descriptor.131 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr49 = lshr i32 %bf.load48, 18
  %bf.clear50 = and i32 %bf.lshr49, 255
  %and51 = and i32 %bf.clear50, 1
  %tobool52 = icmp ne i32 %and51, 0
  %lnot53 = xor i1 %tobool52, true
  %lnot55 = xor i1 %lnot53, true
  %lnot.ext56 = zext i1 %lnot55 to i32
  %conv57 = sext i32 %lnot.ext56 to i64
  %expval58 = call i64 @llvm.expect.i64(i64 %conv57, i64 0)
  %tobool59 = icmp ne i64 %expval58, 0
  br i1 %tobool59, label %if.then60, label %do.end66

if.then60:                                        ; preds = %if.then45
  %dev61 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @port_event.descriptor.131 to %struct._ddebug*), %struct.device* %dev61, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.127, i32 0, i32 0))
  br label %do.end66

do.end66:                                         ; preds = %if.then60, %if.then45
  %call67 = call i32 @usb_clear_port_feature(%struct.usb_device* %3, i32 %port1, i32 19)
  call void @msleep(i32 100)
  call void @hub_power_on(%struct.usb_hub* %hub, i1 zeroext true)
  %call68 = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1, i16* %status, i16* %unused)
  %10 = load i16, i16* %status, align 2, !tbaa !165
  %conv69 = zext i16 %10 to i32
  %and70 = and i32 %conv69, 8
  %tobool71 = icmp ne i32 %and70, 0
  br i1 %tobool71, label %if.then72, label %if.end74

if.then72:                                        ; preds = %do.end66
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end74

if.end74:                                         ; preds = %if.then72, %do.end66
  br label %if.end75

if.end75:                                         ; preds = %if.end74, %if.end41
  %11 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv76 = zext i16 %11 to i32
  %and77 = and i32 %conv76, 16
  %tobool78 = icmp ne i32 %and77, 0
  br i1 %tobool78, label %do.body81, label %if.end102

do.body81:                                        ; preds = %if.end75
  %bf.load82 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @port_event.descriptor.132 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr83 = lshr i32 %bf.load82, 18
  %bf.clear84 = and i32 %bf.lshr83, 255
  %and85 = and i32 %bf.clear84, 1
  %tobool86 = icmp ne i32 %and85, 0
  %lnot87 = xor i1 %tobool86, true
  %lnot89 = xor i1 %lnot87, true
  %lnot.ext90 = zext i1 %lnot89 to i32
  %conv91 = sext i32 %lnot.ext90 to i64
  %expval92 = call i64 @llvm.expect.i64(i64 %conv91, i64 0)
  %tobool93 = icmp ne i64 %expval92, 0
  br i1 %tobool93, label %if.then94, label %do.end100

if.then94:                                        ; preds = %do.body81
  %dev95 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @port_event.descriptor.132 to %struct._ddebug*), %struct.device* %dev95, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.133, i32 0, i32 0))
  br label %do.end100

do.end100:                                        ; preds = %if.then94, %do.body81
  %call101 = call i32 @usb_clear_port_feature(%struct.usb_device* %3, i32 %port1, i32 20)
  br label %if.end102

if.end102:                                        ; preds = %do.end100, %if.end75
  %12 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv103 = zext i16 %12 to i32
  %and104 = and i32 %conv103, 32
  %tobool105 = icmp ne i32 %and104, 0
  br i1 %tobool105, label %land.lhs.true106, label %if.end132

land.lhs.true106:                                 ; preds = %if.end102
  %call107 = call i32 @hub_is_superspeed(%struct.usb_device* %3)
  %tobool108 = icmp ne i32 %call107, 0
  br i1 %tobool108, label %do.body111, label %if.end132

do.body111:                                       ; preds = %land.lhs.true106
  %bf.load112 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @port_event.descriptor.134 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr113 = lshr i32 %bf.load112, 18
  %bf.clear114 = and i32 %bf.lshr113, 255
  %and115 = and i32 %bf.clear114, 1
  %tobool116 = icmp ne i32 %and115, 0
  %lnot117 = xor i1 %tobool116, true
  %lnot119 = xor i1 %lnot117, true
  %lnot.ext120 = zext i1 %lnot119 to i32
  %conv121 = sext i32 %lnot.ext120 to i64
  %expval122 = call i64 @llvm.expect.i64(i64 %conv121, i64 0)
  %tobool123 = icmp ne i64 %expval122, 0
  br i1 %tobool123, label %if.then124, label %do.end130

if.then124:                                       ; preds = %do.body111
  %dev125 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @port_event.descriptor.134 to %struct._ddebug*), %struct.device* %dev125, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.135, i32 0, i32 0))
  br label %do.end130

do.end130:                                        ; preds = %if.then124, %do.body111
  %call131 = call i32 @usb_clear_port_feature(%struct.usb_device* %3, i32 %port1, i32 29)
  br label %if.end132

if.end132:                                        ; preds = %do.end130, %land.lhs.true106, %if.end102
  %13 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv133 = zext i16 %13 to i32
  %and134 = and i32 %conv133, 64
  %tobool135 = icmp ne i32 %and134, 0
  br i1 %tobool135, label %do.body138, label %if.end159

do.body138:                                       ; preds = %if.end132
  %bf.load139 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @port_event.descriptor.136 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr140 = lshr i32 %bf.load139, 18
  %bf.clear141 = and i32 %bf.lshr140, 255
  %and142 = and i32 %bf.clear141, 1
  %tobool143 = icmp ne i32 %and142, 0
  %lnot144 = xor i1 %tobool143, true
  %lnot146 = xor i1 %lnot144, true
  %lnot.ext147 = zext i1 %lnot146 to i32
  %conv148 = sext i32 %lnot.ext147 to i64
  %expval149 = call i64 @llvm.expect.i64(i64 %conv148, i64 0)
  %tobool150 = icmp ne i64 %expval149, 0
  br i1 %tobool150, label %if.then151, label %do.end157

if.then151:                                       ; preds = %do.body138
  %dev152 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @port_event.descriptor.136 to %struct._ddebug*), %struct.device* %dev152, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.137, i32 0, i32 0))
  br label %do.end157

do.end157:                                        ; preds = %if.then151, %do.body138
  %call158 = call i32 @usb_clear_port_feature(%struct.usb_device* %3, i32 %port1, i32 25)
  br label %if.end159

if.end159:                                        ; preds = %do.end157, %if.end132
  %14 = load i16, i16* %portchange, align 2, !tbaa !165
  %conv160 = zext i16 %14 to i32
  %and161 = and i32 %conv160, 128
  %tobool162 = icmp ne i32 %and161, 0
  br i1 %tobool162, label %if.then163, label %if.end166

if.then163:                                       ; preds = %if.end159
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %call165 = call i32 @usb_clear_port_feature(%struct.usb_device* %3, i32 %port1, i32 26)
  br label %if.end166

if.end166:                                        ; preds = %if.then163, %if.end159
  %dev167 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  %call168 = call zeroext i1 @pm_runtime_active(%struct.device* %dev167)
  br i1 %call168, label %if.end170, label %cleanup

if.end170:                                        ; preds = %if.end166
  %15 = load i16, i16* %portstatus, align 2, !tbaa !165
  %16 = load i16, i16* %portchange, align 2, !tbaa !165
  %call171 = call i32 @hub_handle_remote_wakeup(%struct.usb_hub* %hub, i32 %port1, i16 zeroext %15, i16 zeroext %16)
  %tobool172 = icmp ne i32 %call171, 0
  %.connect_change.2 = select i1 %tobool172, i32 1, i32 %connect_change.2
  %17 = load i16, i16* %portstatus, align 2, !tbaa !165
  %call175 = call zeroext i1 @hub_port_warm_reset_required(%struct.usb_hub* %hub, i32 %port1, i16 zeroext %17)
  br i1 %call175, label %do.body178, label %if.end216

do.body178:                                       ; preds = %if.end170
  %bf.load179 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @port_event.descriptor.139 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr180 = lshr i32 %bf.load179, 18
  %bf.clear181 = and i32 %bf.lshr180, 255
  %and182 = and i32 %bf.clear181, 1
  %tobool183 = icmp ne i32 %and182, 0
  %lnot184 = xor i1 %tobool183, true
  %lnot186 = xor i1 %lnot184, true
  %lnot.ext187 = zext i1 %lnot186 to i32
  %conv188 = sext i32 %lnot.ext187 to i64
  %expval189 = call i64 @llvm.expect.i64(i64 %conv188, i64 0)
  %tobool190 = icmp ne i64 %expval189, 0
  br i1 %tobool190, label %if.then191, label %do.end197

if.then191:                                       ; preds = %do.body178
  %dev192 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @port_event.descriptor.139 to %struct._ddebug*), %struct.device* %dev192, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.140, i32 0, i32 0))
  br label %do.end197

do.end197:                                        ; preds = %if.then191, %do.body178
  %tobool198 = icmp ne %struct.usb_device* %2, null
  br i1 %tobool198, label %lor.lhs.false, label %if.then205

lor.lhs.false:                                    ; preds = %do.end197
  %18 = load i16, i16* %portstatus, align 2, !tbaa !165
  %conv199 = zext i16 %18 to i32
  %and200 = and i32 %conv199, 1
  %tobool201 = icmp ne i32 %and200, 0
  br i1 %tobool201, label %lor.lhs.false202, label %if.then205

lor.lhs.false202:                                 ; preds = %lor.lhs.false
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 3
  %19 = load i32, i32* %state, align 8, !tbaa !54
  %cmp203 = icmp eq i32 %19, 0
  br i1 %cmp203, label %if.then205, label %if.else

if.then205:                                       ; preds = %lor.lhs.false202, %lor.lhs.false, %do.end197
  %call206 = call i32 @hub_port_reset(%struct.usb_hub* %hub, i32 %port1, %struct.usb_device* null, i32 50, i1 zeroext true)
  %cmp207 = icmp slt i32 %call206, 0
  br i1 %cmp207, label %if.then209, label %if.end216

if.then209:                                       ; preds = %if.then205
  call void @hub_port_disable(%struct.usb_hub* %hub, i32 %port1, i32 1)
  br label %if.end216

if.else:                                          ; preds = %lor.lhs.false202
  call void @usb_unlock_port(%struct.usb_port* %1)
  %dev212 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock(%struct.device* %dev212)
  %call213 = call i32 @usb_reset_device(%struct.usb_device* %2)
  %dev214 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev214)
  call void @usb_lock_port(%struct.usb_port* %1)
  br label %if.end216

if.end216:                                        ; preds = %if.else, %if.then209, %if.then205, %if.end170
  %connect_change.5 = phi i32 [ %.connect_change.2, %if.end170 ], [ 0, %if.else ], [ %.connect_change.2, %if.then209 ], [ %.connect_change.2, %if.then205 ]
  %tobool217 = icmp ne i32 %connect_change.5, 0
  br i1 %tobool217, label %if.then218, label %cleanup

if.then218:                                       ; preds = %if.end216
  %20 = load i16, i16* %portstatus, align 2, !tbaa !165
  %21 = load i16, i16* %portchange, align 2, !tbaa !165
  call void @hub_port_connect_change(%struct.usb_hub* %hub, i32 %port1, i16 zeroext %20, i16 zeroext %21)
  br label %cleanup

cleanup:                                          ; preds = %if.then218, %if.end216, %if.end166, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @clear_hub_feature(%struct.usb_device* %hdev, i32 %feature) #0 {
entry:
  %call = call i32 @__create_pipe(%struct.usb_device* %hdev, i32 0)
  %or = or i32 -2147483648, %call
  %conv = trunc i32 %feature to i16
  %call1 = call i32 @usb_control_msg(%struct.usb_device* %hdev, i32 %or, i8 zeroext 1, i8 zeroext 32, i16 zeroext %conv, i16 zeroext 0, i8* null, i16 zeroext 0, i32 1000)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @pm_runtime_active(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %runtime_status = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 17
  %0 = load i32, i32* %runtime_status, align 4, !tbaa !321
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %power1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %disable_depth = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power1, i32 0, i32 14
  %bf.load = load i16, i16* %disable_depth, align 8
  %bf.clear = and i16 %bf.load, 7
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %1 = phi i1 [ true, %entry ], [ %tobool, %lor.rhs ]
  ret i1 %1
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_handle_remote_wakeup(%struct.usb_hub* %hub, i32 %port, i16 zeroext %portstatus, i16 zeroext %portchange) #0 {
entry:
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %0 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub i32 %port, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %0, i64 %idxprom
  %1 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !176
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 0
  %3 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !115
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %conv = zext i16 %portchange to i32
  %and = and i32 %conv, 4
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.end, label %cleanup

if.end:                                           ; preds = %if.then
  %call4 = call i32 @usb_clear_port_feature(%struct.usb_device* %2, i32 %port, i32 18)
  br label %if.end14

if.else:                                          ; preds = %entry
  %tobool5 = icmp ne %struct.usb_device* %3, null
  br i1 %tobool5, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.else
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 3
  %4 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp ne i32 %4, 8
  br i1 %cmp, label %cleanup, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %lor.lhs.false
  %conv8 = zext i16 %portstatus to i32
  %and9 = and i32 %conv8, 480
  %cmp10 = icmp ne i32 %and9, 0
  br i1 %cmp10, label %cleanup, label %if.end14

if.end14:                                         ; preds = %lor.lhs.false7, %if.end
  %tobool15 = icmp ne %struct.usb_device* %3, null
  br i1 %tobool15, label %if.then16, label %if.else22

if.then16:                                        ; preds = %if.end14
  call void @msleep(i32 10)
  call void @usb_unlock_port(%struct.usb_port* %1)
  %call17 = call i32 @usb_remote_wakeup(%struct.usb_device* %3)
  call void @usb_lock_port(%struct.usb_port* %1)
  %cmp18 = icmp slt i32 %call17, 0
  %. = select i1 %cmp18, i32 1, i32 0
  br label %do.body25

if.else22:                                        ; preds = %if.end14
  call void @hub_port_disable(%struct.usb_hub* %hub, i32 %port, i32 1)
  br label %do.body25

do.body25:                                        ; preds = %if.else22, %if.then16
  %connect_change.1 = phi i32 [ %., %if.then16 ], [ 0, %if.else22 ]
  %ret.0 = phi i32 [ %call17, %if.then16 ], [ -19, %if.else22 ]
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_handle_remote_wakeup.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and26 = and i32 %bf.clear, 1
  %tobool27 = icmp ne i32 %and26, 0
  %lnot = xor i1 %tobool27, true
  %lnot28 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot28 to i32
  %conv29 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv29, i64 0)
  %tobool30 = icmp ne i64 %expval, 0
  br i1 %tobool30, label %if.then31, label %cleanup

if.then31:                                        ; preds = %do.body25
  %dev = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_handle_remote_wakeup.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.141, i32 0, i32 0), i32 %ret.0)
  br label %cleanup

cleanup:                                          ; preds = %if.then31, %do.body25, %lor.lhs.false7, %lor.lhs.false, %if.else, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ 0, %lor.lhs.false7 ], [ 0, %lor.lhs.false ], [ 0, %if.else ], [ %connect_change.1, %if.then31 ], [ %connect_change.1, %do.body25 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @hub_port_connect_change(%struct.usb_hub* %hub, i32 %port1, i16 zeroext %portstatus, i16 zeroext %portchange) #0 {
entry:
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %0 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %0, i64 %idxprom
  %1 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 0
  %2 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !115
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_connect_change.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end8

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  %conv4 = zext i16 %portstatus to i32
  %conv5 = zext i16 %portchange to i32
  %conv6 = zext i16 %portstatus to i32
  %call = call i8* @portspeed(%struct.usb_hub* %hub, i32 %conv6)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_connect_change.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.152, i32 0, i32 0), i32 %conv4, i32 %conv5, i8* %call)
  br label %do.end8

do.end8:                                          ; preds = %if.then, %entry
  %has_indicators = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  %bf.load9 = load i8, i8* %has_indicators, align 8
  %bf.lshr10 = lshr i8 %bf.load9, 5
  %bf.clear11 = and i8 %bf.lshr10, 1
  %bf.cast = zext i8 %bf.clear11 to i32
  %tobool12 = icmp ne i32 %bf.cast, 0
  br i1 %tobool12, label %if.then13, label %if.end17

if.then13:                                        ; preds = %do.end8
  call void @set_port_led(%struct.usb_hub* %hub, i32 %port1, i32 0)
  %indicator = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 21
  %sub14 = sub nsw i32 %port1, 1
  %idxprom15 = sext i32 %sub14 to i64
  %arrayidx16 = getelementptr inbounds [31 x i8], [31 x i8]* %indicator, i64 0, i64 %idxprom15
  store i8 0, i8* %arrayidx16, align 1, !tbaa !72
  br label %if.end17

if.end17:                                         ; preds = %if.then13, %do.end8
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 9
  %4 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %is_b_host = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %4, i32 0, i32 6
  %bf.load18 = load i8, i8* %is_b_host, align 1
  %bf.clear19 = and i8 %bf.load18, 1
  %bf.cast20 = zext i8 %bf.clear19 to i32
  %tobool21 = icmp ne i32 %bf.cast20, 0
  %conv23 = zext i16 %portchange to i32
  %and24 = and i32 %conv23, -4
  %conv25 = trunc i32 %and24 to i16
  %portchange.addr.0 = select i1 %tobool21, i16 %conv25, i16 %portchange
  %conv27 = zext i16 %portstatus to i32
  %and28 = and i32 %conv27, 1
  %tobool29 = icmp ne i32 %and28, 0
  %tobool30 = icmp ne %struct.usb_device* %2, null
  %or.cond = and i1 %tobool29, %tobool30
  br i1 %or.cond, label %land.lhs.true31, label %if.end52

land.lhs.true31:                                  ; preds = %if.end17
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 3
  %5 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp ne i32 %5, 0
  br i1 %cmp, label %if.then33, label %if.end52

if.then33:                                        ; preds = %land.lhs.true31
  %conv34 = zext i16 %portstatus to i32
  %and35 = and i32 %conv34, 2
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %if.end52, label %if.else

if.else:                                          ; preds = %if.then33
  %state38 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 3
  %6 = load i32, i32* %state38, align 8, !tbaa !54
  %cmp39 = icmp eq i32 %6, 8
  br i1 %cmp39, label %land.lhs.true41, label %if.end52

land.lhs.true41:                                  ; preds = %if.else
  %persist_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 22
  %bf.load42 = load i16, i16* %persist_enabled, align 4
  %bf.lshr43 = lshr i16 %bf.load42, 1
  %bf.clear44 = and i16 %bf.lshr43, 1
  %bf.cast45 = zext i16 %bf.clear44 to i32
  %tobool46 = icmp ne i32 %bf.cast45, 0
  br i1 %tobool46, label %if.then47, label %if.end52

if.then47:                                        ; preds = %land.lhs.true41
  call void @usb_unlock_port(%struct.usb_port* %1)
  %call48 = call i32 @usb_remote_wakeup(%struct.usb_device* %2)
  call void @usb_lock_port(%struct.usb_port* %1)
  br label %if.end52

if.end52:                                         ; preds = %if.then47, %land.lhs.true41, %if.else, %if.then33, %land.lhs.true31, %if.end17
  %status.2 = phi i32 [ -19, %land.lhs.true31 ], [ -19, %if.end17 ], [ 0, %if.then33 ], [ %call48, %if.then47 ], [ -19, %land.lhs.true41 ], [ -19, %if.else ]
  %conv53 = sext i32 %port1 to i64
  %change_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 10
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i64 %conv53, i64* %arraydecay) #8, !srcloc !222
  %cmp54 = icmp eq i32 %status.2, 0
  br i1 %cmp54, label %cleanup.cont, label %if.end57

if.end57:                                         ; preds = %if.end52
  call void @usb_unlock_port(%struct.usb_port* %1)
  call void @hub_port_connect(%struct.usb_hub* %hub, i32 %port1, i16 zeroext %portstatus, i16 zeroext %portchange.addr.0)
  call void @usb_lock_port(%struct.usb_port* %1)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end57, %if.end52
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @portspeed(%struct.usb_hub* %hub, i32 %portstatus) #1 {
entry:
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %call = call i32 @hub_is_superspeedplus(%struct.usb_device* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !176
  %call2 = call i32 @hub_is_superspeed(%struct.usb_device* %1)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %return, label %if.end5

if.end5:                                          ; preds = %if.end
  %and = and i32 %portstatus, 1024
  %tobool6 = icmp ne i32 %and, 0
  br i1 %tobool6, label %return, label %if.else

if.else:                                          ; preds = %if.end5
  %and8 = and i32 %portstatus, 512
  %tobool9 = icmp ne i32 %and8, 0
  %. = select i1 %tobool9, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.156, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.157, i32 0, i32 0)
  br label %return

return:                                           ; preds = %if.else, %if.end5, %if.end, %entry
  %retval.0 = phi i8* [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.153, i32 0, i32 0), %entry ], [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.154, i32 0, i32 0), %if.end ], [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.155, i32 0, i32 0), %if.end5 ], [ %., %if.else ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @set_port_led(%struct.usb_hub* %hub, i32 %port1, i32 %selector) #0 {
entry:
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %0 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %0, i64 %idxprom
  %1 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !176
  %shl = shl i32 %selector, 8
  %or = or i32 %shl, %port1
  %call = call i32 @set_port_feature(%struct.usb_device* %2, i32 %or, i32 22)
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @set_port_led.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end6

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  %call4 = call i8* @to_led_name(i32 %selector)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @set_port_led.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.110, i32 0, i32 0), i8* %call4, i32 %call)
  br label %do.end6

do.end6:                                          ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_port_connect(%struct.usb_hub* %hub, i32 %port1, i16 zeroext %portstatus, i16 zeroext %portchange) #0 {
entry:
  %oldbit.i = alloca i8, align 1
  %devstat = alloca i16, align 2
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !176
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.19(%struct.usb_bus* %1)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %2 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %2, i64 %idxprom
  %3 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 0
  %4 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !115
  %tobool = icmp ne %struct.usb_device* %4, null
  br i1 %tobool, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  %usb_phy = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 9
  %5 = load %struct.usb_phy*, %struct.usb_phy** %usb_phy, align 8, !tbaa !322
  %tobool2 = icmp ne %struct.usb_phy* %5, null
  br i1 %tobool2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  %6 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool3 = icmp ne %struct.usb_device* %6, null
  br i1 %tobool3, label %if.end, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %usb_phy5 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 9
  %7 = load %struct.usb_phy*, %struct.usb_phy** %usb_phy5, align 8, !tbaa !322
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 4
  %8 = load i32, i32* %speed, align 4, !tbaa !177
  call void @usb_phy_notify_disconnect(%struct.usb_phy* %7, i32 %8)
  br label %if.end

if.end:                                           ; preds = %if.then4, %land.lhs.true, %if.then
  %child7 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 0
  call void @usb_disconnect(%struct.usb_device** %child7)
  br label %if.end8

if.end8:                                          ; preds = %if.end, %entry
  %conv = zext i16 %portstatus to i32
  %and = and i32 %conv, 1
  %tobool9 = icmp ne i32 %and, 0
  br i1 %tobool9, label %lor.lhs.false, label %if.then13

lor.lhs.false:                                    ; preds = %if.end8
  %conv10 = zext i16 %portchange to i32
  %and11 = and i32 %conv10, 1
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %lor.lhs.false, %if.end8
  %conv14 = sext i32 %port1 to i64
  %removed_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 11
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %removed_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i64 %conv14, i64* %arraydecay) #8, !srcloc !222
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %lor.lhs.false
  %conv16 = zext i16 %portchange to i32
  %and17 = and i32 %conv16, 3
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then19, label %if.end38

if.then19:                                        ; preds = %if.end15
  %call20 = call i32 @hub_port_debounce_be_stable(%struct.usb_hub* %hub, i32 %port1)
  %cmp = icmp slt i32 %call20, 0
  br i1 %cmp, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.then19
  %cmp23 = icmp ne i32 %call20, -19
  %9 = load i32, i32* @hub_port_connect.unreliable_port, align 4
  %cmp26 = icmp ne i32 %port1, %9
  %or.cond = and i1 %cmp23, %cmp26
  br i1 %or.cond, label %land.lhs.true28, label %if.end32

land.lhs.true28:                                  ; preds = %if.then22
  %call29 = call i32 @__printk_ratelimit(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.hub_port_connect, i32 0, i32 0))
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %land.lhs.true28
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end32

if.end32:                                         ; preds = %if.then31, %land.lhs.true28, %if.then22
  %conv33 = zext i16 %portstatus to i32
  %and34 = and i32 %conv33, -2
  %conv35 = trunc i32 %and34 to i16
  store i32 %port1, i32* @hub_port_connect.unreliable_port, align 4, !tbaa !73
  br label %if.end38

if.else:                                          ; preds = %if.then19
  %conv36 = trunc i32 %call20 to i16
  br label %if.end38

if.end38:                                         ; preds = %if.else, %if.end32, %if.end15
  %portstatus.addr.1 = phi i16 [ %portstatus, %if.end15 ], [ %conv35, %if.end32 ], [ %conv36, %if.else ]
  %conv39 = zext i16 %portstatus.addr.1 to i32
  %and40 = and i32 %conv39, 1
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %cond.false, label %if.then53

cond.false:                                       ; preds = %if.end38
  %conv48 = sext i32 %port1 to i64
  %removed_bits49 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 11
  %arraydecay50 = getelementptr inbounds [1 x i64], [1 x i64]* %removed_bits49, i32 0, i32 0
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %arraydecay50, i64 %conv48) #8, !srcloc !235
  %10 = load i8, i8* %oldbit.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %10 to i1
  br i1 %tobool.i, label %if.then53, label %if.end70

if.then53:                                        ; preds = %cond.false, %if.end38
  %call54 = call zeroext i1 @hub_is_port_power_switchable(%struct.usb_hub* %hub)
  br i1 %call54, label %land.lhs.true56, label %if.end64

land.lhs.true56:                                  ; preds = %if.then53
  %conv57 = zext i16 %portstatus.addr.1 to i32
  %call58 = call i32 @port_is_power_on(%struct.usb_hub* %hub, i32 %conv57)
  %tobool59 = icmp ne i32 %call58, 0
  br i1 %tobool59, label %if.end64, label %land.lhs.true60

land.lhs.true60:                                  ; preds = %land.lhs.true56
  %port_owner = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 2
  %11 = load %struct.usb_dev_state*, %struct.usb_dev_state** %port_owner, align 8, !tbaa !253
  %tobool61 = icmp ne %struct.usb_dev_state* %11, null
  br i1 %tobool61, label %if.end64, label %if.then62

if.then62:                                        ; preds = %land.lhs.true60
  %call63 = call i32 @set_port_feature(%struct.usb_device* %0, i32 %port1, i32 8)
  br label %if.end64

if.end64:                                         ; preds = %if.then62, %land.lhs.true60, %land.lhs.true56, %if.then53
  %conv65 = zext i16 %portstatus.addr.1 to i32
  %and66 = and i32 %conv65, 2
  %tobool67 = icmp ne i32 %and66, 0
  br i1 %tobool67, label %done, label %cleanup.cont271

if.end70:                                         ; preds = %cond.false
  %hdev71 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %12 = load %struct.usb_device*, %struct.usb_device** %hdev71, align 8, !tbaa !176
  %call72 = call i32 @hub_is_superspeed(%struct.usb_device* %12)
  %tobool73 = icmp ne i32 %call72, 0
  %. = select i1 %tobool73, i32 150, i32 100
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end70
  %i.0 = phi i32 [ 0, %if.end70 ], [ %inc, %for.inc ]
  %status.0 = phi i32 [ 0, %if.end70 ], [ %status.5, %for.inc ]
  %13 = load i8, i8* @use_both_schemes, align 1, !tbaa !109, !range !110
  %tobool77 = trunc i8 %13 to i1
  %conv78 = zext i1 %tobool77 to i32
  %add = add nsw i32 %conv78, 1
  %mul = mul nsw i32 2, %add
  %cmp79 = icmp slt i32 %i.0, %mul
  br i1 %cmp79, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %bus81 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %14 = load %struct.usb_bus*, %struct.usb_bus** %bus81, align 8, !tbaa !2
  %call82 = call %struct.usb_device* @usb_alloc_dev(%struct.usb_device* %0, %struct.usb_bus* %14, i32 %port1)
  %tobool83 = icmp ne %struct.usb_device* %call82, null
  br i1 %tobool83, label %if.end86, label %if.then84

if.then84:                                        ; preds = %for.body
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %done

if.end86:                                         ; preds = %for.body
  call void @usb_set_device_state(%struct.usb_device* %call82, i32 2)
  %mA_per_port = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %15 = load i32, i32* %mA_per_port, align 8, !tbaa !307
  %conv87 = trunc i32 %15 to i16
  %bus_mA = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call82, i32 0, i32 19
  store i16 %conv87, i16* %bus_mA, align 8, !tbaa !306
  %level = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 21
  %16 = load i8, i8* %level, align 1, !tbaa !78
  %conv88 = zext i8 %16 to i32
  %add89 = add nsw i32 %conv88, 1
  %conv90 = trunc i32 %add89 to i8
  %level91 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call82, i32 0, i32 21
  store i8 %conv90, i8* %level91, align 1, !tbaa !78
  %call92 = call i32 @hub_is_wusb(%struct.usb_hub* %hub)
  %wusb = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call82, i32 0, i32 22
  %17 = trunc i32 %call92 to i16
  %bf.load = load i16, i16* %wusb, align 4
  %bf.value = and i16 %17, 1
  %bf.shl = shl i16 %bf.value, 5
  %bf.clear = and i16 %bf.load, -33
  %bf.set = or i16 %bf.clear, %bf.shl
  store i16 %bf.set, i16* %wusb, align 4
  %hdev93 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %18 = load %struct.usb_device*, %struct.usb_device** %hdev93, align 8, !tbaa !176
  %call94 = call i32 @hub_is_superspeed(%struct.usb_device* %18)
  %tobool95 = icmp ne i32 %call94, 0
  %speed97 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call82, i32 0, i32 4
  %.sink = select i1 %tobool95, i32 5, i32 0
  store i32 %.sink, i32* %speed97, align 4, !tbaa !177
  call void @choose_devnum(%struct.usb_device* %call82)
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call82, i32 0, i32 0
  %19 = load i32, i32* %devnum, align 8, !tbaa !44
  %cmp101 = icmp sle i32 %19, 0
  br i1 %cmp101, label %loop, label %if.end104

if.end104:                                        ; preds = %if.end86
  call void @usb_lock_port(%struct.usb_port* %3)
  %call105 = call i32 @hub_port_init(%struct.usb_hub* %hub, %struct.usb_device* %call82, i32 %port1, i32 %i.0)
  call void @usb_unlock_port(%struct.usb_port* %3)
  %cmp106 = icmp slt i32 %call105, 0
  br i1 %cmp106, label %loop, label %if.end109

if.end109:                                        ; preds = %if.end104
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call82, i32 0, i32 29
  %20 = load i32, i32* %quirks, align 4, !tbaa !199
  %conv110 = zext i32 %20 to i64
  %and111 = and i64 %conv110, 64
  %tobool112 = icmp ne i64 %and111, 0
  br i1 %tobool112, label %if.then113, label %if.end114

if.then113:                                       ; preds = %if.end109
  call void @msleep(i32 1000)
  br label %if.end114

if.end114:                                        ; preds = %if.then113, %if.end109
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call82, i32 0, i32 12
  %bDeviceClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 3
  %21 = load i8, i8* %bDeviceClass, align 4, !tbaa !278
  %conv115 = zext i8 %21 to i32
  %cmp116 = icmp eq i32 %conv115, 9
  br i1 %cmp116, label %land.lhs.true118, label %if.end158

land.lhs.true118:                                 ; preds = %if.end114
  %bus_mA119 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call82, i32 0, i32 19
  %22 = load i16, i16* %bus_mA119, align 8, !tbaa !306
  %conv120 = zext i16 %22 to i32
  %cmp121 = icmp ule i32 %conv120, %.
  br i1 %cmp121, label %if.then123, label %if.end158

if.then123:                                       ; preds = %land.lhs.true118
  %23 = bitcast i16* %devstat to i8*
  %call124 = call i32 @usb_get_status(%struct.usb_device* %call82, i32 0, i32 0, i8* %23)
  %tobool125 = icmp ne i32 %call124, 0
  br i1 %tobool125, label %do.body127, label %if.end140

do.body127:                                       ; preds = %if.then123
  %bf.load128 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_connect.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load128, 18
  %bf.clear129 = and i32 %bf.lshr, 255
  %and130 = and i32 %bf.clear129, 1
  %tobool131 = icmp ne i32 %and130, 0
  %lnot = xor i1 %tobool131, true
  %lnot132 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot132 to i32
  %conv133 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv133, i64 0)
  %tobool134 = icmp ne i64 %expval, 0
  br i1 %tobool134, label %if.then135, label %cleanup

if.then135:                                       ; preds = %do.body127
  %dev136 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call82, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_connect.descriptor to %struct._ddebug*), %struct.device* %dev136, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.160, i32 0, i32 0), i32 %call124)
  br label %cleanup

if.end140:                                        ; preds = %if.then123
  %24 = load i16, i16* %devstat, align 2, !tbaa !165
  %conv141 = zext i16 %24 to i32
  %and142 = and i32 %conv141, 1
  %cmp143 = icmp eq i32 %and142, 0
  br i1 %cmp143, label %if.then145, label %cleanup

if.then145:                                       ; preds = %if.end140
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %has_indicators = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  %bf.load147 = load i8, i8* %has_indicators, align 8
  %bf.lshr148 = lshr i8 %bf.load147, 5
  %bf.clear149 = and i8 %bf.lshr148, 1
  %bf.cast = zext i8 %bf.clear149 to i32
  %tobool150 = icmp ne i32 %bf.cast, 0
  br i1 %tobool150, label %if.then151, label %cleanup

if.then151:                                       ; preds = %if.then145
  %indicator = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 21
  %sub152 = sub nsw i32 %port1, 1
  %idxprom153 = sext i32 %sub152 to i64
  %arrayidx154 = getelementptr inbounds [31 x i8], [31 x i8]* %indicator, i64 0, i64 %idxprom153
  store i8 4, i8* %arrayidx154, align 1, !tbaa !72
  %25 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_power_efficient_wq, align 8, !tbaa !52
  %leds = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  call void @queue_delayed_work(%struct.workqueue_struct* %25, %struct.delayed_work* %leds, i64 0)
  br label %cleanup

cleanup:                                          ; preds = %if.then151, %if.then145, %if.end140, %if.then135, %do.body127
  %status.1 = phi i32 [ %call124, %if.then135 ], [ %call124, %do.body127 ], [ -107, %if.then151 ], [ -107, %if.then145 ], [ %call124, %if.end140 ]
  %cleanup.dest.slot.0 = phi i32 [ 11, %if.then135 ], [ 11, %do.body127 ], [ 11, %if.then151 ], [ 11, %if.then145 ], [ 0, %if.end140 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 11
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %cleanup
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 11
  br i1 %SwitchLeaf2, label %loop_disable, label %cleanup.cont271

LeafBlock:                                        ; preds = %cleanup
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end158, label %cleanup.cont271

if.end158:                                        ; preds = %LeafBlock, %land.lhs.true118, %if.end114
  %descriptor159 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call82, i32 0, i32 12
  %bcdUSB = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor159, i32 0, i32 2
  %26 = load i16, i16* %bcdUSB, align 2, !tbaa !187
  %conv160 = zext i16 %26 to i32
  %cmp161 = icmp sge i32 %conv160, 512
  br i1 %cmp161, label %land.lhs.true163, label %if.end171

land.lhs.true163:                                 ; preds = %if.end158
  %speed164 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call82, i32 0, i32 4
  %27 = load i32, i32* %speed164, align 4, !tbaa !177
  %cmp165 = icmp eq i32 %27, 2
  %28 = load i32, i32* @highspeed_hubs, align 4
  %cmp168 = icmp ne i32 %28, 0
  %or.cond3 = and i1 %cmp165, %cmp168
  br i1 %or.cond3, label %if.then170, label %if.end171

if.then170:                                       ; preds = %land.lhs.true163
  call void @check_highspeed(%struct.usb_hub* %hub, %struct.usb_device* %call82, i32 %port1)
  br label %if.end171

if.end171:                                        ; preds = %if.then170, %land.lhs.true163, %if.end158
  call void @mutex_lock_nested(%struct.mutex* @usb_port_peer_mutex, i32 0)
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @device_state_lock, i32 0, i32 0, i32 0)) #8
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 3
  %29 = load i32, i32* %state, align 8, !tbaa !54
  %cmp172 = icmp eq i32 %29, 0
  br i1 %cmp172, label %if.end177, label %if.else175

if.else175:                                       ; preds = %if.end171
  %child176 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 0
  store %struct.usb_device* %call82, %struct.usb_device** %child176, align 8, !tbaa !115
  br label %if.end177

if.end177:                                        ; preds = %if.else175, %if.end171
  %status.2 = phi i32 [ 0, %if.else175 ], [ -107, %if.end171 ]
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @device_state_lock, i32 0, i32 0, i32 0)) #8
  call void @mutex_unlock(%struct.mutex* @usb_port_peer_mutex)
  %tobool178 = icmp ne i32 %status.2, 0
  br i1 %tobool178, label %if.end196, label %if.then179

if.then179:                                       ; preds = %if.end177
  %call180 = call i32 @usb_new_device(%struct.usb_device* %call82)
  %tobool181 = icmp ne i32 %call180, 0
  br i1 %tobool181, label %if.then182, label %if.else184

if.then182:                                       ; preds = %if.then179
  call void @mutex_lock_nested(%struct.mutex* @usb_port_peer_mutex, i32 0)
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @device_state_lock, i32 0, i32 0, i32 0)) #8
  %child183 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 0
  store %struct.usb_device* null, %struct.usb_device** %child183, align 8, !tbaa !115
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @device_state_lock, i32 0, i32 0, i32 0)) #8
  call void @mutex_unlock(%struct.mutex* @usb_port_peer_mutex)
  br label %if.end196

if.else184:                                       ; preds = %if.then179
  %usb_phy185 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 9
  %30 = load %struct.usb_phy*, %struct.usb_phy** %usb_phy185, align 8, !tbaa !322
  %tobool186 = icmp ne %struct.usb_phy* %30, null
  br i1 %tobool186, label %land.lhs.true187, label %if.end196

land.lhs.true187:                                 ; preds = %if.else184
  %parent188 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  %31 = load %struct.usb_device*, %struct.usb_device** %parent188, align 8, !tbaa !79
  %tobool189 = icmp ne %struct.usb_device* %31, null
  br i1 %tobool189, label %if.end196, label %if.then190

if.then190:                                       ; preds = %land.lhs.true187
  %usb_phy191 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 9
  %32 = load %struct.usb_phy*, %struct.usb_phy** %usb_phy191, align 8, !tbaa !322
  %speed192 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call82, i32 0, i32 4
  %33 = load i32, i32* %speed192, align 4, !tbaa !177
  call void @usb_phy_notify_connect(%struct.usb_phy* %32, i32 %33)
  br label %if.end196

if.end196:                                        ; preds = %if.then190, %land.lhs.true187, %if.else184, %if.then182, %if.end177
  %status.3 = phi i32 [ %status.2, %if.end177 ], [ %call180, %if.else184 ], [ %call180, %land.lhs.true187 ], [ %call180, %if.then190 ], [ %call180, %if.then182 ]
  %tobool197 = icmp ne i32 %status.3, 0
  br i1 %tobool197, label %loop_disable, label %if.end199

if.end199:                                        ; preds = %if.end196
  %call200 = call i32 @hub_power_remaining(%struct.usb_hub* %hub)
  %tobool201 = icmp ne i32 %call200, 0
  br i1 %tobool201, label %do.body204, label %cleanup.cont271

do.body204:                                       ; preds = %if.end199
  %bf.load205 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_connect.descriptor.162 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr206 = lshr i32 %bf.load205, 18
  %bf.clear207 = and i32 %bf.lshr206, 255
  %and208 = and i32 %bf.clear207, 1
  %tobool209 = icmp ne i32 %and208, 0
  %lnot210 = xor i1 %tobool209, true
  %lnot212 = xor i1 %lnot210, true
  %lnot.ext213 = zext i1 %lnot212 to i32
  %conv214 = sext i32 %lnot.ext213 to i64
  %expval215 = call i64 @llvm.expect.i64(i64 %conv214, i64 0)
  %tobool216 = icmp ne i64 %expval215, 0
  br i1 %tobool216, label %if.then217, label %cleanup.cont271

if.then217:                                       ; preds = %do.body204
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %34 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !204
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_connect.descriptor.162 to %struct._ddebug*), %struct.device* %34, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.163, i32 0, i32 0), i32 %call200)
  br label %cleanup.cont271

loop_disable:                                     ; preds = %if.end196, %LeafBlock1
  %status.4 = phi i32 [ %status.1, %LeafBlock1 ], [ %status.3, %if.end196 ]
  call void @hub_port_disable(%struct.usb_hub* %hub, i32 %port1, i32 1)
  br label %loop

loop:                                             ; preds = %loop_disable, %if.end104, %if.end86
  %status.5 = phi i32 [ %status.4, %loop_disable ], [ -107, %if.end86 ], [ %call105, %if.end104 ]
  call void @usb_ep0_reinit(%struct.usb_device* %call82)
  call void @release_devnum(%struct.usb_device* %call82)
  call void @hub_free_dev(%struct.usb_device* %call82)
  call void @usb_put_dev(%struct.usb_device* %call82)
  switch i32 %status.5, label %for.inc [
    i32 -107, label %for.end
    i32 -524, label %for.end
  ]

for.inc:                                          ; preds = %loop
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %loop, %loop, %for.cond
  %status.6 = phi i32 [ %status.5, %loop ], [ %status.5, %loop ], [ %status.0, %for.cond ]
  %hdev232 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %35 = load %struct.usb_device*, %struct.usb_device** %hdev232, align 8, !tbaa !176
  %parent233 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %35, i32 0, i32 8
  %36 = load %struct.usb_device*, %struct.usb_device** %parent233, align 8, !tbaa !79
  %tobool234 = icmp ne %struct.usb_device* %36, null
  br i1 %tobool234, label %if.then242, label %lor.lhs.false235

lor.lhs.false235:                                 ; preds = %for.end
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %37 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %port_handed_over = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %37, i32 0, i32 24
  %38 = load i32 (%struct.usb_hcd*, i32)*, i32 (%struct.usb_hcd*, i32)** %port_handed_over, align 8, !tbaa !323
  %tobool236 = icmp ne i32 (%struct.usb_hcd*, i32)* %38, null
  br i1 %tobool236, label %lor.lhs.false237, label %if.then242

lor.lhs.false237:                                 ; preds = %lor.lhs.false235
  %driver238 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %39 = load %struct.hc_driver*, %struct.hc_driver** %driver238, align 8, !tbaa !57
  %port_handed_over239 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %39, i32 0, i32 24
  %40 = load i32 (%struct.usb_hcd*, i32)*, i32 (%struct.usb_hcd*, i32)** %port_handed_over239, align 8, !tbaa !323
  %call240 = call i32 %40(%struct.usb_hcd* %call, i32 %port1)
  %tobool241 = icmp ne i32 %call240, 0
  br i1 %tobool241, label %done, label %if.then242

if.then242:                                       ; preds = %lor.lhs.false237, %lor.lhs.false235, %for.end
  switch i32 %status.6, label %if.then248 [
    i32 -107, label %done
    i32 -19, label %done
  ]

if.then248:                                       ; preds = %if.then242
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %done

done:                                             ; preds = %if.then248, %if.then242, %if.then242, %lor.lhs.false237, %if.then84, %if.end64
  call void @hub_port_disable(%struct.usb_hub* %hub, i32 %port1, i32 1)
  %driver253 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %41 = load %struct.hc_driver*, %struct.hc_driver** %driver253, align 8, !tbaa !57
  %relinquish_port = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %41, i32 0, i32 23
  %42 = load void (%struct.usb_hcd*, i32)*, void (%struct.usb_hcd*, i32)** %relinquish_port, align 8, !tbaa !324
  %tobool254 = icmp ne void (%struct.usb_hcd*, i32)* %42, null
  br i1 %tobool254, label %land.lhs.true255, label %cleanup.cont271

land.lhs.true255:                                 ; preds = %done
  %hdev256 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %43 = load %struct.usb_device*, %struct.usb_device** %hdev256, align 8, !tbaa !176
  %parent257 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %43, i32 0, i32 8
  %44 = load %struct.usb_device*, %struct.usb_device** %parent257, align 8, !tbaa !79
  %tobool258 = icmp ne %struct.usb_device* %44, null
  br i1 %tobool258, label %cleanup.cont271, label %if.then259

if.then259:                                       ; preds = %land.lhs.true255
  %driver260 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %45 = load %struct.hc_driver*, %struct.hc_driver** %driver260, align 8, !tbaa !57
  %relinquish_port261 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %45, i32 0, i32 23
  %46 = load void (%struct.usb_hcd*, i32)*, void (%struct.usb_hcd*, i32)** %relinquish_port261, align 8, !tbaa !324
  call void %46(%struct.usb_hcd* %call, i32 %port1)
  br label %cleanup.cont271

cleanup.cont271:                                  ; preds = %if.then259, %land.lhs.true255, %done, %if.then217, %do.body204, %if.end199, %LeafBlock, %LeafBlock1, %if.end64
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_phy_notify_disconnect(%struct.usb_phy* %x, i32 %speed) #1 {
entry:
  %tobool = icmp ne %struct.usb_phy* %x, null
  br i1 %tobool, label %land.lhs.true, label %return

land.lhs.true:                                    ; preds = %entry
  %notify_disconnect = getelementptr inbounds %struct.usb_phy, %struct.usb_phy* %x, i32 0, i32 20
  %0 = load i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32)** %notify_disconnect, align 8, !tbaa !325
  %tobool1 = icmp ne i32 (%struct.usb_phy*, i32)* %0, null
  br i1 %tobool1, label %if.then, label %return

if.then:                                          ; preds = %land.lhs.true
  %notify_disconnect2 = getelementptr inbounds %struct.usb_phy, %struct.usb_phy* %x, i32 0, i32 20
  %1 = load i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32)** %notify_disconnect2, align 8, !tbaa !325
  %call = call i32 %1(%struct.usb_phy* %x, i32 %speed)
  br label %return

return:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hub_port_debounce_be_stable(%struct.usb_hub* %hub, i32 %port1) #1 {
entry:
  %call = call i32 @hub_port_debounce(%struct.usb_hub* %hub, i32 %port1, i1 zeroext false)
  ret i32 %call
}

declare i32 @__printk_ratelimit(i8*) #2

; Function Attrs: nounwind uwtable
define internal void @choose_devnum(%struct.usb_device* %udev) #0 {
entry:
  %oldbit.i = alloca i8, align 1
  %bus1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus1, align 8, !tbaa !2
  %devnum_next_mutex = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 9
  call void @mutex_lock_nested(%struct.mutex* %devnum_next_mutex, i32 0)
  %wusb = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %wusb, align 4
  %bf.lshr = lshr i16 %bf.load, 5
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %1 = load i8, i8* %portnum, align 2, !tbaa !81
  %conv = zext i8 %1 to i32
  %add = add nsw i32 %conv, 1
  %conv2 = sext i32 %add to i64
  %devmap = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 10
  %devicemap = getelementptr inbounds %struct.usb_devmap, %struct.usb_devmap* %devmap, i32 0, i32 0
  %arraydecay = getelementptr inbounds [2 x i64], [2 x i64]* %devicemap, i32 0, i32 0
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %arraydecay, i64 %conv2) #8, !srcloc !235
  %2 = load i8, i8* %oldbit.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %2 to i1
  %lnot = xor i1 %tobool.i, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv5, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %do.body8, label %if.end32

do.body8:                                         ; preds = %if.then
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10.21, i32 0, i32 0), i32 2002, i64 12) #8, !srcloc !328
  br label %do.body9

do.body9:                                         ; preds = %do.body9, %do.body8
  br label %do.body9

if.else:                                          ; preds = %entry
  %devmap14 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 10
  %devicemap15 = getelementptr inbounds %struct.usb_devmap, %struct.usb_devmap* %devmap14, i32 0, i32 0
  %arraydecay16 = getelementptr inbounds [2 x i64], [2 x i64]* %devicemap15, i32 0, i32 0
  %devnum_next = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 8
  %3 = load i32, i32* %devnum_next, align 8, !tbaa !329
  %conv17 = sext i32 %3 to i64
  %call18 = call i64 @find_next_zero_bit(i64* %arraydecay16, i64 128, i64 %conv17)
  %conv19 = trunc i64 %call18 to i32
  %cmp = icmp sge i32 %conv19, 128
  br i1 %cmp, label %if.then21, label %if.end27

if.then21:                                        ; preds = %if.else
  %devmap22 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 10
  %devicemap23 = getelementptr inbounds %struct.usb_devmap, %struct.usb_devmap* %devmap22, i32 0, i32 0
  %arraydecay24 = getelementptr inbounds [2 x i64], [2 x i64]* %devicemap23, i32 0, i32 0
  %call25 = call i64 @find_next_zero_bit(i64* %arraydecay24, i64 128, i64 1)
  %conv26 = trunc i64 %call25 to i32
  br label %if.end27

if.end27:                                         ; preds = %if.then21, %if.else
  %devnum.0 = phi i32 [ %conv26, %if.then21 ], [ %conv19, %if.else ]
  %cmp28 = icmp sge i32 %devnum.0, 127
  %add30 = add nsw i32 %devnum.0, 1
  %cond = select i1 %cmp28, i32 1, i32 %add30
  %devnum_next31 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 8
  store i32 %cond, i32* %devnum_next31, align 8, !tbaa !329
  br label %if.end32

if.end32:                                         ; preds = %if.end27, %if.then
  %devnum.1 = phi i32 [ %devnum.0, %if.end27 ], [ %add, %if.then ]
  %cmp33 = icmp slt i32 %devnum.1, 128
  br i1 %cmp33, label %if.then35, label %if.end41

if.then35:                                        ; preds = %if.end32
  %conv36 = sext i32 %devnum.1 to i64
  %devmap37 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 10
  %devicemap38 = getelementptr inbounds %struct.usb_devmap, %struct.usb_devmap* %devmap37, i32 0, i32 0
  %arraydecay39 = getelementptr inbounds [2 x i64], [2 x i64]* %devicemap38, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay39, i64 %conv36, i64* %arraydecay39) #8, !srcloc !201
  %devnum40 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  store i32 %devnum.1, i32* %devnum40, align 8, !tbaa !44
  br label %if.end41

if.end41:                                         ; preds = %if.then35, %if.end32
  %devnum_next_mutex42 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 9
  call void @mutex_unlock(%struct.mutex* %devnum_next_mutex42)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @check_highspeed(%struct.usb_hub* %hub, %struct.usb_device* %udev, i32 %port1) #0 {
entry:
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %0 = load i32, i32* %quirks, align 4, !tbaa !199
  %conv = zext i32 %0 to i64
  %and = and i64 %conv, 256
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %call.i = call noalias i8* @__kmalloc(i64 10, i32 20971712) #8
  %1 = bitcast i8* %call.i to %struct.usb_qualifier_descriptor*
  %cmp = icmp eq %struct.usb_qualifier_descriptor* %1, null
  br i1 %cmp, label %cleanup.cont, label %if.end3

if.end3:                                          ; preds = %if.end
  %2 = bitcast %struct.usb_qualifier_descriptor* %1 to i8*
  %call4 = call i32 @usb_get_descriptor(%struct.usb_device* %udev, i8 zeroext 6, i8 zeroext 0, i8* %2, i32 10)
  %conv5 = sext i32 %call4 to i64
  %cmp6 = icmp eq i64 %conv5, 10
  br i1 %cmp6, label %if.then8, label %if.end13

if.then8:                                         ; preds = %if.end3
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %has_indicators = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  %bf.load = load i8, i8* %has_indicators, align 8
  %bf.lshr = lshr i8 %bf.load, 5
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool9 = icmp ne i32 %bf.cast, 0
  br i1 %tobool9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %if.then8
  %indicator = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 21
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [31 x i8], [31 x i8]* %indicator, i64 0, i64 %idxprom
  store i8 2, i8* %arrayidx, align 1, !tbaa !72
  %3 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_power_efficient_wq, align 8, !tbaa !52
  %leds = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  call void @queue_delayed_work(%struct.workqueue_struct* %3, %struct.delayed_work* %leds, i64 0)
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %if.then8, %if.end3
  %4 = bitcast %struct.usb_qualifier_descriptor* %1 to i8*
  call void @kfree(i8* %4)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end13, %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_phy_notify_connect(%struct.usb_phy* %x, i32 %speed) #1 {
entry:
  %tobool = icmp ne %struct.usb_phy* %x, null
  br i1 %tobool, label %land.lhs.true, label %return

land.lhs.true:                                    ; preds = %entry
  %notify_connect = getelementptr inbounds %struct.usb_phy, %struct.usb_phy* %x, i32 0, i32 19
  %0 = load i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32)** %notify_connect, align 8, !tbaa !330
  %tobool1 = icmp ne i32 (%struct.usb_phy*, i32)* %0, null
  br i1 %tobool1, label %if.then, label %return

if.then:                                          ; preds = %land.lhs.true
  %notify_connect2 = getelementptr inbounds %struct.usb_phy, %struct.usb_phy* %x, i32 0, i32 19
  %1 = load i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32)** %notify_connect2, align 8, !tbaa !330
  %call = call i32 %1(%struct.usb_phy* %x, i32 %speed)
  br label %return

return:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_power_remaining(%struct.usb_hub* %hub) #0 {
entry:
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !176
  %limited_power = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  %bf.load = load i8, i8* %limited_power, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end, label %cleanup38

if.end:                                           ; preds = %entry
  %bus_mA = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 19
  %1 = load i16, i16* %bus_mA, align 8, !tbaa !306
  %conv = zext i16 %1 to i32
  %descriptor = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %2 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !232
  %bHubContrCurrent = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %2, i32 0, i32 5
  %3 = load i8, i8* %bHubContrCurrent, align 1, !tbaa !308
  %conv2 = zext i8 %3 to i32
  %sub = sub nsw i32 %conv, %conv2
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock, %if.end
  %port1.0 = phi i32 [ 1, %if.end ], [ %inc, %LeafBlock ]
  %remaining.0 = phi i32 [ %sub, %if.end ], [ %remaining.1, %LeafBlock ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %4 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp = icmp sle i32 %port1.0, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 25
  %5 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub4 = sub nsw i32 %port1.0, 1
  %idxprom = sext i32 %sub4 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %5, i64 %idxprom
  %6 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %6, i32 0, i32 0
  %7 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !115
  %tobool5 = icmp ne %struct.usb_device* %7, null
  br i1 %tobool5, label %if.end7, label %LeafBlock

if.end7:                                          ; preds = %for.body
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %7)
  %tobool8 = icmp ne i32 %call, 0
  %. = select i1 %tobool8, i32 150, i32 100
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 15
  %8 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool11 = icmp ne %struct.usb_host_config* %8, null
  br i1 %tobool11, label %if.then12, label %if.else15

if.then12:                                        ; preds = %if.end7
  %actconfig13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 15
  %9 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig13, align 8, !tbaa !102
  %call14 = call i32 @usb_get_max_power(%struct.usb_device* %7, %struct.usb_host_config* %9)
  br label %if.end23

if.else15:                                        ; preds = %if.end7
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 9
  %10 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %otg_port = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %10, i32 0, i32 5
  %11 = load i8, i8* %otg_port, align 2, !tbaa !178
  %conv16 = zext i8 %11 to i32
  %cmp17 = icmp ne i32 %port1.0, %conv16
  br i1 %cmp17, label %if.end23, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else15
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  %12 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool19 = icmp ne %struct.usb_device* %12, null
  %.. = select i1 %tobool19, i32 %., i32 8
  br label %if.end23

if.end23:                                         ; preds = %lor.lhs.false, %if.else15, %if.then12
  %delta.1 = phi i32 [ %call14, %if.then12 ], [ %., %if.else15 ], [ %.., %lor.lhs.false ]
  %mA_per_port = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %13 = load i32, i32* %mA_per_port, align 8, !tbaa !307
  %cmp24 = icmp ugt i32 %delta.1, %13
  br i1 %cmp24, label %if.then26, label %if.end28

if.then26:                                        ; preds = %if.end23
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %if.end23
  %sub29 = sub nsw i32 %remaining.0, %delta.1
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end28, %for.body
  %remaining.1 = phi i32 [ %sub29, %if.end28 ], [ %remaining.0, %for.body ]
  %inc = add nsw i32 %port1.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %cmp33 = icmp slt i32 %remaining.0, 0
  br i1 %cmp33, label %if.then35, label %cleanup38

if.then35:                                        ; preds = %for.end
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup38

cleanup38:                                        ; preds = %if.then35, %for.end, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ 0, %if.then35 ], [ %remaining.0, %for.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_get_max_power(%struct.usb_device* %udev, %struct.usb_host_config* %c) #1 {
entry:
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp uge i32 %0, 5
  %cond = select i1 %cmp, i32 8, i32 2
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %c, i32 0, i32 0
  %bMaxPower = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 7
  %1 = load i8, i8* %bMaxPower, align 8, !tbaa !331
  %conv = zext i8 %1 to i32
  %mul1 = mul i32 %conv, %cond
  ret i32 %mul1
}

declare i64 @find_next_zero_bit(i64*, i64, i64) #2

; Function Attrs: nounwind uwtable
define internal i8* @to_led_name(i32 %selector) #0 {
entry:
  %Pivot6 = icmp slt i32 %selector, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %selector, 3
  br i1 %Pivot4, label %return, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %selector, 3
  br i1 %SwitchLeaf2, label %return, label %sw.default

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %selector, 1
  br i1 %Pivot, label %LeafBlock, label %return

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %selector, 0
  br i1 %SwitchLeaf, label %return, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %return

return:                                           ; preds = %sw.default, %LeafBlock, %NodeBlock, %LeafBlock1, %NodeBlock3
  %retval.0 = phi i8* [ getelementptr inbounds ([3 x i8], [3 x i8]* @.str.7.879, i32 0, i32 0), %sw.default ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.111, i32 0, i32 0), %NodeBlock ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.112, i32 0, i32 0), %NodeBlock3 ], [ getelementptr inbounds ([4 x i8], [4 x i8]* @.str.113, i32 0, i32 0), %LeafBlock1 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.114, i32 0, i32 0), %LeafBlock ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @refcount_set(%struct.qspinlock* %r, i32 %n) #1 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %refs = getelementptr inbounds %struct.qspinlock, %struct.qspinlock* %r, i32 0, i32 0
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  store i32 %n, i32* %__val.i, align 4, !tbaa !72
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %refs, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %0 = bitcast i8* %arraydecay.i to i32*
  %1 = load i32, i32* %0, align 4, !tbaa !73
  store volatile i32 %1, i32* %counter.i, align 4, !tbaa !73
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_int(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 3
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_dir_in(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !309
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 128
  %cmp = icmp eq i32 %and, 128
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define void @usb_hub_cleanup() #0 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @hub_wq, align 8, !tbaa !52
  call void @destroy_workqueue(%struct.workqueue_struct* %0)
  call void @usb_deregister(%struct.usb_driver* @hub_driver)
  ret void
}

declare void @destroy_workqueue(%struct.workqueue_struct*) #2

; Function Attrs: nounwind uwtable
define i8* @usb_get_hub_port_acpi_handle(%struct.usb_device* %hdev, i32 %port1) #0 {
entry:
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  %tobool = icmp ne %struct.usb_hub* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %0 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %0, i64 %idxprom
  %1 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %dev = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  %fwnode = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 27
  %2 = load %struct.fwnode_handle*, %struct.fwnode_handle** %fwnode, align 8, !tbaa !333
  %call1 = call %struct.acpi_device* @to_acpi_device_node(%struct.fwnode_handle* %2)
  %call2 = call i8* @acpi_device_handle(%struct.acpi_device* %call1)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i8* [ %call2, %if.end ], [ null, %entry ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.acpi_device* @to_acpi_device_node(%struct.fwnode_handle* %fwnode) #1 {
entry:
  %call = call zeroext i1 @is_acpi_device_node(%struct.fwnode_handle* %fwnode)
  %0 = bitcast %struct.fwnode_handle* %fwnode to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.acpi_device*
  %cond = select i1 %call, %struct.acpi_device* %1, %struct.acpi_device* null
  ret %struct.acpi_device* %cond
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @acpi_device_handle(%struct.acpi_device* %adev) #1 {
entry:
  %tobool = icmp ne %struct.acpi_device* %adev, null
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %handle = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %adev, i32 0, i32 1
  %0 = load i8*, i8** %handle, align 8, !tbaa !334
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi i8* [ %0, %cond.true ], [ null, %entry ]
  ret i8* %cond
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @is_acpi_device_node(%struct.fwnode_handle* %fwnode) #1 {
entry:
  %0 = bitcast %struct.fwnode_handle* %fwnode to i8*
  %call = call zeroext i1 @IS_ERR_OR_NULL(i8* %0)
  br i1 %call, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %type = getelementptr inbounds %struct.fwnode_handle, %struct.fwnode_handle* %fwnode, i32 0, i32 0
  %1 = load i32, i32* %type, align 8, !tbaa !350
  %cmp = icmp eq i32 %1, 2
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  ret i1 %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR_OR_NULL(i8* %ptr) #1 {
entry:
  %tobool = icmp ne i8* %ptr, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot5 = xor i1 %cmp, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %expval10 = call i64 @llvm.expect.i64(i64 %conv9, i64 0)
  %tobool11 = icmp ne i64 %expval10, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %tobool11, %lor.rhs ]
  ret i1 %3
}

; Function Attrs: nounwind uwtable
define void @usb_mon_deregister() #0 {
entry:
  %0 = load %struct.usb_mon_operations*, %struct.usb_mon_operations** @mon_ops, align 8, !tbaa !52
  %cmp = icmp eq %struct.usb_mon_operations* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %return

if.end:                                           ; preds = %entry
  store %struct.usb_mon_operations* null, %struct.usb_mon_operations** @mon_ops, align 8, !tbaa !52
  call void asm sideeffect "mfence", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !351
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_mon_register(%struct.usb_mon_operations* %ops) #0 {
entry:
  %0 = load %struct.usb_mon_operations*, %struct.usb_mon_operations** @mon_ops, align 8, !tbaa !52
  %tobool = icmp ne %struct.usb_mon_operations* %0, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  store %struct.usb_mon_operations* %ops, %struct.usb_mon_operations** @mon_ops, align 8, !tbaa !52
  call void asm sideeffect "mfence", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !352
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -16, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_platform_shutdown(%struct.platform_device* %dev) #0 {
entry:
  %call = call i8* @platform_get_drvdata(%struct.platform_device* %dev)
  %0 = bitcast i8* %call to %struct.usb_hcd.712*
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %0, i32 0, i32 8
  %1 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %shutdown = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %1, i32 0, i32 10
  %shutdown1 = bitcast {}** %shutdown to void (%struct.usb_hcd.712*)**
  %2 = load void (%struct.usb_hcd.712*)*, void (%struct.usb_hcd.712*)** %shutdown1, align 8, !tbaa !353
  %tobool = icmp ne void (%struct.usb_hcd.712*)* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %driver2 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %0, i32 0, i32 8
  %3 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver2, align 8, !tbaa !57
  %shutdown3 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %3, i32 0, i32 10
  %shutdown4 = bitcast {}** %shutdown3 to void (%struct.usb_hcd.712*)**
  %4 = load void (%struct.usb_hcd.712*)*, void (%struct.usb_hcd.712*)** %shutdown4, align 8, !tbaa !353
  call void %4(%struct.usb_hcd.712* %0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @platform_get_drvdata(%struct.platform_device* %pdev) #1 {
entry:
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call = call i8* @dev_get_drvdata.48(%struct.device* %dev)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_get_drvdata.48(%struct.device* %dev) #1 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !117
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define void @usb_remove_hcd(%struct.usb_hcd.712* %hcd) #0 {
entry:
  %rhdev = alloca %struct.usb_device*, align 8
  %self = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 11
  %0 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !175
  store %struct.usb_device* %0, %struct.usb_device** %rhdev, align 8, !tbaa !52
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %1 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !52
  %call = call %struct.usb_device* @usb_get_dev(%struct.usb_device* %1)
  %2 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !52
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj, %struct.attribute_group* @usb_bus_attr_group)
  %flags = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags, i64 5, i64* %flags) #8, !srcloc !354
  %state2 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 25
  %3 = load i32, i32* %state2, align 8, !tbaa !355
  %and = and i32 %3, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %do.body4

if.then:                                          ; preds = %entry
  %state3 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 25
  store i32 133, i32* %state3, align 8, !tbaa !355
  br label %do.body4

do.body4:                                         ; preds = %if.then, %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_remove_hcd.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and5 = and i32 %bf.clear, 1
  %tobool6 = icmp ne i32 %and5, 0
  %lnot = xor i1 %tobool6, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then9, label %do.end14

if.then9:                                         ; preds = %do.body4
  %self10 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller11 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self10, i32 0, i32 0
  %4 = load %struct.device*, %struct.device** %controller11, align 8, !tbaa !356
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_remove_hcd.descriptor to %struct._ddebug*), %struct.device* %4, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.50.51, i32 0, i32 0))
  br label %do.end14

do.end14:                                         ; preds = %if.then9, %do.body4
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0)) #8
  %rh_registered = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load15 = load i16, i16* %rh_registered, align 8
  %bf.clear16 = and i16 %bf.load15, -2
  store i16 %bf.clear16, i16* %rh_registered, align 8
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0)) #8
  %wakeup_work = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 7
  %call17 = call zeroext i1 @cancel_work_sync(%struct.work_struct* %wakeup_work)
  call void @mutex_lock_nested(%struct.mutex* @usb_bus_idr_lock, i32 0)
  call void @usb_disconnect(%struct.usb_device** %rhdev)
  call void @mutex_unlock(%struct.mutex* @usb_bus_idr_lock)
  %rh_pollable = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load18 = load i16, i16* %rh_pollable, align 8
  %bf.clear19 = and i16 %bf.load18, -3
  store i16 %bf.clear19, i16* %rh_pollable, align 8
  %flags20 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags20, i64 2, i64* %flags20) #8, !srcloc !354
  %rh_timer = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 5
  %call21 = call i32 @del_timer_sync(%struct.timer_list* %rh_timer)
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %5 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %stop = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %5, i32 0, i32 9
  %stop22 = bitcast {}** %stop to void (%struct.usb_hcd.712*)**
  %6 = load void (%struct.usb_hcd.712*)*, void (%struct.usb_hcd.712*)** %stop22, align 8, !tbaa !357
  call void %6(%struct.usb_hcd.712* %hcd)
  %state23 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 25
  store i32 0, i32* %state23, align 8, !tbaa !355
  %flags24 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags24, i64 2, i64* %flags24) #8, !srcloc !354
  %rh_timer25 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 5
  %call26 = call i32 @del_timer_sync(%struct.timer_list* %rh_timer25)
  %call27 = call i32 @usb_hcd_is_primary_hcd(%struct.usb_hcd.712* %hcd)
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %if.then29, label %if.end34

if.then29:                                        ; preds = %do.end14
  %irq = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 13
  %7 = load i32, i32* %irq, align 4, !tbaa !358
  %cmp = icmp ugt i32 %7, 0
  br i1 %cmp, label %if.then31, label %if.end34

if.then31:                                        ; preds = %if.then29
  %irq32 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 13
  %8 = load i32, i32* %irq32, align 4, !tbaa !358
  %9 = bitcast %struct.usb_hcd.712* %hcd to i8*
  call void @free_irq(i32 %8, i8* %9)
  br label %if.end34

if.end34:                                         ; preds = %if.then31, %if.then29, %do.end14
  %self35 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  call void @usb_deregister_bus(%struct.usb_bus* %self35)
  call void bitcast (void (%struct.usb_hcd.2781*)* @hcd_buffer_destroy to void (%struct.usb_hcd.712*)*)(%struct.usb_hcd.712* %hcd)
  %remove_phy = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load36 = load i16, i16* %remove_phy, align 8
  %bf.lshr37 = lshr i16 %bf.load36, 3
  %bf.clear38 = and i16 %bf.lshr37, 1
  %bf.cast = zext i16 %bf.clear38 to i32
  %tobool39 = icmp ne i32 %bf.cast, 0
  br i1 %tobool39, label %land.lhs.true, label %if.end48

land.lhs.true:                                    ; preds = %if.end34
  %phy = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 10
  %10 = load %struct.phy*, %struct.phy** %phy, align 8, !tbaa !359
  %tobool40 = icmp ne %struct.phy* %10, null
  br i1 %tobool40, label %if.then41, label %if.end48

if.then41:                                        ; preds = %land.lhs.true
  %phy42 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 10
  %11 = load %struct.phy*, %struct.phy** %phy42, align 8, !tbaa !359
  %call43 = call i32 @phy_power_off(%struct.phy* %11)
  %phy44 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 10
  %12 = load %struct.phy*, %struct.phy** %phy44, align 8, !tbaa !359
  %call45 = call i32 @phy_exit(%struct.phy* %12)
  %phy46 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 10
  %13 = load %struct.phy*, %struct.phy** %phy46, align 8, !tbaa !359
  call void @phy_put(%struct.phy* %13)
  %phy47 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 10
  store %struct.phy* null, %struct.phy** %phy47, align 8, !tbaa !359
  br label %if.end48

if.end48:                                         ; preds = %if.then41, %land.lhs.true, %if.end34
  %remove_phy49 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load50 = load i16, i16* %remove_phy49, align 8
  %bf.lshr51 = lshr i16 %bf.load50, 3
  %bf.clear52 = and i16 %bf.lshr51, 1
  %bf.cast53 = zext i16 %bf.clear52 to i32
  %tobool54 = icmp ne i32 %bf.cast53, 0
  br i1 %tobool54, label %land.lhs.true55, label %if.end61

land.lhs.true55:                                  ; preds = %if.end48
  %usb_phy = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 9
  %14 = load %struct.usb_phy*, %struct.usb_phy** %usb_phy, align 8, !tbaa !322
  %tobool56 = icmp ne %struct.usb_phy* %14, null
  br i1 %tobool56, label %if.then57, label %if.end61

if.then57:                                        ; preds = %land.lhs.true55
  %usb_phy58 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 9
  %15 = load %struct.usb_phy*, %struct.usb_phy** %usb_phy58, align 8, !tbaa !322
  call void @usb_phy_shutdown(%struct.usb_phy* %15)
  %usb_phy59 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 9
  %16 = load %struct.usb_phy*, %struct.usb_phy** %usb_phy59, align 8, !tbaa !322
  call void @usb_put_phy(%struct.usb_phy* %16)
  %usb_phy60 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 9
  store %struct.usb_phy* null, %struct.usb_phy** %usb_phy60, align 8, !tbaa !322
  br label %if.end61

if.end61:                                         ; preds = %if.then57, %land.lhs.true55, %if.end48
  call void @usb_put_invalidate_rhdev(%struct.usb_hcd.712* %hcd)
  %flags62 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  store i64 0, i64* %flags62, align 8, !tbaa !84
  ret void
}

declare void @sysfs_remove_group(%struct.kobject*, %struct.attribute_group*) #2

declare zeroext i1 @cancel_work_sync(%struct.work_struct*) #2

declare i32 @del_timer_sync(%struct.timer_list*) #2

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_is_primary_hcd(%struct.usb_hcd.712* %hcd) #0 {
entry:
  %primary_hcd = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 23
  %0 = load %struct.usb_hcd.712*, %struct.usb_hcd.712** %primary_hcd, align 8, !tbaa !360
  %tobool = icmp ne %struct.usb_hcd.712* %0, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %primary_hcd1 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 23
  %1 = load %struct.usb_hcd.712*, %struct.usb_hcd.712** %primary_hcd1, align 8, !tbaa !360
  %cmp = icmp eq %struct.usb_hcd.712* %hcd, %1
  %conv = zext i1 %cmp to i32
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %conv, %if.end ], [ 1, %entry ]
  ret i32 %retval.0
}

declare void @free_irq(i32, i8*) #2

; Function Attrs: nounwind uwtable
define internal void @usb_deregister_bus(%struct.usb_bus* %bus) #0 {
entry:
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  call void @mutex_lock_nested(%struct.mutex* @usb_bus_idr_lock, i32 0)
  %busnum1 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 1
  %0 = load i32, i32* %busnum1, align 8, !tbaa !41
  call void @idr_remove(%struct.idr* @usb_bus_idr, i32 %0)
  call void @mutex_unlock(%struct.mutex* @usb_bus_idr_lock)
  call void @usb_notify_remove_bus(%struct.usb_bus* %bus)
  ret void
}

declare i32 @phy_power_off(%struct.phy*) #2

declare i32 @phy_exit(%struct.phy*) #2

declare void @phy_put(%struct.phy*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_phy_shutdown(%struct.usb_phy* %x) #1 {
entry:
  %tobool = icmp ne %struct.usb_phy* %x, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %shutdown = getelementptr inbounds %struct.usb_phy, %struct.usb_phy* %x, i32 0, i32 14
  %0 = load void (%struct.usb_phy*)*, void (%struct.usb_phy*)** %shutdown, align 8, !tbaa !361
  %tobool1 = icmp ne void (%struct.usb_phy*)* %0, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %shutdown2 = getelementptr inbounds %struct.usb_phy, %struct.usb_phy* %x, i32 0, i32 14
  %1 = load void (%struct.usb_phy*)*, void (%struct.usb_phy*)** %shutdown2, align 8, !tbaa !361
  call void %1(%struct.usb_phy* %x)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

declare void @usb_put_phy(%struct.usb_phy*) #2

; Function Attrs: nounwind uwtable
define internal void @usb_put_invalidate_rhdev(%struct.usb_hcd.712* %hcd) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @usb_port_peer_mutex, i32 0)
  %self = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 11
  %0 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !175
  %self1 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %root_hub2 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self1, i32 0, i32 11
  store %struct.usb_device* null, %struct.usb_device** %root_hub2, align 8, !tbaa !175
  call void @mutex_unlock(%struct.mutex* @usb_port_peer_mutex)
  call void @usb_put_dev(%struct.usb_device* %0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @idr_remove(%struct.idr* %idr, i32 %id) #1 {
entry:
  %idr_rt = getelementptr inbounds %struct.idr, %struct.idr* %idr, i32 0, i32 0
  %conv = sext i32 %id to i64
  %call = call i8* @radix_tree_delete_item(%struct.radix_tree_root* %idr_rt, i64 %conv, i8* null)
  ret void
}

declare i8* @radix_tree_delete_item(%struct.radix_tree_root*, i64, i8*) #2

; Function Attrs: nounwind uwtable
define internal i64 @interface_authorized_default_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %2)
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @interface_authorized_default_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i8, align 1
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %2)
  %conv = trunc i64 %count to i32
  %call1 = call i32 @strtobool(i8* %buf, i8* %val)
  %cmp = icmp ne i32 %call1, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %3 = load i8, i8* %val, align 1, !tbaa !109, !range !110
  %tobool = trunc i8 %3 to i1
  %flags = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 11
  br i1 %tobool, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags, i64 7, i64* %flags) #8, !srcloc !362
  br label %if.end5

if.else:                                          ; preds = %if.end
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags, i64 7, i64* %flags) #8, !srcloc !354
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then3
  %conv6 = sext i32 %conv to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %entry
  %retval.0 = phi i64 [ %conv6, %if.end5 ], [ -22, %entry ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd.712*
  ret %struct.usb_hcd.712* %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @strtobool(i8* %s, i8* %res) #1 {
entry:
  %call = call i32 @kstrtobool(i8* %s, i8* %res)
  ret i32 %call
}

declare i32 @kstrtobool(i8*, i8*) #2

declare i32 @sprintf(i8*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define internal i64 @authorized_default_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %2)
  %flags = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 11
  %3 = load i64, i64* %flags, align 8, !tbaa !84
  %and = and i64 %3, 256
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %call2 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.590, i32 0, i32 0), i32 %lnot.ext)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @authorized_default_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %size) #0 {
entry:
  %val = alloca i32, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %2)
  %call1 = call i32 (i8*, i8*, ...) @sscanf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.590, i32 0, i32 0), i32* %val)
  %conv = sext i32 %call1 to i64
  %cmp = icmp eq i64 %conv, 1
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %3 = load i32, i32* %val, align 4, !tbaa !73
  %tobool = icmp ne i32 %3, 0
  %flags = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 11
  br i1 %tobool, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.then
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags, i64 8, i64* %flags) #8, !srcloc !362
  br label %if.end6

if.else:                                          ; preds = %if.then
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags, i64 8, i64* %flags) #8, !srcloc !354
  br label %if.end6

if.end6:                                          ; preds = %if.else, %if.then3, %entry
  %result.0 = phi i64 [ %size, %if.else ], [ %size, %if.then3 ], [ -22, %entry ]
  ret i64 %result.0
}

declare i32 @sscanf(i8*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define i32 @usb_add_hcd(%struct.usb_hcd.712* %hcd, i32 %irqnum, i64 %irqflags) #0 {
entry:
  %rhdev = alloca %struct.usb_device*, align 8
  %usb_phy = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 9
  %0 = load %struct.usb_phy*, %struct.usb_phy** %usb_phy, align 8, !tbaa !322
  %tobool = icmp ne %struct.usb_phy* %0, null
  br i1 %tobool, label %if.end13, label %if.then

if.then:                                          ; preds = %entry
  %self = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %1 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !356
  %call = call %struct.usb_phy* @usb_get_phy_dev(%struct.device* %1, i8 zeroext 0)
  %2 = bitcast %struct.usb_phy* %call to i8*
  %call2 = call zeroext i1 @IS_ERR(i8* %2)
  br i1 %call2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.then
  %3 = bitcast %struct.usb_phy* %call to i8*
  %call4 = call i64 @PTR_ERR(i8* %3)
  %conv = trunc i64 %call4 to i32
  %cmp = icmp eq i32 %conv, -517
  br i1 %cmp, label %LeafBlock, label %if.end12

if.else:                                          ; preds = %if.then
  %call7 = call i32 @usb_phy_init(%struct.usb_phy* %call)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.else
  call void @usb_put_phy(%struct.usb_phy* %call)
  br label %LeafBlock

if.end10:                                         ; preds = %if.else
  %usb_phy11 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 9
  store %struct.usb_phy* %call, %struct.usb_phy** %usb_phy11, align 8, !tbaa !322
  %remove_phy = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load = load i16, i16* %remove_phy, align 8
  %bf.clear = and i16 %bf.load, -9
  %bf.set = or i16 %bf.clear, 8
  store i16 %bf.set, i16* %remove_phy, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.end10, %if.then3
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end12, %if.then9, %if.then3
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end12 ], [ 1, %if.then9 ], [ 1, %if.then3 ]
  %retval.0 = phi i32 [ undef, %if.end12 ], [ %call7, %if.then9 ], [ %conv, %if.then3 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end13, label %cleanup266

if.end13:                                         ; preds = %LeafBlock, %entry
  %retval.1 = phi i32 [ undef, %entry ], [ %retval.0, %LeafBlock ]
  %phy14 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 10
  %4 = load %struct.phy*, %struct.phy** %phy14, align 8, !tbaa !359
  %tobool15 = icmp ne %struct.phy* %4, null
  br i1 %tobool15, label %if.end48, label %if.then16

if.then16:                                        ; preds = %if.end13
  %self18 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller19 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self18, i32 0, i32 0
  %5 = load %struct.device*, %struct.device** %controller19, align 8, !tbaa !356
  %call20 = call %struct.phy* @phy_get(%struct.device* %5, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18.951, i32 0, i32 0))
  %6 = bitcast %struct.phy* %call20 to i8*
  %call21 = call zeroext i1 @IS_ERR(i8* %6)
  br i1 %call21, label %if.then22, label %if.else29

if.then22:                                        ; preds = %if.then16
  %7 = bitcast %struct.phy* %call20 to i8*
  %call23 = call i64 @PTR_ERR(i8* %7)
  %conv24 = trunc i64 %call23 to i32
  %cmp25 = icmp eq i32 %conv24, -517
  br i1 %cmp25, label %NodeBlock, label %if.end44

if.else29:                                        ; preds = %if.then16
  %call30 = call i32 @phy_init(%struct.phy* %call20)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.else29
  call void @phy_put(%struct.phy* %call20)
  br label %NodeBlock

if.end33:                                         ; preds = %if.else29
  %call34 = call i32 @phy_power_on(%struct.phy* %call20)
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %if.then36, label %if.end38

if.then36:                                        ; preds = %if.end33
  %call37 = call i32 @phy_exit(%struct.phy* %call20)
  call void @phy_put(%struct.phy* %call20)
  br label %NodeBlock

if.end38:                                         ; preds = %if.end33
  %phy39 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 10
  store %struct.phy* %call20, %struct.phy** %phy39, align 8, !tbaa !359
  %remove_phy40 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load41 = load i16, i16* %remove_phy40, align 8
  %bf.clear42 = and i16 %bf.load41, -9
  %bf.set43 = or i16 %bf.clear42, 8
  store i16 %bf.set43, i16* %remove_phy40, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.end38, %if.then22
  %retval1.0 = phi i32 [ %call34, %if.end38 ], [ %conv24, %if.then22 ]
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end44, %if.then36, %if.then32, %if.then22
  %retval1.1 = phi i32 [ %retval1.0, %if.end44 ], [ %call30, %if.then32 ], [ %call34, %if.then36 ], [ %conv24, %if.then22 ]
  %cleanup.dest.slot.1 = phi i32 [ 0, %if.end44 ], [ 2, %if.then32 ], [ 2, %if.then36 ], [ 2, %if.then22 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.1, 2
  br i1 %Pivot, label %LeafBlock2, label %LeafBlock4

LeafBlock4:                                       ; preds = %NodeBlock
  %SwitchLeaf5 = icmp eq i32 %cleanup.dest.slot.1, 2
  br i1 %SwitchLeaf5, label %err_phy, label %cleanup266

LeafBlock2:                                       ; preds = %NodeBlock
  %SwitchLeaf3 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf3, label %if.end48, label %cleanup266

if.end48:                                         ; preds = %LeafBlock2, %if.end13
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %8 = load i32, i32* @authorized_default, align 4, !tbaa !73
  %cmp51 = icmp slt i32 %8, 0
  %9 = load i32, i32* @authorized_default, align 4
  %cmp53 = icmp sgt i32 %9, 1
  %or.cond = or i1 %cmp51, %cmp53
  br i1 %or.cond, label %if.then55, label %if.else63

if.then55:                                        ; preds = %if.end48
  %wireless = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load56 = load i16, i16* %wireless, align 8
  %bf.lshr = lshr i16 %bf.load56, 5
  %bf.clear57 = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear57 to i32
  %tobool58 = icmp ne i32 %bf.cast, 0
  %flags = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  br i1 %tobool58, label %if.then59, label %if.else60

if.then59:                                        ; preds = %if.then55
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags, i64 8, i64* %flags) #8, !srcloc !354
  br label %if.end70

if.else60:                                        ; preds = %if.then55
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags, i64 8, i64* %flags) #8, !srcloc !362
  br label %if.end70

if.else63:                                        ; preds = %if.end48
  %10 = load i32, i32* @authorized_default, align 4, !tbaa !73
  %tobool64 = icmp ne i32 %10, 0
  %flags66 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  br i1 %tobool64, label %if.then65, label %if.else67

if.then65:                                        ; preds = %if.else63
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags66, i64 8, i64* %flags66) #8, !srcloc !362
  br label %if.end70

if.else67:                                        ; preds = %if.else63
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags66, i64 8, i64* %flags66) #8, !srcloc !354
  br label %if.end70

if.end70:                                         ; preds = %if.else67, %if.then65, %if.else60, %if.then59
  %flags71 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags71, i64 0, i64* %flags71) #8, !srcloc !362
  %flags72 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags72, i64 7, i64* %flags72) #8, !srcloc !362
  %call73 = call i32 bitcast (i32 (%struct.usb_hcd.2781*)* @hcd_buffer_create to i32 (%struct.usb_hcd.712*)*)(%struct.usb_hcd.712* %hcd)
  %cmp74 = icmp ne i32 %call73, 0
  br i1 %cmp74, label %do.body77, label %if.end91

do.body77:                                        ; preds = %if.end70
  %bf.load78 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_add_hcd.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr79 = lshr i32 %bf.load78, 18
  %bf.clear80 = and i32 %bf.lshr79, 255
  %and = and i32 %bf.clear80, 1
  %tobool81 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool81, true
  %lnot82 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot82 to i32
  %conv83 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv83, i64 0)
  %tobool84 = icmp ne i64 %expval, 0
  br i1 %tobool84, label %if.then85, label %err_create_buf

if.then85:                                        ; preds = %do.body77
  %self86 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller87 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self86, i32 0, i32 0
  %11 = load %struct.device*, %struct.device** %controller87, align 8, !tbaa !356
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_add_hcd.descriptor to %struct._ddebug*), %struct.device* %11, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.42.65, i32 0, i32 0))
  br label %err_create_buf

if.end91:                                         ; preds = %if.end70
  %self92 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %call93 = call i32 @usb_register_bus(%struct.usb_bus* %self92)
  %cmp94 = icmp slt i32 %call93, 0
  br i1 %cmp94, label %err_register_bus, label %if.end97

if.end97:                                         ; preds = %if.end91
  %self98 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %call99 = call %struct.usb_device* @usb_alloc_dev(%struct.usb_device* null, %struct.usb_bus* %self98, i32 0)
  store %struct.usb_device* %call99, %struct.usb_device** %rhdev, align 8, !tbaa !52
  %12 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !52
  %cmp100 = icmp eq %struct.usb_device* %12, null
  br i1 %cmp100, label %if.then102, label %if.end105

if.then102:                                       ; preds = %if.end97
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %err_allocate_root_hub

if.end105:                                        ; preds = %if.end97
  call void @mutex_lock_nested(%struct.mutex* @usb_port_peer_mutex, i32 0)
  %13 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !52
  %self106 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self106, i32 0, i32 11
  store %struct.usb_device* %13, %struct.usb_device** %root_hub, align 8, !tbaa !175
  call void @mutex_unlock(%struct.mutex* @usb_port_peer_mutex)
  %speed = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 3
  %14 = load i32, i32* %speed, align 8, !tbaa !363
  %Pivot24 = icmp slt i32 %14, 48
  br i1 %Pivot24, label %NodeBlock11, label %NodeBlock21

NodeBlock21:                                      ; preds = %if.end105
  %Pivot22 = icmp slt i32 %14, 64
  br i1 %Pivot22, label %LeafBlock13, label %NodeBlock19

NodeBlock19:                                      ; preds = %NodeBlock21
  %Pivot20 = icmp slt i32 %14, 80
  br i1 %Pivot20, label %LeafBlock15, label %LeafBlock17

LeafBlock17:                                      ; preds = %NodeBlock19
  %SwitchLeaf18 = icmp eq i32 %14, 80
  br i1 %SwitchLeaf18, label %sw.bb114, label %err_set_rh_speed

LeafBlock15:                                      ; preds = %NodeBlock19
  %SwitchLeaf16 = icmp eq i32 %14, 64
  br i1 %SwitchLeaf16, label %sw.bb112, label %err_set_rh_speed

LeafBlock13:                                      ; preds = %NodeBlock21
  %SwitchLeaf14 = icmp eq i32 %14, 48
  br i1 %SwitchLeaf14, label %sw.bb110, label %err_set_rh_speed

NodeBlock11:                                      ; preds = %if.end105
  %Pivot12 = icmp slt i32 %14, 32
  br i1 %Pivot12, label %LeafBlock7, label %LeafBlock9

LeafBlock9:                                       ; preds = %NodeBlock11
  %SwitchLeaf10 = icmp eq i32 %14, 32
  br i1 %SwitchLeaf10, label %sw.bb108, label %err_set_rh_speed

LeafBlock7:                                       ; preds = %NodeBlock11
  %SwitchLeaf8 = icmp eq i32 %14, 16
  br i1 %SwitchLeaf8, label %sw.bb, label %err_set_rh_speed

sw.bb:                                            ; preds = %LeafBlock7
  %15 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !52
  br label %sw.epilog

sw.bb108:                                         ; preds = %LeafBlock9
  %16 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !52
  br label %sw.epilog

sw.bb110:                                         ; preds = %LeafBlock13
  %17 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !52
  br label %sw.epilog

sw.bb112:                                         ; preds = %LeafBlock15
  %18 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !52
  br label %sw.epilog

sw.bb114:                                         ; preds = %LeafBlock17
  %19 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !52
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb114, %sw.bb112, %sw.bb110, %sw.bb108, %sw.bb
  %.sink25 = phi %struct.usb_device* [ %19, %sw.bb114 ], [ %18, %sw.bb112 ], [ %17, %sw.bb110 ], [ %16, %sw.bb108 ], [ %15, %sw.bb ]
  %.sink = phi i32 [ 6, %sw.bb114 ], [ 5, %sw.bb112 ], [ 4, %sw.bb110 ], [ 3, %sw.bb108 ], [ 2, %sw.bb ]
  %speed115 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %.sink25, i32 0, i32 4
  store i32 %.sink, i32* %speed115, align 4, !tbaa !177
  %20 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !52
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %20, i32 0, i32 11
  call void @device_set_wakeup_capable(%struct.device* %dev, i1 zeroext true)
  %flags116 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags116, i64 5, i64* %flags116) #8, !srcloc !362
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %21 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %reset = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %21, i32 0, i32 5
  %22 = load i32 (%struct.usb_hcd.712*)*, i32 (%struct.usb_hcd.712*)** %reset, align 8, !tbaa !364
  %tobool117 = icmp ne i32 (%struct.usb_hcd.712*)* %22, null
  br i1 %tobool117, label %if.then118, label %if.end128

if.then118:                                       ; preds = %sw.epilog
  %driver119 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %23 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver119, align 8, !tbaa !57
  %reset120 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %23, i32 0, i32 5
  %24 = load i32 (%struct.usb_hcd.712*)*, i32 (%struct.usb_hcd.712*)** %reset120, align 8, !tbaa !364
  %call121 = call i32 %24(%struct.usb_hcd.712* %hcd)
  %cmp122 = icmp slt i32 %call121, 0
  br i1 %cmp122, label %if.then124, label %if.end128

if.then124:                                       ; preds = %if.then118
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %err_set_rh_speed

if.end128:                                        ; preds = %if.then118, %sw.epilog
  %rh_pollable = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load129 = load i16, i16* %rh_pollable, align 8
  %bf.clear130 = and i16 %bf.load129, -3
  %bf.set131 = or i16 %bf.clear130, 2
  store i16 %bf.set131, i16* %rh_pollable, align 8
  %self132 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller133 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self132, i32 0, i32 0
  %25 = load %struct.device*, %struct.device** %controller133, align 8, !tbaa !356
  %call134 = call zeroext i1 @device_can_wakeup(%struct.device* %25)
  br i1 %call134, label %land.lhs.true, label %if.end164

land.lhs.true:                                    ; preds = %if.end128
  %self136 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %root_hub137 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self136, i32 0, i32 11
  %26 = load %struct.usb_device*, %struct.usb_device** %root_hub137, align 8, !tbaa !175
  %dev138 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %26, i32 0, i32 11
  %call139 = call zeroext i1 @device_can_wakeup(%struct.device* %dev138)
  br i1 %call139, label %do.body143, label %if.end164

do.body143:                                       ; preds = %land.lhs.true
  %bf.load144 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_add_hcd.descriptor.45 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr145 = lshr i32 %bf.load144, 18
  %bf.clear146 = and i32 %bf.lshr145, 255
  %and147 = and i32 %bf.clear146, 1
  %tobool148 = icmp ne i32 %and147, 0
  %lnot149 = xor i1 %tobool148, true
  %lnot151 = xor i1 %lnot149, true
  %lnot.ext152 = zext i1 %lnot151 to i32
  %conv153 = sext i32 %lnot.ext152 to i64
  %expval154 = call i64 @llvm.expect.i64(i64 %conv153, i64 0)
  %tobool155 = icmp ne i64 %expval154, 0
  br i1 %tobool155, label %if.then156, label %if.end164

if.then156:                                       ; preds = %do.body143
  %self157 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller158 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self157, i32 0, i32 0
  %27 = load %struct.device*, %struct.device** %controller158, align 8, !tbaa !356
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_add_hcd.descriptor.45 to %struct._ddebug*), %struct.device* %27, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.46, i32 0, i32 0))
  br label %if.end164

if.end164:                                        ; preds = %if.then156, %do.body143, %land.lhs.true, %if.end128
  %high_prio_bh = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 18
  call void @init_giveback_urb_bh(%struct.giveback_urb_bh* %high_prio_bh)
  %low_prio_bh = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 19
  call void @init_giveback_urb_bh(%struct.giveback_urb_bh* %low_prio_bh)
  %call165 = call i32 @usb_hcd_is_primary_hcd(%struct.usb_hcd.712* %hcd)
  %tobool166 = icmp ne i32 %call165, 0
  %tobool168 = icmp ne i32 %irqnum, 0
  %or.cond26 = and i1 %tobool166, %tobool168
  br i1 %or.cond26, label %if.then169, label %if.end174

if.then169:                                       ; preds = %if.end164
  %call170 = call i32 @usb_hcd_request_irqs(%struct.usb_hcd.712* %hcd, i32 %irqnum, i64 %irqflags)
  %tobool171 = icmp ne i32 %call170, 0
  br i1 %tobool171, label %err_set_rh_speed, label %if.end174

if.end174:                                        ; preds = %if.then169, %if.end164
  %state = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 25
  store i32 1, i32* %state, align 8, !tbaa !355
  %driver175 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %28 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver175, align 8, !tbaa !57
  %start = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %28, i32 0, i32 6
  %29 = load i32 (%struct.usb_hcd.712*)*, i32 (%struct.usb_hcd.712*)** %start, align 8, !tbaa !365
  %call176 = call i32 %29(%struct.usb_hcd.712* %hcd)
  %cmp177 = icmp slt i32 %call176, 0
  br i1 %cmp177, label %if.then179, label %if.end182

if.then179:                                       ; preds = %if.end174
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %err_hcd_driver_start

if.end182:                                        ; preds = %if.end174
  %call183 = call i32 @register_root_hub(%struct.usb_hcd.712* %hcd)
  %cmp184 = icmp ne i32 %call183, 0
  br i1 %cmp184, label %err_register_root_hub, label %if.end187

if.end187:                                        ; preds = %if.end182
  %30 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !52
  %dev188 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %30, i32 0, i32 11
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev188, i32 0, i32 2
  %call189 = call i32 @sysfs_create_group(%struct.kobject* %kobj, %struct.attribute_group* @usb_bus_attr_group)
  %cmp190 = icmp slt i32 %call189, 0
  br i1 %cmp190, label %if.then192, label %if.end194

if.then192:                                       ; preds = %if.end187
  %31 = call i32 (i8*, ...) @printk(i8* null)
  %flags206 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags206, i64 5, i64* %flags206) #8, !srcloc !354
  %state207 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 25
  %32 = load i32, i32* %state207, align 8, !tbaa !355
  %and208 = and i32 %32, 1
  %tobool209 = icmp ne i32 %and208, 0
  br i1 %tobool209, label %if.then210, label %if.end212

if.end194:                                        ; preds = %if.end187
  %uses_new_polling = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load195 = load i16, i16* %uses_new_polling, align 8
  %bf.lshr196 = lshr i16 %bf.load195, 4
  %bf.clear197 = and i16 %bf.lshr196, 1
  %bf.cast198 = zext i16 %bf.clear197 to i32
  %tobool199 = icmp ne i32 %bf.cast198, 0
  br i1 %tobool199, label %land.lhs.true200, label %cleanup266

land.lhs.true200:                                 ; preds = %if.end194
  %flags201 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  %33 = load i64, i64* %flags201, align 8, !tbaa !84
  %and202 = and i64 %33, 4
  %tobool203 = icmp ne i64 %and202, 0
  br i1 %tobool203, label %if.then204, label %cleanup266

if.then204:                                       ; preds = %land.lhs.true200
  call void @usb_hcd_poll_rh_status(%struct.usb_hcd.712* %hcd)
  br label %cleanup266

if.then210:                                       ; preds = %if.then192
  %state211 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 25
  store i32 133, i32* %state211, align 8, !tbaa !355
  br label %if.end212

if.end212:                                        ; preds = %if.then210, %if.then192
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0)) #8
  %rh_registered = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load213 = load i16, i16* %rh_registered, align 8
  %bf.clear214 = and i16 %bf.load213, -2
  store i16 %bf.clear214, i16* %rh_registered, align 8
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0)) #8
  %wakeup_work = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 7
  %call215 = call zeroext i1 @cancel_work_sync(%struct.work_struct* %wakeup_work)
  call void @mutex_lock_nested(%struct.mutex* @usb_bus_idr_lock, i32 0)
  call void @usb_disconnect(%struct.usb_device** %rhdev)
  call void @mutex_unlock(%struct.mutex* @usb_bus_idr_lock)
  br label %err_register_root_hub

err_register_root_hub:                            ; preds = %if.end212, %if.end182
  %retval1.2 = phi i32 [ %call189, %if.end212 ], [ %call183, %if.end182 ]
  %rh_pollable216 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load217 = load i16, i16* %rh_pollable216, align 8
  %bf.clear218 = and i16 %bf.load217, -3
  store i16 %bf.clear218, i16* %rh_pollable216, align 8
  %flags219 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags219, i64 2, i64* %flags219) #8, !srcloc !354
  %rh_timer = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 5
  %call220 = call i32 @del_timer_sync(%struct.timer_list* %rh_timer)
  %driver221 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %34 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver221, align 8, !tbaa !57
  %stop = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %34, i32 0, i32 9
  %stop222 = bitcast {}** %stop to void (%struct.usb_hcd.712*)**
  %35 = load void (%struct.usb_hcd.712*)*, void (%struct.usb_hcd.712*)** %stop222, align 8, !tbaa !357
  call void %35(%struct.usb_hcd.712* %hcd)
  %state223 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 25
  store i32 0, i32* %state223, align 8, !tbaa !355
  %flags224 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags224, i64 2, i64* %flags224) #8, !srcloc !354
  %rh_timer225 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 5
  %call226 = call i32 @del_timer_sync(%struct.timer_list* %rh_timer225)
  br label %err_hcd_driver_start

err_hcd_driver_start:                             ; preds = %err_register_root_hub, %if.then179
  %retval1.3 = phi i32 [ %call176, %if.then179 ], [ %retval1.2, %err_register_root_hub ]
  %call227 = call i32 @usb_hcd_is_primary_hcd(%struct.usb_hcd.712* %hcd)
  %tobool228 = icmp ne i32 %call227, 0
  br i1 %tobool228, label %land.lhs.true229, label %err_set_rh_speed

land.lhs.true229:                                 ; preds = %err_hcd_driver_start
  %irq = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 13
  %36 = load i32, i32* %irq, align 4, !tbaa !358
  %cmp230 = icmp ugt i32 %36, 0
  br i1 %cmp230, label %if.then232, label %err_set_rh_speed

if.then232:                                       ; preds = %land.lhs.true229
  %37 = bitcast %struct.usb_hcd.712* %hcd to i8*
  call void @free_irq(i32 %irqnum, i8* %37)
  br label %err_set_rh_speed

err_set_rh_speed:                                 ; preds = %if.then232, %land.lhs.true229, %err_hcd_driver_start, %if.then169, %if.then124, %LeafBlock7, %LeafBlock9, %LeafBlock13, %LeafBlock15, %LeafBlock17
  %retval1.6 = phi i32 [ -22, %LeafBlock7 ], [ -22, %LeafBlock9 ], [ -22, %LeafBlock13 ], [ -22, %LeafBlock15 ], [ -22, %LeafBlock17 ], [ %call121, %if.then124 ], [ %call170, %if.then169 ], [ %retval1.3, %if.then232 ], [ %retval1.3, %land.lhs.true229 ], [ %retval1.3, %err_hcd_driver_start ]
  call void @usb_put_invalidate_rhdev(%struct.usb_hcd.712* %hcd)
  br label %err_allocate_root_hub

err_allocate_root_hub:                            ; preds = %err_set_rh_speed, %if.then102
  %retval1.7 = phi i32 [ -12, %if.then102 ], [ %retval1.6, %err_set_rh_speed ]
  %self234 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  call void @usb_deregister_bus(%struct.usb_bus* %self234)
  br label %err_register_bus

err_register_bus:                                 ; preds = %err_allocate_root_hub, %if.end91
  %retval1.8 = phi i32 [ %retval1.7, %err_allocate_root_hub ], [ %call93, %if.end91 ]
  call void bitcast (void (%struct.usb_hcd.2781*)* @hcd_buffer_destroy to void (%struct.usb_hcd.712*)*)(%struct.usb_hcd.712* %hcd)
  br label %err_create_buf

err_create_buf:                                   ; preds = %err_register_bus, %if.then85, %do.body77
  %retval1.9 = phi i32 [ %retval1.8, %err_register_bus ], [ %call73, %if.then85 ], [ %call73, %do.body77 ]
  %remove_phy235 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load236 = load i16, i16* %remove_phy235, align 8
  %bf.lshr237 = lshr i16 %bf.load236, 3
  %bf.clear238 = and i16 %bf.lshr237, 1
  %bf.cast239 = zext i16 %bf.clear238 to i32
  %tobool240 = icmp ne i32 %bf.cast239, 0
  br i1 %tobool240, label %land.lhs.true241, label %err_phy

land.lhs.true241:                                 ; preds = %err_create_buf
  %phy242 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 10
  %38 = load %struct.phy*, %struct.phy** %phy242, align 8, !tbaa !359
  %tobool243 = icmp ne %struct.phy* %38, null
  br i1 %tobool243, label %if.then244, label %err_phy

if.then244:                                       ; preds = %land.lhs.true241
  %phy245 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 10
  %39 = load %struct.phy*, %struct.phy** %phy245, align 8, !tbaa !359
  %call246 = call i32 @phy_power_off(%struct.phy* %39)
  %phy247 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 10
  %40 = load %struct.phy*, %struct.phy** %phy247, align 8, !tbaa !359
  %call248 = call i32 @phy_exit(%struct.phy* %40)
  %phy249 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 10
  %41 = load %struct.phy*, %struct.phy** %phy249, align 8, !tbaa !359
  call void @phy_put(%struct.phy* %41)
  %phy250 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 10
  store %struct.phy* null, %struct.phy** %phy250, align 8, !tbaa !359
  br label %err_phy

err_phy:                                          ; preds = %if.then244, %land.lhs.true241, %err_create_buf, %LeafBlock4
  %retval1.10 = phi i32 [ %retval1.1, %LeafBlock4 ], [ %retval1.9, %if.then244 ], [ %retval1.9, %land.lhs.true241 ], [ %retval1.9, %err_create_buf ]
  %remove_phy252 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load253 = load i16, i16* %remove_phy252, align 8
  %bf.lshr254 = lshr i16 %bf.load253, 3
  %bf.clear255 = and i16 %bf.lshr254, 1
  %bf.cast256 = zext i16 %bf.clear255 to i32
  %tobool257 = icmp ne i32 %bf.cast256, 0
  br i1 %tobool257, label %land.lhs.true258, label %cleanup266

land.lhs.true258:                                 ; preds = %err_phy
  %usb_phy259 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 9
  %42 = load %struct.usb_phy*, %struct.usb_phy** %usb_phy259, align 8, !tbaa !322
  %tobool260 = icmp ne %struct.usb_phy* %42, null
  br i1 %tobool260, label %if.then261, label %cleanup266

if.then261:                                       ; preds = %land.lhs.true258
  %usb_phy262 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 9
  %43 = load %struct.usb_phy*, %struct.usb_phy** %usb_phy262, align 8, !tbaa !322
  call void @usb_phy_shutdown(%struct.usb_phy* %43)
  %usb_phy263 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 9
  %44 = load %struct.usb_phy*, %struct.usb_phy** %usb_phy263, align 8, !tbaa !322
  call void @usb_put_phy(%struct.usb_phy* %44)
  %usb_phy264 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 9
  store %struct.usb_phy* null, %struct.usb_phy** %usb_phy264, align 8, !tbaa !322
  br label %cleanup266

cleanup266:                                       ; preds = %if.then261, %land.lhs.true258, %err_phy, %if.then204, %land.lhs.true200, %if.end194, %LeafBlock2, %LeafBlock4, %LeafBlock
  %retval.2 = phi i32 [ %call189, %if.then204 ], [ %call189, %land.lhs.true200 ], [ %call189, %if.end194 ], [ %retval1.10, %if.then261 ], [ %retval1.10, %land.lhs.true258 ], [ %retval1.10, %err_phy ], [ %retval.0, %LeafBlock ], [ %retval.1, %LeafBlock4 ], [ %retval.1, %LeafBlock2 ]
  ret i32 %retval.2
}

declare %struct.usb_phy* @usb_get_phy_dev(%struct.device*, i8 zeroext) #2

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR(i8* %ptr) #1 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  ret i1 %tobool
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #1 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_phy_init(%struct.usb_phy* %x) #1 {
entry:
  %tobool = icmp ne %struct.usb_phy* %x, null
  br i1 %tobool, label %land.lhs.true, label %return

land.lhs.true:                                    ; preds = %entry
  %init = getelementptr inbounds %struct.usb_phy, %struct.usb_phy* %x, i32 0, i32 13
  %0 = load i32 (%struct.usb_phy*)*, i32 (%struct.usb_phy*)** %init, align 8, !tbaa !366
  %tobool1 = icmp ne i32 (%struct.usb_phy*)* %0, null
  br i1 %tobool1, label %if.then, label %return

if.then:                                          ; preds = %land.lhs.true
  %init2 = getelementptr inbounds %struct.usb_phy, %struct.usb_phy* %x, i32 0, i32 13
  %1 = load i32 (%struct.usb_phy*)*, i32 (%struct.usb_phy*)** %init2, align 8, !tbaa !366
  %call = call i32 %1(%struct.usb_phy* %x)
  br label %return

return:                                           ; preds = %if.then, %land.lhs.true, %entry
  %retval.0 = phi i32 [ %call, %if.then ], [ 0, %land.lhs.true ], [ 0, %entry ]
  ret i32 %retval.0
}

declare %struct.phy* @phy_get(%struct.device*, i8*) #2

declare i32 @phy_init(%struct.phy*) #2

declare i32 @phy_power_on(%struct.phy*) #2

; Function Attrs: nounwind uwtable
define internal i32 @usb_register_bus(%struct.usb_bus* %bus) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @usb_bus_idr_lock, i32 0)
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %call = call i32 @idr_alloc(%struct.idr* @usb_bus_idr, i8* %0, i32 1, i32 64, i32 20971712)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  call void @mutex_unlock(%struct.mutex* @usb_bus_idr_lock)
  br label %cleanup

if.end:                                           ; preds = %entry
  %busnum2 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 1
  store i32 %call, i32* %busnum2, align 8, !tbaa !41
  call void @mutex_unlock(%struct.mutex* @usb_bus_idr_lock)
  call void @usb_notify_add_bus(%struct.usb_bus* %bus)
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ -7, %if.then ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @device_can_wakeup(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %can_wakeup = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i16, i16* %can_wakeup, align 4
  %bf.clear = and i16 %bf.load, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal void @init_giveback_urb_bh(%struct.giveback_urb_bh* %bh) #0 {
entry:
  %lock2 = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %bh, i32 0, i32 1
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock2, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.69.92, i32 0, i32 0), %struct.lock_class_key* @init_giveback_urb_bh.__key)
  %head = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %bh, i32 0, i32 2
  call void @INIT_LIST_HEAD.80(%struct.list_head* %head)
  %bh4 = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %bh, i32 0, i32 3
  %1 = ptrtoint %struct.giveback_urb_bh* %bh to i64
  call void @tasklet_init(%struct.tasklet_struct* %bh4, void (i64)* @usb_giveback_urb_bh, i64 %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_hcd_request_irqs(%struct.usb_hcd.712* %hcd, i32 %irqnum, i64 %irqflags) #0 {
entry:
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %0 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %irq = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %0, i32 0, i32 3
  %1 = load i32 (%struct.usb_hcd.712*)*, i32 (%struct.usb_hcd.712*)** %irq, align 8, !tbaa !367
  %tobool = icmp ne i32 (%struct.usb_hcd.712*)* %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %irq_descr = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 4
  %arraydecay = getelementptr inbounds [24 x i8], [24 x i8]* %irq_descr, i32 0, i32 0
  %driver2 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %2 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver2, align 8, !tbaa !57
  %description = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %2, i32 0, i32 0
  %3 = load i8*, i8** %description, align 8, !tbaa !368
  %self = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %busnum = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 1
  %4 = load i32, i32* %busnum, align 8, !tbaa !369
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 24, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.70.89, i32 0, i32 0), i8* %3, i32 %4)
  %irq_descr3 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 4
  %arraydecay4 = getelementptr inbounds [24 x i8], [24 x i8]* %irq_descr3, i32 0, i32 0
  %5 = bitcast %struct.usb_hcd.712* %hcd to i8*
  %call5 = call i32 @request_irq(i32 %irqnum, i32 (i32, i8*)* @usb_hcd_irq, i64 %irqflags, i8* %arraydecay4, i8* %5)
  %cmp = icmp ne i32 %call5, 0
  br i1 %cmp, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end:                                           ; preds = %if.then
  %irq8 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 13
  store i32 %irqnum, i32* %irq8, align 4, !tbaa !358
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

if.else:                                          ; preds = %entry
  %irq13 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 13
  store i32 0, i32* %irq13, align 4, !tbaa !358
  %rsrc_start14 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 15
  %6 = load i64, i64* %rsrc_start14, align 8, !tbaa !370
  %tobool15 = icmp ne i64 %6, 0
  br i1 %tobool15, label %if.then16, label %cleanup

if.then16:                                        ; preds = %if.else
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then16, %if.else, %if.end, %if.then6
  %retval.0 = phi i32 [ %call5, %if.then6 ], [ 0, %if.else ], [ 0, %if.then16 ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @register_root_hub(%struct.usb_hcd.712* %hcd) #0 {
entry:
  %self = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !356
  %self1 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self1, i32 0, i32 11
  %1 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !175
  %devnum3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 0
  store i32 1, i32* %devnum3, align 8, !tbaa !44
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %devnum_next = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %2, i32 0, i32 8
  store i32 2, i32* %devnum_next, align 8, !tbaa !329
  %bus4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %3 = load %struct.usb_bus*, %struct.usb_bus** %bus4, align 8, !tbaa !2
  %devmap = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %3, i32 0, i32 10
  %devicemap = getelementptr inbounds %struct.usb_devmap, %struct.usb_devmap* %devmap, i32 0, i32 0
  %4 = bitcast [2 x i64]* %devicemap to i8*
  %call = call i8* @__memset(i8* %4, i32 0, i64 16)
  %bus5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %5 = load %struct.usb_bus*, %struct.usb_bus** %bus5, align 8, !tbaa !2
  %devmap6 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %5, i32 0, i32 10
  %devicemap7 = getelementptr inbounds %struct.usb_devmap, %struct.usb_devmap* %devmap6, i32 0, i32 0
  %arraydecay = getelementptr inbounds [2 x i64], [2 x i64]* %devicemap7, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i64 1, i64* %arraydecay) #8, !srcloc !362
  call void @usb_set_device_state(%struct.usb_device* %1, i32 6)
  call void @mutex_lock_nested(%struct.mutex* @usb_bus_idr_lock, i32 0)
  %ep0 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 10
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep0, i32 0, i32 0
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc, i32 0, i32 4
  store i16 64, i16* %wMaxPacketSize, align 4, !tbaa !180
  %call8 = call i32 @usb_get_device_descriptor(%struct.usb_device* %1, i32 18)
  %conv = sext i32 %call8 to i64
  %cmp = icmp ne i64 %conv, 18
  br i1 %cmp, label %if.then, label %if.end20

if.then:                                          ; preds = %entry
  call void @mutex_unlock(%struct.mutex* @usb_bus_idr_lock)
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @register_root_hub.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv12 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv12, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  br i1 %tobool13, label %if.then14, label %do.end17

if.then14:                                        ; preds = %if.then
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call15 = call i8* @dev_name.83(%struct.device* %dev)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @register_root_hub.descriptor to %struct._ddebug*), %struct.device* %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.76.84, i32 0, i32 0), i8* %call15, i32 %call8)
  br label %do.end17

do.end17:                                         ; preds = %if.then14, %if.then
  %cmp18 = icmp slt i32 %call8, 0
  %call8. = select i1 %cmp18, i32 %call8, i32 -90
  br label %cleanup

if.end20:                                         ; preds = %entry
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 12
  %bcdUSB = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 2
  %6 = load i16, i16* %bcdUSB, align 2, !tbaa !187
  %conv21 = zext i16 %6 to i32
  %cmp22 = icmp sge i32 %conv21, 513
  br i1 %cmp22, label %if.then24, label %if.end58

if.then24:                                        ; preds = %if.end20
  %call25 = call i32 @usb_get_bos_descriptor(%struct.usb_device* %1)
  %tobool26 = icmp ne i32 %call25, 0
  br i1 %tobool26, label %if.else, label %if.then27

if.then27:                                        ; preds = %if.then24
  %call28 = call i32 @usb_device_supports_lpm(%struct.usb_device* %1)
  %lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 22
  %7 = trunc i32 %call28 to i16
  %bf.load29 = load i16, i16* %lpm_capable, align 4
  %bf.value = and i16 %7, 1
  %bf.shl = shl i16 %bf.value, 6
  %bf.clear30 = and i16 %bf.load29, -65
  %bf.set = or i16 %bf.clear30, %bf.shl
  store i16 %bf.set, i16* %lpm_capable, align 4
  br label %if.end58

if.else:                                          ; preds = %if.then24
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 4
  %8 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp31 = icmp uge i32 %8, 5
  br i1 %cmp31, label %if.then33, label %if.end58

if.then33:                                        ; preds = %if.else
  call void @mutex_unlock(%struct.mutex* @usb_bus_idr_lock)
  %bf.load36 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @register_root_hub.descriptor.77 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr37 = lshr i32 %bf.load36, 18
  %bf.clear38 = and i32 %bf.lshr37, 255
  %and39 = and i32 %bf.clear38, 1
  %tobool40 = icmp ne i32 %and39, 0
  %lnot41 = xor i1 %tobool40, true
  %lnot43 = xor i1 %lnot41, true
  %lnot.ext44 = zext i1 %lnot43 to i32
  %conv45 = sext i32 %lnot.ext44 to i64
  %expval46 = call i64 @llvm.expect.i64(i64 %conv45, i64 0)
  %tobool47 = icmp ne i64 %expval46, 0
  br i1 %tobool47, label %if.then48, label %cleanup

if.then48:                                        ; preds = %if.then33
  %dev49 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call50 = call i8* @dev_name.83(%struct.device* %dev49)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @register_root_hub.descriptor.77 to %struct._ddebug*), %struct.device* %0, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.78.85, i32 0, i32 0), i8* %call50, i32 %call25)
  br label %cleanup

if.end58:                                         ; preds = %if.else, %if.then27, %if.end20
  %call59 = call i32 @usb_new_device(%struct.usb_device* %1)
  %tobool60 = icmp ne i32 %call59, 0
  br i1 %tobool60, label %if.then61, label %if.else64

if.then61:                                        ; preds = %if.end58
  %dev62 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call63 = call i8* @dev_name.83(%struct.device* %dev62)
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end74

if.else64:                                        ; preds = %if.end58
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0)) #8
  %rh_registered = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load65 = load i16, i16* %rh_registered, align 8
  %bf.clear66 = and i16 %bf.load65, -2
  %bf.set67 = or i16 %bf.clear66, 1
  store i16 %bf.set67, i16* %rh_registered, align 8
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0)) #8
  %flags = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  %9 = load i64, i64* %flags, align 8, !tbaa !84
  %and68 = and i64 %9, 64
  %tobool69 = icmp ne i64 %and68, 0
  br i1 %tobool69, label %if.then70, label %if.end71

if.then70:                                        ; preds = %if.else64
  call void @usb_hc_died(%struct.usb_hcd.712* %hcd)
  br label %if.end71

if.end71:                                         ; preds = %if.then70, %if.else64
  %of_node = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 26
  %10 = load %struct.device_node*, %struct.device_node** %of_node, align 8, !tbaa !371
  %dev72 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %of_node73 = getelementptr inbounds %struct.device, %struct.device* %dev72, i32 0, i32 26
  store %struct.device_node* %10, %struct.device_node** %of_node73, align 8, !tbaa !80
  br label %if.end74

if.end74:                                         ; preds = %if.end71, %if.then61
  call void @mutex_unlock(%struct.mutex* @usb_bus_idr_lock)
  br label %cleanup

cleanup:                                          ; preds = %if.end74, %if.then48, %if.then33, %do.end17
  %retval.0 = phi i32 [ %call8., %do.end17 ], [ %call59, %if.end74 ], [ %call25, %if.then48 ], [ %call25, %if.then33 ]
  ret i32 %retval.0
}

declare i32 @sysfs_create_group(%struct.kobject*, %struct.attribute_group*) #2

; Function Attrs: nounwind uwtable
define void @usb_hcd_poll_rh_status(%struct.usb_hcd.712* %hcd) #0 {
entry:
  %buffer = alloca [6 x i8], align 1
  %rh_pollable = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load = load i16, i16* %rh_pollable, align 8
  %bf.lshr = lshr i16 %bf.load, 1
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %uses_new_polling = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load4 = load i16, i16* %uses_new_polling, align 8
  %bf.lshr5 = lshr i16 %bf.load4, 4
  %bf.clear6 = and i16 %bf.lshr5, 1
  %bf.cast7 = zext i16 %bf.clear6 to i32
  %tobool8 = icmp ne i32 %bf.cast7, 0
  br i1 %tobool8, label %if.end11, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %status_urb = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 6
  %0 = load %struct.urb*, %struct.urb** %status_urb, align 8, !tbaa !372
  %tobool9 = icmp ne %struct.urb* %0, null
  br i1 %tobool9, label %if.end11, label %cleanup

if.end11:                                         ; preds = %land.lhs.true, %if.end
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %1 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %hub_status_data = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %1, i32 0, i32 18
  %2 = load i32 (%struct.usb_hcd.712*, i8*)*, i32 (%struct.usb_hcd.712*, i8*)** %hub_status_data, align 8, !tbaa !373
  %arraydecay = getelementptr inbounds [6 x i8], [6 x i8]* %buffer, i32 0, i32 0
  %call = call i32 %2(%struct.usb_hcd.712* %hcd, i8* %arraydecay)
  %cmp = icmp sgt i32 %call, 0
  br i1 %cmp, label %do.body14, label %if.end31

do.body14:                                        ; preds = %if.end11
  %call18 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0))
  %status_urb21 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 6
  %3 = load %struct.urb*, %struct.urb** %status_urb21, align 8, !tbaa !372
  %tobool22 = icmp ne %struct.urb* %3, null
  %flags24 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  br i1 %tobool22, label %if.then23, label %if.else

if.then23:                                        ; preds = %do.body14
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags24, i64 3, i64* %flags24) #8, !srcloc !354
  %status_urb25 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 6
  store %struct.urb* null, %struct.urb** %status_urb25, align 8, !tbaa !372
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %3, i32 0, i32 20
  store i32 %call, i32* %actual_length, align 4, !tbaa !315
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %3, i32 0, i32 14
  %4 = load i8*, i8** %transfer_buffer, align 8, !tbaa !316
  %arraydecay26 = getelementptr inbounds [6 x i8], [6 x i8]* %buffer, i32 0, i32 0
  %conv27 = sext i32 %call to i64
  %call28 = call i8* @__memcpy(i8* %4, i8* %arraydecay26, i64 %conv27)
  call void @usb_hcd_unlink_urb_from_ep(%struct.usb_hcd.712* undef, %struct.urb* %3)
  call void @usb_hcd_giveback_urb(%struct.usb_hcd.712* %hcd, %struct.urb* %3, i32 0)
  br label %if.end30

if.else:                                          ; preds = %do.body14
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags24, i64 3, i64* %flags24) #8, !srcloc !362
  br label %if.end30

if.end30:                                         ; preds = %if.else, %if.then23
  %length.0 = phi i32 [ %call, %if.then23 ], [ 0, %if.else ]
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0), i64 %call18) #8
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.end11
  %length.1 = phi i32 [ %length.0, %if.end30 ], [ %call, %if.end11 ]
  %uses_new_polling32 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load33 = load i16, i16* %uses_new_polling32, align 8
  %bf.lshr34 = lshr i16 %bf.load33, 4
  %bf.clear35 = and i16 %bf.lshr34, 1
  %bf.cast36 = zext i16 %bf.clear35 to i32
  %tobool37 = icmp ne i32 %bf.cast36, 0
  br i1 %tobool37, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end31
  %flags38 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  %5 = load i64, i64* %flags38, align 8, !tbaa !84
  %and = and i64 %5, 4
  %tobool39 = icmp ne i64 %and, 0
  br i1 %tobool39, label %if.then47, label %cleanup

cond.false:                                       ; preds = %if.end31
  %cmp40 = icmp eq i32 %length.1, 0
  br i1 %cmp40, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %status_urb42 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 6
  %6 = load %struct.urb*, %struct.urb** %status_urb42, align 8, !tbaa !372
  %cmp43 = icmp ne %struct.urb* %6, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %7 = phi i1 [ false, %cond.false ], [ %cmp43, %land.rhs ]
  %land.ext = zext i1 %7 to i32
  %conv45 = sext i32 %land.ext to i64
  %tobool46 = icmp ne i64 %conv45, 0
  br i1 %tobool46, label %if.then47, label %cleanup

if.then47:                                        ; preds = %land.end, %cond.true
  %rh_timer = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 5
  %8 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  %div = udiv i64 %8, 62
  %add = add i64 %div, 1
  %mul = mul i64 %add, 62
  %call48 = call i32 @mod_timer(%struct.timer_list* %rh_timer, i64 %mul)
  br label %cleanup

cleanup:                                          ; preds = %if.then47, %land.end, %cond.true, %land.lhs.true, %entry
  ret void
}

declare i8* @__memcpy(i8*, i8*, i64) #2

; Function Attrs: nounwind uwtable
define void @usb_hcd_unlink_urb_from_ep(%struct.usb_hcd.712* %hcd, %struct.urb* %urb) #0 {
entry:
  call void @_raw_spin_lock(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_urb_list_lock, i32 0, i32 0, i32 0)) #8
  %urb_list = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 5
  call void @list_del_init(%struct.list_head* %urb_list)
  call void @_raw_spin_unlock(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_urb_list_lock, i32 0, i32 0, i32 0)) #8
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_giveback_urb(%struct.usb_hcd.712* %hcd, %struct.urb* %urb, i32 %status) #0 {
entry:
  %unlinked = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 4
  %0 = load i32, i32* %unlinked, align 8, !tbaa !374
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %unlinked4 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 4
  store i32 %status, i32* %unlinked4, align 8, !tbaa !374
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call = call i32 @hcd_giveback_urb_in_bh(%struct.usb_hcd.712* %hcd)
  %tobool5 = icmp ne i32 %call, 0
  br i1 %tobool5, label %if.end9, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !242
  %call6 = call i32 @is_root_hub(%struct.usb_device* %1)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %land.lhs.true
  call void @__usb_hcd_giveback_urb(%struct.urb* %urb)
  br label %cleanup.cont

if.end9:                                          ; preds = %land.lhs.true, %if.end
  %pipe = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 10
  %2 = load i32, i32* %pipe, align 8, !tbaa !244
  %shr = lshr i32 %2, 30
  %and = and i32 %shr, 3
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end9
  %pipe11 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 10
  %3 = load i32, i32* %pipe11, align 8, !tbaa !244
  %shr12 = lshr i32 %3, 30
  %and13 = and i32 %shr12, 3
  %cmp14 = icmp eq i32 %and13, 1
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %lor.lhs.false, %if.end9
  %high_prio_bh17 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 18
  br label %if.end18

if.else:                                          ; preds = %lor.lhs.false
  %low_prio_bh = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 19
  br label %if.end18

if.end18:                                         ; preds = %if.else, %if.then16
  %bh.0 = phi %struct.giveback_urb_bh* [ %high_prio_bh17, %if.then16 ], [ %low_prio_bh, %if.else ]
  %high_prio_bh.0 = phi i8 [ 1, %if.then16 ], [ 0, %if.else ]
  %lock = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %bh.0, i32 0, i32 1
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock.i) #8
  %urb_list = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 5
  %head = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %bh.0, i32 0, i32 2
  call void @list_add_tail.72(%struct.list_head* %urb_list, %struct.list_head* %head)
  %running19 = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %bh.0, i32 0, i32 0
  %5 = load i8, i8* %running19, align 8, !tbaa !375, !range !110
  %tobool20 = trunc i8 %5 to i1
  %frombool = zext i1 %tobool20 to i8
  %lock21 = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %bh.0, i32 0, i32 1
  %6 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock21, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %6 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock.i1) #8
  %tobool22 = trunc i8 %frombool to i1
  br i1 %tobool22, label %cleanup.cont, label %if.else24

if.else24:                                        ; preds = %if.end18
  %tobool25 = trunc i8 %high_prio_bh.0 to i1
  %bh27 = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %bh.0, i32 0, i32 3
  br i1 %tobool25, label %if.then26, label %if.else28

if.then26:                                        ; preds = %if.else24
  call void @tasklet_hi_schedule(%struct.tasklet_struct* %bh27)
  br label %cleanup.cont

if.else28:                                        ; preds = %if.else24
  call void @tasklet_schedule(%struct.tasklet_struct* %bh27)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.else28, %if.then26, %if.end18, %if.then8
  ret void
}

declare i32 @mod_timer(%struct.timer_list*, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hcd_giveback_urb_in_bh(%struct.usb_hcd.712* %hcd) #1 {
entry:
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %0 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %flags = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %0, i32 0, i32 4
  %1 = load i32, i32* %flags, align 8, !tbaa !376
  %and = and i32 %1, 256
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_root_hub(%struct.usb_device* %udev) #1 {
entry:
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %cmp = icmp eq %struct.usb_device* %0, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal void @__usb_hcd_giveback_urb(%struct.urb* %urb) #0 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !242
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %1)
  %anchor1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 7
  %2 = load %struct.usb_anchor*, %struct.usb_anchor** %anchor1, align 8, !tbaa !377
  %unlinked = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 4
  %3 = load i32, i32* %unlinked, align 8, !tbaa !374
  %hcpriv = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 1
  store i8* null, i8** %hcpriv, align 8, !tbaa !378
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %4 = load i32, i32* %transfer_flags, align 4, !tbaa !379
  %and = and i32 %4, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %5 = load i32, i32* %actual_length, align 4, !tbaa !315
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %6 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !317
  %cmp = icmp ult i32 %5, %6
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %tobool2 = icmp ne i32 %3, 0
  %lnot = xor i1 %tobool2, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %7 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %lnot, %land.rhs ]
  %lnot3 = xor i1 %7, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  %. = select i1 %tobool5, i32 -121, i32 %3
  call void @unmap_urb_for_dma(%struct.usb_hcd.712* %call, %struct.urb* %urb)
  %self = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 0
  call void @usbmon_urb_complete(%struct.usb_bus* %self, %struct.urb* %urb, i32 %.)
  call void @usb_anchor_suspend_wakeups(%struct.usb_anchor* %2)
  call void bitcast (void (%struct.urb.744*)* @usb_unanchor_urb to void (%struct.urb*)*)(%struct.urb* %urb)
  %cmp6 = icmp eq i32 %., 0
  %lnot8 = xor i1 %cmp6, true
  %lnot10 = xor i1 %lnot8, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  %conv12 = sext i32 %lnot.ext11 to i64
  %expval13 = call i64 @llvm.expect.i64(i64 %conv12, i64 1)
  %tobool14 = icmp ne i64 %expval13, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %land.end
  call void @usb_led_activity(i32 0)
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %land.end
  %status17 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 12
  store i32 %., i32* %status17, align 8, !tbaa !314
  %call21 = call i64 @arch_local_irq_save()
  call void @trace_hardirqs_off()
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 28
  %8 = load void (%struct.urb*)*, void (%struct.urb*)** %complete, align 8, !tbaa !318
  call void %8(%struct.urb* %urb)
  %call31 = call i32 @arch_irqs_disabled_flags(i64 %call21)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %do.body34, label %if.else

do.body34:                                        ; preds = %if.end16
  call void @arch_local_irq_restore(i64 %call21)
  call void @trace_hardirqs_off()
  br label %do.end52

if.else:                                          ; preds = %if.end16
  call void @trace_hardirqs_on()
  call void @arch_local_irq_restore(i64 %call21)
  br label %do.end52

do.end52:                                         ; preds = %if.else, %do.body34
  call void @usb_anchor_resume_wakeups(%struct.usb_anchor* %2)
  %use_count = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 2
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %use_count, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !380
  %reject = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 3
  %counter.i1 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %reject, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %9 = load volatile i32, i32* %counter.i1, align 4, !tbaa !73
  %10 = bitcast i8* %arraydecay.i to i32*
  store i32 %9, i32* %10, align 4, !tbaa !73
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %11 = load i32, i32* %__val.i, align 4, !tbaa !72
  %tobool54 = icmp ne i32 %11, 0
  %lnot55 = xor i1 %tobool54, true
  %lnot57 = xor i1 %lnot55, true
  %lnot.ext58 = zext i1 %lnot57 to i32
  %conv59 = sext i32 %lnot.ext58 to i64
  %expval60 = call i64 @llvm.expect.i64(i64 %conv59, i64 0)
  %tobool61 = icmp ne i64 %expval60, 0
  br i1 %tobool61, label %if.then62, label %if.end63

if.then62:                                        ; preds = %do.end52
  call void @__wake_up(%struct.__wait_queue_head* @usb_kill_urb_queue, i32 3, i32 1, i8* null)
  br label %if.end63

if.end63:                                         ; preds = %if.then62, %do.end52
  call void bitcast (void (%struct.urb.744*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %urb)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.72(%struct.list_head* %new, %struct.list_head* %head) #1 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !87
  call void @__list_add.74(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @tasklet_hi_schedule(%struct.tasklet_struct* %t) #1 {
entry:
  %c.i = alloca i8, align 1
  %state = getelementptr inbounds %struct.tasklet_struct, %struct.tasklet_struct* %t, i32 0, i32 1
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $2, $0;\0A\09setc $1\0A", "=*m,=*qm,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %state, i8* %c.i, i64 0, i64* %state) #8, !srcloc !381
  %0 = load i8, i8* %c.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %0 to i1
  br i1 %tobool.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @__tasklet_hi_schedule(%struct.tasklet_struct* %t)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @tasklet_schedule(%struct.tasklet_struct* %t) #1 {
entry:
  %c.i = alloca i8, align 1
  %state = getelementptr inbounds %struct.tasklet_struct, %struct.tasklet_struct* %t, i32 0, i32 1
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $2, $0;\0A\09setc $1\0A", "=*m,=*qm,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %state, i8* %c.i, i64 0, i64* %state) #8, !srcloc !381
  %0 = load i8, i8* %c.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %0 to i1
  br i1 %tobool.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @__tasklet_schedule(%struct.tasklet_struct* %t)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @__tasklet_schedule(%struct.tasklet_struct*) #2

declare void @__tasklet_hi_schedule(%struct.tasklet_struct*) #2

declare void @_raw_spin_unlock(%struct.raw_spinlock*) #2 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add.74(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !87
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !252
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !87
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !72
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare void @_raw_spin_lock(%struct.raw_spinlock*) #2 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal void @unmap_urb_for_dma(%struct.usb_hcd.712* %hcd, %struct.urb* %urb) #0 {
entry:
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %0 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %unmap_urb_for_dma = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %0, i32 0, i32 15
  %1 = load void (%struct.usb_hcd.712*, %struct.urb*)*, void (%struct.usb_hcd.712*, %struct.urb*)** %unmap_urb_for_dma, align 8, !tbaa !382
  %tobool = icmp ne void (%struct.usb_hcd.712*, %struct.urb*)* %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %driver1 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %2 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver1, align 8, !tbaa !57
  %unmap_urb_for_dma2 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %2, i32 0, i32 15
  %3 = load void (%struct.usb_hcd.712*, %struct.urb*)*, void (%struct.usb_hcd.712*, %struct.urb*)** %unmap_urb_for_dma2, align 8, !tbaa !382
  call void %3(%struct.usb_hcd.712* %hcd, %struct.urb* %urb)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @usb_hcd_unmap_urb_for_dma(%struct.usb_hcd.712* %hcd, %struct.urb* %urb)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usbmon_urb_complete(%struct.usb_bus* %bus, %struct.urb* %urb, i32 %status) #1 {
entry:
  %monitored = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 18
  %0 = load i32, i32* %monitored, align 8, !tbaa !383
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.usb_mon_operations*, %struct.usb_mon_operations** @mon_ops, align 8, !tbaa !52
  %urb_complete = getelementptr inbounds %struct.usb_mon_operations, %struct.usb_mon_operations* %1, i32 0, i32 2
  %2 = load void (%struct.usb_bus*, %struct.urb*, i32)*, void (%struct.usb_bus*, %struct.urb*, i32)** %urb_complete, align 8, !tbaa !384
  call void %2(%struct.usb_bus* %bus, %struct.urb* %urb, i32 %status)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @usb_led_activity(i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @arch_local_irq_save() #1 {
entry:
  %call = call i64 @arch_local_save_flags()
  call void @arch_local_irq_disable()
  ret i64 %call
}

declare void @trace_hardirqs_off() #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @arch_irqs_disabled_flags(i64 %flags) #1 {
entry:
  %and = and i64 %flags, 512
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @arch_local_irq_restore(i64 %f) #1 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 1, i32 0), align 8, !tbaa !386
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.13.994, i32 0, i32 0), i32 778, i64 12) #8, !srcloc !389
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call { i64, i8* } asm sideeffect "771:\0A\09call *${3:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${2:c}\0A  .byte 772b-771b\0A  .short ${4:c}\0A.popsection\0A", "={ax},={rsp},i,i,i,{di},1,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 40, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 1, i32 0), i32 1, i64 %f, i8* undef) #8, !srcloc !390
  ret void
}

declare void @trace_hardirqs_on() #2

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @arch_local_save_flags() #1 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), align 8, !tbaa !391
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.13.994, i32 0, i32 0), i32 773, i64 12) #8, !srcloc !392
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call { i64, i8* } asm sideeffect "771:\0A\09call *${3:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${2:c}\0A  .byte 772b-771b\0A  .short ${4:c}\0A.popsection\0A", "={ax},={rsp},i,i,i,1,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 39, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), i32 1, i8* undef) #8, !srcloc !393
  %asmresult = extractvalue { i64, i8* } %1, 0
  %and = and i64 %asmresult, -1
  ret i64 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @arch_local_irq_disable() #1 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 2, i32 0), align 8, !tbaa !394
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.13.994, i32 0, i32 0), i32 783, i64 12) #8, !srcloc !395
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call { i64, i8* } asm sideeffect "771:\0A\09call *${3:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${2:c}\0A  .byte 772b-771b\0A  .short ${4:c}\0A.popsection\0A", "={ax},={rsp},i,i,i,1,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 41, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 2, i32 0), i32 1, i8* undef) #8, !srcloc !396
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_unmap_urb_for_dma(%struct.usb_hcd.712* %hcd, %struct.urb* %urb) #0 {
entry:
  call void @usb_hcd_unmap_urb_setup_for_dma(%struct.usb_hcd.712* %hcd, %struct.urb* %urb)
  %call = call i32 @usb_urb_dir_in(%struct.urb* %urb)
  %tobool = icmp ne i32 %call, 0
  %cond = select i1 %tobool, i32 2, i32 1
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %0 = load i32, i32* %transfer_flags, align 4, !tbaa !379
  %and = and i32 %0, 262144
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %self = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %1 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !356
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 16
  %2 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8, !tbaa !397
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %3 = load i32, i32* %num_sgs, align 4, !tbaa !398
  call void @dma_unmap_sg_attrs(%struct.device* %1, %struct.scatterlist* %2, i32 %3, i32 %cond, i64 0)
  br label %if.end28

if.else:                                          ; preds = %entry
  %transfer_flags2 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %4 = load i32, i32* %transfer_flags2, align 4, !tbaa !379
  %and3 = and i32 %4, 131072
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then5, label %if.else8

if.then5:                                         ; preds = %if.else
  %self6 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller7 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self6, i32 0, i32 0
  %5 = load %struct.device*, %struct.device** %controller7, align 8, !tbaa !356
  %transfer_dma = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 15
  %6 = load i64, i64* %transfer_dma, align 8, !tbaa !399
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %7 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !317
  %conv = zext i32 %7 to i64
  call void @dma_unmap_page_attrs(%struct.device* %5, i64 %6, i64 %conv, i32 %cond, i64 0)
  br label %if.end28

if.else8:                                         ; preds = %if.else
  %transfer_flags9 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %8 = load i32, i32* %transfer_flags9, align 4, !tbaa !379
  %and10 = and i32 %8, 65536
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.else18

if.then12:                                        ; preds = %if.else8
  %self13 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller14 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self13, i32 0, i32 0
  %9 = load %struct.device*, %struct.device** %controller14, align 8, !tbaa !356
  %transfer_dma15 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 15
  %10 = load i64, i64* %transfer_dma15, align 8, !tbaa !399
  %transfer_buffer_length16 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %11 = load i32, i32* %transfer_buffer_length16, align 8, !tbaa !317
  %conv17 = zext i32 %11 to i64
  call void @dma_unmap_single_attrs(%struct.device* %9, i64 %10, i64 %conv17, i32 %cond, i64 0)
  br label %if.end28

if.else18:                                        ; preds = %if.else8
  %transfer_flags19 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %12 = load i32, i32* %transfer_flags19, align 4, !tbaa !379
  %and20 = and i32 %12, 524288
  %tobool21 = icmp ne i32 %and20, 0
  br i1 %tobool21, label %if.then22, label %if.end28

if.then22:                                        ; preds = %if.else18
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %13 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !242
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 9
  %14 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %transfer_dma23 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 15
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %transfer_buffer_length24 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %15 = load i32, i32* %transfer_buffer_length24, align 8, !tbaa !317
  %conv25 = zext i32 %15 to i64
  call void @hcd_free_coherent(%struct.usb_bus* %14, i64* %transfer_dma23, i8** %transfer_buffer, i64 %conv25, i32 %cond)
  br label %if.end28

if.end28:                                         ; preds = %if.then22, %if.else18, %if.then12, %if.then5, %if.then
  %transfer_flags29 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %16 = load i32, i32* %transfer_flags29, align 4, !tbaa !379
  %and30 = and i32 %16, -983041
  store i32 %and30, i32* %transfer_flags29, align 4, !tbaa !379
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_unmap_urb_setup_for_dma(%struct.usb_hcd.712* %hcd, %struct.urb* %urb) #0 {
entry:
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %0 = load i32, i32* %transfer_flags, align 4, !tbaa !379
  %and = and i32 %0, 1048576
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %self = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %1 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !356
  %setup_dma = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 22
  %2 = load i64, i64* %setup_dma, align 8, !tbaa !400
  call void @dma_unmap_single_attrs(%struct.device* %1, i64 %2, i64 8, i32 1, i64 0)
  br label %if.end6

if.else:                                          ; preds = %entry
  %transfer_flags1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %3 = load i32, i32* %transfer_flags1, align 4, !tbaa !379
  %and2 = and i32 %3, 2097152
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.else
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !242
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 9
  %5 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %setup_dma5 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 22
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 21
  call void @hcd_free_coherent(%struct.usb_bus* %5, i64* %setup_dma5, i8** %setup_packet, i64 8, i32 1)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.else, %if.then
  %transfer_flags7 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %6 = load i32, i32* %transfer_flags7, align 4, !tbaa !379
  %and8 = and i32 %6, -3145729
  store i32 %and8, i32* %transfer_flags7, align 4, !tbaa !379
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_urb_dir_in(%struct.urb* %urb) #1 {
entry:
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %0 = load i32, i32* %transfer_flags, align 4, !tbaa !379
  %and = and i32 %0, 512
  %cmp = icmp eq i32 %and, 512
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @dma_unmap_sg_attrs(%struct.device* %dev, %struct.scatterlist* %sg, i32 %nents, i32 %dir, i64 %attrs) #1 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  %call1 = call i32 @valid_dma_direction(i32 %dir)
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.end10

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.1.564, i32 0, i32 0), i32 260, i64 12) #8, !srcloc !401
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.end10:                                         ; preds = %entry
  call void @debug_dma_unmap_sg(%struct.device* %dev, %struct.scatterlist* %sg, i32 %nents, i32 %dir)
  %unmap_sg = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 7
  %0 = load void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)** %unmap_sg, align 8, !tbaa !402
  %tobool11 = icmp ne void (%struct.device*, %struct.scatterlist*, i32, i32, i64)* %0, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %do.end10
  %unmap_sg13 = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 7
  %1 = load void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)** %unmap_sg13, align 8, !tbaa !402
  call void %1(%struct.device* %dev, %struct.scatterlist* %sg, i32 %nents, i32 %dir, i64 %attrs)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %do.end10
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @dma_unmap_page_attrs(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, i64 %attrs) #1 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  %call1 = call i32 @valid_dma_direction(i32 %dir)
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.end10

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.1.564, i32 0, i32 0), i32 290, i64 12) #8, !srcloc !404
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.end10:                                         ; preds = %entry
  %unmap_page = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 5
  %0 = load void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)** %unmap_page, align 8, !tbaa !405
  %tobool11 = icmp ne void (%struct.device*, i64, i64, i32, i64)* %0, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %do.end10
  %unmap_page13 = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 5
  %1 = load void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)** %unmap_page13, align 8, !tbaa !405
  call void %1(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, i64 %attrs)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %do.end10
  call void @debug_dma_unmap_page(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, i1 zeroext false)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @dma_unmap_single_attrs(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, i64 %attrs) #1 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  %call1 = call i32 @valid_dma_direction(i32 %dir)
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.end10

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.1.564, i32 0, i32 0), i32 226, i64 12) #8, !srcloc !406
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.end10:                                         ; preds = %entry
  %unmap_page = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 5
  %0 = load void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)** %unmap_page, align 8, !tbaa !405
  %tobool11 = icmp ne void (%struct.device*, i64, i64, i32, i64)* %0, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %do.end10
  %unmap_page13 = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 5
  %1 = load void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)** %unmap_page13, align 8, !tbaa !405
  call void %1(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, i64 %attrs)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %do.end10
  call void @debug_dma_unmap_page(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, i1 zeroext true)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hcd_free_coherent(%struct.usb_bus* %bus, i64* %dma_handle, i8** %vaddr_handle, i64 %size, i32 %dir) #0 {
entry:
  %0 = load i8*, i8** %vaddr_handle, align 8, !tbaa !52
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 %size
  %1 = bitcast i8* %add.ptr to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = inttoptr i64 %2 to i8*
  %cmp = icmp eq i32 %dir, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i8*, i8** %vaddr_handle, align 8, !tbaa !52
  %call1 = call i8* @__memcpy(i8* %3, i8* %4, i64 %size)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %add = add i64 %size, 8
  %5 = load i8*, i8** %vaddr_handle, align 8, !tbaa !52
  %6 = load i64, i64* %dma_handle, align 8, !tbaa !86
  call void @hcd_buffer_free(%struct.usb_bus* %bus, i64 %add, i8* %5, i64 %6)
  store i8* %3, i8** %vaddr_handle, align 8, !tbaa !52
  store i64 0, i64* %dma_handle, align 8, !tbaa !86
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev) #1 {
entry:
  %magicptr = ptrtoint %struct.device* %dev to i64
  %cond1 = icmp eq i64 %magicptr, 0
  br i1 %cond1, label %cond.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %dma_ops = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 17
  %0 = load %struct.dma_map_ops*, %struct.dma_map_ops** %dma_ops, align 8, !tbaa !407
  %tobool1 = icmp ne %struct.dma_map_ops* %0, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %dma_ops2 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 17
  %1 = load %struct.dma_map_ops*, %struct.dma_map_ops** %dma_ops2, align 8, !tbaa !407
  br label %return

if.end:                                           ; preds = %land.lhs.true
  %tobool3 = icmp ne %struct.device* %dev, null
  br i1 %tobool3, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.end, %entry
  %call = call %struct.dma_map_ops* @get_arch_dma_ops()
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %retval.0 = phi %struct.dma_map_ops* [ %1, %if.then ], [ %call, %cond.end ]
  ret %struct.dma_map_ops* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @valid_dma_direction(i32 %dma_direction) #1 {
entry:
  %switch = icmp ult i32 %dma_direction, 3
  %. = select i1 %switch, i1 true, i1 false
  %lor.ext = zext i1 %. to i32
  ret i32 %lor.ext
}

declare void @debug_dma_unmap_page(%struct.device*, i64, i64, i32, i1 zeroext) #2

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.dma_map_ops* @get_arch_dma_ops() #1 {
entry:
  %0 = load %struct.dma_map_ops*, %struct.dma_map_ops** @dma_ops, align 8, !tbaa !52
  ret %struct.dma_map_ops* %0
}

declare void @debug_dma_unmap_sg(%struct.device*, %struct.scatterlist*, i32, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init(%struct.list_head* %entry1) #1 {
entry:
  call void @__list_del_entry.79(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD.80(%struct.list_head* %entry1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry.79(%struct.list_head* %entry1) #1 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !87
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !252
  call void @__list_del.81(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.80(%struct.list_head* %list) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !72
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !87
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del.81(%struct.list_head* %prev, %struct.list_head* %next) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !87
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !72
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  ret void
}

declare i8* @__memset(i8*, i32, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name.83(%struct.device* %dev) #1 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !299
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !299
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name.88(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_hc_died(%struct.usb_hcd.712* %hcd) #0 {
entry:
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0))
  %flags5 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags5, i64 5, i64* %flags5) #8, !srcloc !354
  %flags6 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags6, i64 6, i64* %flags6) #8, !srcloc !362
  %rh_registered = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load = load i16, i16* %rh_registered, align 8
  %bf.clear = and i16 %bf.load, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %flags7 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags7, i64 2, i64* %flags7) #8, !srcloc !354
  %self8 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self8, i32 0, i32 11
  %0 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !175
  call void @usb_set_device_state(%struct.usb_device* %0, i32 0)
  %self9 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %root_hub10 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self9, i32 0, i32 11
  %1 = load %struct.usb_device*, %struct.usb_device** %root_hub10, align 8, !tbaa !175
  call void @usb_kick_hub_wq(%struct.usb_device* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call11 = call i32 @usb_hcd_is_primary_hcd(%struct.usb_hcd.712* %hcd)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %land.lhs.true, label %if.end28

land.lhs.true:                                    ; preds = %if.end
  %shared_hcd = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 22
  %2 = load %struct.usb_hcd.712*, %struct.usb_hcd.712** %shared_hcd, align 8, !tbaa !408
  %tobool13 = icmp ne %struct.usb_hcd.712* %2, null
  br i1 %tobool13, label %if.then14, label %if.end28

if.then14:                                        ; preds = %land.lhs.true
  %shared_hcd15 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 22
  %3 = load %struct.usb_hcd.712*, %struct.usb_hcd.712** %shared_hcd15, align 8, !tbaa !408
  %rh_registered16 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %3, i32 0, i32 12
  %bf.load17 = load i16, i16* %rh_registered16, align 8
  %bf.clear18 = and i16 %bf.load17, 1
  %bf.cast19 = zext i16 %bf.clear18 to i32
  %tobool20 = icmp ne i32 %bf.cast19, 0
  br i1 %tobool20, label %if.then21, label %if.end28

if.then21:                                        ; preds = %if.then14
  %flags22 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %3, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags22, i64 2, i64* %flags22) #8, !srcloc !354
  %self23 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %3, i32 0, i32 0
  %root_hub24 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self23, i32 0, i32 11
  %4 = load %struct.usb_device*, %struct.usb_device** %root_hub24, align 8, !tbaa !175
  call void @usb_set_device_state(%struct.usb_device* %4, i32 0)
  %self25 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %3, i32 0, i32 0
  %root_hub26 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self25, i32 0, i32 11
  %5 = load %struct.usb_device*, %struct.usb_device** %root_hub26, align 8, !tbaa !175
  call void @usb_kick_hub_wq(%struct.usb_device* %5)
  br label %if.end28

if.end28:                                         ; preds = %if.then21, %if.then14, %land.lhs.true, %if.end
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0), i64 %call2) #8
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name.88(%struct.kobject* %kobj) #1 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !409
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_irq(i32 %irq, i8* %__hcd) #0 {
entry:
  %0 = bitcast i8* %__hcd to %struct.usb_hcd.712*
  %flags = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %0, i32 0, i32 11
  %1 = load i64, i64* %flags, align 8, !tbaa !84
  %and = and i64 %1, 64
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %flags1 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %0, i32 0, i32 11
  %2 = load i64, i64* %flags1, align 8, !tbaa !84
  %and2 = and i64 %2, 1
  %tobool3 = icmp ne i64 %and2, 0
  %lnot = xor i1 %tobool3, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot4 = xor i1 %3, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.end11, label %if.else

if.else:                                          ; preds = %lor.end
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %0, i32 0, i32 8
  %4 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %irq7 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %4, i32 0, i32 3
  %5 = load i32 (%struct.usb_hcd.712*)*, i32 (%struct.usb_hcd.712*)** %irq7, align 8, !tbaa !367
  %call = call i32 %5(%struct.usb_hcd.712* %0)
  %cmp = icmp eq i32 %call, 0
  %. = select i1 %cmp, i32 0, i32 1
  br label %if.end11

if.end11:                                         ; preds = %if.else, %lor.end
  %rc.1 = phi i32 [ %., %if.else ], [ 0, %lor.end ]
  ret i32 %rc.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @request_irq(i32 %irq, i32 (i32, i8*)* %handler, i64 %flags, i8* %name, i8* %dev) #1 {
entry:
  %call = call i32 @request_threaded_irq(i32 %irq, i32 (i32, i8*)* %handler, i32 (i32, i8*)* null, i64 %flags, i8* %name, i8* %dev)
  ret i32 %call
}

declare i32 @request_threaded_irq(i32, i32 (i32, i8*)*, i32 (i32, i8*)*, i64, i8*, i8*) #2

; Function Attrs: nounwind uwtable
define internal void @usb_giveback_urb_bh(i64 %param) #0 {
entry:
  %local_list = alloca %struct.list_head, align 8
  %0 = inttoptr i64 %param to %struct.giveback_urb_bh*
  %lock = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %0, i32 0, i32 1
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %1 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i1) #8
  %running = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %0, i32 0, i32 0
  store i8 1, i8* %running, align 8, !tbaa !375
  %lock3 = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %0, i32 0, i32 1
  br label %restart

restart:                                          ; preds = %if.then, %entry
  %head = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %0, i32 0, i32 2
  call void @list_replace_init(%struct.list_head* %head, %struct.list_head* %local_list)
  %lock1 = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %0, i32 0, i32 1
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock1, i32 0, i32 0
  %rlock.i3 = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i3) #8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %restart
  %call = call i32 @list_empty.93(%struct.list_head* %local_list)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %local_list, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !252
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 -32
  %5 = bitcast i8* %add.ptr to %struct.urb*
  %urb_list = getelementptr inbounds %struct.urb, %struct.urb* %5, i32 0, i32 5
  call void @list_del_init(%struct.list_head* %urb_list)
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %5, i32 0, i32 9
  %6 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !250
  %completing_ep = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %0, i32 0, i32 4
  store %struct.usb_host_endpoint* %6, %struct.usb_host_endpoint** %completing_ep, align 8, !tbaa !410
  call void @__usb_hcd_giveback_urb(%struct.urb* %5)
  %completing_ep2 = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %0, i32 0, i32 4
  store %struct.usb_host_endpoint* null, %struct.usb_host_endpoint** %completing_ep2, align 8, !tbaa !410
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %7 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock3, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %7 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i) #8
  %head4 = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %0, i32 0, i32 2
  %call5 = call i32 @list_empty.93(%struct.list_head* %head4)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.end, label %if.then

if.then:                                          ; preds = %while.end
  br label %restart

if.end:                                           ; preds = %while.end
  %running7 = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %0, i32 0, i32 0
  store i8 0, i8* %running7, align 8, !tbaa !375
  %lock8 = getelementptr inbounds %struct.giveback_urb_bh, %struct.giveback_urb_bh* %0, i32 0, i32 1
  %8 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock8, i32 0, i32 0
  %rlock.i2 = bitcast %union.anon.1* %8 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i2) #8
  ret void
}

declare void @tasklet_init(%struct.tasklet_struct*, void (i64)*, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_replace_init(%struct.list_head* %old, %struct.list_head* %new) #1 {
entry:
  call void @list_replace(%struct.list_head* %old, %struct.list_head* %new)
  call void @INIT_LIST_HEAD.80(%struct.list_head* %old)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty.93(%struct.list_head* %head) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %0 to i64*
  %2 = load volatile i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %arraydecay to i64*
  store i64 %2, i64* %3, align 8, !tbaa !86
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  %4 = load %struct.list_head*, %struct.list_head** %__val, align 8, !tbaa !72
  %cmp = icmp eq %struct.list_head* %4, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_replace(%struct.list_head* %old, %struct.list_head* %new) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %old, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !252
  %next1 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %0, %struct.list_head** %next1, align 8, !tbaa !252
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next2, align 8, !tbaa !252
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev, align 8, !tbaa !87
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %old, i32 0, i32 1
  %2 = load %struct.list_head*, %struct.list_head** %prev3, align 8, !tbaa !87
  %prev4 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %2, %struct.list_head** %prev4, align 8, !tbaa !87
  %prev5 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  %3 = load %struct.list_head*, %struct.list_head** %prev5, align 8, !tbaa !87
  %next6 = getelementptr inbounds %struct.list_head, %struct.list_head* %3, i32 0, i32 0
  store %struct.list_head* %new, %struct.list_head** %next6, align 8, !tbaa !252
  ret void
}

declare i32 @idr_alloc(%struct.idr*, i8*, i32, i32, i32) #2

; Function Attrs: nounwind uwtable
define void @usb_put_hcd(%struct.usb_hcd.712* %hcd) #0 {
entry:
  %tobool = icmp ne %struct.usb_hcd.712* %hcd, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %kref = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 1
  call void @kref_put.98(%struct.kref* %kref, void (%struct.kref*)* @hcd_release)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hcd_release(%struct.kref* %kref) #0 {
entry:
  %0 = bitcast %struct.kref* %kref to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -264
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd.712*
  call void @mutex_lock_nested(%struct.mutex* @usb_port_peer_mutex, i32 0)
  %shared_hcd = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 22
  %2 = load %struct.usb_hcd.712*, %struct.usb_hcd.712** %shared_hcd, align 8, !tbaa !408
  %tobool = icmp ne %struct.usb_hcd.712* %2, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %shared_hcd1 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 22
  %3 = load %struct.usb_hcd.712*, %struct.usb_hcd.712** %shared_hcd1, align 8, !tbaa !408
  %shared_hcd2 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %3, i32 0, i32 22
  store %struct.usb_hcd.712* null, %struct.usb_hcd.712** %shared_hcd2, align 8, !tbaa !408
  %primary_hcd = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %3, i32 0, i32 23
  store %struct.usb_hcd.712* null, %struct.usb_hcd.712** %primary_hcd, align 8, !tbaa !360
  br label %if.end

if.else:                                          ; preds = %entry
  %address0_mutex = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 20
  %4 = load %struct.mutex*, %struct.mutex** %address0_mutex, align 8, !tbaa !179
  %5 = bitcast %struct.mutex* %4 to i8*
  call void @kfree(i8* %5)
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 21
  %6 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !167
  %7 = bitcast %struct.mutex* %6 to i8*
  call void @kfree(i8* %7)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  call void @mutex_unlock(%struct.mutex* @usb_port_peer_mutex)
  %8 = bitcast %struct.usb_hcd.712* %1 to i8*
  call void @kfree(i8* %8)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put.98(%struct.kref* %kref, void (%struct.kref*)* %release) #1 {
entry:
  %cmp = icmp eq void (%struct.kref*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.11.527, i32 0, i32 0), i32 69)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  %call = call zeroext i1 @refcount_dec_and_test(%struct.qspinlock* %refcount)
  br i1 %call, label %if.then14, label %return

if.then14:                                        ; preds = %if.end
  call void %release(%struct.kref* %kref)
  br label %return

return:                                           ; preds = %if.then14, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.usb_hcd.712* @usb_get_hcd(%struct.usb_hcd.712* %hcd) #0 {
entry:
  %tobool = icmp ne %struct.usb_hcd.712* %hcd, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %kref = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 1
  call void @kref_get.102(%struct.kref* %kref)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.usb_hcd.712* %hcd
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_get.102(%struct.kref* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  call void @refcount_inc(%struct.qspinlock* %refcount)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.usb_hcd.712* @usb_create_hcd(%struct.hc_driver.713* %driver, %struct.device* %dev, i8* %bus_name) #0 {
entry:
  %call = call %struct.usb_hcd.712* @usb_create_shared_hcd(%struct.hc_driver.713* %driver, %struct.device* %dev, i8* %bus_name, %struct.usb_hcd.712* null)
  ret %struct.usb_hcd.712* %call
}

; Function Attrs: nounwind uwtable
define %struct.usb_hcd.712* @usb_create_shared_hcd(%struct.hc_driver.713* %driver, %struct.device* %dev, i8* %bus_name, %struct.usb_hcd.712* %primary_hcd) #0 {
entry:
  %.compoundliteral = alloca %union.anon.3, align 8
  %hcd_priv_size = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %driver, i32 0, i32 2
  %0 = load i64, i64* %hcd_priv_size, align 8, !tbaa !411
  %add = add i64 928, %0
  %call = call i8* @kzalloc.103(i64 %add, i32 20971712)
  %1 = bitcast i8* %call to %struct.usb_hcd.712*
  %tobool = icmp ne %struct.usb_hcd.712* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %cmp = icmp eq %struct.usb_hcd.712* %primary_hcd, null
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %call.i1 = call noalias i8* @__kmalloc(i64 160, i32 20971712) #8
  %2 = bitcast i8* %call.i1 to %struct.mutex*
  %address0_mutex = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 20
  store %struct.mutex* %2, %struct.mutex** %address0_mutex, align 8, !tbaa !179
  %address0_mutex3 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 20
  %3 = load %struct.mutex*, %struct.mutex** %address0_mutex3, align 8, !tbaa !179
  %tobool4 = icmp ne %struct.mutex* %3, null
  br i1 %tobool4, label %do.body15, label %if.then5

if.then5:                                         ; preds = %if.then1
  %4 = bitcast %struct.usb_hcd.712* %1 to i8*
  call void @kfree(i8* %4)
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_create_shared_hcd.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool7 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool7, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %cleanup

if.then10:                                        ; preds = %if.then5
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_create_shared_hcd.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.29.105, i32 0, i32 0))
  br label %cleanup

do.body15:                                        ; preds = %if.then1
  %address0_mutex16 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 20
  %5 = load %struct.mutex*, %struct.mutex** %address0_mutex16, align 8, !tbaa !179
  call void @__mutex_init(%struct.mutex* %5, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.30, i32 0, i32 0), %struct.lock_class_key* @usb_create_shared_hcd.__key)
  %call.i = call noalias i8* @__kmalloc(i64 160, i32 20971712) #8
  %6 = bitcast i8* %call.i to %struct.mutex*
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 21
  store %struct.mutex* %6, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !167
  %bandwidth_mutex20 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 21
  %7 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex20, align 8, !tbaa !167
  %tobool21 = icmp ne %struct.mutex* %7, null
  br i1 %tobool21, label %do.body44, label %if.then22

if.then22:                                        ; preds = %do.body15
  %8 = bitcast %struct.usb_hcd.712* %1 to i8*
  call void @kfree(i8* %8)
  %bf.load25 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_create_shared_hcd.descriptor.31 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr26 = lshr i32 %bf.load25, 18
  %bf.clear27 = and i32 %bf.lshr26, 255
  %and28 = and i32 %bf.clear27, 1
  %tobool29 = icmp ne i32 %and28, 0
  %lnot30 = xor i1 %tobool29, true
  %lnot32 = xor i1 %lnot30, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %expval35 = call i64 @llvm.expect.i64(i64 %conv34, i64 0)
  %tobool36 = icmp ne i64 %expval35, 0
  br i1 %tobool36, label %if.then37, label %cleanup

if.then37:                                        ; preds = %if.then22
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_create_shared_hcd.descriptor.31 to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.32, i32 0, i32 0))
  br label %cleanup

do.body44:                                        ; preds = %do.body15
  %bandwidth_mutex45 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 21
  %9 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex45, align 8, !tbaa !167
  call void @__mutex_init(%struct.mutex* %9, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.34, i32 0, i32 0), %struct.lock_class_key* @usb_create_shared_hcd.__key.33)
  %10 = bitcast %struct.usb_hcd.712* %1 to i8*
  call void @dev_set_drvdata.106(%struct.device* %dev, i8* %10)
  br label %if.end55

if.else:                                          ; preds = %if.end
  call void @mutex_lock_nested(%struct.mutex* @usb_port_peer_mutex, i32 0)
  %address0_mutex48 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %primary_hcd, i32 0, i32 20
  %11 = load %struct.mutex*, %struct.mutex** %address0_mutex48, align 8, !tbaa !179
  %address0_mutex49 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 20
  store %struct.mutex* %11, %struct.mutex** %address0_mutex49, align 8, !tbaa !179
  %bandwidth_mutex50 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %primary_hcd, i32 0, i32 21
  %12 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex50, align 8, !tbaa !167
  %bandwidth_mutex51 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 21
  store %struct.mutex* %12, %struct.mutex** %bandwidth_mutex51, align 8, !tbaa !167
  %primary_hcd52 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 23
  store %struct.usb_hcd.712* %primary_hcd, %struct.usb_hcd.712** %primary_hcd52, align 8, !tbaa !360
  %primary_hcd53 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %primary_hcd, i32 0, i32 23
  store %struct.usb_hcd.712* %primary_hcd, %struct.usb_hcd.712** %primary_hcd53, align 8, !tbaa !360
  %shared_hcd = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 22
  store %struct.usb_hcd.712* %primary_hcd, %struct.usb_hcd.712** %shared_hcd, align 8, !tbaa !408
  %shared_hcd54 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %primary_hcd, i32 0, i32 22
  store %struct.usb_hcd.712* %1, %struct.usb_hcd.712** %shared_hcd54, align 8, !tbaa !408
  call void @mutex_unlock(%struct.mutex* @usb_port_peer_mutex)
  br label %if.end55

if.end55:                                         ; preds = %if.else, %do.body44
  %kref = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 1
  call void @kref_init.107(%struct.kref* %kref)
  %self = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 0
  call void @usb_bus_init(%struct.usb_bus* %self)
  %self56 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self56, i32 0, i32 0
  store %struct.device* %dev, %struct.device** %controller, align 8, !tbaa !356
  %self57 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 0
  %bus_name58 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self57, i32 0, i32 2
  store i8* %bus_name, i8** %bus_name58, align 8, !tbaa !412
  %dma_mask = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 18
  %13 = load i64*, i64** %dma_mask, align 8, !tbaa !67
  %cmp59 = icmp ne i64* %13, null
  %conv60 = zext i1 %cmp59 to i32
  %conv61 = trunc i32 %conv60 to i8
  %self62 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 0
  %uses_dma = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self62, i32 0, i32 3
  store i8 %conv61, i8* %uses_dma, align 8, !tbaa !413
  %rh_timer = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 5
  call void @init_timer_key(%struct.timer_list* %rh_timer, i32 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.36.108, i32 0, i32 0), %struct.lock_class_key* @usb_create_shared_hcd.__key.35)
  %rh_timer66 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 5
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %rh_timer66, i32 0, i32 2
  store void (i64)* @rh_timer_func, void (i64)** %function, align 8, !tbaa !414
  %14 = ptrtoint %struct.usb_hcd.712* %1 to i64
  %rh_timer67 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 5
  %data = getelementptr inbounds %struct.timer_list, %struct.timer_list* %rh_timer67, i32 0, i32 3
  store i64 %14, i64* %data, align 8, !tbaa !415
  %wakeup_work = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 7
  call void @__init_work(%struct.work_struct* %wakeup_work, i32 0)
  %wakeup_work69 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 7
  %data70 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %wakeup_work69, i32 0, i32 0
  %counter = getelementptr inbounds %union.anon.3, %union.anon.3* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !287
  %15 = bitcast %union.anon.3* %data70 to i8*
  %16 = bitcast %union.anon.3* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 8, i32 8, i1 false), !tbaa.struct !288
  %wakeup_work71 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 7
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %wakeup_work71, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.38.109, i32 0, i32 0), %struct.lock_class_key* @usb_create_shared_hcd.__key.37, i32 0)
  %wakeup_work72 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 7
  %entry73 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %wakeup_work72, i32 0, i32 1
  call void @INIT_LIST_HEAD.80(%struct.list_head* %entry73)
  %wakeup_work74 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 7
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %wakeup_work74, i32 0, i32 2
  store void (%struct.work_struct*)* @hcd_resume_work, void (%struct.work_struct*)** %func, align 8, !tbaa !289
  %driver77 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 8
  store %struct.hc_driver.713* %driver, %struct.hc_driver.713** %driver77, align 8, !tbaa !57
  %flags = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %driver, i32 0, i32 4
  %17 = load i32, i32* %flags, align 8, !tbaa !376
  %and78 = and i32 %17, 112
  %speed = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 3
  store i32 %and78, i32* %speed, align 8, !tbaa !363
  %product_desc = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %driver, i32 0, i32 1
  %18 = load i8*, i8** %product_desc, align 8, !tbaa !416
  %tobool79 = icmp ne i8* %18, null
  br i1 %tobool79, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end55
  %product_desc80 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %driver, i32 0, i32 1
  %19 = load i8*, i8** %product_desc80, align 8, !tbaa !416
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.end55
  %cond = phi i8* [ %19, %cond.true ], [ getelementptr inbounds ([20 x i8], [20 x i8]* @.str.39.110, i32 0, i32 0), %if.end55 ]
  %product_desc81 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 2
  store i8* %cond, i8** %product_desc81, align 8, !tbaa !417
  br label %cleanup

cleanup:                                          ; preds = %cond.end, %if.then37, %if.then22, %if.then10, %if.then5, %entry
  %retval.0 = phi %struct.usb_hcd.712* [ %1, %cond.end ], [ null, %entry ], [ null, %if.then10 ], [ null, %if.then5 ], [ null, %if.then37 ], [ null, %if.then22 ]
  ret %struct.usb_hcd.712* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.103(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call noalias i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @dev_set_drvdata.106(%struct.device* %dev, i8* %data) #1 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  store i8* %data, i8** %driver_data, align 8, !tbaa !117
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_init.107(%struct.kref* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  call void @refcount_set.112(%struct.qspinlock* %refcount, i32 1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usb_bus_init(%struct.usb_bus* %bus) #0 {
entry:
  %devmap = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 10
  %0 = bitcast %struct.usb_devmap* %devmap to i8*
  %call = call i8* @__memset(i8* %0, i32 0, i64 16)
  %devnum_next = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 8
  store i32 1, i32* %devnum_next, align 8, !tbaa !329
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 11
  store %struct.usb_device* null, %struct.usb_device** %root_hub, align 8, !tbaa !264
  %busnum = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 1
  store i32 -1, i32* %busnum, align 8, !tbaa !41
  %bandwidth_allocated = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 13
  store i32 0, i32* %bandwidth_allocated, align 8, !tbaa !418
  %bandwidth_int_reqs = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 14
  store i32 0, i32* %bandwidth_int_reqs, align 4, !tbaa !419
  %bandwidth_isoc_reqs = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 15
  store i32 0, i32* %bandwidth_isoc_reqs, align 8, !tbaa !420
  %devnum_next_mutex = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 9
  call void @__mutex_init(%struct.mutex* %devnum_next_mutex, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.65.111, i32 0, i32 0), %struct.lock_class_key* @usb_bus_init.__key)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rh_timer_func(i64 %_hcd) #0 {
entry:
  %0 = inttoptr i64 %_hcd to %struct.usb_hcd.712*
  call void @usb_hcd_poll_rh_status(%struct.usb_hcd.712* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hcd_resume_work(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -416
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd.712*
  %self = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %1, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 11
  %2 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !175
  %call = call i32 @usb_remote_wakeup(%struct.usb_device* %2)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @refcount_set.112(%struct.qspinlock* %r, i32 %n) #1 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %refs = getelementptr inbounds %struct.qspinlock, %struct.qspinlock* %r, i32 0, i32 0
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  store i32 %n, i32* %__val.i, align 4, !tbaa !72
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %refs, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %0 = bitcast i8* %arraydecay.i to i32*
  %1 = load i32, i32* %0, align 4, !tbaa !73
  store volatile i32 %1, i32* %counter.i, align 4, !tbaa !73
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_bus_start_enum(%struct.usb_bus* %bus, i32 %port_num) #0 {
entry:
  %call = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %bus)
  %tobool = icmp ne i32 %port_num, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %0 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %start_port_reset = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %0, i32 0, i32 22
  %1 = load i32 (%struct.usb_hcd.712*, i32)*, i32 (%struct.usb_hcd.712*, i32)** %start_port_reset, align 8, !tbaa !421
  %tobool1 = icmp ne i32 (%struct.usb_hcd.712*, i32)* %1, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %driver2 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %2 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver2, align 8, !tbaa !57
  %start_port_reset3 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %2, i32 0, i32 22
  %3 = load i32 (%struct.usb_hcd.712*, i32)*, i32 (%struct.usb_hcd.712*, i32)** %start_port_reset3, align 8, !tbaa !421
  %call4 = call i32 %3(%struct.usb_hcd.712* %call, i32 %port_num)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %status.0 = phi i32 [ %call4, %if.then ], [ -95, %land.lhs.true ], [ -95, %entry ]
  %cmp = icmp eq i32 %status.0, 0
  br i1 %cmp, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end
  %rh_timer = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 5
  %4 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  %call.i = call i64 @__msecs_to_jiffies(i32 10) #8
  %add = add i64 %4, %call.i
  %call7 = call i32 @mod_timer(%struct.timer_list* %rh_timer, i64 %add)
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %if.end
  ret i32 %status.0
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_resume_root_hub(%struct.usb_hcd.712* %hcd) #0 {
entry:
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0))
  %rh_registered = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load = load i16, i16* %rh_registered, align 8
  %bf.clear = and i16 %bf.load, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %flags5 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags5, i64 4, i64* %flags5) #8, !srcloc !362
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @pm_wq, align 8, !tbaa !52
  %wakeup_work = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 7
  call void @queue_work.115(%struct.workqueue_struct* %0, %struct.work_struct* %wakeup_work)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0), i64 %call2) #8
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_work.115(%struct.workqueue_struct* %wq, %struct.work_struct* %work) #1 {
entry:
  %call = call zeroext i1 @queue_work_on(i32 8192, %struct.workqueue_struct* %wq, %struct.work_struct* %work)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_free_streams(%struct.usb_interface* %interface, %struct.usb_host_endpoint** %eps, i32 %num_eps, i32 %mem_flags) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev.116(%struct.usb_interface* %interface)
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call1 = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %0)
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 4
  %1 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp ult i32 %1, 5
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %cmp2 = icmp ult i32 %i.0, %num_eps
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %eps, i64 %idxprom
  %2 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8, !tbaa !52
  %tobool = icmp ne %struct.usb_host_endpoint* %2, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %for.body
  %idxprom3 = sext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %eps, i64 %idxprom3
  %3 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx4, align 8, !tbaa !52
  %streams = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %3, i32 0, i32 10
  %4 = load i32, i32* %streams, align 8, !tbaa !174
  %tobool5 = icmp ne i32 %4, 0
  br i1 %tobool5, label %for.inc, label %cleanup

for.inc:                                          ; preds = %lor.lhs.false
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call1, i32 0, i32 8
  %5 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %free_streams = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %5, i32 0, i32 29
  %6 = load i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32)** %free_streams, align 8, !tbaa !422
  %call8 = call i32 %6(%struct.usb_hcd.712* %call1, %struct.usb_device* %call, %struct.usb_host_endpoint** %eps, i32 %num_eps, i32 %mem_flags)
  %cmp9 = icmp slt i32 %call8, 0
  br i1 %cmp9, label %cleanup, label %if.end11

if.end11:                                         ; preds = %for.end
  br label %for.cond12

for.cond12:                                       ; preds = %for.body14, %if.end11
  %i.1 = phi i32 [ 0, %if.end11 ], [ %inc19, %for.body14 ]
  %cmp13 = icmp ult i32 %i.1, %num_eps
  br i1 %cmp13, label %for.body14, label %cleanup

for.body14:                                       ; preds = %for.cond12
  %idxprom15 = sext i32 %i.1 to i64
  %arrayidx16 = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %eps, i64 %idxprom15
  %7 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx16, align 8, !tbaa !52
  %streams17 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %7, i32 0, i32 10
  store i32 0, i32* %streams17, align 8, !tbaa !174
  %inc19 = add nsw i32 %i.1, 1
  br label %for.cond12

cleanup:                                          ; preds = %for.cond12, %for.end, %lor.lhs.false, %for.body, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -22, %lor.lhs.false ], [ -22, %for.body ], [ %call8, %for.end ], [ %call8, %for.cond12 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_device* @interface_to_usbdev.116(%struct.usb_interface* %intf) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %parent, align 8, !tbaa !300
  %1 = bitcast %struct.device* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -152
  %2 = bitcast i8* %add.ptr to %struct.usb_device*
  ret %struct.usb_device* %2
}

; Function Attrs: nounwind uwtable
define i32 @usb_alloc_streams(%struct.usb_interface* %interface, %struct.usb_host_endpoint** %eps, i32 %num_eps, i32 %num_streams, i32 %mem_flags) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev.116(%struct.usb_interface* %interface)
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call1 = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %0)
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call1, i32 0, i32 8
  %1 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %alloc_streams = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %1, i32 0, i32 28
  %2 = load i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32, i32)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32, i32)** %alloc_streams, align 8, !tbaa !423
  %tobool = icmp ne i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32, i32)* %2, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %driver2 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call1, i32 0, i32 8
  %3 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver2, align 8, !tbaa !57
  %free_streams = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %3, i32 0, i32 29
  %4 = load i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32)** %free_streams, align 8, !tbaa !422
  %tobool3 = icmp ne i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32)* %4, null
  br i1 %tobool3, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 4
  %5 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp ult i32 %5, 5
  br i1 %cmp, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 3
  %6 = load i32, i32* %state, align 8, !tbaa !54
  %cmp6 = icmp ult i32 %6, 7
  br i1 %cmp6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end8
  %i.0 = phi i32 [ 0, %if.end8 ], [ %inc, %for.inc ]
  %cmp9 = icmp ult i32 %i.0, %num_eps
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %eps, i64 %idxprom
  %7 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8, !tbaa !52
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %7, i32 0, i32 0
  %call10 = call i32 @usb_endpoint_xfer_bulk(%struct.usb_endpoint_descriptor* %desc)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end13, label %cleanup

if.end13:                                         ; preds = %for.body
  %idxprom14 = sext i32 %i.0 to i64
  %arrayidx15 = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %eps, i64 %idxprom14
  %8 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx15, align 8, !tbaa !52
  %streams = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %8, i32 0, i32 10
  %9 = load i32, i32* %streams, align 8, !tbaa !174
  %tobool16 = icmp ne i32 %9, 0
  br i1 %tobool16, label %cleanup, label %for.inc

for.inc:                                          ; preds = %if.end13
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %driver19 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call1, i32 0, i32 8
  %10 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver19, align 8, !tbaa !57
  %alloc_streams20 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %10, i32 0, i32 28
  %11 = load i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32, i32)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32, i32)** %alloc_streams20, align 8, !tbaa !423
  %call21 = call i32 %11(%struct.usb_hcd.712* %call1, %struct.usb_device* %call, %struct.usb_host_endpoint** %eps, i32 %num_eps, i32 %num_streams, i32 %mem_flags)
  %cmp22 = icmp slt i32 %call21, 0
  br i1 %cmp22, label %cleanup, label %if.end24

if.end24:                                         ; preds = %for.end
  br label %for.cond25

for.cond25:                                       ; preds = %for.body27, %if.end24
  %i.1 = phi i32 [ 0, %if.end24 ], [ %inc32, %for.body27 ]
  %cmp26 = icmp ult i32 %i.1, %num_eps
  br i1 %cmp26, label %for.body27, label %cleanup

for.body27:                                       ; preds = %for.cond25
  %idxprom28 = sext i32 %i.1 to i64
  %arrayidx29 = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %eps, i64 %idxprom28
  %12 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx29, align 8, !tbaa !52
  %streams30 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %12, i32 0, i32 10
  store i32 %call21, i32* %streams30, align 8, !tbaa !174
  %inc32 = add nsw i32 %i.1, 1
  br label %for.cond25

cleanup:                                          ; preds = %for.cond25, %for.end, %if.end13, %for.body, %if.end5, %if.end, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ -22, %lor.lhs.false ], [ -22, %entry ], [ -22, %if.end ], [ -19, %if.end5 ], [ -22, %for.body ], [ -22, %if.end13 ], [ %call21, %for.end ], [ %call21, %for.cond25 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_bulk(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 2
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_map_urb_for_dma(%struct.usb_hcd.712* %hcd, %struct.urb* %urb, i32 %mem_flags) #0 {
entry:
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !250
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %0, i32 0, i32 0
  %call = call i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %desc)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end27

if.then:                                          ; preds = %entry
  %self = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %uses_pio_for_control = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 4
  %1 = load i8, i8* %uses_pio_for_control, align 1, !tbaa !424
  %tobool1 = icmp ne i8 %1, 0
  br i1 %tobool1, label %cleanup195, label %if.end

if.end:                                           ; preds = %if.then
  %self3 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %uses_dma = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self3, i32 0, i32 3
  %2 = load i8, i8* %uses_dma, align 8, !tbaa !413
  %conv = zext i8 %2 to i32
  %tobool4 = icmp ne i32 %conv, 0
  br i1 %tobool4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end
  %self6 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self6, i32 0, i32 0
  %3 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !356
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 21
  %4 = load i8*, i8** %setup_packet, align 8, !tbaa !425
  %call7 = call i64 @dma_map_single_attrs(%struct.device* %3, i8* %4, i64 8, i32 1, i64 0)
  %setup_dma = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 22
  store i64 %call7, i64* %setup_dma, align 8, !tbaa !400
  %self8 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller9 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self8, i32 0, i32 0
  %5 = load %struct.device*, %struct.device** %controller9, align 8, !tbaa !356
  %setup_dma10 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 22
  %6 = load i64, i64* %setup_dma10, align 8, !tbaa !400
  %call11 = call i32 @dma_mapping_error(%struct.device* %5, i64 %6)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %cleanup195, label %if.end14

if.end14:                                         ; preds = %if.then5
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %7 = load i32, i32* %transfer_flags, align 4, !tbaa !379
  %or = or i32 %7, 1048576
  store i32 %or, i32* %transfer_flags, align 4, !tbaa !379
  br label %if.end27

if.else:                                          ; preds = %if.end
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %8 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %flags = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %8, i32 0, i32 4
  %9 = load i32, i32* %flags, align 8, !tbaa !376
  %and = and i32 %9, 2
  %tobool15 = icmp ne i32 %and, 0
  br i1 %tobool15, label %if.then16, label %if.end27

if.then16:                                        ; preds = %if.else
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %10 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !242
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %10, i32 0, i32 9
  %11 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %setup_dma17 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 22
  %setup_packet18 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 21
  %call19 = call i32 @hcd_alloc_coherent(%struct.usb_bus* %11, i32 %mem_flags, i64* %setup_dma17, i8** %setup_packet18, i64 8, i32 1)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %cleanup195, label %if.end22

if.end22:                                         ; preds = %if.then16
  %transfer_flags23 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %12 = load i32, i32* %transfer_flags23, align 4, !tbaa !379
  %or24 = or i32 %12, 2097152
  store i32 %or24, i32* %transfer_flags23, align 4, !tbaa !379
  br label %if.end27

if.end27:                                         ; preds = %if.end22, %if.else, %if.end14, %entry
  %ret.2 = phi i32 [ 0, %entry ], [ 0, %if.end14 ], [ %call19, %if.end22 ], [ 0, %if.else ]
  %call28 = call i32 @usb_urb_dir_in(%struct.urb* %urb)
  %tobool29 = icmp ne i32 %call28, 0
  %cond = select i1 %tobool29, i32 2, i32 1
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %13 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !317
  %cmp = icmp ne i32 %13, 0
  br i1 %cmp, label %land.lhs.true, label %cleanup195

land.lhs.true:                                    ; preds = %if.end27
  %transfer_flags31 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %14 = load i32, i32* %transfer_flags31, align 4, !tbaa !379
  %and32 = and i32 %14, 4
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %cleanup195, label %if.then34

if.then34:                                        ; preds = %land.lhs.true
  %self35 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %uses_dma36 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self35, i32 0, i32 3
  %15 = load i8, i8* %uses_dma36, align 8, !tbaa !413
  %conv37 = zext i8 %15 to i32
  %tobool38 = icmp ne i32 %conv37, 0
  br i1 %tobool38, label %if.then39, label %if.else166

if.then39:                                        ; preds = %if.then34
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %16 = load i32, i32* %num_sgs, align 4, !tbaa !398
  %tobool40 = icmp ne i32 %16, 0
  br i1 %tobool40, label %if.then41, label %if.else79

if.then41:                                        ; preds = %if.then39
  %ep42 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %17 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep42, align 8, !tbaa !250
  %desc43 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %17, i32 0, i32 0
  %call44 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %desc43)
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %if.then46, label %if.end60

if.then46:                                        ; preds = %if.then41
  %tobool47 = icmp ne i32 1, 0
  %lnot = xor i1 %tobool47, true
  %lnot48 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot48 to i32
  %conv49 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv49, i64 0)
  %tobool50 = icmp ne i64 %expval, 0
  br i1 %tobool50, label %if.then51, label %if.end52

if.then51:                                        ; preds = %if.then46
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i32 1556)
  br label %if.end52

if.end52:                                         ; preds = %if.then51, %if.then46
  br label %LeafBlock

if.end60:                                         ; preds = %if.then41
  %self61 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller62 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self61, i32 0, i32 0
  %18 = load %struct.device*, %struct.device** %controller62, align 8, !tbaa !356
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 16
  %19 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8, !tbaa !397
  %num_sgs63 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %20 = load i32, i32* %num_sgs63, align 4, !tbaa !398
  %call64 = call i32 @dma_map_sg_attrs(%struct.device* %18, %struct.scatterlist* %19, i32 %20, i32 %cond, i64 0)
  %cmp65 = icmp sle i32 %call64, 0
  br i1 %cmp65, label %if.end71, label %if.else68

if.else68:                                        ; preds = %if.end60
  %transfer_flags69 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %21 = load i32, i32* %transfer_flags69, align 4, !tbaa !379
  %or70 = or i32 %21, 262144
  store i32 %or70, i32* %transfer_flags69, align 4, !tbaa !379
  br label %if.end71

if.end71:                                         ; preds = %if.else68, %if.end60
  %ret.3 = phi i32 [ %ret.2, %if.else68 ], [ -11, %if.end60 ]
  %num_mapped_sgs = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 17
  store i32 %call64, i32* %num_mapped_sgs, align 8, !tbaa !426
  %num_sgs72 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %22 = load i32, i32* %num_sgs72, align 4, !tbaa !398
  %cmp73 = icmp ne i32 %call64, %22
  br i1 %cmp73, label %if.then75, label %LeafBlock

if.then75:                                        ; preds = %if.end71
  %transfer_flags76 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %23 = load i32, i32* %transfer_flags76, align 4, !tbaa !379
  %or77 = or i32 %23, 4194304
  store i32 %or77, i32* %transfer_flags76, align 4, !tbaa !379
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.then75, %if.end71, %if.end52
  %ret.4 = phi i32 [ %ret.2, %if.end52 ], [ %ret.3, %if.then75 ], [ %ret.3, %if.end71 ]
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.end52 ], [ 0, %if.then75 ], [ 0, %if.end71 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end186, label %cleanup195

if.else79:                                        ; preds = %if.then39
  %sg80 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 16
  %24 = load %struct.scatterlist*, %struct.scatterlist** %sg80, align 8, !tbaa !397
  %tobool81 = icmp ne %struct.scatterlist* %24, null
  br i1 %tobool81, label %if.then82, label %if.else102

if.then82:                                        ; preds = %if.else79
  %sg84 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 16
  %25 = load %struct.scatterlist*, %struct.scatterlist** %sg84, align 8, !tbaa !397
  %self85 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller86 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self85, i32 0, i32 0
  %26 = load %struct.device*, %struct.device** %controller86, align 8, !tbaa !356
  %call87 = call %struct.page* @sg_page(%struct.scatterlist* %25)
  %offset = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %25, i32 0, i32 2
  %27 = load i32, i32* %offset, align 8, !tbaa !427
  %conv88 = zext i32 %27 to i64
  %transfer_buffer_length89 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %28 = load i32, i32* %transfer_buffer_length89, align 8, !tbaa !317
  %conv90 = zext i32 %28 to i64
  %call91 = call i64 @dma_map_page_attrs(%struct.device* %26, %struct.page* %call87, i64 %conv88, i64 %conv90, i32 %cond, i64 0)
  %transfer_dma = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 15
  store i64 %call91, i64* %transfer_dma, align 8, !tbaa !399
  %self92 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller93 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self92, i32 0, i32 0
  %29 = load %struct.device*, %struct.device** %controller93, align 8, !tbaa !356
  %transfer_dma94 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 15
  %30 = load i64, i64* %transfer_dma94, align 8, !tbaa !399
  %call95 = call i32 @dma_mapping_error(%struct.device* %29, i64 %30)
  %tobool96 = icmp ne i32 %call95, 0
  br i1 %tobool96, label %if.end186, label %if.else98

if.else98:                                        ; preds = %if.then82
  %transfer_flags99 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %31 = load i32, i32* %transfer_flags99, align 4, !tbaa !379
  %or100 = or i32 %31, 131072
  store i32 %or100, i32* %transfer_flags99, align 4, !tbaa !379
  br label %if.end186

if.else102:                                       ; preds = %if.else79
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %32 = load i8*, i8** %transfer_buffer, align 8, !tbaa !316
  %call103 = call zeroext i1 @is_vmalloc_addr(i8* %32)
  br i1 %call103, label %if.then104, label %if.else145

if.then104:                                       ; preds = %if.else102
  %tobool105 = icmp ne i32 1, 0
  br i1 %tobool105, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then104
  %33 = load i8, i8* @usb_hcd_map_urb_for_dma.__warned, align 1, !tbaa !109, !range !110
  %tobool106 = trunc i8 %33 to i1
  %lnot107 = xor i1 %tobool106, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then104
  %34 = phi i1 [ false, %if.then104 ], [ %lnot107, %land.rhs ]
  %lnot109 = xor i1 %34, true
  %lnot111 = xor i1 %lnot109, true
  %lnot.ext112 = zext i1 %lnot111 to i32
  %conv113 = sext i32 %lnot.ext112 to i64
  %expval114 = call i64 @llvm.expect.i64(i64 %conv113, i64 0)
  %tobool115 = icmp ne i64 %expval114, 0
  br i1 %tobool115, label %if.then116, label %if.end136

if.then116:                                       ; preds = %land.end
  store i8 1, i8* @usb_hcd_map_urb_for_dma.__warned, align 1, !tbaa !109
  %tobool118 = icmp ne i32 1, 0
  %lnot119 = xor i1 %tobool118, true
  %lnot121 = xor i1 %lnot119, true
  %lnot.ext122 = zext i1 %lnot121 to i32
  %conv123 = sext i32 %lnot.ext122 to i64
  %expval124 = call i64 @llvm.expect.i64(i64 %conv123, i64 0)
  %tobool125 = icmp ne i64 %expval124, 0
  br i1 %tobool125, label %if.then126, label %if.end127

if.then126:                                       ; preds = %if.then116
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i32 1587, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6.117, i32 0, i32 0))
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %if.then116
  br label %if.end136

if.end136:                                        ; preds = %if.end127, %land.end
  br label %if.end186

if.else145:                                       ; preds = %if.else102
  %self146 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller147 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self146, i32 0, i32 0
  %35 = load %struct.device*, %struct.device** %controller147, align 8, !tbaa !356
  %transfer_buffer148 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %36 = load i8*, i8** %transfer_buffer148, align 8, !tbaa !316
  %transfer_buffer_length149 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %37 = load i32, i32* %transfer_buffer_length149, align 8, !tbaa !317
  %conv150 = zext i32 %37 to i64
  %call151 = call i64 @dma_map_single_attrs(%struct.device* %35, i8* %36, i64 %conv150, i32 %cond, i64 0)
  %transfer_dma152 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 15
  store i64 %call151, i64* %transfer_dma152, align 8, !tbaa !399
  %self153 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller154 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self153, i32 0, i32 0
  %38 = load %struct.device*, %struct.device** %controller154, align 8, !tbaa !356
  %transfer_dma155 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 15
  %39 = load i64, i64* %transfer_dma155, align 8, !tbaa !399
  %call156 = call i32 @dma_mapping_error(%struct.device* %38, i64 %39)
  %tobool157 = icmp ne i32 %call156, 0
  br i1 %tobool157, label %if.end186, label %if.else159

if.else159:                                       ; preds = %if.else145
  %transfer_flags160 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %40 = load i32, i32* %transfer_flags160, align 4, !tbaa !379
  %or161 = or i32 %40, 65536
  store i32 %or161, i32* %transfer_flags160, align 4, !tbaa !379
  br label %if.end186

if.else166:                                       ; preds = %if.then34
  %driver167 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %41 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver167, align 8, !tbaa !57
  %flags168 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %41, i32 0, i32 4
  %42 = load i32, i32* %flags168, align 8, !tbaa !376
  %and169 = and i32 %42, 2
  %tobool170 = icmp ne i32 %and169, 0
  br i1 %tobool170, label %if.then171, label %if.end186

if.then171:                                       ; preds = %if.else166
  %dev172 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %43 = load %struct.usb_device*, %struct.usb_device** %dev172, align 8, !tbaa !242
  %bus173 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %43, i32 0, i32 9
  %44 = load %struct.usb_bus*, %struct.usb_bus** %bus173, align 8, !tbaa !2
  %transfer_dma174 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 15
  %transfer_buffer175 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %transfer_buffer_length176 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %45 = load i32, i32* %transfer_buffer_length176, align 8, !tbaa !317
  %conv177 = zext i32 %45 to i64
  %call178 = call i32 @hcd_alloc_coherent(%struct.usb_bus* %44, i32 %mem_flags, i64* %transfer_dma174, i8** %transfer_buffer175, i64 %conv177, i32 %cond)
  %cmp179 = icmp eq i32 %call178, 0
  br i1 %cmp179, label %if.then181, label %if.end186

if.then181:                                       ; preds = %if.then171
  %transfer_flags182 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %46 = load i32, i32* %transfer_flags182, align 4, !tbaa !379
  %or183 = or i32 %46, 524288
  store i32 %or183, i32* %transfer_flags182, align 4, !tbaa !379
  br label %if.end186

if.end186:                                        ; preds = %if.then181, %if.then171, %if.else166, %if.else159, %if.else145, %if.end136, %if.else98, %if.then82, %LeafBlock
  %ret.11 = phi i32 [ %ret.4, %LeafBlock ], [ %ret.2, %if.else98 ], [ -11, %if.then82 ], [ -11, %if.end136 ], [ %ret.2, %if.else159 ], [ -11, %if.else145 ], [ %ret.2, %if.else166 ], [ %call178, %if.then181 ], [ %call178, %if.then171 ]
  %tobool187 = icmp ne i32 %ret.11, 0
  br i1 %tobool187, label %land.lhs.true188, label %cleanup195

land.lhs.true188:                                 ; preds = %if.end186
  %transfer_flags189 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %47 = load i32, i32* %transfer_flags189, align 4, !tbaa !379
  %and190 = and i32 %47, 3145728
  %tobool191 = icmp ne i32 %and190, 0
  br i1 %tobool191, label %if.then192, label %cleanup195

if.then192:                                       ; preds = %land.lhs.true188
  call void @usb_hcd_unmap_urb_for_dma(%struct.usb_hcd.712* %hcd, %struct.urb* %urb)
  br label %cleanup195

cleanup195:                                       ; preds = %if.then192, %land.lhs.true188, %if.end186, %LeafBlock, %land.lhs.true, %if.end27, %if.then16, %if.then5, %if.then
  %retval.1 = phi i32 [ 0, %if.then ], [ -11, %if.then5 ], [ %call19, %if.then16 ], [ %ret.2, %land.lhs.true ], [ %ret.2, %if.end27 ], [ %ret.11, %if.then192 ], [ %ret.11, %land.lhs.true188 ], [ %ret.11, %if.end186 ], [ -22, %LeafBlock ]
  ret i32 %retval.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @dma_map_single_attrs(%struct.device* %dev, i8* %ptr, i64 %size, i32 %dir, i64 %attrs) #1 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  call void @kmemcheck_mark_initialized()
  %call1 = call i32 @valid_dma_direction(i32 %dir)
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %do.body6, label %do.end11

do.body6:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.1.564, i32 0, i32 0), i32 209, i64 12) #8, !srcloc !429
  br label %do.body7

do.body7:                                         ; preds = %do.body7, %do.body6
  br label %do.body7

do.end11:                                         ; preds = %entry
  %map_page = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 4
  %0 = load i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)** %map_page, align 8, !tbaa !430
  %1 = load i64, i64* @vmemmap_base, align 8, !tbaa !53
  %2 = inttoptr i64 %1 to %struct.page*
  %3 = ptrtoint i8* %ptr to i64
  %call12 = call i64 @__phys_addr(i64 %3)
  %shr = lshr i64 %call12, 12
  %add.ptr = getelementptr inbounds %struct.page, %struct.page* %2, i64 %shr
  %4 = ptrtoint i8* %ptr to i64
  %and = and i64 %4, 4095
  %call13 = call i64 %0(%struct.device* %dev, %struct.page* %add.ptr, i64 %and, i64 %size, i32 %dir, i64 %attrs)
  %5 = load i64, i64* @vmemmap_base, align 8, !tbaa !53
  %6 = inttoptr i64 %5 to %struct.page*
  %7 = ptrtoint i8* %ptr to i64
  %call14 = call i64 @__phys_addr(i64 %7)
  %shr15 = lshr i64 %call14, 12
  %add.ptr16 = getelementptr inbounds %struct.page, %struct.page* %6, i64 %shr15
  %8 = ptrtoint i8* %ptr to i64
  %and17 = and i64 %8, 4095
  call void @debug_dma_map_page(%struct.device* %dev, %struct.page* %add.ptr16, i64 %and17, i64 %size, i32 %dir, i64 %call13, i1 zeroext true)
  ret i64 %call13
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @dma_mapping_error(%struct.device* %dev, i64 %dma_addr) #1 {
entry:
  call void @debug_dma_mapping_error(%struct.device* %dev, i64 %dma_addr)
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  %mapping_error = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 14
  %0 = load i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)** %mapping_error, align 8, !tbaa !431
  %tobool = icmp ne i32 (%struct.device*, i64)* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  %mapping_error2 = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call1, i32 0, i32 14
  %1 = load i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)** %mapping_error2, align 8, !tbaa !431
  %call3 = call i32 %1(%struct.device* %dev, i64 %dma_addr)
  br label %return

if.end:                                           ; preds = %entry
  %cmp = icmp eq i64 %dma_addr, 0
  %conv = zext i1 %cmp to i32
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call3, %if.then ], [ %conv, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @hcd_alloc_coherent(%struct.usb_bus* %bus, i32 %mem_flags, i64* %dma_handle, i8** %vaddr_handle, i64 %size, i32 %dir) #0 {
entry:
  %0 = load i8*, i8** %vaddr_handle, align 8, !tbaa !52
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.then, label %if.end31

if.then:                                          ; preds = %entry
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then
  %1 = load i8, i8* @hcd_alloc_coherent.__warned, align 1, !tbaa !109, !range !110
  %tobool1 = trunc i8 %1 to i1
  %lnot = xor i1 %tobool1, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then
  %2 = phi i1 [ false, %if.then ], [ %lnot, %land.rhs ]
  %lnot2 = xor i1 %2, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then5, label %if.end22

if.then5:                                         ; preds = %land.end
  store i8 1, i8* @hcd_alloc_coherent.__warned, align 1, !tbaa !109
  %tobool6 = icmp ne i32 1, 0
  %lnot7 = xor i1 %tobool6, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %conv11 = sext i32 %lnot.ext10 to i64
  %expval12 = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool13 = icmp ne i64 %expval12, 0
  br i1 %tobool13, label %if.then14, label %if.end

if.then14:                                        ; preds = %if.then5
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i32 1390)
  br label %if.end

if.end:                                           ; preds = %if.then14, %if.then5
  br label %if.end22

if.end22:                                         ; preds = %if.end, %land.end
  br label %cleanup

if.end31:                                         ; preds = %entry
  %add = add i64 %size, 8
  %call = call i8* @hcd_buffer_alloc(%struct.usb_bus* %bus, i64 %add, i32 %mem_flags, i64* %dma_handle)
  %tobool32 = icmp ne i8* %call, null
  br i1 %tobool32, label %if.end34, label %cleanup

if.end34:                                         ; preds = %if.end31
  %add.ptr = getelementptr inbounds i8, i8* %call, i64 %size
  %3 = bitcast i8* %add.ptr to i64*
  %4 = load i8*, i8** %vaddr_handle, align 8, !tbaa !52
  %5 = ptrtoint i8* %4 to i64
  store i64 %5, i64* %3, align 8, !tbaa !86
  %cmp35 = icmp eq i32 %dir, 1
  br i1 %cmp35, label %if.then37, label %if.end39

if.then37:                                        ; preds = %if.end34
  %6 = load i8*, i8** %vaddr_handle, align 8, !tbaa !52
  %call38 = call i8* @__memcpy(i8* %call, i8* %6, i64 %size)
  br label %if.end39

if.end39:                                         ; preds = %if.then37, %if.end34
  store i8* %call, i8** %vaddr_handle, align 8, !tbaa !52
  br label %cleanup

cleanup:                                          ; preds = %if.end39, %if.end31, %if.end22
  %retval.0 = phi i32 [ -14, %if.end22 ], [ 0, %if.end39 ], [ -12, %if.end31 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 1
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @dma_map_sg_attrs(%struct.device* %dev, %struct.scatterlist* %sg, i32 %nents, i32 %dir, i64 %attrs) #1 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %s.0 = phi %struct.scatterlist* [ %sg, %entry ], [ %call2, %for.body ]
  %cmp = icmp slt i32 %i.0, %nents
  br i1 %cmp, label %for.body, label %do.body

for.body:                                         ; preds = %for.cond
  call void @sg_virt(%struct.scatterlist* %s.0)
  call void @kmemcheck_mark_initialized()
  %inc = add nsw i32 %i.0, 1
  %call2 = call %struct.scatterlist* @sg_next(%struct.scatterlist* %s.0)
  br label %for.cond

do.body:                                          ; preds = %for.cond
  %call3 = call i32 @valid_dma_direction(i32 %dir)
  %tobool = icmp ne i32 %call3, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %do.body7, label %do.end12

do.body7:                                         ; preds = %do.body
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.1.564, i32 0, i32 0), i32 246, i64 12) #8, !srcloc !432
  br label %do.body8

do.body8:                                         ; preds = %do.body8, %do.body7
  br label %do.body8

do.end12:                                         ; preds = %do.body
  %map_sg = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 6
  %0 = load i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)** %map_sg, align 8, !tbaa !433
  %call13 = call i32 %0(%struct.device* %dev, %struct.scatterlist* %sg, i32 %nents, i32 %dir, i64 %attrs)
  %cmp15 = icmp slt i32 %call13, 0
  %lnot17 = xor i1 %cmp15, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool23 = icmp ne i64 %expval22, 0
  br i1 %tobool23, label %do.body25, label %do.end33

do.body25:                                        ; preds = %do.end12
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.1.564, i32 0, i32 0), i32 248, i64 12) #8, !srcloc !434
  br label %do.body26

do.body26:                                        ; preds = %do.body26, %do.body25
  br label %do.body26

do.end33:                                         ; preds = %do.end12
  call void @debug_dma_map_sg(%struct.device* %dev, %struct.scatterlist* %sg, i32 %nents, i32 %call13, i32 %dir)
  ret i32 %call13
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.page* @sg_page(%struct.scatterlist* %sg) #1 {
entry:
  %sg_magic = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 0
  %0 = load i64, i64* %sg_magic, align 8, !tbaa !435
  %cmp = icmp ne i64 %0, 2271560481
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.body8

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.37.737, i32 0, i32 0), i32 123, i64 12) #8, !srcloc !436
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.body8:                                         ; preds = %entry
  %page_link = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %1 = load i64, i64* %page_link, align 8, !tbaa !437
  %and = and i64 %1, 1
  %tobool9 = icmp ne i64 %and, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %do.body18, label %do.end26

do.body18:                                        ; preds = %do.body8
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.37.737, i32 0, i32 0), i32 124, i64 12) #8, !srcloc !438
  br label %do.body19

do.body19:                                        ; preds = %do.body19, %do.body18
  br label %do.body19

do.end26:                                         ; preds = %do.body8
  %page_link27 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %2 = load i64, i64* %page_link27, align 8, !tbaa !437
  %and28 = and i64 %2, -4
  %3 = inttoptr i64 %and28 to %struct.page*
  ret %struct.page* %3
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @dma_map_page_attrs(%struct.device* %dev, %struct.page* %page, i64 %offset, i64 %size, i32 %dir, i64 %attrs) #1 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  call void @kmemcheck_mark_initialized()
  %call2 = call i32 @valid_dma_direction(i32 %dir)
  %tobool = icmp ne i32 %call2, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv5, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %do.body7, label %do.end12

do.body7:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.1.564, i32 0, i32 0), i32 276, i64 12) #8, !srcloc !439
  br label %do.body8

do.body8:                                         ; preds = %do.body8, %do.body7
  br label %do.body8

do.end12:                                         ; preds = %entry
  %map_page = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 4
  %0 = load i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)** %map_page, align 8, !tbaa !430
  %call13 = call i64 %0(%struct.device* %dev, %struct.page* %page, i64 %offset, i64 %size, i32 %dir, i64 %attrs)
  call void @debug_dma_map_page(%struct.device* %dev, %struct.page* %page, i64 %offset, i64 %size, i32 %dir, i64 %call13, i1 zeroext false)
  ret i64 %call13
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @is_vmalloc_addr(i8* %x) #1 {
entry:
  %0 = ptrtoint i8* %x to i64
  %1 = load i64, i64* @vmalloc_base, align 8, !tbaa !53
  %cmp = icmp uge i64 %0, %1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load i64, i64* @vmalloc_base, align 8, !tbaa !53
  %add = add i64 %2, 35184372088831
  %cmp1 = icmp ult i64 %0, %add
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  ret i1 %3
}

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @kmemcheck_mark_initialized() #1 {
entry:
  ret void
}

declare void @debug_dma_map_page(%struct.device*, %struct.page*, i64, i64, i32, i64, i1 zeroext) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_virt(%struct.scatterlist* %sg) #1 {
entry:
  %call = call %struct.page* @sg_page(%struct.scatterlist* %sg)
  ret void
}

declare %struct.scatterlist* @sg_next(%struct.scatterlist*) #2

declare void @debug_dma_map_sg(%struct.device*, %struct.scatterlist*, i32, i32, i32) #2

declare void @debug_dma_mapping_error(%struct.device*, i64) #2

declare i64 @__phys_addr(i64) #2

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_check_unlink_urb(%struct.usb_hcd.712* %hcd, %struct.urb* %urb, i32 %status) #0 {
entry:
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !250
  %urb_list = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %0, i32 0, i32 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %.sink = phi %struct.list_head* [ %1, %for.inc ], [ %urb_list, %entry ]
  %next5 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next5, align 8, !tbaa !252
  %ep1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %2 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep1, align 8, !tbaa !250
  %urb_list2 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %2, i32 0, i32 4
  %cmp = icmp eq %struct.list_head* %1, %urb_list2
  %urb_list3 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 5
  %cmp4 = icmp eq %struct.list_head* %1, %urb_list3
  %or.cond = or i1 %cmp, %cmp4
  br i1 %or.cond, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.cond
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %urb_list6 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 5
  %cmp7 = icmp ne %struct.list_head* %1, %urb_list6
  br i1 %cmp7, label %cleanup, label %if.end9

if.end9:                                          ; preds = %for.end
  %unlinked = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 4
  %3 = load i32, i32* %unlinked, align 8, !tbaa !374
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %if.end11

if.end11:                                         ; preds = %if.end9
  %unlinked12 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 4
  store i32 %status, i32* %unlinked12, align 8, !tbaa !374
  br label %cleanup

cleanup:                                          ; preds = %if.end11, %if.end9, %for.end
  %retval.0 = phi i32 [ 0, %if.end11 ], [ -43, %for.end ], [ -16, %if.end9 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_link_urb_to_ep(%struct.usb_hcd.712* %hcd, %struct.urb* %urb) #0 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  call void @_raw_spin_lock(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_urb_list_lock, i32 0, i32 0, i32 0)) #8
  %reject = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 3
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %reject, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %0 = load volatile i32, i32* %counter.i, align 4, !tbaa !73
  %1 = bitcast i8* %arraydecay.i to i32*
  store i32 %0, i32* %1, align 4, !tbaa !73
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %2 = load i32, i32* %__val.i, align 4, !tbaa !72
  %tobool = icmp ne i32 %2, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %done, label %if.end

if.end:                                           ; preds = %entry
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %3 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !250
  %enabled = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %3, i32 0, i32 9
  %4 = load i32, i32* %enabled, align 4, !tbaa !440
  %tobool3 = icmp ne i32 %4, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv10 = sext i32 %lnot.ext9 to i64
  %expval11 = call i64 @llvm.expect.i64(i64 %conv10, i64 0)
  %tobool12 = icmp ne i64 %expval11, 0
  br i1 %tobool12, label %done, label %if.end14

if.end14:                                         ; preds = %if.end
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %5 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !242
  %can_submit = getelementptr inbounds %struct.usb_device, %struct.usb_device* %5, i32 0, i32 22
  %bf.load = load i16, i16* %can_submit, align 4
  %bf.clear = and i16 %bf.load, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool15 = icmp ne i32 %bf.cast, 0
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  %expval23 = call i64 @llvm.expect.i64(i64 %conv22, i64 0)
  %tobool24 = icmp ne i64 %expval23, 0
  br i1 %tobool24, label %done, label %if.end26

if.end26:                                         ; preds = %if.end14
  %flags = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  %6 = load i64, i64* %flags, align 8, !tbaa !84
  %and = and i64 %6, 32
  %tobool27 = icmp ne i64 %and, 0
  br i1 %tobool27, label %if.then28, label %done

if.then28:                                        ; preds = %if.end26
  %unlinked = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 4
  store i32 0, i32* %unlinked, align 8, !tbaa !374
  %urb_list = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 5
  %ep29 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %7 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep29, align 8, !tbaa !250
  %urb_list30 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %7, i32 0, i32 4
  call void @list_add_tail.72(%struct.list_head* %urb_list, %struct.list_head* %urb_list30)
  br label %done

done:                                             ; preds = %if.then28, %if.end26, %if.end14, %if.end, %entry
  %rc.0 = phi i32 [ 0, %if.then28 ], [ -1, %entry ], [ -2, %if.end ], [ -113, %if.end14 ], [ -108, %if.end26 ]
  call void @_raw_spin_unlock(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_urb_list_lock, i32 0, i32 0, i32 0)) #8
  ret i32 %rc.0
}

; Function Attrs: nounwind uwtable
define i64 @usb_calc_bus_time(i32 %speed, i32 %is_input, i32 %isoc, i32 %bytecount) #0 {
entry:
  %Pivot4 = icmp slt i32 %speed, 2
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %speed, 3
  br i1 %Pivot, label %sw.bb13, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %speed, 3
  br i1 %SwitchLeaf2, label %sw.bb35, label %do.body

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %speed, 1
  br i1 %SwitchLeaf, label %sw.bb, label %do.body

sw.bb:                                            ; preds = %LeafBlock
  %tobool = icmp ne i32 %is_input, 0
  %mul = mul nsw i32 56, %bytecount
  %div = sdiv i32 %mul, 6
  %conv = sext i32 %div to i64
  %mul1 = mul nsw i64 10, %conv
  %add = add nsw i64 31, %mul1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %mul2 = mul nsw i64 67667, %add
  %div3 = sdiv i64 %mul2, 1000
  %add4 = add i64 65726, %div3
  br label %cleanup

if.else:                                          ; preds = %sw.bb
  %mul10 = mul nsw i64 66700, %add
  %div11 = sdiv i64 %mul10, 1000
  %add12 = add i64 65773, %div11
  br label %cleanup

sw.bb13:                                          ; preds = %NodeBlock
  %tobool14 = icmp ne i32 %isoc, 0
  %mul16 = mul nsw i32 56, %bytecount
  %div17 = sdiv i32 %mul16, 6
  %conv18 = sext i32 %div17 to i64
  %mul19 = mul nsw i64 10, %conv18
  %add20 = add nsw i64 31, %mul19
  %mul21 = mul nsw i64 8354, %add20
  %div22 = sdiv i64 %mul21, 1000
  br i1 %tobool14, label %if.then15, label %if.else26

if.then15:                                        ; preds = %sw.bb13
  %tobool23 = icmp ne i32 %is_input, 0
  %cond = select i1 %tobool23, i64 7268, i64 6265
  %add24 = add nsw i64 %cond, 1000
  %add25 = add i64 %add24, %div22
  br label %cleanup

if.else26:                                        ; preds = %sw.bb13
  %add34 = add i64 10107, %div22
  br label %cleanup

sw.bb35:                                          ; preds = %LeafBlock1
  %tobool36 = icmp ne i32 %isoc, 0
  %mul38 = mul nsw i32 56, %bytecount
  %div39 = sdiv i32 %mul38, 6
  %add40 = add nsw i32 3, %div39
  %conv41 = sext i32 %add40 to i64
  %mul42 = mul i64 2083, %conv41
  %.sink = select i1 %tobool36, i64 633232, i64 916520
  %add52 = add i64 %.sink, %mul42
  %div53 = udiv i64 %add52, 1000
  %add54 = add i64 %div53, 5
  br label %cleanup

do.body:                                          ; preds = %LeafBlock, %LeafBlock1
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_calc_bus_time.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool55 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool55, true
  %lnot56 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot56 to i32
  %conv57 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv57, i64 0)
  %tobool58 = icmp ne i64 %expval, 0
  br i1 %tobool58, label %if.then59, label %cleanup

if.then59:                                        ; preds = %do.body
  %0 = load i8*, i8** @usbcore_name, align 8, !tbaa !52
  call void (%struct._ddebug*, i8*, ...) @__dynamic_pr_debug(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_calc_bus_time.descriptor to %struct._ddebug*), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.5.119, i32 0, i32 0), i8* %0)
  br label %cleanup

cleanup:                                          ; preds = %if.then59, %do.body, %sw.bb35, %if.else26, %if.then15, %if.else, %if.then
  %retval.0 = phi i64 [ %add4, %if.then ], [ %add12, %if.else ], [ %add25, %if.then15 ], [ %add34, %if.else26 ], [ %add54, %sw.bb35 ], [ -1, %if.then59 ], [ -1, %do.body ]
  ret i64 %retval.0
}

declare void @__dynamic_pr_debug(%struct._ddebug*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define void @usb_hcd_end_port_resume(%struct.usb_bus* %bus, i32 %portnum) #0 {
entry:
  %shl = shl i32 1, %portnum
  %resuming_ports = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 16
  %0 = load i32, i32* %resuming_ports, align 4, !tbaa !441
  %and = and i32 %0, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %neg = xor i32 %shl, -1
  %resuming_ports1 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 16
  %1 = load i32, i32* %resuming_ports1, align 4, !tbaa !441
  %and2 = and i32 %1, %neg
  store i32 %and2, i32* %resuming_ports1, align 4, !tbaa !441
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 11
  %2 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !264
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @pm_runtime_put_noidle(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put_noidle(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %usage_count = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 12
  call void @atomic_add_unless(%struct.atomic_t* %usage_count, i32 -1, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_add_unless(%struct.atomic_t* %v, i32 %a, i32 %u) #1 {
entry:
  %__u.i.i = alloca %struct.atomic_t, align 4
  %counter.i.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %__c.i.i = bitcast %struct.atomic_t* %__u.i.i to [1 x i8]*
  %arraydecay.i.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i.i, i32 0, i32 0
  %0 = load volatile i32, i32* %counter.i.i, align 4, !tbaa !73
  %1 = bitcast i8* %arraydecay.i.i to i32*
  store i32 %0, i32* %1, align 4, !tbaa !73
  %__val.i.i = bitcast %struct.atomic_t* %__u.i.i to i32*
  %2 = load i32, i32* %__val.i.i, align 4, !tbaa !72
  br label %for.cond.i

for.cond.i:                                       ; preds = %if.end13.i, %entry
  %c.0.i = phi i32 [ %2, %entry ], [ %3, %if.end13.i ]
  %cmp.i = icmp eq i32 %c.0.i, %u
  %lnot.ext.i = zext i1 %cmp.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv.i, i64 0) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %__atomic_add_unless.exit, label %if.end.i

if.end.i:                                         ; preds = %for.cond.i
  %add.i = add nsw i32 %c.0.i, %a
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %3 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; cmpxchgl $2,$1", "={ax},=*m,r,0,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32 %add.i, i32 %c.0.i, i32* %counter.i) #8, !srcloc !442
  %cmp3.i = icmp eq i32 %3, %c.0.i
  %lnot.ext8.i = zext i1 %cmp3.i to i32
  %conv9.i = sext i32 %lnot.ext8.i to i64
  %expval10.i = call i64 @llvm.expect.i64(i64 %conv9.i, i64 1) #8
  %tobool11.i = icmp ne i64 %expval10.i, 0
  br i1 %tobool11.i, label %__atomic_add_unless.exit, label %if.end13.i

if.end13.i:                                       ; preds = %if.end.i
  br label %for.cond.i

__atomic_add_unless.exit:                         ; preds = %if.end.i, %for.cond.i
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_start_port_resume(%struct.usb_bus* %bus, i32 %portnum) #0 {
entry:
  %shl = shl i32 1, %portnum
  %resuming_ports = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 16
  %0 = load i32, i32* %resuming_ports, align 4, !tbaa !441
  %and = and i32 %0, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %resuming_ports1 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 16
  %1 = load i32, i32* %resuming_ports1, align 4, !tbaa !441
  %or = or i32 %1, %shl
  store i32 %or, i32* %resuming_ports1, align 4, !tbaa !441
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 11
  %2 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !264
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @pm_runtime_get_noresume.120(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_get_noresume.120(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %usage_count = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 12
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %usage_count, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !443
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_submit_urb(%struct.urb* %urb, i32 %mem_flags) #0 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !242
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %1)
  %call1 = call %struct.urb* bitcast (%struct.urb.744* (%struct.urb.744*)* @usb_get_urb to %struct.urb* (%struct.urb*)*)(%struct.urb* %urb)
  %use_count = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 2
  %counter.i4 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %use_count, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i4, i32* %counter.i4) #8, !srcloc !443
  %dev2 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %2 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8, !tbaa !242
  %urbnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 30
  %counter.i3 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %urbnum, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i3, i32* %counter.i3) #8, !srcloc !443
  %self = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 0
  call void @usbmon_urb_submit(%struct.usb_bus* %self, %struct.urb* %urb)
  %dev3 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %3 = load %struct.usb_device*, %struct.usb_device** %dev3, align 8, !tbaa !242
  %call4 = call i32 @is_root_hub(%struct.usb_device* %3)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call5 = call i32 @rh_urb_enqueue(%struct.usb_hcd.712* %call, %struct.urb* %urb)
  br label %if.end21

if.else:                                          ; preds = %entry
  %call6 = call i32 @map_urb_for_dma(%struct.usb_hcd.712* %call, %struct.urb* %urb, i32 %mem_flags)
  %cmp = icmp eq i32 %call6, 0
  %lnot = xor i1 %cmp, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then9, label %if.end21

if.then9:                                         ; preds = %if.else
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %4 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %urb_enqueue = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %4, i32 0, i32 12
  %5 = load i32 (%struct.usb_hcd.712*, %struct.urb*, i32)*, i32 (%struct.usb_hcd.712*, %struct.urb*, i32)** %urb_enqueue, align 8, !tbaa !444
  %call10 = call i32 %5(%struct.usb_hcd.712* %call, %struct.urb* %urb, i32 %mem_flags)
  %tobool11 = icmp ne i32 %call10, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.then9
  call void @unmap_urb_for_dma(%struct.usb_hcd.712* %call, %struct.urb* %urb)
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %if.then9, %if.else, %if.then
  %status.1 = phi i32 [ %call5, %if.then ], [ %call6, %if.else ], [ %call10, %if.then19 ], [ %call10, %if.then9 ]
  %tobool22 = icmp ne i32 %status.1, 0
  %lnot23 = xor i1 %tobool22, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %conv27 = sext i32 %lnot.ext26 to i64
  %expval28 = call i64 @llvm.expect.i64(i64 %conv27, i64 0)
  %tobool29 = icmp ne i64 %expval28, 0
  br i1 %tobool29, label %if.then30, label %if.end39

if.then30:                                        ; preds = %if.end21
  %self31 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 0
  call void @usbmon_urb_submit_error(%struct.usb_bus* %self31, %struct.urb* %urb, i32 %status.1)
  %hcpriv = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 1
  store i8* null, i8** %hcpriv, align 8, !tbaa !378
  %urb_list = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 5
  call void @INIT_LIST_HEAD.80(%struct.list_head* %urb_list)
  %use_count32 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 2
  %counter.i1 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %use_count32, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i1, i32* %counter.i1) #8, !srcloc !380
  %dev33 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %6 = load %struct.usb_device*, %struct.usb_device** %dev33, align 8, !tbaa !242
  %urbnum34 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 30
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %urbnum34, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !380
  %reject = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 3
  %counter.i2 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %reject, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %7 = load volatile i32, i32* %counter.i2, align 4, !tbaa !73
  %8 = bitcast i8* %arraydecay.i to i32*
  store i32 %7, i32* %8, align 4, !tbaa !73
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %9 = load i32, i32* %__val.i, align 4, !tbaa !72
  %tobool36 = icmp ne i32 %9, 0
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.then30
  call void @__wake_up(%struct.__wait_queue_head* @usb_kill_urb_queue, i32 3, i32 1, i8* null)
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %if.then30
  call void bitcast (void (%struct.urb.744*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %urb)
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end21
  ret i32 %status.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usbmon_urb_submit(%struct.usb_bus* %bus, %struct.urb* %urb) #1 {
entry:
  %monitored = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 18
  %0 = load i32, i32* %monitored, align 8, !tbaa !383
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.usb_mon_operations*, %struct.usb_mon_operations** @mon_ops, align 8, !tbaa !52
  %urb_submit = getelementptr inbounds %struct.usb_mon_operations, %struct.usb_mon_operations* %1, i32 0, i32 0
  %2 = load void (%struct.usb_bus*, %struct.urb*)*, void (%struct.usb_bus*, %struct.urb*)** %urb_submit, align 8, !tbaa !445
  call void %2(%struct.usb_bus* %bus, %struct.urb* %urb)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rh_urb_enqueue(%struct.usb_hcd.712* %hcd, %struct.urb* %urb) #0 {
entry:
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !250
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %0, i32 0, i32 0
  %call = call i32 @usb_endpoint_xfer_int.122(%struct.usb_endpoint_descriptor* %desc)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 @rh_queue_status(%struct.usb_hcd.712* %hcd, %struct.urb* %urb)
  br label %return

if.end:                                           ; preds = %entry
  %ep2 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %1 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep2, align 8, !tbaa !250
  %desc3 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %1, i32 0, i32 0
  %call4 = call i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %desc3)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %return

if.then6:                                         ; preds = %if.end
  %call7 = call i32 @rh_call_control(%struct.usb_hcd.712* %hcd, %struct.urb* %urb)
  br label %return

return:                                           ; preds = %if.then6, %if.end, %if.then
  %retval.0 = phi i32 [ %call1, %if.then ], [ %call7, %if.then6 ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @map_urb_for_dma(%struct.usb_hcd.712* %hcd, %struct.urb* %urb, i32 %mem_flags) #0 {
entry:
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %0 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %map_urb_for_dma = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %0, i32 0, i32 14
  %1 = load i32 (%struct.usb_hcd.712*, %struct.urb*, i32)*, i32 (%struct.usb_hcd.712*, %struct.urb*, i32)** %map_urb_for_dma, align 8, !tbaa !446
  %tobool = icmp ne i32 (%struct.usb_hcd.712*, %struct.urb*, i32)* %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %driver1 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %2 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver1, align 8, !tbaa !57
  %map_urb_for_dma2 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %2, i32 0, i32 14
  %3 = load i32 (%struct.usb_hcd.712*, %struct.urb*, i32)*, i32 (%struct.usb_hcd.712*, %struct.urb*, i32)** %map_urb_for_dma2, align 8, !tbaa !446
  %call = call i32 %3(%struct.usb_hcd.712* %hcd, %struct.urb* %urb, i32 %mem_flags)
  br label %return

if.else:                                          ; preds = %entry
  %call3 = call i32 @usb_hcd_map_urb_for_dma(%struct.usb_hcd.712* %hcd, %struct.urb* %urb, i32 %mem_flags)
  br label %return

return:                                           ; preds = %if.else, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %call3, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usbmon_urb_submit_error(%struct.usb_bus* %bus, %struct.urb* %urb, i32 %error) #1 {
entry:
  %monitored = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 18
  %0 = load i32, i32* %monitored, align 8, !tbaa !383
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.usb_mon_operations*, %struct.usb_mon_operations** @mon_ops, align 8, !tbaa !52
  %urb_submit_error = getelementptr inbounds %struct.usb_mon_operations, %struct.usb_mon_operations* %1, i32 0, i32 1
  %2 = load void (%struct.usb_bus*, %struct.urb*, i32)*, void (%struct.usb_bus*, %struct.urb*, i32)** %urb_submit_error, align 8, !tbaa !447
  call void %2(%struct.usb_bus* %bus, %struct.urb* %urb, i32 %error)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_int.122(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 3
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define internal i32 @rh_queue_status(%struct.usb_hcd.712* %hcd, %struct.urb* %urb) #0 {
entry:
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !242
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %1 = load i32, i32* %maxchild, align 8, !tbaa !111
  %div = sdiv i32 %1, 8
  %add = add nsw i32 1, %div
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0))
  %status_urb = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 6
  %2 = load %struct.urb*, %struct.urb** %status_urb, align 8, !tbaa !372
  %tobool = icmp ne %struct.urb* %2, null
  br i1 %tobool, label %do.body9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %3 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !317
  %cmp6 = icmp ult i32 %3, %add
  br i1 %cmp6, label %do.body9, label %if.end19

do.body9:                                         ; preds = %lor.lhs.false, %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @rh_queue_status.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool10 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv12 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv12, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  br i1 %tobool13, label %if.then14, label %done

if.then14:                                        ; preds = %do.body9
  %self = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %4 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !356
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @rh_queue_status.descriptor to %struct._ddebug*), %struct.device* %4, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.56.127, i32 0, i32 0))
  br label %done

if.end19:                                         ; preds = %lor.lhs.false
  %call20 = call i32 @usb_hcd_link_urb_to_ep(%struct.usb_hcd.712* %hcd, %struct.urb* %urb)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %done, label %if.end23

if.end23:                                         ; preds = %if.end19
  %status_urb24 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 6
  store %struct.urb* %urb, %struct.urb** %status_urb24, align 8, !tbaa !372
  %5 = bitcast %struct.usb_hcd.712* %hcd to i8*
  %hcpriv = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 1
  store i8* %5, i8** %hcpriv, align 8, !tbaa !378
  %uses_new_polling = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load25 = load i16, i16* %uses_new_polling, align 8
  %bf.lshr26 = lshr i16 %bf.load25, 4
  %bf.clear27 = and i16 %bf.lshr26, 1
  %bf.cast = zext i16 %bf.clear27 to i32
  %tobool28 = icmp ne i32 %bf.cast, 0
  br i1 %tobool28, label %if.else, label %if.then29

if.then29:                                        ; preds = %if.end23
  %rh_timer = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 5
  %6 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  %div30 = udiv i64 %6, 62
  %add31 = add i64 %div30, 1
  %mul = mul i64 %add31, 62
  %call32 = call i32 @mod_timer(%struct.timer_list* %rh_timer, i64 %mul)
  br label %done

if.else:                                          ; preds = %if.end23
  %flags33 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 11
  %7 = load i64, i64* %flags33, align 8, !tbaa !84
  %and34 = and i64 %7, 8
  %tobool35 = icmp ne i64 %and34, 0
  br i1 %tobool35, label %if.then36, label %done

if.then36:                                        ; preds = %if.else
  %rh_timer37 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 5
  %8 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  %call38 = call i32 @mod_timer(%struct.timer_list* %rh_timer37, i64 %8)
  br label %done

done:                                             ; preds = %if.then36, %if.else, %if.then29, %if.end19, %if.then14, %do.body9
  %retval1.0 = phi i32 [ -22, %if.then14 ], [ -22, %do.body9 ], [ %call20, %if.end19 ], [ 0, %if.else ], [ 0, %if.then36 ], [ 0, %if.then29 ]
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0), i64 %call3) #8
  ret i32 %retval1.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rh_call_control(%struct.usb_hcd.712* %hcd, %struct.urb* %urb) #0 {
entry:
  %__UNIQUE_ID_min1_18 = alloca i16, align 2
  %__UNIQUE_ID_min2_19 = alloca i16, align 2
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %0 = load i8*, i8** %transfer_buffer, align 8, !tbaa !316
  call void @__might_sleep(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i32 499, i32 0)
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0)) #8
  %call = call i32 @usb_hcd_link_urb_to_ep(%struct.usb_hcd.712* %hcd, %struct.urb* %urb)
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0)) #8
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = bitcast %struct.usb_hcd.712* %hcd to i8*
  %hcpriv = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 1
  store i8* %1, i8** %hcpriv, align 8, !tbaa !378
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 21
  %2 = load i8*, i8** %setup_packet, align 8, !tbaa !425
  %3 = bitcast i8* %2 to %struct.usb_ctrlrequest*
  %bRequestType = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %3, i32 0, i32 0
  %4 = load i8, i8* %bRequestType, align 1, !tbaa !448
  %conv = zext i8 %4 to i32
  %shl = shl i32 %conv, 8
  %bRequest = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %3, i32 0, i32 1
  %5 = load i8, i8* %bRequest, align 1, !tbaa !450
  %conv4 = zext i8 %5 to i32
  %or = or i32 %shl, %conv4
  %conv5 = trunc i32 %or to i16
  %wValue6 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %3, i32 0, i32 2
  %6 = load i16, i16* %wValue6, align 1, !tbaa !451
  %wIndex7 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %3, i32 0, i32 3
  %7 = load i16, i16* %wIndex7, align 1, !tbaa !452
  %wLength8 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %3, i32 0, i32 4
  %8 = load i16, i16* %wLength8, align 1, !tbaa !453
  %conv9 = zext i16 %8 to i32
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %9 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !317
  %cmp = icmp ugt i32 %conv9, %9
  br i1 %cmp, label %sw.epilog169, label %if.end12

if.end12:                                         ; preds = %if.end
  store i16 15, i16* %__UNIQUE_ID_min1_18, align 2, !tbaa !165
  store i16 %8, i16* %__UNIQUE_ID_min2_19, align 2, !tbaa !165
  %10 = load i16, i16* %__UNIQUE_ID_min1_18, align 2, !tbaa !165
  %conv15 = zext i16 %10 to i32
  %11 = load i16, i16* %__UNIQUE_ID_min2_19, align 2, !tbaa !165
  %conv16 = zext i16 %11 to i32
  %cmp17 = icmp sgt i32 %conv15, %conv16
  %12 = load i16, i16* %__UNIQUE_ID_min2_19, align 2
  %13 = load i16, i16* %__UNIQUE_ID_min1_18, align 2
  %.sink = select i1 %cmp17, i16 %13, i16 %12
  %conv20 = zext i16 %.sink to i32
  %conv21 = trunc i32 %conv20 to i16
  %conv22 = zext i16 %conv21 to i64
  %call23 = call i8* @kzalloc.103(i64 %conv22, i32 20971712)
  %tobool24 = icmp ne i8* %call23, null
  br i1 %tobool24, label %if.end26, label %err_alloc

if.end26:                                         ; preds = %if.end12
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  store i32 0, i32* %actual_length, align 4, !tbaa !315
  %conv27 = zext i16 %conv5 to i32
  %Pivot42 = icmp slt i32 %conv27, 259
  br i1 %Pivot42, label %NodeBlock17, label %NodeBlock39

NodeBlock39:                                      ; preds = %if.end26
  %Pivot40 = icmp slt i32 %conv27, 32776
  br i1 %Pivot40, label %NodeBlock27, label %NodeBlock37

NodeBlock37:                                      ; preds = %NodeBlock39
  %Pivot38 = icmp slt i32 %conv27, 32778
  br i1 %Pivot38, label %LeafBlock29, label %NodeBlock35

NodeBlock35:                                      ; preds = %NodeBlock37
  %Pivot36 = icmp slt i32 %conv27, 33024
  br i1 %Pivot36, label %LeafBlock31, label %LeafBlock33

LeafBlock33:                                      ; preds = %NodeBlock35
  %SwitchLeaf34 = icmp eq i32 %conv27, 33024
  br i1 %SwitchLeaf34, label %sw.bb123, label %nongeneric

LeafBlock31:                                      ; preds = %NodeBlock35
  %SwitchLeaf32 = icmp eq i32 %conv27, 32778
  br i1 %SwitchLeaf32, label %sw.bb102, label %nongeneric

LeafBlock29:                                      ; preds = %NodeBlock37
  %SwitchLeaf30 = icmp eq i32 %conv27, 32776
  br i1 %SwitchLeaf30, label %sw.bb60, label %nongeneric

NodeBlock27:                                      ; preds = %NodeBlock39
  %Pivot28 = icmp slt i32 %conv27, 32768
  br i1 %Pivot28, label %LeafBlock19, label %NodeBlock25

NodeBlock25:                                      ; preds = %NodeBlock27
  %Pivot26 = icmp slt i32 %conv27, 32774
  br i1 %Pivot26, label %LeafBlock21, label %LeafBlock23

LeafBlock23:                                      ; preds = %NodeBlock25
  %SwitchLeaf24 = icmp eq i32 %conv27, 32774
  br i1 %SwitchLeaf24, label %sw.bb62, label %nongeneric

LeafBlock21:                                      ; preds = %NodeBlock25
  %SwitchLeaf22 = icmp eq i32 %conv27, 32768
  br i1 %SwitchLeaf22, label %sw.bb, label %nongeneric

LeafBlock19:                                      ; preds = %NodeBlock27
  %SwitchLeaf20 = icmp eq i32 %conv27, 259
  br i1 %SwitchLeaf20, label %do.body128, label %nongeneric

NodeBlock17:                                      ; preds = %if.end26
  %Pivot18 = icmp slt i32 %conv27, 9
  br i1 %Pivot18, label %NodeBlock5, label %NodeBlock15

NodeBlock15:                                      ; preds = %NodeBlock17
  %Pivot16 = icmp slt i32 %conv27, 11
  br i1 %Pivot16, label %LeafBlock7, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %conv27, 257
  br i1 %Pivot14, label %LeafBlock9, label %LeafBlock11

LeafBlock11:                                      ; preds = %NodeBlock13
  %SwitchLeaf12 = icmp eq i32 %conv27, 257
  br i1 %SwitchLeaf12, label %do.body128, label %nongeneric

LeafBlock9:                                       ; preds = %NodeBlock13
  %SwitchLeaf10 = icmp eq i32 %conv27, 11
  br i1 %SwitchLeaf10, label %sw.epilog169, label %nongeneric

LeafBlock7:                                       ; preds = %NodeBlock15
  %SwitchLeaf8 = icmp eq i32 %conv27, 9
  br i1 %SwitchLeaf8, label %sw.epilog169, label %nongeneric

NodeBlock5:                                       ; preds = %NodeBlock17
  %Pivot6 = icmp slt i32 %conv27, 3
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %conv27, 5
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %conv27, 5
  br i1 %SwitchLeaf4, label %do.body106, label %nongeneric

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv27, 3
  br i1 %SwitchLeaf2, label %sw.bb44, label %nongeneric

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %conv27, 1
  br i1 %SwitchLeaf, label %sw.bb34, label %nongeneric

sw.bb:                                            ; preds = %LeafBlock21
  %self = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 11
  %14 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !175
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %14, i32 0, i32 11
  %call28 = call zeroext i1 @device_may_wakeup(%struct.device* %dev)
  %conv29 = zext i1 %call28 to i32
  %shl30 = shl i32 %conv29, 1
  %or31 = or i32 %shl30, 1
  %conv32 = trunc i32 %or31 to i8
  %arrayidx = getelementptr inbounds i8, i8* %call23, i64 0
  store i8 %conv32, i8* %arrayidx, align 1, !tbaa !72
  %arrayidx33 = getelementptr inbounds i8, i8* %call23, i64 1
  store i8 0, i8* %arrayidx33, align 1, !tbaa !72
  br label %sw.epilog169

sw.bb34:                                          ; preds = %LeafBlock
  %conv35 = zext i16 %6 to i32
  %cmp36 = icmp eq i32 %conv35, 1
  br i1 %cmp36, label %if.then38, label %sw.epilog169

if.then38:                                        ; preds = %sw.bb34
  %self39 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %root_hub40 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self39, i32 0, i32 11
  %15 = load %struct.usb_device*, %struct.usb_device** %root_hub40, align 8, !tbaa !175
  %dev41 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %15, i32 0, i32 11
  %call42 = call i32 @device_set_wakeup_enable(%struct.device* %dev41, i1 zeroext false)
  br label %sw.epilog169

sw.bb44:                                          ; preds = %LeafBlock1
  %self45 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %root_hub46 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self45, i32 0, i32 11
  %16 = load %struct.usb_device*, %struct.usb_device** %root_hub46, align 8, !tbaa !175
  %dev47 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %16, i32 0, i32 11
  %call48 = call zeroext i1 @device_can_wakeup(%struct.device* %dev47)
  %conv50 = zext i16 %6 to i32
  %cmp51 = icmp eq i32 %conv50, 1
  %or.cond = and i1 %call48, %cmp51
  br i1 %or.cond, label %if.then53, label %sw.epilog169

if.then53:                                        ; preds = %sw.bb44
  %self54 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %root_hub55 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self54, i32 0, i32 11
  %17 = load %struct.usb_device*, %struct.usb_device** %root_hub55, align 8, !tbaa !175
  %dev56 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %17, i32 0, i32 11
  %call57 = call i32 @device_set_wakeup_enable(%struct.device* %dev56, i1 zeroext true)
  br label %sw.epilog169

sw.bb60:                                          ; preds = %LeafBlock29
  %arrayidx61 = getelementptr inbounds i8, i8* %call23, i64 0
  store i8 1, i8* %arrayidx61, align 1, !tbaa !72
  br label %sw.epilog169

sw.bb62:                                          ; preds = %LeafBlock23
  %conv63 = zext i16 %6 to i32
  %and = and i32 %conv63, 65280
  %Pivot57 = icmp slt i32 %and, 768
  br i1 %Pivot57, label %NodeBlock48, label %NodeBlock54

NodeBlock54:                                      ; preds = %sw.bb62
  %Pivot55 = icmp slt i32 %and, 3840
  br i1 %Pivot55, label %LeafBlock50, label %LeafBlock52

LeafBlock52:                                      ; preds = %NodeBlock54
  %SwitchLeaf53 = icmp eq i32 %and, 3840
  br i1 %SwitchLeaf53, label %nongeneric, label %sw.epilog169

LeafBlock50:                                      ; preds = %NodeBlock54
  %SwitchLeaf51 = icmp eq i32 %and, 768
  br i1 %SwitchLeaf51, label %sw.bb86, label %sw.epilog169

NodeBlock48:                                      ; preds = %sw.bb62
  %Pivot49 = icmp slt i32 %and, 512
  br i1 %Pivot49, label %LeafBlock44, label %LeafBlock46

LeafBlock46:                                      ; preds = %NodeBlock48
  %SwitchLeaf47 = icmp eq i32 %and, 512
  br i1 %SwitchLeaf47, label %sw.bb73, label %sw.epilog169

LeafBlock44:                                      ; preds = %NodeBlock48
  %SwitchLeaf45 = icmp eq i32 %and, 256
  br i1 %SwitchLeaf45, label %sw.bb64, label %sw.epilog169

sw.bb64:                                          ; preds = %LeafBlock44
  %speed = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 3
  %18 = load i32, i32* %speed, align 8, !tbaa !363
  %Pivot76 = icmp slt i32 %18, 48
  br i1 %Pivot76, label %NodeBlock63, label %NodeBlock73

NodeBlock73:                                      ; preds = %sw.bb64
  %Pivot74 = icmp slt i32 %18, 64
  br i1 %Pivot74, label %LeafBlock65, label %NodeBlock71

NodeBlock71:                                      ; preds = %NodeBlock73
  %Pivot72 = icmp slt i32 %18, 80
  br i1 %Pivot72, label %LeafBlock67, label %LeafBlock69

LeafBlock69:                                      ; preds = %NodeBlock71
  %SwitchLeaf70 = icmp eq i32 %18, 80
  br i1 %SwitchLeaf70, label %sw.epilog, label %sw.epilog169

LeafBlock67:                                      ; preds = %NodeBlock71
  %SwitchLeaf68 = icmp eq i32 %18, 64
  br i1 %SwitchLeaf68, label %sw.epilog, label %sw.epilog169

LeafBlock65:                                      ; preds = %NodeBlock73
  %SwitchLeaf66 = icmp eq i32 %18, 48
  br i1 %SwitchLeaf66, label %sw.epilog, label %sw.epilog169

NodeBlock63:                                      ; preds = %sw.bb64
  %Pivot64 = icmp slt i32 %18, 32
  br i1 %Pivot64, label %LeafBlock59, label %LeafBlock61

LeafBlock61:                                      ; preds = %NodeBlock63
  %SwitchLeaf62 = icmp eq i32 %18, 32
  br i1 %SwitchLeaf62, label %sw.epilog, label %sw.epilog169

LeafBlock59:                                      ; preds = %NodeBlock63
  %SwitchLeaf60 = icmp eq i32 %18, 16
  br i1 %SwitchLeaf60, label %sw.epilog, label %sw.epilog169

sw.epilog:                                        ; preds = %LeafBlock59, %LeafBlock61, %LeafBlock65, %LeafBlock67, %LeafBlock69
  %bufp.0 = phi i8* [ getelementptr inbounds ([18 x i8], [18 x i8]* @usb31_rh_dev_descriptor, i32 0, i32 0), %LeafBlock69 ], [ getelementptr inbounds ([18 x i8], [18 x i8]* @usb3_rh_dev_descriptor, i32 0, i32 0), %LeafBlock67 ], [ getelementptr inbounds ([18 x i8], [18 x i8]* @usb25_rh_dev_descriptor, i32 0, i32 0), %LeafBlock65 ], [ getelementptr inbounds ([18 x i8], [18 x i8]* @usb2_rh_dev_descriptor, i32 0, i32 0), %LeafBlock61 ], [ getelementptr inbounds ([18 x i8], [18 x i8]* @usb11_rh_dev_descriptor, i32 0, i32 0), %LeafBlock59 ]
  %has_tt = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load = load i16, i16* %has_tt, align 8
  %bf.lshr = lshr i16 %bf.load, 6
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool70 = icmp ne i32 %bf.cast, 0
  %. = select i1 %tobool70, i8 1, i8 0
  br label %sw.epilog169

sw.bb73:                                          ; preds = %LeafBlock46
  %speed74 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 3
  %19 = load i32, i32* %speed74, align 8, !tbaa !363
  %Pivot95 = icmp slt i32 %19, 48
  br i1 %Pivot95, label %NodeBlock82, label %NodeBlock92

NodeBlock92:                                      ; preds = %sw.bb73
  %Pivot93 = icmp slt i32 %19, 64
  br i1 %Pivot93, label %LeafBlock84, label %NodeBlock90

NodeBlock90:                                      ; preds = %NodeBlock92
  %Pivot91 = icmp slt i32 %19, 80
  br i1 %Pivot91, label %LeafBlock86, label %LeafBlock88

LeafBlock88:                                      ; preds = %NodeBlock90
  %SwitchLeaf89 = icmp eq i32 %19, 80
  br i1 %SwitchLeaf89, label %sw.epilog79, label %sw.epilog169

LeafBlock86:                                      ; preds = %NodeBlock90
  %SwitchLeaf87 = icmp eq i32 %19, 64
  br i1 %SwitchLeaf87, label %sw.epilog79, label %sw.epilog169

LeafBlock84:                                      ; preds = %NodeBlock92
  %SwitchLeaf85 = icmp eq i32 %19, 48
  br i1 %SwitchLeaf85, label %sw.epilog79, label %sw.epilog169

NodeBlock82:                                      ; preds = %sw.bb73
  %Pivot83 = icmp slt i32 %19, 32
  br i1 %Pivot83, label %LeafBlock78, label %LeafBlock80

LeafBlock80:                                      ; preds = %NodeBlock82
  %SwitchLeaf81 = icmp eq i32 %19, 32
  br i1 %SwitchLeaf81, label %sw.epilog79, label %sw.epilog169

LeafBlock78:                                      ; preds = %NodeBlock82
  %SwitchLeaf79 = icmp eq i32 %19, 16
  br i1 %SwitchLeaf79, label %sw.epilog79, label %sw.epilog169

sw.epilog79:                                      ; preds = %LeafBlock78, %LeafBlock80, %LeafBlock84, %LeafBlock86, %LeafBlock88
  %len.0 = phi i32 [ 31, %LeafBlock88 ], [ 31, %LeafBlock86 ], [ 25, %LeafBlock84 ], [ 25, %LeafBlock80 ], [ 25, %LeafBlock78 ]
  %bufp.1 = phi i8* [ getelementptr inbounds ([31 x i8], [31 x i8]* @ss_rh_config_descriptor, i32 0, i32 0), %LeafBlock88 ], [ getelementptr inbounds ([31 x i8], [31 x i8]* @ss_rh_config_descriptor, i32 0, i32 0), %LeafBlock86 ], [ getelementptr inbounds ([25 x i8], [25 x i8]* @hs_rh_config_descriptor, i32 0, i32 0), %LeafBlock84 ], [ getelementptr inbounds ([25 x i8], [25 x i8]* @hs_rh_config_descriptor, i32 0, i32 0), %LeafBlock80 ], [ getelementptr inbounds ([25 x i8], [25 x i8]* @fs_rh_config_descriptor, i32 0, i32 0), %LeafBlock78 ]
  %self80 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %root_hub81 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self80, i32 0, i32 11
  %20 = load %struct.usb_device*, %struct.usb_device** %root_hub81, align 8, !tbaa !175
  %dev82 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %20, i32 0, i32 11
  %call83 = call zeroext i1 @device_can_wakeup(%struct.device* %dev82)
  %.111 = select i1 %call83, i8 1, i8 0
  br label %sw.epilog169

sw.bb86:                                          ; preds = %LeafBlock50
  %conv87 = zext i16 %6 to i32
  %and88 = and i32 %conv87, 255
  %cmp89 = icmp slt i32 %and88, 4
  br i1 %cmp89, label %if.then91, label %sw.epilog169

if.then91:                                        ; preds = %sw.bb86
  %conv92 = zext i16 %6 to i32
  %and93 = and i32 %conv92, 255
  %conv94 = zext i16 %8 to i32
  %call95 = call i32 @rh_string(i32 %and93, %struct.usb_hcd.712* %hcd, i8* %0, i32 %conv94)
  %actual_length96 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  store i32 %call95, i32* %actual_length96, align 4, !tbaa !315
  br label %sw.epilog169

sw.bb102:                                         ; preds = %LeafBlock31
  %arrayidx103 = getelementptr inbounds i8, i8* %call23, i64 0
  store i8 0, i8* %arrayidx103, align 1, !tbaa !72
  br label %sw.epilog169

do.body106:                                       ; preds = %LeafBlock3
  %bf.load107 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @rh_call_control.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr108 = lshr i32 %bf.load107, 18
  %bf.clear109 = and i32 %bf.lshr108, 255
  %and110 = and i32 %bf.clear109, 1
  %tobool111 = icmp ne i32 %and110, 0
  %lnot = xor i1 %tobool111, true
  %lnot112 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot112 to i32
  %conv113 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv113, i64 0)
  %tobool114 = icmp ne i64 %expval, 0
  br i1 %tobool114, label %if.then115, label %sw.epilog169

if.then115:                                       ; preds = %do.body106
  %self116 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self116, i32 0, i32 0
  %21 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !356
  %conv117 = zext i16 %6 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @rh_call_control.descriptor to %struct._ddebug*), %struct.device* %21, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.57.123, i32 0, i32 0), i32 %conv117)
  br label %sw.epilog169

sw.bb123:                                         ; preds = %LeafBlock33
  %arrayidx124 = getelementptr inbounds i8, i8* %call23, i64 0
  store i8 0, i8* %arrayidx124, align 1, !tbaa !72
  %arrayidx125 = getelementptr inbounds i8, i8* %call23, i64 1
  store i8 0, i8* %arrayidx125, align 1, !tbaa !72
  br label %do.body128

do.body128:                                       ; preds = %sw.bb123, %LeafBlock11, %LeafBlock19
  %len.2 = phi i32 [ 0, %LeafBlock11 ], [ 0, %LeafBlock19 ], [ 2, %sw.bb123 ]
  %bf.load129 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @rh_call_control.descriptor.58 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr130 = lshr i32 %bf.load129, 18
  %bf.clear131 = and i32 %bf.lshr130, 255
  %and132 = and i32 %bf.clear131, 1
  %tobool133 = icmp ne i32 %and132, 0
  %lnot134 = xor i1 %tobool133, true
  %lnot136 = xor i1 %lnot134, true
  %lnot.ext137 = zext i1 %lnot136 to i32
  %conv138 = sext i32 %lnot.ext137 to i64
  %expval139 = call i64 @llvm.expect.i64(i64 %conv138, i64 0)
  %tobool140 = icmp ne i64 %expval139, 0
  br i1 %tobool140, label %if.then141, label %sw.epilog169

if.then141:                                       ; preds = %do.body128
  %self142 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller143 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self142, i32 0, i32 0
  %22 = load %struct.device*, %struct.device** %controller143, align 8, !tbaa !356
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @rh_call_control.descriptor.58 to %struct._ddebug*), %struct.device* %22, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.59.124, i32 0, i32 0))
  br label %sw.epilog169

nongeneric:                                       ; preds = %LeafBlock52, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock7, %LeafBlock9, %LeafBlock11, %LeafBlock19, %LeafBlock21, %LeafBlock23, %LeafBlock29, %LeafBlock31, %LeafBlock33
  %conv150 = zext i16 %conv5 to i32
  %Pivot110 = icmp slt i32 %conv150, 40966
  br i1 %Pivot110, label %NodeBlock101, label %NodeBlock107

NodeBlock107:                                     ; preds = %nongeneric
  %Pivot108 = icmp slt i32 %conv150, 41728
  br i1 %Pivot108, label %LeafBlock103, label %LeafBlock105

LeafBlock105:                                     ; preds = %NodeBlock107
  %SwitchLeaf106 = icmp eq i32 %conv150, 41728
  br i1 %SwitchLeaf106, label %sw.bb152, label %NewDefault96

LeafBlock103:                                     ; preds = %NodeBlock107
  %SwitchLeaf104 = icmp eq i32 %conv150, 40966
  br i1 %SwitchLeaf104, label %sw.epilog160, label %NewDefault96

NodeBlock101:                                     ; preds = %nongeneric
  %Pivot102 = icmp slt i32 %conv150, 40960
  br i1 %Pivot102, label %LeafBlock97, label %LeafBlock99

LeafBlock99:                                      ; preds = %NodeBlock101
  %SwitchLeaf100 = icmp eq i32 %conv150, 40960
  br i1 %SwitchLeaf100, label %sw.epilog160, label %NewDefault96

LeafBlock97:                                      ; preds = %NodeBlock101
  %SwitchLeaf98 = icmp eq i32 %conv150, 32774
  br i1 %SwitchLeaf98, label %sw.epilog160, label %NewDefault96

sw.bb152:                                         ; preds = %LeafBlock105
  %conv153 = zext i16 %6 to i32
  %cmp154 = icmp eq i32 %conv153, 0
  %.112 = select i1 %cmp154, i32 4, i32 8
  br label %sw.epilog160

NewDefault96:                                     ; preds = %LeafBlock97, %LeafBlock99, %LeafBlock103, %LeafBlock105
  br label %sw.epilog160

sw.epilog160:                                     ; preds = %NewDefault96, %sw.bb152, %LeafBlock97, %LeafBlock99, %LeafBlock103
  %len.4 = phi i32 [ 0, %LeafBlock97 ], [ 0, %NewDefault96 ], [ %.112, %sw.bb152 ], [ 4, %LeafBlock99 ], [ 15, %LeafBlock103 ]
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %23 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %hub_control = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %23, i32 0, i32 19
  %24 = load i32 (%struct.usb_hcd.712*, i16, i16, i16, i8*, i16)*, i32 (%struct.usb_hcd.712*, i16, i16, i16, i8*, i16)** %hub_control, align 8, !tbaa !454
  %call161 = call i32 %24(%struct.usb_hcd.712* %hcd, i16 zeroext %conv5, i16 zeroext %6, i16 zeroext %7, i8* %call23, i16 zeroext %8)
  %conv162 = zext i16 %conv5 to i32
  %cmp163 = icmp eq i32 %conv162, 40966
  br i1 %cmp163, label %if.then165, label %sw.epilog169

if.then165:                                       ; preds = %sw.epilog160
  %self166 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %root_hub167 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self166, i32 0, i32 11
  %25 = load %struct.usb_device*, %struct.usb_device** %root_hub167, align 8, !tbaa !175
  %26 = bitcast i8* %call23 to %struct.usb_hub_descriptor*
  call void @usb_hub_adjust_deviceremovable(%struct.usb_device* %25, %struct.usb_hub_descriptor* %26)
  br label %sw.epilog169

sw.epilog169:                                     ; preds = %if.then165, %sw.epilog160, %if.then141, %do.body128, %if.then115, %do.body106, %sw.bb102, %if.then91, %sw.bb86, %sw.epilog79, %LeafBlock78, %LeafBlock80, %LeafBlock84, %LeafBlock86, %LeafBlock88, %sw.epilog, %LeafBlock59, %LeafBlock61, %LeafBlock65, %LeafBlock67, %LeafBlock69, %LeafBlock44, %LeafBlock46, %LeafBlock50, %LeafBlock52, %sw.bb60, %if.then53, %sw.bb44, %if.then38, %sw.bb34, %sw.bb, %LeafBlock7, %LeafBlock9, %if.end
  %len.5 = phi i32 [ 0, %if.then38 ], [ 0, %if.then53 ], [ 0, %LeafBlock7 ], [ 0, %LeafBlock9 ], [ 2, %sw.bb ], [ 1, %sw.bb60 ], [ 1, %sw.bb102 ], [ 18, %sw.epilog ], [ %len.0, %sw.epilog79 ], [ 0, %if.then91 ], [ 0, %if.then115 ], [ 0, %do.body106 ], [ %len.2, %if.then141 ], [ %len.2, %do.body128 ], [ %len.4, %if.then165 ], [ %len.4, %sw.epilog160 ], [ 0, %LeafBlock52 ], [ 0, %LeafBlock50 ], [ 0, %LeafBlock46 ], [ 0, %LeafBlock44 ], [ 0, %sw.bb86 ], [ 0, %LeafBlock88 ], [ 0, %LeafBlock86 ], [ 0, %LeafBlock84 ], [ 0, %LeafBlock80 ], [ 0, %LeafBlock78 ], [ 0, %LeafBlock69 ], [ 0, %LeafBlock67 ], [ 0, %LeafBlock65 ], [ 0, %LeafBlock61 ], [ 0, %LeafBlock59 ], [ 0, %sw.bb44 ], [ 0, %sw.bb34 ], [ 0, %if.end ]
  %status.0 = phi i32 [ %call, %if.then38 ], [ %call, %if.then53 ], [ %call, %LeafBlock7 ], [ %call, %LeafBlock9 ], [ %call, %sw.bb ], [ %call, %sw.bb60 ], [ %call, %sw.bb102 ], [ %call, %if.then91 ], [ %call, %sw.epilog79 ], [ %call, %sw.epilog ], [ %call, %if.then115 ], [ %call, %do.body106 ], [ %call, %if.then141 ], [ %call, %do.body128 ], [ %call161, %if.then165 ], [ %call161, %sw.epilog160 ], [ -32, %LeafBlock52 ], [ -32, %LeafBlock50 ], [ -32, %LeafBlock46 ], [ -32, %LeafBlock44 ], [ -32, %sw.bb86 ], [ -32, %LeafBlock88 ], [ -32, %LeafBlock86 ], [ -32, %LeafBlock84 ], [ -32, %LeafBlock80 ], [ -32, %LeafBlock78 ], [ -32, %LeafBlock69 ], [ -32, %LeafBlock67 ], [ -32, %LeafBlock65 ], [ -32, %LeafBlock61 ], [ -32, %LeafBlock59 ], [ -32, %sw.bb44 ], [ -32, %sw.bb34 ], [ -32, %if.end ]
  %patch_wakeup.2 = phi i8 [ 0, %if.then38 ], [ 0, %if.then53 ], [ 0, %LeafBlock7 ], [ 0, %LeafBlock9 ], [ 0, %sw.bb ], [ 0, %sw.bb60 ], [ 0, %sw.bb102 ], [ 0, %sw.epilog ], [ %.111, %sw.epilog79 ], [ 0, %if.then91 ], [ 0, %if.then115 ], [ 0, %do.body106 ], [ 0, %if.then141 ], [ 0, %do.body128 ], [ 0, %if.then165 ], [ 0, %sw.epilog160 ], [ 0, %LeafBlock52 ], [ 0, %LeafBlock50 ], [ 0, %LeafBlock46 ], [ 0, %LeafBlock44 ], [ 0, %sw.bb86 ], [ 0, %LeafBlock88 ], [ 0, %LeafBlock86 ], [ 0, %LeafBlock84 ], [ 0, %LeafBlock80 ], [ 0, %LeafBlock78 ], [ 0, %LeafBlock69 ], [ 0, %LeafBlock67 ], [ 0, %LeafBlock65 ], [ 0, %LeafBlock61 ], [ 0, %LeafBlock59 ], [ 0, %sw.bb44 ], [ 0, %sw.bb34 ], [ 0, %if.end ]
  %patch_protocol.2 = phi i8 [ 0, %if.then38 ], [ 0, %if.then53 ], [ 0, %LeafBlock7 ], [ 0, %LeafBlock9 ], [ 0, %sw.bb ], [ 0, %sw.bb60 ], [ 0, %sw.bb102 ], [ %., %sw.epilog ], [ 0, %sw.epilog79 ], [ 0, %if.then91 ], [ 0, %if.then115 ], [ 0, %do.body106 ], [ 0, %if.then141 ], [ 0, %do.body128 ], [ 0, %if.then165 ], [ 0, %sw.epilog160 ], [ 0, %LeafBlock52 ], [ 0, %LeafBlock50 ], [ 0, %LeafBlock46 ], [ 0, %LeafBlock44 ], [ 0, %sw.bb86 ], [ 0, %LeafBlock88 ], [ 0, %LeafBlock86 ], [ 0, %LeafBlock84 ], [ 0, %LeafBlock80 ], [ 0, %LeafBlock78 ], [ 0, %LeafBlock69 ], [ 0, %LeafBlock67 ], [ 0, %LeafBlock65 ], [ 0, %LeafBlock61 ], [ 0, %LeafBlock59 ], [ 0, %sw.bb44 ], [ 0, %sw.bb34 ], [ 0, %if.end ]
  %tbuf.1 = phi i8* [ %call23, %if.then38 ], [ %call23, %if.then53 ], [ %call23, %LeafBlock7 ], [ %call23, %LeafBlock9 ], [ %call23, %sw.bb ], [ %call23, %sw.bb60 ], [ %call23, %sw.bb102 ], [ %call23, %if.then91 ], [ %call23, %sw.epilog79 ], [ %call23, %sw.epilog ], [ %call23, %if.then115 ], [ %call23, %do.body106 ], [ %call23, %if.then141 ], [ %call23, %do.body128 ], [ %call23, %if.then165 ], [ %call23, %sw.epilog160 ], [ null, %if.end ], [ %call23, %sw.bb34 ], [ %call23, %sw.bb44 ], [ %call23, %LeafBlock59 ], [ %call23, %LeafBlock61 ], [ %call23, %LeafBlock65 ], [ %call23, %LeafBlock67 ], [ %call23, %LeafBlock69 ], [ %call23, %LeafBlock78 ], [ %call23, %LeafBlock80 ], [ %call23, %LeafBlock84 ], [ %call23, %LeafBlock86 ], [ %call23, %LeafBlock88 ], [ %call23, %sw.bb86 ], [ %call23, %LeafBlock44 ], [ %call23, %LeafBlock46 ], [ %call23, %LeafBlock50 ], [ %call23, %LeafBlock52 ]
  %bufp.4 = phi i8* [ %call23, %if.then38 ], [ %call23, %if.then53 ], [ %call23, %LeafBlock7 ], [ %call23, %LeafBlock9 ], [ %call23, %sw.bb ], [ %call23, %sw.bb60 ], [ %call23, %sw.bb102 ], [ %bufp.0, %sw.epilog ], [ %bufp.1, %sw.epilog79 ], [ %call23, %if.then91 ], [ %call23, %if.then115 ], [ %call23, %do.body106 ], [ %call23, %if.then141 ], [ %call23, %do.body128 ], [ %call23, %if.then165 ], [ %call23, %sw.epilog160 ], [ undef, %if.end ], [ %call23, %sw.bb34 ], [ %call23, %sw.bb44 ], [ %call23, %LeafBlock59 ], [ %call23, %LeafBlock61 ], [ %call23, %LeafBlock65 ], [ %call23, %LeafBlock67 ], [ %call23, %LeafBlock69 ], [ %call23, %LeafBlock78 ], [ %call23, %LeafBlock80 ], [ %call23, %LeafBlock84 ], [ %call23, %LeafBlock86 ], [ %call23, %LeafBlock88 ], [ %call23, %sw.bb86 ], [ %call23, %LeafBlock44 ], [ %call23, %LeafBlock46 ], [ %call23, %LeafBlock50 ], [ %call23, %LeafBlock52 ]
  %cmp170 = icmp slt i32 %status.0, 0
  br i1 %cmp170, label %if.then172, label %if.else203

if.then172:                                       ; preds = %sw.epilog169
  %cmp173 = icmp ne i32 %status.0, -32
  br i1 %cmp173, label %do.body177, label %if.end208

do.body177:                                       ; preds = %if.then172
  %bf.load178 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @rh_call_control.descriptor.60 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr179 = lshr i32 %bf.load178, 18
  %bf.clear180 = and i32 %bf.lshr179, 255
  %and181 = and i32 %bf.clear180, 1
  %tobool182 = icmp ne i32 %and181, 0
  %lnot183 = xor i1 %tobool182, true
  %lnot185 = xor i1 %lnot183, true
  %lnot.ext186 = zext i1 %lnot185 to i32
  %conv187 = sext i32 %lnot.ext186 to i64
  %expval188 = call i64 @llvm.expect.i64(i64 %conv187, i64 0)
  %tobool189 = icmp ne i64 %expval188, 0
  br i1 %tobool189, label %if.then190, label %if.end208

if.then190:                                       ; preds = %do.body177
  %self191 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %controller192 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self191, i32 0, i32 0
  %27 = load %struct.device*, %struct.device** %controller192, align 8, !tbaa !356
  %conv193 = zext i16 %conv5 to i32
  %conv194 = zext i16 %6 to i32
  %conv195 = zext i16 %7 to i32
  %conv196 = zext i16 %8 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @rh_call_control.descriptor.60 to %struct._ddebug*), %struct.device* %27, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.61.125, i32 0, i32 0), i32 %conv193, i32 %conv194, i32 %conv195, i32 %conv196, i32 %status.0)
  br label %if.end208

if.else203:                                       ; preds = %sw.epilog169
  %cmp204 = icmp sgt i32 %status.0, 0
  %status.0.len.5 = select i1 %cmp204, i32 %status.0, i32 %len.5
  %.status.0 = select i1 %cmp204, i32 0, i32 %status.0
  br label %if.end208

if.end208:                                        ; preds = %if.else203, %if.then190, %do.body177, %if.then172
  %len.7 = phi i32 [ %status.0.len.5, %if.else203 ], [ 0, %do.body177 ], [ 0, %if.then190 ], [ 0, %if.then172 ]
  %status.2 = phi i32 [ %.status.0, %if.else203 ], [ %status.0, %do.body177 ], [ %status.0, %if.then190 ], [ %status.0, %if.then172 ]
  %tobool209 = icmp ne i32 %len.7, 0
  br i1 %tobool209, label %if.then210, label %if.end239

if.then210:                                       ; preds = %if.end208
  %transfer_buffer_length211 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %28 = load i32, i32* %transfer_buffer_length211, align 8, !tbaa !317
  %cmp212 = icmp ult i32 %28, %len.7
  br i1 %cmp212, label %if.then214, label %if.end216

if.then214:                                       ; preds = %if.then210
  %transfer_buffer_length215 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %29 = load i32, i32* %transfer_buffer_length215, align 8, !tbaa !317
  br label %if.end216

if.end216:                                        ; preds = %if.then214, %if.then210
  %len.8 = phi i32 [ %29, %if.then214 ], [ %len.7, %if.then210 ]
  %actual_length217 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  store i32 %len.8, i32* %actual_length217, align 4, !tbaa !315
  %conv218 = zext i32 %len.8 to i64
  %call219 = call i8* @__memcpy(i8* %0, i8* %bufp.4, i64 %conv218)
  %conv220 = zext i8 %patch_wakeup.2 to i32
  %tobool221 = icmp ne i32 %conv220, 0
  %conv223 = zext i32 %len.8 to i64
  %cmp224 = icmp ugt i64 %conv223, 7
  %or.cond113 = and i1 %tobool221, %cmp224
  br i1 %or.cond113, label %if.then226, label %if.end230

if.then226:                                       ; preds = %if.end216
  %30 = bitcast i8* %0 to %struct.usb_config_descriptor*
  %bmAttributes = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %30, i32 0, i32 6
  %31 = load i8, i8* %bmAttributes, align 1, !tbaa !455
  %conv227 = zext i8 %31 to i32
  %or228 = or i32 %conv227, 32
  %conv229 = trunc i32 %or228 to i8
  store i8 %conv229, i8* %bmAttributes, align 1, !tbaa !455
  br label %if.end230

if.end230:                                        ; preds = %if.then226, %if.end216
  %conv231 = zext i8 %patch_protocol.2 to i32
  %tobool232 = icmp ne i32 %conv231, 0
  %conv234 = zext i32 %len.8 to i64
  %cmp235 = icmp ugt i64 %conv234, 6
  %or.cond114 = and i1 %tobool232, %cmp235
  br i1 %or.cond114, label %if.then237, label %if.end239

if.then237:                                       ; preds = %if.end230
  %32 = bitcast i8* %0 to %struct.usb_device_descriptor*
  %bDeviceProtocol = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %32, i32 0, i32 5
  store i8 1, i8* %bDeviceProtocol, align 1, !tbaa !456
  br label %if.end239

if.end239:                                        ; preds = %if.then237, %if.end230, %if.end208
  call void @kfree(i8* %tbuf.1)
  br label %err_alloc

err_alloc:                                        ; preds = %if.end239, %if.end12
  %status.3 = phi i32 [ %status.2, %if.end239 ], [ -12, %if.end12 ]
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0)) #8
  call void @usb_hcd_unlink_urb_from_ep(%struct.usb_hcd.712* undef, %struct.urb* %urb)
  call void @usb_hcd_giveback_urb(%struct.usb_hcd.712* %hcd, %struct.urb* %urb, i32 %status.3)
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0)) #8
  br label %cleanup

cleanup:                                          ; preds = %err_alloc, %entry
  %retval.0 = phi i32 [ 0, %err_alloc ], [ %call, %entry ]
  ret i32 %retval.0
}

declare void @__might_sleep(i8*, i32, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @device_may_wakeup(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %can_wakeup = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i16, i16* %can_wakeup, align 4
  %bf.clear = and i16 %bf.load, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %power1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %wakeup = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power1, i32 0, i32 5
  %0 = load %struct.wakeup_source*, %struct.wakeup_source** %wakeup, align 8, !tbaa !457
  %tobool2 = icmp ne %struct.wakeup_source* %0, null
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %1 = phi i1 [ false, %entry ], [ %lnot3, %land.rhs ]
  ret i1 %1
}

declare i32 @device_set_wakeup_enable(%struct.device*, i1 zeroext) #2

; Function Attrs: nounwind uwtable
define internal i32 @rh_string(i32 %id, %struct.usb_hcd.712* %hcd, i8* %data, i32 %len) #0 {
entry:
  %buf = alloca [100 x i8], align 16
  %Pivot6 = icmp slt i32 %id, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %id, 3
  br i1 %Pivot4, label %sw.bb2, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %id, 3
  br i1 %SwitchLeaf2, label %sw.bb3, label %cleanup

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %id, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb1

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %id, 0
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %LeafBlock
  %cmp = icmp ugt i32 %len, 4
  %.len = select i1 %cmp, i32 4, i32 %len
  %conv = zext i32 %.len to i64
  %call = call i8* @__memcpy(i8* %data, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @rh_string.langids, i32 0, i32 0), i64 %conv)
  br label %cleanup

sw.bb1:                                           ; preds = %NodeBlock
  %self = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 0
  %bus_name = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 2
  %0 = load i8*, i8** %bus_name, align 8, !tbaa !412
  br label %sw.epilog

sw.bb2:                                           ; preds = %NodeBlock3
  %product_desc = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 2
  %1 = load i8*, i8** %product_desc, align 8, !tbaa !417
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock1
  %arraydecay = getelementptr inbounds [100 x i8], [100 x i8]* %buf, i32 0, i32 0
  %call4 = call %struct.new_utsname* @init_utsname()
  %sysname = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call4, i32 0, i32 0
  %arraydecay5 = getelementptr inbounds [65 x i8], [65 x i8]* %sysname, i32 0, i32 0
  %call6 = call %struct.new_utsname* @init_utsname()
  %release = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call6, i32 0, i32 2
  %arraydecay7 = getelementptr inbounds [65 x i8], [65 x i8]* %release, i32 0, i32 0
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %2 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %description = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %2, i32 0, i32 0
  %3 = load i8*, i8** %description, align 8, !tbaa !368
  %call8 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 100, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.62.126, i32 0, i32 0), i8* %arraydecay5, i8* %arraydecay7, i8* %3)
  %arraydecay9 = getelementptr inbounds [100 x i8], [100 x i8]* %buf, i32 0, i32 0
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb3, %sw.bb2, %sw.bb1
  %s.0 = phi i8* [ %0, %sw.bb1 ], [ %1, %sw.bb2 ], [ %arraydecay9, %sw.bb3 ]
  %call10 = call i32 @ascii2desc(i8* %s.0, i8* %data, i32 %len)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %sw.bb, %LeafBlock, %LeafBlock1
  %retval.0 = phi i32 [ %.len, %sw.bb ], [ %call10, %sw.epilog ], [ 0, %LeafBlock ], [ 0, %LeafBlock1 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.new_utsname* @init_utsname() #1 {
entry:
  ret %struct.new_utsname* getelementptr inbounds (%struct.uts_namespace, %struct.uts_namespace* @init_uts_ns, i32 0, i32 1)
}

; Function Attrs: nounwind uwtable
define internal i32 @ascii2desc(i8* %s, i8* %buf, i32 %len) #0 {
entry:
  %call = call i64 @strlen(i8* %s)
  %mul = mul i64 2, %call
  %add = add i64 2, %mul
  %conv = trunc i64 %add to i32
  %cmp = icmp ugt i32 %conv, 254
  %.conv = select i1 %cmp, i32 254, i32 %conv
  %cmp2 = icmp ugt i32 %len, %.conv
  %len.addr.0 = select i1 %cmp2, i32 %.conv, i32 %len
  %add6 = add i32 %.conv, 768
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %entry
  %t.1 = phi i32 [ %add6, %entry ], [ %conv15, %if.end11 ]
  %n.0 = phi i32 [ %len.addr.0, %entry ], [ %dec8, %if.end11 ]
  %buf.addr.0 = phi i8* [ %buf, %entry ], [ %incdec.ptr13, %if.end11 ]
  %s.addr.0 = phi i8* [ %s, %entry ], [ %incdec.ptr14, %if.end11 ]
  %dec = add i32 %n.0, -1
  %tobool = icmp ne i32 %n.0, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %conv7 = trunc i32 %t.1 to i8
  %incdec.ptr = getelementptr inbounds i8, i8* %buf.addr.0, i32 1
  store i8 %conv7, i8* %buf.addr.0, align 1, !tbaa !72
  %dec8 = add i32 %dec, -1
  %tobool9 = icmp ne i32 %dec, 0
  br i1 %tobool9, label %if.end11, label %while.end

if.end11:                                         ; preds = %while.body
  %shr = lshr i32 %t.1, 8
  %conv12 = trunc i32 %shr to i8
  %incdec.ptr13 = getelementptr inbounds i8, i8* %incdec.ptr, i32 1
  store i8 %conv12, i8* %incdec.ptr, align 1, !tbaa !72
  %incdec.ptr14 = getelementptr inbounds i8, i8* %s.addr.0, i32 1
  %0 = load i8, i8* %s.addr.0, align 1, !tbaa !72
  %conv15 = zext i8 %0 to i32
  br label %while.cond

while.end:                                        ; preds = %while.body, %while.cond
  ret i32 %len.addr.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_unlink_urb(%struct.urb* %urb, i32 %status) #0 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !242
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_urb_unlink_lock, i32 0, i32 0, i32 0))
  %use_count = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 2
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %use_count, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %1 = load volatile i32, i32* %counter.i, align 4, !tbaa !73
  %2 = bitcast i8* %arraydecay.i to i32*
  store i32 %1, i32* %2, align 4, !tbaa !73
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %3 = load i32, i32* %__val.i, align 4, !tbaa !72
  %cmp7 = icmp sgt i32 %3, 0
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call9 = call %struct.usb_device* @usb_get_dev(%struct.usb_device* %0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %retval1.0 = phi i32 [ 0, %if.then ], [ -43, %entry ]
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_urb_unlink_lock, i32 0, i32 0, i32 0), i64 %call3) #8
  %cmp10 = icmp eq i32 %retval1.0, 0
  br i1 %cmp10, label %if.then12, label %if.end38

if.then12:                                        ; preds = %if.end
  %dev13 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %4 = load %struct.usb_device*, %struct.usb_device** %dev13, align 8, !tbaa !242
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 9
  %5 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call14 = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %5)
  %call15 = call i32 @unlink1(%struct.usb_hcd.712* %call14, %struct.urb* %urb, i32 %status)
  switch i32 %call15, label %do.body25 [
    i32 0, label %if.end37
    i32 -43, label %if.end36
    i32 -16, label %if.end36
  ]

do.body25:                                        ; preds = %if.then12
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_unlink_urb.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot26 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot26 to i32
  %conv27 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv27, i64 0)
  %tobool28 = icmp ne i64 %expval, 0
  br i1 %tobool28, label %if.then29, label %if.end36

if.then29:                                        ; preds = %do.body25
  %dev30 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_unlink_urb.descriptor to %struct._ddebug*), %struct.device* %dev30, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.7.128, i32 0, i32 0), %struct.urb* %urb, i32 %call15)
  br label %if.end36

if.end36:                                         ; preds = %if.then29, %do.body25, %if.then12, %if.then12
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then12
  %retval1.1 = phi i32 [ %call15, %if.end36 ], [ -115, %if.then12 ]
  call void @usb_put_dev(%struct.usb_device* %0)
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.end
  %retval1.2 = phi i32 [ %retval1.1, %if.end37 ], [ %retval1.0, %if.end ]
  ret i32 %retval1.2
}

; Function Attrs: nounwind uwtable
define internal i32 @unlink1(%struct.usb_hcd.712* %hcd, %struct.urb* %urb, i32 %status) #0 {
entry:
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !242
  %call = call i32 @is_root_hub(%struct.usb_device* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = call i32 @usb_rh_urb_dequeue(%struct.usb_hcd.712* %hcd, %struct.urb* %urb, i32 %status)
  br label %if.end

if.else:                                          ; preds = %entry
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %1 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %urb_dequeue = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %1, i32 0, i32 13
  %2 = load i32 (%struct.usb_hcd.712*, %struct.urb*, i32)*, i32 (%struct.usb_hcd.712*, %struct.urb*, i32)** %urb_dequeue, align 8, !tbaa !458
  %call2 = call i32 %2(%struct.usb_hcd.712* %hcd, %struct.urb* %urb, i32 %status)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %value.0 = phi i32 [ %call1, %if.then ], [ %call2, %if.else ]
  ret i32 %value.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_rh_urb_dequeue(%struct.usb_hcd.712* %hcd, %struct.urb* %urb, i32 %status) #0 {
entry:
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0))
  %call5 = call i32 @usb_hcd_check_unlink_urb(%struct.usb_hcd.712* undef, %struct.urb* %urb, i32 %status)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %done, label %if.end

if.end:                                           ; preds = %entry
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !250
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %0, i32 0, i32 0
  %call6 = call i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %desc)
  %cmp7 = icmp eq i32 %call6, 0
  br i1 %cmp7, label %done, label %if.else

if.else:                                          ; preds = %if.end
  %uses_new_polling = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 12
  %bf.load = load i16, i16* %uses_new_polling, align 8
  %bf.lshr = lshr i16 %bf.load, 4
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool10 = icmp ne i32 %bf.cast, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %if.else
  %rh_timer = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 5
  %call12 = call i32 @del_timer(%struct.timer_list* %rh_timer)
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.else
  %status_urb = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 6
  %1 = load %struct.urb*, %struct.urb** %status_urb, align 8, !tbaa !372
  %cmp14 = icmp eq %struct.urb* %urb, %1
  br i1 %cmp14, label %if.then16, label %done

if.then16:                                        ; preds = %if.end13
  %status_urb17 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 6
  store %struct.urb* null, %struct.urb** %status_urb17, align 8, !tbaa !372
  call void @usb_hcd_unlink_urb_from_ep(%struct.usb_hcd.712* undef, %struct.urb* %urb)
  call void @usb_hcd_giveback_urb(%struct.usb_hcd.712* %hcd, %struct.urb* %urb, i32 %status)
  br label %done

done:                                             ; preds = %if.then16, %if.end13, %if.end, %entry
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0), i64 %call2) #8
  ret i32 %call5
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !309
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  ret i32 %and
}

declare i32 @del_timer(%struct.timer_list*) #2

; Function Attrs: nounwind uwtable
define void @usb_hcd_flush_endpoint(%struct.usb_device* %udev, %struct.usb_host_endpoint* %ep) #0 {
entry:
  %tobool = icmp ne %struct.usb_host_endpoint* %ep, null
  br i1 %tobool, label %do.body, label %cleanup.cont

do.body:                                          ; preds = %entry
  call void @__might_sleep(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i32 1874, i32 0)
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %0)
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_urb_list_lock, i32 0, i32 0, i32 0)) #8
  br label %rescan

NewDefault5:                                      ; preds = %LeafBlock6
  br label %rescan

rescan:                                           ; preds = %NewDefault5, %do.body
  %urb_list = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %rescan
  %urb_list31.sink = phi %struct.list_head* [ %urb_list31, %for.inc ], [ %urb_list, %rescan ]
  %next32 = getelementptr inbounds %struct.list_head, %struct.list_head* %urb_list31.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next32, align 8, !tbaa !52
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr34 = getelementptr inbounds i8, i8* %2, i64 -32
  %3 = bitcast i8* %add.ptr34 to %struct.urb*
  %urb_list4 = getelementptr inbounds %struct.urb, %struct.urb* %3, i32 0, i32 5
  %urb_list5 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 4
  %cmp = icmp ne %struct.list_head* %urb_list4, %urb_list5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %unlinked = getelementptr inbounds %struct.urb, %struct.urb* %3, i32 0, i32 4
  %4 = load i32, i32* %unlinked, align 8, !tbaa !374
  %tobool6 = icmp ne i32 %4, 0
  br i1 %tobool6, label %LeafBlock6, label %if.end8

if.end8:                                          ; preds = %for.body
  %call9 = call %struct.urb* bitcast (%struct.urb.744* (%struct.urb.744*)* @usb_get_urb to %struct.urb* (%struct.urb*)*)(%struct.urb* %3)
  %call10 = call i32 @usb_urb_dir_in(%struct.urb* %3)
  call void @_raw_spin_unlock(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_urb_list_lock, i32 0, i32 0, i32 0)) #8
  %call11 = call i32 @unlink1(%struct.usb_hcd.712* %call, %struct.urb* %3, i32 -108)
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_flush_endpoint.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool14 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool14, true
  %lnot15 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot15 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool16 = icmp ne i64 %expval, 0
  br i1 %tobool16, label %if.then17, label %do.end29

if.then17:                                        ; preds = %if.end8
  %self = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %5 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !356
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call18 = call i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %desc)
  %tobool19 = icmp ne i32 %call10, 0
  %cond = select i1 %tobool19, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.49.801, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.48.800, i32 0, i32 0)
  %desc20 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call21 = call i32 @usb_endpoint_type(%struct.usb_endpoint_descriptor* %desc20)
  %Pivot4 = icmp slt i32 %call21, 2
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.then17
  %Pivot = icmp slt i32 %call21, 3
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %call21, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %if.then17
  %SwitchLeaf = icmp eq i32 %call21, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock, %LeafBlock1, %NodeBlock
  %s.0 = phi i8* [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.14.132, i32 0, i32 0), %sw.default ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.28.900, i32 0, i32 0), %LeafBlock ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.12.134, i32 0, i32 0), %NodeBlock ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13.135, i32 0, i32 0), %LeafBlock1 ]
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_flush_endpoint.descriptor to %struct._ddebug*), %struct.device* %5, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.8.136, i32 0, i32 0), %struct.urb* %3, i32 %call18, i8* %cond, i8* %s.0)
  br label %do.end29

do.end29:                                         ; preds = %sw.epilog, %if.end8
  call void bitcast (void (%struct.urb.744*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %3)
  call void @_raw_spin_lock(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_urb_list_lock, i32 0, i32 0, i32 0)) #8
  br label %LeafBlock6

LeafBlock6:                                       ; preds = %do.end29, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 6, %do.end29 ], [ 9, %for.body ]
  %SwitchLeaf7 = icmp eq i32 %cleanup.dest.slot.0, 9
  br i1 %SwitchLeaf7, label %for.inc, label %NewDefault5

for.inc:                                          ; preds = %LeafBlock6
  %urb_list31 = getelementptr inbounds %struct.urb, %struct.urb* %3, i32 0, i32 5
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_urb_list_lock, i32 0, i32 0, i32 0)) #8
  br label %while.cond

while.cond:                                       ; preds = %if.end52, %for.end
  %urb_list35 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 4
  %call36 = call i32 @list_empty.93(%struct.list_head* %urb_list35)
  %tobool37 = icmp ne i32 %call36, 0
  %lnot38 = xor i1 %tobool37, true
  br i1 %lnot38, label %while.body, label %cleanup.cont

while.body:                                       ; preds = %while.cond
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_urb_list_lock, i32 0, i32 0, i32 0)) #8
  %urb_list40 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 4
  %call41 = call i32 @list_empty.93(%struct.list_head* %urb_list40)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %if.end49, label %if.then43

if.then43:                                        ; preds = %while.body
  %urb_list45 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 4
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %urb_list45, i32 0, i32 1
  %6 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !459
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr47 = getelementptr inbounds i8, i8* %7, i64 -32
  %8 = bitcast i8* %add.ptr47 to %struct.urb*
  %call48 = call %struct.urb* bitcast (%struct.urb.744* (%struct.urb.744*)* @usb_get_urb to %struct.urb* (%struct.urb*)*)(%struct.urb* %8)
  br label %if.end49

if.end49:                                         ; preds = %if.then43, %while.body
  %urb.1 = phi %struct.urb* [ null, %while.body ], [ %8, %if.then43 ]
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_urb_list_lock, i32 0, i32 0, i32 0)) #8
  %tobool50 = icmp ne %struct.urb* %urb.1, null
  br i1 %tobool50, label %if.then51, label %if.end52

if.then51:                                        ; preds = %if.end49
  call void bitcast (void (%struct.urb.744*)* @usb_kill_urb to void (%struct.urb*)*)(%struct.urb* %urb.1)
  call void bitcast (void (%struct.urb.744*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %urb.1)
  br label %if.end52

if.end52:                                         ; preds = %if.then51, %if.end49
  br label %while.cond

cleanup.cont:                                     ; preds = %while.cond, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_type(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %udev, %struct.usb_host_config* %new_config, %struct.usb_host_interface* %cur_alt, %struct.usb_host_interface* %new_alt) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %0)
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %1 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %check_bandwidth = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %1, i32 0, i32 32
  %2 = load i32 (%struct.usb_hcd.712*, %struct.usb_device*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*)** %check_bandwidth, align 8, !tbaa !460
  %tobool = icmp ne i32 (%struct.usb_hcd.712*, %struct.usb_device*)* %2, null
  br i1 %tobool, label %if.end, label %cleanup163

if.end:                                           ; preds = %entry
  %tobool1 = icmp ne %struct.usb_host_config* %new_config, null
  %tobool2 = icmp ne %struct.usb_host_interface* %cur_alt, null
  %or.cond = or i1 %tobool1, %tobool2
  br i1 %or.cond, label %if.end20, label %if.then3

if.then3:                                         ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then3
  %i.0 = phi i32 [ 1, %if.then3 ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 17
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out, i64 0, i64 %idxprom
  %3 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8, !tbaa !52
  %tobool4 = icmp ne %struct.usb_host_endpoint* %3, null
  br i1 %tobool4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %for.body
  %driver6 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %4 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver6, align 8, !tbaa !57
  %drop_endpoint = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %4, i32 0, i32 31
  %5 = load i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint*)** %drop_endpoint, align 8, !tbaa !461
  %call7 = call i32 %5(%struct.usb_hcd.712* %call, %struct.usb_device* %udev, %struct.usb_host_endpoint* %3)
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %for.body
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 16
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in, i64 0, i64 %idxprom9
  %6 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx10, align 8, !tbaa !52
  %tobool11 = icmp ne %struct.usb_host_endpoint* %6, null
  br i1 %tobool11, label %if.then12, label %for.inc

if.then12:                                        ; preds = %if.end8
  %driver13 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %7 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver13, align 8, !tbaa !57
  %drop_endpoint14 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %7, i32 0, i32 31
  %8 = load i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint*)** %drop_endpoint14, align 8, !tbaa !461
  %call15 = call i32 %8(%struct.usb_hcd.712* %call, %struct.usb_device* %udev, %struct.usb_host_endpoint* %6)
  br label %for.inc

for.inc:                                          ; preds = %if.then12, %if.end8
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %driver17 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %9 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver17, align 8, !tbaa !57
  %check_bandwidth18 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %9, i32 0, i32 32
  %10 = load i32 (%struct.usb_hcd.712*, %struct.usb_device*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*)** %check_bandwidth18, align 8, !tbaa !460
  %call19 = call i32 %10(%struct.usb_hcd.712* %call, %struct.usb_device* %udev)
  br label %cleanup163

if.end20:                                         ; preds = %if.end
  %tobool21 = icmp ne %struct.usb_host_config* %new_config, null
  br i1 %tobool21, label %if.then22, label %if.end90

if.then22:                                        ; preds = %if.end20
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %new_config, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %11 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv = zext i8 %11 to i32
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc53, %if.then22
  %i.1 = phi i32 [ 1, %if.then22 ], [ %inc54, %for.inc53 ]
  %ret.0 = phi i32 [ 0, %if.then22 ], [ %ret.2, %for.inc53 ]
  %cmp24 = icmp slt i32 %i.1, 16
  br i1 %cmp24, label %for.body26, label %for.end55

for.body26:                                       ; preds = %for.cond23
  %ep_out27 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 17
  %idxprom28 = sext i32 %i.1 to i64
  %arrayidx29 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out27, i64 0, i64 %idxprom28
  %12 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx29, align 8, !tbaa !52
  %tobool30 = icmp ne %struct.usb_host_endpoint* %12, null
  br i1 %tobool30, label %if.then31, label %if.end39

if.then31:                                        ; preds = %for.body26
  %driver32 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %13 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver32, align 8, !tbaa !57
  %drop_endpoint33 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %13, i32 0, i32 31
  %14 = load i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint*)** %drop_endpoint33, align 8, !tbaa !461
  %call34 = call i32 %14(%struct.usb_hcd.712* %call, %struct.usb_device* %udev, %struct.usb_host_endpoint* %12)
  %cmp35 = icmp slt i32 %call34, 0
  br i1 %cmp35, label %reset, label %if.end39

if.end39:                                         ; preds = %if.then31, %for.body26
  %ret.1 = phi i32 [ %ret.0, %for.body26 ], [ %call34, %if.then31 ]
  %ep_in40 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 16
  %idxprom41 = sext i32 %i.1 to i64
  %arrayidx42 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in40, i64 0, i64 %idxprom41
  %15 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx42, align 8, !tbaa !52
  %tobool43 = icmp ne %struct.usb_host_endpoint* %15, null
  br i1 %tobool43, label %if.then44, label %for.inc53

if.then44:                                        ; preds = %if.end39
  %driver45 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %16 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver45, align 8, !tbaa !57
  %drop_endpoint46 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %16, i32 0, i32 31
  %17 = load i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint*)** %drop_endpoint46, align 8, !tbaa !461
  %call47 = call i32 %17(%struct.usb_hcd.712* %call, %struct.usb_device* %udev, %struct.usb_host_endpoint* %15)
  %cmp48 = icmp slt i32 %call47, 0
  br i1 %cmp48, label %reset, label %for.inc53

for.inc53:                                        ; preds = %if.then44, %if.end39
  %ret.2 = phi i32 [ %ret.1, %if.end39 ], [ %call47, %if.then44 ]
  %inc54 = add nsw i32 %i.1, 1
  br label %for.cond23

for.end55:                                        ; preds = %for.cond23
  br label %for.cond56

for.cond56:                                       ; preds = %for.inc87, %for.end55
  %i.2 = phi i32 [ 0, %for.end55 ], [ %inc88, %for.inc87 ]
  %ret.3 = phi i32 [ %ret.0, %for.end55 ], [ %ret.5, %for.inc87 ]
  %cmp57 = icmp slt i32 %i.2, %conv
  br i1 %cmp57, label %for.body59, label %if.end90

for.body59:                                       ; preds = %for.cond56
  %intf_cache = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %new_config, i32 0, i32 4
  %idxprom60 = sext i32 %i.2 to i64
  %arrayidx61 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache, i64 0, i64 %idxprom60
  %18 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx61, align 8, !tbaa !52
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %18, i32 0, i32 2
  %arrayidx62 = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i64 0, i64 0
  %desc63 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx62, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc63, i32 0, i32 2
  %19 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !106
  %conv64 = zext i8 %19 to i32
  %call65 = call %struct.usb_host_interface* @usb_find_alt_setting(%struct.usb_host_config* %new_config, i32 %conv64, i32 0)
  %tobool66 = icmp ne %struct.usb_host_interface* %call65, null
  %call65.arrayidx62 = select i1 %tobool66, %struct.usb_host_interface* %call65, %struct.usb_host_interface* %arrayidx62
  br label %for.cond69

for.cond69:                                       ; preds = %for.inc83, %for.body59
  %j.0 = phi i32 [ 0, %for.body59 ], [ %inc84, %for.inc83 ]
  %ret.4 = phi i32 [ %ret.3, %for.body59 ], [ %call78, %for.inc83 ]
  %desc70 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %call65.arrayidx62, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc70, i32 0, i32 4
  %20 = load i8, i8* %bNumEndpoints, align 4, !tbaa !172
  %conv71 = zext i8 %20 to i32
  %cmp72 = icmp slt i32 %j.0, %conv71
  br i1 %cmp72, label %for.body74, label %NodeBlock

for.body74:                                       ; preds = %for.cond69
  %driver75 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %21 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver75, align 8, !tbaa !57
  %add_endpoint = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %21, i32 0, i32 30
  %22 = load i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint*)** %add_endpoint, align 8, !tbaa !462
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %call65.arrayidx62, i32 0, i32 3
  %23 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !173
  %idxprom76 = sext i32 %j.0 to i64
  %arrayidx77 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %23, i64 %idxprom76
  %call78 = call i32 %22(%struct.usb_hcd.712* %call, %struct.usb_device* %udev, %struct.usb_host_endpoint* %arrayidx77)
  %cmp79 = icmp slt i32 %call78, 0
  br i1 %cmp79, label %NodeBlock, label %for.inc83

for.inc83:                                        ; preds = %for.body74
  %inc84 = add nsw i32 %j.0, 1
  br label %for.cond69

NodeBlock:                                        ; preds = %for.body74, %for.cond69
  %ret.5 = phi i32 [ %call78, %for.body74 ], [ %ret.4, %for.cond69 ]
  %cleanup.dest.slot.0 = phi i32 [ 8, %for.body74 ], [ 0, %for.cond69 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 8
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 8
  br i1 %SwitchLeaf2, label %reset, label %cleanup163

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc87, label %cleanup163

for.inc87:                                        ; preds = %LeafBlock
  %inc88 = add nsw i32 %i.2, 1
  br label %for.cond56

if.end90:                                         ; preds = %for.cond56, %if.end20
  %ret.6 = phi i32 [ 0, %if.end20 ], [ %ret.3, %for.cond56 ]
  %tobool91 = icmp ne %struct.usb_host_interface* %cur_alt, null
  %tobool93 = icmp ne %struct.usb_host_interface* %new_alt, null
  %or.cond10 = and i1 %tobool91, %tobool93
  br i1 %or.cond10, label %if.then94, label %if.end154

if.then94:                                        ; preds = %if.end90
  %desc95 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %cur_alt, i32 0, i32 0
  %bInterfaceNumber96 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc95, i32 0, i32 2
  %24 = load i8, i8* %bInterfaceNumber96, align 2, !tbaa !106
  %conv97 = zext i8 %24 to i32
  %call98 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %udev, i32 %conv97)
  %tobool99 = icmp ne %struct.usb_interface* %call98, null
  br i1 %tobool99, label %if.end101, label %NodeBlock8

if.end101:                                        ; preds = %if.then94
  %resetting_device = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call98, i32 0, i32 6
  %bf.load = load i8, i8* %resetting_device, align 8
  %bf.lshr = lshr i8 %bf.load, 6
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool102 = icmp ne i32 %bf.cast, 0
  br i1 %tobool102, label %if.then103, label %if.end110

if.then103:                                       ; preds = %if.end101
  %call104 = call %struct.usb_host_interface* @usb_altnum_to_altsetting(%struct.usb_interface* %call98, i32 0)
  %tobool105 = icmp ne %struct.usb_host_interface* %call104, null
  br i1 %tobool105, label %if.end110, label %if.then106

if.then106:                                       ; preds = %if.then103
  %altsetting107 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call98, i32 0, i32 0
  %25 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting107, align 8, !tbaa !98
  %arrayidx108 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %25, i64 0
  br label %if.end110

if.end110:                                        ; preds = %if.then106, %if.then103, %if.end101
  %cur_alt.addr.1 = phi %struct.usb_host_interface* [ %cur_alt, %if.end101 ], [ %call104, %if.then103 ], [ %arrayidx108, %if.then106 ]
  br label %for.cond111

for.cond111:                                      ; preds = %for.inc128, %if.end110
  %i.3 = phi i32 [ 0, %if.end110 ], [ %inc129, %for.inc128 ]
  %ret.7 = phi i32 [ %ret.6, %if.end110 ], [ %call123, %for.inc128 ]
  %desc112 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %cur_alt.addr.1, i32 0, i32 0
  %bNumEndpoints113 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc112, i32 0, i32 4
  %26 = load i8, i8* %bNumEndpoints113, align 4, !tbaa !172
  %conv114 = zext i8 %26 to i32
  %cmp115 = icmp slt i32 %i.3, %conv114
  br i1 %cmp115, label %for.body117, label %for.end130

for.body117:                                      ; preds = %for.cond111
  %driver118 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %27 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver118, align 8, !tbaa !57
  %drop_endpoint119 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %27, i32 0, i32 31
  %28 = load i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint*)** %drop_endpoint119, align 8, !tbaa !461
  %endpoint120 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %cur_alt.addr.1, i32 0, i32 3
  %29 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint120, align 8, !tbaa !173
  %idxprom121 = sext i32 %i.3 to i64
  %arrayidx122 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %29, i64 %idxprom121
  %call123 = call i32 %28(%struct.usb_hcd.712* %call, %struct.usb_device* %udev, %struct.usb_host_endpoint* %arrayidx122)
  %cmp124 = icmp slt i32 %call123, 0
  br i1 %cmp124, label %NodeBlock8, label %for.inc128

for.inc128:                                       ; preds = %for.body117
  %inc129 = add nsw i32 %i.3, 1
  br label %for.cond111

for.end130:                                       ; preds = %for.cond111
  br label %for.cond131

for.cond131:                                      ; preds = %for.inc148, %for.end130
  %i.4 = phi i32 [ 0, %for.end130 ], [ %inc149, %for.inc148 ]
  %ret.8 = phi i32 [ %ret.7, %for.end130 ], [ %call143, %for.inc148 ]
  %desc132 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %new_alt, i32 0, i32 0
  %bNumEndpoints133 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc132, i32 0, i32 4
  %30 = load i8, i8* %bNumEndpoints133, align 4, !tbaa !172
  %conv134 = zext i8 %30 to i32
  %cmp135 = icmp slt i32 %i.4, %conv134
  br i1 %cmp135, label %for.body137, label %NodeBlock8

for.body137:                                      ; preds = %for.cond131
  %driver138 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %31 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver138, align 8, !tbaa !57
  %add_endpoint139 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %31, i32 0, i32 30
  %32 = load i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*, %struct.usb_host_endpoint*)** %add_endpoint139, align 8, !tbaa !462
  %endpoint140 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %new_alt, i32 0, i32 3
  %33 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint140, align 8, !tbaa !173
  %idxprom141 = sext i32 %i.4 to i64
  %arrayidx142 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %33, i64 %idxprom141
  %call143 = call i32 %32(%struct.usb_hcd.712* %call, %struct.usb_device* %udev, %struct.usb_host_endpoint* %arrayidx142)
  %cmp144 = icmp slt i32 %call143, 0
  br i1 %cmp144, label %NodeBlock8, label %for.inc148

for.inc148:                                       ; preds = %for.body137
  %inc149 = add nsw i32 %i.4, 1
  br label %for.cond131

NodeBlock8:                                       ; preds = %for.body137, %for.cond131, %for.body117, %if.then94
  %ret.9 = phi i32 [ %ret.6, %if.then94 ], [ %call123, %for.body117 ], [ %call143, %for.body137 ], [ %ret.8, %for.cond131 ]
  %cleanup.dest.slot.1 = phi i32 [ 1, %if.then94 ], [ 8, %for.body117 ], [ 8, %for.body137 ], [ 0, %for.cond131 ]
  %Pivot9 = icmp slt i32 %cleanup.dest.slot.1, 8
  br i1 %Pivot9, label %LeafBlock4, label %LeafBlock6

LeafBlock6:                                       ; preds = %NodeBlock8
  %SwitchLeaf7 = icmp eq i32 %cleanup.dest.slot.1, 8
  br i1 %SwitchLeaf7, label %reset, label %cleanup163

LeafBlock4:                                       ; preds = %NodeBlock8
  %SwitchLeaf5 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf5, label %if.end154, label %cleanup163

if.end154:                                        ; preds = %LeafBlock4, %if.end90
  %driver155 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %34 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver155, align 8, !tbaa !57
  %check_bandwidth156 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %34, i32 0, i32 32
  %35 = load i32 (%struct.usb_hcd.712*, %struct.usb_device*)*, i32 (%struct.usb_hcd.712*, %struct.usb_device*)** %check_bandwidth156, align 8, !tbaa !460
  %call157 = call i32 %35(%struct.usb_hcd.712* %call, %struct.usb_device* %udev)
  br label %reset

reset:                                            ; preds = %if.end154, %LeafBlock6, %LeafBlock1, %if.then44, %if.then31
  %ret.10 = phi i32 [ %ret.5, %LeafBlock1 ], [ %call157, %if.end154 ], [ %ret.9, %LeafBlock6 ], [ %call34, %if.then31 ], [ %call47, %if.then44 ]
  %cmp158 = icmp slt i32 %ret.10, 0
  br i1 %cmp158, label %if.then160, label %cleanup163

if.then160:                                       ; preds = %reset
  %driver161 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %36 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver161, align 8, !tbaa !57
  %reset_bandwidth = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %36, i32 0, i32 33
  %37 = load void (%struct.usb_hcd.712*, %struct.usb_device*)*, void (%struct.usb_hcd.712*, %struct.usb_device*)** %reset_bandwidth, align 8, !tbaa !463
  call void %37(%struct.usb_hcd.712* %call, %struct.usb_device* %udev)
  br label %cleanup163

cleanup163:                                       ; preds = %if.then160, %reset, %LeafBlock4, %LeafBlock6, %LeafBlock, %LeafBlock1, %for.end, %entry
  %retval.1 = phi i32 [ 0, %for.end ], [ 0, %entry ], [ %ret.10, %if.then160 ], [ %ret.10, %reset ], [ undef, %LeafBlock ], [ undef, %LeafBlock1 ], [ -22, %LeafBlock6 ], [ -22, %LeafBlock4 ]
  ret i32 %retval.1
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_disable_endpoint(%struct.usb_device* %udev, %struct.usb_host_endpoint* %ep) #0 {
entry:
  call void @__might_sleep(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.57, i32 0, i32 0), i32 2085, i32 0)
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %0)
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %1 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %endpoint_disable = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %1, i32 0, i32 16
  %2 = load void (%struct.usb_hcd.712*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd.712*, %struct.usb_host_endpoint*)** %endpoint_disable, align 8, !tbaa !464
  %tobool = icmp ne void (%struct.usb_hcd.712*, %struct.usb_host_endpoint*)* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %driver4 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %3 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver4, align 8, !tbaa !57
  %endpoint_disable5 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %3, i32 0, i32 16
  %4 = load void (%struct.usb_hcd.712*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd.712*, %struct.usb_host_endpoint*)** %endpoint_disable5, align 8, !tbaa !464
  call void %4(%struct.usb_hcd.712* %call, %struct.usb_host_endpoint* %ep)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_reset_endpoint(%struct.usb_device* %udev, %struct.usb_host_endpoint* %ep) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %0)
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %1 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %endpoint_reset = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %1, i32 0, i32 17
  %2 = load void (%struct.usb_hcd.712*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd.712*, %struct.usb_host_endpoint*)** %endpoint_reset, align 8, !tbaa !465
  %tobool = icmp ne void (%struct.usb_hcd.712*, %struct.usb_host_endpoint*)* %2, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %driver1 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %3 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver1, align 8, !tbaa !57
  %endpoint_reset2 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %3, i32 0, i32 17
  %4 = load void (%struct.usb_hcd.712*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd.712*, %struct.usb_host_endpoint*)** %endpoint_reset2, align 8, !tbaa !465
  call void %4(%struct.usb_hcd.712* %call, %struct.usb_host_endpoint* %ep)
  br label %if.end29

if.else:                                          ; preds = %entry
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call3 = call i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %desc)
  %desc4 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call5 = call i32 @usb_endpoint_dir_out(%struct.usb_endpoint_descriptor* %desc4)
  %desc6 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call7 = call i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %desc6)
  %toggle = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 7
  %idxprom = sext i32 %call5 to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %toggle, i64 0, i64 %idxprom
  %5 = load i32, i32* %arrayidx, align 4, !tbaa !73
  %shl = shl i32 1, %call3
  %neg = xor i32 %shl, -1
  %and = and i32 %5, %neg
  %shl8 = shl i32 0, %call3
  %or = or i32 %and, %shl8
  %toggle9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 7
  %idxprom10 = sext i32 %call5 to i64
  %arrayidx11 = getelementptr inbounds [2 x i32], [2 x i32]* %toggle9, i64 0, i64 %idxprom10
  store i32 %or, i32* %arrayidx11, align 4, !tbaa !73
  %tobool12 = icmp ne i32 %call7, 0
  br i1 %tobool12, label %if.then13, label %if.end29

if.then13:                                        ; preds = %if.else
  %toggle14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 7
  %tobool15 = icmp ne i32 %call5, 0
  %lnot = xor i1 %tobool15, true
  %lnot.ext = zext i1 %lnot to i32
  %idxprom16 = sext i32 %lnot.ext to i64
  %arrayidx17 = getelementptr inbounds [2 x i32], [2 x i32]* %toggle14, i64 0, i64 %idxprom16
  %6 = load i32, i32* %arrayidx17, align 4, !tbaa !73
  %shl18 = shl i32 1, %call3
  %neg19 = xor i32 %shl18, -1
  %and20 = and i32 %6, %neg19
  %shl21 = shl i32 0, %call3
  %or22 = or i32 %and20, %shl21
  %toggle23 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 7
  %tobool24 = icmp ne i32 %call5, 0
  %lnot25 = xor i1 %tobool24, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %idxprom27 = sext i32 %lnot.ext26 to i64
  %arrayidx28 = getelementptr inbounds [2 x i32], [2 x i32]* %toggle23, i64 0, i64 %idxprom27
  store i32 %or22, i32* %arrayidx28, align 4, !tbaa !73
  br label %if.end29

if.end29:                                         ; preds = %if.then13, %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_dir_out(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !309
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 128
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_synchronize_unlinks(%struct.usb_device* %udev) #0 {
entry:
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_urb_unlink_lock, i32 0, i32 0, i32 0)) #8
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_urb_unlink_lock, i32 0, i32 0, i32 0)) #8
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_get_frame_number(%struct.usb_device* %udev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %0)
  %flags = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 11
  %1 = load i64, i64* %flags, align 8, !tbaa !84
  %and = and i64 %1, 32
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %2 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %get_frame_number = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %2, i32 0, i32 11
  %3 = load i32 (%struct.usb_hcd.712*)*, i32 (%struct.usb_hcd.712*)** %get_frame_number, align 8, !tbaa !466
  %call1 = call i32 %3(%struct.usb_hcd.712* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call1, %if.end ], [ -108, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @hcd_bus_suspend(%struct.usb_device* %rhdev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.atomic_t, align 4
  %buffer = alloca [6 x i8], align 1
  %.compoundliteral = alloca %struct.atomic_t, align 4
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %0)
  %state = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 25
  %1 = load i32, i32* %state, align 8, !tbaa !355
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_suspend.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end9

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 11
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %2 = load i32, i32* %event, align 4, !tbaa !48
  %and4 = and i32 %2, 1024
  %cmp = icmp ne i32 %and4, 0
  %cond = select i1 %cmp, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.16.143, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.28.900, i32 0, i32 0)
  %do_remote_wakeup = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 33
  %bf.load6 = load i8, i8* %do_remote_wakeup, align 8
  %bf.clear7 = and i8 %bf.load6, 1
  %bf.cast = zext i8 %bf.clear7 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_suspend.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.15.144, i32 0, i32 0), i8* %cond, i32 %bf.cast)
  br label %do.end9

do.end9:                                          ; preds = %if.then, %entry
  %flags = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 11
  %3 = load i64, i64* %flags, align 8, !tbaa !84
  %and10 = and i64 %3, 64
  %tobool11 = icmp ne i64 %and10, 0
  br i1 %tobool11, label %do.body14, label %if.end34

do.body14:                                        ; preds = %do.end9
  %bf.load15 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_suspend.descriptor.17 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr16 = lshr i32 %bf.load15, 18
  %bf.clear17 = and i32 %bf.lshr16, 255
  %and18 = and i32 %bf.clear17, 1
  %tobool19 = icmp ne i32 %and18, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %expval25 = call i64 @llvm.expect.i64(i64 %conv24, i64 0)
  %tobool26 = icmp ne i64 %expval25, 0
  br i1 %tobool26, label %if.then27, label %cleanup

if.then27:                                        ; preds = %do.body14
  %dev28 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_suspend.descriptor.17 to %struct._ddebug*), %struct.device* %dev28, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.18.145, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.19.146, i32 0, i32 0))
  br label %cleanup

if.end34:                                         ; preds = %do.end9
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %4 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %bus_suspend = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %4, i32 0, i32 20
  %5 = load i32 (%struct.usb_hcd.712*)*, i32 (%struct.usb_hcd.712*)** %bus_suspend, align 8, !tbaa !284
  %tobool35 = icmp ne i32 (%struct.usb_hcd.712*)* %5, null
  br i1 %tobool35, label %if.else, label %if.end42

if.else:                                          ; preds = %if.end34
  %flags37 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags37, i64 5, i64* %flags37) #8, !srcloc !354
  %state38 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 25
  store i32 133, i32* %state38, align 8, !tbaa !355
  %driver39 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %6 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver39, align 8, !tbaa !57
  %bus_suspend40 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %6, i32 0, i32 20
  %7 = load i32 (%struct.usb_hcd.712*)*, i32 (%struct.usb_hcd.712*)** %bus_suspend40, align 8, !tbaa !284
  %call41 = call i32 %7(%struct.usb_hcd.712* %call)
  br label %if.end42

if.end42:                                         ; preds = %if.else, %if.end34
  %status.0 = phi i32 [ %call41, %if.else ], [ -2, %if.end34 ]
  %cmp43 = icmp eq i32 %status.0, 0
  br i1 %cmp43, label %if.then45, label %if.else84

if.then45:                                        ; preds = %if.end42
  call void @usb_set_device_state(%struct.usb_device* %rhdev, i32 8)
  %state46 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 25
  store i32 4, i32* %state46, align 8, !tbaa !355
  %do_remote_wakeup47 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 33
  %bf.load48 = load i8, i8* %do_remote_wakeup47, align 8
  %bf.clear49 = and i8 %bf.load48, 1
  %bf.cast50 = zext i8 %bf.clear49 to i32
  %tobool51 = icmp ne i32 %bf.cast50, 0
  br i1 %tobool51, label %if.then52, label %cleanup

if.then52:                                        ; preds = %if.then45
  %driver53 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %8 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver53, align 8, !tbaa !57
  %hub_status_data = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %8, i32 0, i32 18
  %9 = load i32 (%struct.usb_hcd.712*, i8*)*, i32 (%struct.usb_hcd.712*, i8*)** %hub_status_data, align 8, !tbaa !373
  %arraydecay = getelementptr inbounds [6 x i8], [6 x i8]* %buffer, i32 0, i32 0
  %call54 = call i32 %9(%struct.usb_hcd.712* %call, i8* %arraydecay)
  %cmp55 = icmp ne i32 %call54, 0
  br i1 %cmp55, label %do.body59, label %if.end82

do.body59:                                        ; preds = %if.then52
  %bf.load60 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_suspend.descriptor.20 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr61 = lshr i32 %bf.load60, 18
  %bf.clear62 = and i32 %bf.lshr61, 255
  %and63 = and i32 %bf.clear62, 1
  %tobool64 = icmp ne i32 %and63, 0
  %lnot65 = xor i1 %tobool64, true
  %lnot67 = xor i1 %lnot65, true
  %lnot.ext68 = zext i1 %lnot67 to i32
  %conv69 = sext i32 %lnot.ext68 to i64
  %expval70 = call i64 @llvm.expect.i64(i64 %conv69, i64 0)
  %tobool71 = icmp ne i64 %expval70, 0
  br i1 %tobool71, label %if.then72, label %do.end78

if.then72:                                        ; preds = %do.body59
  %dev73 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_suspend.descriptor.20 to %struct._ddebug*), %struct.device* %dev73, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.21.147, i32 0, i32 0))
  br label %do.end78

do.end78:                                         ; preds = %if.then72, %do.body59
  %event79 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  store i32 1040, i32* %event79, align 4, !tbaa !48
  %coerce.dive80 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  %10 = load i32, i32* %coerce.dive80, align 4
  %call81 = call i32 @hcd_bus_resume(%struct.usb_device* %rhdev, i32 %10)
  br label %if.end82

if.end82:                                         ; preds = %do.end78, %if.then52
  %status.1 = phi i32 [ -16, %do.end78 ], [ %call54, %if.then52 ]
  br label %cleanup

if.else84:                                        ; preds = %if.end42
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0)) #8
  %flags85 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 11
  %11 = load i64, i64* %flags85, align 8, !tbaa !84
  %and86 = and i64 %11, 64
  %tobool87 = icmp ne i64 %and86, 0
  br i1 %tobool87, label %if.end91, label %if.then88

if.then88:                                        ; preds = %if.else84
  %flags89 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags89, i64 5, i64* %flags89) #8, !srcloc !362
  %state90 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 25
  store i32 %1, i32* %state90, align 8, !tbaa !355
  br label %if.end91

if.end91:                                         ; preds = %if.then88, %if.else84
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0)) #8
  %bf.load94 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_suspend.descriptor.22 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr95 = lshr i32 %bf.load94, 18
  %bf.clear96 = and i32 %bf.lshr95, 255
  %and97 = and i32 %bf.clear96, 1
  %tobool98 = icmp ne i32 %and97, 0
  %lnot99 = xor i1 %tobool98, true
  %lnot101 = xor i1 %lnot99, true
  %lnot.ext102 = zext i1 %lnot101 to i32
  %conv103 = sext i32 %lnot.ext102 to i64
  %expval104 = call i64 @llvm.expect.i64(i64 %conv103, i64 0)
  %tobool105 = icmp ne i64 %expval104, 0
  br i1 %tobool105, label %if.then106, label %cleanup

if.then106:                                       ; preds = %if.end91
  %dev107 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_suspend.descriptor.22 to %struct._ddebug*), %struct.device* %dev107, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.19.146, i32 0, i32 0), i32 %status.0)
  br label %cleanup

cleanup:                                          ; preds = %if.then106, %if.end91, %if.end82, %if.then45, %if.then27, %do.body14
  %retval.0 = phi i32 [ 0, %if.then27 ], [ 0, %do.body14 ], [ %status.1, %if.end82 ], [ %status.0, %if.then45 ], [ %status.0, %if.then106 ], [ %status.0, %if.end91 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @hcd_bus_resume(%struct.usb_device* %rhdev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.atomic_t, align 4
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.712* @bus_to_hcd.59(%struct.usb_bus* %0)
  %state = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 25
  %1 = load i32, i32* %state, align 8, !tbaa !355
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_resume.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end7

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 11
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %2 = load i32, i32* %event, align 4, !tbaa !48
  %and4 = and i32 %2, 1024
  %cmp = icmp ne i32 %and4, 0
  %cond = select i1 %cmp, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.16.143, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.28.900, i32 0, i32 0)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_resume.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.24.148, i32 0, i32 0), i8* %cond)
  br label %do.end7

do.end7:                                          ; preds = %if.then, %entry
  %flags = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 11
  %3 = load i64, i64* %flags, align 8, !tbaa !84
  %and8 = and i64 %3, 64
  %tobool9 = icmp ne i64 %and8, 0
  br i1 %tobool9, label %do.body12, label %if.end32

do.body12:                                        ; preds = %do.end7
  %bf.load13 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_resume.descriptor.25 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr14 = lshr i32 %bf.load13, 18
  %bf.clear15 = and i32 %bf.lshr14, 255
  %and16 = and i32 %bf.clear15, 1
  %tobool17 = icmp ne i32 %and16, 0
  %lnot18 = xor i1 %tobool17, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  %expval23 = call i64 @llvm.expect.i64(i64 %conv22, i64 0)
  %tobool24 = icmp ne i64 %expval23, 0
  br i1 %tobool24, label %if.then25, label %cleanup

if.then25:                                        ; preds = %do.body12
  %dev26 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_resume.descriptor.25 to %struct._ddebug*), %struct.device* %dev26, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.18.145, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.26.149, i32 0, i32 0))
  br label %cleanup

if.end32:                                         ; preds = %do.end7
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %4 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %bus_resume = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %4, i32 0, i32 21
  %5 = load i32 (%struct.usb_hcd.712*)*, i32 (%struct.usb_hcd.712*)** %bus_resume, align 8, !tbaa !285
  %tobool33 = icmp ne i32 (%struct.usb_hcd.712*)* %5, null
  br i1 %tobool33, label %if.end35, label %cleanup

if.end35:                                         ; preds = %if.end32
  %flags36 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 11
  %6 = load i64, i64* %flags36, align 8, !tbaa !84
  %and37 = and i64 %6, 32
  %tobool38 = icmp ne i64 %and37, 0
  br i1 %tobool38, label %cleanup, label %if.end40

if.end40:                                         ; preds = %if.end35
  %state41 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 25
  store i32 132, i32* %state41, align 8, !tbaa !355
  %driver42 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 8
  %7 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver42, align 8, !tbaa !57
  %bus_resume43 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %7, i32 0, i32 21
  %8 = load i32 (%struct.usb_hcd.712*)*, i32 (%struct.usb_hcd.712*)** %bus_resume43, align 8, !tbaa !285
  %call44 = call i32 %8(%struct.usb_hcd.712* %call)
  %flags45 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags45, i64 4, i64* %flags45) #8, !srcloc !354
  %cmp46 = icmp eq i32 %call44, 0
  br i1 %cmp46, label %if.then48, label %if.else74

if.then48:                                        ; preds = %if.end40
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0)) #8
  %flags49 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 11
  %9 = load i64, i64* %flags49, align 8, !tbaa !84
  %and50 = and i64 %9, 64
  %tobool51 = icmp ne i64 %and50, 0
  br i1 %tobool51, label %if.end57, label %if.then52

if.then52:                                        ; preds = %if.then48
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 15
  %10 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool53 = icmp ne %struct.usb_host_config* %10, null
  %cond54 = select i1 %tobool53, i32 7, i32 6
  call void @usb_set_device_state(%struct.usb_device* %rhdev, i32 %cond54)
  %flags55 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags55, i64 5, i64* %flags55) #8, !srcloc !362
  %state56 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 25
  store i32 1, i32* %state56, align 8, !tbaa !355
  br label %if.end57

if.end57:                                         ; preds = %if.then52, %if.then48
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @hcd_root_hub_lock, i32 0, i32 0, i32 0)) #8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end57
  %inc.sink = phi i32 [ %inc, %for.inc ], [ 1, %if.end57 ]
  %port1.0 = phi i32 [ 1, %if.end57 ], [ %inc, %for.inc ]
  %call73 = call %struct.usb_device* @usb_hub_find_child(%struct.usb_device* %rhdev, i32 %inc.sink)
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 28
  %11 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp59 = icmp sle i32 %port1.0, %11
  br i1 %cmp59, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %tobool61 = icmp ne %struct.usb_device* %call73, null
  br i1 %tobool61, label %if.else, label %for.inc

if.else:                                          ; preds = %for.body
  %state63 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call73, i32 0, i32 3
  %12 = load i32, i32* %state63, align 8, !tbaa !54
  %cmp64 = icmp ne i32 %12, 0
  br i1 %cmp64, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %if.else
  %port_is_suspended = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call73, i32 0, i32 33
  %bf.load66 = load i8, i8* %port_is_suspended, align 8
  %bf.lshr67 = lshr i8 %bf.load66, 2
  %bf.clear68 = and i8 %bf.lshr67, 1
  %bf.cast = zext i8 %bf.clear68 to i32
  %tobool69 = icmp ne i32 %bf.cast, 0
  br i1 %tobool69, label %for.inc, label %if.then70

if.then70:                                        ; preds = %land.lhs.true
  call void @usleep_range(i64 10000, i64 11000)
  br label %cleanup

for.inc:                                          ; preds = %land.lhs.true, %if.else, %for.body
  %inc = add nsw i32 %port1.0, 1
  br label %for.cond

if.else74:                                        ; preds = %if.end40
  %state75 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %call, i32 0, i32 25
  store i32 %1, i32* %state75, align 8, !tbaa !355
  %bf.load78 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_resume.descriptor.27 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr79 = lshr i32 %bf.load78, 18
  %bf.clear80 = and i32 %bf.lshr79, 255
  %and81 = and i32 %bf.clear80, 1
  %tobool82 = icmp ne i32 %and81, 0
  %lnot83 = xor i1 %tobool82, true
  %lnot85 = xor i1 %lnot83, true
  %lnot.ext86 = zext i1 %lnot85 to i32
  %conv87 = sext i32 %lnot.ext86 to i64
  %expval88 = call i64 @llvm.expect.i64(i64 %conv87, i64 0)
  %tobool89 = icmp ne i64 %expval88, 0
  br i1 %tobool89, label %if.then90, label %do.end96

if.then90:                                        ; preds = %if.else74
  %dev91 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_resume.descriptor.27 to %struct._ddebug*), %struct.device* %dev91, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.26.149, i32 0, i32 0), i32 %call44)
  br label %do.end96

do.end96:                                         ; preds = %if.then90, %if.else74
  %cmp97 = icmp ne i32 %call44, -108
  br i1 %cmp97, label %if.then99, label %cleanup

if.then99:                                        ; preds = %do.end96
  call void @usb_hc_died(%struct.usb_hcd.712* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.then99, %do.end96, %if.then70, %for.cond, %if.end35, %if.end32, %if.then25, %do.body12
  %retval.0 = phi i32 [ 0, %if.then25 ], [ 0, %do.body12 ], [ -2, %if.end32 ], [ 0, %if.end35 ], [ %call44, %do.end96 ], [ %call44, %if.then99 ], [ %call44, %if.then70 ], [ %call44, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_find_raw_port_number(%struct.usb_hcd.712* %hcd, i32 %port1) #0 {
entry:
  %driver = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %0 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver, align 8, !tbaa !57
  %find_raw_port_number = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %0, i32 0, i32 42
  %1 = load i32 (%struct.usb_hcd.712*, i32)*, i32 (%struct.usb_hcd.712*, i32)** %find_raw_port_number, align 8, !tbaa !467
  %tobool = icmp ne i32 (%struct.usb_hcd.712*, i32)* %1, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %driver1 = getelementptr inbounds %struct.usb_hcd.712, %struct.usb_hcd.712* %hcd, i32 0, i32 8
  %2 = load %struct.hc_driver.713*, %struct.hc_driver.713** %driver1, align 8, !tbaa !57
  %find_raw_port_number2 = getelementptr inbounds %struct.hc_driver.713, %struct.hc_driver.713* %2, i32 0, i32 42
  %3 = load i32 (%struct.usb_hcd.712*, i32)*, i32 (%struct.usb_hcd.712*, i32)** %find_raw_port_number2, align 8, !tbaa !467
  %call = call i32 %3(%struct.usb_hcd.712* %hcd, i32 %port1)
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call, %if.end ], [ %port1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_anchor_empty(%struct.usb_anchor* %anchor) #0 {
entry:
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %call = call i32 @list_empty.153(%struct.list_head* %urb_list)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty.153(%struct.list_head* %head) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %0 to i64*
  %2 = load volatile i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %arraydecay to i64*
  store i64 %2, i64* %3, align 8, !tbaa !86
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  %4 = load %struct.list_head*, %struct.list_head** %__val, align 8, !tbaa !72
  %cmp = icmp eq %struct.list_head* %4, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define void @usb_scuttle_anchored_urbs(%struct.usb_anchor* %anchor) #0 {
entry:
  %lock = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %call5 = call i32 @list_empty.153(%struct.list_head* %urb_list)
  %tobool = icmp ne i32 %call5, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %urb_list6 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %urb_list6, i32 0, i32 1
  %1 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !468
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -48
  %3 = bitcast i8* %add.ptr to %struct.urb.744*
  call void @__usb_unanchor_urb(%struct.urb.744* %3, %struct.usb_anchor* %anchor)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %lock8 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock8, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__usb_unanchor_urb(%struct.urb.744* %urb, %struct.usb_anchor* %anchor) #0 {
entry:
  %anchor1 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 7
  store %struct.usb_anchor* null, %struct.usb_anchor** %anchor1, align 8, !tbaa !377
  %anchor_list = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 6
  call void @list_del.157(%struct.list_head* %anchor_list)
  call void @usb_free_urb(%struct.urb.744* %urb)
  %call = call i32 @usb_anchor_check_wakeup(%struct.usb_anchor* %anchor)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %wait = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 1
  call void @__wake_up(%struct.__wait_queue_head* %wait, i32 3, i32 1, i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del.157(%struct.list_head* %entry1) #1 {
entry:
  call void @__list_del_entry.163(%struct.list_head* %entry1)
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8, !tbaa !252
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8, !tbaa !87
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_free_urb(%struct.urb.744* %urb) #0 {
entry:
  %tobool = icmp ne %struct.urb.744* %urb, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %kref = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 0
  call void @kref_put.161(%struct.kref* %kref, void (%struct.kref*)* @urb_destroy)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_anchor_check_wakeup(%struct.usb_anchor* %anchor) #0 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %suspend_wakeups = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 3
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %suspend_wakeups, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %0 = load volatile i32, i32* %counter.i, align 4, !tbaa !73
  %1 = bitcast i8* %arraydecay.i to i32*
  store i32 %0, i32* %1, align 4, !tbaa !73
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %2 = load i32, i32* %__val.i, align 4, !tbaa !72
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %call1 = call i32 @list_empty.153(%struct.list_head* %urb_list)
  %tobool = icmp ne i32 %call1, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %tobool, %land.rhs ]
  %land.ext = zext i1 %3 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define internal void @urb_destroy(%struct.kref* %kref) #0 {
entry:
  %0 = bitcast %struct.kref* %kref to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.urb.744*
  %transfer_flags = getelementptr inbounds %struct.urb.744, %struct.urb.744* %1, i32 0, i32 13
  %2 = load i32, i32* %transfer_flags, align 4, !tbaa !379
  %and = and i32 %2, 256
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %transfer_buffer = getelementptr inbounds %struct.urb.744, %struct.urb.744* %1, i32 0, i32 14
  %3 = load i8*, i8** %transfer_buffer, align 8, !tbaa !316
  call void @kfree(i8* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = bitcast %struct.urb.744* %1 to i8*
  call void @kfree(i8* %4)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put.161(%struct.kref* %kref, void (%struct.kref*)* %release) #1 {
entry:
  %cmp = icmp eq void (%struct.kref*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.11.527, i32 0, i32 0), i32 69)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  %call = call zeroext i1 @refcount_dec_and_test(%struct.qspinlock* %refcount)
  br i1 %call, label %if.then14, label %return

if.then14:                                        ; preds = %if.end
  call void %release(%struct.kref* %kref)
  br label %return

return:                                           ; preds = %if.then14, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry.163(%struct.list_head* %entry1) #1 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !87
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !252
  call void @__list_del.164(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del.164(%struct.list_head* %prev, %struct.list_head* %next) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !87
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !72
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.urb.744* @usb_get_from_anchor(%struct.usb_anchor* %anchor) #0 {
entry:
  %lock = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %call5 = call i32 @list_empty.153(%struct.list_head* %urb_list)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %urb_list6 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %urb_list6, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !470
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -48
  %3 = bitcast i8* %add.ptr to %struct.urb.744*
  %call8 = call %struct.urb.744* @usb_get_urb(%struct.urb.744* %3)
  call void @__usb_unanchor_urb(%struct.urb.744* %3, %struct.usb_anchor* %anchor)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %victim.0 = phi %struct.urb.744* [ %3, %if.then ], [ null, %entry ]
  %lock9 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock9, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #8
  ret %struct.urb.744* %victim.0
}

; Function Attrs: nounwind uwtable
define %struct.urb.744* @usb_get_urb(%struct.urb.744* %urb) #0 {
entry:
  %tobool = icmp ne %struct.urb.744* %urb, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %kref = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 0
  call void @kref_get.168(%struct.kref* %kref)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.urb.744* %urb
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_get.168(%struct.kref* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  call void @refcount_inc(%struct.qspinlock* %refcount)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_wait_anchor_empty_timeout(%struct.usb_anchor* %anchor, i32 %timeout) #0 {
entry:
  %__wait = alloca %struct.__wait_queue, align 8
  %call.i1 = call i64 @__msecs_to_jiffies(i32 %timeout) #8
  call void @__might_sleep(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.172, i32 0, i32 0), i32 900, i32 0)
  %call4 = call i32 @usb_anchor_check_wakeup(%struct.usb_anchor* %anchor)
  %tobool = icmp ne i32 %call4, 0
  %frombool = zext i1 %tobool to i8
  %tobool5 = trunc i8 %frombool to i1
  %tobool5.not = xor i1 %tobool5, true
  %tobool6 = icmp ne i64 %call.i1, 0
  %or.cond = or i1 %tobool5.not, %tobool6
  %__ret.0 = select i1 %or.cond, i64 %call.i1, i64 1
  %tobool7 = trunc i8 %frombool to i1
  br i1 %tobool7, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %tobool8 = icmp ne i64 %__ret.0, 0
  %lnot = xor i1 %tobool8, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lor.ext = zext i1 %0 to i32
  %tobool9 = icmp ne i32 %lor.ext, 0
  br i1 %tobool9, label %if.end36, label %if.then10

if.then10:                                        ; preds = %lor.end
  %call.i = call i64 @__msecs_to_jiffies(i32 %timeout) #8
  call void @init_wait_entry(%struct.__wait_queue* %__wait, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %cleanup.cont, %if.then10
  %__ret11.0 = phi i64 [ %call.i, %if.then10 ], [ %__ret11.2, %cleanup.cont ]
  %wait = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 1
  %call13 = call i64 @prepare_to_wait_event(%struct.__wait_queue_head* %wait, %struct.__wait_queue* %__wait, i32 2)
  %call15 = call i32 @usb_anchor_check_wakeup(%struct.usb_anchor* %anchor)
  %tobool16 = icmp ne i32 %call15, 0
  %frombool17 = zext i1 %tobool16 to i8
  %tobool18 = trunc i8 %frombool17 to i1
  %tobool18.not = xor i1 %tobool18, true
  %tobool20 = icmp ne i64 %__ret11.0, 0
  %or.cond1 = or i1 %tobool18.not, %tobool20
  %__ret11.1 = select i1 %or.cond1, i64 %__ret11.0, i64 1
  %tobool24 = trunc i8 %frombool17 to i1
  br i1 %tobool24, label %lor.end28, label %lor.rhs25

lor.rhs25:                                        ; preds = %for.cond
  %tobool26 = icmp ne i64 %__ret11.1, 0
  %lnot27 = xor i1 %tobool26, true
  br label %lor.end28

lor.end28:                                        ; preds = %lor.rhs25, %for.cond
  %1 = phi i1 [ true, %for.cond ], [ %lnot27, %lor.rhs25 ]
  %lor.ext29 = zext i1 %1 to i32
  %tobool30 = icmp ne i32 %lor.ext29, 0
  br i1 %tobool30, label %LeafBlock, label %if.end32

if.end32:                                         ; preds = %lor.end28
  %call33 = call i64 @schedule_timeout(i64 %__ret11.1)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end32, %lor.end28
  %__ret11.2 = phi i64 [ %call33, %if.end32 ], [ %__ret11.1, %lor.end28 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end32 ], [ 6, %lor.end28 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 6
  br i1 %SwitchLeaf, label %for.end, label %cleanup.cont

cleanup.cont:                                     ; preds = %LeafBlock
  br label %for.cond

for.end:                                          ; preds = %LeafBlock
  %wait34 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 1
  call void @finish_wait(%struct.__wait_queue_head* %wait34, %struct.__wait_queue* %__wait)
  br label %if.end36

if.end36:                                         ; preds = %for.end, %lor.end
  %__ret.1 = phi i64 [ %__ret.0, %lor.end ], [ %__ret11.2, %for.end ]
  %conv = trunc i64 %__ret.1 to i32
  ret i32 %conv
}

declare void @init_wait_entry(%struct.__wait_queue*, i32) #2

declare i64 @prepare_to_wait_event(%struct.__wait_queue_head*, %struct.__wait_queue*, i32) #2

declare i64 @schedule_timeout(i64) #2

declare void @finish_wait(%struct.__wait_queue_head*, %struct.__wait_queue*) #2

; Function Attrs: nounwind uwtable
define void @usb_anchor_resume_wakeups(%struct.usb_anchor* %anchor) #0 {
entry:
  %tobool = icmp ne %struct.usb_anchor* %anchor, null
  br i1 %tobool, label %if.end, label %if.end3

if.end:                                           ; preds = %entry
  %suspend_wakeups = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 3
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %suspend_wakeups, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !471
  %call = call i32 @usb_anchor_check_wakeup(%struct.usb_anchor* %anchor)
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %wait = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 1
  call void @__wake_up(%struct.__wait_queue_head* %wait, i32 3, i32 1, i8* null)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_anchor_suspend_wakeups(%struct.usb_anchor* %anchor) #0 {
entry:
  %tobool = icmp ne %struct.usb_anchor* %anchor, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %suspend_wakeups = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 3
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %suspend_wakeups, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !472
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_unlink_anchored_urbs(%struct.usb_anchor* %anchor) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call %struct.urb.744* @usb_get_from_anchor(%struct.usb_anchor* %anchor)
  %cmp = icmp ne %struct.urb.744* %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call1 = call i32 @usb_unlink_urb(%struct.urb.744* %call)
  call void @usb_free_urb(%struct.urb.744* %call)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_unlink_urb(%struct.urb.744* %urb) #0 {
entry:
  %tobool = icmp ne %struct.urb.744* %urb, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !242
  %tobool1 = icmp ne %struct.usb_device* %0, null
  br i1 %tobool1, label %if.end3, label %return

if.end3:                                          ; preds = %if.end
  %ep = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 9
  %1 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !250
  %tobool4 = icmp ne %struct.usb_host_endpoint* %1, null
  br i1 %tobool4, label %if.end6, label %return

if.end6:                                          ; preds = %if.end3
  %call = call i32 bitcast (i32 (%struct.urb*, i32)* @usb_hcd_unlink_urb to i32 (%struct.urb.744*, i32)*)(%struct.urb.744* %urb, i32 -104)
  br label %return

return:                                           ; preds = %if.end6, %if.end3, %if.end, %entry
  %retval.0 = phi i32 [ %call, %if.end6 ], [ -22, %entry ], [ -19, %if.end ], [ -43, %if.end3 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_unpoison_anchored_urbs(%struct.usb_anchor* %anchor) #0 {
entry:
  %lock = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %anchor_list10.sink = phi %struct.list_head* [ %anchor_list10, %for.body ], [ %urb_list, %entry ]
  %next11 = getelementptr inbounds %struct.list_head, %struct.list_head* %anchor_list10.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next11, align 8, !tbaa !52
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr13 = getelementptr inbounds i8, i8* %2, i64 -48
  %3 = bitcast i8* %add.ptr13 to %struct.urb.744*
  %anchor_list = getelementptr inbounds %struct.urb.744, %struct.urb.744* %3, i32 0, i32 6
  %urb_list6 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %cmp7 = icmp ne %struct.list_head* %anchor_list, %urb_list6
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @usb_unpoison_urb(%struct.urb.744* %3)
  %anchor_list10 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %3, i32 0, i32 6
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %poisoned = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 4
  %bf.load = load i8, i8* %poisoned, align 4
  %bf.clear = and i8 %bf.load, -2
  store i8 %bf.clear, i8* %poisoned, align 4
  %lock14 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock14, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #8
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_unpoison_urb(%struct.urb.744* %urb) #0 {
entry:
  %tobool = icmp ne %struct.urb.744* %urb, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %reject = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 3
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %reject, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !471
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_poison_anchored_urbs(%struct.usb_anchor* %anchor) #0 {
entry:
  %lock = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i1) #8
  %poisoned = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 4
  %bf.load = load i8, i8* %poisoned, align 4
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %poisoned, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %call = call i32 @list_empty.153(%struct.list_head* %urb_list)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %urb_list1 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %urb_list1, i32 0, i32 1
  %1 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !468
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -48
  %3 = bitcast i8* %add.ptr to %struct.urb.744*
  %call2 = call %struct.urb.744* @usb_get_urb(%struct.urb.744* %3)
  %lock3 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock3, i32 0, i32 0
  %rlock.i3 = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i3) #8
  call void @usb_poison_urb(%struct.urb.744* %3)
  call void @usb_free_urb(%struct.urb.744* %3)
  %lock4 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %5 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock4, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %5 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i) #8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %lock5 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %6 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock5, i32 0, i32 0
  %rlock.i2 = bitcast %union.anon.1* %6 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i2) #8
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_poison_urb(%struct.urb.744* %urb) #0 {
entry:
  %__u.i1 = alloca %struct.atomic_t, align 4
  %__u.i = alloca %struct.atomic_t, align 4
  %__wait = alloca %struct.__wait_queue, align 8
  call void @__might_sleep(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.172, i32 0, i32 0), i32 703, i32 0)
  %tobool = icmp ne %struct.urb.744* %urb, null
  br i1 %tobool, label %if.end, label %do.end21

if.end:                                           ; preds = %entry
  %reject = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 3
  %counter.i6 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %reject, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i6, i32* %counter.i6) #8, !srcloc !472
  %dev = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !242
  %tobool3 = icmp ne %struct.usb_device* %0, null
  br i1 %tobool3, label %lor.lhs.false, label %do.end21

lor.lhs.false:                                    ; preds = %if.end
  %ep = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 9
  %1 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !250
  %tobool4 = icmp ne %struct.usb_host_endpoint* %1, null
  br i1 %tobool4, label %if.end6, label %do.end21

if.end6:                                          ; preds = %lor.lhs.false
  %call = call i32 bitcast (i32 (%struct.urb*, i32)* @usb_hcd_unlink_urb to i32 (%struct.urb.744*, i32)*)(%struct.urb.744* %urb, i32 -2)
  call void @__might_sleep(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.172, i32 0, i32 0), i32 712, i32 0)
  %use_count = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 2
  %counter.i2 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %use_count, i32 0, i32 0
  %__c.i3 = bitcast %struct.atomic_t* %__u.i1 to [1 x i8]*
  %arraydecay.i4 = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i3, i32 0, i32 0
  %2 = load volatile i32, i32* %counter.i2, align 4, !tbaa !73
  %3 = bitcast i8* %arraydecay.i4 to i32*
  store i32 %2, i32* %3, align 4, !tbaa !73
  %__val.i5 = bitcast %struct.atomic_t* %__u.i1 to i32*
  %4 = load i32, i32* %__val.i5, align 4, !tbaa !72
  %cmp = icmp eq i32 %4, 0
  br i1 %cmp, label %do.end21, label %if.end14

if.end14:                                         ; preds = %if.end6
  call void @init_wait_entry(%struct.__wait_queue* %__wait, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %cleanup.cont, %if.end14
  %call15 = call i64 @prepare_to_wait_event(%struct.__wait_queue_head* @usb_kill_urb_queue, %struct.__wait_queue* %__wait, i32 2)
  %use_count16 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 2
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %use_count16, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %5 = load volatile i32, i32* %counter.i, align 4, !tbaa !73
  %6 = bitcast i8* %arraydecay.i to i32*
  store i32 %5, i32* %6, align 4, !tbaa !73
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %7 = load i32, i32* %__val.i, align 4, !tbaa !72
  %cmp18 = icmp eq i32 %7, 0
  br i1 %cmp18, label %LeafBlock, label %if.end20

if.end20:                                         ; preds = %for.cond
  call void @schedule()
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end20, %for.cond
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end20 ], [ 12, %for.cond ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 12
  br i1 %SwitchLeaf, label %for.end, label %cleanup.cont

cleanup.cont:                                     ; preds = %LeafBlock
  br label %for.cond

for.end:                                          ; preds = %LeafBlock
  call void @finish_wait(%struct.__wait_queue_head* @usb_kill_urb_queue, %struct.__wait_queue* %__wait)
  br label %do.end21

do.end21:                                         ; preds = %for.end, %if.end6, %lor.lhs.false, %if.end, %entry
  ret void
}

declare void @schedule() #2

; Function Attrs: nounwind uwtable
define void @usb_kill_anchored_urbs(%struct.usb_anchor* %anchor) #0 {
entry:
  %lock = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i1) #8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %call = call i32 @list_empty.153(%struct.list_head* %urb_list)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %urb_list1 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %urb_list1, i32 0, i32 1
  %1 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !468
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -48
  %3 = bitcast i8* %add.ptr to %struct.urb.744*
  %call2 = call %struct.urb.744* @usb_get_urb(%struct.urb.744* %3)
  %lock3 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock3, i32 0, i32 0
  %rlock.i3 = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i3) #8
  call void @usb_kill_urb(%struct.urb.744* %3)
  call void @usb_free_urb(%struct.urb.744* %3)
  %lock4 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %5 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock4, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %5 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i) #8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %lock5 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %6 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock5, i32 0, i32 0
  %rlock.i2 = bitcast %union.anon.1* %6 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i2) #8
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_kill_urb(%struct.urb.744* %urb) #0 {
entry:
  %__u.i1 = alloca %struct.atomic_t, align 4
  %__u.i = alloca %struct.atomic_t, align 4
  %__wait = alloca %struct.__wait_queue, align 8
  call void @__might_sleep(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.172, i32 0, i32 0), i32 662, i32 0)
  %tobool = icmp ne %struct.urb.744* %urb, null
  br i1 %tobool, label %land.lhs.true, label %return

land.lhs.true:                                    ; preds = %entry
  %dev = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !242
  %tobool3 = icmp ne %struct.usb_device* %0, null
  br i1 %tobool3, label %land.lhs.true4, label %return

land.lhs.true4:                                   ; preds = %land.lhs.true
  %ep = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 9
  %1 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !250
  %tobool5 = icmp ne %struct.usb_host_endpoint* %1, null
  br i1 %tobool5, label %if.end, label %return

if.end:                                           ; preds = %land.lhs.true4
  %reject = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 3
  %counter.i7 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %reject, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i7, i32* %counter.i7) #8, !srcloc !472
  %call = call i32 bitcast (i32 (%struct.urb*, i32)* @usb_hcd_unlink_urb to i32 (%struct.urb.744*, i32)*)(%struct.urb.744* %urb, i32 -2)
  call void @__might_sleep(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.172, i32 0, i32 0), i32 668, i32 0)
  %use_count = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 2
  %counter.i2 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %use_count, i32 0, i32 0
  %__c.i3 = bitcast %struct.atomic_t* %__u.i1 to [1 x i8]*
  %arraydecay.i4 = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i3, i32 0, i32 0
  %2 = load volatile i32, i32* %counter.i2, align 4, !tbaa !73
  %3 = bitcast i8* %arraydecay.i4 to i32*
  store i32 %2, i32* %3, align 4, !tbaa !73
  %__val.i5 = bitcast %struct.atomic_t* %__u.i1 to i32*
  %4 = load i32, i32* %__val.i5, align 4, !tbaa !72
  %cmp = icmp eq i32 %4, 0
  br i1 %cmp, label %do.end20, label %if.end13

if.end13:                                         ; preds = %if.end
  call void @init_wait_entry(%struct.__wait_queue* %__wait, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %cleanup.cont, %if.end13
  %call14 = call i64 @prepare_to_wait_event(%struct.__wait_queue_head* @usb_kill_urb_queue, %struct.__wait_queue* %__wait, i32 2)
  %use_count15 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 2
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %use_count15, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %5 = load volatile i32, i32* %counter.i, align 4, !tbaa !73
  %6 = bitcast i8* %arraydecay.i to i32*
  store i32 %5, i32* %6, align 4, !tbaa !73
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %7 = load i32, i32* %__val.i, align 4, !tbaa !72
  %cmp17 = icmp eq i32 %7, 0
  br i1 %cmp17, label %LeafBlock, label %if.end19

if.end19:                                         ; preds = %for.cond
  call void @schedule()
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end19, %for.cond
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end19 ], [ 12, %for.cond ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 12
  br i1 %SwitchLeaf, label %for.end, label %cleanup.cont

cleanup.cont:                                     ; preds = %LeafBlock
  br label %for.cond

for.end:                                          ; preds = %LeafBlock
  call void @finish_wait(%struct.__wait_queue_head* @usb_kill_urb_queue, %struct.__wait_queue* %__wait)
  br label %do.end20

do.end20:                                         ; preds = %for.end, %if.end
  %reject21 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 3
  %counter.i6 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %reject21, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i6, i32* %counter.i6) #8, !srcloc !471
  br label %return

return:                                           ; preds = %do.end20, %land.lhs.true4, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_block_urb(%struct.urb.744* %urb) #0 {
entry:
  %tobool = icmp ne %struct.urb.744* %urb, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %reject = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 3
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %reject, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !472
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_submit_urb(%struct.urb.744* %urb, i32 %mem_flags) #0 {
entry:
  %__UNIQUE_ID_min1_16 = alloca i32, align 4
  %__UNIQUE_ID_min2_17 = alloca i32, align 4
  %tobool = icmp ne %struct.urb.744* %urb, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup333

lor.lhs.false:                                    ; preds = %entry
  %complete = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 28
  %complete1 = bitcast {}** %complete to void (%struct.urb.744*)**
  %0 = load void (%struct.urb.744*)*, void (%struct.urb.744*)** %complete1, align 8, !tbaa !318
  %tobool2 = icmp ne void (%struct.urb.744*)* %0, null
  br i1 %tobool2, label %if.end, label %cleanup333

if.end:                                           ; preds = %lor.lhs.false
  %hcpriv = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 1
  %1 = load i8*, i8** %hcpriv, align 8, !tbaa !378
  %tobool3 = icmp ne i8* %1, null
  br i1 %tobool3, label %if.then4, label %if.end37

if.then4:                                         ; preds = %if.end
  %tobool5 = icmp ne i32 1, 0
  br i1 %tobool5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then4
  %2 = load i8, i8* @usb_submit_urb.__warned, align 1, !tbaa !109, !range !110
  %tobool6 = trunc i8 %2 to i1
  %lnot = xor i1 %tobool6, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then4
  %3 = phi i1 [ false, %if.then4 ], [ %lnot, %land.rhs ]
  %lnot7 = xor i1 %3, true
  %lnot8 = xor i1 %lnot7, true
  %lnot.ext = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %if.end28

if.then10:                                        ; preds = %land.end
  store i8 1, i8* @usb_submit_urb.__warned, align 1, !tbaa !109
  %tobool11 = icmp ne i32 1, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.then10
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.172, i32 0, i32 0), i32 341, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.1.185, i32 0, i32 0), %struct.urb.744* %urb)
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %if.then10
  br label %if.end28

if.end28:                                         ; preds = %if.end20, %land.end
  br label %cleanup333

if.end37:                                         ; preds = %if.end
  %dev38 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 8
  %4 = load %struct.usb_device*, %struct.usb_device** %dev38, align 8, !tbaa !242
  %tobool39 = icmp ne %struct.usb_device* %4, null
  br i1 %tobool39, label %lor.lhs.false40, label %cleanup333

lor.lhs.false40:                                  ; preds = %if.end37
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 3
  %5 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp ult i32 %5, 4
  br i1 %cmp, label %cleanup333, label %if.end43

if.end43:                                         ; preds = %lor.lhs.false40
  %pipe = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 10
  %6 = load i32, i32* %pipe, align 8, !tbaa !244
  %call = call %struct.usb_host_endpoint* @usb_pipe_endpoint(%struct.usb_device* %4, i32 %6)
  %tobool44 = icmp ne %struct.usb_host_endpoint* %call, null
  br i1 %tobool44, label %if.end46, label %cleanup333

if.end46:                                         ; preds = %if.end43
  %ep47 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 9
  store %struct.usb_host_endpoint* %call, %struct.usb_host_endpoint** %ep47, align 8, !tbaa !250
  %status = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 12
  store i32 -115, i32* %status, align 8, !tbaa !314
  %actual_length = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 20
  store i32 0, i32* %actual_length, align 4, !tbaa !315
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 0
  %call48 = call i32 @usb_endpoint_type.186(%struct.usb_endpoint_descriptor* %desc)
  %cmp49 = icmp eq i32 %call48, 0
  br i1 %cmp49, label %if.then51, label %if.else

if.then51:                                        ; preds = %if.end46
  %setup_packet = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 21
  %7 = load i8*, i8** %setup_packet, align 8, !tbaa !425
  %8 = bitcast i8* %7 to %struct.usb_ctrlrequest*
  %tobool52 = icmp ne %struct.usb_ctrlrequest* %8, null
  br i1 %tobool52, label %if.end54, label %LeafBlock

if.end54:                                         ; preds = %if.then51
  %bRequestType = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %8, i32 0, i32 0
  %9 = load i8, i8* %bRequestType, align 1, !tbaa !448
  %conv55 = zext i8 %9 to i32
  %and = and i32 %conv55, 128
  %tobool56 = icmp ne i32 %and, 0
  br i1 %tobool56, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.end54
  %wLength = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %8, i32 0, i32 4
  %10 = load i16, i16* %wLength, align 1, !tbaa !453
  %tobool57 = icmp ne i16 %10, 0
  %lnot58 = xor i1 %tobool57, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end54
  %11 = phi i1 [ true, %if.end54 ], [ %lnot58, %lor.rhs ]
  %lor.ext = zext i1 %11 to i32
  br label %LeafBlock

LeafBlock:                                        ; preds = %lor.end, %if.then51
  %is_out.0 = phi i32 [ %lor.ext, %lor.end ], [ undef, %if.then51 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %lor.end ], [ 1, %if.then51 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end62, label %cleanup333

if.else:                                          ; preds = %if.end46
  %desc60 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 0
  %call61 = call i32 @usb_endpoint_dir_out.187(%struct.usb_endpoint_descriptor* %desc60)
  br label %if.end62

if.end62:                                         ; preds = %if.else, %LeafBlock
  %is_out.1 = phi i32 [ %call61, %if.else ], [ %is_out.0, %LeafBlock ]
  %transfer_flags = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 13
  %12 = load i32, i32* %transfer_flags, align 4, !tbaa !379
  %and63 = and i32 %12, -8323585
  store i32 %and63, i32* %transfer_flags, align 4, !tbaa !379
  %tobool64 = icmp ne i32 %is_out.1, 0
  %cond = select i1 %tobool64, i32 0, i32 512
  %transfer_flags65 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 13
  %13 = load i32, i32* %transfer_flags65, align 4, !tbaa !379
  %or = or i32 %13, %cond
  store i32 %or, i32* %transfer_flags65, align 4, !tbaa !379
  %cmp66 = icmp ne i32 %call48, 0
  br i1 %cmp66, label %land.lhs.true, label %if.end72

land.lhs.true:                                    ; preds = %if.end62
  %state68 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 3
  %14 = load i32, i32* %state68, align 8, !tbaa !54
  %cmp69 = icmp ult i32 %14, 7
  br i1 %cmp69, label %cleanup333, label %if.end72

if.end72:                                         ; preds = %land.lhs.true, %if.end62
  %desc73 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 0
  %call74 = call i32 @usb_endpoint_maxp.188(%struct.usb_endpoint_descriptor* %desc73)
  %cmp75 = icmp sle i32 %call74, 0
  br i1 %cmp75, label %do.body78, label %if.end97

do.body78:                                        ; preds = %if.end72
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_submit_urb.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and79 = and i32 %bf.clear, 1
  %tobool80 = icmp ne i32 %and79, 0
  %lnot81 = xor i1 %tobool80, true
  %lnot83 = xor i1 %lnot81, true
  %lnot.ext84 = zext i1 %lnot83 to i32
  %conv85 = sext i32 %lnot.ext84 to i64
  %expval86 = call i64 @llvm.expect.i64(i64 %conv85, i64 0)
  %tobool87 = icmp ne i64 %expval86, 0
  br i1 %tobool87, label %if.then88, label %cleanup333

if.then88:                                        ; preds = %do.body78
  %dev89 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 11
  %desc90 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 0
  %call91 = call i32 @usb_endpoint_num.189(%struct.usb_endpoint_descriptor* %desc90)
  %tobool92 = icmp ne i32 %is_out.1, 0
  %cond93 = select i1 %tobool92, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.48.800, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.49.801, i32 0, i32 0)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_submit_urb.descriptor to %struct._ddebug*), %struct.device* %dev89, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.3.192, i32 0, i32 0), i32 %call91, i8* %cond93, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.usb_submit_urb, i32 0, i32 0), i32 %call74)
  br label %cleanup333

if.end97:                                         ; preds = %if.end72
  %cmp98 = icmp eq i32 %call48, 1
  br i1 %cmp98, label %if.then100, label %if.else145

if.then100:                                       ; preds = %if.end97
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 4
  %15 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp101 = icmp uge i32 %15, 5
  br i1 %cmp101, label %if.then103, label %if.end110

if.then103:                                       ; preds = %if.then100
  %ss_ep_comp = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 1
  %bMaxBurst = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp, i32 0, i32 2
  %16 = load i8, i8* %bMaxBurst, align 1, !tbaa !473
  %conv104 = zext i8 %16 to i32
  %add = add nsw i32 1, %conv104
  %ss_ep_comp105 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 1
  %bmAttributes = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp105, i32 0, i32 3
  %17 = load i8, i8* %bmAttributes, align 1, !tbaa !474
  %conv106 = zext i8 %17 to i32
  %and107 = and i32 %conv106, 3
  %add108 = add nsw i32 1, %and107
  %mul = mul nsw i32 %call74, %add
  %mul109 = mul nsw i32 %mul, %add108
  br label %if.end110

if.end110:                                        ; preds = %if.then103, %if.then100
  %max.0 = phi i32 [ %mul109, %if.then103 ], [ %call74, %if.then100 ]
  %speed111 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 4
  %18 = load i32, i32* %speed111, align 4, !tbaa !177
  %cmp112 = icmp eq i32 %18, 3
  br i1 %cmp112, label %if.then114, label %if.end118

if.then114:                                       ; preds = %if.end110
  %desc115 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 0
  %call116 = call i32 @usb_endpoint_maxp_mult(%struct.usb_endpoint_descriptor* %desc115)
  %mul117 = mul nsw i32 %max.0, %call116
  br label %if.end118

if.end118:                                        ; preds = %if.then114, %if.end110
  %max.1 = phi i32 [ %mul117, %if.then114 ], [ %max.0, %if.end110 ]
  %number_of_packets = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 24
  %19 = load i32, i32* %number_of_packets, align 4, !tbaa !475
  %cmp119 = icmp sle i32 %19, 0
  br i1 %cmp119, label %LeafBlock2, label %if.end122

if.end122:                                        ; preds = %if.end118
  br label %for.cond

for.cond:                                         ; preds = %if.end132, %if.end122
  %n.0 = phi i32 [ 0, %if.end122 ], [ %inc, %if.end132 ]
  %number_of_packets123 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 24
  %20 = load i32, i32* %number_of_packets123, align 4, !tbaa !475
  %cmp124 = icmp slt i32 %n.0, %20
  br i1 %cmp124, label %for.body, label %LeafBlock2

for.body:                                         ; preds = %for.cond
  %iso_frame_desc = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 29
  %idxprom = sext i32 %n.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb3_lpm_parameters], [0 x %struct.usb3_lpm_parameters]* %iso_frame_desc, i64 0, i64 %idxprom
  %length = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %arrayidx, i32 0, i32 1
  %21 = load i32, i32* %length, align 4, !tbaa !476
  %cmp126 = icmp slt i32 %21, 0
  %cmp129 = icmp sgt i32 %21, %max.1
  %or.cond = or i1 %cmp126, %cmp129
  br i1 %or.cond, label %LeafBlock2, label %if.end132

if.end132:                                        ; preds = %for.body
  %iso_frame_desc133 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 29
  %idxprom134 = sext i32 %n.0 to i64
  %arrayidx135 = getelementptr inbounds [0 x %struct.usb3_lpm_parameters], [0 x %struct.usb3_lpm_parameters]* %iso_frame_desc133, i64 0, i64 %idxprom134
  %status136 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %arrayidx135, i32 0, i32 3
  store i32 -18, i32* %status136, align 4, !tbaa !478
  %iso_frame_desc137 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 29
  %idxprom138 = sext i32 %n.0 to i64
  %arrayidx139 = getelementptr inbounds [0 x %struct.usb3_lpm_parameters], [0 x %struct.usb3_lpm_parameters]* %iso_frame_desc137, i64 0, i64 %idxprom138
  %actual_length140 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %arrayidx139, i32 0, i32 2
  store i32 0, i32* %actual_length140, align 8, !tbaa !479
  %inc = add nsw i32 %n.0, 1
  br label %for.cond

LeafBlock2:                                       ; preds = %for.body, %for.cond, %if.end118
  %cleanup.dest.slot.1 = phi i32 [ 1, %if.end118 ], [ 1, %for.body ], [ 0, %for.cond ]
  %retval.2 = phi i32 [ -22, %if.end118 ], [ -90, %for.body ], [ -8, %for.cond ]
  %SwitchLeaf3 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf3, label %if.end177, label %cleanup333

if.else145:                                       ; preds = %if.end97
  %num_sgs = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 18
  %22 = load i32, i32* %num_sgs, align 4, !tbaa !398
  %tobool146 = icmp ne i32 %22, 0
  br i1 %tobool146, label %land.lhs.true147, label %if.end177

land.lhs.true147:                                 ; preds = %if.else145
  %dev148 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 8
  %23 = load %struct.usb_device*, %struct.usb_device** %dev148, align 8, !tbaa !242
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %23, i32 0, i32 9
  %24 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %no_sg_constraint = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %24, i32 0, i32 6
  %bf.load149 = load i8, i8* %no_sg_constraint, align 1
  %bf.lshr150 = lshr i8 %bf.load149, 3
  %bf.clear151 = and i8 %bf.lshr150, 1
  %bf.cast = zext i8 %bf.clear151 to i32
  %tobool152 = icmp ne i32 %bf.cast, 0
  br i1 %tobool152, label %if.end177, label %land.lhs.true153

land.lhs.true153:                                 ; preds = %land.lhs.true147
  %speed154 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 4
  %25 = load i32, i32* %speed154, align 4, !tbaa !177
  %cmp155 = icmp ne i32 %25, 4
  br i1 %cmp155, label %if.then157, label %if.end177

if.then157:                                       ; preds = %land.lhs.true153
  %sg158 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 16
  %26 = load %struct.scatterlist*, %struct.scatterlist** %sg158, align 8, !tbaa !397
  br label %for.cond159

for.cond159:                                      ; preds = %for.inc168, %if.then157
  %sg.0 = phi %struct.scatterlist* [ %26, %if.then157 ], [ %call170, %for.inc168 ]
  %i.0 = phi i32 [ 0, %if.then157 ], [ %inc169, %for.inc168 ]
  %num_sgs160 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 18
  %27 = load i32, i32* %num_sgs160, align 4, !tbaa !398
  %sub = sub nsw i32 %27, 1
  %cmp161 = icmp slt i32 %i.0, %sub
  br i1 %cmp161, label %for.body163, label %LeafBlock5

for.body163:                                      ; preds = %for.cond159
  %length164 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg.0, i32 0, i32 3
  %28 = load i32, i32* %length164, align 4, !tbaa !480
  %rem = urem i32 %28, %call74
  %tobool165 = icmp ne i32 %rem, 0
  br i1 %tobool165, label %LeafBlock5, label %for.inc168

for.inc168:                                       ; preds = %for.body163
  %inc169 = add nsw i32 %i.0, 1
  %call170 = call %struct.scatterlist* @sg_next(%struct.scatterlist* %sg.0)
  br label %for.cond159

LeafBlock5:                                       ; preds = %for.body163, %for.cond159
  %cleanup.dest.slot.2 = phi i32 [ 1, %for.body163 ], [ 0, %for.cond159 ]
  %retval.3 = phi i32 [ -22, %for.body163 ], [ -8, %for.cond159 ]
  %SwitchLeaf6 = icmp eq i32 %cleanup.dest.slot.2, 0
  br i1 %SwitchLeaf6, label %if.end177, label %cleanup333

if.end177:                                        ; preds = %LeafBlock5, %land.lhs.true153, %land.lhs.true147, %if.else145, %LeafBlock2
  %max.2 = phi i32 [ %max.1, %LeafBlock2 ], [ %call74, %LeafBlock5 ], [ %call74, %land.lhs.true153 ], [ %call74, %land.lhs.true147 ], [ %call74, %if.else145 ]
  %transfer_buffer_length = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 19
  %29 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !317
  %cmp178 = icmp ugt i32 %29, 2147483647
  br i1 %cmp178, label %cleanup333, label %if.end181

if.end181:                                        ; preds = %if.end177
  %pipe182 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 10
  %30 = load i32, i32* %pipe182, align 8, !tbaa !244
  %shr = lshr i32 %30, 30
  %and183 = and i32 %shr, 3
  %idxprom184 = sext i32 %call48 to i64
  %arrayidx185 = getelementptr inbounds [4 x i32], [4 x i32]* @usb_submit_urb.pipetypes, i64 0, i64 %idxprom184
  %31 = load i32, i32* %arrayidx185, align 4, !tbaa !73
  %cmp186 = icmp ne i32 %and183, %31
  br i1 %cmp186, label %if.then188, label %NodeBlock12

if.then188:                                       ; preds = %if.end181
  %tobool190 = icmp ne i32 1, 0
  %lnot191 = xor i1 %tobool190, true
  %lnot193 = xor i1 %lnot191, true
  %lnot.ext194 = zext i1 %lnot193 to i32
  %conv195 = sext i32 %lnot.ext194 to i64
  %expval196 = call i64 @llvm.expect.i64(i64 %conv195, i64 0)
  %tobool197 = icmp ne i64 %expval196, 0
  br i1 %tobool197, label %if.then198, label %if.end208

if.then198:                                       ; preds = %if.then188
  %dev199 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 11
  %call200 = call i8* @dev_driver_string(%struct.device* %dev199)
  %dev201 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 11
  %call202 = call i8* @dev_name.193(%struct.device* %dev201)
  %pipe203 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 10
  %32 = load i32, i32* %pipe203, align 8, !tbaa !244
  %shr204 = lshr i32 %32, 30
  %and205 = and i32 %shr204, 3
  %idxprom206 = sext i32 %call48 to i64
  %arrayidx207 = getelementptr inbounds [4 x i32], [4 x i32]* @usb_submit_urb.pipetypes, i64 0, i64 %idxprom206
  %33 = load i32, i32* %arrayidx207, align 4, !tbaa !73
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.172, i32 0, i32 0), i32 449, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.6.194, i32 0, i32 0), i8* %call200, i8* %call202, i32 %and205, i32 %33)
  br label %if.end208

if.end208:                                        ; preds = %if.then198, %if.then188
  br label %NodeBlock12

NodeBlock12:                                      ; preds = %if.end208, %if.end181
  %Pivot13 = icmp slt i32 %call48, 1
  br i1 %Pivot13, label %LeafBlock8, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock12
  %Pivot = icmp slt i32 %call48, 2
  br i1 %Pivot, label %sw.bb228, label %LeafBlock10

LeafBlock10:                                      ; preds = %NodeBlock
  %.off = add i32 %call48, -2
  %SwitchLeaf11 = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf11, label %sw.bb, label %sw.default

LeafBlock8:                                       ; preds = %NodeBlock12
  %SwitchLeaf9 = icmp eq i32 %call48, 0
  br i1 %SwitchLeaf9, label %sw.bb222, label %sw.default

sw.bb:                                            ; preds = %LeafBlock10
  %tobool218 = icmp ne i32 %is_out.1, 0
  %or220 = or i32 900, 64
  %or220. = select i1 %tobool218, i32 %or220, i32 900
  br label %sw.bb222

sw.bb222:                                         ; preds = %sw.bb, %LeafBlock8
  %allowed.1 = phi i32 [ 900, %LeafBlock8 ], [ %or220., %sw.bb ]
  %or223 = or i32 %allowed.1, 32
  br label %sw.default

sw.default:                                       ; preds = %sw.bb222, %LeafBlock8, %LeafBlock10
  %allowed.2 = phi i32 [ %or223, %sw.bb222 ], [ 900, %LeafBlock10 ], [ 900, %LeafBlock8 ]
  %tobool224 = icmp ne i32 %is_out.1, 0
  %or226 = or i32 %allowed.2, 1
  %allowed.2.or226 = select i1 %tobool224, i32 %allowed.2, i32 %or226
  br label %sw.epilog

sw.bb228:                                         ; preds = %NodeBlock
  %or229 = or i32 900, 2
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb228, %sw.default
  %allowed.4 = phi i32 [ %allowed.2.or226, %sw.default ], [ %or229, %sw.bb228 ]
  %transfer_flags230 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 13
  %34 = load i32, i32* %transfer_flags230, align 4, !tbaa !379
  %and231 = and i32 %allowed.4, %34
  %transfer_flags232 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 13
  %35 = load i32, i32* %transfer_flags232, align 4, !tbaa !379
  %cmp233 = icmp ne i32 %and231, %35
  br i1 %cmp233, label %if.then235, label %NodeBlock19

if.then235:                                       ; preds = %sw.epilog
  %tobool237 = icmp ne i32 1, 0
  %lnot238 = xor i1 %tobool237, true
  %lnot240 = xor i1 %lnot238, true
  %lnot.ext241 = zext i1 %lnot240 to i32
  %conv242 = sext i32 %lnot.ext241 to i64
  %expval243 = call i64 @llvm.expect.i64(i64 %conv242, i64 0)
  %tobool244 = icmp ne i64 %expval243, 0
  br i1 %tobool244, label %if.then245, label %if.end251

if.then245:                                       ; preds = %if.then235
  %dev246 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 11
  %call247 = call i8* @dev_driver_string(%struct.device* %dev246)
  %dev248 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 11
  %call249 = call i8* @dev_name.193(%struct.device* %dev248)
  %transfer_flags250 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 13
  %36 = load i32, i32* %transfer_flags250, align 4, !tbaa !379
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.172, i32 0, i32 0), i32 476, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.7.195, i32 0, i32 0), i8* %call247, i8* %call249, i32 %36, i32 %and231)
  br label %if.end251

if.end251:                                        ; preds = %if.then245, %if.then235
  br label %NodeBlock19

NodeBlock19:                                      ; preds = %if.end251, %sw.epilog
  %Pivot20 = icmp slt i32 %call48, 3
  br i1 %Pivot20, label %LeafBlock15, label %LeafBlock17

LeafBlock17:                                      ; preds = %NodeBlock19
  %SwitchLeaf18 = icmp eq i32 %call48, 3
  br i1 %SwitchLeaf18, label %sw.bb261, label %sw.epilog331

LeafBlock15:                                      ; preds = %NodeBlock19
  %SwitchLeaf16 = icmp eq i32 %call48, 1
  br i1 %SwitchLeaf16, label %sw.bb261, label %sw.epilog331

sw.bb261:                                         ; preds = %LeafBlock15, %LeafBlock17
  %speed262 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 4
  %37 = load i32, i32* %speed262, align 4, !tbaa !177
  %SwitchLeaf23 = icmp eq i32 %37, 4
  br i1 %SwitchLeaf23, label %sw.bb263, label %sw.default271

sw.bb263:                                         ; preds = %sw.bb261
  %interval = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 25
  %38 = load i32, i32* %interval, align 8, !tbaa !319
  %cmp264 = icmp slt i32 %38, 6
  %cmp267 = icmp eq i32 %call48, 3
  %or.cond37 = and i1 %cmp264, %cmp267
  br i1 %or.cond37, label %cleanup333, label %sw.default271

sw.default271:                                    ; preds = %sw.bb263, %sw.bb261
  %interval272 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 25
  %39 = load i32, i32* %interval272, align 8, !tbaa !319
  %cmp273 = icmp sle i32 %39, 0
  br i1 %cmp273, label %cleanup333, label %sw.epilog277

sw.epilog277:                                     ; preds = %sw.default271
  %speed278 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 4
  %40 = load i32, i32* %speed278, align 4, !tbaa !177
  %Pivot36 = icmp slt i32 %40, 4
  br i1 %Pivot36, label %NodeBlock28, label %NodeBlock33

NodeBlock33:                                      ; preds = %sw.epilog277
  %Pivot34 = icmp slt i32 %40, 5
  br i1 %Pivot34, label %sw.bb285, label %LeafBlock30

LeafBlock30:                                      ; preds = %NodeBlock33
  %.off31 = add i32 %40, -5
  %SwitchLeaf32 = icmp ule i32 %.off31, 1
  br i1 %SwitchLeaf32, label %sw.bb279, label %cleanup333

NodeBlock28:                                      ; preds = %sw.epilog277
  %Pivot29 = icmp slt i32 %40, 3
  br i1 %Pivot29, label %LeafBlock25, label %sw.bb291

LeafBlock25:                                      ; preds = %NodeBlock28
  %.off26 = add i32 %40, -1
  %SwitchLeaf27 = icmp ule i32 %.off26, 1
  br i1 %SwitchLeaf27, label %sw.bb298, label %cleanup333

sw.bb279:                                         ; preds = %LeafBlock30
  %interval280 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 25
  %41 = load i32, i32* %interval280, align 8, !tbaa !319
  %cmp281 = icmp sgt i32 %41, 32768
  br i1 %cmp281, label %cleanup333, label %sw.epilog316

sw.bb285:                                         ; preds = %NodeBlock33
  %interval286 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 25
  %42 = load i32, i32* %interval286, align 8, !tbaa !319
  %cmp287 = icmp sgt i32 %42, 16
  br i1 %cmp287, label %cleanup333, label %sw.epilog316

sw.bb291:                                         ; preds = %NodeBlock28
  %interval292 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 25
  %43 = load i32, i32* %interval292, align 8, !tbaa !319
  %cmp293 = icmp sgt i32 %43, 8192
  br i1 %cmp293, label %if.then295, label %sw.epilog316

if.then295:                                       ; preds = %sw.bb291
  %interval296 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 25
  store i32 8192, i32* %interval296, align 8, !tbaa !319
  br label %sw.epilog316

sw.bb298:                                         ; preds = %LeafBlock25
  %cmp299 = icmp eq i32 %call48, 3
  %interval302 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 25
  %44 = load i32, i32* %interval302, align 8, !tbaa !319
  br i1 %cmp299, label %if.then301, label %if.else307

if.then301:                                       ; preds = %sw.bb298
  %cmp303 = icmp sgt i32 %44, 255
  br i1 %cmp303, label %cleanup333, label %sw.epilog316

if.else307:                                       ; preds = %sw.bb298
  %cmp309 = icmp sgt i32 %44, 1024
  br i1 %cmp309, label %if.then311, label %sw.epilog316

if.then311:                                       ; preds = %if.else307
  %interval312 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 25
  store i32 1024, i32* %interval312, align 8, !tbaa !319
  br label %sw.epilog316

sw.epilog316:                                     ; preds = %if.then311, %if.else307, %if.then301, %if.then295, %sw.bb291, %sw.bb285, %sw.bb279
  %max.4 = phi i32 [ 32768, %sw.bb279 ], [ %max.2, %sw.bb285 ], [ 8192, %if.then295 ], [ 8192, %sw.bb291 ], [ 128, %if.then301 ], [ 1024, %if.then311 ], [ 1024, %if.else307 ]
  %speed317 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 4
  %45 = load i32, i32* %speed317, align 4, !tbaa !177
  %cmp318 = icmp ne i32 %45, 4
  br i1 %cmp318, label %if.then320, label %sw.epilog331

if.then320:                                       ; preds = %sw.epilog316
  store i32 %max.4, i32* %__UNIQUE_ID_min1_16, align 4, !tbaa !73
  %interval321 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 25
  %46 = load i32, i32* %interval321, align 8, !tbaa !319
  %call322 = call i32 @__ilog2_u32(i32 %46) #4
  %shl = shl i32 1, %call322
  store i32 %shl, i32* %__UNIQUE_ID_min2_17, align 4, !tbaa !73
  %47 = load i32, i32* %__UNIQUE_ID_min1_16, align 4, !tbaa !73
  %48 = load i32, i32* %__UNIQUE_ID_min2_17, align 4, !tbaa !73
  %cmp326 = icmp slt i32 %47, %48
  %49 = load i32, i32* %__UNIQUE_ID_min1_16, align 4
  %50 = load i32, i32* %__UNIQUE_ID_min2_17, align 4
  %cond328 = select i1 %cmp326, i32 %49, i32 %50
  %interval329 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 25
  store i32 %cond328, i32* %interval329, align 8, !tbaa !319
  br label %sw.epilog331

sw.epilog331:                                     ; preds = %if.then320, %sw.epilog316, %LeafBlock15, %LeafBlock17
  %call332 = call i32 bitcast (i32 (%struct.urb*, i32)* @usb_hcd_submit_urb to i32 (%struct.urb.744*, i32)*)(%struct.urb.744* %urb, i32 %mem_flags)
  br label %cleanup333

cleanup333:                                       ; preds = %sw.epilog331, %if.then301, %sw.bb285, %sw.bb279, %LeafBlock25, %LeafBlock30, %sw.default271, %sw.bb263, %if.end177, %LeafBlock5, %LeafBlock2, %if.then88, %do.body78, %land.lhs.true, %LeafBlock, %if.end43, %lor.lhs.false40, %if.end37, %if.end28, %lor.lhs.false, %entry
  %retval.4 = phi i32 [ -16, %if.end28 ], [ %call332, %sw.epilog331 ], [ -22, %lor.lhs.false ], [ -22, %entry ], [ -19, %lor.lhs.false40 ], [ -19, %if.end37 ], [ -2, %if.end43 ], [ -19, %land.lhs.true ], [ -90, %if.then88 ], [ -90, %do.body78 ], [ -90, %if.end177 ], [ -22, %sw.bb263 ], [ -22, %sw.default271 ], [ -22, %sw.bb279 ], [ -22, %sw.bb285 ], [ -22, %if.then301 ], [ -22, %LeafBlock25 ], [ -22, %LeafBlock30 ], [ -8, %LeafBlock ], [ %retval.2, %LeafBlock2 ], [ %retval.3, %LeafBlock5 ]
  ret i32 %retval.4
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_host_endpoint* @usb_pipe_endpoint(%struct.usb_device* %dev, i32 %pipe) #1 {
entry:
  %and = and i32 %pipe, 128
  %tobool = icmp ne i32 %and, 0
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 17
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 16
  %ep_out.sink = select i1 %tobool, [16 x %struct.usb_host_endpoint*]* %ep_in, [16 x %struct.usb_host_endpoint*]* %ep_out
  %arraydecay1 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out.sink, i32 0, i32 0
  %shr = lshr i32 %pipe, 15
  %and2 = and i32 %shr, 15
  %idxprom = zext i32 %and2 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arraydecay1, i64 %idxprom
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8, !tbaa !52
  ret %struct.usb_host_endpoint* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_type.186(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_dir_out.187(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !309
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 128
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_maxp.188(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 4
  %0 = load i16, i16* %wMaxPacketSize, align 1, !tbaa !226
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 2047
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_num.189(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !309
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_maxp_mult(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 4
  %0 = load i16, i16* %wMaxPacketSize, align 1, !tbaa !226
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 6144
  %shr = ashr i32 %and, 11
  %add = add nsw i32 %shr, 1
  ret i32 %add
}

declare i8* @dev_driver_string(%struct.device*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name.193(%struct.device* %dev) #1 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !299
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !299
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name.196(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__ilog2_u32(i32 %n) #6 {
entry:
  %0 = call i32 asm "bsrl $1,$0", "=r,rm,0,~{dirflag},~{fpsr},~{flags}"(i32 %n, i32 -1) #9, !srcloc !481
  %add.i = add nsw i32 %0, 1
  %sub = sub nsw i32 %add.i, 1
  ret i32 %sub
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name.196(%struct.kobject* %kobj) #1 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !409
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define void @usb_unanchor_urb(%struct.urb.744* %urb) #0 {
entry:
  %tobool = icmp ne %struct.urb.744* %urb, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %anchor1 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 7
  %0 = load %struct.usb_anchor*, %struct.usb_anchor** %anchor1, align 8, !tbaa !377
  %tobool2 = icmp ne %struct.usb_anchor* %0, null
  br i1 %tobool2, label %do.body5, label %cleanup.cont

do.body5:                                         ; preds = %if.end
  %lock = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %0, i32 0, i32 2
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %1 to %struct.raw_spinlock*
  %call6 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %anchor9 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 7
  %2 = load %struct.usb_anchor*, %struct.usb_anchor** %anchor9, align 8, !tbaa !377
  %cmp10 = icmp eq %struct.usb_anchor* %0, %2
  %lnot = xor i1 %cmp10, true
  %lnot12 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot12 to i32
  %conv13 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv13, i64 1)
  %tobool14 = icmp ne i64 %expval, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %do.body5
  call void @__usb_unanchor_urb(%struct.urb.744* %urb, %struct.usb_anchor* %0)
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %do.body5
  %lock17 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %0, i32 0, i32 2
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock17, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %3 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call6) #8
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end16, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_anchor_urb(%struct.urb.744* %urb, %struct.usb_anchor* %anchor) #0 {
entry:
  %lock = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %call5 = call %struct.urb.744* @usb_get_urb(%struct.urb.744* %urb)
  %anchor_list = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 6
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  call void @list_add_tail.200(%struct.list_head* %anchor_list, %struct.list_head* %urb_list)
  %anchor6 = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 7
  store %struct.usb_anchor* %anchor, %struct.usb_anchor** %anchor6, align 8, !tbaa !377
  %poisoned = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 4
  %bf.load = load i8, i8* %poisoned, align 4
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  %lnot = xor i1 %tobool, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv8 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %reject = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 3
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %reject, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !472
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %lock10 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock10, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %1 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #8
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.200(%struct.list_head* %new, %struct.list_head* %head) #1 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !87
  call void @__list_add.201(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add.201(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !87
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !252
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !87
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !72
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.urb.744* @usb_alloc_urb(i32 %iso_packets, i32 %mem_flags) #0 {
entry:
  %conv = sext i32 %iso_packets to i64
  %mul = mul i64 %conv, 16
  %add = add i64 192, %mul
  %call.i = call noalias i8* @__kmalloc(i64 %add, i32 %mem_flags) #8
  %0 = bitcast i8* %call.i to %struct.urb.744*
  %tobool = icmp ne %struct.urb.744* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  call void @usb_init_urb(%struct.urb.744* %0)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi %struct.urb.744* [ %0, %if.end ], [ null, %entry ]
  ret %struct.urb.744* %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_init_urb(%struct.urb.744* %urb) #0 {
entry:
  %tobool = icmp ne %struct.urb.744* %urb, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.urb.744* %urb to i8*
  %call = call i8* @__memset(i8* %0, i32 0, i64 192)
  %kref = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 0
  call void @kref_init.205(%struct.kref* %kref)
  %anchor_list = getelementptr inbounds %struct.urb.744, %struct.urb.744* %urb, i32 0, i32 6
  call void @INIT_LIST_HEAD.206(%struct.list_head* %anchor_list)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_init.205(%struct.kref* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  call void @refcount_set.207(%struct.qspinlock* %refcount, i32 1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.206(%struct.list_head* %list) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !72
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !87
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @refcount_set.207(%struct.qspinlock* %r, i32 %n) #1 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %refs = getelementptr inbounds %struct.qspinlock, %struct.qspinlock* %r, i32 0, i32 0
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  store i32 %n, i32* %__val.i, align 4, !tbaa !72
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %refs, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %0 = bitcast i8* %arraydecay.i to i32*
  %1 = load i32, i32* %0, align 4, !tbaa !73
  store volatile i32 %1, i32* %counter.i, align 4, !tbaa !73
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_if_uevent(%struct.device* %dev, %struct.kobj_uevent_env* %env) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -48
  %1 = bitcast i8* %add.ptr to %struct.usb_interface*
  %call = call %struct.usb_device* @interface_to_usbdev.213(%struct.usb_interface* %1)
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %1, i32 0, i32 1
  %2 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !169
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 5
  %3 = load i8, i8* %bInterfaceClass, align 1, !tbaa !482
  %conv = zext i8 %3 to i32
  %desc1 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceSubClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc1, i32 0, i32 6
  %4 = load i8, i8* %bInterfaceSubClass, align 2, !tbaa !286
  %conv2 = zext i8 %4 to i32
  %desc3 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceProtocol = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc3, i32 0, i32 7
  %5 = load i8, i8* %bInterfaceProtocol, align 1, !tbaa !483
  %conv4 = zext i8 %5 to i32
  %call5 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.38.215, i32 0, i32 0), i32 %conv, i32 %conv2, i32 %conv4)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 12
  %idVendor = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 7
  %6 = load i16, i16* %idVendor, align 8, !tbaa !268
  %conv6 = zext i16 %6 to i32
  %descriptor7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 12
  %idProduct = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor7, i32 0, i32 8
  %7 = load i16, i16* %idProduct, align 2, !tbaa !269
  %conv8 = zext i16 %7 to i32
  %descriptor9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 12
  %bcdDevice = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor9, i32 0, i32 9
  %8 = load i16, i16* %bcdDevice, align 4, !tbaa !275
  %conv10 = zext i16 %8 to i32
  %descriptor11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 12
  %bDeviceClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor11, i32 0, i32 3
  %9 = load i8, i8* %bDeviceClass, align 4, !tbaa !278
  %conv12 = zext i8 %9 to i32
  %descriptor13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 12
  %bDeviceSubClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor13, i32 0, i32 4
  %10 = load i8, i8* %bDeviceSubClass, align 1, !tbaa !280
  %conv14 = zext i8 %10 to i32
  %descriptor15 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 12
  %bDeviceProtocol = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor15, i32 0, i32 5
  %11 = load i8, i8* %bDeviceProtocol, align 2, !tbaa !205
  %conv16 = zext i8 %11 to i32
  %desc17 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceClass18 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc17, i32 0, i32 5
  %12 = load i8, i8* %bInterfaceClass18, align 1, !tbaa !482
  %conv19 = zext i8 %12 to i32
  %desc20 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceSubClass21 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc20, i32 0, i32 6
  %13 = load i8, i8* %bInterfaceSubClass21, align 2, !tbaa !286
  %conv22 = zext i8 %13 to i32
  %desc23 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceProtocol24 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc23, i32 0, i32 7
  %14 = load i8, i8* %bInterfaceProtocol24, align 1, !tbaa !483
  %conv25 = zext i8 %14 to i32
  %desc26 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc26, i32 0, i32 2
  %15 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !106
  %conv27 = zext i8 %15 to i32
  %call28 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.39.216, i32 0, i32 0), i32 %conv6, i32 %conv8, i32 %conv10, i32 %conv12, i32 %conv14, i32 %conv16, i32 %conv19, i32 %conv22, i32 %conv25, i32 %conv27)
  %tobool29 = icmp ne i32 %call28, 0
  %. = select i1 %tobool29, i32 -12, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ -12, %entry ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @usb_release_interface(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -48
  %1 = bitcast i8* %add.ptr to %struct.usb_interface*
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %1, i32 0, i32 0
  %2 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !98
  %3 = bitcast %struct.usb_host_interface* %2 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -8
  %4 = bitcast i8* %add.ptr3 to %struct.usb_interface_cache*
  %ref = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %4, i32 0, i32 1
  call void @kref_put.212(%struct.kref* %ref, void (%struct.kref*)* @usb_release_interface_cache)
  %call4 = call %struct.usb_device* @interface_to_usbdev.213(%struct.usb_interface* %1)
  call void @usb_put_dev(%struct.usb_device* %call4)
  %5 = bitcast %struct.usb_interface* %1 to i8*
  call void @kfree(i8* %5)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put.212(%struct.kref* %kref, void (%struct.kref*)* %release) #1 {
entry:
  %cmp = icmp eq void (%struct.kref*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.11.527, i32 0, i32 0), i32 69)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  %call = call zeroext i1 @refcount_dec_and_test(%struct.qspinlock* %refcount)
  br i1 %call, label %if.then14, label %return

if.then14:                                        ; preds = %if.end
  call void %release(%struct.kref* %kref)
  br label %return

return:                                           ; preds = %if.then14, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_device* @interface_to_usbdev.213(%struct.usb_interface* %intf) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %parent, align 8, !tbaa !300
  %1 = bitcast %struct.device* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -152
  %2 = bitcast i8* %add.ptr to %struct.usb_device*
  ret %struct.usb_device* %2
}

; Function Attrs: nounwind uwtable
define i32 @cdc_parse_cdc_header(%struct.usb_cdc_parsed_header* %hdr, %struct.usb_interface* %intf, i8* %buffer, i32 %buflen) #0 {
entry:
  %0 = bitcast %struct.usb_cdc_parsed_header* %hdr to i8*
  %call = call i8* @__memset(i8* %0, i32 0, i64 120)
  %phonet_magic_present = getelementptr inbounds %struct.usb_cdc_parsed_header, %struct.usb_cdc_parsed_header* %hdr, i32 0, i32 14
  store i8 0, i8* %phonet_magic_present, align 8, !tbaa !484
  br label %while.cond

while.cond:                                       ; preds = %next_desc, %entry
  %desc.0 = phi %struct.usb_cdc_mdlm_desc* [ null, %entry ], [ %desc.2, %next_desc ]
  %detail.0 = phi %struct.usb_cdc_mdlm_detail_desc* [ null, %entry ], [ %detail.2, %next_desc ]
  %ether.0 = phi %struct.usb_cdc_ether_desc* [ null, %entry ], [ %ether.2, %next_desc ]
  %header.0 = phi %struct.usb_cdc_header_desc* [ null, %entry ], [ %header.2, %next_desc ]
  %union_header.0 = phi %struct.usb_cdc_union_desc* [ null, %entry ], [ %union_header.2, %next_desc ]
  %buflen.addr.0 = phi i32 [ %buflen, %entry ], [ %sub, %next_desc ]
  %buffer.addr.0 = phi i8* [ %buffer, %entry ], [ %add.ptr, %next_desc ]
  %cnt.0 = phi i32 [ 0, %entry ], [ %cnt.1, %next_desc ]
  %cmp = icmp sgt i32 %buflen.addr.0, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %arrayidx = getelementptr inbounds i8, i8* %buffer.addr.0, i64 0
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !72
  %conv = zext i8 %1 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %next_desc

if.end:                                           ; preds = %while.body
  %arrayidx1 = getelementptr inbounds i8, i8* %buffer.addr.0, i64 1
  %2 = load i8, i8* %arrayidx1, align 1, !tbaa !72
  %conv2 = zext i8 %2 to i32
  %cmp3 = icmp ne i32 %conv2, 36
  br i1 %cmp3, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %next_desc

if.end7:                                          ; preds = %if.end
  %arrayidx8 = getelementptr inbounds i8, i8* %buffer.addr.0, i64 2
  %3 = load i8, i8* %arrayidx8, align 1, !tbaa !72
  %conv9 = zext i8 %3 to i32
  %Pivot34 = icmp slt i32 %conv9, 18
  br i1 %Pivot34, label %NodeBlock13, label %NodeBlock31

NodeBlock31:                                      ; preds = %if.end7
  %Pivot32 = icmp slt i32 %conv9, 26
  br i1 %Pivot32, label %NodeBlock19, label %NodeBlock29

NodeBlock29:                                      ; preds = %NodeBlock31
  %Pivot30 = icmp slt i32 %conv9, 28
  br i1 %Pivot30, label %NodeBlock21, label %NodeBlock27

NodeBlock27:                                      ; preds = %NodeBlock29
  %Pivot28 = icmp slt i32 %conv9, 171
  br i1 %Pivot28, label %LeafBlock23, label %LeafBlock25

LeafBlock25:                                      ; preds = %NodeBlock27
  %SwitchLeaf26 = icmp eq i32 %conv9, 171
  br i1 %SwitchLeaf26, label %sw.bb97, label %do.body99

LeafBlock23:                                      ; preds = %NodeBlock27
  %SwitchLeaf24 = icmp eq i32 %conv9, 28
  br i1 %SwitchLeaf24, label %sw.bb91, label %do.body99

NodeBlock21:                                      ; preds = %NodeBlock29
  %Pivot22 = icmp slt i32 %conv9, 27
  %conv80 = zext i32 %conv to i64
  br i1 %Pivot22, label %sw.bb79, label %sw.bb85

NodeBlock19:                                      ; preds = %NodeBlock31
  %Pivot20 = icmp slt i32 %conv9, 19
  br i1 %Pivot20, label %sw.bb61, label %NodeBlock17

NodeBlock17:                                      ; preds = %NodeBlock19
  %Pivot18 = icmp slt i32 %conv9, 20
  br i1 %Pivot18, label %sw.bb70, label %LeafBlock15

LeafBlock15:                                      ; preds = %NodeBlock17
  %SwitchLeaf16 = icmp eq i32 %conv9, 20
  br i1 %SwitchLeaf16, label %sw.bb55, label %do.body99

NodeBlock13:                                      ; preds = %if.end7
  %Pivot14 = icmp slt i32 %conv9, 6
  br i1 %Pivot14, label %NodeBlock3, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %conv9, 7
  br i1 %Pivot12, label %sw.bb, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %conv9, 15
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %conv9, 15
  br i1 %SwitchLeaf8, label %sw.bb40, label %do.body99

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %conv9, 7
  br i1 %SwitchLeaf6, label %sw.bb19, label %do.body99

NodeBlock3:                                       ; preds = %NodeBlock13
  %Pivot4 = icmp slt i32 %conv9, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %conv9, 2
  br i1 %Pivot, label %sw.bb49, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv9, 2
  br i1 %SwitchLeaf2, label %sw.bb34, label %do.body99

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %conv9, 0
  br i1 %SwitchLeaf, label %sw.bb25, label %do.body99

sw.bb:                                            ; preds = %NodeBlock11
  %conv10 = zext i32 %conv to i64
  %cmp11 = icmp ult i64 %conv10, 5
  br i1 %cmp11, label %next_desc, label %if.end14

if.end14:                                         ; preds = %sw.bb
  %tobool15 = icmp ne %struct.usb_cdc_union_desc* %union_header.0, null
  br i1 %tobool15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end14
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %next_desc

if.end18:                                         ; preds = %if.end14
  %4 = bitcast i8* %buffer.addr.0 to %struct.usb_cdc_union_desc*
  br label %sw.epilog

sw.bb19:                                          ; preds = %LeafBlock5
  %conv20 = zext i32 %conv to i64
  %cmp21 = icmp ult i64 %conv20, 6
  br i1 %cmp21, label %next_desc, label %if.end24

if.end24:                                         ; preds = %sw.bb19
  %5 = bitcast i8* %buffer.addr.0 to %struct.usb_ss_ep_comp_descriptor*
  %usb_cdc_country_functional_desc = getelementptr inbounds %struct.usb_cdc_parsed_header, %struct.usb_cdc_parsed_header* %hdr, i32 0, i32 4
  store %struct.usb_ss_ep_comp_descriptor* %5, %struct.usb_ss_ep_comp_descriptor** %usb_cdc_country_functional_desc, align 8, !tbaa !486
  br label %sw.epilog

sw.bb25:                                          ; preds = %LeafBlock
  %conv26 = zext i32 %conv to i64
  %cmp27 = icmp ne i64 %conv26, 5
  br i1 %cmp27, label %next_desc, label %if.end30

if.end30:                                         ; preds = %sw.bb25
  %tobool31 = icmp ne %struct.usb_cdc_header_desc* %header.0, null
  br i1 %tobool31, label %cleanup, label %if.end33

if.end33:                                         ; preds = %if.end30
  %6 = bitcast i8* %buffer.addr.0 to %struct.usb_cdc_header_desc*
  br label %sw.epilog

sw.bb34:                                          ; preds = %LeafBlock1
  %conv35 = zext i32 %conv to i64
  %cmp36 = icmp ult i64 %conv35, 4
  br i1 %cmp36, label %next_desc, label %if.end39

if.end39:                                         ; preds = %sw.bb34
  %7 = bitcast i8* %buffer.addr.0 to %struct.usb_cdc_acm_descriptor*
  %usb_cdc_acm_descriptor = getelementptr inbounds %struct.usb_cdc_parsed_header, %struct.usb_cdc_parsed_header* %hdr, i32 0, i32 3
  store %struct.usb_cdc_acm_descriptor* %7, %struct.usb_cdc_acm_descriptor** %usb_cdc_acm_descriptor, align 8, !tbaa !487
  br label %sw.epilog

sw.bb40:                                          ; preds = %LeafBlock7
  %conv41 = zext i32 %conv to i64
  %cmp42 = icmp ne i64 %conv41, 13
  br i1 %cmp42, label %next_desc, label %if.end45

if.end45:                                         ; preds = %sw.bb40
  %tobool46 = icmp ne %struct.usb_cdc_ether_desc* %ether.0, null
  br i1 %tobool46, label %cleanup, label %if.end48

if.end48:                                         ; preds = %if.end45
  %8 = bitcast i8* %buffer.addr.0 to %struct.usb_cdc_ether_desc*
  br label %sw.epilog

sw.bb49:                                          ; preds = %NodeBlock
  %conv50 = zext i32 %conv to i64
  %cmp51 = icmp ult i64 %conv50, 5
  br i1 %cmp51, label %next_desc, label %if.end54

if.end54:                                         ; preds = %sw.bb49
  %9 = bitcast i8* %buffer.addr.0 to %struct.usb_cdc_union_desc*
  %usb_cdc_call_mgmt_descriptor = getelementptr inbounds %struct.usb_cdc_parsed_header, %struct.usb_cdc_parsed_header* %hdr, i32 0, i32 2
  store %struct.usb_cdc_union_desc* %9, %struct.usb_cdc_union_desc** %usb_cdc_call_mgmt_descriptor, align 8, !tbaa !488
  br label %sw.epilog

sw.bb55:                                          ; preds = %LeafBlock15
  %conv56 = zext i32 %conv to i64
  %cmp57 = icmp ult i64 %conv56, 7
  br i1 %cmp57, label %next_desc, label %if.end60

if.end60:                                         ; preds = %sw.bb55
  %10 = bitcast i8* %buffer.addr.0 to %struct.usb_cdc_dmm_desc*
  %usb_cdc_dmm_desc = getelementptr inbounds %struct.usb_cdc_parsed_header, %struct.usb_cdc_parsed_header* %hdr, i32 0, i32 7
  store %struct.usb_cdc_dmm_desc* %10, %struct.usb_cdc_dmm_desc** %usb_cdc_dmm_desc, align 8, !tbaa !489
  br label %sw.epilog

sw.bb61:                                          ; preds = %NodeBlock19
  %conv62 = zext i32 %conv to i64
  %cmp63 = icmp ult i64 %conv62, 8
  br i1 %cmp63, label %next_desc, label %if.end66

if.end66:                                         ; preds = %sw.bb61
  %tobool67 = icmp ne %struct.usb_cdc_mdlm_desc* %desc.0, null
  br i1 %tobool67, label %cleanup, label %if.end69

if.end69:                                         ; preds = %if.end66
  %11 = bitcast i8* %buffer.addr.0 to %struct.usb_cdc_mdlm_desc*
  br label %sw.epilog

sw.bb70:                                          ; preds = %NodeBlock17
  %conv71 = zext i32 %conv to i64
  %cmp72 = icmp ult i64 %conv71, 8
  br i1 %cmp72, label %next_desc, label %if.end75

if.end75:                                         ; preds = %sw.bb70
  %tobool76 = icmp ne %struct.usb_cdc_mdlm_detail_desc* %detail.0, null
  br i1 %tobool76, label %cleanup, label %if.end78

if.end78:                                         ; preds = %if.end75
  %12 = bitcast i8* %buffer.addr.0 to %struct.usb_cdc_mdlm_detail_desc*
  br label %sw.epilog

sw.bb79:                                          ; preds = %NodeBlock21
  %cmp81 = icmp ult i64 %conv80, 6
  br i1 %cmp81, label %next_desc, label %if.end84

if.end84:                                         ; preds = %sw.bb79
  %13 = bitcast i8* %buffer.addr.0 to %struct.usb_cdc_ncm_desc*
  %usb_cdc_ncm_desc = getelementptr inbounds %struct.usb_cdc_parsed_header, %struct.usb_cdc_parsed_header* %hdr, i32 0, i32 11
  store %struct.usb_cdc_ncm_desc* %13, %struct.usb_cdc_ncm_desc** %usb_cdc_ncm_desc, align 8, !tbaa !490
  br label %sw.epilog

sw.bb85:                                          ; preds = %NodeBlock21
  %cmp87 = icmp ult i64 %conv80, 12
  br i1 %cmp87, label %next_desc, label %if.end90

if.end90:                                         ; preds = %sw.bb85
  %14 = bitcast i8* %buffer.addr.0 to %struct.usb_cdc_mbim_desc*
  %usb_cdc_mbim_desc = getelementptr inbounds %struct.usb_cdc_parsed_header, %struct.usb_cdc_parsed_header* %hdr, i32 0, i32 12
  store %struct.usb_cdc_mbim_desc* %14, %struct.usb_cdc_mbim_desc** %usb_cdc_mbim_desc, align 8, !tbaa !491
  br label %sw.epilog

sw.bb91:                                          ; preds = %LeafBlock23
  %conv92 = zext i32 %conv to i64
  %cmp93 = icmp ult i64 %conv92, 8
  br i1 %cmp93, label %sw.epilog, label %if.end96

if.end96:                                         ; preds = %sw.bb91
  %15 = bitcast i8* %buffer.addr.0 to %struct.usb_cdc_mbim_extended_desc*
  %usb_cdc_mbim_extended_desc = getelementptr inbounds %struct.usb_cdc_parsed_header, %struct.usb_cdc_parsed_header* %hdr, i32 0, i32 13
  store %struct.usb_cdc_mbim_extended_desc* %15, %struct.usb_cdc_mbim_extended_desc** %usb_cdc_mbim_extended_desc, align 8, !tbaa !492
  br label %sw.epilog

sw.bb97:                                          ; preds = %LeafBlock25
  %phonet_magic_present98 = getelementptr inbounds %struct.usb_cdc_parsed_header, %struct.usb_cdc_parsed_header* %hdr, i32 0, i32 14
  store i8 1, i8* %phonet_magic_present98, align 8, !tbaa !484
  br label %sw.epilog

do.body99:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock5, %LeafBlock7, %LeafBlock15, %LeafBlock23, %LeafBlock25
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @cdc_parse_cdc_header.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool100 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool100, true
  %lnot101 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot101 to i32
  %conv102 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv102, i64 0)
  %tobool103 = icmp ne i64 %expval, 0
  br i1 %tobool103, label %if.then104, label %next_desc

if.then104:                                       ; preds = %do.body99
  %dev105 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %arrayidx106 = getelementptr inbounds i8, i8* %buffer.addr.0, i64 2
  %16 = load i8, i8* %arrayidx106, align 1, !tbaa !72
  %conv107 = zext i8 %16 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @cdc_parse_cdc_header.descriptor to %struct._ddebug*), %struct.device* %dev105, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.28.220, i32 0, i32 0), i32 %conv107, i32 %conv)
  br label %next_desc

sw.epilog:                                        ; preds = %sw.bb97, %if.end96, %sw.bb91, %if.end90, %if.end84, %if.end78, %if.end69, %if.end60, %if.end54, %if.end48, %if.end39, %if.end33, %if.end24, %if.end18
  %desc.1 = phi %struct.usb_cdc_mdlm_desc* [ %desc.0, %if.end33 ], [ %desc.0, %if.end54 ], [ %desc.0, %if.end39 ], [ %desc.0, %if.end18 ], [ %desc.0, %if.end24 ], [ %desc.0, %if.end48 ], [ %11, %if.end69 ], [ %desc.0, %if.end78 ], [ %desc.0, %if.end60 ], [ %desc.0, %if.end84 ], [ %desc.0, %if.end90 ], [ %desc.0, %if.end96 ], [ %desc.0, %sw.bb97 ], [ %desc.0, %sw.bb91 ]
  %detail.1 = phi %struct.usb_cdc_mdlm_detail_desc* [ %detail.0, %if.end33 ], [ %detail.0, %if.end54 ], [ %detail.0, %if.end39 ], [ %detail.0, %if.end18 ], [ %detail.0, %if.end24 ], [ %detail.0, %if.end48 ], [ %detail.0, %if.end69 ], [ %12, %if.end78 ], [ %detail.0, %if.end60 ], [ %detail.0, %if.end84 ], [ %detail.0, %if.end90 ], [ %detail.0, %if.end96 ], [ %detail.0, %sw.bb97 ], [ %detail.0, %sw.bb91 ]
  %ether.1 = phi %struct.usb_cdc_ether_desc* [ %ether.0, %if.end33 ], [ %ether.0, %if.end54 ], [ %ether.0, %if.end39 ], [ %ether.0, %if.end18 ], [ %ether.0, %if.end24 ], [ %8, %if.end48 ], [ %ether.0, %if.end69 ], [ %ether.0, %if.end78 ], [ %ether.0, %if.end60 ], [ %ether.0, %if.end84 ], [ %ether.0, %if.end90 ], [ %ether.0, %if.end96 ], [ %ether.0, %sw.bb97 ], [ %ether.0, %sw.bb91 ]
  %header.1 = phi %struct.usb_cdc_header_desc* [ %6, %if.end33 ], [ %header.0, %if.end54 ], [ %header.0, %if.end39 ], [ %header.0, %if.end18 ], [ %header.0, %if.end24 ], [ %header.0, %if.end48 ], [ %header.0, %if.end69 ], [ %header.0, %if.end78 ], [ %header.0, %if.end60 ], [ %header.0, %if.end84 ], [ %header.0, %if.end90 ], [ %header.0, %if.end96 ], [ %header.0, %sw.bb97 ], [ %header.0, %sw.bb91 ]
  %union_header.1 = phi %struct.usb_cdc_union_desc* [ %union_header.0, %if.end33 ], [ %union_header.0, %if.end54 ], [ %union_header.0, %if.end39 ], [ %4, %if.end18 ], [ %union_header.0, %if.end24 ], [ %union_header.0, %if.end48 ], [ %union_header.0, %if.end69 ], [ %union_header.0, %if.end78 ], [ %union_header.0, %if.end60 ], [ %union_header.0, %if.end84 ], [ %union_header.0, %if.end90 ], [ %union_header.0, %if.end96 ], [ %union_header.0, %sw.bb97 ], [ %union_header.0, %sw.bb91 ]
  %inc = add nsw i32 %cnt.0, 1
  br label %next_desc

next_desc:                                        ; preds = %sw.epilog, %if.then104, %do.body99, %sw.bb85, %sw.bb79, %sw.bb70, %sw.bb61, %sw.bb55, %sw.bb49, %sw.bb40, %sw.bb34, %sw.bb25, %sw.bb19, %if.then16, %sw.bb, %if.then5, %if.then
  %elength.0 = phi i32 [ %conv, %if.then5 ], [ %conv, %sw.epilog ], [ %conv, %if.then16 ], [ 1, %if.then ], [ %conv, %sw.bb ], [ %conv, %sw.bb19 ], [ %conv, %sw.bb25 ], [ %conv, %sw.bb34 ], [ %conv, %sw.bb40 ], [ %conv, %sw.bb49 ], [ %conv, %sw.bb55 ], [ %conv, %sw.bb61 ], [ %conv, %sw.bb70 ], [ %conv, %sw.bb79 ], [ %conv, %sw.bb85 ], [ %conv, %if.then104 ], [ %conv, %do.body99 ]
  %desc.2 = phi %struct.usb_cdc_mdlm_desc* [ %desc.0, %if.then5 ], [ %desc.1, %sw.epilog ], [ %desc.0, %if.then16 ], [ %desc.0, %if.then ], [ %desc.0, %sw.bb ], [ %desc.0, %sw.bb19 ], [ %desc.0, %sw.bb25 ], [ %desc.0, %sw.bb34 ], [ %desc.0, %sw.bb40 ], [ %desc.0, %sw.bb49 ], [ %desc.0, %sw.bb55 ], [ %desc.0, %sw.bb61 ], [ %desc.0, %sw.bb70 ], [ %desc.0, %sw.bb79 ], [ %desc.0, %sw.bb85 ], [ %desc.0, %if.then104 ], [ %desc.0, %do.body99 ]
  %detail.2 = phi %struct.usb_cdc_mdlm_detail_desc* [ %detail.0, %if.then5 ], [ %detail.1, %sw.epilog ], [ %detail.0, %if.then16 ], [ %detail.0, %if.then ], [ %detail.0, %sw.bb ], [ %detail.0, %sw.bb19 ], [ %detail.0, %sw.bb25 ], [ %detail.0, %sw.bb34 ], [ %detail.0, %sw.bb40 ], [ %detail.0, %sw.bb49 ], [ %detail.0, %sw.bb55 ], [ %detail.0, %sw.bb61 ], [ %detail.0, %sw.bb70 ], [ %detail.0, %sw.bb79 ], [ %detail.0, %sw.bb85 ], [ %detail.0, %if.then104 ], [ %detail.0, %do.body99 ]
  %ether.2 = phi %struct.usb_cdc_ether_desc* [ %ether.0, %if.then5 ], [ %ether.1, %sw.epilog ], [ %ether.0, %if.then16 ], [ %ether.0, %if.then ], [ %ether.0, %sw.bb ], [ %ether.0, %sw.bb19 ], [ %ether.0, %sw.bb25 ], [ %ether.0, %sw.bb34 ], [ %ether.0, %sw.bb40 ], [ %ether.0, %sw.bb49 ], [ %ether.0, %sw.bb55 ], [ %ether.0, %sw.bb61 ], [ %ether.0, %sw.bb70 ], [ %ether.0, %sw.bb79 ], [ %ether.0, %sw.bb85 ], [ %ether.0, %if.then104 ], [ %ether.0, %do.body99 ]
  %header.2 = phi %struct.usb_cdc_header_desc* [ %header.0, %if.then5 ], [ %header.1, %sw.epilog ], [ %header.0, %if.then16 ], [ %header.0, %if.then ], [ %header.0, %sw.bb ], [ %header.0, %sw.bb19 ], [ %header.0, %sw.bb25 ], [ %header.0, %sw.bb34 ], [ %header.0, %sw.bb40 ], [ %header.0, %sw.bb49 ], [ %header.0, %sw.bb55 ], [ %header.0, %sw.bb61 ], [ %header.0, %sw.bb70 ], [ %header.0, %sw.bb79 ], [ %header.0, %sw.bb85 ], [ %header.0, %if.then104 ], [ %header.0, %do.body99 ]
  %union_header.2 = phi %struct.usb_cdc_union_desc* [ %union_header.0, %if.then5 ], [ %union_header.1, %sw.epilog ], [ %union_header.0, %if.then16 ], [ %union_header.0, %if.then ], [ %union_header.0, %sw.bb ], [ %union_header.0, %sw.bb19 ], [ %union_header.0, %sw.bb25 ], [ %union_header.0, %sw.bb34 ], [ %union_header.0, %sw.bb40 ], [ %union_header.0, %sw.bb49 ], [ %union_header.0, %sw.bb55 ], [ %union_header.0, %sw.bb61 ], [ %union_header.0, %sw.bb70 ], [ %union_header.0, %sw.bb79 ], [ %union_header.0, %sw.bb85 ], [ %union_header.0, %if.then104 ], [ %union_header.0, %do.body99 ]
  %cnt.1 = phi i32 [ %cnt.0, %if.then5 ], [ %inc, %sw.epilog ], [ %cnt.0, %if.then16 ], [ %cnt.0, %if.then ], [ %cnt.0, %sw.bb ], [ %cnt.0, %sw.bb19 ], [ %cnt.0, %sw.bb25 ], [ %cnt.0, %sw.bb34 ], [ %cnt.0, %sw.bb40 ], [ %cnt.0, %sw.bb49 ], [ %cnt.0, %sw.bb55 ], [ %cnt.0, %sw.bb61 ], [ %cnt.0, %sw.bb70 ], [ %cnt.0, %sw.bb79 ], [ %cnt.0, %sw.bb85 ], [ %cnt.0, %if.then104 ], [ %cnt.0, %do.body99 ]
  %sub = sub i32 %buflen.addr.0, %elength.0
  %idx.ext = zext i32 %elength.0 to i64
  %add.ptr = getelementptr inbounds i8, i8* %buffer.addr.0, i64 %idx.ext
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %usb_cdc_union_desc = getelementptr inbounds %struct.usb_cdc_parsed_header, %struct.usb_cdc_parsed_header* %hdr, i32 0, i32 0
  store %struct.usb_cdc_union_desc* %union_header.0, %struct.usb_cdc_union_desc** %usb_cdc_union_desc, align 8, !tbaa !493
  %usb_cdc_header_desc = getelementptr inbounds %struct.usb_cdc_parsed_header, %struct.usb_cdc_parsed_header* %hdr, i32 0, i32 1
  store %struct.usb_cdc_header_desc* %header.0, %struct.usb_cdc_header_desc** %usb_cdc_header_desc, align 8, !tbaa !494
  %usb_cdc_mdlm_detail_desc = getelementptr inbounds %struct.usb_cdc_parsed_header, %struct.usb_cdc_parsed_header* %hdr, i32 0, i32 9
  store %struct.usb_cdc_mdlm_detail_desc* %detail.0, %struct.usb_cdc_mdlm_detail_desc** %usb_cdc_mdlm_detail_desc, align 8, !tbaa !495
  %usb_cdc_mdlm_desc = getelementptr inbounds %struct.usb_cdc_parsed_header, %struct.usb_cdc_parsed_header* %hdr, i32 0, i32 8
  store %struct.usb_cdc_mdlm_desc* %desc.0, %struct.usb_cdc_mdlm_desc** %usb_cdc_mdlm_desc, align 8, !tbaa !496
  %usb_cdc_ether_desc = getelementptr inbounds %struct.usb_cdc_parsed_header, %struct.usb_cdc_parsed_header* %hdr, i32 0, i32 6
  store %struct.usb_cdc_ether_desc* %ether.0, %struct.usb_cdc_ether_desc** %usb_cdc_ether_desc, align 8, !tbaa !497
  br label %cleanup

cleanup:                                          ; preds = %while.end, %if.end75, %if.end66, %if.end45, %if.end30
  %retval.0 = phi i32 [ %cnt.0, %while.end ], [ -22, %if.end30 ], [ -22, %if.end45 ], [ -22, %if.end66 ], [ -22, %if.end75 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_driver_set_configuration(%struct.usb_device* %udev, i32 %config) #0 {
entry:
  %.compoundliteral = alloca %union.anon.3, align 8
  %call.i = call noalias i8* @__kmalloc(i64 112, i32 20971712) #8
  %0 = bitcast i8* %call.i to %struct.set_config_request*
  %tobool = icmp ne %struct.set_config_request* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %udev1 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 0
  store %struct.usb_device* %udev, %struct.usb_device** %udev1, align 8, !tbaa !498
  %config2 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 1
  store i32 %config, i32* %config2, align 8, !tbaa !500
  %work = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 2
  call void @__init_work(%struct.work_struct* %work, i32 0)
  %work3 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 2
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work3, i32 0, i32 0
  %counter = getelementptr inbounds %union.anon.3, %union.anon.3* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !287
  %1 = bitcast %union.anon.3* %data to i8*
  %2 = bitcast %union.anon.3* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 8, i32 8, i1 false), !tbaa.struct !288
  %work4 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 2
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work4, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.24.224, i32 0, i32 0), %struct.lock_class_key* @usb_driver_set_configuration.__key, i32 0)
  %work5 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 2
  %entry6 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work5, i32 0, i32 1
  call void @INIT_LIST_HEAD.225(%struct.list_head* %entry6)
  %work7 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 2
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work7, i32 0, i32 2
  store void (%struct.work_struct*)* @driver_set_config_work, void (%struct.work_struct*)** %func, align 8, !tbaa !289
  call void @_raw_spin_lock(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @set_config_lock, i32 0, i32 0, i32 0)) #8
  %node = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 3
  call void @list_add(%struct.list_head* %node, %struct.list_head* @set_config_list)
  call void @_raw_spin_unlock(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @set_config_lock, i32 0, i32 0, i32 0)) #8
  %call8 = call %struct.usb_device* @usb_get_dev(%struct.usb_device* %udev)
  %work9 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 2
  call void @schedule_work.228(%struct.work_struct* %work9)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.225(%struct.list_head* %list) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !72
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !87
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @driver_set_config_work(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.set_config_request*
  %udev1 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %1, i32 0, i32 0
  %2 = load %struct.usb_device*, %struct.usb_device** %udev1, align 8, !tbaa !498
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock.233(%struct.device* %dev)
  call void @_raw_spin_lock(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @set_config_lock, i32 0, i32 0, i32 0)) #8
  %node = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %1, i32 0, i32 3
  call void @list_del.234(%struct.list_head* %node)
  call void @_raw_spin_unlock(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @set_config_lock, i32 0, i32 0, i32 0)) #8
  %config = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %1, i32 0, i32 1
  %3 = load i32, i32* %config, align 8, !tbaa !500
  %cmp = icmp sge i32 %3, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %config2 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %1, i32 0, i32 1
  %4 = load i32, i32* %config2, align 8, !tbaa !500
  %call = call i32 @usb_set_configuration(%struct.usb_device* %2, i32 %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %dev3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock.237(%struct.device* %dev3)
  call void @usb_put_dev(%struct.usb_device* %2)
  %5 = bitcast %struct.set_config_request* %1 to i8*
  call void @kfree(i8* %5)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add(%struct.list_head* %new, %struct.list_head* %head) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !252
  call void @__list_add.230(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @schedule_work.228(%struct.work_struct* %work) #1 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8, !tbaa !52
  call void @queue_work.229(%struct.workqueue_struct* %0, %struct.work_struct* %work)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_work.229(%struct.workqueue_struct* %wq, %struct.work_struct* %work) #1 {
entry:
  %call = call zeroext i1 @queue_work_on(i32 8192, %struct.workqueue_struct* %wq, %struct.work_struct* %work)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add.230(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !87
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !252
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !87
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !72
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock.233(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del.234(%struct.list_head* %entry1) #1 {
entry:
  call void @__list_del_entry.288(%struct.list_head* %entry1)
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8, !tbaa !252
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8, !tbaa !87
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_set_configuration(%struct.usb_device* %dev, i32 %configuration) #0 {
entry:
  %.compoundliteral = alloca %union.anon.3, align 8
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.238(%struct.usb_bus* %0)
  %authorized = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 22
  %bf.load = load i16, i16* %authorized, align 4
  %bf.lshr = lshr i16 %bf.load, 3
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 0
  %cmp1 = icmp eq i32 %configuration, -1
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.end11, label %if.else

if.else:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %i.0 = phi i32 [ 0, %if.else ], [ %inc, %for.inc ]
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 13
  %1 = load i8, i8* %bNumConfigurations, align 1, !tbaa !193
  %conv = zext i8 %1 to i32
  %cmp2 = icmp slt i32 %i.0, %conv
  br i1 %cmp2, label %for.body, label %if.end11

for.body:                                         ; preds = %for.cond
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !194
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i64 %idxprom
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx, i32 0, i32 0
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 4
  %3 = load i8, i8* %bConfigurationValue, align 1, !tbaa !168
  %conv4 = zext i8 %3 to i32
  %cmp5 = icmp eq i32 %conv4, %configuration
  br i1 %cmp5, label %if.then7, label %for.inc

if.then7:                                         ; preds = %for.body
  %config8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  %4 = load %struct.usb_host_config*, %struct.usb_host_config** %config8, align 8, !tbaa !194
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %4, i64 %idxprom9
  br label %if.end11

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end11:                                         ; preds = %if.then7, %for.cond, %entry
  %cp.1 = phi %struct.usb_host_config* [ null, %entry ], [ %arrayidx10, %if.then7 ], [ null, %for.cond ]
  %configuration.addr.0 = phi i32 [ 0, %entry ], [ %configuration, %for.cond ], [ %configuration, %if.then7 ]
  %tobool = icmp eq %struct.usb_host_config* %cp.1, null
  %cmp12 = icmp ne i32 %configuration.addr.0, 0
  %or.cond1 = and i1 %tobool, %cmp12
  br i1 %or.cond1, label %cleanup234, label %if.end15

if.end15:                                         ; preds = %if.end11
  %tobool16 = icmp ne %struct.usb_host_config* %cp.1, null
  %cmp18 = icmp eq i32 %configuration.addr.0, 0
  %or.cond2 = and i1 %tobool16, %cmp18
  br i1 %or.cond2, label %if.then20, label %if.end22

if.then20:                                        ; preds = %if.end15
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end22

if.end22:                                         ; preds = %if.then20, %if.end15
  %tobool23 = icmp ne %struct.usb_host_config* %cp.1, null
  br i1 %tobool23, label %if.then24, label %if.end59

if.then24:                                        ; preds = %if.end22
  %desc25 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.1, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc25, i32 0, i32 3
  %5 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv26 = zext i8 %5 to i32
  %conv27 = sext i32 %conv26 to i64
  %mul = mul i64 %conv27, 8
  %call.i = call noalias i8* @__kmalloc(i64 %mul, i32 20971520) #8
  %6 = bitcast i8* %call.i to %struct.usb_interface**
  %tobool29 = icmp ne %struct.usb_interface** %6, null
  br i1 %tobool29, label %if.end31, label %cleanup234

if.end31:                                         ; preds = %if.then24
  br label %for.cond32

for.cond32:                                       ; preds = %for.inc48, %if.end31
  %n.0 = phi i32 [ 0, %if.end31 ], [ %inc49, %for.inc48 ]
  %cmp33 = icmp slt i32 %n.0, %conv26
  br i1 %cmp33, label %for.body35, label %for.end50

for.body35:                                       ; preds = %for.cond32
  %call36 = call i8* @kzalloc.240(i64 1568, i32 20971520)
  %7 = bitcast i8* %call36 to %struct.usb_interface*
  %idxprom37 = sext i32 %n.0 to i64
  %arrayidx38 = getelementptr inbounds %struct.usb_interface*, %struct.usb_interface** %6, i64 %idxprom37
  store %struct.usb_interface* %7, %struct.usb_interface** %arrayidx38, align 8, !tbaa !52
  %idxprom39 = sext i32 %n.0 to i64
  %arrayidx40 = getelementptr inbounds %struct.usb_interface*, %struct.usb_interface** %6, i64 %idxprom39
  %8 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx40, align 8, !tbaa !52
  %tobool41 = icmp ne %struct.usb_interface* %8, null
  br i1 %tobool41, label %for.inc48, label %free_interfaces

free_interfaces:                                  ; preds = %if.end83, %if.then72, %if.end59, %for.body35
  %n.1 = phi i32 [ %n.3, %if.then72 ], [ %n.3, %if.end83 ], [ %n.0, %for.body35 ], [ %n.3, %if.end59 ]
  %new_interfaces.0 = phi %struct.usb_interface** [ %new_interfaces.1, %if.then72 ], [ %new_interfaces.1, %if.end83 ], [ %6, %for.body35 ], [ %new_interfaces.1, %if.end59 ]
  %ret.0 = phi i32 [ -12, %if.then72 ], [ %call76, %if.end83 ], [ -12, %for.body35 ], [ %call60, %if.end59 ]
  br label %while.cond

while.cond:                                       ; preds = %while.body, %free_interfaces
  %n.2 = phi i32 [ %n.1, %free_interfaces ], [ %dec, %while.body ]
  %dec = add nsw i32 %n.2, -1
  %cmp43 = icmp sge i32 %dec, 0
  br i1 %cmp43, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %idxprom45 = sext i32 %dec to i64
  %arrayidx46 = getelementptr inbounds %struct.usb_interface*, %struct.usb_interface** %new_interfaces.0, i64 %idxprom45
  %9 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx46, align 8, !tbaa !52
  %10 = bitcast %struct.usb_interface* %9 to i8*
  call void @kfree(i8* %10)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %11 = bitcast %struct.usb_interface** %new_interfaces.0 to i8*
  call void @kfree(i8* %11)
  br label %cleanup234

for.inc48:                                        ; preds = %for.body35
  %inc49 = add nsw i32 %n.0, 1
  br label %for.cond32

for.end50:                                        ; preds = %for.cond32
  %bus_mA = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 19
  %12 = load i16, i16* %bus_mA, align 8, !tbaa !306
  %conv51 = zext i16 %12 to i32
  %call52 = call i32 @usb_get_max_power.241(%struct.usb_device* %dev, %struct.usb_host_config* %cp.1)
  %sub = sub i32 %conv51, %call52
  %cmp53 = icmp slt i32 %sub, 0
  br i1 %cmp53, label %if.then55, label %if.end59

if.then55:                                        ; preds = %for.end50
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end59

if.end59:                                         ; preds = %if.then55, %for.end50, %if.end22
  %nintf.0 = phi i32 [ 0, %if.end22 ], [ %conv26, %if.then55 ], [ %conv26, %for.end50 ]
  %n.3 = phi i32 [ 0, %if.end22 ], [ %n.0, %if.then55 ], [ %n.0, %for.end50 ]
  %new_interfaces.1 = phi %struct.usb_interface** [ null, %if.end22 ], [ %6, %if.then55 ], [ %6, %for.end50 ]
  %call60 = call i32 @usb_autoresume_device(%struct.usb_device* %dev)
  %tobool61 = icmp ne i32 %call60, 0
  br i1 %tobool61, label %free_interfaces, label %if.end63

if.end63:                                         ; preds = %if.end59
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 3
  %13 = load i32, i32* %state, align 8, !tbaa !54
  %cmp64 = icmp ne i32 %13, 6
  br i1 %cmp64, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.end63
  call void @usb_disable_device(%struct.usb_device* %dev, i32 1)
  br label %if.end67

if.end67:                                         ; preds = %if.then66, %if.end63
  call void @cancel_async_set_config(%struct.usb_device* %dev)
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %14 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !167
  call void @mutex_lock_nested(%struct.mutex* %14, i32 0)
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %15 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool68 = icmp ne %struct.usb_host_config* %15, null
  br i1 %tobool68, label %land.lhs.true69, label %if.end75

land.lhs.true69:                                  ; preds = %if.end67
  %call70 = call i32 @usb_disable_lpm(%struct.usb_device* %dev)
  %tobool71 = icmp ne i32 %call70, 0
  br i1 %tobool71, label %if.then72, label %if.end75

if.then72:                                        ; preds = %land.lhs.true69
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %bandwidth_mutex74 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %16 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex74, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %16)
  br label %free_interfaces

if.end75:                                         ; preds = %land.lhs.true69, %if.end67
  %call76 = call i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %dev, %struct.usb_host_config* %cp.1, %struct.usb_host_interface* null, %struct.usb_host_interface* null)
  %cmp77 = icmp slt i32 %call76, 0
  br i1 %cmp77, label %if.then79, label %if.end85

if.then79:                                        ; preds = %if.end75
  %actconfig80 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %17 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig80, align 8, !tbaa !102
  %tobool81 = icmp ne %struct.usb_host_config* %17, null
  br i1 %tobool81, label %if.then82, label %if.end83

if.then82:                                        ; preds = %if.then79
  call void @usb_enable_lpm(%struct.usb_device* %dev)
  br label %if.end83

if.end83:                                         ; preds = %if.then82, %if.then79
  %bandwidth_mutex84 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %18 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex84, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %18)
  call void @usb_autosuspend_device(%struct.usb_device* %dev)
  br label %free_interfaces

if.end85:                                         ; preds = %if.end75
  br label %for.cond86

for.cond86:                                       ; preds = %if.end108, %if.end85
  %i.1 = phi i32 [ 0, %if.end85 ], [ %inc140, %if.end108 ]
  %cmp87 = icmp slt i32 %i.1, %nintf.0
  br i1 %cmp87, label %for.body89, label %for.end141

for.body89:                                       ; preds = %for.cond86
  %idxprom90 = sext i32 %i.1 to i64
  %arrayidx91 = getelementptr inbounds %struct.usb_interface*, %struct.usb_interface** %new_interfaces.1, i64 %idxprom90
  %19 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx91, align 8, !tbaa !52
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.1, i32 0, i32 3
  %idxprom92 = sext i32 %i.1 to i64
  %arrayidx93 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom92
  store %struct.usb_interface* %19, %struct.usb_interface** %arrayidx93, align 8, !tbaa !52
  %intf_cache = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.1, i32 0, i32 4
  %idxprom94 = sext i32 %i.1 to i64
  %arrayidx95 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache, i64 0, i64 %idxprom94
  %20 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx95, align 8, !tbaa !52
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %20, i32 0, i32 2
  %arraydecay = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i32 0, i32 0
  %altsetting96 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 0
  store %struct.usb_host_interface* %arraydecay, %struct.usb_host_interface** %altsetting96, align 8, !tbaa !98
  %num_altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %20, i32 0, i32 0
  %21 = load i32, i32* %num_altsetting, align 8, !tbaa !107
  %num_altsetting97 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 2
  store i32 %21, i32* %num_altsetting97, align 8, !tbaa !97
  %flags = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 11
  %22 = load i64, i64* %flags, align 8, !tbaa !84
  %and = and i64 %22, 128
  %tobool98 = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool98, true
  %lnot99 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot99 to i32
  %authorized100 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 6
  %23 = trunc i32 %lnot.ext to i8
  %bf.load101 = load i8, i8* %authorized100, align 8
  %bf.value = and i8 %23, 1
  %bf.shl = shl i8 %bf.value, 7
  %bf.clear102 = and i8 %bf.load101, 127
  %bf.set = or i8 %bf.clear102, %bf.shl
  store i8 %bf.set, i8* %authorized100, align 8
  %ref = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %20, i32 0, i32 1
  call void @kref_get.246(%struct.kref* %ref)
  %call103 = call %struct.usb_host_interface* @usb_altnum_to_altsetting(%struct.usb_interface* %19, i32 0)
  %tobool104 = icmp ne %struct.usb_host_interface* %call103, null
  br i1 %tobool104, label %if.end108, label %if.then105

if.then105:                                       ; preds = %for.body89
  %altsetting106 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 0
  %24 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting106, align 8, !tbaa !98
  %arrayidx107 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %24, i64 0
  br label %if.end108

if.end108:                                        ; preds = %if.then105, %for.body89
  %alt.0 = phi %struct.usb_host_interface* [ %call103, %for.body89 ], [ %arrayidx107, %if.then105 ]
  %desc109 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc109, i32 0, i32 2
  %25 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !106
  %call110 = call %struct.usb_interface_assoc_descriptor* @find_iad(%struct.usb_host_config* %cp.1, i8 zeroext %25)
  %intf_assoc = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 3
  store %struct.usb_interface_assoc_descriptor* %call110, %struct.usb_interface_assoc_descriptor** %intf_assoc, align 8, !tbaa !501
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 1
  store %struct.usb_host_interface* %alt.0, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !169
  call void @usb_enable_interface(%struct.usb_device* %dev, %struct.usb_interface* %19, i1 zeroext true)
  %dev111 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %dev112 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 7
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev112, i32 0, i32 0
  store %struct.device* %dev111, %struct.device** %parent, align 8, !tbaa !300
  %dev113 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev113, i32 0, i32 7
  store %struct.device_driver* null, %struct.device_driver** %driver, align 8, !tbaa !118
  %dev114 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 7
  %bus115 = getelementptr inbounds %struct.device, %struct.device* %dev114, i32 0, i32 6
  store %struct.bus_type* @usb_bus_type, %struct.bus_type** %bus115, align 8, !tbaa !502
  %dev116 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 7
  %type = getelementptr inbounds %struct.device, %struct.device* %dev116, i32 0, i32 4
  store %struct.device_type* @usb_if_device_type, %struct.device_type** %type, align 8, !tbaa !503
  %dev117 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 7
  %groups = getelementptr inbounds %struct.device, %struct.device* %dev117, i32 0, i32 34
  store %struct.attribute_group** getelementptr inbounds ([3 x %struct.attribute_group*], [3 x %struct.attribute_group*]* @usb_interface_groups, i32 0, i32 0), %struct.attribute_group*** %groups, align 8, !tbaa !504
  %dev118 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %dma_mask = getelementptr inbounds %struct.device, %struct.device* %dev118, i32 0, i32 18
  %26 = load i64*, i64** %dma_mask, align 8, !tbaa !68
  %dev119 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 7
  %dma_mask120 = getelementptr inbounds %struct.device, %struct.device* %dev119, i32 0, i32 18
  store i64* %26, i64** %dma_mask120, align 8, !tbaa !505
  %dev121 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %dma_pfn_offset = getelementptr inbounds %struct.device, %struct.device* %dev121, i32 0, i32 20
  %27 = load i64, i64* %dma_pfn_offset, align 8, !tbaa !70
  %dev122 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 7
  %dma_pfn_offset123 = getelementptr inbounds %struct.device, %struct.device* %dev122, i32 0, i32 20
  store i64 %27, i64* %dma_pfn_offset123, align 8, !tbaa !506
  %reset_ws = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 10
  call void @__init_work(%struct.work_struct* %reset_ws, i32 0)
  %reset_ws124 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 10
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %reset_ws124, i32 0, i32 0
  %counter = getelementptr inbounds %union.anon.3, %union.anon.3* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !287
  %28 = bitcast %union.anon.3* %data to i8*
  %29 = bitcast %union.anon.3* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %28, i8* %29, i64 8, i32 8, i1 false), !tbaa.struct !288
  %reset_ws125 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 10
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %reset_ws125, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.20.249, i32 0, i32 0), %struct.lock_class_key* @usb_set_configuration.__key, i32 0)
  %reset_ws126 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 10
  %entry127 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %reset_ws126, i32 0, i32 1
  call void @INIT_LIST_HEAD.225(%struct.list_head* %entry127)
  %reset_ws128 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 10
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %reset_ws128, i32 0, i32 2
  store void (%struct.work_struct*)* @__usb_queue_reset_device, void (%struct.work_struct*)** %func, align 8, !tbaa !289
  %minor = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 4
  store i32 -1, i32* %minor, align 8, !tbaa !96
  %dev129 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 7
  call void @device_initialize(%struct.device* %dev129)
  %dev130 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 7
  call void @pm_runtime_no_callbacks(%struct.device* %dev130)
  %dev131 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 7
  %bus132 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %30 = load %struct.usb_bus*, %struct.usb_bus** %bus132, align 8, !tbaa !2
  %busnum = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %30, i32 0, i32 1
  %31 = load i32, i32* %busnum, align 8, !tbaa !41
  %devpath = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 1
  %arraydecay133 = getelementptr inbounds [16 x i8], [16 x i8]* %devpath, i32 0, i32 0
  %desc134 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 0
  %bInterfaceNumber135 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc134, i32 0, i32 2
  %32 = load i8, i8* %bInterfaceNumber135, align 2, !tbaa !106
  %conv136 = zext i8 %32 to i32
  %call137 = call i32 (%struct.device*, i8*, ...) @dev_set_name(%struct.device* %dev131, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.21.250, i32 0, i32 0), i32 %31, i8* %arraydecay133, i32 %configuration.addr.0, i32 %conv136)
  %call138 = call %struct.usb_device* @usb_get_dev(%struct.usb_device* %dev)
  %inc140 = add nsw i32 %i.1, 1
  br label %for.cond86

for.end141:                                       ; preds = %for.cond86
  %33 = bitcast %struct.usb_interface** %new_interfaces.1 to i8*
  call void @kfree(i8* %33)
  %call142 = call i32 @__create_pipe.251(%struct.usb_device* %dev, i32 0)
  %or = or i32 -2147483648, %call142
  %conv143 = trunc i32 %configuration.addr.0 to i16
  %call144 = call i32 @usb_control_msg(%struct.usb_device* %dev, i32 %or, i8 zeroext 9, i8 zeroext 0, i16 zeroext %conv143, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  %cmp145 = icmp slt i32 %call144, 0
  %tobool148 = icmp ne %struct.usb_host_config* %cp.1, null
  %or.cond3 = and i1 %cmp145, %tobool148
  br i1 %or.cond3, label %if.then149, label %if.end168

if.then149:                                       ; preds = %for.end141
  %call150 = call i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %dev, %struct.usb_host_config* null, %struct.usb_host_interface* null, %struct.usb_host_interface* null)
  br label %for.cond151

for.cond151:                                      ; preds = %for.body154, %if.then149
  %i.2 = phi i32 [ 0, %if.then149 ], [ %inc166, %for.body154 ]
  %cmp152 = icmp slt i32 %i.2, %nintf.0
  br i1 %cmp152, label %for.body154, label %if.end168

for.body154:                                      ; preds = %for.cond151
  %interface155 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.1, i32 0, i32 3
  %idxprom156 = sext i32 %i.2 to i64
  %arrayidx157 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface155, i64 0, i64 %idxprom156
  %34 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx157, align 8, !tbaa !52
  call void @usb_disable_interface(%struct.usb_device* %dev, %struct.usb_interface* %34, i1 zeroext true)
  %interface158 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.1, i32 0, i32 3
  %idxprom159 = sext i32 %i.2 to i64
  %arrayidx160 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface158, i64 0, i64 %idxprom159
  %35 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx160, align 8, !tbaa !52
  %dev161 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %35, i32 0, i32 7
  call void @put_device(%struct.device* %dev161)
  %interface162 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.1, i32 0, i32 3
  %idxprom163 = sext i32 %i.2 to i64
  %arrayidx164 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface162, i64 0, i64 %idxprom163
  store %struct.usb_interface* null, %struct.usb_interface** %arrayidx164, align 8, !tbaa !52
  %inc166 = add nsw i32 %i.2, 1
  br label %for.cond151

if.end168:                                        ; preds = %for.cond151, %for.end141
  %cp.2 = phi %struct.usb_host_config* [ %cp.1, %for.end141 ], [ null, %for.cond151 ]
  %actconfig169 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  store %struct.usb_host_config* %cp.2, %struct.usb_host_config** %actconfig169, align 8, !tbaa !102
  %bandwidth_mutex170 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %36 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex170, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %36)
  %tobool171 = icmp ne %struct.usb_host_config* %cp.2, null
  br i1 %tobool171, label %if.end173, label %if.then172

if.then172:                                       ; preds = %if.end168
  call void @usb_set_device_state(%struct.usb_device* %dev, i32 6)
  call void @usb_autosuspend_device(%struct.usb_device* %dev)
  br label %cleanup234

if.end173:                                        ; preds = %if.end168
  call void @usb_set_device_state(%struct.usb_device* %dev, i32 7)
  %string = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.2, i32 0, i32 1
  %37 = load i8*, i8** %string, align 8, !tbaa !507
  %cmp174 = icmp eq i8* %37, null
  br i1 %cmp174, label %land.lhs.true176, label %if.end185

land.lhs.true176:                                 ; preds = %if.end173
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 29
  %38 = load i32, i32* %quirks, align 4, !tbaa !199
  %conv177 = zext i32 %38 to i64
  %and178 = and i64 %conv177, 8
  %tobool179 = icmp ne i64 %and178, 0
  br i1 %tobool179, label %if.end185, label %if.then180

if.then180:                                       ; preds = %land.lhs.true176
  %desc181 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.2, i32 0, i32 0
  %iConfiguration = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc181, i32 0, i32 5
  %39 = load i8, i8* %iConfiguration, align 2, !tbaa !508
  %conv182 = zext i8 %39 to i32
  %call183 = call i8* @usb_cache_string(%struct.usb_device* %dev, i32 %conv182)
  %string184 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.2, i32 0, i32 1
  store i8* %call183, i8** %string184, align 8, !tbaa !507
  br label %if.end185

if.end185:                                        ; preds = %if.then180, %land.lhs.true176, %if.end173
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %dev)
  call void @usb_enable_ltm(%struct.usb_device* %dev)
  br label %for.cond186

for.cond186:                                      ; preds = %LeafBlock, %if.end185
  %i.3 = phi i32 [ 0, %if.end185 ], [ %inc232, %LeafBlock ]
  %cmp187 = icmp slt i32 %i.3, %nintf.0
  br i1 %cmp187, label %for.body189, label %for.end233

for.body189:                                      ; preds = %for.cond186
  %interface191 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.2, i32 0, i32 3
  %idxprom192 = sext i32 %i.3 to i64
  %arrayidx193 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface191, i64 0, i64 %idxprom192
  %40 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx193, align 8, !tbaa !52
  %bf.load196 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_set_configuration.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr197 = lshr i32 %bf.load196, 18
  %bf.clear198 = and i32 %bf.lshr197, 255
  %and199 = and i32 %bf.clear198, 1
  %tobool200 = icmp ne i32 %and199, 0
  %lnot201 = xor i1 %tobool200, true
  %lnot203 = xor i1 %lnot201, true
  %lnot.ext204 = zext i1 %lnot203 to i32
  %conv205 = sext i32 %lnot.ext204 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv205, i64 0)
  %tobool206 = icmp ne i64 %expval, 0
  br i1 %tobool206, label %if.then207, label %do.end219

if.then207:                                       ; preds = %for.body189
  %dev208 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %dev209 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %40, i32 0, i32 7
  %call210 = call i8* @dev_name.258(%struct.device* %dev209)
  %cur_altsetting211 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %40, i32 0, i32 1
  %41 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting211, align 8, !tbaa !169
  %desc212 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %41, i32 0, i32 0
  %bInterfaceNumber213 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc212, i32 0, i32 2
  %42 = load i8, i8* %bInterfaceNumber213, align 2, !tbaa !106
  %conv214 = zext i8 %42 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_set_configuration.descriptor to %struct._ddebug*), %struct.device* %dev208, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.22.259, i32 0, i32 0), i8* %call210, i32 %configuration.addr.0, i32 %conv214)
  br label %do.end219

do.end219:                                        ; preds = %if.then207, %for.body189
  %dev220 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %40, i32 0, i32 7
  call void @device_enable_async_suspend.260(%struct.device* %dev220)
  %dev221 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %40, i32 0, i32 7
  %call222 = call i32 @device_add(%struct.device* %dev221)
  %cmp223 = icmp ne i32 %call222, 0
  br i1 %cmp223, label %if.then225, label %if.end229

if.then225:                                       ; preds = %do.end219
  %dev227 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %40, i32 0, i32 7
  %call228 = call i8* @dev_name.258(%struct.device* %dev227)
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %LeafBlock

if.end229:                                        ; preds = %do.end219
  call void @create_intf_ep_devs(%struct.usb_interface* %40)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end229, %if.then225
  %inc232 = add nsw i32 %i.3, 1
  br label %for.cond186

for.end233:                                       ; preds = %for.cond186
  call void @usb_autosuspend_device(%struct.usb_device* %dev)
  br label %cleanup234

cleanup234:                                       ; preds = %for.end233, %if.then172, %while.end, %if.then24, %if.end11
  %retval.0 = phi i32 [ %ret.0, %while.end ], [ 0, %for.end233 ], [ %call144, %if.then172 ], [ -22, %if.end11 ], [ -12, %if.then24 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock.237(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd* @bus_to_hcd.238(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd*
  ret %struct.usb_hcd* %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.240(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call noalias i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_get_max_power.241(%struct.usb_device* %udev, %struct.usb_host_config* %c) #1 {
entry:
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp uge i32 %0, 5
  %cond = select i1 %cmp, i32 8, i32 2
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %c, i32 0, i32 0
  %bMaxPower = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 7
  %1 = load i8, i8* %bMaxPower, align 8, !tbaa !331
  %conv = zext i8 %1 to i32
  %mul1 = mul i32 %conv, %cond
  ret i32 %mul1
}

; Function Attrs: nounwind uwtable
define void @usb_disable_device(%struct.usb_device* %dev, i32 %skip_ep0) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.238(%struct.usb_bus* %0)
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %1 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_host_config* %1, null
  br i1 %tobool, label %if.then, label %do.body76

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %actconfig1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig1, align 8, !tbaa !102
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %3 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv = zext i8 %3 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %actconfig3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %4 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig3, align 8, !tbaa !102
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %4, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %5 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !52
  %unregistering = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %5, i32 0, i32 6
  %bf.load = load i8, i8* %unregistering, align 8
  %bf.clear = and i8 %bf.load, -5
  %bf.set = or i8 %bf.clear, 4
  store i8 %bf.set, i8* %unregistering, align 8
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond4

for.cond4:                                        ; preds = %LeafBlock, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc37, %LeafBlock ]
  %actconfig5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %6 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig5, align 8, !tbaa !102
  %desc6 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %6, i32 0, i32 0
  %bNumInterfaces7 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc6, i32 0, i32 3
  %7 = load i8, i8* %bNumInterfaces7, align 4, !tbaa !103
  %conv8 = zext i8 %7 to i32
  %cmp9 = icmp slt i32 %i.1, %conv8
  br i1 %cmp9, label %for.body11, label %for.end38

for.body11:                                       ; preds = %for.cond4
  %actconfig13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %8 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig13, align 8, !tbaa !102
  %interface14 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %8, i32 0, i32 3
  %idxprom15 = sext i32 %i.1 to i64
  %arrayidx16 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface14, i64 0, i64 %idxprom15
  %9 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx16, align 8, !tbaa !52
  %dev17 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %9, i32 0, i32 7
  %call18 = call i32 @device_is_registered(%struct.device* %dev17)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %do.body21, label %LeafBlock

do.body21:                                        ; preds = %for.body11
  %bf.load22 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_disable_device.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load22, 18
  %bf.clear23 = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear23, 1
  %tobool24 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool24, true
  %lnot25 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot25 to i32
  %conv26 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv26, i64 0)
  %tobool27 = icmp ne i64 %expval, 0
  br i1 %tobool27, label %if.then28, label %do.end34

if.then28:                                        ; preds = %do.body21
  %dev29 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %dev30 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %9, i32 0, i32 7
  %call31 = call i8* @dev_name.258(%struct.device* %dev30)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_disable_device.descriptor to %struct._ddebug*), %struct.device* %dev29, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.6.284, i32 0, i32 0), i8* %call31)
  br label %do.end34

do.end34:                                         ; preds = %if.then28, %do.body21
  call void @remove_intf_ep_devs(%struct.usb_interface* %9)
  %dev35 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %9, i32 0, i32 7
  call void @device_del(%struct.device* %dev35)
  br label %LeafBlock

LeafBlock:                                        ; preds = %do.end34, %for.body11
  %inc37 = add nsw i32 %i.1, 1
  br label %for.cond4

for.end38:                                        ; preds = %for.cond4
  br label %for.cond39

for.cond39:                                       ; preds = %for.body46, %for.end38
  %i.2 = phi i32 [ 0, %for.end38 ], [ %inc57, %for.body46 ]
  %actconfig40 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %10 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig40, align 8, !tbaa !102
  %desc41 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %10, i32 0, i32 0
  %bNumInterfaces42 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc41, i32 0, i32 3
  %11 = load i8, i8* %bNumInterfaces42, align 4, !tbaa !103
  %conv43 = zext i8 %11 to i32
  %cmp44 = icmp slt i32 %i.2, %conv43
  br i1 %cmp44, label %for.body46, label %for.end58

for.body46:                                       ; preds = %for.cond39
  %actconfig47 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %12 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig47, align 8, !tbaa !102
  %interface48 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %12, i32 0, i32 3
  %idxprom49 = sext i32 %i.2 to i64
  %arrayidx50 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface48, i64 0, i64 %idxprom49
  %13 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx50, align 8, !tbaa !52
  %dev51 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %13, i32 0, i32 7
  call void @put_device(%struct.device* %dev51)
  %actconfig52 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %14 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig52, align 8, !tbaa !102
  %interface53 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %14, i32 0, i32 3
  %idxprom54 = sext i32 %i.2 to i64
  %arrayidx55 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface53, i64 0, i64 %idxprom54
  store %struct.usb_interface* null, %struct.usb_interface** %arrayidx55, align 8, !tbaa !52
  %inc57 = add nsw i32 %i.2, 1
  br label %for.cond39

for.end58:                                        ; preds = %for.cond39
  %usb2_hw_lpm_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 22
  %bf.load59 = load i16, i16* %usb2_hw_lpm_enabled, align 4
  %bf.lshr60 = lshr i16 %bf.load59, 9
  %bf.clear61 = and i16 %bf.lshr60, 1
  %bf.cast = zext i16 %bf.clear61 to i32
  %cmp62 = icmp eq i32 %bf.cast, 1
  br i1 %cmp62, label %if.then64, label %if.end66

if.then64:                                        ; preds = %for.end58
  %call65 = call i32 @usb_set_usb2_hardware_lpm(%struct.usb_device* %dev, i32 0)
  br label %if.end66

if.end66:                                         ; preds = %if.then64, %for.end58
  %call67 = call i32 @usb_unlocked_disable_lpm(%struct.usb_device* %dev)
  %call68 = call i32 @usb_disable_ltm(%struct.usb_device* %dev)
  %actconfig69 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  store %struct.usb_host_config* null, %struct.usb_host_config** %actconfig69, align 8, !tbaa !102
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 3
  %15 = load i32, i32* %state, align 8, !tbaa !54
  %cmp70 = icmp eq i32 %15, 7
  br i1 %cmp70, label %if.then72, label %do.body76

if.then72:                                        ; preds = %if.end66
  call void @usb_set_device_state(%struct.usb_device* %dev, i32 6)
  br label %do.body76

do.body76:                                        ; preds = %if.then72, %if.end66, %entry
  %bf.load77 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_disable_device.descriptor.7 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr78 = lshr i32 %bf.load77, 18
  %bf.clear79 = and i32 %bf.lshr78, 255
  %and80 = and i32 %bf.clear79, 1
  %tobool81 = icmp ne i32 %and80, 0
  %lnot82 = xor i1 %tobool81, true
  %lnot84 = xor i1 %lnot82, true
  %lnot.ext85 = zext i1 %lnot84 to i32
  %conv86 = sext i32 %lnot.ext85 to i64
  %expval87 = call i64 @llvm.expect.i64(i64 %conv86, i64 0)
  %tobool88 = icmp ne i64 %expval87, 0
  br i1 %tobool88, label %if.then89, label %do.end96

if.then89:                                        ; preds = %do.body76
  %dev90 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %tobool91 = icmp ne i32 %skip_ep0, 0
  %cond = select i1 %tobool91, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.9.285, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7.459, i32 0, i32 0)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_disable_device.descriptor.7 to %struct._ddebug*), %struct.device* %dev90, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.8.287, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.usb_disable_device, i32 0, i32 0), i8* %cond)
  br label %do.end96

do.end96:                                         ; preds = %if.then89, %do.body76
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %16 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %check_bandwidth = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %16, i32 0, i32 32
  %17 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %check_bandwidth, align 8, !tbaa !460
  %tobool97 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*)* %17, null
  br i1 %tobool97, label %if.then98, label %if.end108

if.then98:                                        ; preds = %do.end96
  br label %for.cond99

for.cond99:                                       ; preds = %for.body102, %if.then98
  %i.3 = phi i32 [ %skip_ep0, %if.then98 ], [ %inc104, %for.body102 ]
  %cmp100 = icmp slt i32 %i.3, 16
  br i1 %cmp100, label %for.body102, label %for.end105

for.body102:                                      ; preds = %for.cond99
  call void @usb_disable_endpoint(%struct.usb_device* %dev, i32 %i.3, i1 zeroext false)
  %add = add nsw i32 %i.3, 128
  call void @usb_disable_endpoint(%struct.usb_device* %dev, i32 %add, i1 zeroext false)
  %inc104 = add nsw i32 %i.3, 1
  br label %for.cond99

for.end105:                                       ; preds = %for.cond99
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %18 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !167
  call void @mutex_lock_nested(%struct.mutex* %18, i32 0)
  %call106 = call i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %dev, %struct.usb_host_config* null, %struct.usb_host_interface* null, %struct.usb_host_interface* null)
  %bandwidth_mutex107 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %19 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex107, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %19)
  br label %if.end108

if.end108:                                        ; preds = %for.end105, %do.end96
  br label %for.cond109

for.cond109:                                      ; preds = %for.body112, %if.end108
  %i.4 = phi i32 [ %skip_ep0, %if.end108 ], [ %inc115, %for.body112 ]
  %cmp110 = icmp slt i32 %i.4, 16
  br i1 %cmp110, label %for.body112, label %for.end116

for.body112:                                      ; preds = %for.cond109
  call void @usb_disable_endpoint(%struct.usb_device* %dev, i32 %i.4, i1 zeroext true)
  %add113 = add nsw i32 %i.4, 128
  call void @usb_disable_endpoint(%struct.usb_device* %dev, i32 %add113, i1 zeroext true)
  %inc115 = add nsw i32 %i.4, 1
  br label %for.cond109

for.end116:                                       ; preds = %for.cond109
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @cancel_async_set_config(%struct.usb_device* %udev) #0 {
entry:
  call void @_raw_spin_lock(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @set_config_lock, i32 0, i32 0, i32 0)) #8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @set_config_list, i32 0, i32 0), %entry ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !52
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr6 = getelementptr inbounds i8, i8* %1, i64 -96
  %2 = bitcast i8* %add.ptr6 to %struct.set_config_request*
  %node = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %2, i32 0, i32 3
  %cmp = icmp ne %struct.list_head* %node, @set_config_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %udev1 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %2, i32 0, i32 0
  %3 = load %struct.usb_device*, %struct.usb_device** %udev1, align 8, !tbaa !498
  %cmp2 = icmp eq %struct.usb_device* %3, %udev
  br i1 %cmp2, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %config = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %2, i32 0, i32 1
  store i32 -999, i32* %config, align 8, !tbaa !500
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %node4 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %2, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %node4, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @_raw_spin_unlock(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @set_config_lock, i32 0, i32 0, i32 0)) #8
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_get.246(%struct.kref* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  call void @refcount_inc(%struct.qspinlock* %refcount)
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.usb_interface_assoc_descriptor* @find_iad(%struct.usb_host_config* %config, i8 zeroext %inum) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %retval1.0 = phi %struct.usb_interface_assoc_descriptor* [ null, %entry ], [ %retval1.3, %for.inc ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 16
  br i1 %cmp, label %land.rhs, label %for.end

land.rhs:                                         ; preds = %for.cond
  %intf_assoc2 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 2
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x %struct.usb_interface_assoc_descriptor*], [16 x %struct.usb_interface_assoc_descriptor*]* %intf_assoc2, i64 0, i64 %idxprom
  %0 = load %struct.usb_interface_assoc_descriptor*, %struct.usb_interface_assoc_descriptor** %arrayidx, align 8, !tbaa !52
  %tobool = icmp ne %struct.usb_interface_assoc_descriptor* %0, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %land.rhs
  %intf_assoc3 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 2
  %idxprom4 = sext i32 %i.0 to i64
  %arrayidx5 = getelementptr inbounds [16 x %struct.usb_interface_assoc_descriptor*], [16 x %struct.usb_interface_assoc_descriptor*]* %intf_assoc3, i64 0, i64 %idxprom4
  %1 = load %struct.usb_interface_assoc_descriptor*, %struct.usb_interface_assoc_descriptor** %arrayidx5, align 8, !tbaa !52
  %bInterfaceCount = getelementptr inbounds %struct.usb_interface_assoc_descriptor, %struct.usb_interface_assoc_descriptor* %1, i32 0, i32 3
  %2 = load i8, i8* %bInterfaceCount, align 1, !tbaa !509
  %conv = zext i8 %2 to i32
  %cmp6 = icmp eq i32 %conv, 0
  br i1 %cmp6, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %bFirstInterface = getelementptr inbounds %struct.usb_interface_assoc_descriptor, %struct.usb_interface_assoc_descriptor* %1, i32 0, i32 2
  %3 = load i8, i8* %bFirstInterface, align 1, !tbaa !511
  %conv8 = zext i8 %3 to i32
  %bInterfaceCount9 = getelementptr inbounds %struct.usb_interface_assoc_descriptor, %struct.usb_interface_assoc_descriptor* %1, i32 0, i32 3
  %4 = load i8, i8* %bInterfaceCount9, align 1, !tbaa !509
  %conv10 = zext i8 %4 to i32
  %sub = sub nsw i32 %conv10, 1
  %add = add nsw i32 %conv8, %sub
  %conv11 = zext i8 %inum to i32
  %cmp12 = icmp sge i32 %conv11, %conv8
  %conv14 = zext i8 %inum to i32
  %cmp15 = icmp sle i32 %conv14, %add
  %or.cond = and i1 %cmp12, %cmp15
  br i1 %or.cond, label %if.then17, label %for.inc

if.then17:                                        ; preds = %if.end
  %tobool18 = icmp ne %struct.usb_interface_assoc_descriptor* %retval1.0, null
  br i1 %tobool18, label %if.else, label %for.inc

if.else:                                          ; preds = %if.then17
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %for.inc

for.inc:                                          ; preds = %if.else, %if.then17, %if.end, %for.body
  %retval1.3 = phi %struct.usb_interface_assoc_descriptor* [ %retval1.0, %for.body ], [ %retval1.0, %if.end ], [ %retval1.0, %if.else ], [ %1, %if.then17 ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %land.rhs, %for.cond
  ret %struct.usb_interface_assoc_descriptor* %retval1.0
}

; Function Attrs: nounwind uwtable
define void @usb_enable_interface(%struct.usb_device* %dev, %struct.usb_interface* %intf, i1 zeroext %reset_eps) #0 {
entry:
  %frombool = zext i1 %reset_eps to i8
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %0 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !169
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 4
  %1 = load i8, i8* %bNumEndpoints, align 4, !tbaa !172
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 3
  %2 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !173
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %2, i64 %idxprom
  %tobool = trunc i8 %frombool to i1
  call void @usb_enable_endpoint(%struct.usb_device* %dev, %struct.usb_host_endpoint* %arrayidx, i1 zeroext %tobool)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__usb_queue_reset_device(%struct.work_struct* %ws) #0 {
entry:
  %0 = bitcast %struct.work_struct* %ws to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -1488
  %1 = bitcast i8* %add.ptr to %struct.usb_interface*
  %call = call %struct.usb_device* @interface_to_usbdev.213(%struct.usb_interface* %1)
  %call1 = call i32 @usb_lock_device_for_reset(%struct.usb_device* %call, %struct.usb_interface* %1)
  %cmp = icmp sge i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call i32 @usb_reset_device(%struct.usb_device* %call)
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 11
  call void @device_unlock.237(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @usb_put_intf(%struct.usb_interface* %1)
  ret void
}

declare void @pm_runtime_no_callbacks(%struct.device*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__create_pipe.251(%struct.usb_device* %dev, i32 %endpoint) #1 {
entry:
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 0
  %0 = load i32, i32* %devnum, align 8, !tbaa !44
  %shl = shl i32 %0, 8
  %shl1 = shl i32 %endpoint, 15
  %or = or i32 %shl, %shl1
  ret i32 %or
}

; Function Attrs: nounwind uwtable
define i32 @usb_control_msg(%struct.usb_device* %dev, i32 %pipe, i8 zeroext %request, i8 zeroext %requesttype, i16 zeroext %value, i16 zeroext %index, i8* %data, i16 zeroext %size, i32 %timeout) #0 {
entry:
  %call.i = call noalias i8* @__kmalloc(i64 8, i32 20971520) #8
  %0 = bitcast i8* %call.i to %struct.usb_ctrlrequest*
  %tobool = icmp ne %struct.usb_ctrlrequest* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %bRequestType = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %0, i32 0, i32 0
  store i8 %requesttype, i8* %bRequestType, align 1, !tbaa !448
  %bRequest = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %0, i32 0, i32 1
  store i8 %request, i8* %bRequest, align 1, !tbaa !450
  %wValue = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %0, i32 0, i32 2
  store i16 %value, i16* %wValue, align 1, !tbaa !451
  %wIndex = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %0, i32 0, i32 3
  store i16 %index, i16* %wIndex, align 1, !tbaa !452
  %wLength = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %0, i32 0, i32 4
  store i16 %size, i16* %wLength, align 1, !tbaa !453
  %conv = zext i16 %size to i32
  %call1 = call i32 @usb_internal_control_msg(%struct.usb_device* %dev, i32 %pipe, %struct.usb_ctrlrequest* %0, i8* %data, i32 %conv, i32 %timeout)
  %1 = bitcast %struct.usb_ctrlrequest* %0 to i8*
  call void @kfree(i8* %1)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call1, %if.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_disable_interface(%struct.usb_device* %dev, %struct.usb_interface* %intf, i1 zeroext %reset_hardware) #0 {
entry:
  %frombool = zext i1 %reset_hardware to i8
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %0 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !169
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 4
  %1 = load i8, i8* %bNumEndpoints, align 4, !tbaa !172
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 3
  %2 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !173
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %2, i64 %idxprom
  %desc2 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 0
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc2, i32 0, i32 2
  %3 = load i8, i8* %bEndpointAddress, align 2, !tbaa !512
  %conv3 = zext i8 %3 to i32
  %tobool = trunc i8 %frombool to i1
  call void @usb_disable_endpoint(%struct.usb_device* %dev, i32 %conv3, i1 zeroext %tobool)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @usb_cache_string(%struct.usb_device* %udev, i32 %index) #0 {
entry:
  %cmp = icmp sle i32 %index, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call.i1 = call noalias i8* @__kmalloc(i64 382, i32 20971520) #8
  %tobool = icmp ne i8* %call.i1, null
  br i1 %tobool, label %if.then1, label %cleanup

if.then1:                                         ; preds = %if.end
  %call2 = call i32 @usb_string(%struct.usb_device* %udev, i32 %index, i8* %call.i1, i64 382)
  %cmp3 = icmp sgt i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end11

if.then4:                                         ; preds = %if.then1
  %inc = add nsw i32 %call2, 1
  %conv = sext i32 %inc to i64
  %call.i = call noalias i8* @__kmalloc(i64 %conv, i32 20971520) #8
  %tobool6 = icmp ne i8* %call.i, null
  br i1 %tobool6, label %if.end8, label %cleanup

if.end8:                                          ; preds = %if.then4
  %conv9 = sext i32 %inc to i64
  %call10 = call i8* @__memcpy(i8* %call.i, i8* %call.i1, i64 %conv9)
  br label %if.end11

if.end11:                                         ; preds = %if.end8, %if.then1
  %smallbuf.0 = phi i8* [ %call.i, %if.end8 ], [ null, %if.then1 ]
  call void @kfree(i8* %call.i1)
  br label %cleanup

cleanup:                                          ; preds = %if.end11, %if.then4, %if.end, %entry
  %retval.0 = phi i8* [ null, %entry ], [ %call.i1, %if.then4 ], [ %smallbuf.0, %if.end11 ], [ null, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name.258(%struct.device* %dev) #1 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !299
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !299
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name.262(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_enable_async_suspend.260(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %is_prepared = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i16, i16* %is_prepared, align 4
  %bf.lshr = lshr i16 %bf.load, 3
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = trunc i16 %bf.clear to i1
  br i1 %bf.cast, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %power1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %async_suspend = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power1, i32 0, i32 1
  %bf.load2 = load i16, i16* %async_suspend, align 4
  %bf.clear3 = and i16 %bf.load2, -3
  %bf.set = or i16 %bf.clear3, 2
  store i16 %bf.set, i16* %async_suspend, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @create_intf_ep_devs(%struct.usb_interface* %intf) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev.213(%struct.usb_interface* %intf)
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %0 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !169
  %ep_devs_created = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load = load i8, i8* %ep_devs_created, align 8
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %unregistering = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load1 = load i8, i8* %unregistering, align 8
  %bf.lshr2 = lshr i8 %bf.load1, 2
  %bf.clear3 = and i8 %bf.lshr2, 1
  %bf.cast4 = zext i8 %bf.clear3 to i32
  %tobool5 = icmp ne i32 %bf.cast4, 0
  br i1 %tobool5, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 4
  %1 = load i8, i8* %bNumEndpoints, align 4, !tbaa !172
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 3
  %2 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !173
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %2, i64 %idxprom
  %call7 = call i32 bitcast (i32 (%struct.device.3441*, %struct.usb_host_endpoint*, %struct.usb_device.3478*)* @usb_create_ep_devs to i32 (%struct.device*, %struct.usb_host_endpoint*, %struct.usb_device*)*)(%struct.device* %dev, %struct.usb_host_endpoint* %arrayidx, %struct.usb_device* %call)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %ep_devs_created8 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load9 = load i8, i8* %ep_devs_created8, align 8
  %bf.clear10 = and i8 %bf.load9, -3
  %bf.set = or i8 %bf.clear10, 2
  store i8 %bf.set, i8* %ep_devs_created8, align 8
  br label %cleanup

cleanup:                                          ; preds = %for.end, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name.262(%struct.kobject* %kobj) #1 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !409
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define i32 @usb_string(%struct.usb_device* %dev, i32 %index, i8* %buf, i64 %size) #0 {
entry:
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %0, 8
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp ugt i64 %size, 0
  %tobool = icmp ne i8* %buf, null
  %or.cond = and i1 %cmp1, %tobool
  %tobool3 = icmp ne i32 %index, 0
  %or.cond1 = and i1 %or.cond, %tobool3
  br i1 %or.cond1, label %if.end5, label %cleanup

if.end5:                                          ; preds = %if.end
  %arrayidx = getelementptr inbounds i8, i8* %buf, i64 0
  store i8 0, i8* %arrayidx, align 1, !tbaa !72
  %call.i = call noalias i8* @__kmalloc(i64 256, i32 20971520) #8
  %tobool6 = icmp ne i8* %call.i, null
  br i1 %tobool6, label %if.end8, label %cleanup

if.end8:                                          ; preds = %if.end5
  %call9 = call i32 @usb_get_langid(%struct.usb_device* %dev, i8* %call.i)
  %cmp10 = icmp slt i32 %call9, 0
  br i1 %cmp10, label %errout, label %if.end12

if.end12:                                         ; preds = %if.end8
  %string_langid = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 23
  %1 = load i32, i32* %string_langid, align 8, !tbaa !513
  %call13 = call i32 @usb_string_sub(%struct.usb_device* %dev, i32 %1, i32 %index, i8* %call.i)
  %cmp14 = icmp slt i32 %call13, 0
  br i1 %cmp14, label %errout, label %if.end16

if.end16:                                         ; preds = %if.end12
  %dec = add i64 %size, -1
  %arrayidx17 = getelementptr inbounds i8, i8* %call.i, i64 2
  %2 = bitcast i8* %arrayidx17 to i16*
  %sub = sub nsw i32 %call13, 2
  %div = sdiv i32 %sub, 2
  %conv = trunc i64 %dec to i32
  %call18 = call i32 @utf16s_to_utf8s(i16* %2, i32 %div, i32 1, i8* %buf, i32 %conv)
  %idxprom = sext i32 %call18 to i64
  %arrayidx19 = getelementptr inbounds i8, i8* %buf, i64 %idxprom
  store i8 0, i8* %arrayidx19, align 1, !tbaa !72
  %arrayidx20 = getelementptr inbounds i8, i8* %call.i, i64 1
  %3 = load i8, i8* %arrayidx20, align 1, !tbaa !72
  %conv21 = zext i8 %3 to i32
  %cmp22 = icmp ne i32 %conv21, 3
  br i1 %cmp22, label %do.body25, label %errout

do.body25:                                        ; preds = %if.end16
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_string.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool26 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool26, true
  %lnot27 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot27 to i32
  %conv28 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool29 = icmp ne i64 %expval, 0
  br i1 %tobool29, label %if.then30, label %errout

if.then30:                                        ; preds = %do.body25
  %dev31 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %arrayidx32 = getelementptr inbounds i8, i8* %call.i, i64 1
  %4 = load i8, i8* %arrayidx32, align 1, !tbaa !72
  %conv33 = zext i8 %4 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_string.descriptor to %struct._ddebug*), %struct.device* %dev31, i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.5.265, i32 0, i32 0), i32 %conv33, i32 %index, i8* %buf)
  br label %errout

errout:                                           ; preds = %if.then30, %do.body25, %if.end16, %if.end12, %if.end8
  %err.0 = phi i32 [ %call9, %if.end8 ], [ %call13, %if.end12 ], [ %call18, %do.body25 ], [ %call18, %if.then30 ], [ %call18, %if.end16 ]
  call void @kfree(i8* %call.i)
  br label %cleanup

cleanup:                                          ; preds = %errout, %if.end5, %if.end, %entry
  %retval.0 = phi i32 [ %err.0, %errout ], [ -113, %entry ], [ -22, %if.end ], [ -12, %if.end5 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_get_langid(%struct.usb_device* %dev, i8* %tbuf) #0 {
entry:
  %have_langid = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 22
  %bf.load = load i16, i16* %have_langid, align 4
  %bf.lshr = lshr i16 %bf.load, 2
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %string_langid = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 23
  %0 = load i32, i32* %string_langid, align 8, !tbaa !513
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %call = call i32 @usb_string_sub(%struct.usb_device* %dev, i32 0, i32 0, i8* %tbuf)
  %cmp3 = icmp eq i32 %call, -61
  br i1 %cmp3, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end2
  %cmp4 = icmp sgt i32 %call, 0
  %cmp5 = icmp slt i32 %call, 4
  %or.cond = and i1 %cmp4, %cmp5
  br i1 %or.cond, label %if.then6, label %if.end12

if.then6:                                         ; preds = %lor.lhs.false, %if.end2
  %string_langid7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 23
  store i32 1033, i32* %string_langid7, align 8, !tbaa !513
  %have_langid8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 22
  %bf.load9 = load i16, i16* %have_langid8, align 4
  %bf.clear10 = and i16 %bf.load9, -5
  %bf.set = or i16 %bf.clear10, 4
  store i16 %bf.set, i16* %have_langid8, align 4
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end12:                                         ; preds = %lor.lhs.false
  %cmp13 = icmp slt i32 %call, 0
  br i1 %cmp13, label %if.then14, label %if.end17

if.then14:                                        ; preds = %if.end12
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %string_langid16 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 23
  store i32 -1, i32* %string_langid16, align 8, !tbaa !513
  br label %cleanup

if.end17:                                         ; preds = %if.end12
  %arrayidx = getelementptr inbounds i8, i8* %tbuf, i64 2
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !72
  %conv = zext i8 %1 to i32
  %arrayidx18 = getelementptr inbounds i8, i8* %tbuf, i64 3
  %2 = load i8, i8* %arrayidx18, align 1, !tbaa !72
  %conv19 = zext i8 %2 to i32
  %shl = shl i32 %conv19, 8
  %or = or i32 %conv, %shl
  %string_langid20 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 23
  store i32 %or, i32* %string_langid20, align 8, !tbaa !513
  %have_langid21 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 22
  %bf.load22 = load i16, i16* %have_langid21, align 4
  %bf.clear23 = and i16 %bf.load22, -5
  %bf.set24 = or i16 %bf.clear23, 4
  store i16 %bf.set24, i16* %have_langid21, align 4
  %bf.load26 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_get_langid.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr27 = lshr i32 %bf.load26, 18
  %bf.clear28 = and i32 %bf.lshr27, 255
  %and = and i32 %bf.clear28, 1
  %tobool29 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool29, true
  %lnot30 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot30 to i32
  %conv31 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool32 = icmp ne i64 %expval, 0
  br i1 %tobool32, label %if.then33, label %cleanup

if.then33:                                        ; preds = %if.end17
  %dev34 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %string_langid35 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 23
  %3 = load i32, i32* %string_langid35, align 8, !tbaa !513
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_get_langid.descriptor to %struct._ddebug*), %struct.device* %dev34, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.37.268, i32 0, i32 0), i32 %3)
  br label %cleanup

cleanup:                                          ; preds = %if.then33, %if.end17, %if.then14, %if.then6, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.then6 ], [ -32, %if.then14 ], [ 0, %entry ], [ -32, %if.end ], [ 0, %if.then33 ], [ 0, %if.end17 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_string_sub(%struct.usb_device* %dev, i32 %langid, i32 %index, i8* %buf) #0 {
entry:
  %rc = alloca i32, align 4
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 29
  %0 = load i32, i32* %quirks, align 4, !tbaa !199
  %conv = zext i32 %0 to i64
  %and = and i64 %conv, 1
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -5, i32* %rc, align 4, !tbaa !73
  br label %if.end

if.else:                                          ; preds = %entry
  %conv1 = trunc i32 %langid to i16
  %conv2 = trunc i32 %index to i8
  %call = call i32 @usb_get_string(%struct.usb_device* %dev, i16 zeroext %conv1, i8 zeroext %conv2, i8* %buf, i32 255)
  store i32 %call, i32* %rc, align 4, !tbaa !73
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %1 = load i32, i32* %rc, align 4, !tbaa !73
  %cmp = icmp slt i32 %1, 2
  br i1 %cmp, label %if.then4, label %if.end16

if.then4:                                         ; preds = %if.end
  %conv5 = trunc i32 %langid to i16
  %conv6 = trunc i32 %index to i8
  %call7 = call i32 @usb_get_string(%struct.usb_device* %dev, i16 zeroext %conv5, i8 zeroext %conv6, i8* %buf, i32 2)
  store i32 %call7, i32* %rc, align 4, !tbaa !73
  %2 = load i32, i32* %rc, align 4, !tbaa !73
  %cmp8 = icmp eq i32 %2, 2
  br i1 %cmp8, label %if.then10, label %if.end16

if.then10:                                        ; preds = %if.then4
  %conv11 = trunc i32 %langid to i16
  %conv12 = trunc i32 %index to i8
  %arrayidx = getelementptr inbounds i8, i8* %buf, i64 0
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !72
  %conv13 = zext i8 %3 to i32
  %call14 = call i32 @usb_get_string(%struct.usb_device* %dev, i16 zeroext %conv11, i8 zeroext %conv12, i8* %buf, i32 %conv13)
  store i32 %call14, i32* %rc, align 4, !tbaa !73
  br label %if.end16

if.end16:                                         ; preds = %if.then10, %if.then4, %if.end
  %4 = load i32, i32* %rc, align 4, !tbaa !73
  %cmp17 = icmp sge i32 %4, 2
  br i1 %cmp17, label %if.then19, label %if.end35

if.then19:                                        ; preds = %if.end16
  %arrayidx20 = getelementptr inbounds i8, i8* %buf, i64 0
  %5 = load i8, i8* %arrayidx20, align 1, !tbaa !72
  %tobool21 = icmp ne i8 %5, 0
  br i1 %tobool21, label %if.end25, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then19
  %arrayidx22 = getelementptr inbounds i8, i8* %buf, i64 1
  %6 = load i8, i8* %arrayidx22, align 1, !tbaa !72
  %tobool23 = icmp ne i8 %6, 0
  br i1 %tobool23, label %if.end25, label %if.then24

if.then24:                                        ; preds = %land.lhs.true
  call void @usb_try_string_workarounds(i8* %buf, i32* %rc)
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %land.lhs.true, %if.then19
  %arrayidx26 = getelementptr inbounds i8, i8* %buf, i64 0
  %7 = load i8, i8* %arrayidx26, align 1, !tbaa !72
  %conv27 = zext i8 %7 to i32
  %8 = load i32, i32* %rc, align 4, !tbaa !73
  %cmp28 = icmp slt i32 %conv27, %8
  br i1 %cmp28, label %if.then30, label %if.end33

if.then30:                                        ; preds = %if.end25
  %arrayidx31 = getelementptr inbounds i8, i8* %buf, i64 0
  %9 = load i8, i8* %arrayidx31, align 1, !tbaa !72
  %conv32 = zext i8 %9 to i32
  store i32 %conv32, i32* %rc, align 4, !tbaa !73
  br label %if.end33

if.end33:                                         ; preds = %if.then30, %if.end25
  %10 = load i32, i32* %rc, align 4, !tbaa !73
  %11 = load i32, i32* %rc, align 4, !tbaa !73
  %and34 = and i32 %11, 1
  %sub = sub nsw i32 %10, %and34
  store i32 %sub, i32* %rc, align 4, !tbaa !73
  br label %if.end35

if.end35:                                         ; preds = %if.end33, %if.end16
  %12 = load i32, i32* %rc, align 4, !tbaa !73
  %cmp36 = icmp slt i32 %12, 2
  br i1 %cmp36, label %if.then38, label %if.end41

if.then38:                                        ; preds = %if.end35
  %13 = load i32, i32* %rc, align 4, !tbaa !73
  %cmp39 = icmp slt i32 %13, 0
  %14 = load i32, i32* %rc, align 4
  %cond = select i1 %cmp39, i32 %14, i32 -22
  store i32 %cond, i32* %rc, align 4, !tbaa !73
  br label %if.end41

if.end41:                                         ; preds = %if.then38, %if.end35
  %15 = load i32, i32* %rc, align 4, !tbaa !73
  ret i32 %15
}

declare i32 @utf16s_to_utf8s(i16*, i32, i32, i8*, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @usb_get_string(%struct.usb_device* %dev, i16 zeroext %langid, i8 zeroext %index, i8* %buf, i32 %size) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %result.0 = phi i32 [ undef, %entry ], [ %result.1, %for.inc ]
  %cmp = icmp slt i32 %i.0, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @__create_pipe.251(%struct.usb_device* %dev, i32 0)
  %or = or i32 -2147483648, %call
  %or1 = or i32 %or, 128
  %conv = zext i8 %index to i32
  %add = add nsw i32 768, %conv
  %conv2 = trunc i32 %add to i16
  %conv3 = trunc i32 %size to i16
  %call4 = call i32 @usb_control_msg(%struct.usb_device* %dev, i32 %or1, i8 zeroext 6, i8 zeroext -128, i16 zeroext %conv2, i16 zeroext %langid, i8* %buf, i16 zeroext %conv3, i32 5000)
  switch i32 %call4, label %if.end [
    i32 0, label %for.inc
    i32 -32, label %for.inc
  ]

if.end:                                           ; preds = %for.body
  %cmp9 = icmp sgt i32 %call4, 1
  br i1 %cmp9, label %land.lhs.true, label %for.end

land.lhs.true:                                    ; preds = %if.end
  %arrayidx = getelementptr inbounds i8, i8* %buf, i64 1
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !72
  %conv11 = zext i8 %0 to i32
  %cmp12 = icmp ne i32 %conv11, 3
  br i1 %cmp12, label %for.inc, label %for.end

for.inc:                                          ; preds = %land.lhs.true, %for.body, %for.body
  %result.1 = phi i32 [ %call4, %for.body ], [ %call4, %for.body ], [ -61, %land.lhs.true ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %land.lhs.true, %if.end, %for.cond
  %result.2 = phi i32 [ %call4, %land.lhs.true ], [ %call4, %if.end ], [ %result.0, %for.cond ]
  ret i32 %result.2
}

; Function Attrs: nounwind uwtable
define internal void @usb_try_string_workarounds(i8* %buf, i32* %length) #0 {
entry:
  %0 = load i32, i32* %length, align 4, !tbaa !73
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %newlength.0 = phi i32 [ 2, %entry ], [ %add10, %for.inc ]
  %add = add nsw i32 %newlength.0, 1
  %cmp = icmp slt i32 %add, %0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %newlength.0 to i64
  %arrayidx = getelementptr inbounds i8, i8* %buf, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !72
  %conv = zext i8 %1 to i32
  %idxprom1 = sext i32 %conv to i64
  %arrayidx2 = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom1
  %2 = load i8, i8* %arrayidx2, align 1, !tbaa !72
  %conv3 = zext i8 %2 to i32
  %and = and i32 %conv3, 151
  %cmp4 = icmp ne i32 %and, 0
  br i1 %cmp4, label %lor.lhs.false, label %for.end

lor.lhs.false:                                    ; preds = %for.body
  %add6 = add nsw i32 %newlength.0, 1
  %idxprom7 = sext i32 %add6 to i64
  %arrayidx8 = getelementptr inbounds i8, i8* %buf, i64 %idxprom7
  %3 = load i8, i8* %arrayidx8, align 1, !tbaa !72
  %conv9 = zext i8 %3 to i32
  %tobool = icmp ne i32 %conv9, 0
  br i1 %tobool, label %for.end, label %for.inc

for.inc:                                          ; preds = %lor.lhs.false
  %add10 = add nsw i32 %newlength.0, 2
  br label %for.cond

for.end:                                          ; preds = %lor.lhs.false, %for.body, %for.cond
  %cmp11 = icmp sgt i32 %newlength.0, 2
  br i1 %cmp11, label %if.then13, label %if.end16

if.then13:                                        ; preds = %for.end
  %conv14 = trunc i32 %newlength.0 to i8
  %arrayidx15 = getelementptr inbounds i8, i8* %buf, i64 0
  store i8 %conv14, i8* %arrayidx15, align 1, !tbaa !72
  store i32 %newlength.0, i32* %length, align 4, !tbaa !73
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_disable_endpoint(%struct.usb_device* %dev, i32 %epaddr, i1 zeroext %reset_hardware) #0 {
entry:
  %frombool = zext i1 %reset_hardware to i8
  %and = and i32 %epaddr, 15
  %tobool = icmp ne %struct.usb_device* %dev, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %and1 = and i32 %epaddr, 128
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.else, label %if.then3

if.then3:                                         ; preds = %if.end
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 17
  %idxprom = zext i32 %and to i64
  %arrayidx = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out, i64 0, i64 %idxprom
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8, !tbaa !52
  %tobool4 = trunc i8 %frombool to i1
  br i1 %tobool4, label %if.then5, label %if.end18

if.then5:                                         ; preds = %if.then3
  %ep_out6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 17
  %idxprom7 = zext i32 %and to i64
  %arrayidx8 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out6, i64 0, i64 %idxprom7
  store %struct.usb_host_endpoint* null, %struct.usb_host_endpoint** %arrayidx8, align 8, !tbaa !52
  br label %if.end18

if.else:                                          ; preds = %if.end
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 16
  %idxprom10 = zext i32 %and to i64
  %arrayidx11 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in, i64 0, i64 %idxprom10
  %1 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx11, align 8, !tbaa !52
  %tobool12 = trunc i8 %frombool to i1
  br i1 %tobool12, label %if.then13, label %if.end18

if.then13:                                        ; preds = %if.else
  %ep_in14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 16
  %idxprom15 = zext i32 %and to i64
  %arrayidx16 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in14, i64 0, i64 %idxprom15
  store %struct.usb_host_endpoint* null, %struct.usb_host_endpoint** %arrayidx16, align 8, !tbaa !52
  br label %if.end18

if.end18:                                         ; preds = %if.then13, %if.else, %if.then5, %if.then3
  %ep.0 = phi %struct.usb_host_endpoint* [ %0, %if.then5 ], [ %0, %if.then3 ], [ %1, %if.then13 ], [ %1, %if.else ]
  %tobool19 = icmp ne %struct.usb_host_endpoint* %ep.0, null
  br i1 %tobool19, label %if.then20, label %cleanup.cont

if.then20:                                        ; preds = %if.end18
  %enabled = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep.0, i32 0, i32 9
  store i32 0, i32* %enabled, align 4, !tbaa !440
  call void @usb_hcd_flush_endpoint(%struct.usb_device* %dev, %struct.usb_host_endpoint* %ep.0)
  %tobool21 = trunc i8 %frombool to i1
  br i1 %tobool21, label %if.then22, label %cleanup.cont

if.then22:                                        ; preds = %if.then20
  call void @usb_hcd_disable_endpoint(%struct.usb_device* %dev, %struct.usb_host_endpoint* %ep.0)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then22, %if.then20, %if.end18, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_internal_control_msg(%struct.usb_device* %usb_dev, i32 %pipe, %struct.usb_ctrlrequest* %cmd, i8* %data, i32 %len, i32 %timeout) #0 {
entry:
  %length = alloca i32, align 4
  %call = call %struct.urb* bitcast (%struct.urb.744* (i32, i32)* @usb_alloc_urb to %struct.urb* (i32, i32)*)(i32 0, i32 20971520)
  %tobool = icmp ne %struct.urb* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %0 = bitcast %struct.usb_ctrlrequest* %cmd to i8*
  call void @usb_fill_control_urb(%struct.urb* %call, %struct.usb_device* %usb_dev, i32 %pipe, i8* %0, i8* %data, i32 %len, void (%struct.urb*)* @usb_api_blocking_completion, i8* null)
  %call1 = call i32 @usb_start_wait_urb(%struct.urb* %call, i32 %timeout, i32* %length)
  %cmp = icmp slt i32 %call1, 0
  %1 = load i32, i32* %length, align 4
  %call1. = select i1 %cmp, i32 %call1, i32 %1
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ -12, %entry ], [ %call1., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @usb_api_blocking_completion(%struct.urb* %urb) #0 {
entry:
  %context = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  %0 = load i8*, i8** %context, align 8, !tbaa !313
  %1 = bitcast i8* %0 to %struct.api_context*
  %status = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 12
  %2 = load i32, i32* %status, align 8, !tbaa !314
  %status1 = getelementptr inbounds %struct.api_context, %struct.api_context* %1, i32 0, i32 1
  store i32 %2, i32* %status1, align 8, !tbaa !514
  %done = getelementptr inbounds %struct.api_context, %struct.api_context* %1, i32 0, i32 0
  call void @complete(%struct.completion* %done)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_fill_control_urb(%struct.urb* %urb, %struct.usb_device* %dev, i32 %pipe, i8* %setup_packet, i8* %transfer_buffer, i32 %buffer_length, void (%struct.urb*)* %complete_fn, i8* %context) #1 {
entry:
  %dev1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  store %struct.usb_device* %dev, %struct.usb_device** %dev1, align 8, !tbaa !242
  %pipe2 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 10
  store i32 %pipe, i32* %pipe2, align 8, !tbaa !244
  %setup_packet3 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 21
  store i8* %setup_packet, i8** %setup_packet3, align 8, !tbaa !425
  %transfer_buffer4 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  store i8* %transfer_buffer, i8** %transfer_buffer4, align 8, !tbaa !316
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  store i32 %buffer_length, i32* %transfer_buffer_length, align 8, !tbaa !317
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 28
  store void (%struct.urb*)* %complete_fn, void (%struct.urb*)** %complete, align 8, !tbaa !318
  %context5 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  store i8* %context, i8** %context5, align 8, !tbaa !313
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_start_wait_urb(%struct.urb* %urb, i32 %timeout, i32* %actual_length) #0 {
entry:
  %ctx = alloca %struct.api_context, align 8
  %done = getelementptr inbounds %struct.api_context, %struct.api_context* %ctx, i32 0, i32 0
  call void @init_completion(%struct.completion* %done)
  %0 = bitcast %struct.api_context* %ctx to i8*
  %context = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  store i8* %0, i8** %context, align 8, !tbaa !313
  %actual_length2 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  store i32 0, i32* %actual_length2, align 4, !tbaa !315
  %call = call i32 bitcast (i32 (%struct.urb.744*, i32)* @usb_submit_urb to i32 (%struct.urb*, i32)*)(%struct.urb* %urb, i32 20971520)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %out, label %if.end

if.end:                                           ; preds = %entry
  %tobool5 = icmp ne i32 %timeout, 0
  br i1 %tobool5, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end
  %call.i = call i64 @__msecs_to_jiffies(i32 %timeout) #8
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.end
  %cond = phi i64 [ %call.i, %cond.true ], [ 9223372036854775807, %if.end ]
  %done7 = getelementptr inbounds %struct.api_context, %struct.api_context* %ctx, i32 0, i32 0
  %call8 = call i64 @wait_for_completion_timeout(%struct.completion* %done7, i64 %cond)
  %tobool9 = icmp ne i64 %call8, 0
  br i1 %tobool9, label %if.else, label %if.then10

if.then10:                                        ; preds = %cond.end
  call void bitcast (void (%struct.urb.744*)* @usb_kill_urb to void (%struct.urb*)*)(%struct.urb* %urb)
  %status = getelementptr inbounds %struct.api_context, %struct.api_context* %ctx, i32 0, i32 1
  %1 = load i32, i32* %status, align 8, !tbaa !514
  %cmp = icmp eq i32 %1, -2
  %status14 = getelementptr inbounds %struct.api_context, %struct.api_context* %ctx, i32 0, i32 1
  %2 = load i32, i32* %status14, align 8
  %cond16 = select i1 %cmp, i32 -110, i32 %2
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_start_wait_urb.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool18 = icmp ne i32 %and, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %if.then26, label %out

if.then26:                                        ; preds = %if.then10
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %3 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !242
  %dev27 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 11
  %4 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !516
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %4, i32 0, i32 82
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %5 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !250
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %5, i32 0, i32 0
  %call29 = call i32 @usb_endpoint_num.273(%struct.usb_endpoint_descriptor* %desc)
  %call30 = call i32 @usb_urb_dir_in.274(%struct.urb* %urb)
  %tobool31 = icmp ne i32 %call30, 0
  %cond32 = select i1 %tobool31, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.49.801, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.48.800, i32 0, i32 0)
  %actual_length33 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %6 = load i32, i32* %actual_length33, align 4, !tbaa !315
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %7 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !317
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_start_wait_urb.descriptor to %struct._ddebug*), %struct.device* %dev27, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.29.277, i32 0, i32 0), i8* %arraydecay, i32 %call29, i8* %cond32, i32 %6, i32 %7)
  br label %out

if.else:                                          ; preds = %cond.end
  %status37 = getelementptr inbounds %struct.api_context, %struct.api_context* %ctx, i32 0, i32 1
  %8 = load i32, i32* %status37, align 8, !tbaa !514
  br label %out

out:                                              ; preds = %if.else, %if.then26, %if.then10, %entry
  %retval1.1 = phi i32 [ %call, %entry ], [ %8, %if.else ], [ %cond16, %if.then26 ], [ %cond16, %if.then10 ]
  %tobool39 = icmp ne i32* %actual_length, null
  br i1 %tobool39, label %if.then40, label %if.end42

if.then40:                                        ; preds = %out
  %actual_length41 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %9 = load i32, i32* %actual_length41, align 4, !tbaa !315
  store i32 %9, i32* %actual_length, align 4, !tbaa !73
  br label %if.end42

if.end42:                                         ; preds = %if.then40, %out
  call void bitcast (void (%struct.urb.744*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %urb)
  ret i32 %retval1.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @init_completion(%struct.completion* %x) #1 {
entry:
  %done = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 0
  store i32 0, i32* %done, align 8, !tbaa !517
  %wait = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 1
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wait, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.34.278, i32 0, i32 0), %struct.lock_class_key* @init_completion.__key)
  ret void
}

declare i64 @wait_for_completion_timeout(%struct.completion*, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_num.273(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !309
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_urb_dir_in.274(%struct.urb* %urb) #1 {
entry:
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %0 = load i32, i32* %transfer_flags, align 4, !tbaa !379
  %and = and i32 %0, 512
  %cmp = icmp eq i32 %and, 512
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #2

declare void @complete(%struct.completion*) #2

; Function Attrs: nounwind uwtable
define void @usb_enable_endpoint(%struct.usb_device* %dev, %struct.usb_host_endpoint* %ep, i1 zeroext %reset_ep) #0 {
entry:
  %frombool = zext i1 %reset_ep to i8
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call = call i32 @usb_endpoint_num.273(%struct.usb_endpoint_descriptor* %desc)
  %desc1 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call2 = call i32 @usb_endpoint_dir_out.281(%struct.usb_endpoint_descriptor* %desc1)
  %desc3 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call4 = call i32 @usb_endpoint_xfer_control.282(%struct.usb_endpoint_descriptor* %desc3)
  %tobool = trunc i8 %frombool to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @usb_hcd_reset_endpoint(%struct.usb_device* %dev, %struct.usb_host_endpoint* %ep)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool5 = icmp ne i32 %call2, 0
  %tobool6 = icmp ne i32 %call4, 0
  %or.cond = or i1 %tobool5, %tobool6
  br i1 %or.cond, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 17
  %idxprom = sext i32 %call to i64
  %arrayidx = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out, i64 0, i64 %idxprom
  store %struct.usb_host_endpoint* %ep, %struct.usb_host_endpoint** %arrayidx, align 8, !tbaa !52
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end
  %tobool9 = icmp eq i32 %call2, 0
  %tobool11 = icmp ne i32 %call4, 0
  %or.cond1 = or i1 %tobool9, %tobool11
  br i1 %or.cond1, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end8
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 16
  %idxprom13 = sext i32 %call to i64
  %arrayidx14 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in, i64 0, i64 %idxprom13
  store %struct.usb_host_endpoint* %ep, %struct.usb_host_endpoint** %arrayidx14, align 8, !tbaa !52
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.end8
  %enabled = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 9
  store i32 1, i32* %enabled, align 4, !tbaa !440
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_dir_out.281(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !309
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 128
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_control.282(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @device_is_registered(%struct.device* %dev) #1 {
entry:
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %state_in_sysfs = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 8
  %bf.load = load i8, i8* %state_in_sysfs, align 8
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  ret i32 %bf.cast
}

; Function Attrs: nounwind uwtable
define internal void @remove_intf_ep_devs(%struct.usb_interface* %intf) #0 {
entry:
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %0 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !169
  %ep_devs_created = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load = load i8, i8* %ep_devs_created, align 8
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 4
  %1 = load i8, i8* %bNumEndpoints, align 4, !tbaa !172
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 3
  %2 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !173
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %2, i64 %idxprom
  call void @usb_remove_ep_devs(%struct.usb_host_endpoint* %arrayidx)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %ep_devs_created2 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load3 = load i8, i8* %ep_devs_created2, align 8
  %bf.clear4 = and i8 %bf.load3, -3
  store i8 %bf.clear4, i8* %ep_devs_created2, align 8
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry.288(%struct.list_head* %entry1) #1 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !87
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !252
  call void @__list_del.289(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del.289(%struct.list_head* %prev, %struct.list_head* %next) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !87
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !72
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_reset_configuration(%struct.usb_device* %dev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.238(%struct.usb_bus* %0)
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %1, 8
  br i1 %cmp, label %cleanup103, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %i.0 = phi i32 [ 1, %if.end ], [ %inc, %for.body ]
  %cmp2 = icmp slt i32 %i.0, 16
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @usb_disable_endpoint(%struct.usb_device* %dev, i32 %i.0, i1 zeroext true)
  %add = add nsw i32 %i.0, 128
  call void @usb_disable_endpoint(%struct.usb_device* %dev, i32 %add, i1 zeroext true)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %3 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !167
  call void @mutex_lock_nested(%struct.mutex* %3, i32 0)
  %call3 = call i32 @usb_disable_lpm(%struct.usb_device* %dev)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.then4, label %if.end7

if.then4:                                         ; preds = %for.end
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %bandwidth_mutex6 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %4 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex6, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %4)
  br label %cleanup103

if.end7:                                          ; preds = %for.end
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc28, %if.end7
  %retval1.0 = phi i32 [ 0, %if.end7 ], [ %retval1.1, %for.inc28 ]
  %i.1 = phi i32 [ 0, %if.end7 ], [ %inc29, %for.inc28 ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %5 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv = zext i8 %5 to i32
  %cmp9 = icmp slt i32 %i.1, %conv
  br i1 %cmp9, label %for.body11, label %for.end30

for.body11:                                       ; preds = %for.cond8
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 3
  %idxprom = sext i32 %i.1 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %6 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !52
  %call12 = call %struct.usb_host_interface* @usb_altnum_to_altsetting(%struct.usb_interface* %6, i32 0)
  %tobool13 = icmp ne %struct.usb_host_interface* %call12, null
  br i1 %tobool13, label %if.end16, label %if.then14

if.then14:                                        ; preds = %for.body11
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %6, i32 0, i32 0
  %7 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !98
  %arrayidx15 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %7, i64 0
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %for.body11
  %alt.0 = phi %struct.usb_host_interface* [ %call12, %for.body11 ], [ %arrayidx15, %if.then14 ]
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %6, i32 0, i32 1
  %8 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !169
  %cmp17 = icmp ne %struct.usb_host_interface* %alt.0, %8
  br i1 %cmp17, label %if.then19, label %if.end22

if.then19:                                        ; preds = %if.end16
  %cur_altsetting20 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %6, i32 0, i32 1
  %9 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting20, align 8, !tbaa !169
  %call21 = call i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %dev, %struct.usb_host_config* null, %struct.usb_host_interface* %9, %struct.usb_host_interface* %alt.0)
  br label %if.end22

if.end22:                                         ; preds = %if.then19, %if.end16
  %retval1.1 = phi i32 [ %call21, %if.then19 ], [ %retval1.0, %if.end16 ]
  %cmp23 = icmp slt i32 %retval1.1, 0
  %. = select i1 %cmp23, i32 5, i32 0
  %SwitchLeaf = icmp eq i32 %., 5
  br i1 %SwitchLeaf, label %for.end30, label %for.inc28

for.inc28:                                        ; preds = %if.end22
  %inc29 = add nsw i32 %i.1, 1
  br label %for.cond8

for.end30:                                        ; preds = %if.end22, %for.cond8
  %retval1.2 = phi i32 [ %retval1.1, %if.end22 ], [ %retval1.0, %for.cond8 ]
  %cmp31 = icmp slt i32 %retval1.2, 0
  br i1 %cmp31, label %reset_old_alts, label %if.end60

reset_old_alts:                                   ; preds = %if.end60, %for.end30
  %retval1.3 = phi i32 [ %retval1.2, %for.end30 ], [ %call64, %if.end60 ]
  br label %for.cond34

for.cond34:                                       ; preds = %for.inc56, %reset_old_alts
  %i.2.sink = phi i32 [ %dec57, %for.inc56 ], [ %i.1, %reset_old_alts ]
  %dec57 = add nsw i32 %i.2.sink, -1
  %cmp35 = icmp sge i32 %dec57, 0
  br i1 %cmp35, label %for.body37, label %for.end58

for.body37:                                       ; preds = %for.cond34
  %interface39 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 3
  %idxprom40 = sext i32 %dec57 to i64
  %arrayidx41 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface39, i64 0, i64 %idxprom40
  %10 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx41, align 8, !tbaa !52
  %call43 = call %struct.usb_host_interface* @usb_altnum_to_altsetting(%struct.usb_interface* %10, i32 0)
  %tobool44 = icmp ne %struct.usb_host_interface* %call43, null
  br i1 %tobool44, label %if.end48, label %if.then45

if.then45:                                        ; preds = %for.body37
  %altsetting46 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %10, i32 0, i32 0
  %11 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting46, align 8, !tbaa !98
  %arrayidx47 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %11, i64 0
  br label %if.end48

if.end48:                                         ; preds = %if.then45, %for.body37
  %alt42.0 = phi %struct.usb_host_interface* [ %call43, %for.body37 ], [ %arrayidx47, %if.then45 ]
  %cur_altsetting49 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %10, i32 0, i32 1
  %12 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting49, align 8, !tbaa !169
  %cmp50 = icmp ne %struct.usb_host_interface* %alt42.0, %12
  br i1 %cmp50, label %if.then52, label %for.inc56

if.then52:                                        ; preds = %if.end48
  %cur_altsetting53 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %10, i32 0, i32 1
  %13 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting53, align 8, !tbaa !169
  %call54 = call i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %dev, %struct.usb_host_config* null, %struct.usb_host_interface* %alt42.0, %struct.usb_host_interface* %13)
  br label %for.inc56

for.inc56:                                        ; preds = %if.then52, %if.end48
  br label %for.cond34

for.end58:                                        ; preds = %for.cond34
  call void @usb_enable_lpm(%struct.usb_device* %dev)
  %bandwidth_mutex59 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %14 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex59, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %14)
  br label %cleanup103

if.end60:                                         ; preds = %for.end30
  %call61 = call i32 @__create_pipe.251(%struct.usb_device* %dev, i32 0)
  %or = or i32 -2147483648, %call61
  %desc62 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 0
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc62, i32 0, i32 4
  %15 = load i8, i8* %bConfigurationValue, align 1, !tbaa !168
  %conv63 = zext i8 %15 to i16
  %call64 = call i32 @usb_control_msg(%struct.usb_device* %dev, i32 %or, i8 zeroext 9, i8 zeroext 0, i16 zeroext %conv63, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  %cmp65 = icmp slt i32 %call64, 0
  br i1 %cmp65, label %reset_old_alts, label %if.end68

if.end68:                                         ; preds = %if.end60
  %bandwidth_mutex69 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %16 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex69, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %16)
  br label %for.cond70

for.cond70:                                       ; preds = %for.inc100, %if.end68
  %i.3 = phi i32 [ 0, %if.end68 ], [ %inc101, %for.inc100 ]
  %desc71 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 0
  %bNumInterfaces72 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc71, i32 0, i32 3
  %17 = load i8, i8* %bNumInterfaces72, align 4, !tbaa !103
  %conv73 = zext i8 %17 to i32
  %cmp74 = icmp slt i32 %i.3, %conv73
  br i1 %cmp74, label %for.body76, label %for.end102

for.body76:                                       ; preds = %for.cond70
  %interface78 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 3
  %idxprom79 = sext i32 %i.3 to i64
  %arrayidx80 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface78, i64 0, i64 %idxprom79
  %18 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx80, align 8, !tbaa !52
  %call82 = call %struct.usb_host_interface* @usb_altnum_to_altsetting(%struct.usb_interface* %18, i32 0)
  %tobool83 = icmp ne %struct.usb_host_interface* %call82, null
  br i1 %tobool83, label %if.end87, label %if.then84

if.then84:                                        ; preds = %for.body76
  %altsetting85 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %18, i32 0, i32 0
  %19 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting85, align 8, !tbaa !98
  %arrayidx86 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %19, i64 0
  br label %if.end87

if.end87:                                         ; preds = %if.then84, %for.body76
  %alt81.0 = phi %struct.usb_host_interface* [ %call82, %for.body76 ], [ %arrayidx86, %if.then84 ]
  %cur_altsetting88 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %18, i32 0, i32 1
  %20 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting88, align 8, !tbaa !169
  %cmp89 = icmp ne %struct.usb_host_interface* %alt81.0, %20
  br i1 %cmp89, label %if.then91, label %if.end92

if.then91:                                        ; preds = %if.end87
  call void @remove_intf_ep_devs(%struct.usb_interface* %18)
  call void @usb_remove_sysfs_intf_files(%struct.usb_interface* %18)
  br label %if.end92

if.end92:                                         ; preds = %if.then91, %if.end87
  %cur_altsetting93 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %18, i32 0, i32 1
  store %struct.usb_host_interface* %alt81.0, %struct.usb_host_interface** %cur_altsetting93, align 8, !tbaa !169
  call void @usb_enable_interface(%struct.usb_device* %dev, %struct.usb_interface* %18, i1 zeroext true)
  %dev94 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %18, i32 0, i32 7
  %call95 = call i32 @device_is_registered(%struct.device* %dev94)
  %tobool96 = icmp ne i32 %call95, 0
  br i1 %tobool96, label %if.then97, label %for.inc100

if.then97:                                        ; preds = %if.end92
  call void @usb_create_sysfs_intf_files(%struct.usb_interface* %18)
  call void @create_intf_ep_devs(%struct.usb_interface* %18)
  br label %for.inc100

for.inc100:                                       ; preds = %if.then97, %if.end92
  %inc101 = add nsw i32 %i.3, 1
  br label %for.cond70

for.end102:                                       ; preds = %for.cond70
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %dev)
  br label %cleanup103

cleanup103:                                       ; preds = %for.end102, %for.end58, %if.then4, %entry
  %retval.0 = phi i32 [ -12, %if.then4 ], [ %retval1.3, %for.end58 ], [ 0, %for.end102 ], [ -113, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_set_interface(%struct.usb_device* %dev, i32 %interface, i32 %alternate) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.238(%struct.usb_bus* %0)
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %1, 8
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %dev, i32 %interface)
  %tobool = icmp ne %struct.usb_interface* %call1, null
  br i1 %tobool, label %if.end12, label %do.body3

do.body3:                                         ; preds = %if.end
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_set_interface.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool4 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool4, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then7, label %cleanup

if.then7:                                         ; preds = %do.body3
  %dev8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_set_interface.descriptor to %struct._ddebug*), %struct.device* %dev8, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.11.292, i32 0, i32 0), i32 %interface)
  br label %cleanup

if.end12:                                         ; preds = %if.end
  %unregistering = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 6
  %bf.load13 = load i8, i8* %unregistering, align 8
  %bf.lshr14 = lshr i8 %bf.load13, 2
  %bf.clear15 = and i8 %bf.lshr14, 1
  %bf.cast = zext i8 %bf.clear15 to i32
  %tobool16 = icmp ne i32 %bf.cast, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end12
  %call19 = call %struct.usb_host_interface* @usb_altnum_to_altsetting(%struct.usb_interface* %call1, i32 %alternate)
  %tobool20 = icmp ne %struct.usb_host_interface* %call19, null
  br i1 %tobool20, label %if.end23, label %if.then21

if.then21:                                        ; preds = %if.end18
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

if.end23:                                         ; preds = %if.end18
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %2 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !167
  call void @mutex_lock_nested(%struct.mutex* %2, i32 0)
  %call24 = call i32 @usb_disable_lpm(%struct.usb_device* %dev)
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %if.then26, label %if.end29

if.then26:                                        ; preds = %if.end23
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %bandwidth_mutex28 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %3 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex28, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %3)
  br label %cleanup

if.end29:                                         ; preds = %if.end23
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end29
  %i.0 = phi i32 [ 0, %if.end29 ], [ %inc, %for.body ]
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 1
  %4 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !169
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %4, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 4
  %5 = load i8, i8* %bNumEndpoints, align 4, !tbaa !172
  %conv30 = zext i8 %5 to i32
  %cmp31 = icmp slt i32 %i.0, %conv30
  %cur_altsetting33 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 1
  %6 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting33, align 8, !tbaa !169
  br i1 %cmp31, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %6, i32 0, i32 3
  %7 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !173
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %7, i64 %idxprom
  %streams = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 10
  store i32 0, i32* %streams, align 8, !tbaa !174
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call35 = call i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %dev, %struct.usb_host_config* null, %struct.usb_host_interface* %6, %struct.usb_host_interface* %call19)
  %cmp36 = icmp slt i32 %call35, 0
  br i1 %cmp36, label %if.then38, label %if.end41

if.then38:                                        ; preds = %for.end
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  call void @usb_enable_lpm(%struct.usb_device* %dev)
  %bandwidth_mutex40 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %8 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex40, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %8)
  br label %cleanup

if.end41:                                         ; preds = %for.end
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 29
  %9 = load i32, i32* %quirks, align 4, !tbaa !199
  %conv42 = zext i32 %9 to i64
  %and43 = and i64 %conv42, 4
  %tobool44 = icmp ne i64 %and43, 0
  br i1 %tobool44, label %if.end50, label %if.else

if.else:                                          ; preds = %if.end41
  %call46 = call i32 @__create_pipe.251(%struct.usb_device* %dev, i32 0)
  %or = or i32 -2147483648, %call46
  %conv47 = trunc i32 %alternate to i16
  %conv48 = trunc i32 %interface to i16
  %call49 = call i32 @usb_control_msg(%struct.usb_device* %dev, i32 %or, i8 zeroext 11, i8 zeroext 1, i16 zeroext %conv47, i16 zeroext %conv48, i8* null, i16 zeroext 0, i32 5000)
  br label %if.end50

if.end50:                                         ; preds = %if.else, %if.end41
  %ret.0 = phi i32 [ %call49, %if.else ], [ -32, %if.end41 ]
  %cmp51 = icmp eq i32 %ret.0, -32
  br i1 %cmp51, label %land.lhs.true, label %if.else77

land.lhs.true:                                    ; preds = %if.end50
  %num_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 2
  %10 = load i32, i32* %num_altsetting, align 8, !tbaa !97
  %cmp53 = icmp eq i32 %10, 1
  br i1 %cmp53, label %do.body57, label %if.else77

do.body57:                                        ; preds = %land.lhs.true
  %bf.load58 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_set_interface.descriptor.15 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr59 = lshr i32 %bf.load58, 18
  %bf.clear60 = and i32 %bf.lshr59, 255
  %and61 = and i32 %bf.clear60, 1
  %tobool62 = icmp ne i32 %and61, 0
  %lnot63 = xor i1 %tobool62, true
  %lnot65 = xor i1 %lnot63, true
  %lnot.ext66 = zext i1 %lnot65 to i32
  %conv67 = sext i32 %lnot.ext66 to i64
  %expval68 = call i64 @llvm.expect.i64(i64 %conv67, i64 0)
  %tobool69 = icmp ne i64 %expval68, 0
  br i1 %tobool69, label %if.then70, label %if.end85

if.then70:                                        ; preds = %do.body57
  %dev71 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_set_interface.descriptor.15 to %struct._ddebug*), %struct.device* %dev71, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.16.295, i32 0, i32 0), i32 %interface, i32 %alternate)
  br label %if.end85

if.else77:                                        ; preds = %land.lhs.true, %if.end50
  %cmp78 = icmp slt i32 %ret.0, 0
  br i1 %cmp78, label %if.then80, label %if.end85

if.then80:                                        ; preds = %if.else77
  %cur_altsetting81 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 1
  %11 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting81, align 8, !tbaa !169
  %call82 = call i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %dev, %struct.usb_host_config* null, %struct.usb_host_interface* %call19, %struct.usb_host_interface* %11)
  call void @usb_enable_lpm(%struct.usb_device* %dev)
  %bandwidth_mutex83 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %12 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex83, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %12)
  br label %cleanup

if.end85:                                         ; preds = %if.else77, %if.then70, %do.body57
  %manual.0 = phi i32 [ 1, %if.then70 ], [ 1, %do.body57 ], [ 0, %if.else77 ]
  %bandwidth_mutex86 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 21
  %13 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex86, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %13)
  %cur_altsetting87 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 1
  %14 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting87, align 8, !tbaa !169
  %cmp88 = icmp ne %struct.usb_host_interface* %14, %call19
  br i1 %cmp88, label %if.then90, label %if.end91

if.then90:                                        ; preds = %if.end85
  call void @remove_intf_ep_devs(%struct.usb_interface* %call1)
  call void @usb_remove_sysfs_intf_files(%struct.usb_interface* %call1)
  br label %if.end91

if.end91:                                         ; preds = %if.then90, %if.end85
  call void @usb_disable_interface(%struct.usb_device* %dev, %struct.usb_interface* %call1, i1 zeroext true)
  %cur_altsetting92 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 1
  store %struct.usb_host_interface* %call19, %struct.usb_host_interface** %cur_altsetting92, align 8, !tbaa !169
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %dev)
  %tobool93 = icmp ne i32 %manual.0, 0
  br i1 %tobool93, label %if.then94, label %if.end118

if.then94:                                        ; preds = %if.end91
  br label %for.cond95

for.cond95:                                       ; preds = %for.body101, %if.then94
  %i.1 = phi i32 [ 0, %if.then94 ], [ %inc116, %for.body101 ]
  %desc96 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %call19, i32 0, i32 0
  %bNumEndpoints97 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc96, i32 0, i32 4
  %15 = load i8, i8* %bNumEndpoints97, align 4, !tbaa !172
  %conv98 = zext i8 %15 to i32
  %cmp99 = icmp slt i32 %i.1, %conv98
  br i1 %cmp99, label %for.body101, label %if.end118

for.body101:                                      ; preds = %for.cond95
  %endpoint102 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %call19, i32 0, i32 3
  %16 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint102, align 8, !tbaa !173
  %idxprom103 = sext i32 %i.1 to i64
  %arrayidx104 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %16, i64 %idxprom103
  %desc105 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx104, i32 0, i32 0
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc105, i32 0, i32 2
  %17 = load i8, i8* %bEndpointAddress, align 2, !tbaa !512
  %conv106 = zext i8 %17 to i32
  %and107 = and i32 15, %conv106
  %call108 = call i32 @__create_pipe.251(%struct.usb_device* %dev, i32 %and107)
  %and109 = and i32 %conv106, 128
  %tobool110 = icmp ne i32 %and109, 0
  %lnot111 = xor i1 %tobool110, true
  %cond = select i1 %lnot111, i32 0, i32 128
  %or113 = or i32 %call108, %cond
  %call114 = call i32 @usb_clear_halt(%struct.usb_device* %dev, i32 %or113)
  %inc116 = add nsw i32 %i.1, 1
  br label %for.cond95

if.end118:                                        ; preds = %for.cond95, %if.end91
  call void @usb_enable_interface(%struct.usb_device* %dev, %struct.usb_interface* %call1, i1 zeroext true)
  %dev119 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %call120 = call i32 @device_is_registered(%struct.device* %dev119)
  %tobool121 = icmp ne i32 %call120, 0
  br i1 %tobool121, label %if.then122, label %cleanup

if.then122:                                       ; preds = %if.end118
  call void @usb_create_sysfs_intf_files(%struct.usb_interface* %call1)
  call void @create_intf_ep_devs(%struct.usb_interface* %call1)
  br label %cleanup

cleanup:                                          ; preds = %if.then122, %if.end118, %if.then80, %if.then38, %if.then26, %if.then21, %if.end12, %if.then7, %do.body3, %entry
  %retval.0 = phi i32 [ -12, %if.then26 ], [ %call35, %if.then38 ], [ %ret.0, %if.then80 ], [ -22, %if.then21 ], [ -113, %entry ], [ -22, %if.then7 ], [ -22, %do.body3 ], [ -19, %if.end12 ], [ 0, %if.then122 ], [ 0, %if.end118 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_clear_halt(%struct.usb_device* %dev, i32 %pipe) #0 {
entry:
  %shr = ashr i32 %pipe, 15
  %and = and i32 %shr, 15
  %and1 = and i32 %pipe, 128
  %tobool = icmp ne i32 %and1, 0
  %or = or i32 %and, 128
  %or.and = select i1 %tobool, i32 %or, i32 %and
  %call = call i32 @__create_pipe.251(%struct.usb_device* %dev, i32 0)
  %or2 = or i32 -2147483648, %call
  %conv = trunc i32 %or.and to i16
  %call3 = call i32 @usb_control_msg(%struct.usb_device* %dev, i32 %or2, i8 zeroext 1, i8 zeroext 2, i16 zeroext 0, i16 zeroext %conv, i8* null, i16 zeroext 0, i32 5000)
  %cmp = icmp slt i32 %call3, 0
  br i1 %cmp, label %cleanup, label %if.end6

if.end6:                                          ; preds = %entry
  call void @usb_reset_endpoint(%struct.usb_device* %dev, i32 %or.and)
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %entry
  %retval.0 = phi i32 [ 0, %if.end6 ], [ %call3, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_reset_endpoint(%struct.usb_device* %dev, i32 %epaddr) #0 {
entry:
  %and = and i32 %epaddr, 15
  %and1 = and i32 %epaddr, 128
  %tobool = icmp ne i32 %and1, 0
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 16
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 17
  %ep_in.sink = select i1 %tobool, [16 x %struct.usb_host_endpoint*]* %ep_in, [16 x %struct.usb_host_endpoint*]* %ep_out
  %idxprom2 = zext i32 %and to i64
  %arrayidx3 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in.sink, i64 0, i64 %idxprom2
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx3, align 8, !tbaa !52
  %tobool4 = icmp ne %struct.usb_host_endpoint* %0, null
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %entry
  call void @usb_hcd_reset_endpoint(%struct.usb_device* %dev, %struct.usb_host_endpoint* %0)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_get_status(%struct.usb_device* %dev, i32 %type, i32 %target, i8* %data) #0 {
entry:
  %call.i = call noalias i8* @__kmalloc(i64 2, i32 20971712) #8
  %0 = bitcast i8* %call.i to i16*
  %tobool = icmp ne i16* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @__create_pipe.251(%struct.usb_device* %dev, i32 0)
  %or = or i32 -2147483648, %call1
  %or2 = or i32 %or, 128
  %or3 = or i32 128, %type
  %conv = trunc i32 %or3 to i8
  %conv4 = trunc i32 %target to i16
  %1 = bitcast i16* %0 to i8*
  %call5 = call i32 @usb_control_msg(%struct.usb_device* %dev, i32 %or2, i8 zeroext 0, i8 zeroext %conv, i16 zeroext 0, i16 zeroext %conv4, i8* %1, i16 zeroext 2, i32 5000)
  %cmp = icmp eq i32 %call5, 2
  br i1 %cmp, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end
  %2 = load i16, i16* %0, align 2, !tbaa !165
  %3 = bitcast i8* %data to i16*
  store i16 %2, i16* %3, align 2, !tbaa !165
  br label %if.end12

if.else:                                          ; preds = %if.end
  %cmp8 = icmp sge i32 %call5, 0
  %.call5 = select i1 %cmp8, i32 -5, i32 %call5
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then7
  %ret.1 = phi i32 [ 0, %if.then7 ], [ %.call5, %if.else ]
  %4 = bitcast i16* %0 to i8*
  call void @kfree(i8* %4)
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %entry
  %retval.0 = phi i32 [ %ret.1, %if.end12 ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_get_descriptor(%struct.usb_device* %dev, i8 zeroext %type, i8 zeroext %index, i8* %buf, i32 %size) #0 {
entry:
  %conv = sext i32 %size to i64
  %call = call i8* @__memset(i8* %buf, i32 0, i64 %conv)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %result.0 = phi i32 [ undef, %entry ], [ %result.1, %for.inc ]
  %cmp = icmp slt i32 %i.0, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call2 = call i32 @__create_pipe.251(%struct.usb_device* %dev, i32 0)
  %or = or i32 -2147483648, %call2
  %or3 = or i32 %or, 128
  %conv4 = zext i8 %type to i32
  %shl = shl i32 %conv4, 8
  %conv5 = zext i8 %index to i32
  %add = add nsw i32 %shl, %conv5
  %conv6 = trunc i32 %add to i16
  %conv7 = trunc i32 %size to i16
  %call8 = call i32 @usb_control_msg(%struct.usb_device* %dev, i32 %or3, i8 zeroext 6, i8 zeroext -128, i16 zeroext %conv6, i16 zeroext 0, i8* %buf, i16 zeroext %conv7, i32 5000)
  %cmp9 = icmp sle i32 %call8, 0
  %cmp11 = icmp ne i32 %call8, -110
  %or.cond = and i1 %cmp9, %cmp11
  br i1 %or.cond, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %cmp13 = icmp sgt i32 %call8, 1
  br i1 %cmp13, label %land.lhs.true15, label %for.end

land.lhs.true15:                                  ; preds = %if.end
  %arrayidx = getelementptr inbounds i8, i8* %buf, i64 1
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !72
  %conv16 = zext i8 %0 to i32
  %conv17 = zext i8 %type to i32
  %cmp18 = icmp ne i32 %conv16, %conv17
  br i1 %cmp18, label %for.inc, label %for.end

for.inc:                                          ; preds = %land.lhs.true15, %for.body
  %result.1 = phi i32 [ %call8, %for.body ], [ -61, %land.lhs.true15 ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %land.lhs.true15, %if.end, %for.cond
  %result.2 = phi i32 [ %call8, %land.lhs.true15 ], [ %call8, %if.end ], [ %result.0, %for.cond ]
  ret i32 %result.2
}

; Function Attrs: nounwind uwtable
define void @usb_sg_cancel(%struct.usb_sg_request* %io) #0 {
entry:
  %lock = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %status = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 0
  %1 = load i32, i32* %status, align 8, !tbaa !518
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %lock5 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock5, i32 0, i32 0
  %rlock.i4 = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i4, i64 %call2) #8
  br label %cleanup.cont

if.end:                                           ; preds = %entry
  %status6 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 0
  store i32 -104, i32* %status6, align 8, !tbaa !518
  %lock7 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock7, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %3 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #8
  %entries = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  %4 = load i32, i32* %entries, align 4, !tbaa !520
  %sub = sub nsw i32 %4, 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ %sub, %if.end ], [ %dec, %for.inc ]
  %cmp8 = icmp sge i32 %i.0, 0
  br i1 %cmp8, label %for.body, label %cleanup.cont

for.body:                                         ; preds = %for.cond
  %urbs = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %5 = load %struct.urb**, %struct.urb*** %urbs, align 8, !tbaa !521
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.urb*, %struct.urb** %5, i64 %idxprom
  %6 = load %struct.urb*, %struct.urb** %arrayidx, align 8, !tbaa !52
  call void bitcast (void (%struct.urb.744*)* @usb_block_urb to void (%struct.urb*)*)(%struct.urb* %6)
  %urbs10 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %7 = load %struct.urb**, %struct.urb*** %urbs10, align 8, !tbaa !521
  %idxprom11 = sext i32 %i.0 to i64
  %arrayidx12 = getelementptr inbounds %struct.urb*, %struct.urb** %7, i64 %idxprom11
  %8 = load %struct.urb*, %struct.urb** %arrayidx12, align 8, !tbaa !52
  %call13 = call i32 bitcast (i32 (%struct.urb.744*)* @usb_unlink_urb to i32 (%struct.urb*)*)(%struct.urb* %8)
  switch i32 %call13, label %if.then24 [
    i32 -115, label %for.inc
    i32 -19, label %for.inc
    i32 -16, label %for.inc
    i32 -43, label %for.inc
  ]

if.then24:                                        ; preds = %for.body
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.inc

for.inc:                                          ; preds = %if.then24, %for.body, %for.body, %for.body, %for.body
  %dec = add nsw i32 %i.0, -1
  br label %for.cond

cleanup.cont:                                     ; preds = %for.cond, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_sg_wait(%struct.usb_sg_request* %io) #0 {
entry:
  %entries1 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  %0 = load i32, i32* %entries1, align 4, !tbaa !520
  %lock = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %1 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i1) #8
  br label %while.cond

while.cond:                                       ; preds = %if.end31, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %i.1, %if.end31 ]
  %cmp = icmp slt i32 %i.0, %0
  br i1 %cmp, label %land.rhs, label %while.end

land.rhs:                                         ; preds = %while.cond
  %status = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 0
  %2 = load i32, i32* %status, align 8, !tbaa !518
  %tobool = icmp ne i32 %2, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  %dev = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 3
  %3 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !522
  %urbs = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %4 = load %struct.urb**, %struct.urb*** %urbs, align 8, !tbaa !521
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.urb*, %struct.urb** %4, i64 %idxprom
  %5 = load %struct.urb*, %struct.urb** %arrayidx, align 8, !tbaa !52
  %dev2 = getelementptr inbounds %struct.urb, %struct.urb* %5, i32 0, i32 8
  store %struct.usb_device* %3, %struct.usb_device** %dev2, align 8, !tbaa !242
  %lock3 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  %6 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock3, i32 0, i32 0
  %rlock.i3 = bitcast %union.anon.1* %6 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i3) #8
  %urbs4 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %7 = load %struct.urb**, %struct.urb*** %urbs4, align 8, !tbaa !521
  %idxprom5 = sext i32 %i.0 to i64
  %arrayidx6 = getelementptr inbounds %struct.urb*, %struct.urb** %7, i64 %idxprom5
  %8 = load %struct.urb*, %struct.urb** %arrayidx6, align 8, !tbaa !52
  %call = call i32 bitcast (i32 (%struct.urb.744*, i32)* @usb_submit_urb to i32 (%struct.urb*, i32)*)(%struct.urb* %8, i32 20971520)
  %Pivot6 = icmp slt i32 %call, -6
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %while.body
  %Pivot = icmp slt i32 %call, 0
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %call, 0
  br i1 %SwitchLeaf4, label %sw.bb7, label %sw.default

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %call, -6
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.default

LeafBlock:                                        ; preds = %while.body
  %.off = add i32 %call, 12
  %SwitchLeaf = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock, %LeafBlock1
  call void @yield()
  br label %sw.epilog

sw.bb7:                                           ; preds = %LeafBlock3
  %inc = add nsw i32 %i.0, 1
  call void asm sideeffect "rep; nop", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !523
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  %urbs8 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %9 = load %struct.urb**, %struct.urb*** %urbs8, align 8, !tbaa !521
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds %struct.urb*, %struct.urb** %9, i64 %idxprom9
  %10 = load %struct.urb*, %struct.urb** %arrayidx10, align 8, !tbaa !52
  %status11 = getelementptr inbounds %struct.urb, %struct.urb* %10, i32 0, i32 12
  store i32 %call, i32* %status11, align 8, !tbaa !314
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_sg_wait.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool13 = icmp ne i32 %and, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot15 = xor i1 %lnot14, true
  %lnot.ext = zext i1 %lnot15 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool16 = icmp ne i64 %expval, 0
  br i1 %tobool16, label %if.then, label %do.end20

if.then:                                          ; preds = %sw.default
  %dev17 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 3
  %11 = load %struct.usb_device*, %struct.usb_device** %dev17, align 8, !tbaa !522
  %dev18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %11, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_sg_wait.descriptor to %struct._ddebug*), %struct.device* %dev18, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.305, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.usb_sg_wait, i32 0, i32 0), i32 %call)
  br label %do.end20

do.end20:                                         ; preds = %if.then, %sw.default
  call void @usb_sg_cancel(%struct.usb_sg_request* %io)
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end20, %sw.bb7, %sw.bb
  %i.1 = phi i32 [ %i.0, %sw.bb ], [ %i.0, %do.end20 ], [ %inc, %sw.bb7 ]
  %retval.0 = phi i32 [ 0, %sw.bb ], [ %call, %do.end20 ], [ %call, %sw.bb7 ]
  %lock21 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  %12 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock21, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %12 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i) #8
  %tobool22 = icmp ne i32 %retval.0, 0
  br i1 %tobool22, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %sw.epilog
  %status23 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 0
  %13 = load i32, i32* %status23, align 8, !tbaa !518
  %cmp24 = icmp eq i32 %13, 0
  br i1 %cmp24, label %if.then29, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %status26 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 0
  %14 = load i32, i32* %status26, align 8, !tbaa !518
  %cmp27 = icmp eq i32 %14, -104
  br i1 %cmp27, label %if.then29, label %if.end31

if.then29:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %status30 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 0
  store i32 %retval.0, i32* %status30, align 8, !tbaa !518
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %lor.lhs.false, %sw.epilog
  br label %while.cond

while.end:                                        ; preds = %land.rhs, %while.cond
  %sub = sub nsw i32 %0, %i.0
  %count = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 7
  %15 = load i32, i32* %count, align 8, !tbaa !524
  %sub32 = sub nsw i32 %15, %sub
  store i32 %sub32, i32* %count, align 8, !tbaa !524
  %count33 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 7
  %16 = load i32, i32* %count33, align 8, !tbaa !524
  %cmp34 = icmp eq i32 %16, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %while.end
  %complete = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 8
  call void @complete(%struct.completion* %complete)
  br label %if.end37

if.end37:                                         ; preds = %if.then36, %while.end
  %lock38 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  %17 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock38, i32 0, i32 0
  %rlock.i2 = bitcast %union.anon.1* %17 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i2) #8
  %complete39 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 8
  call void @wait_for_completion(%struct.completion* %complete39)
  call void @sg_clean(%struct.usb_sg_request* %io)
  ret void
}

declare void @yield() #2

declare void @wait_for_completion(%struct.completion*) #2

; Function Attrs: nounwind uwtable
define internal void @sg_clean(%struct.usb_sg_request* %io) #0 {
entry:
  %urbs = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %0 = load %struct.urb**, %struct.urb*** %urbs, align 8, !tbaa !521
  %tobool = icmp ne %struct.urb** %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %entries = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  %1 = load i32, i32* %entries, align 4, !tbaa !520
  %dec = add nsw i32 %1, -1
  store i32 %dec, i32* %entries, align 4, !tbaa !520
  %tobool1 = icmp ne i32 %1, 0
  %urbs2 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %2 = load %struct.urb**, %struct.urb*** %urbs2, align 8, !tbaa !521
  br i1 %tobool1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %entries3 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  %3 = load i32, i32* %entries3, align 4, !tbaa !520
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %struct.urb*, %struct.urb** %2, i64 %idxprom
  %4 = load %struct.urb*, %struct.urb** %arrayidx, align 8, !tbaa !52
  call void bitcast (void (%struct.urb.744*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %4)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %5 = bitcast %struct.urb** %2 to i8*
  call void @kfree(i8* %5)
  %urbs5 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  store %struct.urb** null, %struct.urb*** %urbs5, align 8, !tbaa !521
  br label %if.end

if.end:                                           ; preds = %while.end, %entry
  %dev = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 3
  store %struct.usb_device* null, %struct.usb_device** %dev, align 8, !tbaa !522
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_sg_init(%struct.usb_sg_request* %io, %struct.usb_device* %dev, i32 %pipe, i32 %period, %struct.scatterlist* %sg, i32 %nents, i64 %length, i32 %mem_flags) #0 {
entry:
  %__UNIQUE_ID_min1_16 = alloca i64, align 8
  %__UNIQUE_ID_min2_17 = alloca i64, align 8
  %tobool = icmp ne %struct.usb_sg_request* %io, null
  %tobool1 = icmp ne %struct.usb_device* %dev, null
  %or.cond = and i1 %tobool, %tobool1
  %tobool3 = icmp ne %struct.scatterlist* %sg, null
  %or.cond3 = and i1 %or.cond, %tobool3
  br i1 %or.cond3, label %lor.lhs.false4, label %cleanup96

lor.lhs.false4:                                   ; preds = %entry
  %shr = lshr i32 %pipe, 30
  %and = and i32 %shr, 3
  %cmp = icmp eq i32 %and, 2
  br i1 %cmp, label %cleanup96, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false4
  %shr6 = lshr i32 %pipe, 30
  %and7 = and i32 %shr6, 3
  %cmp8 = icmp eq i32 %and7, 0
  %cmp10 = icmp sle i32 %nents, 0
  %or.cond4 = or i1 %cmp8, %cmp10
  br i1 %or.cond4, label %cleanup96, label %do.body

do.body:                                          ; preds = %lor.lhs.false5
  %lock12 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock12, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.306, i32 0, i32 0), %struct.lock_class_key* @usb_sg_init.__key)
  %dev15 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 3
  store %struct.usb_device* %dev, %struct.usb_device** %dev15, align 8, !tbaa !522
  %pipe16 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 4
  store i32 %pipe, i32* %pipe16, align 8, !tbaa !525
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %sg_tablesize = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %1, i32 0, i32 7
  %2 = load i32, i32* %sg_tablesize, align 4, !tbaa !526
  %cmp17 = icmp ugt i32 %2, 0
  %nents.sink = select i1 %cmp17, i32 1, i32 %nents
  %use_sg.0 = select i1 %cmp17, i32 1, i32 0
  %entries19 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  store i32 %nents.sink, i32* %entries19, align 4, !tbaa !520
  %entries21 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  %3 = load i32, i32* %entries21, align 4, !tbaa !520
  %conv = sext i32 %3 to i64
  %mul = mul i64 %conv, 8
  %call.i = call noalias i8* @__kmalloc(i64 %mul, i32 %mem_flags) #8
  %4 = bitcast i8* %call.i to %struct.urb**
  %urbs = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  store %struct.urb** %4, %struct.urb*** %urbs, align 8, !tbaa !521
  %urbs23 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %5 = load %struct.urb**, %struct.urb*** %urbs23, align 8, !tbaa !521
  %tobool24 = icmp ne %struct.urb** %5, null
  br i1 %tobool24, label %if.end26, label %nomem

if.end26:                                         ; preds = %do.body
  %and27 = and i32 %pipe, 128
  %tobool28 = icmp ne i32 %and27, 0
  %or = or i32 128, 1
  %or. = select i1 %tobool28, i32 %or, i32 128
  br label %for.cond

for.cond:                                         ; preds = %for.inc85, %if.end26
  %i.0 = phi i32 [ 0, %if.end26 ], [ %inc86, %for.inc85 ]
  %length.addr.0 = phi i64 [ %length, %if.end26 ], [ %length.addr.3, %for.inc85 ]
  %sg.addr.0 = phi %struct.scatterlist* [ %sg, %if.end26 ], [ %call87, %for.inc85 ]
  %entries31 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  %6 = load i32, i32* %entries31, align 4, !tbaa !520
  %cmp32 = icmp slt i32 %i.0, %6
  br i1 %cmp32, label %for.body, label %for.end88

for.body:                                         ; preds = %for.cond
  %call34 = call %struct.urb* bitcast (%struct.urb.744* (i32, i32)* @usb_alloc_urb to %struct.urb* (i32, i32)*)(i32 0, i32 %mem_flags)
  %tobool35 = icmp ne %struct.urb* %call34, null
  br i1 %tobool35, label %if.end38, label %if.then36

if.then36:                                        ; preds = %for.body
  %entries37 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  store i32 %i.0, i32* %entries37, align 4, !tbaa !520
  br label %NodeBlock

if.end38:                                         ; preds = %for.body
  %urbs39 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %7 = load %struct.urb**, %struct.urb*** %urbs39, align 8, !tbaa !521
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.urb*, %struct.urb** %7, i64 %idxprom
  store %struct.urb* %call34, %struct.urb** %arrayidx, align 8, !tbaa !52
  %dev40 = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 8
  store %struct.usb_device* null, %struct.usb_device** %dev40, align 8, !tbaa !242
  %pipe41 = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 10
  store i32 %pipe, i32* %pipe41, align 8, !tbaa !244
  %interval = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 25
  store i32 %period, i32* %interval, align 8, !tbaa !319
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 13
  store i32 %or., i32* %transfer_flags, align 4, !tbaa !379
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 28
  store void (%struct.urb*)* @sg_complete, void (%struct.urb*)** %complete, align 8, !tbaa !318
  %8 = bitcast %struct.usb_sg_request* %io to i8*
  %context = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 27
  store i8* %8, i8** %context, align 8, !tbaa !313
  %sg42 = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 16
  store %struct.scatterlist* %sg.addr.0, %struct.scatterlist** %sg42, align 8, !tbaa !397
  %tobool43 = icmp ne i32 %use_sg.0, 0
  br i1 %tobool43, label %if.then44, label %if.else56

if.then44:                                        ; preds = %if.end38
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 14
  store i8* null, i8** %transfer_buffer, align 8, !tbaa !316
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 18
  store i32 %nents, i32* %num_sgs, align 4, !tbaa !398
  %conv45 = trunc i64 %length.addr.0 to i32
  %cmp46 = icmp eq i32 %conv45, 0
  br i1 %cmp46, label %if.then48, label %if.end83

if.then48:                                        ; preds = %if.then44
  br label %for.cond49

for.cond49:                                       ; preds = %for.body52, %if.then48
  %len.0 = phi i32 [ %conv45, %if.then48 ], [ %add, %for.body52 ]
  %sg2.0 = phi %struct.scatterlist* [ %sg.addr.0, %if.then48 ], [ %call54, %for.body52 ]
  %j.0 = phi i32 [ 0, %if.then48 ], [ %inc, %for.body52 ]
  %cmp50 = icmp slt i32 %j.0, %nents
  br i1 %cmp50, label %for.body52, label %if.end83

for.body52:                                       ; preds = %for.cond49
  %length53 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg2.0, i32 0, i32 3
  %9 = load i32, i32* %length53, align 4, !tbaa !480
  %add = add i32 %len.0, %9
  %inc = add nsw i32 %j.0, 1
  %call54 = call %struct.scatterlist* @sg_next(%struct.scatterlist* %sg2.0)
  br label %for.cond49

if.else56:                                        ; preds = %if.end38
  %call57 = call %struct.page* @sg_page.307(%struct.scatterlist* %sg.addr.0)
  %call58 = call i32 @PageHighMem()
  %tobool59 = icmp ne i32 %call58, 0
  br i1 %tobool59, label %if.end65, label %if.then60

if.then60:                                        ; preds = %if.else56
  %call61 = call i8* @sg_virt.308(%struct.scatterlist* %sg.addr.0)
  br label %if.end65

if.end65:                                         ; preds = %if.then60, %if.else56
  %.sink = phi i8* [ %call61, %if.then60 ], [ null, %if.else56 ]
  %transfer_buffer64 = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 14
  store i8* %.sink, i8** %transfer_buffer64, align 8, !tbaa !316
  %length66 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg.addr.0, i32 0, i32 3
  %10 = load i32, i32* %length66, align 4, !tbaa !480
  %tobool67 = icmp ne i64 %length.addr.0, 0
  br i1 %tobool67, label %if.then68, label %if.end83

if.then68:                                        ; preds = %if.end65
  %conv69 = zext i32 %10 to i64
  store i64 %conv69, i64* %__UNIQUE_ID_min1_16, align 8, !tbaa !53
  store i64 %length.addr.0, i64* %__UNIQUE_ID_min2_17, align 8, !tbaa !53
  %11 = load i64, i64* %__UNIQUE_ID_min1_16, align 8, !tbaa !53
  %12 = load i64, i64* %__UNIQUE_ID_min2_17, align 8, !tbaa !53
  %cmp72 = icmp ult i64 %11, %12
  %13 = load i64, i64* %__UNIQUE_ID_min1_16, align 8
  %14 = load i64, i64* %__UNIQUE_ID_min2_17, align 8
  %cond = select i1 %cmp72, i64 %13, i64 %14
  %conv74 = trunc i64 %cond to i32
  %conv75 = zext i32 %conv74 to i64
  %sub = sub i64 %length.addr.0, %conv75
  %cmp76 = icmp eq i64 %sub, 0
  br i1 %cmp76, label %if.then78, label %if.end83

if.then78:                                        ; preds = %if.then68
  %add79 = add nsw i32 %i.0, 1
  %entries80 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  store i32 %add79, i32* %entries80, align 4, !tbaa !520
  br label %if.end83

if.end83:                                         ; preds = %if.then78, %if.then68, %if.end65, %for.cond49, %if.then44
  %length.addr.2 = phi i64 [ %length.addr.0, %for.cond49 ], [ %length.addr.0, %if.then44 ], [ %length.addr.0, %if.end65 ], [ %sub, %if.then78 ], [ %sub, %if.then68 ]
  %len.3 = phi i32 [ %conv45, %if.then44 ], [ %len.0, %for.cond49 ], [ %10, %if.end65 ], [ %conv74, %if.then78 ], [ %conv74, %if.then68 ]
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 19
  store i32 %len.3, i32* %transfer_buffer_length, align 8, !tbaa !317
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end83, %if.then36
  %length.addr.3 = phi i64 [ %length.addr.2, %if.end83 ], [ %length.addr.0, %if.then36 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end83 ], [ 6, %if.then36 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 6
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 6
  br i1 %SwitchLeaf2, label %nomem, label %cleanup96

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc85, label %cleanup96

for.inc85:                                        ; preds = %LeafBlock
  %inc86 = add nsw i32 %i.0, 1
  %call87 = call %struct.scatterlist* @sg_next(%struct.scatterlist* %sg.addr.0)
  br label %for.cond

for.end88:                                        ; preds = %for.cond
  %urbs89 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %15 = load %struct.urb**, %struct.urb*** %urbs89, align 8, !tbaa !521
  %dec = add nsw i32 %i.0, -1
  %idxprom90 = sext i32 %dec to i64
  %arrayidx91 = getelementptr inbounds %struct.urb*, %struct.urb** %15, i64 %idxprom90
  %16 = load %struct.urb*, %struct.urb** %arrayidx91, align 8, !tbaa !52
  %transfer_flags92 = getelementptr inbounds %struct.urb, %struct.urb* %16, i32 0, i32 13
  %17 = load i32, i32* %transfer_flags92, align 4, !tbaa !379
  %and93 = and i32 %17, -129
  store i32 %and93, i32* %transfer_flags92, align 4, !tbaa !379
  %entries94 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  %18 = load i32, i32* %entries94, align 4, !tbaa !520
  %count = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 7
  store i32 %18, i32* %count, align 8, !tbaa !524
  %status = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 0
  store i32 0, i32* %status, align 8, !tbaa !518
  %bytes = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 1
  store i64 0, i64* %bytes, align 8, !tbaa !527
  %complete95 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 8
  call void @init_completion(%struct.completion* %complete95)
  br label %cleanup96

nomem:                                            ; preds = %LeafBlock1, %do.body
  call void @sg_clean(%struct.usb_sg_request* %io)
  br label %cleanup96

cleanup96:                                        ; preds = %nomem, %for.end88, %LeafBlock, %LeafBlock1, %lor.lhs.false5, %lor.lhs.false4, %entry
  %retval.0 = phi i32 [ -12, %nomem ], [ 0, %for.end88 ], [ -22, %lor.lhs.false5 ], [ -22, %lor.lhs.false4 ], [ -22, %entry ], [ undef, %LeafBlock ], [ undef, %LeafBlock1 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sg_complete(%struct.urb* %urb) #0 {
entry:
  %context = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  %0 = load i8*, i8** %context, align 8, !tbaa !313
  %1 = bitcast i8* %0 to %struct.usb_sg_request*
  %status1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 12
  %2 = load i32, i32* %status1, align 8, !tbaa !314
  %lock = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 2
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %3 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock.i1) #8
  %status2 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 0
  %4 = load i32, i32* %status2, align 8, !tbaa !518
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %status3 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 0
  %5 = load i32, i32* %status3, align 8, !tbaa !518
  %cmp = icmp ne i32 %5, -104
  %cmp4 = icmp ne i32 %2, -104
  %or.cond = or i1 %cmp, %cmp4
  br i1 %or.cond, label %land.lhs.true5, label %if.end

land.lhs.true5:                                   ; preds = %land.lhs.true
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %6 = load i32, i32* %actual_length, align 4, !tbaa !315
  %tobool6 = icmp ne i32 %6, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true5
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %7 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !250
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %7, i32 0, i32 0
  %call = call i32 @usb_endpoint_num.273(%struct.usb_endpoint_descriptor* %desc)
  %call8 = call i32 @usb_urb_dir_in.274(%struct.urb* %urb)
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true5, %land.lhs.true, %entry
  %status11 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 0
  %8 = load i32, i32* %status11, align 8, !tbaa !518
  %cmp12 = icmp eq i32 %8, 0
  br i1 %cmp12, label %switch.early.test, label %if.end52

switch.early.test:                                ; preds = %if.end
  switch i32 %2, label %if.then17 [
    i32 -104, label %if.end52
    i32 0, label %if.end52
  ]

if.then17:                                        ; preds = %switch.early.test
  %status18 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 0
  store i32 %2, i32* %status18, align 8, !tbaa !518
  %lock19 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 2
  %9 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock19, i32 0, i32 0
  %rlock.i3 = bitcast %union.anon.1* %9 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock.i3) #8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then17
  %i.0 = phi i32 [ 0, %if.then17 ], [ %inc, %for.inc ]
  %found.0 = phi i32 [ 0, %if.then17 ], [ %found.3, %for.inc ]
  %entries = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 5
  %10 = load i32, i32* %entries, align 4, !tbaa !520
  %cmp20 = icmp slt i32 %i.0, %10
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %urbs = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 6
  %11 = load %struct.urb**, %struct.urb*** %urbs, align 8, !tbaa !521
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.urb*, %struct.urb** %11, i64 %idxprom
  %12 = load %struct.urb*, %struct.urb** %arrayidx, align 8, !tbaa !52
  %tobool21 = icmp ne %struct.urb* %12, null
  br i1 %tobool21, label %if.end23, label %for.inc

if.end23:                                         ; preds = %for.body
  %tobool24 = icmp ne i32 %found.0, 0
  %urbs26 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 6
  %13 = load %struct.urb**, %struct.urb*** %urbs26, align 8, !tbaa !521
  %idxprom27 = sext i32 %i.0 to i64
  %arrayidx28 = getelementptr inbounds %struct.urb*, %struct.urb** %13, i64 %idxprom27
  %14 = load %struct.urb*, %struct.urb** %arrayidx28, align 8, !tbaa !52
  br i1 %tobool24, label %if.then25, label %if.else

if.then25:                                        ; preds = %if.end23
  call void bitcast (void (%struct.urb.744*)* @usb_block_urb to void (%struct.urb*)*)(%struct.urb* %14)
  %urbs29 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 6
  %15 = load %struct.urb**, %struct.urb*** %urbs29, align 8, !tbaa !521
  %idxprom30 = sext i32 %i.0 to i64
  %arrayidx31 = getelementptr inbounds %struct.urb*, %struct.urb** %15, i64 %idxprom30
  %16 = load %struct.urb*, %struct.urb** %arrayidx31, align 8, !tbaa !52
  %call32 = call i32 bitcast (i32 (%struct.urb.744*)* @usb_unlink_urb to i32 (%struct.urb*)*)(%struct.urb* %16)
  switch i32 %call32, label %if.then40 [
    i32 -115, label %for.inc
    i32 -19, label %for.inc
    i32 -16, label %for.inc
    i32 -43, label %for.inc
  ]

if.then40:                                        ; preds = %if.then25
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %for.inc

if.else:                                          ; preds = %if.end23
  %cmp47 = icmp eq %struct.urb* %urb, %14
  %.found.0 = select i1 %cmp47, i32 1, i32 %found.0
  br label %for.inc

for.inc:                                          ; preds = %if.else, %if.then40, %if.then25, %if.then25, %if.then25, %if.then25, %for.body
  %found.3 = phi i32 [ %found.0, %for.body ], [ %.found.0, %if.else ], [ %found.0, %if.then25 ], [ %found.0, %if.then25 ], [ %found.0, %if.then25 ], [ %found.0, %if.then25 ], [ %found.0, %if.then40 ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %lock51 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 2
  %17 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock51, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %17 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock.i) #8
  br label %if.end52

if.end52:                                         ; preds = %for.end, %switch.early.test, %switch.early.test, %if.end
  %actual_length53 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %18 = load i32, i32* %actual_length53, align 4, !tbaa !315
  %conv = zext i32 %18 to i64
  %bytes = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 1
  %19 = load i64, i64* %bytes, align 8, !tbaa !527
  %add = add i64 %19, %conv
  store i64 %add, i64* %bytes, align 8, !tbaa !527
  %count = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 7
  %20 = load i32, i32* %count, align 8, !tbaa !524
  %dec = add nsw i32 %20, -1
  store i32 %dec, i32* %count, align 8, !tbaa !524
  %count54 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 7
  %21 = load i32, i32* %count54, align 8, !tbaa !524
  %tobool55 = icmp ne i32 %21, 0
  br i1 %tobool55, label %if.end57, label %if.then56

if.then56:                                        ; preds = %if.end52
  %complete = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 8
  call void @complete(%struct.completion* %complete)
  br label %if.end57

if.end57:                                         ; preds = %if.then56, %if.end52
  %lock58 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 2
  %22 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock58, i32 0, i32 0
  %rlock.i2 = bitcast %union.anon.1* %22 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock.i2) #8
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.page* @sg_page.307(%struct.scatterlist* %sg) #1 {
entry:
  %sg_magic = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 0
  %0 = load i64, i64* %sg_magic, align 8, !tbaa !435
  %cmp = icmp ne i64 %0, 2271560481
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.body8

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.37.737, i32 0, i32 0), i32 123, i64 12) #8, !srcloc !528
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.body8:                                         ; preds = %entry
  %page_link = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %1 = load i64, i64* %page_link, align 8, !tbaa !437
  %and = and i64 %1, 1
  %tobool9 = icmp ne i64 %and, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %do.body18, label %do.end26

do.body18:                                        ; preds = %do.body8
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.37.737, i32 0, i32 0), i32 124, i64 12) #8, !srcloc !529
  br label %do.body19

do.body19:                                        ; preds = %do.body19, %do.body18
  br label %do.body19

do.end26:                                         ; preds = %do.body8
  %page_link27 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %2 = load i64, i64* %page_link27, align 8, !tbaa !437
  %and28 = and i64 %2, -4
  %3 = inttoptr i64 %and28 to %struct.page*
  ret %struct.page* %3
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @PageHighMem() #1 {
entry:
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @sg_virt.308(%struct.scatterlist* %sg) #1 {
entry:
  %call = call %struct.page* @sg_page.307(%struct.scatterlist* %sg)
  %0 = load i64, i64* @vmemmap_base, align 8, !tbaa !53
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %call to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %0
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %1 = load i64, i64* @page_offset_base, align 8, !tbaa !53
  %add.i = add i64 %shl.i, %1
  %2 = inttoptr i64 %add.i to i8*
  %offset = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 2
  %3 = load i32, i32* %offset, align 8, !tbaa !427
  %idx.ext = zext i32 %3 to i64
  %add.ptr = getelementptr i8, i8* %2, i64 %idx.ext
  ret i8* %add.ptr
}

; Function Attrs: nounwind uwtable
define i32 @usb_bulk_msg(%struct.usb_device* %usb_dev, i32 %pipe, i8* %data, i32 %len, i32* %actual_length, i32 %timeout) #0 {
entry:
  %call = call %struct.usb_host_endpoint* @usb_pipe_endpoint.312(%struct.usb_device* %usb_dev, i32 %pipe)
  %tobool = icmp eq %struct.usb_host_endpoint* %call, null
  %cmp = icmp slt i32 %len, 0
  %or.cond = or i1 %tobool, %cmp
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call %struct.urb* bitcast (%struct.urb.744* (i32, i32)* @usb_alloc_urb to %struct.urb* (i32, i32)*)(i32 0, i32 20971712)
  %tobool2 = icmp ne %struct.urb* %call1, null
  br i1 %tobool2, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 0
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !530
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp5 = icmp eq i32 %and, 3
  br i1 %cmp5, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end4
  %and8 = and i32 %pipe, 1073741823
  %or = or i32 %and8, 1073741824
  %desc9 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 0
  %bInterval = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc9, i32 0, i32 5
  %1 = load i8, i8* %bInterval, align 2, !tbaa !531
  %conv10 = zext i8 %1 to i32
  call void @usb_fill_int_urb.313(%struct.urb* %call1, %struct.usb_device* %usb_dev, i32 %or, i8* %data, i32 %len, void (%struct.urb*)* @usb_api_blocking_completion, i8* null, i32 %conv10)
  br label %if.end11

if.else:                                          ; preds = %if.end4
  call void @usb_fill_bulk_urb(%struct.urb* %call1, %struct.usb_device* %usb_dev, i32 %pipe, i8* %data, i32 %len, void (%struct.urb*)* @usb_api_blocking_completion, i8* null)
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.then7
  %call12 = call i32 @usb_start_wait_urb(%struct.urb* %call1, i32 %timeout, i32* %actual_length)
  br label %cleanup

cleanup:                                          ; preds = %if.end11, %if.end, %entry
  %retval.0 = phi i32 [ %call12, %if.end11 ], [ -22, %entry ], [ -12, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_host_endpoint* @usb_pipe_endpoint.312(%struct.usb_device* %dev, i32 %pipe) #1 {
entry:
  %and = and i32 %pipe, 128
  %tobool = icmp ne i32 %and, 0
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 17
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 16
  %ep_out.sink = select i1 %tobool, [16 x %struct.usb_host_endpoint*]* %ep_in, [16 x %struct.usb_host_endpoint*]* %ep_out
  %arraydecay1 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out.sink, i32 0, i32 0
  %shr = lshr i32 %pipe, 15
  %and2 = and i32 %shr, 15
  %idxprom = zext i32 %and2 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arraydecay1, i64 %idxprom
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8, !tbaa !52
  ret %struct.usb_host_endpoint* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_fill_int_urb.313(%struct.urb* %urb, %struct.usb_device* %dev, i32 %pipe, i8* %transfer_buffer, i32 %buffer_length, void (%struct.urb*)* %complete_fn, i8* %context, i32 %interval) #1 {
entry:
  %__UNIQUE_ID_min1_14 = alloca i32, align 4
  %__UNIQUE_ID_max1_12 = alloca i32, align 4
  %__UNIQUE_ID_max2_13 = alloca i32, align 4
  %__UNIQUE_ID_min2_15 = alloca i32, align 4
  %dev1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  store %struct.usb_device* %dev, %struct.usb_device** %dev1, align 8, !tbaa !242
  %pipe2 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 10
  store i32 %pipe, i32* %pipe2, align 8, !tbaa !244
  %transfer_buffer3 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  store i8* %transfer_buffer, i8** %transfer_buffer3, align 8, !tbaa !316
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  store i32 %buffer_length, i32* %transfer_buffer_length, align 8, !tbaa !317
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 28
  store void (%struct.urb*)* %complete_fn, void (%struct.urb*)** %complete, align 8, !tbaa !318
  %context4 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  store i8* %context, i8** %context4, align 8, !tbaa !313
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp eq i32 %0, 3
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %speed5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 4
  %1 = load i32, i32* %speed5, align 4, !tbaa !177
  %cmp6 = icmp uge i32 %1, 5
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 %interval, i32* %__UNIQUE_ID_max1_12, align 4, !tbaa !73
  store i32 1, i32* %__UNIQUE_ID_max2_13, align 4, !tbaa !73
  %2 = load i32, i32* %__UNIQUE_ID_max1_12, align 4, !tbaa !73
  %3 = load i32, i32* %__UNIQUE_ID_max2_13, align 4, !tbaa !73
  %cmp8 = icmp sgt i32 %2, %3
  %4 = load i32, i32* %__UNIQUE_ID_max1_12, align 4
  %5 = load i32, i32* %__UNIQUE_ID_max2_13, align 4
  %cond = select i1 %cmp8, i32 %4, i32 %5
  store i32 %cond, i32* %__UNIQUE_ID_min1_14, align 4, !tbaa !73
  store i32 16, i32* %__UNIQUE_ID_min2_15, align 4, !tbaa !73
  %6 = load i32, i32* %__UNIQUE_ID_min1_14, align 4, !tbaa !73
  %7 = load i32, i32* %__UNIQUE_ID_min2_15, align 4, !tbaa !73
  %cmp13 = icmp slt i32 %6, %7
  %8 = load i32, i32* %__UNIQUE_ID_min1_14, align 4
  %9 = load i32, i32* %__UNIQUE_ID_min2_15, align 4
  %cond18 = select i1 %cmp13, i32 %8, i32 %9
  %sub = sub nsw i32 %cond18, 1
  %shl = shl i32 1, %sub
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %interval.sink = phi i32 [ %shl, %if.then ], [ %interval, %lor.lhs.false ]
  %interval20 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 25
  store i32 %interval.sink, i32* %interval20, align 8, !tbaa !319
  %start_frame = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 23
  store i32 -1, i32* %start_frame, align 8, !tbaa !320
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_fill_bulk_urb(%struct.urb* %urb, %struct.usb_device* %dev, i32 %pipe, i8* %transfer_buffer, i32 %buffer_length, void (%struct.urb*)* %complete_fn, i8* %context) #1 {
entry:
  %dev1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  store %struct.usb_device* %dev, %struct.usb_device** %dev1, align 8, !tbaa !242
  %pipe2 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 10
  store i32 %pipe, i32* %pipe2, align 8, !tbaa !244
  %transfer_buffer3 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  store i8* %transfer_buffer, i8** %transfer_buffer3, align 8, !tbaa !316
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  store i32 %buffer_length, i32* %transfer_buffer_length, align 8, !tbaa !317
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 28
  store void (%struct.urb*)* %complete_fn, void (%struct.urb*)** %complete, align 8, !tbaa !318
  %context4 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  store i8* %context, i8** %context4, align 8, !tbaa !313
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_interrupt_msg(%struct.usb_device* %usb_dev, i32 %pipe, i8* %data, i32 %len, i32* %actual_length, i32 %timeout) #0 {
entry:
  %call = call i32 @usb_bulk_msg(%struct.usb_device* %usb_dev, i32 %pipe, i8* %data, i32 %len, i32* %actual_length, i32 %timeout)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @usb_get_device_descriptor(%struct.usb_device* %dev, i32 %size) #0 {
entry:
  %conv = zext i32 %size to i64
  %cmp = icmp ugt i64 %conv, 18
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call.i = call noalias i8* @__kmalloc(i64 18, i32 20971520) #8
  %0 = bitcast i8* %call.i to %struct.usb_device_descriptor*
  %tobool = icmp ne %struct.usb_device_descriptor* %0, null
  br i1 %tobool, label %if.end3, label %cleanup

if.end3:                                          ; preds = %if.end
  %1 = bitcast %struct.usb_device_descriptor* %0 to i8*
  %call4 = call i32 @usb_get_descriptor(%struct.usb_device* %dev, i8 zeroext 1, i8 zeroext 0, i8* %1, i32 %size)
  %cmp5 = icmp sge i32 %call4, 0
  br i1 %cmp5, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end3
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %2 = bitcast %struct.usb_device_descriptor* %descriptor to i8*
  %3 = bitcast %struct.usb_device_descriptor* %0 to i8*
  %conv8 = zext i32 %size to i64
  %call9 = call i8* @__memcpy(i8* %2, i8* %3, i64 %conv8)
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end3
  %4 = bitcast %struct.usb_device_descriptor* %0 to i8*
  call void @kfree(i8* %4)
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.end, %entry
  %retval.0 = phi i32 [ %call4, %if.end10 ], [ -22, %entry ], [ -12, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_deauthorize_interface(%struct.usb_interface* %intf) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %parent, align 8, !tbaa !532
  call void @device_lock.233(%struct.device* %0)
  %authorized = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load = load i8, i8* %authorized, align 8
  %bf.lshr = lshr i8 %bf.load, 7
  %bf.cast = zext i8 %bf.lshr to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @device_lock.233(%struct.device* %dev1)
  %authorized2 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load3 = load i8, i8* %authorized2, align 8
  %bf.clear = and i8 %bf.load3, 127
  store i8 %bf.clear, i8* %authorized2, align 8
  call void @device_unlock.237(%struct.device* %dev1)
  call void @usb_forced_unbind_intf(%struct.usb_interface* %intf)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %parent4 = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 0
  %1 = load %struct.device*, %struct.device** %parent4, align 8, !tbaa !532
  call void @device_unlock.237(%struct.device* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_authorize_interface(%struct.usb_interface* %intf) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %authorized = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load = load i8, i8* %authorized, align 8
  %bf.lshr = lshr i8 %bf.load, 7
  %bf.cast = zext i8 %bf.lshr to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @device_lock.233(%struct.device* %dev1)
  %authorized2 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load3 = load i8, i8* %authorized2, align 8
  %bf.clear = and i8 %bf.load3, 127
  %bf.set = or i8 %bf.clear, -128
  store i8 %bf.set, i8* %authorized2, align 8
  call void @device_unlock.237(%struct.device* %dev1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_device_match(%struct.device* %dev, %struct.device_driver* %drv) #0 {
entry:
  %call = call i32 @is_usb_device.319(%struct.device* %dev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = call i32 @is_usb_device_driver(%struct.device_driver* %drv)
  %tobool2 = icmp ne i32 %call1, 0
  %. = select i1 %tobool2, i32 1, i32 0
  br label %return

if.else:                                          ; preds = %entry
  %call4 = call i32 @is_usb_interface.320(%struct.device* %dev)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end25

if.then6:                                         ; preds = %if.else
  %call7 = call i32 @is_usb_device_driver(%struct.device_driver* %drv)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %LeafBlock, label %if.end10

if.end10:                                         ; preds = %if.then6
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -48
  %1 = bitcast i8* %add.ptr to %struct.usb_interface*
  %2 = bitcast %struct.device_driver* %drv to i8*
  %add.ptr13 = getelementptr inbounds i8, i8* %2, i64 -168
  %3 = bitcast i8* %add.ptr13 to %struct.usb_driver*
  %id_table = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %3, i32 0, i32 9
  %4 = load %struct.usb_device_id*, %struct.usb_device_id** %id_table, align 8, !tbaa !533
  %call14 = call %struct.usb_device_id* @usb_match_id(%struct.usb_interface* %1, %struct.usb_device_id* %4)
  %tobool15 = icmp ne %struct.usb_device_id* %call14, null
  br i1 %tobool15, label %LeafBlock, label %if.end17

if.end17:                                         ; preds = %if.end10
  %call18 = call %struct.usb_device_id* @usb_match_dynamic_id(%struct.usb_interface* %1, %struct.usb_driver* %3)
  %tobool19 = icmp ne %struct.usb_device_id* %call18, null
  %.1 = select i1 %tobool19, i32 1, i32 0
  %.2 = select i1 %tobool19, i32 1, i32 undef
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end17, %if.end10, %if.then6
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then6 ], [ 1, %if.end10 ], [ %.1, %if.end17 ]
  %retval.0 = phi i32 [ 0, %if.then6 ], [ 1, %if.end10 ], [ %.2, %if.end17 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 1
  br i1 %SwitchLeaf, label %return, label %if.end25

if.end25:                                         ; preds = %LeafBlock, %if.else
  br label %return

return:                                           ; preds = %if.end25, %LeafBlock, %if.then
  %retval.1 = phi i32 [ %retval.0, %LeafBlock ], [ 0, %if.end25 ], [ %., %if.then ]
  ret i32 %retval.1
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_uevent(%struct.device* %dev, %struct.kobj_uevent_env* %env) #0 {
entry:
  %call = call i32 @is_usb_device.319(%struct.device* %dev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  br label %if.end9

if.else:                                          ; preds = %entry
  %call1 = call i32 @is_usb_interface.320(%struct.device* %dev)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %cleanup

if.then3:                                         ; preds = %if.else
  %2 = bitcast %struct.device* %dev to i8*
  %add.ptr6 = getelementptr inbounds i8, i8* %2, i64 -48
  %3 = bitcast i8* %add.ptr6 to %struct.usb_interface*
  %call7 = call %struct.usb_device* @interface_to_usbdev.321(%struct.usb_interface* %3)
  br label %if.end9

if.end9:                                          ; preds = %if.then3, %if.then
  %usb_dev.0 = phi %struct.usb_device* [ %1, %if.then ], [ %call7, %if.then3 ]
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev.0, i32 0, i32 0
  %4 = load i32, i32* %devnum, align 8, !tbaa !44
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %do.body, label %if.end17

do.body:                                          ; preds = %if.end9
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_uevent.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool11 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool11, true
  %lnot12 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot12 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  br i1 %tobool13, label %if.then14, label %cleanup

if.then14:                                        ; preds = %do.body
  %call15 = call i8* @dev_name.322(%struct.device* %dev)
  call void (%struct._ddebug*, i8*, ...) @__dynamic_pr_debug(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_uevent.descriptor to %struct._ddebug*), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.32.323, i32 0, i32 0), i8* %call15)
  br label %cleanup

if.end17:                                         ; preds = %if.end9
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev.0, i32 0, i32 9
  %5 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %tobool18 = icmp ne %struct.usb_bus* %5, null
  br i1 %tobool18, label %if.end38, label %do.body20

do.body20:                                        ; preds = %if.end17
  %bf.load21 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_uevent.descriptor.33 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr22 = lshr i32 %bf.load21, 18
  %bf.clear23 = and i32 %bf.lshr22, 255
  %and24 = and i32 %bf.clear23, 1
  %tobool25 = icmp ne i32 %and24, 0
  %lnot26 = xor i1 %tobool25, true
  %lnot28 = xor i1 %lnot26, true
  %lnot.ext29 = zext i1 %lnot28 to i32
  %conv30 = sext i32 %lnot.ext29 to i64
  %expval31 = call i64 @llvm.expect.i64(i64 %conv30, i64 0)
  %tobool32 = icmp ne i64 %expval31, 0
  br i1 %tobool32, label %if.then33, label %cleanup

if.then33:                                        ; preds = %do.body20
  %call34 = call i8* @dev_name.322(%struct.device* %dev)
  call void (%struct._ddebug*, i8*, ...) @__dynamic_pr_debug(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_uevent.descriptor.33 to %struct._ddebug*), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.34.324, i32 0, i32 0), i8* %call34)
  br label %cleanup

if.end38:                                         ; preds = %if.end17
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev.0, i32 0, i32 12
  %idVendor = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 7
  %6 = load i16, i16* %idVendor, align 8, !tbaa !268
  %conv39 = zext i16 %6 to i32
  %descriptor40 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev.0, i32 0, i32 12
  %idProduct = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor40, i32 0, i32 8
  %7 = load i16, i16* %idProduct, align 2, !tbaa !269
  %conv41 = zext i16 %7 to i32
  %descriptor42 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev.0, i32 0, i32 12
  %bcdDevice = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor42, i32 0, i32 9
  %8 = load i16, i16* %bcdDevice, align 4, !tbaa !275
  %conv43 = zext i16 %8 to i32
  %call44 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.35.325, i32 0, i32 0), i32 %conv39, i32 %conv41, i32 %conv43)
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %cleanup, label %if.end47

if.end47:                                         ; preds = %if.end38
  %descriptor48 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev.0, i32 0, i32 12
  %bDeviceClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor48, i32 0, i32 3
  %9 = load i8, i8* %bDeviceClass, align 4, !tbaa !278
  %conv49 = zext i8 %9 to i32
  %descriptor50 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev.0, i32 0, i32 12
  %bDeviceSubClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor50, i32 0, i32 4
  %10 = load i8, i8* %bDeviceSubClass, align 1, !tbaa !280
  %conv51 = zext i8 %10 to i32
  %descriptor52 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev.0, i32 0, i32 12
  %bDeviceProtocol = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor52, i32 0, i32 5
  %11 = load i8, i8* %bDeviceProtocol, align 2, !tbaa !205
  %conv53 = zext i8 %11 to i32
  %call54 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.36.326, i32 0, i32 0), i32 %conv49, i32 %conv51, i32 %conv53)
  %tobool55 = icmp ne i32 %call54, 0
  %. = select i1 %tobool55, i32 -12, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end47, %if.end38, %if.then33, %do.body20, %if.then14, %do.body, %if.else
  %retval.0 = phi i32 [ 0, %if.else ], [ -19, %if.then14 ], [ -19, %do.body ], [ -19, %if.then33 ], [ -19, %do.body20 ], [ -12, %if.end38 ], [ %., %if.end47 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_usb_device.319(%struct.device* %dev) #1 {
entry:
  %type = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 4
  %0 = load %struct.device_type*, %struct.device_type** %type, align 8, !tbaa !91
  %cmp = icmp eq %struct.device_type* %0, @usb_device_type
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_usb_interface.320(%struct.device* %dev) #1 {
entry:
  %type = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 4
  %0 = load %struct.device_type*, %struct.device_type** %type, align 8, !tbaa !91
  %cmp = icmp eq %struct.device_type* %0, @usb_if_device_type
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_device* @interface_to_usbdev.321(%struct.usb_interface* %intf) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %parent, align 8, !tbaa !300
  %1 = bitcast %struct.device* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -152
  %2 = bitcast i8* %add.ptr to %struct.usb_device*
  ret %struct.usb_device* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name.322(%struct.device* %dev) #1 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !299
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !299
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name.329(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name.329(%struct.kobject* %kobj) #1 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !409
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_usb_device_driver(%struct.device_driver* %drv) #1 {
entry:
  %0 = bitcast %struct.device_driver* %drv to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usbdrv_wrap*
  %for_devices = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %1, i32 0, i32 1
  %2 = load i32, i32* %for_devices, align 8, !tbaa !534
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define %struct.usb_device_id* @usb_match_id(%struct.usb_interface* %interface, %struct.usb_device_id* %id) #0 {
entry:
  %cmp = icmp eq %struct.usb_device_id* %id, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %id.addr.0 = phi %struct.usb_device_id* [ %id, %if.end ], [ %incdec.ptr, %for.inc ]
  %idVendor = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 0, i32 1
  %0 = load i16, i16* %idVendor, align 2, !tbaa !272
  %conv = zext i16 %0 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %for.body, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.cond
  %idProduct = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 0, i32 2
  %1 = load i16, i16* %idProduct, align 4, !tbaa !273
  %conv1 = zext i16 %1 to i32
  %tobool2 = icmp ne i32 %conv1, 0
  br i1 %tobool2, label %for.body, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %bDeviceClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 0, i32 5
  %2 = load i8, i8* %bDeviceClass, align 2, !tbaa !277
  %conv4 = zext i8 %2 to i32
  %tobool5 = icmp ne i32 %conv4, 0
  br i1 %tobool5, label %for.body, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false3
  %bInterfaceClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 0, i32 8
  %3 = load i8, i8* %bInterfaceClass, align 1, !tbaa !535
  %conv7 = zext i8 %3 to i32
  %tobool8 = icmp ne i32 %conv7, 0
  br i1 %tobool8, label %for.body, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false6
  %driver_info = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 0, i32 12
  %4 = load i64, i64* %driver_info, align 8, !tbaa !292
  %tobool9 = icmp ne i64 %4, 0
  br i1 %tobool9, label %for.body, label %return

for.body:                                         ; preds = %lor.rhs, %lor.lhs.false6, %lor.lhs.false3, %lor.lhs.false, %for.cond
  %call = call i32 @usb_match_one_id(%struct.usb_interface* %interface, %struct.usb_device_id* %id.addr.0)
  %tobool10 = icmp ne i32 %call, 0
  br i1 %tobool10, label %return, label %for.inc

for.inc:                                          ; preds = %for.body
  %incdec.ptr = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 1
  br label %for.cond

return:                                           ; preds = %for.body, %lor.rhs, %entry
  %retval.0 = phi %struct.usb_device_id* [ null, %entry ], [ %id.addr.0, %for.body ], [ null, %lor.rhs ]
  ret %struct.usb_device_id* %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.usb_device_id* @usb_match_dynamic_id(%struct.usb_interface* %intf, %struct.usb_driver* %drv) #0 {
entry:
  %dynids = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %drv, i32 0, i32 10
  %lock = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 0
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock.i) #8
  %dynids1 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %drv, i32 0, i32 10
  %list = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids1, i32 0, i32 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %node8.sink = phi %struct.list_head* [ %node8, %for.inc ], [ %list, %entry ]
  %next9 = getelementptr inbounds %struct.list_head, %struct.list_head* %node8.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next9, align 8, !tbaa !52
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr11 = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr11 to %struct.usb_dynid*
  %node = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %3, i32 0, i32 0
  %dynids2 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %drv, i32 0, i32 10
  %list3 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids2, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %node, %list3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %id = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %3, i32 0, i32 1
  %call = call i32 @usb_match_one_id(%struct.usb_interface* %intf, %struct.usb_device_id* %id)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %dynids4 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %drv, i32 0, i32 10
  %lock5 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids4, i32 0, i32 0
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock5, i32 0, i32 0
  %rlock.i2 = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock.i2) #8
  %id6 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %3, i32 0, i32 1
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %node8 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %3, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %dynids12 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %drv, i32 0, i32 10
  %lock13 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids12, i32 0, i32 0
  %5 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock13, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %5 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock.i1) #8
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then
  %retval.0 = phi %struct.usb_device_id* [ %id6, %if.then ], [ null, %for.end ]
  ret %struct.usb_device_id* %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_match_one_id(%struct.usb_interface* %interface, %struct.usb_device_id* %id) #0 {
entry:
  %cmp = icmp eq %struct.usb_device_id* %id, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %interface, i32 0, i32 1
  %0 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !169
  %call = call %struct.usb_device* @interface_to_usbdev.321(%struct.usb_interface* %interface)
  %call1 = call i32 @usb_match_device(%struct.usb_device* %call, %struct.usb_device_id* %id)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end3, label %cleanup

if.end3:                                          ; preds = %if.end
  %call4 = call i32 @usb_match_one_id_intf(%struct.usb_device* %call, %struct.usb_host_interface* %0, %struct.usb_device_id* %id)
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry
  %retval.0 = phi i32 [ %call4, %if.end3 ], [ 0, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_match_device(%struct.usb_device* %dev, %struct.usb_device_id* %id) #0 {
entry:
  %match_flags = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %0 = load i16, i16* %match_flags, align 8, !tbaa !270
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %idVendor = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 1
  %1 = load i16, i16* %idVendor, align 2, !tbaa !272
  %conv1 = zext i16 %1 to i32
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %idVendor2 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 7
  %2 = load i16, i16* %idVendor2, align 8, !tbaa !268
  %conv3 = zext i16 %2 to i32
  %cmp = icmp ne i32 %conv1, %conv3
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %match_flags5 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %3 = load i16, i16* %match_flags5, align 8, !tbaa !270
  %conv6 = zext i16 %3 to i32
  %and7 = and i32 %conv6, 2
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %land.lhs.true9, label %if.end17

land.lhs.true9:                                   ; preds = %if.end
  %idProduct = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 2
  %4 = load i16, i16* %idProduct, align 4, !tbaa !273
  %conv10 = zext i16 %4 to i32
  %descriptor11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %idProduct12 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor11, i32 0, i32 8
  %5 = load i16, i16* %idProduct12, align 2, !tbaa !269
  %conv13 = zext i16 %5 to i32
  %cmp14 = icmp ne i32 %conv10, %conv13
  br i1 %cmp14, label %return, label %if.end17

if.end17:                                         ; preds = %land.lhs.true9, %if.end
  %match_flags18 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %6 = load i16, i16* %match_flags18, align 8, !tbaa !270
  %conv19 = zext i16 %6 to i32
  %and20 = and i32 %conv19, 4
  %tobool21 = icmp ne i32 %and20, 0
  br i1 %tobool21, label %land.lhs.true22, label %if.end29

land.lhs.true22:                                  ; preds = %if.end17
  %bcdDevice_lo = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 3
  %7 = load i16, i16* %bcdDevice_lo, align 2, !tbaa !274
  %conv23 = zext i16 %7 to i32
  %descriptor24 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bcdDevice = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor24, i32 0, i32 9
  %8 = load i16, i16* %bcdDevice, align 4, !tbaa !275
  %conv25 = zext i16 %8 to i32
  %cmp26 = icmp sgt i32 %conv23, %conv25
  br i1 %cmp26, label %return, label %if.end29

if.end29:                                         ; preds = %land.lhs.true22, %if.end17
  %match_flags30 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %9 = load i16, i16* %match_flags30, align 8, !tbaa !270
  %conv31 = zext i16 %9 to i32
  %and32 = and i32 %conv31, 8
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %land.lhs.true34, label %if.end42

land.lhs.true34:                                  ; preds = %if.end29
  %bcdDevice_hi = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 4
  %10 = load i16, i16* %bcdDevice_hi, align 8, !tbaa !276
  %conv35 = zext i16 %10 to i32
  %descriptor36 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bcdDevice37 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor36, i32 0, i32 9
  %11 = load i16, i16* %bcdDevice37, align 4, !tbaa !275
  %conv38 = zext i16 %11 to i32
  %cmp39 = icmp slt i32 %conv35, %conv38
  br i1 %cmp39, label %return, label %if.end42

if.end42:                                         ; preds = %land.lhs.true34, %if.end29
  %match_flags43 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %12 = load i16, i16* %match_flags43, align 8, !tbaa !270
  %conv44 = zext i16 %12 to i32
  %and45 = and i32 %conv44, 16
  %tobool46 = icmp ne i32 %and45, 0
  br i1 %tobool46, label %land.lhs.true47, label %if.end55

land.lhs.true47:                                  ; preds = %if.end42
  %bDeviceClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 5
  %13 = load i8, i8* %bDeviceClass, align 2, !tbaa !277
  %conv48 = zext i8 %13 to i32
  %descriptor49 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bDeviceClass50 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor49, i32 0, i32 3
  %14 = load i8, i8* %bDeviceClass50, align 4, !tbaa !278
  %conv51 = zext i8 %14 to i32
  %cmp52 = icmp ne i32 %conv48, %conv51
  br i1 %cmp52, label %return, label %if.end55

if.end55:                                         ; preds = %land.lhs.true47, %if.end42
  %match_flags56 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %15 = load i16, i16* %match_flags56, align 8, !tbaa !270
  %conv57 = zext i16 %15 to i32
  %and58 = and i32 %conv57, 32
  %tobool59 = icmp ne i32 %and58, 0
  br i1 %tobool59, label %land.lhs.true60, label %if.end68

land.lhs.true60:                                  ; preds = %if.end55
  %bDeviceSubClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 6
  %16 = load i8, i8* %bDeviceSubClass, align 1, !tbaa !279
  %conv61 = zext i8 %16 to i32
  %descriptor62 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bDeviceSubClass63 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor62, i32 0, i32 4
  %17 = load i8, i8* %bDeviceSubClass63, align 1, !tbaa !280
  %conv64 = zext i8 %17 to i32
  %cmp65 = icmp ne i32 %conv61, %conv64
  br i1 %cmp65, label %return, label %if.end68

if.end68:                                         ; preds = %land.lhs.true60, %if.end55
  %match_flags69 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %18 = load i16, i16* %match_flags69, align 8, !tbaa !270
  %conv70 = zext i16 %18 to i32
  %and71 = and i32 %conv70, 64
  %tobool72 = icmp ne i32 %and71, 0
  br i1 %tobool72, label %land.lhs.true73, label %if.end81

land.lhs.true73:                                  ; preds = %if.end68
  %bDeviceProtocol = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 7
  %19 = load i8, i8* %bDeviceProtocol, align 4, !tbaa !281
  %conv74 = zext i8 %19 to i32
  %descriptor75 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bDeviceProtocol76 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor75, i32 0, i32 5
  %20 = load i8, i8* %bDeviceProtocol76, align 2, !tbaa !205
  %conv77 = zext i8 %20 to i32
  %cmp78 = icmp ne i32 %conv74, %conv77
  br i1 %cmp78, label %return, label %if.end81

if.end81:                                         ; preds = %land.lhs.true73, %if.end68
  br label %return

return:                                           ; preds = %if.end81, %land.lhs.true73, %land.lhs.true60, %land.lhs.true47, %land.lhs.true34, %land.lhs.true22, %land.lhs.true9, %land.lhs.true
  %retval.0 = phi i32 [ 1, %if.end81 ], [ 0, %land.lhs.true ], [ 0, %land.lhs.true9 ], [ 0, %land.lhs.true22 ], [ 0, %land.lhs.true34 ], [ 0, %land.lhs.true47 ], [ 0, %land.lhs.true60 ], [ 0, %land.lhs.true73 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_match_one_id_intf(%struct.usb_device* %dev, %struct.usb_host_interface* %intf, %struct.usb_device_id* %id) #0 {
entry:
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bDeviceClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 3
  %0 = load i8, i8* %bDeviceClass, align 4, !tbaa !278
  %conv = zext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 255
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %match_flags = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %1 = load i16, i16* %match_flags, align 8, !tbaa !270
  %conv2 = zext i16 %1 to i32
  %and = and i32 %conv2, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %land.lhs.true
  %match_flags4 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %2 = load i16, i16* %match_flags4, align 8, !tbaa !270
  %conv5 = zext i16 %2 to i32
  %and6 = and i32 %conv5, 1920
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %return, label %if.end

if.end:                                           ; preds = %land.lhs.true3, %land.lhs.true, %entry
  %match_flags8 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %3 = load i16, i16* %match_flags8, align 8, !tbaa !270
  %conv9 = zext i16 %3 to i32
  %and10 = and i32 %conv9, 128
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %land.lhs.true12, label %if.end19

land.lhs.true12:                                  ; preds = %if.end
  %bInterfaceClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 8
  %4 = load i8, i8* %bInterfaceClass, align 1, !tbaa !535
  %conv13 = zext i8 %4 to i32
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %intf, i32 0, i32 0
  %bInterfaceClass14 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 5
  %5 = load i8, i8* %bInterfaceClass14, align 1, !tbaa !482
  %conv15 = zext i8 %5 to i32
  %cmp16 = icmp ne i32 %conv13, %conv15
  br i1 %cmp16, label %return, label %if.end19

if.end19:                                         ; preds = %land.lhs.true12, %if.end
  %match_flags20 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %6 = load i16, i16* %match_flags20, align 8, !tbaa !270
  %conv21 = zext i16 %6 to i32
  %and22 = and i32 %conv21, 256
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %land.lhs.true24, label %if.end32

land.lhs.true24:                                  ; preds = %if.end19
  %bInterfaceSubClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 9
  %7 = load i8, i8* %bInterfaceSubClass, align 2, !tbaa !536
  %conv25 = zext i8 %7 to i32
  %desc26 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %intf, i32 0, i32 0
  %bInterfaceSubClass27 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc26, i32 0, i32 6
  %8 = load i8, i8* %bInterfaceSubClass27, align 2, !tbaa !286
  %conv28 = zext i8 %8 to i32
  %cmp29 = icmp ne i32 %conv25, %conv28
  br i1 %cmp29, label %return, label %if.end32

if.end32:                                         ; preds = %land.lhs.true24, %if.end19
  %match_flags33 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %9 = load i16, i16* %match_flags33, align 8, !tbaa !270
  %conv34 = zext i16 %9 to i32
  %and35 = and i32 %conv34, 512
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %land.lhs.true37, label %if.end45

land.lhs.true37:                                  ; preds = %if.end32
  %bInterfaceProtocol = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 10
  %10 = load i8, i8* %bInterfaceProtocol, align 1, !tbaa !537
  %conv38 = zext i8 %10 to i32
  %desc39 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %intf, i32 0, i32 0
  %bInterfaceProtocol40 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc39, i32 0, i32 7
  %11 = load i8, i8* %bInterfaceProtocol40, align 1, !tbaa !483
  %conv41 = zext i8 %11 to i32
  %cmp42 = icmp ne i32 %conv38, %conv41
  br i1 %cmp42, label %return, label %if.end45

if.end45:                                         ; preds = %land.lhs.true37, %if.end32
  %match_flags46 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %12 = load i16, i16* %match_flags46, align 8, !tbaa !270
  %conv47 = zext i16 %12 to i32
  %and48 = and i32 %conv47, 1024
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool49, label %land.lhs.true50, label %if.end58

land.lhs.true50:                                  ; preds = %if.end45
  %bInterfaceNumber = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 11
  %13 = load i8, i8* %bInterfaceNumber, align 8, !tbaa !538
  %conv51 = zext i8 %13 to i32
  %desc52 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %intf, i32 0, i32 0
  %bInterfaceNumber53 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc52, i32 0, i32 2
  %14 = load i8, i8* %bInterfaceNumber53, align 2, !tbaa !106
  %conv54 = zext i8 %14 to i32
  %cmp55 = icmp ne i32 %conv51, %conv54
  br i1 %cmp55, label %return, label %if.end58

if.end58:                                         ; preds = %land.lhs.true50, %if.end45
  br label %return

return:                                           ; preds = %if.end58, %land.lhs.true50, %land.lhs.true37, %land.lhs.true24, %land.lhs.true12, %land.lhs.true3
  %retval.0 = phi i32 [ 1, %if.end58 ], [ 0, %land.lhs.true3 ], [ 0, %land.lhs.true12 ], [ 0, %land.lhs.true24 ], [ 0, %land.lhs.true37 ], [ 0, %land.lhs.true50 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_autopm_get_interface_no_resume(%struct.usb_interface* %intf) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev.321(%struct.usb_interface* %intf)
  call void @usb_mark_last_busy.335(%struct.usb_device* %call)
  %pm_usage_cnt = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 9
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %pm_usage_cnt, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !539
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @pm_runtime_get_noresume.337(%struct.device* %dev)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_mark_last_busy.335(%struct.usb_device* %udev) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_mark_last_busy.338(%struct.device* %dev)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_get_noresume.337(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %usage_count = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 12
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %usage_count, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !539
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_mark_last_busy.338(%struct.device* %dev) #1 {
entry:
  %0 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %last_busy = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 20
  store volatile i64 %0, i64* %last_busy, align 8, !tbaa !53
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_autopm_get_interface_async(%struct.usb_interface* %intf) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i32 @pm_runtime_get(%struct.device* %dev)
  %cmp = icmp slt i32 %call, 0
  %cmp1 = icmp ne i32 %call, -115
  %or.cond = and i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %dev2 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @pm_runtime_put_noidle.339(%struct.device* %dev2)
  br label %if.end

if.else:                                          ; preds = %entry
  %pm_usage_cnt = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 9
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %pm_usage_cnt, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !539
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %cmp3 = icmp sgt i32 %call, 0
  %cmp4 = icmp eq i32 %call, -115
  %or.cond1 = or i1 %cmp3, %cmp4
  %status.0 = select i1 %or.cond1, i32 0, i32 %call
  ret i32 %status.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pm_runtime_get(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_resume(%struct.device* %dev, i32 5)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put_noidle.339(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %usage_count = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 12
  call void @atomic_add_unless.340(%struct.atomic_t* %usage_count, i32 -1, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_add_unless.340(%struct.atomic_t* %v, i32 %a, i32 %u) #1 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %0 = load volatile i32, i32* %counter.i, align 4, !tbaa !73
  %1 = bitcast i8* %arraydecay.i to i32*
  store i32 %0, i32* %1, align 4, !tbaa !73
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %2 = load i32, i32* %__val.i, align 4, !tbaa !72
  br label %for.cond.i

for.cond.i:                                       ; preds = %if.end13.i, %entry
  %c.0.i = phi i32 [ %2, %entry ], [ %3, %if.end13.i ]
  %cmp.i = icmp eq i32 %c.0.i, %u
  %lnot.ext.i = zext i1 %cmp.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv.i, i64 0) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %__atomic_add_unless.341.exit, label %if.end.i

if.end.i:                                         ; preds = %for.cond.i
  %add.i = add nsw i32 %c.0.i, %a
  %counter.i1 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %3 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; cmpxchgl $2,$1", "={ax},=*m,r,0,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter.i1, i32 %add.i, i32 %c.0.i, i32* %counter.i1) #8, !srcloc !540
  %cmp3.i = icmp eq i32 %3, %c.0.i
  %lnot.ext8.i = zext i1 %cmp3.i to i32
  %conv9.i = sext i32 %lnot.ext8.i to i64
  %expval10.i = call i64 @llvm.expect.i64(i64 %conv9.i, i64 1) #8
  %tobool11.i = icmp ne i64 %expval10.i, 0
  br i1 %tobool11.i, label %__atomic_add_unless.341.exit, label %if.end13.i

if.end13.i:                                       ; preds = %if.end.i
  br label %for.cond.i

__atomic_add_unless.341.exit:                     ; preds = %if.end.i, %for.cond.i
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_autopm_get_interface(%struct.usb_interface* %intf) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i32 @pm_runtime_get_sync.347(%struct.device* %dev)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %dev1 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @pm_runtime_put_sync.348(%struct.device* %dev1)
  br label %if.end

if.else:                                          ; preds = %entry
  %pm_usage_cnt = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 9
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %pm_usage_cnt, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !539
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %cmp3 = icmp sgt i32 %call, 0
  %.call = select i1 %cmp3, i32 0, i32 %call
  ret i32 %.call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pm_runtime_get_sync.347(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_resume(%struct.device* %dev, i32 4)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put_sync.348(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_idle(%struct.device* %dev, i32 4)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_autopm_put_interface_no_suspend(%struct.usb_interface* %intf) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev.321(%struct.usb_interface* %intf)
  call void @usb_mark_last_busy.335(%struct.usb_device* %call)
  %pm_usage_cnt = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 9
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %pm_usage_cnt, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !541
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @pm_runtime_put_noidle.339(%struct.device* %dev)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_autopm_put_interface_async(%struct.usb_interface* %intf) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev.321(%struct.usb_interface* %intf)
  call void @usb_mark_last_busy.335(%struct.usb_device* %call)
  %pm_usage_cnt = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 9
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %pm_usage_cnt, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !541
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @pm_runtime_put.354(%struct.device* %dev)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put.354(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_idle(%struct.device* %dev, i32 5)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_autopm_put_interface(%struct.usb_interface* %intf) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev.321(%struct.usb_interface* %intf)
  call void @usb_mark_last_busy.335(%struct.usb_device* %call)
  %pm_usage_cnt = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 9
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %pm_usage_cnt, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !541
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @pm_runtime_put_sync.348(%struct.device* %dev)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_disable_autosuspend(%struct.usb_device* %udev) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_forbid(%struct.device* %dev)
  ret void
}

declare void @pm_runtime_forbid(%struct.device*) #2

; Function Attrs: nounwind uwtable
define void @usb_enable_autosuspend(%struct.usb_device* %udev) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_allow(%struct.device* %dev)
  ret void
}

declare void @pm_runtime_allow(%struct.device*) #2

; Function Attrs: nounwind uwtable
define void @usb_deregister(%struct.usb_driver* %driver) #0 {
entry:
  %0 = call i32 (i8*, ...) @printk(i8* null)
  call void @usb_remove_newid_files(%struct.usb_driver* %driver)
  %drvwrap = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver, i32 0, i32 11
  %driver1 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 0
  call void @driver_unregister(%struct.device_driver* %driver1)
  call void @usb_free_dynids(%struct.usb_driver* %driver)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usb_remove_newid_files(%struct.usb_driver* %usb_drv) #0 {
entry:
  %no_dynamic_id = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 12
  %bf.load = load i8, i8* %no_dynamic_id, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end4, label %if.end

if.end:                                           ; preds = %entry
  %probe = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 1
  %0 = load i32 (%struct.usb_interface*, %struct.usb_device_id*)*, i32 (%struct.usb_interface*, %struct.usb_device_id*)** %probe, align 8, !tbaa !542
  %cmp = icmp ne i32 (%struct.usb_interface*, %struct.usb_device_id*)* %0, null
  br i1 %cmp, label %if.then1, label %if.end4

if.then1:                                         ; preds = %if.end
  %drvwrap = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 11
  %driver = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 0
  call void @driver_remove_file(%struct.device_driver* %driver, %struct.driver_attribute* @driver_attr_remove_id)
  %drvwrap2 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 11
  %driver3 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap2, i32 0, i32 0
  call void @driver_remove_file(%struct.device_driver* %driver3, %struct.driver_attribute* @driver_attr_new_id)
  br label %if.end4

if.end4:                                          ; preds = %if.then1, %if.end, %entry
  ret void
}

declare void @driver_unregister(%struct.device_driver*) #2

; Function Attrs: nounwind uwtable
define internal void @usb_free_dynids(%struct.usb_driver* %usb_drv) #0 {
entry:
  %dynids = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 10
  %lock = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 0
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock.i) #8
  %dynids1 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 10
  %list = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids1, i32 0, i32 1
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !252
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.usb_dynid*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %.sink = phi %struct.usb_dynid* [ %6, %for.body ], [ %3, %entry ]
  %dynid.0 = phi %struct.usb_dynid* [ %3, %entry ], [ %6, %for.body ]
  %node11 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %.sink, i32 0, i32 0
  %next12 = getelementptr inbounds %struct.list_head, %struct.list_head* %node11, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next12, align 8, !tbaa !543
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr14 = getelementptr inbounds i8, i8* %5, i64 0
  %6 = bitcast i8* %add.ptr14 to %struct.usb_dynid*
  %node6 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %dynid.0, i32 0, i32 0
  %dynids7 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 10
  %list8 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids7, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %node6, %list8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %node9 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %dynid.0, i32 0, i32 0
  call void @list_del.364(%struct.list_head* %node9)
  %7 = bitcast %struct.usb_dynid* %dynid.0 to i8*
  call void @kfree(i8* %7)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %dynids15 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 10
  %lock16 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids15, i32 0, i32 0
  %8 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock16, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %8 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock.i1) #8
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del.364(%struct.list_head* %entry1) #1 {
entry:
  call void @__list_del_entry.365(%struct.list_head* %entry1)
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8, !tbaa !252
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8, !tbaa !87
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry.365(%struct.list_head* %entry1) #1 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !87
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !252
  call void @__list_del.366(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del.366(%struct.list_head* %prev, %struct.list_head* %next) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !87
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !72
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  ret void
}

declare void @driver_remove_file(%struct.device_driver*, %struct.driver_attribute*) #2

; Function Attrs: nounwind uwtable
define internal i64 @new_id_show(%struct.device_driver* %driver, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_driver* %driver to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -168
  %1 = bitcast i8* %add.ptr to %struct.usb_driver*
  %dynids = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %1, i32 0, i32 10
  %call = call i64 @usb_show_dynids(%struct.__wait_queue_head* %dynids, i8* %buf)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @new_id_store(%struct.device_driver* %driver, i8* %buf, i64 %count) #0 {
entry:
  %0 = bitcast %struct.device_driver* %driver to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -168
  %1 = bitcast i8* %add.ptr to %struct.usb_driver*
  %dynids = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %1, i32 0, i32 10
  %id_table = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %1, i32 0, i32 9
  %2 = load %struct.usb_device_id*, %struct.usb_device_id** %id_table, align 8, !tbaa !533
  %call = call i64 @usb_store_new_id(%struct.__wait_queue_head* %dynids, %struct.usb_device_id* %2, %struct.device_driver* %driver, i8* %buf, i64 %count)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @usb_store_new_id(%struct.__wait_queue_head* %dynids, %struct.usb_device_id* %id_table, %struct.device_driver* %driver, i8* %buf, i64 %count) #0 {
entry:
  %idVendor = alloca i32, align 4
  %idProduct = alloca i32, align 4
  %bInterfaceClass = alloca i32, align 4
  %refVendor = alloca i32, align 4
  %refProduct = alloca i32, align 4
  store i32 0, i32* %idVendor, align 4, !tbaa !73
  store i32 0, i32* %idProduct, align 4, !tbaa !73
  store i32 0, i32* %bInterfaceClass, align 4, !tbaa !73
  %call = call i32 (i8*, i8*, ...) @sscanf(i8* %buf, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.369, i32 0, i32 0), i32* %idVendor, i32* %idProduct, i32* %bInterfaceClass, i32* %refVendor, i32* %refProduct)
  %cmp = icmp slt i32 %call, 2
  br i1 %cmp, label %cleanup61, label %if.end

if.end:                                           ; preds = %entry
  %call2 = call i8* @kzalloc.370(i64 48, i32 20971712)
  %0 = bitcast i8* %call2 to %struct.usb_dynid*
  %tobool = icmp ne %struct.usb_dynid* %0, null
  br i1 %tobool, label %if.end4, label %cleanup61

if.end4:                                          ; preds = %if.end
  %node = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %0, i32 0, i32 0
  call void @INIT_LIST_HEAD.371(%struct.list_head* %node)
  %1 = load i32, i32* %idVendor, align 4, !tbaa !73
  %conv = trunc i32 %1 to i16
  %id = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %0, i32 0, i32 1
  %idVendor5 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 1
  store i16 %conv, i16* %idVendor5, align 2, !tbaa !545
  %2 = load i32, i32* %idProduct, align 4, !tbaa !73
  %conv6 = trunc i32 %2 to i16
  %id7 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %0, i32 0, i32 1
  %idProduct8 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id7, i32 0, i32 2
  store i16 %conv6, i16* %idProduct8, align 4, !tbaa !546
  %id9 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %0, i32 0, i32 1
  %match_flags = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id9, i32 0, i32 0
  store i16 3, i16* %match_flags, align 8, !tbaa !547
  %cmp10 = icmp sgt i32 %call, 2
  %3 = load i32, i32* %bInterfaceClass, align 4
  %tobool12 = icmp ne i32 %3, 0
  %or.cond = and i1 %cmp10, %tobool12
  br i1 %or.cond, label %if.then13, label %if.end25

if.then13:                                        ; preds = %if.end4
  %4 = load i32, i32* %bInterfaceClass, align 4, !tbaa !73
  %cmp14 = icmp ugt i32 %4, 255
  br i1 %cmp14, label %fail, label %if.end17

if.end17:                                         ; preds = %if.then13
  %5 = load i32, i32* %bInterfaceClass, align 4, !tbaa !73
  %conv18 = trunc i32 %5 to i8
  %id19 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %0, i32 0, i32 1
  %bInterfaceClass20 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id19, i32 0, i32 8
  store i8 %conv18, i8* %bInterfaceClass20, align 1, !tbaa !548
  %id21 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %0, i32 0, i32 1
  %match_flags22 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id21, i32 0, i32 0
  %6 = load i16, i16* %match_flags22, align 8, !tbaa !547
  %conv23 = zext i16 %6 to i32
  %or = or i32 %conv23, 128
  %conv24 = trunc i32 %or to i16
  store i16 %conv24, i16* %match_flags22, align 8, !tbaa !547
  br label %if.end25

if.end25:                                         ; preds = %if.end17, %if.end4
  %cmp26 = icmp sgt i32 %call, 4
  br i1 %cmp26, label %if.then28, label %if.end52

if.then28:                                        ; preds = %if.end25
  %tobool30 = icmp ne %struct.usb_device_id* %id_table, null
  br i1 %tobool30, label %if.end32, label %NodeBlock

if.end32:                                         ; preds = %if.then28
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end32
  %id29.0 = phi %struct.usb_device_id* [ %id_table, %if.end32 ], [ %incdec.ptr, %for.inc ]
  %match_flags33 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id29.0, i32 0, i32 0
  %7 = load i16, i16* %match_flags33, align 8, !tbaa !270
  %tobool34 = icmp ne i16 %7, 0
  br i1 %tobool34, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idVendor35 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id29.0, i32 0, i32 1
  %8 = load i16, i16* %idVendor35, align 2, !tbaa !272
  %conv36 = zext i16 %8 to i32
  %9 = load i32, i32* %refVendor, align 4, !tbaa !73
  %cmp37 = icmp eq i32 %conv36, %9
  br i1 %cmp37, label %land.lhs.true39, label %for.inc

land.lhs.true39:                                  ; preds = %for.body
  %idProduct40 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id29.0, i32 0, i32 2
  %10 = load i16, i16* %idProduct40, align 4, !tbaa !273
  %conv41 = zext i16 %10 to i32
  %11 = load i32, i32* %refProduct, align 4, !tbaa !73
  %cmp42 = icmp eq i32 %conv41, %11
  br i1 %cmp42, label %for.end, label %for.inc

for.inc:                                          ; preds = %land.lhs.true39, %for.body
  %incdec.ptr = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id29.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %land.lhs.true39, %for.cond
  %match_flags46 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id29.0, i32 0, i32 0
  %12 = load i16, i16* %match_flags46, align 8, !tbaa !270
  %tobool47 = icmp ne i16 %12, 0
  br i1 %tobool47, label %if.then48, label %NodeBlock

if.then48:                                        ; preds = %for.end
  %driver_info = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id29.0, i32 0, i32 12
  %13 = load i64, i64* %driver_info, align 8, !tbaa !292
  %id49 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %0, i32 0, i32 1
  %driver_info50 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id49, i32 0, i32 12
  store i64 %13, i64* %driver_info50, align 8, !tbaa !549
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.then48, %for.end, %if.then28
  %retval1.0 = phi i32 [ 0, %if.then48 ], [ -19, %if.then28 ], [ -19, %for.end ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.then48 ], [ 2, %if.then28 ], [ 2, %for.end ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf2, label %fail, label %cleanup61

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end52, label %cleanup61

if.end52:                                         ; preds = %LeafBlock, %if.end25
  %lock = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 0
  %14 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %14 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock.i) #8
  %node53 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %0, i32 0, i32 0
  %list = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 1
  call void @list_add_tail.372(%struct.list_head* %node53, %struct.list_head* %list)
  %lock54 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 0
  %15 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock54, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %15 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock.i1) #8
  %call55 = call i32 @driver_attach(%struct.device_driver* %driver)
  %tobool56 = icmp ne i32 %call55, 0
  %conv58 = sext i32 %call55 to i64
  %conv58.count = select i1 %tobool56, i64 %conv58, i64 %count
  br label %cleanup61

fail:                                             ; preds = %LeafBlock1, %if.then13
  %retval1.1 = phi i32 [ %retval1.0, %LeafBlock1 ], [ -22, %if.then13 ]
  %16 = bitcast %struct.usb_dynid* %0 to i8*
  call void @kfree(i8* %16)
  %conv60 = sext i32 %retval1.1 to i64
  br label %cleanup61

cleanup61:                                        ; preds = %fail, %if.end52, %LeafBlock, %LeafBlock1, %if.end, %entry
  %retval.0 = phi i64 [ %conv60, %fail ], [ -22, %entry ], [ -12, %if.end ], [ undef, %LeafBlock1 ], [ undef, %LeafBlock ], [ %conv58.count, %if.end52 ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.370(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call noalias i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.371(%struct.list_head* %list) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !72
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !87
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.372(%struct.list_head* %new, %struct.list_head* %head) #1 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !87
  call void @__list_add.373(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

declare i32 @driver_attach(%struct.device_driver*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add.373(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !87
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !252
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !87
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !72
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @usb_show_dynids(%struct.__wait_queue_head* %dynids, i8* %buf) #0 {
entry:
  %list = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 1
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %node24.sink = phi %struct.list_head* [ %node24, %if.end ], [ %list, %entry ]
  %count.0 = phi i64 [ 0, %entry ], [ %add22, %if.end ]
  %next25 = getelementptr inbounds %struct.list_head, %struct.list_head* %node24.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next25, align 8, !tbaa !52
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr27 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr27 to %struct.usb_dynid*
  %node = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %2, i32 0, i32 0
  %list1 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %node, %list1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %id = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %2, i32 0, i32 1
  %bInterfaceClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 8
  %3 = load i8, i8* %bInterfaceClass, align 1, !tbaa !548
  %conv = zext i8 %3 to i32
  %cmp2 = icmp ne i32 %conv, 0
  %arrayidx = getelementptr inbounds i8, i8* %buf, i64 %count.0
  %sub = sub i64 4096, %count.0
  %id4 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %2, i32 0, i32 1
  %idVendor = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id4, i32 0, i32 1
  %4 = load i16, i16* %idVendor, align 2, !tbaa !545
  %conv5 = zext i16 %4 to i32
  %id6 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %2, i32 0, i32 1
  %idProduct = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id6, i32 0, i32 2
  %5 = load i16, i16* %idProduct, align 4, !tbaa !546
  %conv7 = zext i16 %5 to i32
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %id8 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %2, i32 0, i32 1
  %bInterfaceClass9 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id8, i32 0, i32 8
  %6 = load i8, i8* %bInterfaceClass9, align 1, !tbaa !548
  %conv10 = zext i8 %6 to i32
  %call = call i32 (i8*, i64, i8*, ...) @scnprintf(i8* %arrayidx, i64 %sub, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.1.375, i32 0, i32 0), i32 %conv5, i32 %conv7, i32 %conv10)
  br label %if.end

if.else:                                          ; preds = %for.body
  %call20 = call i32 (i8*, i64, i8*, ...) @scnprintf(i8* %arrayidx, i64 %sub, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.2.376, i32 0, i32 0), i32 %conv5, i32 %conv7)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %call20.sink = phi i32 [ %call20, %if.else ], [ %call, %if.then ]
  %conv21 = sext i32 %call20.sink to i64
  %add22 = add i64 %count.0, %conv21
  %node24 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %2, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret i64 %count.0
}

declare i32 @scnprintf(i8*, i64, i8*, ...) #2

; Function Attrs: nounwind uwtable
define internal i64 @remove_id_show(%struct.device_driver* %driver, i8* %buf) #0 {
entry:
  %call = call i64 @new_id_show(%struct.device_driver* %driver, i8* %buf)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @remove_id_store(%struct.device_driver* %driver, i8* %buf, i64 %count) #0 {
entry:
  %idVendor = alloca i32, align 4
  %idProduct = alloca i32, align 4
  %0 = bitcast %struct.device_driver* %driver to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -168
  %1 = bitcast i8* %add.ptr to %struct.usb_driver*
  %call = call i32 (i8*, i8*, ...) @sscanf(i8* %buf, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.22.378, i32 0, i32 0), i32* %idVendor, i32* %idProduct)
  %cmp = icmp slt i32 %call, 2
  br i1 %cmp, label %cleanup31, label %if.end

if.end:                                           ; preds = %entry
  %dynids = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %1, i32 0, i32 10
  %lock = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 0
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock.i) #8
  %dynids2 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %1, i32 0, i32 10
  %list = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids2, i32 0, i32 1
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !252
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr4 = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr4 to %struct.usb_dynid*
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %.sink = phi %struct.usb_dynid* [ %8, %for.inc ], [ %5, %if.end ]
  %dynid.0 = phi %struct.usb_dynid* [ %5, %if.end ], [ %8, %for.inc ]
  %node25 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %.sink, i32 0, i32 0
  %next26 = getelementptr inbounds %struct.list_head, %struct.list_head* %node25, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next26, align 8, !tbaa !543
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr28 = getelementptr inbounds i8, i8* %7, i64 0
  %8 = bitcast i8* %add.ptr28 to %struct.usb_dynid*
  %node9 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %dynid.0, i32 0, i32 0
  %dynids10 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %1, i32 0, i32 10
  %list11 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids10, i32 0, i32 1
  %cmp12 = icmp ne %struct.list_head* %node9, %list11
  br i1 %cmp12, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %id13 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %dynid.0, i32 0, i32 1
  %idVendor14 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id13, i32 0, i32 1
  %9 = load i16, i16* %idVendor14, align 2, !tbaa !272
  %conv = zext i16 %9 to i32
  %10 = load i32, i32* %idVendor, align 4, !tbaa !73
  %cmp15 = icmp eq i32 %conv, %10
  br i1 %cmp15, label %land.lhs.true, label %LeafBlock

land.lhs.true:                                    ; preds = %for.body
  %idProduct17 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id13, i32 0, i32 2
  %11 = load i16, i16* %idProduct17, align 4, !tbaa !273
  %conv18 = zext i16 %11 to i32
  %12 = load i32, i32* %idProduct, align 4, !tbaa !73
  %cmp19 = icmp eq i32 %conv18, %12
  br i1 %cmp19, label %if.then21, label %LeafBlock

if.then21:                                        ; preds = %land.lhs.true
  %node22 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %dynid.0, i32 0, i32 0
  call void @list_del.364(%struct.list_head* %node22)
  %13 = bitcast %struct.usb_dynid* %dynid.0 to i8*
  call void @kfree(i8* %13)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.then21, %land.lhs.true, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 2, %if.then21 ], [ 0, %land.lhs.true ], [ 0, %for.body ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf, label %for.end, label %for.inc

for.inc:                                          ; preds = %LeafBlock
  br label %for.cond

for.end:                                          ; preds = %LeafBlock, %for.cond
  %dynids29 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %1, i32 0, i32 10
  %lock30 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids29, i32 0, i32 0
  %14 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock30, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %14 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock.i1) #8
  br label %cleanup31

cleanup31:                                        ; preds = %for.end, %entry
  %retval.0 = phi i64 [ %count, %for.end ], [ -22, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_register_driver(%struct.usb_driver* %new_driver, %struct.module* %owner, i8* %mod_name) #0 {
entry:
  %call = call i32 @usb_disabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %drvwrap = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %for_devices = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 1
  store i32 0, i32* %for_devices, align 8, !tbaa !550
  %name = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !551
  %drvwrap2 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %driver = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap2, i32 0, i32 0
  %name3 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver, i32 0, i32 0
  store i8* %0, i8** %name3, align 8, !tbaa !552
  %drvwrap4 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %driver5 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap4, i32 0, i32 0
  %bus = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver5, i32 0, i32 1
  store %struct.bus_type* @usb_bus_type, %struct.bus_type** %bus, align 8, !tbaa !553
  %drvwrap6 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %driver7 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap6, i32 0, i32 0
  %probe = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver7, i32 0, i32 8
  store i32 (%struct.device*)* @usb_probe_interface, i32 (%struct.device*)** %probe, align 8, !tbaa !554
  %drvwrap8 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %driver9 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap8, i32 0, i32 0
  %remove = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver9, i32 0, i32 9
  store i32 (%struct.device*)* @usb_unbind_interface, i32 (%struct.device*)** %remove, align 8, !tbaa !555
  %drvwrap10 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %driver11 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap10, i32 0, i32 0
  %owner12 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver11, i32 0, i32 2
  store %struct.module* %owner, %struct.module** %owner12, align 8, !tbaa !556
  %drvwrap13 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %driver14 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap13, i32 0, i32 0
  %mod_name15 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver14, i32 0, i32 3
  store i8* %mod_name, i8** %mod_name15, align 8, !tbaa !557
  %dynids18 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 10
  %lock19 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids18, i32 0, i32 0
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock19, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %1 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.7.382, i32 0, i32 0), %struct.lock_class_key* @usb_register_driver.__key)
  %dynids22 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 10
  %list = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids22, i32 0, i32 1
  call void @INIT_LIST_HEAD.371(%struct.list_head* %list)
  %drvwrap23 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %driver24 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap23, i32 0, i32 0
  %call25 = call i32 @driver_register(%struct.device_driver* %driver24)
  %tobool26 = icmp ne i32 %call25, 0
  br i1 %tobool26, label %cleanup, label %if.end28

if.end28:                                         ; preds = %if.end
  %call29 = call i32 @usb_create_newid_files(%struct.usb_driver* %new_driver)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %out_newid, label %if.end32

if.end32:                                         ; preds = %if.end28
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

out_newid:                                        ; preds = %if.end28
  %drvwrap35 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %driver36 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap35, i32 0, i32 0
  call void @driver_unregister(%struct.device_driver* %driver36)
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %out_newid, %if.end32, %if.end, %entry
  %retval.0 = phi i32 [ -19, %entry ], [ %call29, %out_newid ], [ %call29, %if.end32 ], [ %call25, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_probe_interface(%struct.device* %dev) #0 {
entry:
  %driver1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver1, align 8, !tbaa !95
  %1 = bitcast %struct.device_driver* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -168
  %2 = bitcast i8* %add.ptr to %struct.usb_driver*
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr4 = getelementptr inbounds i8, i8* %3, i64 -48
  %4 = bitcast i8* %add.ptr4 to %struct.usb_interface*
  %call = call %struct.usb_device* @interface_to_usbdev.321(%struct.usb_interface* %4)
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_probe_interface.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then, label %do.end9

if.then:                                          ; preds = %entry
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_probe_interface.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12.957, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.usb_probe_interface, i32 0, i32 0))
  br label %do.end9

do.end9:                                          ; preds = %if.then, %entry
  %needs_binding = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load10 = load i8, i8* %needs_binding, align 8
  %bf.clear11 = and i8 %bf.load10, -33
  store i8 %bf.clear11, i8* %needs_binding, align 8
  %call12 = call zeroext i1 @usb_device_is_owned(%struct.usb_device* %call)
  br i1 %call12, label %cleanup, label %if.end14

if.end14:                                         ; preds = %do.end9
  %authorized = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 22
  %bf.load15 = load i16, i16* %authorized, align 4
  %bf.lshr16 = lshr i16 %bf.load15, 3
  %bf.clear17 = and i16 %bf.lshr16, 1
  %bf.cast = zext i16 %bf.clear17 to i32
  %cmp = icmp eq i32 %bf.cast, 0
  br i1 %cmp, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end14
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.else:                                          ; preds = %if.end14
  %authorized21 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load22 = load i8, i8* %authorized21, align 8
  %bf.lshr23 = lshr i8 %bf.load22, 7
  %bf.cast24 = zext i8 %bf.lshr23 to i32
  %cmp25 = icmp eq i32 %bf.cast24, 0
  br i1 %cmp25, label %if.then27, label %if.end31

if.then27:                                        ; preds = %if.else
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end31:                                         ; preds = %if.else
  %call32 = call %struct.usb_device_id* @usb_match_dynamic_id(%struct.usb_interface* %4, %struct.usb_driver* %2)
  %tobool33 = icmp ne %struct.usb_device_id* %call32, null
  br i1 %tobool33, label %if.end36, label %if.then34

if.then34:                                        ; preds = %if.end31
  %id_table = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 9
  %5 = load %struct.usb_device_id*, %struct.usb_device_id** %id_table, align 8, !tbaa !533
  %call35 = call %struct.usb_device_id* @usb_match_id(%struct.usb_interface* %4, %struct.usb_device_id* %5)
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.end31
  %id.0 = phi %struct.usb_device_id* [ %call32, %if.end31 ], [ %call35, %if.then34 ]
  %tobool37 = icmp ne %struct.usb_device_id* %id.0, null
  br i1 %tobool37, label %do.body41, label %cleanup

do.body41:                                        ; preds = %if.end36
  %bf.load42 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_probe_interface.descriptor.18 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr43 = lshr i32 %bf.load42, 18
  %bf.clear44 = and i32 %bf.lshr43, 255
  %and45 = and i32 %bf.clear44, 1
  %tobool46 = icmp ne i32 %and45, 0
  %lnot47 = xor i1 %tobool46, true
  %lnot49 = xor i1 %lnot47, true
  %lnot.ext50 = zext i1 %lnot49 to i32
  %conv51 = sext i32 %lnot.ext50 to i64
  %expval52 = call i64 @llvm.expect.i64(i64 %conv51, i64 0)
  %tobool53 = icmp ne i64 %expval52, 0
  br i1 %tobool53, label %if.then54, label %do.end59

if.then54:                                        ; preds = %do.body41
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_probe_interface.descriptor.18 to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.19.398, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.usb_probe_interface, i32 0, i32 0))
  br label %do.end59

do.end59:                                         ; preds = %if.then54, %do.body41
  %call60 = call i32 @usb_autoresume_device(%struct.usb_device* %call)
  %tobool61 = icmp ne i32 %call60, 0
  br i1 %tobool61, label %cleanup, label %if.end63

if.end63:                                         ; preds = %do.end59
  %condition = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 5
  store i32 1, i32* %condition, align 4, !tbaa !55
  call void @pm_runtime_set_active.399(%struct.device* %dev)
  call void @pm_suspend_ignore_children.400(%struct.device* %dev, i1 zeroext false)
  %supports_autosuspend = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 12
  %bf.load65 = load i8, i8* %supports_autosuspend, align 8
  %bf.lshr66 = lshr i8 %bf.load65, 1
  %bf.clear67 = and i8 %bf.lshr66, 1
  %bf.cast68 = zext i8 %bf.clear67 to i32
  %tobool69 = icmp ne i32 %bf.cast68, 0
  br i1 %tobool69, label %if.then70, label %if.end71

if.then70:                                        ; preds = %if.end63
  call void @pm_runtime_enable(%struct.device* %dev)
  br label %if.end71

if.end71:                                         ; preds = %if.then70, %if.end63
  %disable_hub_initiated_lpm = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 12
  %bf.load72 = load i8, i8* %disable_hub_initiated_lpm, align 8
  %bf.lshr73 = lshr i8 %bf.load72, 2
  %bf.clear74 = and i8 %bf.lshr73, 1
  %bf.cast75 = zext i8 %bf.clear74 to i32
  %tobool76 = icmp ne i32 %bf.cast75, 0
  br i1 %tobool76, label %if.then77, label %if.end83

if.then77:                                        ; preds = %if.end71
  %call78 = call i32 @usb_unlocked_disable_lpm(%struct.usb_device* %call)
  %tobool79 = icmp ne i32 %call78, 0
  br i1 %tobool79, label %if.then80, label %if.end83

if.then80:                                        ; preds = %if.then77
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %err

if.end83:                                         ; preds = %if.then77, %if.end71
  %lpm_disable_error.0 = phi i32 [ -19, %if.end71 ], [ %call78, %if.then77 ]
  %needs_altsetting0 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load84 = load i8, i8* %needs_altsetting0, align 8
  %bf.lshr85 = lshr i8 %bf.load84, 4
  %bf.clear86 = and i8 %bf.lshr85, 1
  %bf.cast87 = zext i8 %bf.clear86 to i32
  %tobool88 = icmp ne i32 %bf.cast87, 0
  br i1 %tobool88, label %if.then89, label %if.end102

if.then89:                                        ; preds = %if.end83
  %altsetting90 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 0
  %6 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting90, align 8, !tbaa !98
  %arrayidx = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %6, i64 0
  %desc91 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bInterfaceNumber92 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc91, i32 0, i32 2
  %7 = load i8, i8* %bInterfaceNumber92, align 2, !tbaa !106
  %conv93 = zext i8 %7 to i32
  %call94 = call i32 @usb_set_interface(%struct.usb_device* %call, i32 %conv93, i32 0)
  %cmp95 = icmp slt i32 %call94, 0
  br i1 %cmp95, label %err, label %if.end98

if.end98:                                         ; preds = %if.then89
  %needs_altsetting099 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load100 = load i8, i8* %needs_altsetting099, align 8
  %bf.clear101 = and i8 %bf.load100, -17
  store i8 %bf.clear101, i8* %needs_altsetting099, align 8
  br label %if.end102

if.end102:                                        ; preds = %if.end98, %if.end83
  %probe = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 1
  %8 = load i32 (%struct.usb_interface*, %struct.usb_device_id*)*, i32 (%struct.usb_interface*, %struct.usb_device_id*)** %probe, align 8, !tbaa !542
  %call103 = call i32 %8(%struct.usb_interface* %4, %struct.usb_device_id* %id.0)
  %tobool104 = icmp ne i32 %call103, 0
  br i1 %tobool104, label %err, label %if.end106

if.end106:                                        ; preds = %if.end102
  %condition107 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 5
  store i32 2, i32* %condition107, align 4, !tbaa !55
  %tobool108 = icmp ne i32 %lpm_disable_error.0, 0
  br i1 %tobool108, label %if.end110, label %if.then109

if.then109:                                       ; preds = %if.end106
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %call)
  br label %if.end110

if.end110:                                        ; preds = %if.then109, %if.end106
  call void @usb_autosuspend_device(%struct.usb_device* %call)
  br label %cleanup

err:                                              ; preds = %if.end102, %if.then89, %if.then80
  %error.0 = phi i32 [ %call78, %if.then80 ], [ %call94, %if.then89 ], [ %call103, %if.end102 ]
  %lpm_disable_error.1 = phi i32 [ %call78, %if.then80 ], [ %lpm_disable_error.0, %if.then89 ], [ %lpm_disable_error.0, %if.end102 ]
  call void @usb_set_intfdata.387(%struct.usb_interface* %4, i8* null)
  %needs_remote_wakeup = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load111 = load i8, i8* %needs_remote_wakeup, align 8
  %bf.clear112 = and i8 %bf.load111, -9
  store i8 %bf.clear112, i8* %needs_remote_wakeup, align 8
  %condition113 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 5
  store i32 0, i32* %condition113, align 4, !tbaa !55
  %tobool114 = icmp ne i32 %lpm_disable_error.1, 0
  br i1 %tobool114, label %if.end116, label %if.then115

if.then115:                                       ; preds = %err
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %call)
  br label %if.end116

if.end116:                                        ; preds = %if.then115, %err
  %supports_autosuspend117 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 12
  %bf.load118 = load i8, i8* %supports_autosuspend117, align 8
  %bf.lshr119 = lshr i8 %bf.load118, 1
  %bf.clear120 = and i8 %bf.lshr119, 1
  %bf.cast121 = zext i8 %bf.clear120 to i32
  %tobool122 = icmp ne i32 %bf.cast121, 0
  br i1 %tobool122, label %if.then123, label %if.end124

if.then123:                                       ; preds = %if.end116
  call void @pm_runtime_disable.388(%struct.device* %dev)
  br label %if.end124

if.end124:                                        ; preds = %if.then123, %if.end116
  call void @pm_runtime_set_suspended.389(%struct.device* %dev)
  call void @usb_autosuspend_device(%struct.usb_device* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.end124, %if.end110, %do.end59, %if.end36, %if.then27, %if.then19, %do.end9
  %retval.0 = phi i32 [ -19, %if.then19 ], [ -19, %if.then27 ], [ %error.0, %if.end124 ], [ %call103, %if.end110 ], [ -19, %do.end9 ], [ -19, %if.end36 ], [ %call60, %do.end59 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_unbind_interface(%struct.device* %dev) #0 {
entry:
  %__u.i1 = alloca %struct.atomic_t, align 4
  %__u.i = alloca %struct.atomic_t, align 4
  %driver1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver1, align 8, !tbaa !95
  %1 = bitcast %struct.device_driver* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -168
  %2 = bitcast i8* %add.ptr to %struct.usb_driver*
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr4 = getelementptr inbounds i8, i8* %3, i64 -48
  %4 = bitcast i8* %add.ptr4 to %struct.usb_interface*
  %condition = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 5
  store i32 3, i32* %condition, align 4, !tbaa !55
  %call = call %struct.usb_device* @interface_to_usbdev.321(%struct.usb_interface* %4)
  %call5 = call i32 @usb_autoresume_device(%struct.usb_device* %call)
  %disable_hub_initiated_lpm = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 12
  %bf.load = load i8, i8* %disable_hub_initiated_lpm, align 8
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call6 = call i32 @usb_unlocked_disable_lpm(%struct.usb_device* %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %lpm_disable_error.0 = phi i32 [ %call6, %if.then ], [ -19, %entry ]
  %soft_unbind = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 12
  %bf.load7 = load i8, i8* %soft_unbind, align 8
  %bf.lshr8 = lshr i8 %bf.load7, 3
  %bf.clear9 = and i8 %bf.lshr8, 1
  %bf.cast10 = zext i8 %bf.clear9 to i32
  %tobool11 = icmp ne i32 %bf.cast10, 0
  br i1 %tobool11, label %lor.lhs.false, label %if.then12

lor.lhs.false:                                    ; preds = %if.end
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 3
  %5 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %5, 0
  br i1 %cmp, label %if.then12, label %if.end13

if.then12:                                        ; preds = %lor.lhs.false, %if.end
  call void @usb_disable_interface(%struct.usb_device* %call, %struct.usb_interface* %4, i1 zeroext false)
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %lor.lhs.false
  %disconnect = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 2
  %6 = load void (%struct.usb_interface*)*, void (%struct.usb_interface*)** %disconnect, align 8, !tbaa !558
  call void %6(%struct.usb_interface* %4)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end13
  %eps.0 = phi %struct.usb_host_endpoint** [ null, %if.end13 ], [ %eps.2, %for.inc ]
  %i.0 = phi i32 [ 0, %if.end13 ], [ %inc31, %for.inc ]
  %j.0 = phi i32 [ 0, %if.end13 ], [ %j.1, %for.inc ]
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 1
  %7 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !169
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %7, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 4
  %8 = load i8, i8* %bNumEndpoints, align 4, !tbaa !172
  %conv = zext i8 %8 to i32
  %cmp14 = icmp slt i32 %i.0, %conv
  br i1 %cmp14, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %cur_altsetting16 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 1
  %9 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting16, align 8, !tbaa !169
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %9, i32 0, i32 3
  %10 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !173
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i64 %idxprom
  %streams = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 10
  %11 = load i32, i32* %streams, align 8, !tbaa !174
  %cmp17 = icmp eq i32 %11, 0
  br i1 %cmp17, label %for.inc, label %if.end20

if.end20:                                         ; preds = %for.body
  %cmp21 = icmp eq i32 %j.0, 0
  br i1 %cmp21, label %if.then23, label %if.end28

if.then23:                                        ; preds = %if.end20
  %call24 = call i8* @kmalloc_array(i64 30, i64 8, i32 20971712)
  %12 = bitcast i8* %call24 to %struct.usb_host_endpoint**
  %tobool25 = icmp ne %struct.usb_host_endpoint** %12, null
  br i1 %tobool25, label %if.end28, label %for.end

if.end28:                                         ; preds = %if.then23, %if.end20
  %eps.1 = phi %struct.usb_host_endpoint** [ %eps.0, %if.end20 ], [ %12, %if.then23 ]
  %inc = add nsw i32 %j.0, 1
  %idxprom29 = sext i32 %j.0 to i64
  %arrayidx30 = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %eps.1, i64 %idxprom29
  store %struct.usb_host_endpoint* %arrayidx, %struct.usb_host_endpoint** %arrayidx30, align 8, !tbaa !52
  br label %for.inc

for.inc:                                          ; preds = %if.end28, %for.body
  %eps.2 = phi %struct.usb_host_endpoint** [ %eps.1, %if.end28 ], [ %eps.0, %for.body ]
  %j.1 = phi i32 [ %inc, %if.end28 ], [ %j.0, %for.body ]
  %inc31 = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %if.then23, %for.cond
  %eps.3 = phi %struct.usb_host_endpoint** [ %12, %if.then23 ], [ %eps.0, %for.cond ]
  %tobool32 = icmp ne i32 %j.0, 0
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %for.end
  %call34 = call i32 @usb_free_streams(%struct.usb_interface* %4, %struct.usb_host_endpoint** %eps.3, i32 %j.0, i32 20971712)
  %13 = bitcast %struct.usb_host_endpoint** %eps.3 to i8*
  call void @kfree(i8* %13)
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %for.end
  %cur_altsetting36 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 1
  %14 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting36, align 8, !tbaa !169
  %desc37 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %14, i32 0, i32 0
  %bAlternateSetting = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc37, i32 0, i32 3
  %15 = load i8, i8* %bAlternateSetting, align 1, !tbaa !99
  %conv38 = zext i8 %15 to i32
  %cmp39 = icmp eq i32 %conv38, 0
  br i1 %cmp39, label %if.then41, label %if.else

if.then41:                                        ; preds = %if.end35
  call void @usb_enable_interface(%struct.usb_device* %call, %struct.usb_interface* %4, i1 zeroext false)
  br label %if.end65

if.else:                                          ; preds = %if.end35
  %tobool42 = icmp ne i32 %call5, 0
  br i1 %tobool42, label %if.end64.sink.split, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %dev43 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 7
  %power = getelementptr inbounds %struct.device, %struct.device* %dev43, i32 0, i32 11
  %is_prepared = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load44 = load i16, i16* %is_prepared, align 4
  %bf.lshr45 = lshr i16 %bf.load44, 3
  %bf.clear46 = and i16 %bf.lshr45, 1
  %bf.cast47 = trunc i16 %bf.clear46 to i1
  br i1 %bf.cast47, label %if.end64.sink.split, label %if.then48

if.then48:                                        ; preds = %land.lhs.true
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 0
  %16 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !98
  %arrayidx49 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %16, i64 0
  %desc50 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx49, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc50, i32 0, i32 2
  %17 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !106
  %conv51 = zext i8 %17 to i32
  %call52 = call i32 @usb_set_interface(%struct.usb_device* %call, i32 %conv51, i32 0)
  %cmp53 = icmp slt i32 %call52, 0
  br i1 %cmp53, label %if.end64.sink.split, label %if.end65

if.end64.sink.split:                              ; preds = %if.then48, %land.lhs.true, %if.else
  %needs_altsetting060 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load56 = load i8, i8* %needs_altsetting060, align 8
  %bf.clear57 = and i8 %bf.load56, -17
  %bf.set = or i8 %bf.clear57, 16
  store i8 %bf.set, i8* %needs_altsetting060, align 8
  br label %if.end65

if.end65:                                         ; preds = %if.end64.sink.split, %if.then48, %if.then41
  call void @usb_set_intfdata.387(%struct.usb_interface* %4, i8* null)
  %condition66 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 5
  store i32 0, i32* %condition66, align 4, !tbaa !55
  %needs_remote_wakeup = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load67 = load i8, i8* %needs_remote_wakeup, align 8
  %bf.clear68 = and i8 %bf.load67, -9
  store i8 %bf.clear68, i8* %needs_remote_wakeup, align 8
  %tobool69 = icmp ne i32 %lpm_disable_error.0, 0
  br i1 %tobool69, label %if.end71, label %if.then70

if.then70:                                        ; preds = %if.end65
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %call)
  br label %if.end71

if.end71:                                         ; preds = %if.then70, %if.end65
  %supports_autosuspend = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 12
  %bf.load72 = load i8, i8* %supports_autosuspend, align 8
  %bf.lshr73 = lshr i8 %bf.load72, 1
  %bf.clear74 = and i8 %bf.lshr73, 1
  %bf.cast75 = zext i8 %bf.clear74 to i32
  %tobool76 = icmp ne i32 %bf.cast75, 0
  br i1 %tobool76, label %if.then77, label %if.end78

if.then77:                                        ; preds = %if.end71
  call void @pm_runtime_disable.388(%struct.device* %dev)
  br label %if.end78

if.end78:                                         ; preds = %if.then77, %if.end71
  call void @pm_runtime_set_suspended.389(%struct.device* %dev)
  %pm_usage_cnt = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 9
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %pm_usage_cnt, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %18 = load volatile i32, i32* %counter.i, align 4, !tbaa !73
  %19 = bitcast i8* %arraydecay.i to i32*
  store i32 %18, i32* %19, align 4, !tbaa !73
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %20 = load i32, i32* %__val.i, align 4, !tbaa !72
  br label %for.cond81

for.cond81:                                       ; preds = %for.body84, %if.end78
  %r.0 = phi i32 [ %20, %if.end78 ], [ %dec, %for.body84 ]
  %cmp82 = icmp sgt i32 %r.0, 0
  br i1 %cmp82, label %for.body84, label %for.end86

for.body84:                                       ; preds = %for.cond81
  call void @usb_autopm_put_interface_no_suspend(%struct.usb_interface* %4)
  %dec = add nsw i32 %r.0, -1
  br label %for.cond81

for.end86:                                        ; preds = %for.cond81
  %pm_usage_cnt87 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 9
  %__val.i2 = bitcast %struct.atomic_t* %__u.i1 to i32*
  store i32 0, i32* %__val.i2, align 4, !tbaa !72
  %counter.i3 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %pm_usage_cnt87, i32 0, i32 0
  %__c.i4 = bitcast %struct.atomic_t* %__u.i1 to [1 x i8]*
  %arraydecay.i5 = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i4, i32 0, i32 0
  %21 = bitcast i8* %arraydecay.i5 to i32*
  %22 = load i32, i32* %21, align 4, !tbaa !73
  store volatile i32 %22, i32* %counter.i3, align 4, !tbaa !73
  %tobool88 = icmp ne i32 %call5, 0
  br i1 %tobool88, label %if.end90, label %if.then89

if.then89:                                        ; preds = %for.end86
  call void @usb_autosuspend_device(%struct.usb_device* %call)
  br label %if.end90

if.end90:                                         ; preds = %if.then89, %for.end86
  ret i32 0
}

declare i32 @driver_register(%struct.device_driver*) #2

; Function Attrs: nounwind uwtable
define internal i32 @usb_create_newid_files(%struct.usb_driver* %usb_drv) #0 {
entry:
  %no_dynamic_id = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 12
  %bf.load = load i8, i8* %no_dynamic_id, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %exit, label %if.end

if.end:                                           ; preds = %entry
  %probe = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 1
  %0 = load i32 (%struct.usb_interface*, %struct.usb_device_id*)*, i32 (%struct.usb_interface*, %struct.usb_device_id*)** %probe, align 8, !tbaa !542
  %cmp = icmp ne i32 (%struct.usb_interface*, %struct.usb_device_id*)* %0, null
  br i1 %cmp, label %if.then1, label %exit

if.then1:                                         ; preds = %if.end
  %drvwrap = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 11
  %driver = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 0
  %call = call i32 @driver_create_file(%struct.device_driver* %driver, %struct.driver_attribute* @driver_attr_new_id)
  %cmp2 = icmp eq i32 %call, 0
  br i1 %cmp2, label %if.then3, label %exit

if.then3:                                         ; preds = %if.then1
  %drvwrap4 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 11
  %driver5 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap4, i32 0, i32 0
  %call6 = call i32 @driver_create_file(%struct.device_driver* %driver5, %struct.driver_attribute* @driver_attr_remove_id)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %exit

if.then8:                                         ; preds = %if.then3
  %drvwrap9 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 11
  %driver10 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap9, i32 0, i32 0
  call void @driver_remove_file(%struct.device_driver* %driver10, %struct.driver_attribute* @driver_attr_new_id)
  br label %exit

exit:                                             ; preds = %if.then8, %if.then3, %if.then1, %if.end, %entry
  %error.2 = phi i32 [ 0, %entry ], [ 0, %if.end ], [ %call, %if.then1 ], [ %call6, %if.then8 ], [ %call6, %if.then3 ]
  ret i32 %error.2
}

declare i32 @driver_create_file(%struct.device_driver*, %struct.driver_attribute*) #2

; Function Attrs: nounwind uwtable
define i32 @usb_autoresume_device(%struct.usb_device* %udev) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call = call i32 @pm_runtime_get_sync.347(%struct.device* %dev)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_put_sync.348(%struct.device* %dev1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %cmp3 = icmp sgt i32 %call, 0
  %.call = select i1 %cmp3, i32 0, i32 %call
  ret i32 %.call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kmalloc_array(i64 %n, i64 %size, i32 %flags) #1 {
entry:
  %cmp = icmp ne i64 %size, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %div = udiv i64 -1, %size
  %cmp1 = icmp ugt i64 %n, %div
  br i1 %cmp1, label %return, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %mul = mul i64 %n, %size
  %call = call noalias i8* @__kmalloc(i64 %mul, i32 %flags)
  br label %return

return:                                           ; preds = %if.end, %land.lhs.true
  %retval.0 = phi i8* [ %call, %if.end ], [ null, %land.lhs.true ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_set_intfdata.387(%struct.usb_interface* %intf, i8* %data) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @dev_set_drvdata.394(%struct.device* %dev, i8* %data)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_disable.388(%struct.device* %dev) #1 {
entry:
  call void @__pm_runtime_disable(%struct.device* %dev, i1 zeroext true)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_set_suspended.389(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_set_status(%struct.device* %dev, i32 2)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_autosuspend_device(%struct.usb_device* %udev) #0 {
entry:
  call void @usb_mark_last_busy.335(%struct.usb_device* %udev)
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_put_sync_autosuspend.393(%struct.device* %dev)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put_sync_autosuspend.393(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_suspend(%struct.device* %dev, i32 12)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @dev_set_drvdata.394(%struct.device* %dev, i8* %data) #1 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  store i8* %data, i8** %driver_data, align 8, !tbaa !117
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_set_active.399(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_set_status(%struct.device* %dev, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_suspend_ignore_children.400(%struct.device* %dev, i1 zeroext %enable) #1 {
entry:
  %frombool = zext i1 %enable to i8
  %tobool = trunc i8 %frombool to i1
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %ignore_children = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 14
  %0 = zext i1 %tobool to i16
  %bf.load = load i16, i16* %ignore_children, align 8
  %bf.shl = shl i16 %0, 8
  %bf.clear = and i16 %bf.load, -257
  %bf.set = or i16 %bf.clear, %bf.shl
  store i16 %bf.set, i16* %ignore_children, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_deregister_device_driver(%struct.usb_device_driver* %udriver) #0 {
entry:
  %0 = call i32 (i8*, ...) @printk(i8* null)
  %drvwrap = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %udriver, i32 0, i32 5
  %driver = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 0
  call void @driver_unregister(%struct.device_driver* %driver)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_register_device_driver(%struct.usb_device_driver* %new_udriver, %struct.module* %owner) #0 {
entry:
  %call = call i32 @usb_disabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %drvwrap = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %new_udriver, i32 0, i32 5
  %for_devices = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 1
  store i32 1, i32* %for_devices, align 8, !tbaa !559
  %name = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %new_udriver, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !561
  %drvwrap2 = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %new_udriver, i32 0, i32 5
  %driver = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap2, i32 0, i32 0
  %name3 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver, i32 0, i32 0
  store i8* %0, i8** %name3, align 8, !tbaa !562
  %drvwrap4 = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %new_udriver, i32 0, i32 5
  %driver5 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap4, i32 0, i32 0
  %bus = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver5, i32 0, i32 1
  store %struct.bus_type* @usb_bus_type, %struct.bus_type** %bus, align 8, !tbaa !563
  %drvwrap6 = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %new_udriver, i32 0, i32 5
  %driver7 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap6, i32 0, i32 0
  %probe = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver7, i32 0, i32 8
  store i32 (%struct.device*)* @usb_probe_device, i32 (%struct.device*)** %probe, align 8, !tbaa !564
  %drvwrap8 = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %new_udriver, i32 0, i32 5
  %driver9 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap8, i32 0, i32 0
  %remove = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver9, i32 0, i32 9
  store i32 (%struct.device*)* @usb_unbind_device, i32 (%struct.device*)** %remove, align 8, !tbaa !565
  %drvwrap10 = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %new_udriver, i32 0, i32 5
  %driver11 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap10, i32 0, i32 0
  %owner12 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver11, i32 0, i32 2
  store %struct.module* %owner, %struct.module** %owner12, align 8, !tbaa !566
  %drvwrap13 = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %new_udriver, i32 0, i32 5
  %driver14 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap13, i32 0, i32 0
  %call15 = call i32 @driver_register(%struct.device_driver* %driver14)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.else, label %if.then17

if.then17:                                        ; preds = %if.end
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.else:                                          ; preds = %if.end
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.then17, %entry
  %retval.0 = phi i32 [ -19, %entry ], [ %call15, %if.else ], [ %call15, %if.then17 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_probe_device(%struct.device* %dev) #0 {
entry:
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !95
  %1 = bitcast %struct.device_driver* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -40
  %2 = bitcast i8* %add.ptr to %struct.usb_device_driver*
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -152
  %4 = bitcast i8* %add.ptr3 to %struct.usb_device*
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_probe_device.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %do.end8

if.then:                                          ; preds = %entry
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_probe_device.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12.957, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.usb_probe_device, i32 0, i32 0))
  br label %do.end8

do.end8:                                          ; preds = %if.then, %entry
  %supports_autosuspend = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %2, i32 0, i32 6
  %bf.load9 = load i8, i8* %supports_autosuspend, align 8
  %bf.clear10 = and i8 %bf.load9, 1
  %bf.cast = zext i8 %bf.clear10 to i32
  %tobool11 = icmp ne i32 %bf.cast, 0
  br i1 %tobool11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %do.end8
  %call = call i32 @usb_autoresume_device(%struct.usb_device* %4)
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %do.end8
  %error.0 = phi i32 [ 0, %do.end8 ], [ %call, %if.then12 ]
  %tobool14 = icmp ne i32 %error.0, 0
  br i1 %tobool14, label %if.end17, label %if.then15

if.then15:                                        ; preds = %if.end13
  %probe = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %2, i32 0, i32 1
  %5 = load i32 (%struct.usb_device*)*, i32 (%struct.usb_device*)** %probe, align 8, !tbaa !567
  %call16 = call i32 %5(%struct.usb_device* %4)
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.end13
  %error.1 = phi i32 [ %error.0, %if.end13 ], [ %call16, %if.then15 ]
  ret i32 %error.1
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_unbind_device(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %2 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !95
  %3 = bitcast %struct.device_driver* %2 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.usb_device_driver*
  %disconnect = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %4, i32 0, i32 2
  %5 = load void (%struct.usb_device*)*, void (%struct.usb_device*)** %disconnect, align 8, !tbaa !568
  call void %5(%struct.usb_device* %1)
  %supports_autosuspend = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %4, i32 0, i32 6
  %bf.load = load i8, i8* %supports_autosuspend, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @usb_autosuspend_device(%struct.usb_device* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}

; Function Attrs: nounwind uwtable
define void @usb_driver_release_interface(%struct.usb_driver* %driver, %struct.usb_interface* %iface) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 7
  %driver2 = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver2, align 8, !tbaa !95
  %tobool = icmp ne %struct.device_driver* %0, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup.cont

lor.lhs.false:                                    ; preds = %entry
  %driver3 = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 7
  %1 = load %struct.device_driver*, %struct.device_driver** %driver3, align 8, !tbaa !95
  %drvwrap = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver, i32 0, i32 11
  %driver4 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 0
  %cmp = icmp ne %struct.device_driver* %1, %driver4
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %condition = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 5
  %2 = load i32, i32* %condition, align 4, !tbaa !55
  %cmp5 = icmp ne i32 %2, 2
  br i1 %cmp5, label %cleanup.cont, label %if.end7

if.end7:                                          ; preds = %if.end
  %condition8 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 5
  store i32 3, i32* %condition8, align 4, !tbaa !55
  %call = call i32 @device_is_registered.409(%struct.device* %dev1)
  %tobool9 = icmp ne i32 %call, 0
  br i1 %tobool9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end7
  call void @device_release_driver(%struct.device* %dev1)
  br label %cleanup.cont

if.else:                                          ; preds = %if.end7
  call void @device_lock.410(%struct.device* %dev1)
  %call11 = call i32 @usb_unbind_interface(%struct.device* %dev1)
  %driver12 = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 7
  store %struct.device_driver* null, %struct.device_driver** %driver12, align 8, !tbaa !95
  call void @device_unlock.411(%struct.device* %dev1)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.else, %if.then10, %if.end, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @device_is_registered.409(%struct.device* %dev) #1 {
entry:
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %state_in_sysfs = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 8
  %bf.load = load i8, i8* %state_in_sysfs, align 8
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  ret i32 %bf.cast
}

declare void @device_release_driver(%struct.device*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock.410(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock.411(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_driver_claim_interface(%struct.usb_driver* %driver, %struct.usb_interface* %iface, i8* %priv) #0 {
entry:
  %tobool = icmp ne %struct.usb_interface* %iface, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %dev2 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 7
  %driver3 = getelementptr inbounds %struct.device, %struct.device* %dev2, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver3, align 8, !tbaa !95
  %tobool4 = icmp ne %struct.device_driver* %0, null
  br i1 %tobool4, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %authorized = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 6
  %bf.load = load i8, i8* %authorized, align 8
  %bf.lshr = lshr i8 %bf.load, 7
  %bf.cast = zext i8 %bf.lshr to i32
  %tobool7 = icmp ne i32 %bf.cast, 0
  br i1 %tobool7, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end6
  %call = call %struct.usb_device* @interface_to_usbdev.321(%struct.usb_interface* %iface)
  %drvwrap = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver, i32 0, i32 11
  %driver10 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 0
  %driver11 = getelementptr inbounds %struct.device, %struct.device* %dev2, i32 0, i32 7
  store %struct.device_driver* %driver10, %struct.device_driver** %driver11, align 8, !tbaa !95
  call void @usb_set_intfdata.387(%struct.usb_interface* %iface, i8* %priv)
  %needs_binding = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 6
  %bf.load12 = load i8, i8* %needs_binding, align 8
  %bf.clear = and i8 %bf.load12, -33
  store i8 %bf.clear, i8* %needs_binding, align 8
  %condition = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 5
  store i32 2, i32* %condition, align 4, !tbaa !55
  %disable_hub_initiated_lpm = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver, i32 0, i32 12
  %bf.load13 = load i8, i8* %disable_hub_initiated_lpm, align 8
  %bf.lshr14 = lshr i8 %bf.load13, 2
  %bf.clear15 = and i8 %bf.lshr14, 1
  %bf.cast16 = zext i8 %bf.clear15 to i32
  %tobool17 = icmp ne i32 %bf.cast16, 0
  br i1 %tobool17, label %if.then18, label %if.end24

if.then18:                                        ; preds = %if.end9
  %call19 = call i32 @usb_unlocked_disable_lpm(%struct.usb_device* %call)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.then18
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end24:                                         ; preds = %if.then18, %if.end9
  %lpm_disable_error.0 = phi i32 [ -19, %if.end9 ], [ %call19, %if.then18 ]
  call void @pm_suspend_ignore_children.400(%struct.device* %dev2, i1 zeroext false)
  %supports_autosuspend = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver, i32 0, i32 12
  %bf.load25 = load i8, i8* %supports_autosuspend, align 8
  %bf.lshr26 = lshr i8 %bf.load25, 1
  %bf.clear27 = and i8 %bf.lshr26, 1
  %bf.cast28 = zext i8 %bf.clear27 to i32
  %tobool29 = icmp ne i32 %bf.cast28, 0
  br i1 %tobool29, label %if.then30, label %if.else

if.then30:                                        ; preds = %if.end24
  call void @pm_runtime_enable(%struct.device* %dev2)
  br label %if.end32

if.else:                                          ; preds = %if.end24
  call void @pm_runtime_set_active.399(%struct.device* %dev2)
  br label %if.end32

if.end32:                                         ; preds = %if.else, %if.then30
  %call33 = call i32 @device_is_registered.409(%struct.device* %dev2)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.end32
  %call36 = call i32 @device_bind_driver(%struct.device* %dev2)
  br label %if.end37

if.end37:                                         ; preds = %if.then35, %if.end32
  %retval1.0 = phi i32 [ %call36, %if.then35 ], [ 0, %if.end32 ]
  %tobool38 = icmp ne i32 %lpm_disable_error.0, 0
  br i1 %tobool38, label %cleanup, label %if.then39

if.then39:                                        ; preds = %if.end37
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.then39, %if.end37, %if.then21, %if.end6, %if.end, %entry
  %retval.0 = phi i32 [ -12, %if.then21 ], [ -19, %entry ], [ -16, %if.end ], [ -19, %if.end6 ], [ %retval1.0, %if.then39 ], [ %retval1.0, %if.end37 ]
  ret i32 %retval.0
}

declare i32 @device_bind_driver(%struct.device*) #2

; Function Attrs: nounwind uwtable
define void @usb_forced_unbind_intf(%struct.usb_interface* %intf) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %driver1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver1, align 8, !tbaa !118
  %1 = bitcast %struct.device_driver* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -168
  %2 = bitcast i8* %add.ptr to %struct.usb_driver*
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_forced_unbind_intf.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %do.end7

if.then:                                          ; preds = %entry
  %dev5 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_forced_unbind_intf.descriptor to %struct._ddebug*), %struct.device* %dev5, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.13.414, i32 0, i32 0))
  br label %do.end7

do.end7:                                          ; preds = %if.then, %entry
  call void @usb_driver_release_interface(%struct.usb_driver* %2, %struct.usb_interface* %intf)
  %needs_binding = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load8 = load i8, i8* %needs_binding, align 8
  %bf.clear9 = and i8 %bf.load8, -33
  %bf.set = or i8 %bf.clear9, 32
  store i8 %bf.set, i8* %needs_binding, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_unbind_and_rebind_marked_interfaces(%struct.usb_device* %udev) #0 {
entry:
  call void @unbind_marked_interfaces(%struct.usb_device* %udev)
  call void @rebind_marked_interfaces(%struct.usb_device* %udev)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @unbind_marked_interfaces(%struct.usb_device* %udev) #0 {
entry:
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %1 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %if.end5

for.body:                                         ; preds = %for.cond
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %2 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !52
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %2, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %3 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !118
  %tobool2 = icmp ne %struct.device_driver* %3, null
  br i1 %tobool2, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %needs_binding = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %2, i32 0, i32 6
  %bf.load = load i8, i8* %needs_binding, align 8
  %bf.lshr = lshr i8 %bf.load, 5
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool3 = icmp ne i32 %bf.cast, 0
  br i1 %tobool3, label %if.then4, label %for.inc

if.then4:                                         ; preds = %land.lhs.true
  call void @usb_forced_unbind_intf(%struct.usb_interface* %2)
  br label %for.inc

for.inc:                                          ; preds = %if.then4, %land.lhs.true, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end5:                                          ; preds = %for.cond, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rebind_marked_interfaces(%struct.usb_device* %udev) #0 {
entry:
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %1 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %if.end4

for.body:                                         ; preds = %for.cond
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %2 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !52
  %needs_binding = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %2, i32 0, i32 6
  %bf.load = load i8, i8* %needs_binding, align 8
  %bf.lshr = lshr i8 %bf.load, 5
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool2 = icmp ne i32 %bf.cast, 0
  br i1 %tobool2, label %if.then3, label %for.inc

if.then3:                                         ; preds = %for.body
  call void @usb_rebind_intf(%struct.usb_interface* %2)
  br label %for.inc

for.inc:                                          ; preds = %if.then3, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end4:                                          ; preds = %for.cond, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usb_rebind_intf(%struct.usb_interface* %intf) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !118
  %tobool = icmp ne %struct.device_driver* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @usb_forced_unbind_intf(%struct.usb_interface* %intf)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %dev1 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %power = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 11
  %is_prepared = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i16, i16* %is_prepared, align 4
  %bf.lshr = lshr i16 %bf.load, 3
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = trunc i16 %bf.clear to i1
  br i1 %bf.cast, label %if.end9, label %if.then2

if.then2:                                         ; preds = %if.end
  %needs_binding = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load3 = load i8, i8* %needs_binding, align 8
  %bf.clear4 = and i8 %bf.load3, -33
  store i8 %bf.clear4, i8* %needs_binding, align 8
  %dev5 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i32 @device_attach(%struct.device* %dev5)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.then2
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end9

if.end9:                                          ; preds = %if.then6, %if.then2, %if.end
  ret void
}

declare i32 @device_attach(%struct.device*) #2

; Function Attrs: nounwind uwtable
define i32 @usb_suspend(%struct.device* %dev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.atomic_t, align 4
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  call void @unbind_no_pm_drivers_interfaces(%struct.usb_device* %1)
  %coerce.dive1 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %2 = load i32, i32* %coerce.dive1, align 4
  call void @choose_wakeup(%struct.usb_device* %1, i32 %2)
  %coerce.dive2 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %3 = load i32, i32* %coerce.dive2, align 4
  %call = call i32 @usb_suspend_both(%struct.usb_device* %1, i32 %3)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @unbind_no_pm_drivers_interfaces(%struct.usb_device* %udev) #0 {
entry:
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool, label %if.then, label %if.end10

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %1 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %if.end10

for.body:                                         ; preds = %for.cond
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %2 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !52
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %2, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %3 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !118
  %tobool2 = icmp ne %struct.device_driver* %3, null
  br i1 %tobool2, label %if.then3, label %for.inc

if.then3:                                         ; preds = %for.body
  %dev4 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %2, i32 0, i32 7
  %driver5 = getelementptr inbounds %struct.device, %struct.device* %dev4, i32 0, i32 7
  %4 = load %struct.device_driver*, %struct.device_driver** %driver5, align 8, !tbaa !118
  %5 = bitcast %struct.device_driver* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 -168
  %6 = bitcast i8* %add.ptr to %struct.usb_driver*
  %suspend = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %6, i32 0, i32 4
  %7 = load i32 (%struct.usb_interface*, i32)*, i32 (%struct.usb_interface*, i32)** %suspend, align 8, !tbaa !569
  %tobool6 = icmp ne i32 (%struct.usb_interface*, i32)* %7, null
  br i1 %tobool6, label %lor.lhs.false, label %if.then8

lor.lhs.false:                                    ; preds = %if.then3
  %resume = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %6, i32 0, i32 5
  %8 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %resume, align 8, !tbaa !570
  %tobool7 = icmp ne i32 (%struct.usb_interface*)* %8, null
  br i1 %tobool7, label %for.inc, label %if.then8

if.then8:                                         ; preds = %lor.lhs.false, %if.then3
  call void @usb_forced_unbind_intf(%struct.usb_interface* %2)
  br label %for.inc

for.inc:                                          ; preds = %if.then8, %lor.lhs.false, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end10:                                         ; preds = %for.cond, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @choose_wakeup(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.atomic_t, align 4
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %0 = load i32, i32* %event, align 4, !tbaa !48
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %event1 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %1 = load i32, i32* %event1, align 4, !tbaa !48
  %cmp2 = icmp eq i32 %1, 8
  br i1 %cmp2, label %if.then, label %if.end5

if.then:                                          ; preds = %lor.lhs.false, %entry
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %2 = load i32, i32* %state, align 8, !tbaa !54
  %cmp3 = icmp ne i32 %2, 8
  br i1 %cmp3, label %if.then4, label %cleanup.cont

if.then4:                                         ; preds = %if.then
  %do_remote_wakeup = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load = load i8, i8* %do_remote_wakeup, align 8
  %bf.clear = and i8 %bf.load, -2
  store i8 %bf.clear, i8* %do_remote_wakeup, align 8
  br label %cleanup.cont

if.end5:                                          ; preds = %lor.lhs.false
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call = call zeroext i1 @device_may_wakeup.425(%struct.device* %dev)
  %conv = zext i1 %call to i32
  %state6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %3 = load i32, i32* %state6, align 8, !tbaa !54
  %cmp7 = icmp eq i32 %3, 8
  br i1 %cmp7, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.end5
  %do_remote_wakeup9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load10 = load i8, i8* %do_remote_wakeup9, align 8
  %bf.clear11 = and i8 %bf.load10, 1
  %bf.cast = zext i8 %bf.clear11 to i32
  %cmp12 = icmp ne i32 %conv, %bf.cast
  br i1 %cmp12, label %if.then14, label %if.end17

if.then14:                                        ; preds = %land.lhs.true
  %dev15 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_resume(%struct.device* %dev15)
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %land.lhs.true, %if.end5
  %do_remote_wakeup18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %4 = trunc i32 %conv to i8
  %bf.load19 = load i8, i8* %do_remote_wakeup18, align 8
  %bf.value = and i8 %4, 1
  %bf.clear20 = and i8 %bf.load19, -2
  %bf.set = or i8 %bf.clear20, %bf.value
  store i8 %bf.set, i8* %do_remote_wakeup18, align 8
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end17, %if.then4, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_suspend_both(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.atomic_t, align 4
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %done, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %state1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %1 = load i32, i32* %state1, align 8, !tbaa !54
  %cmp2 = icmp eq i32 %1, 8
  br i1 %cmp2, label %done, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %if.then3, label %if.end17

if.then3:                                         ; preds = %if.end
  %actconfig4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %3 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig4, align 8, !tbaa !102
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %3, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %4 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv = zext i8 %4 to i32
  %sub = sub nsw i32 %conv, 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then3
  %i.0 = phi i32 [ %sub, %if.then3 ], [ %dec, %for.inc ]
  %status.0 = phi i32 [ 0, %if.then3 ], [ %call., %for.inc ]
  %cmp5 = icmp sge i32 %i.0, 0
  br i1 %cmp5, label %for.body, label %if.end17

for.body:                                         ; preds = %for.cond
  %actconfig7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %5 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig7, align 8, !tbaa !102
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %6 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !52
  %coerce.dive8 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %7 = load i32, i32* %coerce.dive8, align 4
  %call = call i32 @usb_suspend_interface(%struct.usb_device* %udev, %struct.usb_interface* %6, i32 %7)
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %8 = load i32, i32* %event, align 4, !tbaa !48
  %and = and i32 %8, 1024
  %cmp9 = icmp ne i32 %and, 0
  %call. = select i1 %cmp9, i32 %call, i32 0
  %cmp13 = icmp ne i32 %call., 0
  br i1 %cmp13, label %if.end17, label %for.inc

for.inc:                                          ; preds = %for.body
  %dec = add nsw i32 %i.0, -1
  br label %for.cond

if.end17:                                         ; preds = %for.body, %for.cond, %if.end
  %n.0 = phi i32 [ 0, %if.end ], [ %conv, %for.cond ], [ %conv, %for.body ]
  %i.1 = phi i32 [ 0, %if.end ], [ %i.0, %for.cond ], [ %i.0, %for.body ]
  %status.3 = phi i32 [ 0, %if.end ], [ %call., %for.body ], [ %status.0, %for.cond ]
  %cmp18 = icmp eq i32 %status.3, 0
  br i1 %cmp18, label %if.then20, label %if.end30

if.then20:                                        ; preds = %if.end17
  %coerce.dive21 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %9 = load i32, i32* %coerce.dive21, align 4
  %call22 = call i32 @usb_suspend_device(%struct.usb_device* %udev, i32 %9)
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %10 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool23 = icmp ne %struct.usb_device* %10, null
  br i1 %tobool23, label %land.lhs.true, label %if.end30

land.lhs.true:                                    ; preds = %if.then20
  %event24 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %11 = load i32, i32* %event24, align 4, !tbaa !48
  %and25 = and i32 %11, 1024
  %cmp26 = icmp ne i32 %and25, 0
  %call22. = select i1 %cmp26, i32 %call22, i32 0
  br label %if.end30

if.end30:                                         ; preds = %land.lhs.true, %if.then20, %if.end17
  %status.5 = phi i32 [ %status.3, %if.end17 ], [ %call22, %if.then20 ], [ %call22., %land.lhs.true ]
  %cmp31 = icmp ne i32 %status.5, 0
  br i1 %cmp31, label %if.then33, label %if.else

if.then33:                                        ; preds = %if.end30
  %actconfig34 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %12 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig34, align 8, !tbaa !102
  %tobool35 = icmp ne %struct.usb_host_config* %12, null
  br i1 %tobool35, label %if.then36, label %done

if.then36:                                        ; preds = %if.then33
  %event37 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %13 = load i32, i32* %event37, align 4, !tbaa !48
  %xor = xor i32 %13, 18
  store i32 %xor, i32* %event37, align 4, !tbaa !48
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then36
  %i.2 = phi i32 [ %i.1, %if.then36 ], [ %inc, %while.body ]
  %inc = add nsw i32 %i.2, 1
  %cmp38 = icmp slt i32 %inc, %n.0
  br i1 %cmp38, label %while.body, label %done

while.body:                                       ; preds = %while.cond
  %actconfig40 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %14 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig40, align 8, !tbaa !102
  %interface41 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %14, i32 0, i32 3
  %idxprom42 = sext i32 %inc to i64
  %arrayidx43 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface41, i64 0, i64 %idxprom42
  %15 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx43, align 8, !tbaa !52
  %coerce.dive44 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %16 = load i32, i32* %coerce.dive44, align 4
  call void @usb_resume_interface(%struct.usb_device* %udev, %struct.usb_interface* %15, i32 %16, i32 0)
  br label %while.cond

if.else:                                          ; preds = %if.end30
  %can_submit = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %can_submit, align 4
  %bf.clear = and i16 %bf.load, -2
  store i16 %bf.clear, i16* %can_submit, align 4
  br label %for.cond47

for.cond47:                                       ; preds = %for.body50, %if.else
  %i.3 = phi i32 [ 0, %if.else ], [ %inc56, %for.body50 ]
  %cmp48 = icmp slt i32 %i.3, 16
  br i1 %cmp48, label %for.body50, label %done

for.body50:                                       ; preds = %for.cond47
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 17
  %idxprom51 = sext i32 %i.3 to i64
  %arrayidx52 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out, i64 0, i64 %idxprom51
  %17 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx52, align 8, !tbaa !52
  call void @usb_hcd_flush_endpoint(%struct.usb_device* %udev, %struct.usb_host_endpoint* %17)
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 16
  %idxprom53 = sext i32 %i.3 to i64
  %arrayidx54 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in, i64 0, i64 %idxprom53
  %18 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx54, align 8, !tbaa !52
  call void @usb_hcd_flush_endpoint(%struct.usb_device* %udev, %struct.usb_host_endpoint* %18)
  %inc56 = add nsw i32 %i.3, 1
  br label %for.cond47

done:                                             ; preds = %for.cond47, %while.cond, %if.then33, %lor.lhs.false, %entry
  %status.6 = phi i32 [ 0, %lor.lhs.false ], [ 0, %entry ], [ %status.5, %for.cond47 ], [ %status.5, %if.then33 ], [ %status.5, %while.cond ]
  ret i32 %status.6
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_suspend_interface(%struct.usb_device* %udev, %struct.usb_interface* %intf, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.atomic_t, align 4
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %done, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %condition = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 5
  %1 = load i32, i32* %condition, align 4, !tbaa !55
  %cmp1 = icmp eq i32 %1, 0
  br i1 %cmp1, label %done, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %driver2 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %2 = load %struct.device_driver*, %struct.device_driver** %driver2, align 8, !tbaa !118
  %3 = bitcast %struct.device_driver* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -168
  %4 = bitcast i8* %add.ptr to %struct.usb_driver*
  %suspend = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %4, i32 0, i32 4
  %5 = load i32 (%struct.usb_interface*, i32)*, i32 (%struct.usb_interface*, i32)** %suspend, align 8, !tbaa !569
  %coerce.dive3 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %6 = load i32, i32* %coerce.dive3, align 4
  %call = call i32 %5(%struct.usb_interface* %intf, i32 %6)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %done

land.lhs.true:                                    ; preds = %if.end
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %7 = load i32, i32* %event, align 4, !tbaa !48
  %and = and i32 %7, 1024
  %cmp4 = icmp ne i32 %and, 0
  br i1 %cmp4, label %done, label %if.then5

if.then5:                                         ; preds = %land.lhs.true
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %done

done:                                             ; preds = %if.then5, %land.lhs.true, %if.end, %lor.lhs.false, %entry
  %status.0 = phi i32 [ 0, %lor.lhs.false ], [ 0, %entry ], [ %call, %if.then5 ], [ %call, %land.lhs.true ], [ %call, %if.end ]
  ret i32 %status.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_suspend_device(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.atomic_t, align 4
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %done, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %state1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %1 = load i32, i32* %state1, align 8, !tbaa !54
  %cmp2 = icmp eq i32 %1, 8
  br i1 %cmp2, label %done, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %2 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !571
  %tobool = icmp ne %struct.device_driver* %2, null
  br i1 %tobool, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %driver5 = getelementptr inbounds %struct.device, %struct.device* %dev4, i32 0, i32 7
  %3 = load %struct.device_driver*, %struct.device_driver** %driver5, align 8, !tbaa !571
  %4 = bitcast %struct.device_driver* %3 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 -40
  %5 = bitcast i8* %add.ptr to %struct.usb_device_driver*
  br label %if.end6

if.else:                                          ; preds = %if.end
  %do_remote_wakeup = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load = load i8, i8* %do_remote_wakeup, align 8
  %bf.clear = and i8 %bf.load, -2
  store i8 %bf.clear, i8* %do_remote_wakeup, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.else, %if.then3
  %udriver.0 = phi %struct.usb_device_driver* [ %5, %if.then3 ], [ @usb_generic_driver, %if.else ]
  %suspend = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %udriver.0, i32 0, i32 3
  %6 = load i32 (%struct.usb_device*, i32)*, i32 (%struct.usb_device*, i32)** %suspend, align 8, !tbaa !572
  %coerce.dive7 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %7 = load i32, i32* %coerce.dive7, align 4
  %call = call i32 %6(%struct.usb_device* %udev, i32 %7)
  br label %done

done:                                             ; preds = %if.end6, %lor.lhs.false, %entry
  %status.0 = phi i32 [ %call, %if.end6 ], [ 0, %lor.lhs.false ], [ 0, %entry ]
  ret i32 %status.0
}

; Function Attrs: nounwind uwtable
define internal void @usb_resume_interface(%struct.usb_device* %udev, %struct.usb_interface* %intf, i32 %msg.coerce, i32 %reset_resume) #0 {
entry:
  %msg = alloca %struct.atomic_t, align 4
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %done, label %if.end

if.end:                                           ; preds = %entry
  %condition = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 5
  %1 = load i32, i32* %condition, align 4, !tbaa !55
  %cmp1 = icmp eq i32 %1, 3
  br i1 %cmp1, label %done, label %if.end3

if.end3:                                          ; preds = %if.end
  %condition4 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 5
  %2 = load i32, i32* %condition4, align 4, !tbaa !55
  %cmp5 = icmp eq i32 %2, 0
  %needs_altsetting0 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load = load i8, i8* %needs_altsetting0, align 8
  br i1 %cmp5, label %if.then6, label %if.end16

if.then6:                                         ; preds = %if.end3
  %bf.lshr = lshr i8 %bf.load, 4
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %land.lhs.true, label %done

land.lhs.true:                                    ; preds = %if.then6
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %is_prepared = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load7 = load i16, i16* %is_prepared, align 4
  %bf.lshr8 = lshr i16 %bf.load7, 3
  %bf.clear9 = and i16 %bf.lshr8, 1
  %bf.cast10 = trunc i16 %bf.clear9 to i1
  br i1 %bf.cast10, label %done, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 0
  %3 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !98
  %arrayidx = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %3, i64 0
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %4 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !106
  %conv = zext i8 %4 to i32
  %call = call i32 @usb_set_interface(%struct.usb_device* %udev, i32 %conv, i32 0)
  %needs_altsetting012 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load13 = load i8, i8* %needs_altsetting012, align 8
  %bf.clear14 = and i8 %bf.load13, -17
  store i8 %bf.clear14, i8* %needs_altsetting012, align 8
  br label %done

if.end16:                                         ; preds = %if.end3
  %bf.lshr18 = lshr i8 %bf.load, 5
  %bf.clear19 = and i8 %bf.lshr18, 1
  %bf.cast20 = zext i8 %bf.clear19 to i32
  %tobool21 = icmp ne i32 %bf.cast20, 0
  br i1 %tobool21, label %done, label %if.end23

if.end23:                                         ; preds = %if.end16
  %dev24 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %driver25 = getelementptr inbounds %struct.device, %struct.device* %dev24, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver25, align 8, !tbaa !118
  %6 = bitcast %struct.device_driver* %5 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 -168
  %7 = bitcast i8* %add.ptr to %struct.usb_driver*
  %tobool26 = icmp ne i32 %reset_resume, 0
  br i1 %tobool26, label %if.then27, label %if.else54

if.then27:                                        ; preds = %if.end23
  %reset_resume28 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %7, i32 0, i32 6
  %8 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %reset_resume28, align 8, !tbaa !573
  %tobool29 = icmp ne i32 (%struct.usb_interface*)* %8, null
  br i1 %tobool29, label %if.then30, label %if.else

if.then30:                                        ; preds = %if.then27
  %reset_resume31 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %7, i32 0, i32 6
  %9 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %reset_resume31, align 8, !tbaa !573
  %call32 = call i32 %9(%struct.usb_interface* %intf)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %done

if.then34:                                        ; preds = %if.then30
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %done

if.else:                                          ; preds = %if.then27
  %needs_binding37 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load38 = load i8, i8* %needs_binding37, align 8
  %bf.clear39 = and i8 %bf.load38, -33
  %bf.set = or i8 %bf.clear39, 32
  store i8 %bf.set, i8* %needs_binding37, align 8
  %bf.load41 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_resume_interface.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr42 = lshr i32 %bf.load41, 18
  %bf.clear43 = and i32 %bf.lshr42, 255
  %and = and i32 %bf.clear43, 1
  %tobool44 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool44, true
  %lnot45 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot45 to i32
  %conv46 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv46, i64 0)
  %tobool47 = icmp ne i64 %expval, 0
  br i1 %tobool47, label %if.then48, label %done

if.then48:                                        ; preds = %if.else
  %dev49 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %name = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %7, i32 0, i32 0
  %10 = load i8*, i8** %name, align 8, !tbaa !551
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_resume_interface.descriptor to %struct._ddebug*), %struct.device* %dev49, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.27.422, i32 0, i32 0), i8* %10)
  br label %done

if.else54:                                        ; preds = %if.end23
  %resume = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %7, i32 0, i32 5
  %11 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %resume, align 8, !tbaa !570
  %call55 = call i32 %11(%struct.usb_interface* %intf)
  %tobool56 = icmp ne i32 %call55, 0
  br i1 %tobool56, label %if.then57, label %done

if.then57:                                        ; preds = %if.else54
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %done

done:                                             ; preds = %if.then57, %if.else54, %if.then48, %if.else, %if.then34, %if.then30, %if.end16, %if.then11, %land.lhs.true, %if.then6, %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @device_may_wakeup.425(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %can_wakeup = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i16, i16* %can_wakeup, align 4
  %bf.clear = and i16 %bf.load, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %power1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %wakeup = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power1, i32 0, i32 5
  %0 = load %struct.wakeup_source*, %struct.wakeup_source** %wakeup, align 8, !tbaa !457
  %tobool2 = icmp ne %struct.wakeup_source* %0, null
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %1 = phi i1 [ false, %entry ], [ %lnot3, %land.rhs ]
  ret i1 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_resume(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_resume(%struct.device* %dev, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_resume_complete(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 3
  %2 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp ne i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @rebind_marked_interfaces(%struct.usb_device* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @usb_resume(%struct.device* %dev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.atomic_t, align 4
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %coerce.dive1 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %2 = load i32, i32* %coerce.dive1, align 4
  %call = call i32 @usb_resume_both(%struct.usb_device* %1, i32 %2)
  switch i32 %call, label %if.end6 [
    i32 0, label %if.then
    i32 -19, label %if.then5
    i32 -108, label %if.then5
  ]

if.then:                                          ; preds = %entry
  call void @pm_runtime_disable.388(%struct.device* %dev)
  call void @pm_runtime_set_active.399(%struct.device* %dev)
  call void @pm_runtime_enable(%struct.device* %dev)
  call void @unbind_marked_interfaces(%struct.usb_device* %1)
  br label %if.end6

if.then5:                                         ; preds = %entry, %entry
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.then, %entry
  %status.0 = phi i32 [ 0, %if.then5 ], [ %call, %if.then ], [ %call, %entry ]
  ret i32 %status.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_resume_both(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.atomic_t, align 4
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %done, label %if.end

if.end:                                           ; preds = %entry
  %can_submit = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %can_submit, align 4
  %bf.clear = and i16 %bf.load, -2
  %bf.set = or i16 %bf.clear, 1
  store i16 %bf.set, i16* %can_submit, align 4
  %state1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %1 = load i32, i32* %state1, align 8, !tbaa !54
  %cmp2 = icmp eq i32 %1, 8
  br i1 %cmp2, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %reset_resume = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load3 = load i8, i8* %reset_resume, align 8
  %bf.lshr = lshr i8 %bf.load3, 1
  %bf.clear4 = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear4 to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then5, label %if.end7

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %coerce.dive6 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %2 = load i32, i32* %coerce.dive6, align 4
  %call = call i32 @usb_resume_device(%struct.usb_device* %udev, i32 %2)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %lor.lhs.false
  %status.0 = phi i32 [ %call, %if.then5 ], [ 0, %lor.lhs.false ]
  %cmp8 = icmp eq i32 %status.0, 0
  br i1 %cmp8, label %land.lhs.true, label %if.end22

land.lhs.true:                                    ; preds = %if.end7
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %3 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool9 = icmp ne %struct.usb_host_config* %3, null
  br i1 %tobool9, label %if.then10, label %if.end22

if.then10:                                        ; preds = %land.lhs.true
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then10
  %i.0 = phi i32 [ 0, %if.then10 ], [ %inc, %for.body ]
  %actconfig11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %4 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig11, align 8, !tbaa !102
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %4, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %5 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv = zext i8 %5 to i32
  %cmp12 = icmp slt i32 %i.0, %conv
  br i1 %cmp12, label %for.body, label %if.end22

for.body:                                         ; preds = %for.cond
  %actconfig14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %6 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig14, align 8, !tbaa !102
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %6, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %7 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !52
  %reset_resume15 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load16 = load i8, i8* %reset_resume15, align 8
  %bf.lshr17 = lshr i8 %bf.load16, 1
  %bf.clear18 = and i8 %bf.lshr17, 1
  %bf.cast19 = zext i8 %bf.clear18 to i32
  %coerce.dive20 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %8 = load i32, i32* %coerce.dive20, align 4
  call void @usb_resume_interface(%struct.usb_device* %udev, %struct.usb_interface* %7, i32 %8, i32 %bf.cast19)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end22:                                         ; preds = %for.cond, %land.lhs.true, %if.end7
  call void @usb_mark_last_busy.335(%struct.usb_device* %udev)
  br label %done

done:                                             ; preds = %if.end22, %entry
  %status.1 = phi i32 [ %status.0, %if.end22 ], [ -19, %entry ]
  %tobool23 = icmp ne i32 %status.1, 0
  br i1 %tobool23, label %if.end28, label %if.then24

if.then24:                                        ; preds = %done
  %reset_resume25 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load26 = load i8, i8* %reset_resume25, align 8
  %bf.clear27 = and i8 %bf.load26, -3
  store i8 %bf.clear27, i8* %reset_resume25, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.then24, %done
  ret i32 %status.1
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_resume_device(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.atomic_t, align 4
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %done, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %1 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !571
  %cmp1 = icmp eq %struct.device_driver* %1, null
  br i1 %cmp1, label %done, label %if.end3

if.end3:                                          ; preds = %if.end
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %2 = load i32, i32* %event, align 4, !tbaa !48
  %and = and i32 %2, 1024
  %cmp4 = icmp ne i32 %and, 0
  br i1 %cmp4, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end3
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %3 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool = icmp ne %struct.usb_device* %3, null
  br i1 %tobool, label %land.lhs.true5, label %if.end12

land.lhs.true5:                                   ; preds = %land.lhs.true
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %4 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %hs_companion = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %4, i32 0, i32 12
  %5 = load %struct.usb_bus*, %struct.usb_bus** %hs_companion, align 8, !tbaa !574
  %tobool6 = icmp ne %struct.usb_bus* %5, null
  br i1 %tobool6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %land.lhs.true5
  %dev8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %bus9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %6 = load %struct.usb_bus*, %struct.usb_bus** %bus9, align 8, !tbaa !2
  %hs_companion10 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %6, i32 0, i32 12
  %7 = load %struct.usb_bus*, %struct.usb_bus** %hs_companion10, align 8, !tbaa !574
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %7, i32 0, i32 11
  %8 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !264
  %dev11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 11
  %call = call i32 @device_pm_wait_for_dev(%struct.device* %dev8, %struct.device* %dev11)
  br label %if.end12

if.end12:                                         ; preds = %if.then7, %land.lhs.true5, %land.lhs.true, %if.end3
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %9 = load i32, i32* %quirks, align 4, !tbaa !199
  %conv = zext i32 %9 to i64
  %and13 = and i64 %conv, 2
  %tobool14 = icmp ne i64 %and13, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end12
  %reset_resume = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load = load i8, i8* %reset_resume, align 8
  %bf.clear = and i8 %bf.load, -3
  %bf.set = or i8 %bf.clear, 2
  store i8 %bf.set, i8* %reset_resume, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %if.end12
  %dev17 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %driver18 = getelementptr inbounds %struct.device, %struct.device* %dev17, i32 0, i32 7
  %10 = load %struct.device_driver*, %struct.device_driver** %driver18, align 8, !tbaa !571
  %11 = bitcast %struct.device_driver* %10 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %11, i64 -40
  %12 = bitcast i8* %add.ptr to %struct.usb_device_driver*
  %resume = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %12, i32 0, i32 4
  %13 = load i32 (%struct.usb_device*, i32)*, i32 (%struct.usb_device*, i32)** %resume, align 8, !tbaa !575
  %coerce.dive19 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %14 = load i32, i32* %coerce.dive19, align 4
  %call20 = call i32 %13(%struct.usb_device* %udev, i32 %14)
  br label %done

done:                                             ; preds = %if.end16, %if.end, %entry
  %status.0 = phi i32 [ %call20, %if.end16 ], [ 0, %entry ], [ -107, %if.end ]
  ret i32 %status.0
}

declare i32 @device_pm_wait_for_dev(%struct.device*, %struct.device*) #2

; Function Attrs: nounwind uwtable
define i32 @usb_runtime_suspend(%struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %struct.atomic_t, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %call = call i32 @autosuspend_check(%struct.usb_device* %1)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  store i32 1026, i32* %event, align 4, !tbaa !48
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  %2 = load i32, i32* %coerce.dive, align 4
  %call1 = call i32 @usb_suspend_both(%struct.usb_device* %1, i32 %2)
  switch i32 %call1, label %land.lhs.true [
    i32 -11, label %if.then4
    i32 -16, label %if.then4
    i32 0, label %if.end8
  ]

if.then4:                                         ; preds = %if.end, %if.end
  call void @usb_mark_last_busy.335(%struct.usb_device* %1)
  %cmp6 = icmp ne i32 %call1, 0
  br i1 %cmp6, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %if.then4, %if.end
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 8
  %3 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool = icmp ne %struct.usb_device* %3, null
  br i1 %tobool, label %cleanup, label %if.end8

if.end8:                                          ; preds = %land.lhs.true, %if.then4, %if.end
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %land.lhs.true, %entry
  %retval.0 = phi i32 [ %call1, %if.end8 ], [ -11, %entry ], [ -16, %land.lhs.true ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @autosuspend_check(%struct.usb_device* %udev) #0 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool, label %if.then, label %if.end30

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.inc ]
  %w.0 = phi i32 [ 0, %if.then ], [ %w.1, %for.inc ]
  %retval.0 = phi i32 [ undef, %if.then ], [ %retval.3, %for.inc ]
  %actconfig1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %1 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig1, align 8, !tbaa !102
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %1, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %2 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv = zext i8 %2 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %if.end30

for.body:                                         ; preds = %for.cond
  %actconfig3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %3 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig3, align 8, !tbaa !102
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %3, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %4 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !52
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 7
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %disable_depth = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 14
  %bf.load = load i16, i16* %disable_depth, align 8
  %bf.clear = and i16 %bf.load, 7
  %bf.cast = zext i16 %bf.clear to i32
  %tobool4 = icmp ne i32 %bf.cast, 0
  br i1 %tobool4, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %dev6 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 7
  %power7 = getelementptr inbounds %struct.device, %struct.device* %dev6, i32 0, i32 11
  %usage_count = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power7, i32 0, i32 12
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %usage_count, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %5 = load volatile i32, i32* %counter.i, align 4, !tbaa !73
  %6 = bitcast i8* %arraydecay.i to i32*
  store i32 %5, i32* %6, align 4, !tbaa !73
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %7 = load i32, i32* %__val.i, align 4, !tbaa !72
  %cmp8 = icmp sgt i32 %7, 0
  br i1 %cmp8, label %cleanup87, label %if.end11

if.end11:                                         ; preds = %if.end
  %needs_remote_wakeup = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load12 = load i8, i8* %needs_remote_wakeup, align 8
  %bf.lshr = lshr i8 %bf.load12, 3
  %bf.clear13 = and i8 %bf.lshr, 1
  %bf.cast14 = zext i8 %bf.clear13 to i32
  %or = or i32 %w.0, %bf.cast14
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %8 = load i32, i32* %quirks, align 4, !tbaa !199
  %conv15 = zext i32 %8 to i64
  %and = and i64 %conv15, 2
  %tobool16 = icmp ne i64 %and, 0
  br i1 %tobool16, label %if.then17, label %for.inc

if.then17:                                        ; preds = %if.end11
  %dev18 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 7
  %driver19 = getelementptr inbounds %struct.device, %struct.device* %dev18, i32 0, i32 7
  %9 = load %struct.device_driver*, %struct.device_driver** %driver19, align 8, !tbaa !118
  %10 = bitcast %struct.device_driver* %9 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %10, i64 -168
  %11 = bitcast i8* %add.ptr to %struct.usb_driver*
  %reset_resume = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %11, i32 0, i32 6
  %12 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %reset_resume, align 8, !tbaa !573
  %tobool20 = icmp ne i32 (%struct.usb_interface*)* %12, null
  br i1 %tobool20, label %lor.lhs.false, label %LeafBlock

lor.lhs.false:                                    ; preds = %if.then17
  %needs_remote_wakeup21 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load22 = load i8, i8* %needs_remote_wakeup21, align 8
  %bf.lshr23 = lshr i8 %bf.load22, 3
  %bf.clear24 = and i8 %bf.lshr23, 1
  %bf.cast25 = zext i8 %bf.clear24 to i32
  %tobool26 = icmp ne i32 %bf.cast25, 0
  %. = select i1 %tobool26, i32 1, i32 0
  %.retval.0 = select i1 %tobool26, i32 -95, i32 %retval.0
  br label %LeafBlock

LeafBlock:                                        ; preds = %lor.lhs.false, %if.then17
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then17 ], [ %., %lor.lhs.false ]
  %retval.1 = phi i32 [ -95, %if.then17 ], [ %.retval.0, %lor.lhs.false ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup87

for.inc:                                          ; preds = %LeafBlock, %if.end11, %for.body
  %w.1 = phi i32 [ %w.0, %for.body ], [ %or, %LeafBlock ], [ %or, %if.end11 ]
  %retval.3 = phi i32 [ %retval.0, %for.body ], [ %retval.0, %if.end11 ], [ %retval.1, %LeafBlock ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end30:                                         ; preds = %for.cond, %entry
  %w.2 = phi i32 [ 0, %entry ], [ %w.0, %for.cond ]
  %cond = icmp eq i32 %w.2, 0
  br i1 %cond, label %if.end84, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end30
  %dev32 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call33 = call zeroext i1 @device_can_wakeup.432(%struct.device* %dev32)
  br i1 %call33, label %if.end49, label %do.body35

do.body35:                                        ; preds = %land.lhs.true
  %bf.load36 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @autosuspend_check.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr37 = lshr i32 %bf.load36, 18
  %bf.clear38 = and i32 %bf.lshr37, 255
  %and39 = and i32 %bf.clear38, 1
  %tobool40 = icmp ne i32 %and39, 0
  %lnot = xor i1 %tobool40, true
  %lnot41 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot41 to i32
  %conv42 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv42, i64 0)
  %tobool43 = icmp ne i64 %expval, 0
  br i1 %tobool43, label %if.then44, label %cleanup87

if.then44:                                        ; preds = %do.body35
  %dev45 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @autosuspend_check.descriptor to %struct._ddebug*), %struct.device* %dev45, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.29.433, i32 0, i32 0))
  br label %cleanup87

if.end49:                                         ; preds = %land.lhs.true
  %tobool50 = icmp ne i32 %w.2, 0
  br i1 %tobool50, label %land.lhs.true51, label %if.end84

land.lhs.true51:                                  ; preds = %if.end49
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %13 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %14 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %14, i32 0, i32 11
  %15 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !264
  %cmp52 = icmp eq %struct.usb_device* %13, %15
  br i1 %cmp52, label %land.lhs.true54, label %if.end84

land.lhs.true54:                                  ; preds = %land.lhs.true51
  %bus55 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %16 = load %struct.usb_bus*, %struct.usb_bus** %bus55, align 8, !tbaa !2
  %call56 = call %struct.usb_hcd* @bus_to_hcd.434(%struct.usb_bus* %16)
  %cant_recv_wakeups = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call56, i32 0, i32 12
  %bf.load57 = load i16, i16* %cant_recv_wakeups, align 8
  %bf.lshr58 = lshr i16 %bf.load57, 10
  %bf.clear59 = and i16 %bf.lshr58, 1
  %bf.cast60 = zext i16 %bf.clear59 to i32
  %tobool61 = icmp ne i32 %bf.cast60, 0
  br i1 %tobool61, label %do.body64, label %if.end84

do.body64:                                        ; preds = %land.lhs.true54
  %bf.load65 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @autosuspend_check.descriptor.30 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr66 = lshr i32 %bf.load65, 18
  %bf.clear67 = and i32 %bf.lshr66, 255
  %and68 = and i32 %bf.clear67, 1
  %tobool69 = icmp ne i32 %and68, 0
  %lnot70 = xor i1 %tobool69, true
  %lnot72 = xor i1 %lnot70, true
  %lnot.ext73 = zext i1 %lnot72 to i32
  %conv74 = sext i32 %lnot.ext73 to i64
  %expval75 = call i64 @llvm.expect.i64(i64 %conv74, i64 0)
  %tobool76 = icmp ne i64 %expval75, 0
  br i1 %tobool76, label %if.then77, label %cleanup87

if.then77:                                        ; preds = %do.body64
  %dev78 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @autosuspend_check.descriptor.30 to %struct._ddebug*), %struct.device* %dev78, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.31.435, i32 0, i32 0))
  br label %cleanup87

if.end84:                                         ; preds = %land.lhs.true54, %land.lhs.true51, %if.end49, %if.end30
  %do_remote_wakeup = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %17 = trunc i32 %w.2 to i8
  %bf.load85 = load i8, i8* %do_remote_wakeup, align 8
  %bf.value = and i8 %17, 1
  %bf.clear86 = and i8 %bf.load85, -2
  %bf.set = or i8 %bf.clear86, %bf.value
  store i8 %bf.set, i8* %do_remote_wakeup, align 8
  br label %cleanup87

cleanup87:                                        ; preds = %if.end84, %if.then77, %do.body64, %if.then44, %do.body35, %LeafBlock, %if.end
  %retval.4 = phi i32 [ 0, %if.end84 ], [ -16, %if.end ], [ -95, %if.then44 ], [ -95, %do.body35 ], [ -95, %if.then77 ], [ -95, %do.body64 ], [ %retval.1, %LeafBlock ]
  ret i32 %retval.4
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @device_can_wakeup.432(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %can_wakeup = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i16, i16* %can_wakeup, align 4
  %bf.clear = and i16 %bf.load, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  ret i1 %tobool
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd* @bus_to_hcd.434(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd*
  ret %struct.usb_hcd* %1
}

; Function Attrs: nounwind uwtable
define i32 @usb_runtime_resume(%struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %struct.atomic_t, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  store i32 1040, i32* %event, align 4, !tbaa !48
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %.compoundliteral, i32 0, i32 0
  %2 = load i32, i32* %coerce.dive, align 4
  %call = call i32 @usb_resume_both(%struct.usb_device* %1, i32 %2)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @usb_runtime_idle(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %call = call i32 @autosuspend_check(%struct.usb_device* %1)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @pm_runtime_autosuspend(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 -16
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_autosuspend(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_suspend(%struct.device* %dev, i32 8)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_set_usb2_hardware_lpm(%struct.usb_device* %udev, i32 %enable) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.434(%struct.usb_bus* %0)
  %tobool = icmp ne i32 %enable, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %usb2_hw_lpm_allowed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %usb2_hw_lpm_allowed, align 4
  %bf.lshr = lshr i16 %bf.load, 10
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool1 = icmp ne i32 %bf.cast, 0
  br i1 %tobool1, label %if.end, label %cleanup

if.end:                                           ; preds = %land.lhs.true, %entry
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %1 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %set_usb2_hw_lpm = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 39
  %2 = load i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)** %set_usb2_hw_lpm, align 8, !tbaa !576
  %tobool2 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*, i32)* %2, null
  br i1 %tobool2, label %if.then3, label %cleanup

if.then3:                                         ; preds = %if.end
  %driver4 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %3 = load %struct.hc_driver*, %struct.hc_driver** %driver4, align 8, !tbaa !57
  %set_usb2_hw_lpm5 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %3, i32 0, i32 39
  %4 = load i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)** %set_usb2_hw_lpm5, align 8, !tbaa !576
  %call6 = call i32 %4(%struct.usb_hcd* %call, %struct.usb_device* %udev, i32 %enable)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %cleanup, label %if.then8

if.then8:                                         ; preds = %if.then3
  %usb2_hw_lpm_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %5 = trunc i32 %enable to i16
  %bf.load9 = load i16, i16* %usb2_hw_lpm_enabled, align 4
  %bf.value = and i16 %5, 1
  %bf.shl = shl i16 %bf.value, 9
  %bf.clear10 = and i16 %bf.load9, -513
  %bf.set = or i16 %bf.clear10, %bf.shl
  store i16 %bf.set, i16* %usb2_hw_lpm_enabled, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.then8, %if.then3, %if.end, %land.lhs.true
  %retval.0 = phi i32 [ 0, %land.lhs.true ], [ -1, %if.end ], [ %call6, %if.then8 ], [ %call6, %if.then3 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_release_interface_cache(%struct.kref* %ref) #0 {
entry:
  %0 = bitcast %struct.kref* %ref to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -4
  %1 = bitcast i8* %add.ptr to %struct.usb_interface_cache*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %j.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %num_altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %1, i32 0, i32 0
  %2 = load i32, i32* %num_altsetting, align 8, !tbaa !107
  %cmp = icmp ult i32 %j.0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %1, i32 0, i32 2
  %idxprom = sext i32 %j.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i64 0, i64 %idxprom
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 3
  %3 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !173
  %4 = bitcast %struct.usb_host_endpoint* %3 to i8*
  call void @kfree(i8* %4)
  %string = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 4
  %5 = load i8*, i8** %string, align 8, !tbaa !577
  call void @kfree(i8* %5)
  %inc = add nsw i32 %j.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %6 = bitcast %struct.usb_interface_cache* %1 to i8*
  call void @kfree(i8* %6)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_destroy_configuration(%struct.usb_device* %dev) #0 {
entry:
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !194
  %tobool = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %rawdescriptors = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 18
  %1 = load i8**, i8*** %rawdescriptors, align 8, !tbaa !196
  %tobool1 = icmp ne i8** %1, null
  br i1 %tobool1, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then2
  %i.0 = phi i32 [ 0, %if.then2 ], [ %inc, %for.body ]
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 13
  %2 = load i8, i8* %bNumConfigurations, align 1, !tbaa !193
  %conv = zext i8 %2 to i32
  %cmp = icmp slt i32 %i.0, %conv
  %rawdescriptors4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 18
  %3 = load i8**, i8*** %rawdescriptors4, align 8, !tbaa !196
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %3, i64 %idxprom
  %4 = load i8*, i8** %arrayidx, align 8, !tbaa !52
  call void @kfree(i8* %4)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %5 = bitcast i8** %3 to i8*
  call void @kfree(i8* %5)
  %rawdescriptors6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 18
  store i8** null, i8*** %rawdescriptors6, align 8, !tbaa !196
  br label %if.end7

if.end7:                                          ; preds = %for.end, %if.end
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc34, %if.end7
  %c.0 = phi i32 [ 0, %if.end7 ], [ %inc35, %for.inc34 ]
  %descriptor9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bNumConfigurations10 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor9, i32 0, i32 13
  %6 = load i8, i8* %bNumConfigurations10, align 1, !tbaa !193
  %conv11 = zext i8 %6 to i32
  %cmp12 = icmp slt i32 %c.0, %conv11
  %config15 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  %7 = load %struct.usb_host_config*, %struct.usb_host_config** %config15, align 8, !tbaa !194
  br i1 %cmp12, label %for.body14, label %for.end36

for.body14:                                       ; preds = %for.cond8
  %idxprom16 = sext i32 %c.0 to i64
  %arrayidx17 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %7, i64 %idxprom16
  %string = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx17, i32 0, i32 1
  %8 = load i8*, i8** %string, align 8, !tbaa !507
  call void @kfree(i8* %8)
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc31, %for.body14
  %i.1 = phi i32 [ 0, %for.body14 ], [ %inc32, %for.inc31 ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx17, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %9 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv19 = zext i8 %9 to i32
  %cmp20 = icmp slt i32 %i.1, %conv19
  br i1 %cmp20, label %for.body22, label %for.inc34

for.body22:                                       ; preds = %for.cond18
  %intf_cache = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx17, i32 0, i32 4
  %idxprom23 = sext i32 %i.1 to i64
  %arrayidx24 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache, i64 0, i64 %idxprom23
  %10 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx24, align 8, !tbaa !52
  %tobool25 = icmp ne %struct.usb_interface_cache* %10, null
  br i1 %tobool25, label %if.then26, label %for.inc31

if.then26:                                        ; preds = %for.body22
  %intf_cache27 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx17, i32 0, i32 4
  %idxprom28 = sext i32 %i.1 to i64
  %arrayidx29 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache27, i64 0, i64 %idxprom28
  %11 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx29, align 8, !tbaa !52
  %ref = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %11, i32 0, i32 1
  call void @kref_put.446(%struct.kref* %ref, void (%struct.kref*)* @usb_release_interface_cache)
  br label %for.inc31

for.inc31:                                        ; preds = %if.then26, %for.body22
  %inc32 = add nsw i32 %i.1, 1
  br label %for.cond18

for.inc34:                                        ; preds = %for.cond18
  %inc35 = add nsw i32 %c.0, 1
  br label %for.cond8

for.end36:                                        ; preds = %for.cond8
  %12 = bitcast %struct.usb_host_config* %7 to i8*
  call void @kfree(i8* %12)
  %config38 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  store %struct.usb_host_config* null, %struct.usb_host_config** %config38, align 8, !tbaa !194
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end36, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put.446(%struct.kref* %kref, void (%struct.kref*)* %release) #1 {
entry:
  %cmp = icmp eq void (%struct.kref*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.11.527, i32 0, i32 0), i32 69)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  %call = call zeroext i1 @refcount_dec_and_test(%struct.qspinlock* %refcount)
  br i1 %call, label %if.then14, label %return

if.then14:                                        ; preds = %if.end
  call void %release(%struct.kref* %kref)
  br label %return

return:                                           ; preds = %if.then14, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_get_configuration(%struct.usb_device* %dev) #0 {
entry:
  %__UNIQUE_ID_max1_20 = alloca i32, align 4
  %__UNIQUE_ID_max2_21 = alloca i32, align 4
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 13
  %0 = load i8, i8* %bNumConfigurations, align 1, !tbaa !193
  %conv = zext i8 %0 to i32
  %cmp = icmp sgt i32 %conv, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %descriptor3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bNumConfigurations4 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor3, i32 0, i32 13
  store i8 8, i8* %bNumConfigurations4, align 1, !tbaa !193
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %ncfg.0 = phi i32 [ 8, %if.then ], [ %conv, %entry ]
  %cmp5 = icmp slt i32 %ncfg.0, 1
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end8:                                          ; preds = %if.end
  %conv9 = sext i32 %ncfg.0 to i64
  %mul = mul i64 %conv9, 680
  %conv10 = trunc i64 %mul to i32
  %conv11 = zext i32 %conv10 to i64
  %call = call i8* @kzalloc.452(i64 %conv11, i32 20971712)
  %1 = bitcast i8* %call to %struct.usb_host_config*
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  store %struct.usb_host_config* %1, %struct.usb_host_config** %config, align 8, !tbaa !194
  %config12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %config12, align 8, !tbaa !194
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %if.end14, label %err2

if.end14:                                         ; preds = %if.end8
  %conv15 = sext i32 %ncfg.0 to i64
  %mul16 = mul i64 %conv15, 8
  %conv17 = trunc i64 %mul16 to i32
  %conv18 = zext i32 %conv17 to i64
  %call19 = call i8* @kzalloc.452(i64 %conv18, i32 20971712)
  %3 = bitcast i8* %call19 to i8**
  %rawdescriptors = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 18
  store i8** %3, i8*** %rawdescriptors, align 8, !tbaa !196
  %rawdescriptors20 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 18
  %4 = load i8**, i8*** %rawdescriptors20, align 8, !tbaa !196
  %tobool21 = icmp ne i8** %4, null
  br i1 %tobool21, label %if.end23, label %err2

if.end23:                                         ; preds = %if.end14
  %call.i1 = call noalias i8* @__kmalloc(i64 9, i32 20971712) #8
  %5 = bitcast i8* %call.i1 to %struct.usb_config_descriptor*
  %tobool25 = icmp ne %struct.usb_config_descriptor* %5, null
  br i1 %tobool25, label %if.end27, label %err2

if.end27:                                         ; preds = %if.end23
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end27
  %cfgno.0 = phi i32 [ 0, %if.end27 ], [ %inc, %for.inc ]
  %cmp28 = icmp ult i32 %cfgno.0, %ncfg.0
  br i1 %cmp28, label %for.body, label %err

for.body:                                         ; preds = %for.cond
  %conv30 = trunc i32 %cfgno.0 to i8
  %6 = bitcast %struct.usb_config_descriptor* %5 to i8*
  %call31 = call i32 @usb_get_descriptor(%struct.usb_device* %dev, i8 zeroext 2, i8 zeroext %conv30, i8* %6, i32 9)
  %cmp32 = icmp slt i32 %call31, 0
  br i1 %cmp32, label %if.then34, label %if.else

if.then34:                                        ; preds = %for.body
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %cmp35 = icmp ne i32 %call31, -32
  br i1 %cmp35, label %err, label %if.end38

if.end38:                                         ; preds = %if.then34
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %conv39 = trunc i32 %cfgno.0 to i8
  %descriptor40 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bNumConfigurations41 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor40, i32 0, i32 13
  store i8 %conv39, i8* %bNumConfigurations41, align 1, !tbaa !193
  br label %err

if.else:                                          ; preds = %for.body
  %cmp42 = icmp slt i32 %call31, 4
  br i1 %cmp42, label %if.then44, label %if.end46

if.then44:                                        ; preds = %if.else
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %err

if.end46:                                         ; preds = %if.else
  %wTotalLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %5, i32 0, i32 2
  %7 = load i16, i16* %wTotalLength, align 1, !tbaa !578
  %conv47 = zext i16 %7 to i32
  store i32 %conv47, i32* %__UNIQUE_ID_max1_20, align 4, !tbaa !73
  store i32 9, i32* %__UNIQUE_ID_max2_21, align 4, !tbaa !73
  %8 = load i32, i32* %__UNIQUE_ID_max1_20, align 4, !tbaa !73
  %9 = load i32, i32* %__UNIQUE_ID_max2_21, align 4, !tbaa !73
  %cmp50 = icmp sgt i32 %8, %9
  %10 = load i32, i32* %__UNIQUE_ID_max1_20, align 4
  %11 = load i32, i32* %__UNIQUE_ID_max2_21, align 4
  %cond = select i1 %cmp50, i32 %10, i32 %11
  %conv52 = zext i32 %cond to i64
  %call.i = call noalias i8* @__kmalloc(i64 %conv52, i32 20971712) #8
  %tobool54 = icmp ne i8* %call.i, null
  br i1 %tobool54, label %if.end56, label %err

if.end56:                                         ; preds = %if.end46
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 29
  %12 = load i32, i32* %quirks, align 4, !tbaa !199
  %conv57 = zext i32 %12 to i64
  %and = and i64 %conv57, 64
  %tobool58 = icmp ne i64 %and, 0
  br i1 %tobool58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.end56
  call void @msleep(i32 100)
  br label %if.end60

if.end60:                                         ; preds = %if.then59, %if.end56
  %conv61 = trunc i32 %cfgno.0 to i8
  %call62 = call i32 @usb_get_descriptor(%struct.usb_device* %dev, i8 zeroext 2, i8 zeroext %conv61, i8* %call.i, i32 %cond)
  %cmp63 = icmp slt i32 %call62, 0
  br i1 %cmp63, label %if.then65, label %if.end66

if.then65:                                        ; preds = %if.end60
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  call void @kfree(i8* %call.i)
  br label %err

if.end66:                                         ; preds = %if.end60
  %cmp67 = icmp ult i32 %call62, %cond
  br i1 %cmp67, label %if.then69, label %if.end70

if.then69:                                        ; preds = %if.end66
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end70

if.end70:                                         ; preds = %if.then69, %if.end66
  %length.0 = phi i32 [ %call62, %if.then69 ], [ %cond, %if.end66 ]
  %rawdescriptors71 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 18
  %13 = load i8**, i8*** %rawdescriptors71, align 8, !tbaa !196
  %idxprom = zext i32 %cfgno.0 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %13, i64 %idxprom
  store i8* %call.i, i8** %arrayidx, align 8, !tbaa !52
  %config72 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  %14 = load %struct.usb_host_config*, %struct.usb_host_config** %config72, align 8, !tbaa !194
  %idxprom73 = zext i32 %cfgno.0 to i64
  %arrayidx74 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %14, i64 %idxprom73
  %call75 = call i32 @usb_parse_configuration(%struct.usb_device* %dev, %struct.usb_host_config* %arrayidx74, i8* %call.i, i32 %length.0)
  %cmp76 = icmp slt i32 %call75, 0
  %inc = add i32 %cfgno.0, 1
  br i1 %cmp76, label %err, label %for.inc

for.inc:                                          ; preds = %if.end70
  br label %for.cond

err:                                              ; preds = %if.end70, %if.then65, %if.end46, %if.then44, %if.end38, %if.then34, %for.cond
  %cfgno.1 = phi i32 [ %cfgno.0, %if.then44 ], [ %cfgno.0, %if.then65 ], [ %cfgno.0, %if.then34 ], [ %cfgno.0, %if.end46 ], [ %cfgno.0, %for.cond ], [ %cfgno.0, %if.end38 ], [ %inc, %if.end70 ]
  %result.0 = phi i32 [ -22, %if.then44 ], [ %call62, %if.then65 ], [ %call31, %if.then34 ], [ -12, %if.end46 ], [ 0, %for.cond ], [ 0, %if.end38 ], [ %call75, %if.end70 ]
  %15 = bitcast %struct.usb_config_descriptor* %5 to i8*
  call void @kfree(i8* %15)
  %conv81 = trunc i32 %cfgno.1 to i8
  %descriptor82 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bNumConfigurations83 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor82, i32 0, i32 13
  store i8 %conv81, i8* %bNumConfigurations83, align 1, !tbaa !193
  br label %err2

err2:                                             ; preds = %err, %if.end23, %if.end14, %if.end8
  %result.1 = phi i32 [ %result.0, %err ], [ -12, %if.end8 ], [ -12, %if.end14 ], [ -12, %if.end23 ]
  %cmp84 = icmp eq i32 %result.1, -12
  br i1 %cmp84, label %if.then86, label %cleanup

if.then86:                                        ; preds = %err2
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then86, %err2, %if.then7
  %retval.0 = phi i32 [ -22, %if.then7 ], [ %result.1, %if.then86 ], [ %result.1, %err2 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.452(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call noalias i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_parse_configuration(%struct.usb_device* %dev, %struct.usb_host_config* %config, i8* %buffer, i32 %size) #0 {
entry:
  %n = alloca i32, align 4
  %inums = alloca [32 x i8], align 16
  %nalts = alloca [32 x i8], align 16
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %0 = bitcast %struct.usb_config_descriptor* %desc to i8*
  %call = call i8* @__memcpy(i8* %0, i8* %buffer, i64 9)
  %desc3 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bDescriptorType = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc3, i32 0, i32 1
  %1 = load i8, i8* %bDescriptorType, align 1, !tbaa !579
  %conv = zext i8 %1 to i32
  %cmp = icmp ne i32 %conv, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %desc5 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc5, i32 0, i32 0
  %2 = load i8, i8* %bLength, align 8, !tbaa !580
  %conv6 = zext i8 %2 to i32
  %cmp7 = icmp slt i32 %conv6, 9
  br i1 %cmp7, label %if.then, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false
  %desc10 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bLength11 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc10, i32 0, i32 0
  %3 = load i8, i8* %bLength11, align 8, !tbaa !580
  %conv12 = zext i8 %3 to i32
  %cmp13 = icmp sgt i32 %conv12, %size
  br i1 %cmp13, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false9, %lor.lhs.false, %entry
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup296

if.end:                                           ; preds = %lor.lhs.false9
  %desc23 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bLength24 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc23, i32 0, i32 0
  %4 = load i8, i8* %bLength24, align 8, !tbaa !580
  %conv25 = zext i8 %4 to i32
  %idx.ext = sext i32 %conv25 to i64
  %add.ptr = getelementptr inbounds i8, i8* %buffer, i64 %idx.ext
  %desc26 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bLength27 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc26, i32 0, i32 0
  %5 = load i8, i8* %bLength27, align 8, !tbaa !580
  %conv28 = zext i8 %5 to i32
  %sub = sub nsw i32 %size, %conv28
  %desc29 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc29, i32 0, i32 3
  %6 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv30 = zext i8 %6 to i32
  %cmp31 = icmp sgt i32 %conv30, 32
  br i1 %cmp31, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.end
  %nintf.0 = phi i32 [ 32, %if.then33 ], [ %conv30, %if.end ]
  store i32 0, i32* %n, align 4, !tbaa !73
  br label %for.cond

for.cond:                                         ; preds = %for.inc144, %if.end34
  %buffer2.0 = phi i8* [ %add.ptr, %if.end34 ], [ %add.ptr148, %for.inc144 ]
  %size2.0 = phi i32 [ %sub, %if.end34 ], [ %sub151, %for.inc144 ]
  %iad_num.0 = phi i32 [ 0, %if.end34 ], [ %iad_num.4, %for.inc144 ]
  %cmp35 = icmp sgt i32 %size2.0, 0
  br i1 %cmp35, label %for.body, label %for.end152

for.body:                                         ; preds = %for.cond
  %conv37 = sext i32 %size2.0 to i64
  %cmp38 = icmp ult i64 %conv37, 2
  br i1 %cmp38, label %if.then40, label %if.end42

if.then40:                                        ; preds = %for.body
  %call41 = call i8* @plural(i32 %size2.0)
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.end152

if.end42:                                         ; preds = %for.body
  %7 = bitcast i8* %buffer2.0 to %struct.usb_descriptor_header*
  %bLength43 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %7, i32 0, i32 0
  %8 = load i8, i8* %bLength43, align 1, !tbaa !49
  %conv44 = zext i8 %8 to i32
  %cmp45 = icmp sgt i32 %conv44, %size2.0
  br i1 %cmp45, label %if.then52, label %lor.lhs.false47

lor.lhs.false47:                                  ; preds = %if.end42
  %bLength48 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %7, i32 0, i32 0
  %9 = load i8, i8* %bLength48, align 1, !tbaa !49
  %conv49 = zext i8 %9 to i32
  %cmp50 = icmp slt i32 %conv49, 2
  br i1 %cmp50, label %if.then52, label %if.end55

if.then52:                                        ; preds = %lor.lhs.false47, %if.end42
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.end152

if.end55:                                         ; preds = %lor.lhs.false47
  %bDescriptorType56 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %7, i32 0, i32 1
  %10 = load i8, i8* %bDescriptorType56, align 1, !tbaa !51
  %conv57 = zext i8 %10 to i32
  %cmp58 = icmp eq i32 %conv57, 4
  br i1 %cmp58, label %if.then60, label %if.else114

if.then60:                                        ; preds = %if.end55
  %11 = bitcast %struct.usb_descriptor_header* %7 to %struct.usb_interface_descriptor*
  %bLength61 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %11, i32 0, i32 0
  %12 = load i8, i8* %bLength61, align 1, !tbaa !581
  %conv62 = zext i8 %12 to i32
  %cmp63 = icmp slt i32 %conv62, 9
  br i1 %cmp63, label %if.then65, label %if.end68

if.then65:                                        ; preds = %if.then60
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.inc144

if.end68:                                         ; preds = %if.then60
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %11, i32 0, i32 2
  %13 = load i8, i8* %bInterfaceNumber, align 1, !tbaa !171
  %conv69 = zext i8 %13 to i32
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 29
  %14 = load i32, i32* %quirks, align 4, !tbaa !199
  %conv70 = zext i32 %14 to i64
  %and = and i64 %conv70, 32
  %tobool = icmp ne i64 %and, 0
  %15 = load i32, i32* %n, align 4
  %cmp71 = icmp sge i32 %15, %conv30
  %or.cond = and i1 %tobool, %cmp71
  br i1 %or.cond, label %if.then73, label %if.end74

if.then73:                                        ; preds = %if.end68
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.inc144

if.end74:                                         ; preds = %if.end68
  %cmp75 = icmp sge i32 %conv69, %conv30
  br i1 %cmp75, label %if.then77, label %if.end79

if.then77:                                        ; preds = %if.end74
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end79

if.end79:                                         ; preds = %if.then77, %if.end74
  br label %for.cond80

for.cond80:                                       ; preds = %for.inc, %if.end79
  %i.0 = phi i32 [ 0, %if.end79 ], [ %inc, %for.inc ]
  %16 = load i32, i32* %n, align 4, !tbaa !73
  %cmp81 = icmp slt i32 %i.0, %16
  br i1 %cmp81, label %for.body83, label %for.end

for.body83:                                       ; preds = %for.cond80
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* %inums, i64 0, i64 %idxprom
  %17 = load i8, i8* %arrayidx, align 1, !tbaa !72
  %conv84 = zext i8 %17 to i32
  %cmp85 = icmp eq i32 %conv84, %conv69
  br i1 %cmp85, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body83
  %inc = add nsw i32 %i.0, 1
  br label %for.cond80

for.end:                                          ; preds = %for.body83, %for.cond80
  %18 = load i32, i32* %n, align 4, !tbaa !73
  %cmp89 = icmp slt i32 %i.0, %18
  br i1 %cmp89, label %if.then91, label %if.else

if.then91:                                        ; preds = %for.end
  %idxprom92 = sext i32 %i.0 to i64
  %arrayidx93 = getelementptr inbounds [32 x i8], [32 x i8]* %nalts, i64 0, i64 %idxprom92
  %19 = load i8, i8* %arrayidx93, align 1, !tbaa !72
  %conv94 = zext i8 %19 to i32
  %cmp95 = icmp slt i32 %conv94, 255
  br i1 %cmp95, label %if.then97, label %for.inc144

if.then97:                                        ; preds = %if.then91
  %idxprom98 = sext i32 %i.0 to i64
  %arrayidx99 = getelementptr inbounds [32 x i8], [32 x i8]* %nalts, i64 0, i64 %idxprom98
  %20 = load i8, i8* %arrayidx99, align 1, !tbaa !72
  %inc100 = add i8 %20, 1
  store i8 %inc100, i8* %arrayidx99, align 1, !tbaa !72
  br label %for.inc144

if.else:                                          ; preds = %for.end
  %21 = load i32, i32* %n, align 4, !tbaa !73
  %cmp102 = icmp slt i32 %21, 32
  br i1 %cmp102, label %if.then104, label %for.inc144

if.then104:                                       ; preds = %if.else
  %conv105 = trunc i32 %conv69 to i8
  %22 = load i32, i32* %n, align 4, !tbaa !73
  %idxprom106 = sext i32 %22 to i64
  %arrayidx107 = getelementptr inbounds [32 x i8], [32 x i8]* %inums, i64 0, i64 %idxprom106
  store i8 %conv105, i8* %arrayidx107, align 1, !tbaa !72
  %23 = load i32, i32* %n, align 4, !tbaa !73
  %idxprom108 = sext i32 %23 to i64
  %arrayidx109 = getelementptr inbounds [32 x i8], [32 x i8]* %nalts, i64 0, i64 %idxprom108
  store i8 1, i8* %arrayidx109, align 1, !tbaa !72
  %24 = load i32, i32* %n, align 4, !tbaa !73
  %inc110 = add nsw i32 %24, 1
  store i32 %inc110, i32* %n, align 4, !tbaa !73
  br label %for.inc144

if.else114:                                       ; preds = %if.end55
  %bDescriptorType115 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %7, i32 0, i32 1
  %25 = load i8, i8* %bDescriptorType115, align 1, !tbaa !51
  %conv116 = zext i8 %25 to i32
  %cmp117 = icmp eq i32 %conv116, 11
  br i1 %cmp117, label %if.then119, label %if.else128

if.then119:                                       ; preds = %if.else114
  %cmp120 = icmp eq i32 %iad_num.0, 16
  br i1 %cmp120, label %if.then122, label %if.else123

if.then122:                                       ; preds = %if.then119
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.inc144

if.else123:                                       ; preds = %if.then119
  %26 = bitcast %struct.usb_descriptor_header* %7 to %struct.usb_interface_assoc_descriptor*
  %intf_assoc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 2
  %idxprom124 = zext i32 %iad_num.0 to i64
  %arrayidx125 = getelementptr inbounds [16 x %struct.usb_interface_assoc_descriptor*], [16 x %struct.usb_interface_assoc_descriptor*]* %intf_assoc, i64 0, i64 %idxprom124
  store %struct.usb_interface_assoc_descriptor* %26, %struct.usb_interface_assoc_descriptor** %arrayidx125, align 8, !tbaa !52
  %inc126 = add i32 %iad_num.0, 1
  br label %for.inc144

if.else128:                                       ; preds = %if.else114
  %bDescriptorType129 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %7, i32 0, i32 1
  %27 = load i8, i8* %bDescriptorType129, align 1, !tbaa !51
  %conv130 = zext i8 %27 to i32
  %cmp131 = icmp eq i32 %conv130, 1
  br i1 %cmp131, label %if.then138, label %lor.lhs.false133

lor.lhs.false133:                                 ; preds = %if.else128
  %bDescriptorType134 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %7, i32 0, i32 1
  %28 = load i8, i8* %bDescriptorType134, align 1, !tbaa !51
  %conv135 = zext i8 %28 to i32
  %cmp136 = icmp eq i32 %conv135, 2
  br i1 %cmp136, label %if.then138, label %for.inc144

if.then138:                                       ; preds = %lor.lhs.false133, %if.else128
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.inc144

for.inc144:                                       ; preds = %if.then138, %lor.lhs.false133, %if.else123, %if.then122, %if.then104, %if.else, %if.then97, %if.then91, %if.then73, %if.then65
  %iad_num.4 = phi i32 [ %iad_num.0, %if.then122 ], [ %inc126, %if.else123 ], [ %iad_num.0, %if.then138 ], [ %iad_num.0, %lor.lhs.false133 ], [ %iad_num.0, %if.then65 ], [ %iad_num.0, %if.then73 ], [ %iad_num.0, %if.else ], [ %iad_num.0, %if.then104 ], [ %iad_num.0, %if.then91 ], [ %iad_num.0, %if.then97 ]
  %bLength145 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %7, i32 0, i32 0
  %29 = load i8, i8* %bLength145, align 1, !tbaa !49
  %conv146 = zext i8 %29 to i32
  %idx.ext147 = sext i32 %conv146 to i64
  %add.ptr148 = getelementptr inbounds i8, i8* %buffer2.0, i64 %idx.ext147
  %bLength149 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %7, i32 0, i32 0
  %30 = load i8, i8* %bLength149, align 1, !tbaa !49
  %conv150 = zext i8 %30 to i32
  %sub151 = sub nsw i32 %size2.0, %conv150
  br label %for.cond

for.end152:                                       ; preds = %if.then52, %if.then40, %for.cond
  %sub.ptr.lhs.cast = ptrtoint i8* %buffer2.0 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %add.ptr to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv153 = trunc i64 %sub.ptr.sub to i32
  %sub.ptr.lhs.cast154 = ptrtoint i8* %buffer2.0 to i64
  %sub.ptr.rhs.cast155 = ptrtoint i8* %buffer to i64
  %sub.ptr.sub156 = sub i64 %sub.ptr.lhs.cast154, %sub.ptr.rhs.cast155
  %conv157 = trunc i64 %sub.ptr.sub156 to i16
  %desc158 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %wTotalLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc158, i32 0, i32 2
  store i16 %conv157, i16* %wTotalLength, align 2, !tbaa !195
  %31 = load i32, i32* %n, align 4, !tbaa !73
  %cmp159 = icmp ne i32 %31, %nintf.0
  %32 = load i32, i32* %n, align 4, !tbaa !73
  br i1 %cmp159, label %if.then161, label %if.else163

if.then161:                                       ; preds = %for.end152
  %33 = load i32, i32* %n, align 4, !tbaa !73
  %call162 = call i8* @plural(i32 %33)
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end168

if.else163:                                       ; preds = %for.end152
  %cmp164 = icmp eq i32 %32, 0
  br i1 %cmp164, label %if.then166, label %if.end168

if.then166:                                       ; preds = %if.else163
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end168

if.end168:                                        ; preds = %if.then166, %if.else163, %if.then161
  %34 = load i32, i32* %n, align 4, !tbaa !73
  %conv169 = trunc i32 %34 to i8
  %desc170 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bNumInterfaces171 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc170, i32 0, i32 3
  store i8 %conv169, i8* %bNumInterfaces171, align 4, !tbaa !103
  br label %for.cond172

for.cond172:                                      ; preds = %for.inc194, %if.end168
  %i.1 = phi i32 [ 0, %if.end168 ], [ %inc195, %for.inc194 ]
  %cmp173 = icmp slt i32 %i.1, %34
  br i1 %cmp173, label %for.body175, label %for.end196

for.body175:                                      ; preds = %for.cond172
  br label %for.cond176

for.cond176:                                      ; preds = %for.inc187, %for.body175
  %j.0 = phi i32 [ 0, %for.body175 ], [ %inc188, %for.inc187 ]
  %cmp177 = icmp slt i32 %j.0, %34
  br i1 %cmp177, label %for.body179, label %for.end189

for.body179:                                      ; preds = %for.cond176
  %idxprom180 = sext i32 %j.0 to i64
  %arrayidx181 = getelementptr inbounds [32 x i8], [32 x i8]* %inums, i64 0, i64 %idxprom180
  %35 = load i8, i8* %arrayidx181, align 1, !tbaa !72
  %conv182 = zext i8 %35 to i32
  %cmp183 = icmp eq i32 %conv182, %i.1
  br i1 %cmp183, label %for.end189, label %for.inc187

for.inc187:                                       ; preds = %for.body179
  %inc188 = add nsw i32 %j.0, 1
  br label %for.cond176

for.end189:                                       ; preds = %for.body179, %for.cond176
  %cmp190 = icmp sge i32 %j.0, %34
  br i1 %cmp190, label %if.then192, label %for.inc194

if.then192:                                       ; preds = %for.end189
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.inc194

for.inc194:                                       ; preds = %if.then192, %for.end189
  %inc195 = add nsw i32 %i.1, 1
  br label %for.cond172

for.end196:                                       ; preds = %for.cond172
  br label %for.cond197

for.cond197:                                      ; preds = %if.end221, %for.end196
  %i.2 = phi i32 [ 0, %for.end196 ], [ %inc223, %if.end221 ]
  %cmp198 = icmp slt i32 %i.2, %34
  br i1 %cmp198, label %for.body200, label %for.end224

for.body200:                                      ; preds = %for.cond197
  %idxprom201 = sext i32 %i.2 to i64
  %arrayidx202 = getelementptr inbounds [32 x i8], [32 x i8]* %nalts, i64 0, i64 %idxprom201
  %36 = load i8, i8* %arrayidx202, align 1, !tbaa !72
  %conv203 = zext i8 %36 to i32
  %cmp204 = icmp sgt i32 %conv203, 128
  br i1 %cmp204, label %if.then206, label %if.end212

if.then206:                                       ; preds = %for.body200
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %idxprom210 = sext i32 %i.2 to i64
  %arrayidx211 = getelementptr inbounds [32 x i8], [32 x i8]* %nalts, i64 0, i64 %idxprom210
  store i8 -128, i8* %arrayidx211, align 1, !tbaa !72
  br label %if.end212

if.end212:                                        ; preds = %if.then206, %for.body200
  %j.1 = phi i32 [ 128, %if.then206 ], [ %conv203, %for.body200 ]
  %conv213 = sext i32 %j.1 to i64
  %mul = mul i64 40, %conv213
  %add = add i64 8, %mul
  %conv214 = trunc i64 %add to i32
  %conv215 = sext i32 %conv214 to i64
  %call216 = call i8* @kzalloc.452(i64 %conv215, i32 20971712)
  %37 = bitcast i8* %call216 to %struct.usb_interface_cache*
  %intf_cache = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 4
  %idxprom217 = sext i32 %i.2 to i64
  %arrayidx218 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache, i64 0, i64 %idxprom217
  store %struct.usb_interface_cache* %37, %struct.usb_interface_cache** %arrayidx218, align 8, !tbaa !52
  %tobool219 = icmp ne %struct.usb_interface_cache* %37, null
  br i1 %tobool219, label %if.end221, label %cleanup296

if.end221:                                        ; preds = %if.end212
  %ref = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %37, i32 0, i32 1
  call void @kref_init.474(%struct.kref* %ref)
  %inc223 = add nsw i32 %i.2, 1
  br label %for.cond197

for.end224:                                       ; preds = %for.cond197
  %extra = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 5
  store i8* %add.ptr, i8** %extra, align 8, !tbaa !582
  %call225 = call i32 @find_next_descriptor(i8* %add.ptr, i32 %conv153, i32 4, i32 4, i32* %n)
  %extralen = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 6
  store i32 %call225, i32* %extralen, align 8, !tbaa !583
  %38 = load i32, i32* %n, align 4, !tbaa !73
  %cmp226 = icmp sgt i32 %38, 0
  br i1 %cmp226, label %do.body229, label %if.end240

do.body229:                                       ; preds = %for.end224
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_parse_configuration.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and230 = and i32 %bf.clear, 1
  %tobool231 = icmp ne i32 %and230, 0
  %lnot = xor i1 %tobool231, true
  %lnot232 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot232 to i32
  %conv233 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv233, i64 0)
  %tobool234 = icmp ne i64 %expval, 0
  br i1 %tobool234, label %if.then235, label %if.end240

if.then235:                                       ; preds = %do.body229
  %39 = load i32, i32* %n, align 4, !tbaa !73
  %40 = load i32, i32* %n, align 4, !tbaa !73
  %call236 = call i8* @plural(i32 %40)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_parse_configuration.descriptor to %struct._ddebug*), %struct.device* %dev1, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.28.475, i32 0, i32 0), i32 %39, i8* %call236, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.629, i32 0, i32 0))
  br label %if.end240

if.end240:                                        ; preds = %if.then235, %do.body229, %for.end224
  %idx.ext241 = sext i32 %call225 to i64
  %add.ptr242 = getelementptr inbounds i8, i8* %add.ptr, i64 %idx.ext241
  %sub243 = sub nsw i32 %conv153, %call225
  br label %while.cond

while.cond:                                       ; preds = %if.end251, %if.end240
  %size.addr.0 = phi i32 [ %sub243, %if.end240 ], [ %sub254, %if.end251 ]
  %buffer.addr.0 = phi i8* [ %add.ptr242, %if.end240 ], [ %add.ptr253, %if.end251 ]
  %cmp244 = icmp sgt i32 %size.addr.0, 0
  br i1 %cmp244, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %inums, i32 0, i32 0
  %arraydecay246 = getelementptr inbounds [32 x i8], [32 x i8]* %nalts, i32 0, i32 0
  %call247 = call i32 @usb_parse_interface(%struct.device* %dev1, %struct.usb_host_config* %config, i8* %buffer.addr.0, i32 %size.addr.0, i8* %arraydecay, i8* %arraydecay246)
  %cmp248 = icmp slt i32 %call247, 0
  br i1 %cmp248, label %cleanup296, label %if.end251

if.end251:                                        ; preds = %while.body
  %idx.ext252 = sext i32 %call247 to i64
  %add.ptr253 = getelementptr inbounds i8, i8* %buffer.addr.0, i64 %idx.ext252
  %sub254 = sub nsw i32 %size.addr.0, %call247
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %for.cond255

for.cond255:                                      ; preds = %for.inc293, %while.end
  %i.3 = phi i32 [ 0, %while.end ], [ %inc294, %for.inc293 ]
  %cmp256 = icmp slt i32 %i.3, %34
  br i1 %cmp256, label %for.body258, label %cleanup296

for.body258:                                      ; preds = %for.cond255
  %intf_cache259 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 4
  %idxprom260 = sext i32 %i.3 to i64
  %arrayidx261 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache259, i64 0, i64 %idxprom260
  %41 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx261, align 8, !tbaa !52
  br label %for.cond262

for.cond262:                                      ; preds = %for.inc290, %for.body258
  %j.2 = phi i32 [ 0, %for.body258 ], [ %inc291, %for.inc290 ]
  %num_altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %41, i32 0, i32 0
  %42 = load i32, i32* %num_altsetting, align 8, !tbaa !107
  %cmp263 = icmp ult i32 %j.2, %42
  br i1 %cmp263, label %for.body265, label %for.inc293

for.body265:                                      ; preds = %for.cond262
  store i32 0, i32* %n, align 4, !tbaa !73
  br label %for.cond266

for.cond266:                                      ; preds = %for.inc279, %for.body265
  %43 = load i32, i32* %n, align 4, !tbaa !73
  %num_altsetting267 = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %41, i32 0, i32 0
  %44 = load i32, i32* %num_altsetting267, align 8, !tbaa !107
  %cmp268 = icmp ult i32 %43, %44
  br i1 %cmp268, label %for.body270, label %for.end281

for.body270:                                      ; preds = %for.cond266
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %41, i32 0, i32 2
  %45 = load i32, i32* %n, align 4, !tbaa !73
  %idxprom271 = sext i32 %45 to i64
  %arrayidx272 = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i64 0, i64 %idxprom271
  %desc273 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx272, i32 0, i32 0
  %bAlternateSetting = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc273, i32 0, i32 3
  %46 = load i8, i8* %bAlternateSetting, align 1, !tbaa !99
  %conv274 = zext i8 %46 to i32
  %cmp275 = icmp eq i32 %conv274, %j.2
  br i1 %cmp275, label %for.end281, label %for.inc279

for.inc279:                                       ; preds = %for.body270
  %47 = load i32, i32* %n, align 4, !tbaa !73
  %inc280 = add nsw i32 %47, 1
  store i32 %inc280, i32* %n, align 4, !tbaa !73
  br label %for.cond266

for.end281:                                       ; preds = %for.body270, %for.cond266
  %48 = load i32, i32* %n, align 4, !tbaa !73
  %num_altsetting282 = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %41, i32 0, i32 0
  %49 = load i32, i32* %num_altsetting282, align 8, !tbaa !107
  %cmp283 = icmp uge i32 %48, %49
  br i1 %cmp283, label %if.then285, label %for.inc290

if.then285:                                       ; preds = %for.end281
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.inc290

for.inc290:                                       ; preds = %if.then285, %for.end281
  %inc291 = add nsw i32 %j.2, 1
  br label %for.cond262

for.inc293:                                       ; preds = %for.cond262
  %inc294 = add nsw i32 %i.3, 1
  br label %for.cond255

cleanup296:                                       ; preds = %for.cond255, %while.body, %if.end212, %if.then
  %retval.0 = phi i32 [ -22, %if.then ], [ -12, %if.end212 ], [ %call247, %while.body ], [ 0, %for.cond255 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @plural(i32 %n) #1 {
entry:
  %cmp = icmp eq i32 %n, 1
  %cond = select i1 %cmp, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.28.900, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.7.854, i32 0, i32 0)
  ret i8* %cond
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_init.474(%struct.kref* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  call void @refcount_set.513(%struct.qspinlock* %refcount, i32 1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @find_next_descriptor(i8* %buffer, i32 %size, i32 %dt1, i32 %dt2, i32* %num_skipped) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %n.0 = phi i32 [ 0, %entry ], [ %inc, %if.end ]
  %size.addr.0 = phi i32 [ %size, %entry ], [ %sub, %if.end ]
  %buffer.addr.0 = phi i8* [ %buffer, %entry ], [ %add.ptr, %if.end ]
  %cmp = icmp sgt i32 %size.addr.0, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %0 = bitcast i8* %buffer.addr.0 to %struct.usb_descriptor_header*
  %bDescriptorType = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %0, i32 0, i32 1
  %1 = load i8, i8* %bDescriptorType, align 1, !tbaa !51
  %conv = zext i8 %1 to i32
  %cmp1 = icmp eq i32 %conv, %dt1
  br i1 %cmp1, label %while.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %bDescriptorType3 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %0, i32 0, i32 1
  %2 = load i8, i8* %bDescriptorType3, align 1, !tbaa !51
  %conv4 = zext i8 %2 to i32
  %cmp5 = icmp eq i32 %conv4, %dt2
  br i1 %cmp5, label %while.end, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %bLength = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %0, i32 0, i32 0
  %3 = load i8, i8* %bLength, align 1, !tbaa !49
  %conv7 = zext i8 %3 to i32
  %idx.ext = sext i32 %conv7 to i64
  %add.ptr = getelementptr inbounds i8, i8* %buffer.addr.0, i64 %idx.ext
  %bLength8 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %0, i32 0, i32 0
  %4 = load i8, i8* %bLength8, align 1, !tbaa !49
  %conv9 = zext i8 %4 to i32
  %sub = sub nsw i32 %size.addr.0, %conv9
  %inc = add nsw i32 %n.0, 1
  br label %while.cond

while.end:                                        ; preds = %lor.lhs.false, %while.body, %while.cond
  %tobool = icmp ne i32* %num_skipped, null
  br i1 %tobool, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.end
  store i32 %n.0, i32* %num_skipped, align 4, !tbaa !73
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.end
  %sub.ptr.lhs.cast = ptrtoint i8* %buffer.addr.0 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %buffer to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv12 = trunc i64 %sub.ptr.sub to i32
  ret i32 %conv12
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_parse_interface(%struct.device* %ddev, %struct.usb_host_config* %config, i8* %buffer, i32 %size, i8* %inums, i8* %nalts) #0 {
entry:
  %n = alloca i32, align 4
  %0 = bitcast i8* %buffer to %struct.usb_interface_descriptor*
  %bLength = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %0, i32 0, i32 0
  %1 = load i8, i8* %bLength, align 1, !tbaa !581
  %conv = zext i8 %1 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr inbounds i8, i8* %buffer, i64 %idx.ext
  %bLength2 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %0, i32 0, i32 0
  %2 = load i8, i8* %bLength2, align 1, !tbaa !581
  %conv3 = zext i8 %2 to i32
  %sub = sub nsw i32 %size, %conv3
  %bLength4 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %0, i32 0, i32 0
  %3 = load i8, i8* %bLength4, align 1, !tbaa !581
  %conv5 = zext i8 %3 to i32
  %cmp = icmp slt i32 %conv5, 9
  br i1 %cmp, label %skip_to_next_interface_descriptor, label %if.end

if.end:                                           ; preds = %entry
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %0, i32 0, i32 2
  %4 = load i8, i8* %bInterfaceNumber, align 1, !tbaa !171
  %conv7 = zext i8 %4 to i32
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %5 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv8 = zext i8 %5 to i32
  %cmp9 = icmp slt i32 %i.0, %conv8
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8, i8* %inums, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1, !tbaa !72
  %conv11 = zext i8 %6 to i32
  %cmp12 = icmp eq i32 %conv11, %conv7
  br i1 %cmp12, label %if.then14, label %for.inc

if.then14:                                        ; preds = %for.body
  %intf_cache = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 4
  %idxprom15 = sext i32 %i.0 to i64
  %arrayidx16 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache, i64 0, i64 %idxprom15
  %7 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx16, align 8, !tbaa !52
  br label %for.end

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %if.then14, %for.cond
  %intfc.0 = phi %struct.usb_interface_cache* [ %7, %if.then14 ], [ null, %for.cond ]
  %tobool = icmp ne %struct.usb_interface_cache* %intfc.0, null
  br i1 %tobool, label %lor.lhs.false, label %skip_to_next_interface_descriptor

lor.lhs.false:                                    ; preds = %for.end
  %num_altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intfc.0, i32 0, i32 0
  %8 = load i32, i32* %num_altsetting, align 8, !tbaa !107
  %idxprom18 = sext i32 %i.0 to i64
  %arrayidx19 = getelementptr inbounds i8, i8* %nalts, i64 %idxprom18
  %9 = load i8, i8* %arrayidx19, align 1, !tbaa !72
  %conv20 = zext i8 %9 to i32
  %cmp21 = icmp uge i32 %8, %conv20
  br i1 %cmp21, label %skip_to_next_interface_descriptor, label %if.end24

if.end24:                                         ; preds = %lor.lhs.false
  %bAlternateSetting = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %0, i32 0, i32 3
  %10 = load i8, i8* %bAlternateSetting, align 1, !tbaa !170
  %conv25 = zext i8 %10 to i32
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intfc.0, i32 0, i32 2
  %arrayidx26 = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i64 0, i64 0
  br label %for.cond27

for.cond27:                                       ; preds = %for.inc39, %if.end24
  %alt.0 = phi %struct.usb_host_interface* [ %arrayidx26, %if.end24 ], [ %incdec.ptr, %for.inc39 ]
  %i.1 = phi i32 [ 0, %if.end24 ], [ %inc40, %for.inc39 ]
  %num_altsetting28 = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intfc.0, i32 0, i32 0
  %11 = load i32, i32* %num_altsetting28, align 8, !tbaa !107
  %cmp29 = icmp ult i32 %i.1, %11
  br i1 %cmp29, label %for.body31, label %for.end41

for.body31:                                       ; preds = %for.cond27
  %desc32 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 0
  %bAlternateSetting33 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc32, i32 0, i32 3
  %12 = load i8, i8* %bAlternateSetting33, align 1, !tbaa !99
  %conv34 = zext i8 %12 to i32
  %cmp35 = icmp eq i32 %conv34, %conv25
  br i1 %cmp35, label %if.then37, label %for.inc39

if.then37:                                        ; preds = %for.body31
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %skip_to_next_interface_descriptor

for.inc39:                                        ; preds = %for.body31
  %inc40 = add nsw i32 %i.1, 1
  %incdec.ptr = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 1
  br label %for.cond27

for.end41:                                        ; preds = %for.cond27
  %num_altsetting42 = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intfc.0, i32 0, i32 0
  %13 = load i32, i32* %num_altsetting42, align 8, !tbaa !107
  %inc43 = add i32 %13, 1
  store i32 %inc43, i32* %num_altsetting42, align 8, !tbaa !107
  %desc44 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 0
  %14 = bitcast %struct.usb_interface_descriptor* %desc44 to i8*
  %15 = bitcast %struct.usb_interface_descriptor* %0 to i8*
  %call = call i8* @__memcpy(i8* %14, i8* %15, i64 9)
  %extra = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 2
  store i8* %add.ptr, i8** %extra, align 8, !tbaa !584
  %call45 = call i32 @find_next_descriptor(i8* %add.ptr, i32 %sub, i32 5, i32 4, i32* %n)
  %extralen = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 1
  store i32 %call45, i32* %extralen, align 4, !tbaa !585
  %16 = load i32, i32* %n, align 4, !tbaa !73
  %cmp46 = icmp sgt i32 %16, 0
  br i1 %cmp46, label %do.body49, label %if.end59

do.body49:                                        ; preds = %for.end41
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_parse_interface.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool50 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool50, true
  %lnot51 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot51 to i32
  %conv52 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv52, i64 0)
  %tobool53 = icmp ne i64 %expval, 0
  br i1 %tobool53, label %if.then54, label %if.end59

if.then54:                                        ; preds = %do.body49
  %17 = load i32, i32* %n, align 4, !tbaa !73
  %18 = load i32, i32* %n, align 4, !tbaa !73
  %call55 = call i8* @plural(i32 %18)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_parse_interface.descriptor to %struct._ddebug*), %struct.device* %ddev, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.28.475, i32 0, i32 0), i32 %17, i8* %call55, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.80.670, i32 0, i32 0))
  br label %if.end59

if.end59:                                         ; preds = %if.then54, %do.body49, %for.end41
  %idx.ext60 = sext i32 %call45 to i64
  %add.ptr61 = getelementptr inbounds i8, i8* %add.ptr, i64 %idx.ext60
  %sub62 = sub nsw i32 %sub, %call45
  %desc63 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc63, i32 0, i32 4
  %19 = load i8, i8* %bNumEndpoints, align 4, !tbaa !172
  %conv64 = zext i8 %19 to i32
  %desc65 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 0
  %bNumEndpoints66 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc65, i32 0, i32 4
  store i8 0, i8* %bNumEndpoints66, align 4, !tbaa !172
  %cmp67 = icmp sgt i32 %conv64, 30
  br i1 %cmp67, label %if.then69, label %if.end70

if.then69:                                        ; preds = %if.end59
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end70

if.end70:                                         ; preds = %if.then69, %if.end59
  %num_ep.0 = phi i32 [ 30, %if.then69 ], [ %conv64, %if.end59 ]
  %cmp71 = icmp sgt i32 %num_ep.0, 0
  br i1 %cmp71, label %if.then73, label %if.end82

if.then73:                                        ; preds = %if.end70
  %conv74 = sext i32 %num_ep.0 to i64
  %mul = mul i64 80, %conv74
  %conv75 = trunc i64 %mul to i32
  %conv76 = sext i32 %conv75 to i64
  %call77 = call i8* @kzalloc.452(i64 %conv76, i32 20971712)
  %20 = bitcast i8* %call77 to %struct.usb_host_endpoint*
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 3
  store %struct.usb_host_endpoint* %20, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !173
  %endpoint78 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 3
  %21 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint78, align 8, !tbaa !173
  %tobool79 = icmp ne %struct.usb_host_endpoint* %21, null
  br i1 %tobool79, label %if.end82, label %cleanup

if.end82:                                         ; preds = %if.then73, %if.end70
  store i32 0, i32* %n, align 4, !tbaa !73
  br label %while.cond

while.cond:                                       ; preds = %if.end94, %if.end82
  %size.addr.0 = phi i32 [ %sub62, %if.end82 ], [ %sub98, %if.end94 ]
  %buffer.addr.0 = phi i8* [ %add.ptr61, %if.end82 ], [ %add.ptr97, %if.end94 ]
  %cmp83 = icmp sgt i32 %size.addr.0, 0
  br i1 %cmp83, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %22 = bitcast i8* %buffer.addr.0 to %struct.usb_descriptor_header*
  %bDescriptorType = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %22, i32 0, i32 1
  %23 = load i8, i8* %bDescriptorType, align 1, !tbaa !51
  %conv85 = zext i8 %23 to i32
  %cmp86 = icmp eq i32 %conv85, 4
  br i1 %cmp86, label %while.end, label %if.end89

if.end89:                                         ; preds = %while.body
  %call90 = call i32 @usb_parse_endpoint(%struct.device* %ddev, %struct.usb_host_interface* %alt.0, i32 %num_ep.0, i8* %buffer.addr.0, i32 %size.addr.0)
  %cmp91 = icmp slt i32 %call90, 0
  br i1 %cmp91, label %cleanup, label %if.end94

if.end94:                                         ; preds = %if.end89
  %24 = load i32, i32* %n, align 4, !tbaa !73
  %inc95 = add nsw i32 %24, 1
  store i32 %inc95, i32* %n, align 4, !tbaa !73
  %idx.ext96 = sext i32 %call90 to i64
  %add.ptr97 = getelementptr inbounds i8, i8* %buffer.addr.0, i64 %idx.ext96
  %sub98 = sub nsw i32 %size.addr.0, %call90
  br label %while.cond

while.end:                                        ; preds = %while.body, %while.cond
  %25 = load i32, i32* %n, align 4, !tbaa !73
  %cmp99 = icmp ne i32 %25, %conv64
  br i1 %cmp99, label %if.then101, label %if.end103

if.then101:                                       ; preds = %while.end
  %26 = load i32, i32* %n, align 4, !tbaa !73
  %call102 = call i8* @plural(i32 %26)
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end103

if.end103:                                        ; preds = %if.then101, %while.end
  %sub.ptr.lhs.cast = ptrtoint i8* %buffer.addr.0 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %buffer to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv104 = trunc i64 %sub.ptr.sub to i32
  br label %cleanup

skip_to_next_interface_descriptor:                ; preds = %if.then37, %lor.lhs.false, %for.end, %entry
  %call105 = call i32 @find_next_descriptor(i8* %add.ptr, i32 %sub, i32 4, i32 4, i32* null)
  %sub.ptr.lhs.cast106 = ptrtoint i8* %add.ptr to i64
  %sub.ptr.rhs.cast107 = ptrtoint i8* %buffer to i64
  %sub.ptr.sub108 = sub i64 %sub.ptr.lhs.cast106, %sub.ptr.rhs.cast107
  %conv109 = sext i32 %call105 to i64
  %add = add nsw i64 %sub.ptr.sub108, %conv109
  %conv110 = trunc i64 %add to i32
  br label %cleanup

cleanup:                                          ; preds = %skip_to_next_interface_descriptor, %if.end103, %if.end89, %if.then73
  %retval.0 = phi i32 [ %conv110, %skip_to_next_interface_descriptor ], [ %conv104, %if.end103 ], [ -12, %if.then73 ], [ %call90, %if.end89 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_parse_endpoint(%struct.device* %ddev, %struct.usb_host_interface* %ifp, i32 %num_ep, i8* %buffer, i32 %size) #0 {
entry:
  %n = alloca i32, align 4
  %__UNIQUE_ID_min1_14 = alloca i32, align 4
  %__UNIQUE_ID_max1_12 = alloca i32, align 4
  %__UNIQUE_ID_max2_13 = alloca i32, align 4
  %__UNIQUE_ID_min2_15 = alloca i32, align 4
  %__UNIQUE_ID_min1_18 = alloca i32, align 4
  %__UNIQUE_ID_max1_16 = alloca i32, align 4
  %__UNIQUE_ID_max2_17 = alloca i32, align 4
  %__UNIQUE_ID_min2_19 = alloca i32, align 4
  %0 = bitcast i8* %buffer to %struct.usb_endpoint_descriptor*
  %bLength = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 0
  %1 = load i8, i8* %bLength, align 1, !tbaa !586
  %conv = zext i8 %1 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr inbounds i8, i8* %buffer, i64 %idx.ext
  %bLength2 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 0
  %2 = load i8, i8* %bLength2, align 1, !tbaa !586
  %conv3 = zext i8 %2 to i32
  %sub = sub nsw i32 %size, %conv3
  %bLength4 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 0
  %3 = load i8, i8* %bLength4, align 1, !tbaa !586
  %conv5 = zext i8 %3 to i32
  %cmp = icmp sge i32 %conv5, 9
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 9, i32* %n, align 4, !tbaa !73
  br label %if.end15

if.else:                                          ; preds = %entry
  %bLength7 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 0
  %4 = load i8, i8* %bLength7, align 1, !tbaa !586
  %conv8 = zext i8 %4 to i32
  %cmp9 = icmp sge i32 %conv8, 7
  br i1 %cmp9, label %if.then11, label %if.else12

if.then11:                                        ; preds = %if.else
  store i32 7, i32* %n, align 4, !tbaa !73
  br label %if.end15

if.else12:                                        ; preds = %if.else
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %skip_to_next_endpoint_or_interface_descriptor

if.end15:                                         ; preds = %if.then11, %if.then
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 2
  %5 = load i8, i8* %bEndpointAddress, align 1, !tbaa !309
  %conv16 = zext i8 %5 to i32
  %and = and i32 %conv16, -129
  %cmp17 = icmp sge i32 %and, 16
  %cmp19 = icmp eq i32 %and, 0
  %or.cond = or i1 %cmp17, %cmp19
  br i1 %or.cond, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.end15
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %skip_to_next_endpoint_or_interface_descriptor

if.end24:                                         ; preds = %if.end15
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %ifp, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 4
  %6 = load i8, i8* %bNumEndpoints, align 4, !tbaa !172
  %conv25 = zext i8 %6 to i32
  %cmp26 = icmp sge i32 %conv25, %num_ep
  br i1 %cmp26, label %skip_to_next_endpoint_or_interface_descriptor, label %if.end29

if.end29:                                         ; preds = %if.end24
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end29
  %i.0 = phi i32 [ 0, %if.end29 ], [ %inc, %for.inc ]
  %desc30 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %ifp, i32 0, i32 0
  %bNumEndpoints31 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc30, i32 0, i32 4
  %7 = load i8, i8* %bNumEndpoints31, align 4, !tbaa !172
  %conv32 = zext i8 %7 to i32
  %cmp33 = icmp slt i32 %i.0, %conv32
  %endpoint35 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %ifp, i32 0, i32 3
  %8 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint35, align 8, !tbaa !173
  br i1 %cmp33, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %8, i64 %idxprom
  %desc36 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 0
  %bEndpointAddress37 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc36, i32 0, i32 2
  %9 = load i8, i8* %bEndpointAddress37, align 2, !tbaa !512
  %conv38 = zext i8 %9 to i32
  %bEndpointAddress39 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 2
  %10 = load i8, i8* %bEndpointAddress39, align 1, !tbaa !309
  %conv40 = zext i8 %10 to i32
  %cmp41 = icmp eq i32 %conv38, %conv40
  br i1 %cmp41, label %if.then43, label %for.inc

if.then43:                                        ; preds = %for.body
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %skip_to_next_endpoint_or_interface_descriptor

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %desc48 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %ifp, i32 0, i32 0
  %bNumEndpoints49 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc48, i32 0, i32 4
  %11 = load i8, i8* %bNumEndpoints49, align 4, !tbaa !172
  %idxprom50 = zext i8 %11 to i64
  %arrayidx51 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %8, i64 %idxprom50
  %desc52 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %ifp, i32 0, i32 0
  %bNumEndpoints53 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc52, i32 0, i32 4
  %12 = load i8, i8* %bNumEndpoints53, align 4, !tbaa !172
  %inc54 = add i8 %12, 1
  store i8 %inc54, i8* %bNumEndpoints53, align 4, !tbaa !172
  %desc55 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx51, i32 0, i32 0
  %13 = bitcast %struct.usb_endpoint_descriptor* %desc55 to i8*
  %14 = bitcast %struct.usb_endpoint_descriptor* %0 to i8*
  %15 = load i32, i32* %n, align 4, !tbaa !73
  %conv56 = sext i32 %15 to i64
  %call = call i8* @__memcpy(i8* %13, i8* %14, i64 %conv56)
  %urb_list = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx51, i32 0, i32 4
  call void @INIT_LIST_HEAD.485(%struct.list_head* %urb_list)
  %call57 = call i32 @usb_endpoint_xfer_int.486(%struct.usb_endpoint_descriptor* %0)
  %tobool = icmp ne i32 %call57, 0
  br i1 %tobool, label %if.then58, label %if.else121

if.then58:                                        ; preds = %for.end
  %16 = bitcast %struct.device* %ddev to i8*
  %add.ptr59 = getelementptr inbounds i8, i8* %16, i64 -152
  %17 = bitcast i8* %add.ptr59 to %struct.usb_device*
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %17, i32 0, i32 4
  %18 = load i32, i32* %speed, align 4, !tbaa !177
  %Pivot = icmp slt i32 %18, 5
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.then58
  %.off = add i32 %18, -5
  %SwitchLeaf2 = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.default

LeafBlock:                                        ; preds = %if.then58
  %SwitchLeaf = icmp eq i32 %18, 3
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock, %LeafBlock1
  %bInterval = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 5
  %19 = load i8, i8* %bInterval, align 1, !tbaa !310
  %conv60 = zext i8 %19 to i32
  %mul = mul nsw i32 %conv60, 8
  %20 = call i32 asm "bsrl $1,$0", "=r,rm,0,~{dirflag},~{fpsr},~{flags}"(i32 %mul, i32 -1) #9, !srcloc !587
  %add.i2 = add nsw i32 %20, 1
  store i32 %add.i2, i32* %n, align 4, !tbaa !73
  %21 = load i32, i32* %n, align 4, !tbaa !73
  %cmp62 = icmp eq i32 %21, 0
  %.call61 = select i1 %cmp62, i32 7, i32 %add.i2
  store i32 %.call61, i32* %n, align 4
  %22 = bitcast %struct.device* %ddev to i8*
  %add.ptr68 = getelementptr inbounds i8, i8* %22, i64 -152
  %23 = bitcast i8* %add.ptr68 to %struct.usb_device*
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %23, i32 0, i32 29
  %24 = load i32, i32* %quirks, align 4, !tbaa !199
  %conv69 = zext i32 %24 to i64
  %and70 = and i64 %conv69, 2048
  %tobool71 = icmp ne i64 %and70, 0
  br i1 %tobool71, label %if.then72, label %if.end90

if.then72:                                        ; preds = %sw.bb
  %bInterval73 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 5
  %25 = load i8, i8* %bInterval73, align 1, !tbaa !310
  %conv74 = zext i8 %25 to i32
  %26 = call i32 asm "bsrl $1,$0", "=r,rm,0,~{dirflag},~{fpsr},~{flags}"(i32 %conv74, i32 -1) #9, !srcloc !587
  %add.i1 = add nsw i32 %26, 1
  %add = add nsw i32 %add.i1, 3
  store i32 %add, i32* %__UNIQUE_ID_max1_12, align 4, !tbaa !73
  store i32 1, i32* %__UNIQUE_ID_max2_13, align 4, !tbaa !73
  %27 = load i32, i32* %__UNIQUE_ID_max1_12, align 4, !tbaa !73
  %28 = load i32, i32* %__UNIQUE_ID_max2_13, align 4, !tbaa !73
  %cmp79 = icmp sgt i32 %27, %28
  %29 = load i32, i32* %__UNIQUE_ID_max1_12, align 4
  %30 = load i32, i32* %__UNIQUE_ID_max2_13, align 4
  %cond = select i1 %cmp79, i32 %29, i32 %30
  store i32 %cond, i32* %__UNIQUE_ID_min1_14, align 4, !tbaa !73
  store i32 16, i32* %__UNIQUE_ID_min2_15, align 4, !tbaa !73
  %31 = load i32, i32* %__UNIQUE_ID_min1_14, align 4, !tbaa !73
  %32 = load i32, i32* %__UNIQUE_ID_min2_15, align 4, !tbaa !73
  %cmp84 = icmp slt i32 %31, %32
  %33 = load i32, i32* %__UNIQUE_ID_min1_14, align 4
  %34 = load i32, i32* %__UNIQUE_ID_min2_15, align 4
  %cond89 = select i1 %cmp84, i32 %33, i32 %34
  store i32 %cond89, i32* %n, align 4, !tbaa !73
  %35 = load i32, i32* %n, align 4, !tbaa !73
  br label %if.end90

if.end90:                                         ; preds = %if.then72, %sw.bb
  %i.1 = phi i32 [ %35, %if.then72 ], [ 1, %sw.bb ]
  %j.0 = phi i32 [ %35, %if.then72 ], [ 16, %sw.bb ]
  %36 = bitcast %struct.device* %ddev to i8*
  %add.ptr93 = getelementptr inbounds i8, i8* %36, i64 -152
  %37 = bitcast i8* %add.ptr93 to %struct.usb_device*
  %quirks94 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %37, i32 0, i32 29
  %38 = load i32, i32* %quirks94, align 4, !tbaa !199
  %conv95 = zext i32 %38 to i64
  %and96 = and i64 %conv95, 128
  %tobool97 = icmp ne i64 %and96, 0
  br i1 %tobool97, label %if.then98, label %if.end133

if.then98:                                        ; preds = %if.end90
  %bInterval99 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 5
  %39 = load i8, i8* %bInterval99, align 1, !tbaa !310
  %conv100 = zext i8 %39 to i32
  %40 = call i32 asm "bsrl $1,$0", "=r,rm,0,~{dirflag},~{fpsr},~{flags}"(i32 %conv100, i32 -1) #9, !srcloc !587
  %add.i = add nsw i32 %40, 1
  store i32 %add.i, i32* %__UNIQUE_ID_max1_16, align 4, !tbaa !73
  store i32 %i.1, i32* %__UNIQUE_ID_max2_17, align 4, !tbaa !73
  %41 = load i32, i32* %__UNIQUE_ID_max1_16, align 4, !tbaa !73
  %42 = load i32, i32* %__UNIQUE_ID_max2_17, align 4, !tbaa !73
  %cmp105 = icmp sgt i32 %41, %42
  %43 = load i32, i32* %__UNIQUE_ID_max1_16, align 4
  %44 = load i32, i32* %__UNIQUE_ID_max2_17, align 4
  %cond110 = select i1 %cmp105, i32 %43, i32 %44
  store i32 %cond110, i32* %__UNIQUE_ID_min1_18, align 4, !tbaa !73
  store i32 %j.0, i32* %__UNIQUE_ID_min2_19, align 4, !tbaa !73
  %45 = load i32, i32* %__UNIQUE_ID_min1_18, align 4, !tbaa !73
  %46 = load i32, i32* %__UNIQUE_ID_min2_19, align 4, !tbaa !73
  %cmp114 = icmp slt i32 %45, %46
  %47 = load i32, i32* %__UNIQUE_ID_min1_18, align 4
  %48 = load i32, i32* %__UNIQUE_ID_min2_19, align 4
  %cond119 = select i1 %cmp114, i32 %47, i32 %48
  store i32 %cond119, i32* %n, align 4, !tbaa !73
  %49 = load i32, i32* %n, align 4, !tbaa !73
  br label %if.end133

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  store i32 10, i32* %n, align 4, !tbaa !73
  br label %if.end133

if.else121:                                       ; preds = %for.end
  %call122 = call i32 @usb_endpoint_xfer_isoc.488(%struct.usb_endpoint_descriptor* %0)
  %tobool123 = icmp ne i32 %call122, 0
  br i1 %tobool123, label %if.then124, label %if.end133

if.then124:                                       ; preds = %if.else121
  %50 = bitcast %struct.device* %ddev to i8*
  %add.ptr127 = getelementptr inbounds i8, i8* %50, i64 -152
  %51 = bitcast i8* %add.ptr127 to %struct.usb_device*
  %speed128 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %51, i32 0, i32 4
  %52 = load i32, i32* %speed128, align 4, !tbaa !177
  %SwitchLeaf5 = icmp eq i32 %52, 3
  br i1 %SwitchLeaf5, label %sw.bb129, label %sw.default130

sw.bb129:                                         ; preds = %if.then124
  store i32 7, i32* %n, align 4, !tbaa !73
  br label %if.end133

sw.default130:                                    ; preds = %if.then124
  store i32 4, i32* %n, align 4, !tbaa !73
  br label %if.end133

if.end133:                                        ; preds = %sw.default130, %sw.bb129, %if.else121, %sw.default, %if.then98, %if.end90
  %i.5 = phi i32 [ 1, %sw.default ], [ %49, %if.then98 ], [ %i.1, %if.end90 ], [ 0, %if.else121 ], [ 1, %sw.default130 ], [ 1, %sw.bb129 ]
  %j.4 = phi i32 [ 255, %sw.default ], [ %49, %if.then98 ], [ %j.0, %if.end90 ], [ 255, %if.else121 ], [ 16, %sw.default130 ], [ 16, %sw.bb129 ]
  %bInterval134 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 5
  %53 = load i8, i8* %bInterval134, align 1, !tbaa !310
  %conv135 = zext i8 %53 to i32
  %cmp136 = icmp slt i32 %conv135, %i.5
  br i1 %cmp136, label %if.then143, label %lor.lhs.false138

lor.lhs.false138:                                 ; preds = %if.end133
  %bInterval139 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 5
  %54 = load i8, i8* %bInterval139, align 1, !tbaa !310
  %conv140 = zext i8 %54 to i32
  %cmp141 = icmp sgt i32 %conv140, %j.4
  br i1 %cmp141, label %if.then143, label %if.end151

if.then143:                                       ; preds = %lor.lhs.false138, %if.end133
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %55 = load i32, i32* %n, align 4, !tbaa !73
  %conv148 = trunc i32 %55 to i8
  %desc149 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx51, i32 0, i32 0
  %bInterval150 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc149, i32 0, i32 5
  store i8 %conv148, i8* %bInterval150, align 2, !tbaa !531
  br label %if.end151

if.end151:                                        ; preds = %if.then143, %lor.lhs.false138
  %56 = bitcast %struct.device* %ddev to i8*
  %add.ptr154 = getelementptr inbounds i8, i8* %56, i64 -152
  %57 = bitcast i8* %add.ptr154 to %struct.usb_device*
  %speed155 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %57, i32 0, i32 4
  %58 = load i32, i32* %speed155, align 4, !tbaa !177
  %cmp156 = icmp eq i32 %58, 1
  br i1 %cmp156, label %land.lhs.true, label %if.end173

land.lhs.true:                                    ; preds = %if.end151
  %call158 = call i32 @usb_endpoint_xfer_bulk.490(%struct.usb_endpoint_descriptor* %0)
  %tobool159 = icmp ne i32 %call158, 0
  br i1 %tobool159, label %if.then160, label %if.end173

if.then160:                                       ; preds = %land.lhs.true
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %desc163 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx51, i32 0, i32 0
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc163, i32 0, i32 3
  store i8 3, i8* %bmAttributes, align 1, !tbaa !530
  %desc164 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx51, i32 0, i32 0
  %bInterval165 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc164, i32 0, i32 5
  store i8 1, i8* %bInterval165, align 2, !tbaa !531
  %desc166 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx51, i32 0, i32 0
  %call167 = call i32 @usb_endpoint_maxp.492(%struct.usb_endpoint_descriptor* %desc166)
  %cmp168 = icmp sgt i32 %call167, 8
  br i1 %cmp168, label %if.then170, label %if.end173

if.then170:                                       ; preds = %if.then160
  %desc171 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx51, i32 0, i32 0
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc171, i32 0, i32 4
  store i16 8, i16* %wMaxPacketSize, align 4, !tbaa !588
  br label %if.end173

if.end173:                                        ; preds = %if.then170, %if.then160, %land.lhs.true, %if.end151
  %desc174 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx51, i32 0, i32 0
  %call175 = call i32 @usb_endpoint_maxp.492(%struct.usb_endpoint_descriptor* %desc174)
  %59 = bitcast %struct.device* %ddev to i8*
  %add.ptr178 = getelementptr inbounds i8, i8* %59, i64 -152
  %60 = bitcast i8* %add.ptr178 to %struct.usb_device*
  %speed179 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %60, i32 0, i32 4
  %61 = load i32, i32* %speed179, align 4, !tbaa !177
  %Pivot19 = icmp slt i32 %61, 3
  br i1 %Pivot19, label %NodeBlock9, label %NodeBlock16

NodeBlock16:                                      ; preds = %if.end173
  %Pivot17 = icmp slt i32 %61, 5
  br i1 %Pivot17, label %LeafBlock11, label %LeafBlock13

LeafBlock13:                                      ; preds = %NodeBlock16
  %.off14 = add i32 %61, -5
  %SwitchLeaf15 = icmp ule i32 %.off14, 1
  br i1 %SwitchLeaf15, label %sw.epilog196, label %sw.default194

LeafBlock11:                                      ; preds = %NodeBlock16
  %SwitchLeaf12 = icmp eq i32 %61, 3
  br i1 %SwitchLeaf12, label %sw.bb182, label %sw.default194

NodeBlock9:                                       ; preds = %if.end173
  %Pivot10 = icmp slt i32 %61, 2
  br i1 %Pivot10, label %LeafBlock7, label %sw.epilog196

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %61, 1
  br i1 %SwitchLeaf8, label %sw.epilog196, label %sw.default194

sw.bb182:                                         ; preds = %LeafBlock11
  %call183 = call i32 @usb_endpoint_xfer_int.486(%struct.usb_endpoint_descriptor* %0)
  %tobool184 = icmp ne i32 %call183, 0
  br i1 %tobool184, label %if.then188, label %lor.lhs.false185

lor.lhs.false185:                                 ; preds = %sw.bb182
  %call186 = call i32 @usb_endpoint_xfer_isoc.488(%struct.usb_endpoint_descriptor* %0)
  %tobool187 = icmp ne i32 %call186, 0
  br i1 %tobool187, label %if.then188, label %sw.default194

if.then188:                                       ; preds = %lor.lhs.false185, %sw.bb182
  %conv189 = zext i32 %call175 to i64
  %and190 = and i64 %conv189, 6144
  %conv191 = trunc i64 %and190 to i32
  %neg = xor i32 %conv191, -1
  %and192 = and i32 %call175, %neg
  br label %sw.default194

sw.default194:                                    ; preds = %if.then188, %lor.lhs.false185, %LeafBlock7, %LeafBlock11, %LeafBlock13
  %i.7 = phi i32 [ %conv191, %if.then188 ], [ 0, %lor.lhs.false185 ], [ 0, %LeafBlock13 ], [ 0, %LeafBlock11 ], [ 0, %LeafBlock7 ]
  %maxp.1 = phi i32 [ %and192, %if.then188 ], [ %call175, %lor.lhs.false185 ], [ %call175, %LeafBlock13 ], [ %call175, %LeafBlock11 ], [ %call175, %LeafBlock7 ]
  br label %sw.epilog196

sw.epilog196:                                     ; preds = %sw.default194, %LeafBlock7, %NodeBlock9, %LeafBlock13
  %i.8 = phi i32 [ %i.7, %sw.default194 ], [ 0, %LeafBlock7 ], [ 0, %NodeBlock9 ], [ 0, %LeafBlock13 ]
  %maxp.2 = phi i32 [ %maxp.1, %sw.default194 ], [ %call175, %LeafBlock7 ], [ %call175, %NodeBlock9 ], [ %call175, %LeafBlock13 ]
  %maxpacket_maxes.0 = phi i16* [ getelementptr inbounds ([4 x i16], [4 x i16]* @high_speed_maxpacket_maxes, i32 0, i32 0), %sw.default194 ], [ getelementptr inbounds ([4 x i16], [4 x i16]* @low_speed_maxpacket_maxes, i32 0, i32 0), %LeafBlock7 ], [ getelementptr inbounds ([4 x i16], [4 x i16]* @full_speed_maxpacket_maxes, i32 0, i32 0), %NodeBlock9 ], [ getelementptr inbounds ([4 x i16], [4 x i16]* @super_speed_maxpacket_maxes, i32 0, i32 0), %LeafBlock13 ]
  %desc197 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx51, i32 0, i32 0
  %call198 = call i32 @usb_endpoint_type.493(%struct.usb_endpoint_descriptor* %desc197)
  %idxprom199 = sext i32 %call198 to i64
  %arrayidx200 = getelementptr inbounds i16, i16* %maxpacket_maxes.0, i64 %idxprom199
  %62 = load i16, i16* %arrayidx200, align 2, !tbaa !165
  %conv201 = zext i16 %62 to i32
  %cmp202 = icmp ugt i32 %maxp.2, %conv201
  br i1 %cmp202, label %if.then204, label %if.end210

if.then204:                                       ; preds = %sw.epilog196
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %or = or i32 %i.8, %conv201
  %conv207 = trunc i32 %or to i16
  %desc208 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx51, i32 0, i32 0
  %wMaxPacketSize209 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc208, i32 0, i32 4
  store i16 %conv207, i16* %wMaxPacketSize209, align 4, !tbaa !588
  br label %if.end210

if.end210:                                        ; preds = %if.then204, %sw.epilog196
  %maxp.3 = phi i32 [ %conv201, %if.then204 ], [ %maxp.2, %sw.epilog196 ]
  %63 = bitcast %struct.device* %ddev to i8*
  %add.ptr213 = getelementptr inbounds i8, i8* %63, i64 -152
  %64 = bitcast i8* %add.ptr213 to %struct.usb_device*
  %speed214 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %64, i32 0, i32 4
  %65 = load i32, i32* %speed214, align 4, !tbaa !177
  %cmp215 = icmp eq i32 %65, 3
  br i1 %cmp215, label %land.lhs.true217, label %if.end227

land.lhs.true217:                                 ; preds = %if.end210
  %call218 = call i32 @usb_endpoint_xfer_bulk.490(%struct.usb_endpoint_descriptor* %0)
  %tobool219 = icmp ne i32 %call218, 0
  %cmp221 = icmp ne i32 %maxp.3, 512
  %or.cond20 = and i1 %tobool219, %cmp221
  br i1 %or.cond20, label %if.then223, label %if.end227

if.then223:                                       ; preds = %land.lhs.true217
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end227

if.end227:                                        ; preds = %if.then223, %land.lhs.true217, %if.end210
  %66 = bitcast %struct.device* %ddev to i8*
  %add.ptr230 = getelementptr inbounds i8, i8* %66, i64 -152
  %67 = bitcast i8* %add.ptr230 to %struct.usb_device*
  %speed231 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %67, i32 0, i32 4
  %68 = load i32, i32* %speed231, align 4, !tbaa !177
  %cmp232 = icmp uge i32 %68, 5
  br i1 %cmp232, label %if.then234, label %if.end235

if.then234:                                       ; preds = %if.end227
  call void @usb_parse_ss_endpoint_companion(%struct.usb_host_endpoint* %arrayidx51, i8* %add.ptr, i32 %sub)
  br label %if.end235

if.end235:                                        ; preds = %if.then234, %if.end227
  %extra = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx51, i32 0, i32 7
  store i8* %add.ptr, i8** %extra, align 8, !tbaa !589
  %call236 = call i32 @find_next_descriptor(i8* %add.ptr, i32 %sub, i32 5, i32 4, i32* %n)
  %extralen = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx51, i32 0, i32 8
  store i32 %call236, i32* %extralen, align 8, !tbaa !590
  %sub.ptr.lhs.cast = ptrtoint i8* %add.ptr to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %buffer to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv237 = sext i32 %call236 to i64
  %add238 = add nsw i64 %sub.ptr.sub, %conv237
  %conv239 = trunc i64 %add238 to i32
  %69 = load i32, i32* %n, align 4, !tbaa !73
  %cmp240 = icmp sgt i32 %69, 0
  br i1 %cmp240, label %do.body243, label %cleanup

do.body243:                                       ; preds = %if.end235
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_parse_endpoint.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and244 = and i32 %bf.clear, 1
  %tobool245 = icmp ne i32 %and244, 0
  %lnot = xor i1 %tobool245, true
  %lnot246 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot246 to i32
  %conv247 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv247, i64 0)
  %tobool248 = icmp ne i64 %expval, 0
  br i1 %tobool248, label %if.then249, label %cleanup

if.then249:                                       ; preds = %do.body243
  %70 = load i32, i32* %n, align 4, !tbaa !73
  %71 = load i32, i32* %n, align 4, !tbaa !73
  %call250 = call i8* @plural(i32 %71)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_parse_endpoint.descriptor to %struct._ddebug*), %struct.device* %ddev, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.28.475, i32 0, i32 0), i32 %70, i8* %call250, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.44.496, i32 0, i32 0))
  br label %cleanup

skip_to_next_endpoint_or_interface_descriptor:    ; preds = %if.then43, %if.end24, %if.then21, %if.else12
  %call255 = call i32 @find_next_descriptor(i8* %add.ptr, i32 %sub, i32 5, i32 4, i32* null)
  %sub.ptr.lhs.cast256 = ptrtoint i8* %add.ptr to i64
  %sub.ptr.rhs.cast257 = ptrtoint i8* %buffer to i64
  %sub.ptr.sub258 = sub i64 %sub.ptr.lhs.cast256, %sub.ptr.rhs.cast257
  %conv259 = sext i32 %call255 to i64
  %add260 = add nsw i64 %sub.ptr.sub258, %conv259
  %conv261 = trunc i64 %add260 to i32
  br label %cleanup

cleanup:                                          ; preds = %skip_to_next_endpoint_or_interface_descriptor, %if.then249, %do.body243, %if.end235
  %retval.0 = phi i32 [ %conv261, %skip_to_next_endpoint_or_interface_descriptor ], [ %conv239, %do.body243 ], [ %conv239, %if.then249 ], [ %conv239, %if.end235 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.485(%struct.list_head* %list) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !72
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !87
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_int.486(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 3
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_isoc.488(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 1
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_bulk.490(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 2
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_maxp.492(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 4
  %0 = load i16, i16* %wMaxPacketSize, align 1, !tbaa !226
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 2047
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_type.493(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal void @usb_parse_ss_endpoint_companion(%struct.usb_host_endpoint* %ep, i8* %buffer, i32 %size) #0 {
entry:
  %0 = bitcast i8* %buffer to %struct.usb_ss_ep_comp_descriptor*
  %bDescriptorType = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 1
  %1 = load i8, i8* %bDescriptorType, align 1, !tbaa !591
  %conv = zext i8 %1 to i32
  %cmp = icmp ne i32 %conv, 48
  %cmp2 = icmp slt i32 %size, 6
  %or.cond = or i1 %cmp, %cmp2
  br i1 %or.cond, label %if.then, label %if.end16

if.then:                                          ; preds = %entry
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %ss_ep_comp = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %bLength = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp, i32 0, i32 0
  store i8 6, i8* %bLength, align 1, !tbaa !592
  %ss_ep_comp6 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %bDescriptorType7 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp6, i32 0, i32 1
  store i8 48, i8* %bDescriptorType7, align 1, !tbaa !593
  %desc8 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call = call i32 @usb_endpoint_xfer_isoc.488(%struct.usb_endpoint_descriptor* %desc8)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then13, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %if.then
  %desc10 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call11 = call i32 @usb_endpoint_xfer_int.486(%struct.usb_endpoint_descriptor* %desc10)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %cleanup.cont

if.then13:                                        ; preds = %lor.lhs.false9, %if.then
  %desc14 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc14, i32 0, i32 4
  %2 = load i16, i16* %wMaxPacketSize, align 4, !tbaa !588
  %ss_ep_comp15 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %wBytesPerInterval = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp15, i32 0, i32 4
  store i16 %2, i16* %wBytesPerInterval, align 1, !tbaa !594
  br label %cleanup.cont

if.end16:                                         ; preds = %entry
  %bLength17 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 0
  %3 = load i8, i8* %bLength17, align 1, !tbaa !595
  %conv18 = zext i8 %3 to i32
  %idx.ext = sext i32 %conv18 to i64
  %add.ptr = getelementptr inbounds i8, i8* %buffer, i64 %idx.ext
  %bLength19 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 0
  %4 = load i8, i8* %bLength19, align 1, !tbaa !595
  %conv20 = zext i8 %4 to i32
  %sub = sub nsw i32 %size, %conv20
  %ss_ep_comp21 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %5 = bitcast %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp21 to i8*
  %6 = bitcast %struct.usb_ss_ep_comp_descriptor* %0 to i8*
  %call22 = call i8* @__memcpy(i8* %5, i8* %6, i64 6)
  %desc23 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call24 = call i32 @usb_endpoint_xfer_control.500(%struct.usb_endpoint_descriptor* %desc23)
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end16
  %bMaxBurst = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 2
  %7 = load i8, i8* %bMaxBurst, align 1, !tbaa !596
  %conv26 = zext i8 %7 to i32
  %cmp27 = icmp ne i32 %conv26, 0
  br i1 %cmp27, label %if.then29, label %if.else

if.then29:                                        ; preds = %land.lhs.true
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end50.sink.split

if.else:                                          ; preds = %land.lhs.true, %if.end16
  %bMaxBurst37 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 2
  %8 = load i8, i8* %bMaxBurst37, align 1, !tbaa !596
  %conv38 = zext i8 %8 to i32
  %cmp39 = icmp sgt i32 %conv38, 15
  br i1 %cmp39, label %if.then41, label %if.end50

if.then41:                                        ; preds = %if.else
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end50.sink.split

if.end50.sink.split:                              ; preds = %if.then41, %if.then29
  %.sink = phi i8 [ 15, %if.then41 ], [ 0, %if.then29 ]
  %ss_ep_comp47 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %bMaxBurst48 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp47, i32 0, i32 2
  store i8 %.sink, i8* %bMaxBurst48, align 1, !tbaa !473
  br label %if.end50

if.end50:                                         ; preds = %if.end50.sink.split, %if.else
  %desc51 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call52 = call i32 @usb_endpoint_xfer_control.500(%struct.usb_endpoint_descriptor* %desc51)
  %tobool53 = icmp ne i32 %call52, 0
  br i1 %tobool53, label %land.lhs.true58, label %lor.lhs.false54

lor.lhs.false54:                                  ; preds = %if.end50
  %desc55 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call56 = call i32 @usb_endpoint_xfer_int.486(%struct.usb_endpoint_descriptor* %desc55)
  %tobool57 = icmp ne i32 %call56, 0
  br i1 %tobool57, label %land.lhs.true58, label %if.else73

land.lhs.true58:                                  ; preds = %lor.lhs.false54, %if.end50
  %bmAttributes = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 3
  %9 = load i8, i8* %bmAttributes, align 1, !tbaa !597
  %conv59 = zext i8 %9 to i32
  %cmp60 = icmp ne i32 %conv59, 0
  br i1 %cmp60, label %if.then62, label %if.else73

if.then62:                                        ; preds = %land.lhs.true58
  %desc63 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call64 = call i32 @usb_endpoint_xfer_control.500(%struct.usb_endpoint_descriptor* %desc63)
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %ss_ep_comp71 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %bmAttributes72 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp71, i32 0, i32 3
  store i8 0, i8* %bmAttributes72, align 1, !tbaa !474
  br label %if.end114

if.else73:                                        ; preds = %land.lhs.true58, %lor.lhs.false54
  %desc74 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call75 = call i32 @usb_endpoint_xfer_bulk.490(%struct.usb_endpoint_descriptor* %desc74)
  %tobool76 = icmp ne i32 %call75, 0
  br i1 %tobool76, label %land.lhs.true77, label %if.else88

land.lhs.true77:                                  ; preds = %if.else73
  %bmAttributes78 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 3
  %10 = load i8, i8* %bmAttributes78, align 1, !tbaa !597
  %conv79 = zext i8 %10 to i32
  %cmp80 = icmp sgt i32 %conv79, 16
  br i1 %cmp80, label %if.then82, label %if.else88

if.then82:                                        ; preds = %land.lhs.true77
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %ss_ep_comp86 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %bmAttributes87 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp86, i32 0, i32 3
  store i8 16, i8* %bmAttributes87, align 1, !tbaa !474
  br label %if.end114

if.else88:                                        ; preds = %land.lhs.true77, %if.else73
  %desc89 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call90 = call i32 @usb_endpoint_xfer_isoc.488(%struct.usb_endpoint_descriptor* %desc89)
  %tobool91 = icmp ne i32 %call90, 0
  br i1 %tobool91, label %land.lhs.true92, label %if.end114

land.lhs.true92:                                  ; preds = %if.else88
  %bmAttributes93 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 3
  %11 = load i8, i8* %bmAttributes93, align 1, !tbaa !597
  %conv94 = zext i8 %11 to i32
  %and = and i32 %conv94, 128
  %tobool95 = icmp ne i32 %and, 0
  br i1 %tobool95, label %if.end114, label %land.lhs.true96

land.lhs.true96:                                  ; preds = %land.lhs.true92
  %bmAttributes97 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 3
  %12 = load i8, i8* %bmAttributes97, align 1, !tbaa !597
  %conv98 = zext i8 %12 to i32
  %and99 = and i32 %conv98, 3
  %add = add nsw i32 1, %and99
  %cmp100 = icmp sgt i32 %add, 3
  br i1 %cmp100, label %if.then102, label %if.end114

if.then102:                                       ; preds = %land.lhs.true96
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %ss_ep_comp110 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %bmAttributes111 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp110, i32 0, i32 3
  store i8 2, i8* %bmAttributes111, align 1, !tbaa !474
  br label %if.end114

if.end114:                                        ; preds = %if.then102, %land.lhs.true96, %land.lhs.true92, %if.else88, %if.then82, %if.then62
  %desc115 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call116 = call i32 @usb_endpoint_xfer_isoc.488(%struct.usb_endpoint_descriptor* %desc115)
  %tobool117 = icmp ne i32 %call116, 0
  br i1 %tobool117, label %if.then118, label %if.else129

if.then118:                                       ; preds = %if.end114
  %bMaxBurst119 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 2
  %13 = load i8, i8* %bMaxBurst119, align 1, !tbaa !596
  %conv120 = zext i8 %13 to i32
  %add121 = add nsw i32 %conv120, 1
  %bmAttributes122 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 3
  %14 = load i8, i8* %bmAttributes122, align 1, !tbaa !597
  %conv123 = zext i8 %14 to i32
  %and124 = and i32 %conv123, 3
  %add125 = add nsw i32 1, %and124
  %mul = mul nsw i32 %add121, %add125
  %desc126 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call127 = call i32 @usb_endpoint_maxp.492(%struct.usb_endpoint_descriptor* %desc126)
  %mul128 = mul nsw i32 %mul, %call127
  br label %if.end142

if.else129:                                       ; preds = %if.end114
  %desc130 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call131 = call i32 @usb_endpoint_xfer_int.486(%struct.usb_endpoint_descriptor* %desc130)
  %tobool132 = icmp ne i32 %call131, 0
  br i1 %tobool132, label %if.then133, label %if.end142

if.then133:                                       ; preds = %if.else129
  %desc134 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call135 = call i32 @usb_endpoint_maxp.492(%struct.usb_endpoint_descriptor* %desc134)
  %bMaxBurst136 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 2
  %15 = load i8, i8* %bMaxBurst136, align 1, !tbaa !596
  %conv137 = zext i8 %15 to i32
  %add138 = add nsw i32 %conv137, 1
  %mul139 = mul nsw i32 %call135, %add138
  br label %if.end142

if.end142:                                        ; preds = %if.then133, %if.else129, %if.then118
  %max_tx.1 = phi i32 [ %mul128, %if.then118 ], [ %mul139, %if.then133 ], [ 999999, %if.else129 ]
  %wBytesPerInterval143 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 4
  %16 = load i16, i16* %wBytesPerInterval143, align 1, !tbaa !598
  %conv144 = zext i16 %16 to i32
  %cmp145 = icmp sgt i32 %conv144, %max_tx.1
  br i1 %cmp145, label %if.then147, label %if.end160

if.then147:                                       ; preds = %if.end142
  %desc148 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call149 = call i32 @usb_endpoint_xfer_isoc.488(%struct.usb_endpoint_descriptor* %desc148)
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %conv157 = trunc i32 %max_tx.1 to i16
  %ss_ep_comp158 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %wBytesPerInterval159 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp158, i32 0, i32 4
  store i16 %conv157, i16* %wBytesPerInterval159, align 1, !tbaa !594
  br label %if.end160

if.end160:                                        ; preds = %if.then147, %if.end142
  %desc161 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call162 = call i32 @usb_endpoint_xfer_isoc.488(%struct.usb_endpoint_descriptor* %desc161)
  %tobool163 = icmp ne i32 %call162, 0
  br i1 %tobool163, label %land.lhs.true164, label %cleanup.cont

land.lhs.true164:                                 ; preds = %if.end160
  %bmAttributes165 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 3
  %17 = load i8, i8* %bmAttributes165, align 1, !tbaa !597
  %conv166 = zext i8 %17 to i32
  %and167 = and i32 %conv166, 128
  %tobool168 = icmp ne i32 %and167, 0
  br i1 %tobool168, label %if.then169, label %cleanup.cont

if.then169:                                       ; preds = %land.lhs.true164
  call void @usb_parse_ssp_isoc_endpoint_companion(%struct.usb_host_endpoint* %ep, i8* %add.ptr, i32 %sub)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then169, %land.lhs.true164, %if.end160, %if.then13, %lor.lhs.false9
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_control.500(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define internal void @usb_parse_ssp_isoc_endpoint_companion(%struct.usb_host_endpoint* %ep, i8* %buffer, i32 %size) #0 {
entry:
  %0 = bitcast i8* %buffer to %struct.usb_ssp_isoc_ep_comp_descriptor*
  %bDescriptorType = getelementptr inbounds %struct.usb_ssp_isoc_ep_comp_descriptor, %struct.usb_ssp_isoc_ep_comp_descriptor* %0, i32 0, i32 1
  %1 = load i8, i8* %bDescriptorType, align 1, !tbaa !599
  %conv = zext i8 %1 to i32
  %cmp = icmp ne i32 %conv, 49
  %cmp2 = icmp slt i32 %size, 8
  %or.cond = or i1 %cmp, %cmp2
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup.cont

if.end:                                           ; preds = %entry
  %ssp_isoc_ep_comp = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 2
  %2 = bitcast %struct.usb_ssp_isoc_ep_comp_descriptor* %ssp_isoc_ep_comp to i8*
  %3 = bitcast %struct.usb_ssp_isoc_ep_comp_descriptor* %0 to i8*
  %call = call i8* @__memcpy(i8* %2, i8* %3, i64 8)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @refcount_set.513(%struct.qspinlock* %r, i32 %n) #1 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %refs = getelementptr inbounds %struct.qspinlock, %struct.qspinlock* %r, i32 0, i32 0
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  store i32 %n, i32* %__val.i, align 4, !tbaa !72
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %refs, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %0 = bitcast i8* %arraydecay.i to i32*
  %1 = load i32, i32* %0, align 4, !tbaa !73
  store volatile i32 %1, i32* %counter.i, align 4, !tbaa !73
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_release_bos_descriptor(%struct.usb_device* %dev) #0 {
entry:
  %bos = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %0 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos, align 8, !tbaa !166
  %tobool = icmp ne %struct.usb_host_bos* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %bos1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %1 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos1, align 8, !tbaa !166
  %desc = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %1, i32 0, i32 0
  %2 = load %struct.usb_bos_descriptor*, %struct.usb_bos_descriptor** %desc, align 8, !tbaa !189
  %3 = bitcast %struct.usb_bos_descriptor* %2 to i8*
  call void @kfree(i8* %3)
  %bos2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %4 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos2, align 8, !tbaa !166
  %5 = bitcast %struct.usb_host_bos* %4 to i8*
  call void @kfree(i8* %5)
  %bos3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  store %struct.usb_host_bos* null, %struct.usb_host_bos** %bos3, align 8, !tbaa !166
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_get_bos_descriptor(%struct.usb_device* %dev) #0 {
entry:
  %call = call i8* @kzalloc.452(i64 5, i32 20971712)
  %0 = bitcast i8* %call to %struct.usb_bos_descriptor*
  %tobool = icmp ne %struct.usb_bos_descriptor* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %1 = bitcast %struct.usb_bos_descriptor* %0 to i8*
  %call2 = call i32 @usb_get_descriptor(%struct.usb_device* %dev, i8 zeroext 15, i8 zeroext 0, i8* %1, i32 5)
  %cmp = icmp slt i32 %call2, 5
  br i1 %cmp, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.end
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %cmp4 = icmp sge i32 %call2, 0
  %.call2 = select i1 %cmp4, i32 -42, i32 %call2
  %2 = bitcast %struct.usb_bos_descriptor* %0 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

if.end7:                                          ; preds = %if.end
  %bLength = getelementptr inbounds %struct.usb_bos_descriptor, %struct.usb_bos_descriptor* %0, i32 0, i32 0
  %3 = load i8, i8* %bLength, align 1, !tbaa !600
  %conv = zext i8 %3 to i32
  %wTotalLength = getelementptr inbounds %struct.usb_bos_descriptor, %struct.usb_bos_descriptor* %0, i32 0, i32 2
  %4 = load i16, i16* %wTotalLength, align 1, !tbaa !191
  %conv8 = zext i16 %4 to i32
  %bNumDeviceCaps = getelementptr inbounds %struct.usb_bos_descriptor, %struct.usb_bos_descriptor* %0, i32 0, i32 3
  %5 = load i8, i8* %bNumDeviceCaps, align 1, !tbaa !601
  %conv9 = zext i8 %5 to i32
  %6 = bitcast %struct.usb_bos_descriptor* %0 to i8*
  call void @kfree(i8* %6)
  %cmp10 = icmp slt i32 %conv8, %conv
  br i1 %cmp10, label %cleanup, label %if.end13

if.end13:                                         ; preds = %if.end7
  %call14 = call i8* @kzalloc.452(i64 48, i32 20971712)
  %7 = bitcast i8* %call14 to %struct.usb_host_bos*
  %bos15 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  store %struct.usb_host_bos* %7, %struct.usb_host_bos** %bos15, align 8, !tbaa !166
  %bos16 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %8 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos16, align 8, !tbaa !166
  %tobool17 = icmp ne %struct.usb_host_bos* %8, null
  br i1 %tobool17, label %if.end19, label %cleanup

if.end19:                                         ; preds = %if.end13
  %conv20 = sext i32 %conv8 to i64
  %call21 = call i8* @kzalloc.452(i64 %conv20, i32 20971712)
  %tobool22 = icmp ne i8* %call21, null
  br i1 %tobool22, label %if.end24, label %err

if.end24:                                         ; preds = %if.end19
  %9 = bitcast i8* %call21 to %struct.usb_bos_descriptor*
  %bos25 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %10 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos25, align 8, !tbaa !166
  %desc = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %10, i32 0, i32 0
  store %struct.usb_bos_descriptor* %9, %struct.usb_bos_descriptor** %desc, align 8, !tbaa !189
  %call26 = call i32 @usb_get_descriptor(%struct.usb_device* %dev, i8 zeroext 15, i8 zeroext 0, i8* %call21, i32 %conv8)
  %cmp27 = icmp slt i32 %call26, %conv8
  br i1 %cmp27, label %if.then29, label %if.end34

if.then29:                                        ; preds = %if.end24
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %cmp30 = icmp sge i32 %call26, 0
  %.call26 = select i1 %cmp30, i32 -42, i32 %call26
  br label %err

if.end34:                                         ; preds = %if.end24
  %sub = sub nsw i32 %conv8, %conv
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end34
  %length.0 = phi i32 [ %conv, %if.end34 ], [ %conv38, %for.inc ]
  %buffer.0 = phi i8* [ %call21, %if.end34 ], [ %add.ptr, %for.inc ]
  %total_len.0 = phi i32 [ %sub, %if.end34 ], [ %sub43, %for.inc ]
  %i.0 = phi i32 [ 0, %if.end34 ], [ %inc, %for.inc ]
  %cmp35 = icmp slt i32 %i.0, %conv9
  br i1 %cmp35, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %idx.ext = sext i32 %length.0 to i64
  %add.ptr = getelementptr inbounds i8, i8* %buffer.0, i64 %idx.ext
  %11 = bitcast i8* %add.ptr to %struct.usb_ptm_cap_descriptor*
  %bLength37 = getelementptr inbounds %struct.usb_ptm_cap_descriptor, %struct.usb_ptm_cap_descriptor* %11, i32 0, i32 0
  %12 = load i8, i8* %bLength37, align 1, !tbaa !602
  %conv38 = zext i8 %12 to i32
  %cmp39 = icmp slt i32 %total_len.0, %conv38
  br i1 %cmp39, label %cleanup, label %if.end42

if.end42:                                         ; preds = %for.body
  %sub43 = sub nsw i32 %total_len.0, %conv38
  %bDescriptorType = getelementptr inbounds %struct.usb_ptm_cap_descriptor, %struct.usb_ptm_cap_descriptor* %11, i32 0, i32 1
  %13 = load i8, i8* %bDescriptorType, align 1, !tbaa !604
  %conv44 = zext i8 %13 to i32
  %cmp45 = icmp ne i32 %conv44, 16
  br i1 %cmp45, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.end42
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.inc

if.end48:                                         ; preds = %if.end42
  %bDevCapabilityType = getelementptr inbounds %struct.usb_ptm_cap_descriptor, %struct.usb_ptm_cap_descriptor* %11, i32 0, i32 2
  %14 = load i8, i8* %bDevCapabilityType, align 1, !tbaa !605
  %conv49 = zext i8 %14 to i32
  %Pivot12 = icmp slt i32 %conv49, 4
  br i1 %Pivot12, label %NodeBlock1, label %NodeBlock9

NodeBlock9:                                       ; preds = %if.end48
  %Pivot10 = icmp slt i32 %conv49, 10
  br i1 %Pivot10, label %LeafBlock3, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %conv49, 11
  br i1 %Pivot8, label %sw.bb53, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %conv49, 11
  br i1 %SwitchLeaf6, label %sw.bb57, label %for.inc

LeafBlock3:                                       ; preds = %NodeBlock9
  %SwitchLeaf4 = icmp eq i32 %conv49, 4
  br i1 %SwitchLeaf4, label %sw.bb55, label %for.inc

NodeBlock1:                                       ; preds = %if.end48
  %Pivot2 = icmp slt i32 %conv49, 2
  br i1 %Pivot2, label %for.inc, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %conv49, 3
  br i1 %Pivot, label %sw.bb, label %sw.bb51

sw.bb:                                            ; preds = %NodeBlock
  %15 = bitcast i8* %add.ptr to %struct.usb_ext_cap_descriptor*
  %bos50 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %16 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos50, align 8, !tbaa !166
  %ext_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %16, i32 0, i32 1
  store %struct.usb_ext_cap_descriptor* %15, %struct.usb_ext_cap_descriptor** %ext_cap, align 8, !tbaa !227
  br label %for.inc

sw.bb51:                                          ; preds = %NodeBlock
  %17 = bitcast i8* %add.ptr to %struct.usb_ss_cap_descriptor*
  %bos52 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %18 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos52, align 8, !tbaa !166
  %ss_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %18, i32 0, i32 2
  store %struct.usb_ss_cap_descriptor* %17, %struct.usb_ss_cap_descriptor** %ss_cap, align 8, !tbaa !206
  br label %for.inc

sw.bb53:                                          ; preds = %NodeBlock7
  %19 = bitcast i8* %add.ptr to %struct.usb_ssp_cap_descriptor*
  %bos54 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %20 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos54, align 8, !tbaa !166
  %ssp_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %20, i32 0, i32 3
  store %struct.usb_ssp_cap_descriptor* %19, %struct.usb_ssp_cap_descriptor** %ssp_cap, align 8, !tbaa !236
  br label %for.inc

sw.bb55:                                          ; preds = %LeafBlock3
  %21 = bitcast i8* %add.ptr to %struct.usb_ss_container_id_descriptor*
  %bos56 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %22 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos56, align 8, !tbaa !166
  %ss_id = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %22, i32 0, i32 4
  store %struct.usb_ss_container_id_descriptor* %21, %struct.usb_ss_container_id_descriptor** %ss_id, align 8, !tbaa !606
  br label %for.inc

sw.bb57:                                          ; preds = %LeafBlock5
  %23 = bitcast i8* %add.ptr to %struct.usb_ptm_cap_descriptor*
  %bos58 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %24 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos58, align 8, !tbaa !166
  %ptm_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %24, i32 0, i32 5
  store %struct.usb_ptm_cap_descriptor* %23, %struct.usb_ptm_cap_descriptor** %ptm_cap, align 8, !tbaa !607
  br label %for.inc

for.inc:                                          ; preds = %sw.bb57, %sw.bb55, %sw.bb53, %sw.bb51, %sw.bb, %NodeBlock1, %LeafBlock3, %LeafBlock5, %if.then47
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

err:                                              ; preds = %if.then29, %if.end19
  %ret.2 = phi i32 [ %.call26, %if.then29 ], [ -12, %if.end19 ]
  call void @usb_release_bos_descriptor(%struct.usb_device* %dev)
  br label %cleanup

cleanup:                                          ; preds = %err, %for.body, %for.cond, %if.end13, %if.end7, %if.then3, %entry
  %retval.0 = phi i32 [ %.call2, %if.then3 ], [ %ret.2, %err ], [ -12, %entry ], [ -22, %if.end7 ], [ -12, %if.end13 ], [ 0, %for.cond ], [ 0, %for.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_deregister_dev(%struct.usb_interface* %intf, %struct.usb_class_driver* %class_driver) #0 {
entry:
  %minor = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  %0 = load i32, i32* %minor, align 8, !tbaa !96
  %cmp = icmp eq i32 %0, -1
  br i1 %cmp, label %return, label %do.body1

do.body1:                                         ; preds = %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_deregister_dev.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.end7

if.then4:                                         ; preds = %do.body1
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %minor5 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  %1 = load i32, i32* %minor5, align 8, !tbaa !96
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_deregister_dev.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.6.525, i32 0, i32 0), i32 %1)
  br label %do.end7

do.end7:                                          ; preds = %if.then4, %do.body1
  call void @down_write(%struct.rw_semaphore* @minor_rwsem)
  %minor8 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  %2 = load i32, i32* %minor8, align 8, !tbaa !96
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.file_operations*], [256 x %struct.file_operations*]* @usb_minors, i64 0, i64 %idxprom
  store %struct.file_operations* null, %struct.file_operations** %arrayidx, align 8, !tbaa !52
  call void @up_write(%struct.rw_semaphore* @minor_rwsem)
  %3 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !52
  %class = getelementptr inbounds %struct.usb_class, %struct.usb_class* %3, i32 0, i32 1
  %4 = load %struct.class*, %struct.class** %class, align 8, !tbaa !608
  %minor9 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  %5 = load i32, i32* %minor9, align 8, !tbaa !96
  %or = or i32 188743680, %5
  call void @device_destroy(%struct.class* %4, i32 %or)
  %usb_dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 8
  store %struct.device* null, %struct.device** %usb_dev, align 8, !tbaa !610
  %minor10 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  store i32 -1, i32* %minor10, align 8, !tbaa !96
  call void @destroy_usb_class()
  br label %return

return:                                           ; preds = %do.end7, %entry
  ret void
}

declare void @down_write(%struct.rw_semaphore*) #2

declare void @up_write(%struct.rw_semaphore*) #2

declare void @device_destroy(%struct.class*, i32) #2

; Function Attrs: nounwind uwtable
define internal void @destroy_usb_class() #0 {
entry:
  %0 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !52
  %tobool = icmp ne %struct.usb_class* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !52
  %kref = getelementptr inbounds %struct.usb_class, %struct.usb_class* %1, i32 0, i32 0
  call void @kref_put.526(%struct.kref* %kref, void (%struct.kref*)* @release_usb_class)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @release_usb_class(%struct.kref* %kref) #0 {
entry:
  %0 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !52
  %class = getelementptr inbounds %struct.usb_class, %struct.usb_class* %0, i32 0, i32 1
  %1 = load %struct.class*, %struct.class** %class, align 8, !tbaa !608
  call void @class_destroy(%struct.class* %1)
  %2 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !52
  %3 = bitcast %struct.usb_class* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.usb_class* null, %struct.usb_class** @usb_class, align 8, !tbaa !52
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put.526(%struct.kref* %kref, void (%struct.kref*)* %release) #1 {
entry:
  %cmp = icmp eq void (%struct.kref*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.11.527, i32 0, i32 0), i32 69)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  %call = call zeroext i1 @refcount_dec_and_test(%struct.qspinlock* %refcount)
  br i1 %call, label %if.then14, label %return

if.then14:                                        ; preds = %if.end
  call void %release(%struct.kref* %kref)
  br label %return

return:                                           ; preds = %if.then14, %if.end
  ret void
}

declare void @class_destroy(%struct.class*) #2

; Function Attrs: nounwind uwtable
define i32 @usb_register_dev(%struct.usb_interface* %intf, %struct.usb_class_driver* %class_driver) #0 {
entry:
  %name = alloca [20 x i8], align 16
  %fops = getelementptr inbounds %struct.usb_class_driver, %struct.usb_class_driver* %class_driver, i32 0, i32 2
  %0 = load %struct.file_operations*, %struct.file_operations** %fops, align 8, !tbaa !611
  %cmp = icmp eq %struct.file_operations* %0, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %minor3 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  %1 = load i32, i32* %minor3, align 8, !tbaa !96
  %cmp4 = icmp sge i32 %1, 0
  br i1 %cmp4, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %call = call i32 @init_usb_class()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %do.body9

do.body9:                                         ; preds = %if.end6
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_register_dev.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool10 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.then13, label %do.end16

if.then13:                                        ; preds = %do.body9
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_register_dev.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.4.532, i32 0, i32 0), i32 0)
  br label %do.end16

do.end16:                                         ; preds = %if.then13, %do.body9
  call void @down_write(%struct.rw_semaphore* @minor_rwsem)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end16
  %minor.0 = phi i32 [ 0, %do.end16 ], [ %inc, %for.inc ]
  %cmp17 = icmp slt i32 %minor.0, 256
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %minor.0 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.file_operations*], [256 x %struct.file_operations*]* @usb_minors, i64 0, i64 %idxprom
  %2 = load %struct.file_operations*, %struct.file_operations** %arrayidx, align 8, !tbaa !52
  %tobool19 = icmp ne %struct.file_operations* %2, null
  br i1 %tobool19, label %for.inc, label %if.end21

if.end21:                                         ; preds = %for.body
  %fops22 = getelementptr inbounds %struct.usb_class_driver, %struct.usb_class_driver* %class_driver, i32 0, i32 2
  %3 = load %struct.file_operations*, %struct.file_operations** %fops22, align 8, !tbaa !611
  %idxprom23 = sext i32 %minor.0 to i64
  %arrayidx24 = getelementptr inbounds [256 x %struct.file_operations*], [256 x %struct.file_operations*]* @usb_minors, i64 0, i64 %idxprom23
  store %struct.file_operations* %3, %struct.file_operations** %arrayidx24, align 8, !tbaa !52
  %minor25 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  store i32 %minor.0, i32* %minor25, align 8, !tbaa !96
  br label %for.end

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %minor.0, 1
  br label %for.cond

for.end:                                          ; preds = %if.end21, %for.cond
  call void @up_write(%struct.rw_semaphore* @minor_rwsem)
  %minor26 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  %4 = load i32, i32* %minor26, align 8, !tbaa !96
  %cmp27 = icmp slt i32 %4, 0
  br i1 %cmp27, label %cleanup, label %if.end30

if.end30:                                         ; preds = %for.end
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %name, i32 0, i32 0
  %name31 = getelementptr inbounds %struct.usb_class_driver, %struct.usb_class_driver* %class_driver, i32 0, i32 0
  %5 = load i8*, i8** %name31, align 8, !tbaa !613
  %sub = sub nsw i32 %minor.0, 0
  %call32 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 20, i8* %5, i32 %sub)
  %6 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !52
  %class = getelementptr inbounds %struct.usb_class, %struct.usb_class* %6, i32 0, i32 1
  %7 = load %struct.class*, %struct.class** %class, align 8, !tbaa !608
  %dev33 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %or = or i32 188743680, %minor.0
  %8 = bitcast %struct.usb_class_driver* %class_driver to i8*
  %arraydecay34 = getelementptr inbounds [20 x i8], [20 x i8]* %name, i32 0, i32 0
  %call35 = call i8* @kbasename(i8* %arraydecay34)
  %call36 = call %struct.device* (%struct.class*, %struct.device*, i32, i8*, i8*, ...) @device_create(%struct.class* %7, %struct.device* %dev33, i32 %or, i8* %8, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.5.533, i32 0, i32 0), i8* %call35)
  %usb_dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 8
  store %struct.device* %call36, %struct.device** %usb_dev, align 8, !tbaa !610
  %usb_dev37 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 8
  %9 = load %struct.device*, %struct.device** %usb_dev37, align 8, !tbaa !610
  %10 = bitcast %struct.device* %9 to i8*
  %call38 = call zeroext i1 @IS_ERR.534(i8* %10)
  br i1 %call38, label %if.then39, label %cleanup

if.then39:                                        ; preds = %if.end30
  call void @down_write(%struct.rw_semaphore* @minor_rwsem)
  %idxprom40 = sext i32 %minor.0 to i64
  %arrayidx41 = getelementptr inbounds [256 x %struct.file_operations*], [256 x %struct.file_operations*]* @usb_minors, i64 0, i64 %idxprom40
  store %struct.file_operations* null, %struct.file_operations** %arrayidx41, align 8, !tbaa !52
  %minor42 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  store i32 -1, i32* %minor42, align 8, !tbaa !96
  call void @up_write(%struct.rw_semaphore* @minor_rwsem)
  %usb_dev43 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 8
  %11 = load %struct.device*, %struct.device** %usb_dev43, align 8, !tbaa !610
  %12 = bitcast %struct.device* %11 to i8*
  %call44 = call i64 @PTR_ERR.535(i8* %12)
  %conv45 = trunc i64 %call44 to i32
  br label %cleanup

cleanup:                                          ; preds = %if.then39, %if.end30, %for.end, %if.end6, %if.end, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -98, %if.end ], [ %call, %if.end6 ], [ -54, %for.end ], [ %conv45, %if.then39 ], [ %call, %if.end30 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @init_usb_class() #0 {
entry:
  %0 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !52
  %cmp = icmp ne %struct.usb_class* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !52
  %kref = getelementptr inbounds %struct.usb_class, %struct.usb_class* %1, i32 0, i32 0
  call void @kref_get.536(%struct.kref* %kref)
  br label %exit

if.end:                                           ; preds = %entry
  %call.i = call noalias i8* @__kmalloc(i64 16, i32 20971712) #8
  %2 = bitcast i8* %call.i to %struct.usb_class*
  store %struct.usb_class* %2, %struct.usb_class** @usb_class, align 8, !tbaa !52
  %3 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !52
  %tobool = icmp ne %struct.usb_class* %3, null
  br i1 %tobool, label %if.end2, label %exit

if.end2:                                          ; preds = %if.end
  %4 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !52
  %kref3 = getelementptr inbounds %struct.usb_class, %struct.usb_class* %4, i32 0, i32 0
  call void @kref_init.538(%struct.kref* %kref3)
  %call4 = call %struct.class* @__class_create(%struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7.539, i32 0, i32 0), %struct.lock_class_key* @init_usb_class.__key)
  %5 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !52
  %class = getelementptr inbounds %struct.usb_class, %struct.usb_class* %5, i32 0, i32 1
  store %struct.class* %call4, %struct.class** %class, align 8, !tbaa !608
  %6 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !52
  %class5 = getelementptr inbounds %struct.usb_class, %struct.usb_class* %6, i32 0, i32 1
  %7 = load %struct.class*, %struct.class** %class5, align 8, !tbaa !608
  %8 = bitcast %struct.class* %7 to i8*
  %call6 = call zeroext i1 @IS_ERR.534(i8* %8)
  %9 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !52
  %class8 = getelementptr inbounds %struct.usb_class, %struct.usb_class* %9, i32 0, i32 1
  %10 = load %struct.class*, %struct.class** %class8, align 8, !tbaa !608
  br i1 %call6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end2
  %11 = bitcast %struct.class* %10 to i8*
  %call9 = call i64 @PTR_ERR.535(i8* %11)
  %conv = trunc i64 %call9 to i32
  %12 = call i32 (i8*, ...) @printk(i8* null)
  %13 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !52
  %14 = bitcast %struct.usb_class* %13 to i8*
  call void @kfree(i8* %14)
  store %struct.usb_class* null, %struct.usb_class** @usb_class, align 8, !tbaa !52
  br label %exit

if.end11:                                         ; preds = %if.end2
  %devnode = getelementptr inbounds %struct.class, %struct.class* %10, i32 0, i32 7
  store i8* (%struct.device*, i16*)* @usb_devnode.541, i8* (%struct.device*, i16*)** %devnode, align 8, !tbaa !614
  br label %exit

exit:                                             ; preds = %if.end11, %if.then7, %if.end, %if.then
  %result.0 = phi i32 [ 0, %if.then ], [ %conv, %if.then7 ], [ 0, %if.end11 ], [ -12, %if.end ]
  ret i32 %result.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kbasename(i8* %path) #1 {
entry:
  %call = call i8* @strrchr(i8* %path, i32 47)
  %tobool = icmp ne i8* %call, null
  %add.ptr = getelementptr inbounds i8, i8* %call, i64 1
  %cond = select i1 %tobool, i8* %add.ptr, i8* %path
  ret i8* %cond
}

declare %struct.device* @device_create(%struct.class*, %struct.device*, i32, i8*, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR.534(i8* %ptr) #1 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  ret i1 %tobool
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR.535(i8* %ptr) #1 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

declare i8* @strrchr(i8*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_get.536(%struct.kref* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  call void @refcount_inc(%struct.qspinlock* %refcount)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_init.538(%struct.kref* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.kref, %struct.kref* %kref, i32 0, i32 0
  call void @refcount_set.543(%struct.qspinlock* %refcount, i32 1)
  ret void
}

declare %struct.class* @__class_create(%struct.module*, i8*, %struct.lock_class_key*) #2

; Function Attrs: nounwind uwtable
define internal i8* @usb_devnode.541(%struct.device* %dev, i16* %mode) #0 {
entry:
  %call = call i8* @dev_get_drvdata.542(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.usb_class_driver*
  %tobool = icmp ne %struct.usb_class_driver* %0, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %devnode = getelementptr inbounds %struct.usb_class_driver, %struct.usb_class_driver* %0, i32 0, i32 1
  %1 = load i8* (%struct.device*, i16*)*, i8* (%struct.device*, i16*)** %devnode, align 8, !tbaa !616
  %tobool1 = icmp ne i8* (%struct.device*, i16*)* %1, null
  br i1 %tobool1, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %devnode2 = getelementptr inbounds %struct.usb_class_driver, %struct.usb_class_driver* %0, i32 0, i32 1
  %2 = load i8* (%struct.device*, i16*)*, i8* (%struct.device*, i16*)** %devnode2, align 8, !tbaa !616
  %call3 = call i8* %2(%struct.device* %dev, i16* %mode)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %lor.lhs.false, %entry
  %retval.0 = phi i8* [ %call3, %if.end ], [ null, %lor.lhs.false ], [ null, %entry ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_get_drvdata.542(%struct.device* %dev) #1 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !117
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @refcount_set.543(%struct.qspinlock* %r, i32 %n) #1 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %refs = getelementptr inbounds %struct.qspinlock, %struct.qspinlock* %r, i32 0, i32 0
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  store i32 %n, i32* %__val.i, align 4, !tbaa !72
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %refs, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %0 = bitcast i8* %arraydecay.i to i32*
  %1 = load i32, i32* %0, align 4, !tbaa !73
  store volatile i32 %1, i32* %counter.i, align 4, !tbaa !73
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_major_init() #0 {
entry:
  %call = call i32 @register_chrdev(i32 180, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18.951, i32 0, i32 0), %struct.file_operations* @usb_fops)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @register_chrdev(i32 %major, i8* %name, %struct.file_operations* %fops) #1 {
entry:
  %call = call i32 @__register_chrdev(i32 %major, i32 0, i32 256, i8* %name, %struct.file_operations* %fops)
  ret i32 %call
}

declare i32 @__register_chrdev(i32, i32, i32, i8*, %struct.file_operations*) #2

declare i64 @noop_llseek(%struct.file*, i64, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @usb_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  call void @down_read(%struct.rw_semaphore* @minor_rwsem)
  %call = call i32 @iminor(%struct.inode* %inode)
  %idxprom = zext i32 %call to i64
  %arrayidx = getelementptr inbounds [256 x %struct.file_operations*], [256 x %struct.file_operations*]* @usb_minors, i64 0, i64 %idxprom
  %0 = load %struct.file_operations*, %struct.file_operations** %arrayidx, align 8, !tbaa !52
  %tobool = icmp ne %struct.file_operations* %0, null
  br i1 %tobool, label %land.lhs.true, label %cond.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call i32 @iminor(%struct.inode* %inode)
  %idxprom2 = zext i32 %call1 to i64
  %arrayidx3 = getelementptr inbounds [256 x %struct.file_operations*], [256 x %struct.file_operations*]* @usb_minors, i64 0, i64 %idxprom2
  %1 = load %struct.file_operations*, %struct.file_operations** %arrayidx3, align 8, !tbaa !52
  %owner = getelementptr inbounds %struct.file_operations, %struct.file_operations* %1, i32 0, i32 0
  %2 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !617
  %call4 = call zeroext i1 @try_module_get(%struct.module* %2)
  br i1 %call4, label %cond.true, label %cond.end

cond.true:                                        ; preds = %land.lhs.true
  %call5 = call i32 @iminor(%struct.inode* %inode)
  %idxprom6 = zext i32 %call5 to i64
  %arrayidx7 = getelementptr inbounds [256 x %struct.file_operations*], [256 x %struct.file_operations*]* @usb_minors, i64 0, i64 %idxprom6
  %3 = load %struct.file_operations*, %struct.file_operations** %arrayidx7, align 8, !tbaa !52
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %land.lhs.true, %entry
  %cond = phi %struct.file_operations* [ %3, %cond.true ], [ null, %land.lhs.true ], [ null, %entry ]
  %tobool8 = icmp ne %struct.file_operations* %cond, null
  br i1 %tobool8, label %do.body9, label %done

do.body9:                                         ; preds = %cond.end
  %f_op = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %4 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8, !tbaa !619
  %tobool10 = icmp ne %struct.file_operations* %4, null
  br i1 %tobool10, label %if.then11, label %do.body15

if.then11:                                        ; preds = %do.body9
  %f_op12 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %5 = load %struct.file_operations*, %struct.file_operations** %f_op12, align 8, !tbaa !619
  %owner13 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %5, i32 0, i32 0
  %6 = load %struct.module*, %struct.module** %owner13, align 8, !tbaa !617
  call void @module_put(%struct.module* %6)
  br label %do.body15

do.body15:                                        ; preds = %if.then11, %do.body9
  %f_op16 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  store %struct.file_operations* %cond, %struct.file_operations** %f_op16, align 8, !tbaa !619
  %tobool17 = icmp ne %struct.file_operations* %cond, null
  %lnot = xor i1 %tobool17, true
  %lnot18 = xor i1 %lnot, true
  %lnot19 = xor i1 %lnot18, true
  %lnot.ext = zext i1 %lnot19 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool20 = icmp ne i64 %expval, 0
  br i1 %tobool20, label %do.body22, label %do.end32

do.body22:                                        ; preds = %do.body15
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.3.531, i32 0, i32 0), i32 44, i64 12) #8, !srcloc !626
  br label %do.body23

do.body23:                                        ; preds = %do.body23, %do.body22
  br label %do.body23

do.end32:                                         ; preds = %do.body15
  %f_op33 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %7 = load %struct.file_operations*, %struct.file_operations** %f_op33, align 8, !tbaa !619
  %open = getelementptr inbounds %struct.file_operations, %struct.file_operations* %7, i32 0, i32 12
  %8 = load i32 (%struct.inode*, %struct.file*)*, i32 (%struct.inode*, %struct.file*)** %open, align 8, !tbaa !627
  %tobool34 = icmp ne i32 (%struct.inode*, %struct.file*)* %8, null
  br i1 %tobool34, label %if.then35, label %done

if.then35:                                        ; preds = %do.end32
  %f_op36 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %9 = load %struct.file_operations*, %struct.file_operations** %f_op36, align 8, !tbaa !619
  %open37 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %9, i32 0, i32 12
  %10 = load i32 (%struct.inode*, %struct.file*)*, i32 (%struct.inode*, %struct.file*)** %open37, align 8, !tbaa !627
  %call38 = call i32 %10(%struct.inode* %inode, %struct.file* %file)
  br label %done

done:                                             ; preds = %if.then35, %do.end32, %cond.end
  %err.1 = phi i32 [ -19, %cond.end ], [ %call38, %if.then35 ], [ -19, %do.end32 ]
  call void @up_read(%struct.rw_semaphore* @minor_rwsem)
  ret i32 %err.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @iminor(%struct.inode* %inode) #1 {
entry:
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 13
  %0 = load i32, i32* %i_rdev, align 4, !tbaa !628
  %and = and i32 %0, 1048575
  ret i32 %and
}

declare zeroext i1 @try_module_get(%struct.module*) #2

declare void @module_put(%struct.module*) #2

; Function Attrs: nounwind uwtable
define void @usb_major_cleanup() #0 {
entry:
  call void @unregister_chrdev(i32 180, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18.951, i32 0, i32 0))
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @unregister_chrdev(i32 %major, i8* %name) #1 {
entry:
  call void @__unregister_chrdev(i32 %major, i32 0, i32 256, i8* %name)
  ret void
}

declare void @__unregister_chrdev(i32, i32, i32, i8*) #2

; Function Attrs: nounwind uwtable
define void @usb_init_pool_max() #5 section ".init.text" {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @hcd_buffer_create(%struct.usb_hcd.2781* %hcd) #0 {
entry:
  %name = alloca [16 x i8], align 16
  %self = getelementptr inbounds %struct.usb_hcd.2781, %struct.usb_hcd.2781* %hcd, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !356
  %dma_mask = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 18
  %1 = load i64*, i64** %dma_mask, align 8, !tbaa !67
  %tobool = icmp ne i64* %1, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %driver = getelementptr inbounds %struct.usb_hcd.2781, %struct.usb_hcd.2781* %hcd, i32 0, i32 8
  %2 = load %struct.hc_driver.2784*, %struct.hc_driver.2784** %driver, align 8, !tbaa !57
  %flags = getelementptr inbounds %struct.hc_driver.2784, %struct.hc_driver.2784* %2, i32 0, i32 4
  %3 = load i32, i32* %flags, align 8, !tbaa !376
  %and = and i32 %3, 2
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.end, label %cleanup

if.end:                                           ; preds = %land.lhs.true, %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 4
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x i64], [4 x i64]* @pool_max, i64 0, i64 %idxprom
  %4 = load i64, i64* %arrayidx, align 8, !tbaa !53
  %conv = trunc i64 %4 to i32
  %tobool2 = icmp ne i32 %conv, 0
  br i1 %tobool2, label %if.end4, label %for.inc

if.end4:                                          ; preds = %for.body
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %name, i32 0, i32 0
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 16, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.556, i32 0, i32 0), i32 %conv)
  %arraydecay5 = getelementptr inbounds [16 x i8], [16 x i8]* %name, i32 0, i32 0
  %self6 = getelementptr inbounds %struct.usb_hcd.2781, %struct.usb_hcd.2781* %hcd, i32 0, i32 0
  %controller7 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self6, i32 0, i32 0
  %5 = load %struct.device*, %struct.device** %controller7, align 8, !tbaa !356
  %conv8 = sext i32 %conv to i64
  %conv9 = sext i32 %conv to i64
  %call10 = call %struct.dma_pool* @dma_pool_create(i8* %arraydecay5, %struct.device* %5, i64 %conv8, i64 %conv9, i64 0)
  %pool = getelementptr inbounds %struct.usb_hcd.2781, %struct.usb_hcd.2781* %hcd, i32 0, i32 24
  %idxprom11 = sext i32 %i.0 to i64
  %arrayidx12 = getelementptr inbounds [4 x %struct.dma_pool*], [4 x %struct.dma_pool*]* %pool, i64 0, i64 %idxprom11
  store %struct.dma_pool* %call10, %struct.dma_pool** %arrayidx12, align 8, !tbaa !52
  %pool13 = getelementptr inbounds %struct.usb_hcd.2781, %struct.usb_hcd.2781* %hcd, i32 0, i32 24
  %idxprom14 = sext i32 %i.0 to i64
  %arrayidx15 = getelementptr inbounds [4 x %struct.dma_pool*], [4 x %struct.dma_pool*]* %pool13, i64 0, i64 %idxprom14
  %6 = load %struct.dma_pool*, %struct.dma_pool** %arrayidx15, align 8, !tbaa !52
  %tobool16 = icmp ne %struct.dma_pool* %6, null
  br i1 %tobool16, label %for.inc, label %if.then17

if.then17:                                        ; preds = %if.end4
  call void @hcd_buffer_destroy(%struct.usb_hcd.2781* %hcd)
  br label %cleanup

for.inc:                                          ; preds = %if.end4, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.then17, %for.cond, %land.lhs.true
  %retval.0 = phi i32 [ -12, %if.then17 ], [ 0, %land.lhs.true ], [ 0, %for.cond ]
  ret i32 %retval.0
}

declare %struct.dma_pool* @dma_pool_create(i8*, %struct.device*, i64, i64, i64) #2

; Function Attrs: nounwind uwtable
define void @hcd_buffer_destroy(%struct.usb_hcd.2781* %hcd) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %pool1 = getelementptr inbounds %struct.usb_hcd.2781, %struct.usb_hcd.2781* %hcd, i32 0, i32 24
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.dma_pool*], [4 x %struct.dma_pool*]* %pool1, i64 0, i64 %idxprom
  %0 = load %struct.dma_pool*, %struct.dma_pool** %arrayidx, align 8, !tbaa !52
  %tobool = icmp ne %struct.dma_pool* %0, null
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @dma_pool_destroy(%struct.dma_pool* %0)
  %pool2 = getelementptr inbounds %struct.usb_hcd.2781, %struct.usb_hcd.2781* %hcd, i32 0, i32 24
  %idxprom3 = sext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds [4 x %struct.dma_pool*], [4 x %struct.dma_pool*]* %pool2, i64 0, i64 %idxprom3
  store %struct.dma_pool* null, %struct.dma_pool** %arrayidx4, align 8, !tbaa !52
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @dma_pool_destroy(%struct.dma_pool*) #2

; Function Attrs: nounwind uwtable
define i8* @hcd_buffer_alloc(%struct.usb_bus* %bus, i64 %size, i32 %mem_flags, i64* %dma) #0 {
entry:
  %call = call %struct.usb_hcd.2781* @bus_to_hcd.561(%struct.usb_bus* %bus)
  %cmp = icmp eq i64 %size, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !66
  %dma_mask = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 18
  %1 = load i64*, i64** %dma_mask, align 8, !tbaa !67
  %tobool = icmp ne i64* %1, null
  br i1 %tobool, label %if.end4, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %driver = getelementptr inbounds %struct.usb_hcd.2781, %struct.usb_hcd.2781* %call, i32 0, i32 8
  %2 = load %struct.hc_driver.2784*, %struct.hc_driver.2784** %driver, align 8, !tbaa !57
  %flags = getelementptr inbounds %struct.hc_driver.2784, %struct.hc_driver.2784* %2, i32 0, i32 4
  %3 = load i32, i32* %flags, align 8, !tbaa !376
  %and = and i32 %3, 2
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.end4, label %if.then2

if.then2:                                         ; preds = %land.lhs.true
  store i64 -1, i64* %dma, align 8, !tbaa !86
  %call.i = call noalias i8* @__kmalloc(i64 %size, i32 %mem_flags) #8
  br label %cleanup

if.end4:                                          ; preds = %land.lhs.true, %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %i.0 = phi i32 [ 0, %if.end4 ], [ %inc, %for.inc ]
  %cmp5 = icmp slt i32 %i.0, 4
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x i64], [4 x i64]* @pool_max, i64 0, i64 %idxprom
  %4 = load i64, i64* %arrayidx, align 8, !tbaa !53
  %cmp6 = icmp ule i64 %size, %4
  br i1 %cmp6, label %if.then7, label %for.inc

if.then7:                                         ; preds = %for.body
  %pool = getelementptr inbounds %struct.usb_hcd.2781, %struct.usb_hcd.2781* %call, i32 0, i32 24
  %idxprom8 = sext i32 %i.0 to i64
  %arrayidx9 = getelementptr inbounds [4 x %struct.dma_pool*], [4 x %struct.dma_pool*]* %pool, i64 0, i64 %idxprom8
  %5 = load %struct.dma_pool*, %struct.dma_pool** %arrayidx9, align 8, !tbaa !52
  %call10 = call i8* @dma_pool_alloc(%struct.dma_pool* %5, i32 %mem_flags, i64* %dma)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %self = getelementptr inbounds %struct.usb_hcd.2781, %struct.usb_hcd.2781* %call, i32 0, i32 0
  %controller12 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %6 = load %struct.device*, %struct.device** %controller12, align 8, !tbaa !356
  %call13 = call i8* @dma_alloc_coherent(%struct.device* %6, i64 %size, i64* %dma, i32 %mem_flags)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then7, %if.then2, %entry
  %retval.0 = phi i8* [ %call10, %if.then7 ], [ %call13, %for.end ], [ %call.i, %if.then2 ], [ null, %entry ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd.2781* @bus_to_hcd.561(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd.2781*
  ret %struct.usb_hcd.2781* %1
}

declare i8* @dma_pool_alloc(%struct.dma_pool*, i32, i64*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dma_alloc_coherent(%struct.device* %dev, i64 %size, i64* %dma_handle, i32 %flag) #1 {
entry:
  %call = call i8* @dma_alloc_attrs(%struct.device* %dev, i64 %size, i64* %dma_handle, i32 %flag, i64 0)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dma_alloc_attrs(%struct.device* %dev, i64 %size, i64* %dma_handle, i32 %flag, i64 %attrs) #1 {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %flag.addr = alloca i32, align 4
  store %struct.device* %dev, %struct.device** %dev.addr, align 8, !tbaa !52
  store i32 %flag, i32* %flag.addr, align 4, !tbaa !73
  %0 = load %struct.device*, %struct.device** %dev.addr, align 8, !tbaa !52
  %call = call %struct.dma_map_ops* @get_dma_ops.563(%struct.device* %0)
  %tobool = icmp ne %struct.dma_map_ops* %call, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.end9

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.1.564, i32 0, i32 0), i32 483, i64 12) #8, !srcloc !634
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.end9:                                          ; preds = %entry
  %call10 = call zeroext i1 @arch_dma_alloc_attrs(%struct.device** %dev.addr, i32* %flag.addr)
  br i1 %call10, label %if.end12, label %cleanup

if.end12:                                         ; preds = %do.end9
  %alloc = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 0
  %1 = load i8* (%struct.device*, i64, i64*, i32, i64)*, i8* (%struct.device*, i64, i64*, i32, i64)** %alloc, align 8, !tbaa !635
  %tobool13 = icmp ne i8* (%struct.device*, i64, i64*, i32, i64)* %1, null
  br i1 %tobool13, label %if.end15, label %cleanup

if.end15:                                         ; preds = %if.end12
  %alloc16 = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 0
  %2 = load i8* (%struct.device*, i64, i64*, i32, i64)*, i8* (%struct.device*, i64, i64*, i32, i64)** %alloc16, align 8, !tbaa !635
  %3 = load %struct.device*, %struct.device** %dev.addr, align 8, !tbaa !52
  %4 = load i32, i32* %flag.addr, align 4, !tbaa !73
  %call17 = call i8* %2(%struct.device* %3, i64 %size, i64* %dma_handle, i32 %4, i64 %attrs)
  %5 = load %struct.device*, %struct.device** %dev.addr, align 8, !tbaa !52
  %6 = load i64, i64* %dma_handle, align 8, !tbaa !86
  call void @debug_dma_alloc_coherent(%struct.device* %5, i64 %size, i64 %6, i8* %call17)
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.end12, %do.end9
  %retval.0 = phi i8* [ %call17, %if.end15 ], [ null, %do.end9 ], [ null, %if.end12 ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.dma_map_ops* @get_dma_ops.563(%struct.device* %dev) #1 {
entry:
  %magicptr = ptrtoint %struct.device* %dev to i64
  %cond1 = icmp eq i64 %magicptr, 0
  br i1 %cond1, label %cond.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %dma_ops = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 17
  %0 = load %struct.dma_map_ops*, %struct.dma_map_ops** %dma_ops, align 8, !tbaa !407
  %tobool1 = icmp ne %struct.dma_map_ops* %0, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %dma_ops2 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 17
  %1 = load %struct.dma_map_ops*, %struct.dma_map_ops** %dma_ops2, align 8, !tbaa !407
  br label %return

if.end:                                           ; preds = %land.lhs.true
  %tobool3 = icmp ne %struct.device* %dev, null
  br i1 %tobool3, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.end, %entry
  %call = call %struct.dma_map_ops* @get_arch_dma_ops.565()
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %retval.0 = phi %struct.dma_map_ops* [ %1, %if.then ], [ %call, %cond.end ]
  ret %struct.dma_map_ops* %retval.0
}

declare zeroext i1 @arch_dma_alloc_attrs(%struct.device**, i32*) #2

declare void @debug_dma_alloc_coherent(%struct.device*, i64, i64, i8*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.dma_map_ops* @get_arch_dma_ops.565() #1 {
entry:
  %0 = load %struct.dma_map_ops*, %struct.dma_map_ops** @dma_ops, align 8, !tbaa !52
  ret %struct.dma_map_ops* %0
}

; Function Attrs: nounwind uwtable
define void @hcd_buffer_free(%struct.usb_bus* %bus, i64 %size, i8* %addr, i64 %dma) #0 {
entry:
  %call = call %struct.usb_hcd.2781* @bus_to_hcd.561(%struct.usb_bus* %bus)
  %tobool = icmp ne i8* %addr, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !66
  %dma_mask = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 18
  %1 = load i64*, i64** %dma_mask, align 8, !tbaa !67
  %tobool1 = icmp ne i64* %1, null
  br i1 %tobool1, label %if.end4, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %driver = getelementptr inbounds %struct.usb_hcd.2781, %struct.usb_hcd.2781* %call, i32 0, i32 8
  %2 = load %struct.hc_driver.2784*, %struct.hc_driver.2784** %driver, align 8, !tbaa !57
  %flags = getelementptr inbounds %struct.hc_driver.2784, %struct.hc_driver.2784* %2, i32 0, i32 4
  %3 = load i32, i32* %flags, align 8, !tbaa !376
  %and = and i32 %3, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %land.lhs.true
  call void @kfree(i8* %addr)
  br label %cleanup.cont

if.end4:                                          ; preds = %land.lhs.true, %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %i.0 = phi i32 [ 0, %if.end4 ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x i64], [4 x i64]* @pool_max, i64 0, i64 %idxprom
  %4 = load i64, i64* %arrayidx, align 8, !tbaa !53
  %cmp5 = icmp ule i64 %size, %4
  br i1 %cmp5, label %if.then6, label %for.inc

if.then6:                                         ; preds = %for.body
  %pool = getelementptr inbounds %struct.usb_hcd.2781, %struct.usb_hcd.2781* %call, i32 0, i32 24
  %idxprom7 = sext i32 %i.0 to i64
  %arrayidx8 = getelementptr inbounds [4 x %struct.dma_pool*], [4 x %struct.dma_pool*]* %pool, i64 0, i64 %idxprom7
  %5 = load %struct.dma_pool*, %struct.dma_pool** %arrayidx8, align 8, !tbaa !52
  call void @dma_pool_free(%struct.dma_pool* %5, i8* %addr, i64 %dma)
  br label %cleanup.cont

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %self = getelementptr inbounds %struct.usb_hcd.2781, %struct.usb_hcd.2781* %call, i32 0, i32 0
  %controller10 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %6 = load %struct.device*, %struct.device** %controller10, align 8, !tbaa !356
  call void @dma_free_coherent(%struct.device* %6, i64 %size, i8* %addr, i64 %dma)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %if.then6, %if.then3, %entry
  ret void
}

declare void @dma_pool_free(%struct.dma_pool*, i8*, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @dma_free_coherent(%struct.device* %dev, i64 %size, i8* %cpu_addr, i64 %dma_handle) #1 {
entry:
  call void @dma_free_attrs(%struct.device* %dev, i64 %size, i8* %cpu_addr, i64 %dma_handle, i64 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @dma_free_attrs(%struct.device* %dev, i64 %size, i8* %cpu_addr, i64 %dma_handle, i64 %attrs) #1 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops.563(%struct.device* %dev)
  %tobool = icmp ne %struct.dma_map_ops* %call, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.body10

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.1.564, i32 0, i32 0), i32 504, i64 12) #8, !srcloc !636
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.body10:                                        ; preds = %entry
  %call12 = call i64 @arch_local_save_flags.568()
  %call22 = call i32 @arch_irqs_disabled_flags.569(i64 %call12)
  %tobool23 = icmp ne i32 %call22, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %tobool28 = icmp ne i32 %lnot.ext27, 0
  %lnot29 = xor i1 %tobool28, true
  %lnot31 = xor i1 %lnot29, true
  %lnot.ext32 = zext i1 %lnot31 to i32
  %conv33 = sext i32 %lnot.ext32 to i64
  %expval34 = call i64 @llvm.expect.i64(i64 %conv33, i64 0)
  %tobool35 = icmp ne i64 %expval34, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %do.body10
  call void @warn_slowpath_null(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.1.564, i32 0, i32 0), i32 505)
  br label %if.end37

if.end37:                                         ; preds = %if.then36, %do.body10
  %free = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 1
  %0 = load void (%struct.device*, i64, i8*, i64, i64)*, void (%struct.device*, i64, i8*, i64, i64)** %free, align 8, !tbaa !637
  %tobool46 = icmp ne void (%struct.device*, i64, i8*, i64, i64)* %0, null
  %tobool47 = icmp ne i8* %cpu_addr, null
  %or.cond = and i1 %tobool46, %tobool47
  br i1 %or.cond, label %if.end49, label %cleanup.cont

if.end49:                                         ; preds = %if.end37
  call void @debug_dma_free_coherent(%struct.device* %dev, i64 %size, i8* %cpu_addr, i64 %dma_handle)
  %free50 = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 1
  %1 = load void (%struct.device*, i64, i8*, i64, i64)*, void (%struct.device*, i64, i8*, i64, i64)** %free50, align 8, !tbaa !637
  call void %1(%struct.device* %dev, i64 %size, i8* %cpu_addr, i64 %dma_handle, i64 %attrs)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end49, %if.end37
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @arch_local_save_flags.568() #1 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), align 8, !tbaa !391
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.13.994, i32 0, i32 0), i32 773, i64 12) #8, !srcloc !638
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call { i64, i8* } asm sideeffect "771:\0A\09call *${3:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${2:c}\0A  .byte 772b-771b\0A  .short ${4:c}\0A.popsection\0A", "={ax},={rsp},i,i,i,1,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 39, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), i32 1, i8* undef) #8, !srcloc !639
  %asmresult = extractvalue { i64, i8* } %1, 0
  %and = and i64 %asmresult, -1
  ret i64 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @arch_irqs_disabled_flags.569(i64 %flags) #1 {
entry:
  %and = and i64 %flags, 512
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

declare void @debug_dma_free_coherent(%struct.device*, i64, i8*, i64) #2

; Function Attrs: nounwind uwtable
define internal zeroext i16 @dev_string_attrs_are_visible(%struct.kobject* %kobj, %struct.attribute* %a, i32 %n) #0 {
entry:
  %0 = bitcast %struct.kobject* %kobj to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.device*
  %2 = bitcast %struct.device* %1 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 -152
  %3 = bitcast i8* %add.ptr3 to %struct.usb_device*
  %cmp = icmp eq %struct.attribute* %a, getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_manufacturer, i32 0, i32 0)
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %manufacturer = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 25
  %4 = load i8*, i8** %manufacturer, align 8, !tbaa !46
  %cmp4 = icmp eq i8* %4, null
  br i1 %cmp4, label %cleanup, label %if.end19

if.else:                                          ; preds = %entry
  %cmp6 = icmp eq %struct.attribute* %a, getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_product, i32 0, i32 0)
  br i1 %cmp6, label %if.then7, label %if.else11

if.then7:                                         ; preds = %if.else
  %product = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 24
  %5 = load i8*, i8** %product, align 8, !tbaa !45
  %cmp8 = icmp eq i8* %5, null
  br i1 %cmp8, label %cleanup, label %if.end19

if.else11:                                        ; preds = %if.else
  %cmp12 = icmp eq %struct.attribute* %a, getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_serial, i32 0, i32 0)
  br i1 %cmp12, label %if.then13, label %if.end19

if.then13:                                        ; preds = %if.else11
  %serial = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 26
  %6 = load i8*, i8** %serial, align 8, !tbaa !47
  %cmp14 = icmp eq i8* %6, null
  br i1 %cmp14, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.then13, %if.else11, %if.then7, %if.then
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %a, i32 0, i32 1
  %7 = load i16, i16* %mode, align 8, !tbaa !640
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.then13, %if.then7, %if.then
  %retval.0 = phi i16 [ %7, %if.end19 ], [ 0, %if.then ], [ 0, %if.then7 ], [ 0, %if.then13 ]
  ret i16 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @serial_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call = call i32 @device_lock_interruptible(%struct.device* %dev2)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.575(%struct.device* %dev4)
  %conv = sext i32 %2 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -4, %entry ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @device_lock_interruptible(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  %call = call i32 @mutex_lock_interruptible_nested(%struct.mutex* %mutex, i32 0)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock.575(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

declare i32 @mutex_lock_interruptible_nested(%struct.mutex*, i32) #2

; Function Attrs: nounwind uwtable
define internal i64 @product_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call = call i32 @device_lock_interruptible(%struct.device* %dev2)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.575(%struct.device* %dev4)
  %conv = sext i32 %2 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -4, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @manufacturer_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call = call i32 @device_lock_interruptible(%struct.device* %dev2)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.575(%struct.device* %dev4)
  %conv = sext i32 %2 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -4, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @devspec_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %of_node1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 26
  %0 = load %struct.device_node*, %struct.device_node** %of_node1, align 8, !tbaa !371
  call void @of_node_full_name(%struct.device_node* %0)
  %1 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %1 to i64
  ret i64 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @of_node_full_name(%struct.device_node* %np) #1 {
entry:
  %tobool = icmp ne %struct.device_node* %np, null
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @ltm_capable_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  call void @usb_device_supports_ltm.581(%struct.usb_device* %1)
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv3 = sext i32 %2 to i64
  ret i64 %conv3
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_device_supports_ltm.581(%struct.usb_device* %udev) #1 {
entry:
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp ult i32 %0, 5
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %bos = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %1 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos, align 8, !tbaa !166
  %tobool = icmp ne %struct.usb_host_bos* %1, null
  br i1 %tobool, label %lor.lhs.false1, label %return

lor.lhs.false1:                                   ; preds = %lor.lhs.false
  %bos2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %2 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos2, align 8, !tbaa !166
  %ss_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %2, i32 0, i32 2
  %3 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap, align 8, !tbaa !206
  %tobool3 = icmp ne %struct.usb_ss_cap_descriptor* %3, null
  br i1 %tobool3, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false1
  br label %return

return:                                           ; preds = %if.end, %lor.lhs.false1, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @removable_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %removable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 36
  %2 = load i32, i32* %removable, align 4, !tbaa !261
  %Pivot = icmp slt i32 %2, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %2, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %2, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock, %LeafBlock1
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @remove_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_lock.588(%struct.device* %dev1)
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 3
  %2 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp ne i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @usb_set_configuration(%struct.usb_device* %1, i32 -1)
  %call2 = call i32 @usb_remove_device(%struct.usb_device* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rc.0 = phi i32 [ %call2, %if.then ], [ 0, %entry ]
  %cmp3 = icmp eq i32 %rc.0, 0
  %conv = trunc i64 %count to i32
  %conv.rc.0 = select i1 %cmp3, i32 %conv, i32 %rc.0
  %dev6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.575(%struct.device* %dev6)
  %conv7 = sext i32 %conv.rc.0 to i64
  ret i64 %conv7
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock.588(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @authorized_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %authorized = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 22
  %bf.load = load i16, i16* %authorized, align 4
  %bf.lshr = lshr i16 %bf.load, 3
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.590, i32 0, i32 0), i32 %bf.cast)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @authorized_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %size) #0 {
entry:
  %val = alloca i32, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %call = call i32 (i8*, i8*, ...) @sscanf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.590, i32 0, i32 0), i32* %val)
  %conv = sext i32 %call to i64
  %cmp = icmp ne i64 %conv, 1
  br i1 %cmp, label %if.end10, label %if.else

if.else:                                          ; preds = %entry
  %2 = load i32, i32* %val, align 4, !tbaa !73
  %cmp2 = icmp eq i32 %2, 0
  br i1 %cmp2, label %if.then4, label %if.else7

if.then4:                                         ; preds = %if.else
  %call5 = call i32 @usb_deauthorize_device(%struct.usb_device* %1)
  br label %if.end

if.else7:                                         ; preds = %if.else
  %call8 = call i32 @usb_authorize_device(%struct.usb_device* %1)
  br label %if.end

if.end:                                           ; preds = %if.else7, %if.then4
  %call8.sink = phi i32 [ %call8, %if.else7 ], [ %call5, %if.then4 ]
  %conv9 = sext i32 %call8.sink to i64
  br label %if.end10

if.end10:                                         ; preds = %if.end, %entry
  %result.1 = phi i64 [ %conv9, %if.end ], [ -22, %entry ]
  %cmp11 = icmp slt i64 %result.1, 0
  %result.1.size = select i1 %cmp11, i64 %result.1, i64 %size
  ret i64 %result.1.size
}

; Function Attrs: nounwind uwtable
define internal i64 @avoid_reset_quirk_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv2 = sext i32 %0 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @avoid_reset_quirk_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i32, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %call = call i32 (i8*, i8*, ...) @sscanf(i8* %buf, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.6.592, i32 0, i32 0), i32* %val)
  %cmp = icmp ne i32 %call, 1
  %2 = load i32, i32* %val, align 4
  %cmp1 = icmp slt i32 %2, 0
  %or.cond = or i1 %cmp, %cmp1
  %3 = load i32, i32* %val, align 4
  %cmp3 = icmp sgt i32 %3, 1
  %or.cond1 = or i1 %or.cond, %cmp3
  br i1 %or.cond1, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call5 = call i32 @device_lock_interruptible(%struct.device* %dev4)
  %cmp6 = icmp slt i32 %call5, 0
  br i1 %cmp6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end
  %4 = load i32, i32* %val, align 4, !tbaa !73
  %tobool = icmp ne i32 %4, 0
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 29
  %5 = load i32, i32* %quirks, align 4, !tbaa !199
  %conv = zext i32 %5 to i64
  %and = and i64 %conv, -17
  %or = or i64 %conv, 16
  %and.sink = select i1 %tobool, i64 %or, i64 %and
  %conv13 = trunc i64 %and.sink to i32
  store i32 %conv13, i32* %quirks, align 4, !tbaa !199
  %dev15 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.575(%struct.device* %dev15)
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %if.end, %entry
  %retval.0 = phi i64 [ %count, %if.end8 ], [ -22, %entry ], [ -4, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @quirks_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @maxchild_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @version_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv3 = sext i32 %0 to i64
  ret i64 %conv3
}

; Function Attrs: nounwind uwtable
define internal i64 @devpath_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @devnum_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @busnum_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @speed_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %speed1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 4
  %2 = load i32, i32* %speed1, align 4, !tbaa !177
  %Pivot12 = icmp slt i32 %2, 3
  br i1 %Pivot12, label %NodeBlock1, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %2, 5
  br i1 %Pivot10, label %sw.epilog, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %2, 6
  br i1 %Pivot8, label %sw.epilog, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %2, 6
  br i1 %SwitchLeaf6, label %sw.epilog, label %sw.default

NodeBlock1:                                       ; preds = %entry
  %Pivot2 = icmp slt i32 %2, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %2, 2
  br i1 %Pivot, label %sw.epilog, label %sw.bb2

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %2, 0
  br i1 %SwitchLeaf, label %sw.bb2, label %sw.default

sw.bb2:                                           ; preds = %LeafBlock, %NodeBlock
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock5
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb2, %NodeBlock, %LeafBlock5, %NodeBlock7, %NodeBlock9
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @bMaxPacketSize0_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @bNumConfigurations_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @bDeviceProtocol_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @bDeviceSubClass_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @bDeviceClass_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @bcdDevice_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @idProduct_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @idVendor_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @urbnum_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %urbnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 30
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %urbnum, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %2 = load volatile i32, i32* %counter.i, align 4, !tbaa !73
  %3 = bitcast i8* %arraydecay.i to i32*
  store i32 %2, i32* %3, align 4, !tbaa !73
  %4 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %4 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @bMaxPower_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call = call i32 @device_lock_interruptible(%struct.device* %dev1)
  %conv = sext i32 %call to i64
  %cmp = icmp slt i64 %conv, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %actconfig3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig3, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %if.then4, label %if.end8

if.then4:                                         ; preds = %if.end
  call void @usb_get_max_power.622()
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv7 = sext i32 %3 to i64
  br label %if.end8

if.end8:                                          ; preds = %if.then4, %if.end
  %rc.0 = phi i64 [ %conv7, %if.then4 ], [ %conv, %if.end ]
  %dev9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.575(%struct.device* %dev9)
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %entry
  %retval.0 = phi i64 [ %rc.0, %if.end8 ], [ -4, %entry ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_get_max_power.622() #1 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @bmAttributes_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call = call i32 @device_lock_interruptible(%struct.device* %dev1)
  %conv = sext i32 %call to i64
  %cmp = icmp slt i64 %conv, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %actconfig3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig3, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %if.then4, label %if.end8

if.then4:                                         ; preds = %if.end
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv7 = sext i32 %3 to i64
  br label %if.end8

if.end8:                                          ; preds = %if.then4, %if.end
  %rc.0 = phi i64 [ %conv7, %if.then4 ], [ %conv, %if.end ]
  %dev9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.575(%struct.device* %dev9)
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %entry
  %retval.0 = phi i64 [ %rc.0, %if.end8 ], [ -4, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @bConfigurationValue_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call = call i32 @device_lock_interruptible(%struct.device* %dev1)
  %conv = sext i32 %call to i64
  %cmp = icmp slt i64 %conv, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %actconfig3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig3, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %if.then4, label %if.end8

if.then4:                                         ; preds = %if.end
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv7 = sext i32 %3 to i64
  br label %if.end8

if.end8:                                          ; preds = %if.then4, %if.end
  %rc.0 = phi i64 [ %conv7, %if.then4 ], [ %conv, %if.end ]
  %dev9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.575(%struct.device* %dev9)
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %entry
  %retval.0 = phi i64 [ %rc.0, %if.end8 ], [ -4, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @bConfigurationValue_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %config = alloca i32, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %call = call i32 (i8*, i8*, ...) @sscanf(i8* %buf, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.6.592, i32 0, i32 0), i32* %config)
  %cmp = icmp ne i32 %call, 1
  %2 = load i32, i32* %config, align 4
  %cmp1 = icmp slt i32 %2, -1
  %or.cond = or i1 %cmp, %cmp1
  %3 = load i32, i32* %config, align 4
  %cmp3 = icmp sgt i32 %3, 255
  %or.cond1 = or i1 %or.cond, %cmp3
  br i1 %or.cond1, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call5 = call i32 @device_lock_interruptible(%struct.device* %dev4)
  %cmp6 = icmp slt i32 %call5, 0
  br i1 %cmp6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end
  %4 = load i32, i32* %config, align 4, !tbaa !73
  %call9 = call i32 @usb_set_configuration(%struct.usb_device* %1, i32 %4)
  %dev10 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.575(%struct.device* %dev10)
  %cmp11 = icmp slt i32 %call9, 0
  %conv = sext i32 %call9 to i64
  %cond = select i1 %cmp11, i64 %conv, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -4, %if.end ], [ %cond, %if.end8 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @bNumInterfaces_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call = call i32 @device_lock_interruptible(%struct.device* %dev1)
  %conv = sext i32 %call to i64
  %cmp = icmp slt i64 %conv, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %actconfig3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig3, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %if.then4, label %if.end8

if.then4:                                         ; preds = %if.end
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv7 = sext i32 %3 to i64
  br label %if.end8

if.end8:                                          ; preds = %if.then4, %if.end
  %rc.0 = phi i64 [ %conv7, %if.then4 ], [ %conv, %if.end ]
  %dev9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.575(%struct.device* %dev9)
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %entry
  %retval.0 = phi i64 [ %rc.0, %if.end8 ], [ -4, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @configuration_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call = call i32 @device_lock_interruptible(%struct.device* %dev1)
  %conv = sext i32 %call to i64
  %cmp = icmp slt i64 %conv, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %actconfig3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig3, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %if.end
  %string = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 1
  %3 = load i8*, i8** %string, align 8, !tbaa !507
  %tobool4 = icmp ne i8* %3, null
  br i1 %tobool4, label %if.then5, label %if.end9

if.then5:                                         ; preds = %land.lhs.true
  %4 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv8 = sext i32 %4 to i64
  br label %if.end9

if.end9:                                          ; preds = %if.then5, %land.lhs.true, %if.end
  %rc.0 = phi i64 [ %conv8, %if.then5 ], [ %conv, %land.lhs.true ], [ %conv, %if.end ]
  %dev10 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.575(%struct.device* %dev10)
  br label %cleanup

cleanup:                                          ; preds = %if.end9, %entry
  %retval.0 = phi i64 [ %rc.0, %if.end9 ], [ -4, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @intf_assoc_attrs_are_visible(%struct.kobject* %kobj, %struct.attribute* %a, i32 %n) #0 {
entry:
  %0 = bitcast %struct.kobject* %kobj to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.device*
  %2 = bitcast %struct.device* %1 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 -48
  %3 = bitcast i8* %add.ptr3 to %struct.usb_interface*
  %intf_assoc = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %3, i32 0, i32 3
  %4 = load %struct.usb_interface_assoc_descriptor*, %struct.usb_interface_assoc_descriptor** %intf_assoc, align 8, !tbaa !501
  %cmp = icmp eq %struct.usb_interface_assoc_descriptor* %4, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %a, i32 0, i32 1
  %5 = load i16, i16* %mode, align 8, !tbaa !640
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i16 [ %5, %if.end ], [ 0, %entry ]
  ret i16 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @iad_bFunctionProtocol_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @iad_bFunctionSubClass_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @iad_bFunctionClass_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @iad_bInterfaceCount_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @iad_bFirstInterface_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @interface_authorized_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @interface_authorized_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i8, align 1
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -48
  %1 = bitcast i8* %add.ptr to %struct.usb_interface*
  %call = call i32 @strtobool.638(i8* %buf, i8* %val)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = load i8, i8* %val, align 1, !tbaa !109, !range !110
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  call void @usb_authorize_interface(%struct.usb_interface* %1)
  br label %cleanup

if.else:                                          ; preds = %if.end
  call void @usb_deauthorize_interface(%struct.usb_interface* %1)
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.then1, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ %count, %if.else ], [ %count, %if.then1 ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @strtobool.638(i8* %s, i8* %res) #1 {
entry:
  %call = call i32 @kstrtobool(i8* %s, i8* %res)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @supports_autosuspend_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %call = call i32 @device_lock_interruptible(%struct.device* %dev)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !95
  %tobool = icmp ne %struct.device_driver* %0, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.end
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end
  call void @device_unlock.575(%struct.device* %dev)
  %1 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %1 to i64
  br label %cleanup

cleanup:                                          ; preds = %lor.end, %entry
  %retval.0 = phi i64 [ %conv, %lor.end ], [ -4, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @modalias_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -48
  %1 = bitcast i8* %add.ptr to %struct.usb_interface*
  %call = call %struct.usb_device* @interface_to_usbdev.641(%struct.usb_interface* %1)
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %1, i32 0, i32 1
  %2 = load volatile %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !52
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv20 = sext i32 %3 to i64
  ret i64 %conv20
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_device* @interface_to_usbdev.641(%struct.usb_interface* %intf) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %parent, align 8, !tbaa !300
  %1 = bitcast %struct.device* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -152
  %2 = bitcast i8* %add.ptr to %struct.usb_device*
  ret %struct.usb_device* %2
}

; Function Attrs: nounwind uwtable
define internal i64 @bInterfaceProtocol_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @bInterfaceSubClass_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @bInterfaceClass_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @bNumEndpoints_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @bAlternateSetting_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @bInterfaceNumber_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define i32 @usb_create_sysfs_dev_files(%struct.usb_device* %udev) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call = call i32 @device_create_bin_file(%struct.device* %dev1, %struct.bin_attribute* @dev_bin_attr_descriptors)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %error, label %if.end

if.end:                                           ; preds = %entry
  %call3 = call i32 @add_persist_attributes(%struct.device* %dev1)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %error, label %if.end6

if.end6:                                          ; preds = %if.end
  %call7 = call i32 @add_power_attributes(%struct.device* %dev1)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %error, label %cleanup

error:                                            ; preds = %if.end6, %if.end, %entry
  %retval2.0 = phi i32 [ %call, %entry ], [ %call3, %if.end ], [ %call7, %if.end6 ]
  call void @usb_remove_sysfs_dev_files(%struct.usb_device* %udev)
  br label %cleanup

cleanup:                                          ; preds = %error, %if.end6
  %retval.0 = phi i32 [ %retval2.0, %error ], [ %call7, %if.end6 ]
  ret i32 %retval.0
}

declare i32 @device_create_bin_file(%struct.device*, %struct.bin_attribute*) #2

; Function Attrs: nounwind uwtable
define internal i32 @add_persist_attributes(%struct.device* %dev) #0 {
entry:
  %call = call i32 @is_usb_device.664(%struct.device* %dev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 12
  %bDeviceClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 3
  %2 = load i8, i8* %bDeviceClass, align 4, !tbaa !278
  %conv = zext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 9
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.then
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call3 = call i32 @sysfs_add_file_to_group(%struct.kobject* %kobj, %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_persist, i32 0, i32 0), i8* getelementptr inbounds ([0 x i8], [0 x i8]* @power_group_name, i32 0, i32 0))
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.then, %entry
  %rc.1 = phi i32 [ 0, %entry ], [ %call3, %if.then2 ], [ 0, %if.then ]
  ret i32 %rc.1
}

; Function Attrs: nounwind uwtable
define internal i32 @add_power_attributes(%struct.device* %dev) #0 {
entry:
  %call = call i32 @is_usb_device.664(%struct.device* %dev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end15

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call1 = call i32 @sysfs_merge_group(%struct.kobject* %kobj, %struct.attribute_group* @power_attr_group)
  %usb2_hw_lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 22
  %bf.load = load i16, i16* %usb2_hw_lpm_capable, align 4
  %bf.lshr = lshr i16 %bf.load, 7
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 1
  br i1 %cmp, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %kobj3 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call4 = call i32 @sysfs_merge_group(%struct.kobject* %kobj3, %struct.attribute_group* @usb2_hardware_lpm_attr_group)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %rc.0 = phi i32 [ %call4, %if.then2 ], [ %call1, %if.then ]
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 4
  %2 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp5 = icmp eq i32 %2, 5
  br i1 %cmp5, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %if.end
  %lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 22
  %bf.load6 = load i16, i16* %lpm_capable, align 4
  %bf.lshr7 = lshr i16 %bf.load6, 6
  %bf.clear8 = and i16 %bf.lshr7, 1
  %bf.cast9 = zext i16 %bf.clear8 to i32
  %cmp10 = icmp eq i32 %bf.cast9, 1
  br i1 %cmp10, label %if.then11, label %if.end15

if.then11:                                        ; preds = %land.lhs.true
  %kobj12 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call13 = call i32 @sysfs_merge_group(%struct.kobject* %kobj12, %struct.attribute_group* @usb3_hardware_lpm_attr_group)
  br label %if.end15

if.end15:                                         ; preds = %if.then11, %land.lhs.true, %if.end, %entry
  %rc.2 = phi i32 [ 0, %entry ], [ %call13, %if.then11 ], [ %rc.0, %land.lhs.true ], [ %rc.0, %if.end ]
  ret i32 %rc.2
}

; Function Attrs: nounwind uwtable
define void @usb_remove_sysfs_dev_files(%struct.usb_device* %udev) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @remove_power_attributes(%struct.device* %dev1)
  call void @remove_persist_attributes(%struct.device* %dev1)
  call void @device_remove_bin_file(%struct.device* %dev1, %struct.bin_attribute* @dev_bin_attr_descriptors)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @remove_power_attributes(%struct.device* %dev) #0 {
entry:
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  call void @sysfs_unmerge_group(%struct.kobject* %kobj, %struct.attribute_group* @usb2_hardware_lpm_attr_group)
  %kobj1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  call void @sysfs_unmerge_group(%struct.kobject* %kobj1, %struct.attribute_group* @power_attr_group)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @remove_persist_attributes(%struct.device* %dev) #0 {
entry:
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  call void @sysfs_remove_file_from_group(%struct.kobject* %kobj, %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_persist, i32 0, i32 0), i8* getelementptr inbounds ([0 x i8], [0 x i8]* @power_group_name, i32 0, i32 0))
  ret void
}

declare void @device_remove_bin_file(%struct.device*, %struct.bin_attribute*) #2

declare void @sysfs_remove_file_from_group(%struct.kobject*, %struct.attribute*, i8*) #2

; Function Attrs: nounwind uwtable
define internal i64 @persist_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @persist_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %value = alloca i32, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 12
  %bDeviceClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 3
  %2 = load i8, i8* %bDeviceClass, align 4, !tbaa !278
  %conv = zext i8 %2 to i32
  %cmp = icmp eq i32 %conv, 9
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 (i8*, i8*, ...) @sscanf(i8* %buf, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.6.592, i32 0, i32 0), i32* %value)
  %cmp2 = icmp ne i32 %call, 1
  br i1 %cmp2, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %dev6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call7 = call i32 @device_lock_interruptible(%struct.device* %dev6)
  %cmp8 = icmp slt i32 %call7, 0
  br i1 %cmp8, label %cleanup, label %if.end11

if.end11:                                         ; preds = %if.end5
  %3 = load i32, i32* %value, align 4, !tbaa !73
  %tobool = icmp ne i32 %3, 0
  %lnot = xor i1 %tobool, true
  %lnot12 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot12 to i32
  %persist_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 22
  %4 = trunc i32 %lnot.ext to i16
  %bf.load = load i16, i16* %persist_enabled, align 4
  %bf.value = and i16 %4, 1
  %bf.shl = shl i16 %bf.value, 1
  %bf.clear = and i16 %bf.load, -3
  %bf.set = or i16 %bf.clear, %bf.shl
  store i16 %bf.set, i16* %persist_enabled, align 4
  %dev13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.575(%struct.device* %dev13)
  br label %cleanup

cleanup:                                          ; preds = %if.end11, %if.end5, %if.end, %entry
  %retval.0 = phi i64 [ %count, %if.end11 ], [ -1, %entry ], [ -22, %if.end ], [ -4, %if.end5 ]
  ret i64 %retval.0
}

declare void @sysfs_unmerge_group(%struct.kobject*, %struct.attribute_group*) #2

; Function Attrs: nounwind uwtable
define internal i64 @active_duration_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 3
  %2 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp ne i32 %2, 8
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  %active_duration = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 31
  %4 = load i64, i64* %active_duration, align 8, !tbaa !83
  %add = add i64 %3, %4
  br label %if.end

if.else:                                          ; preds = %entry
  %active_duration1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 31
  %5 = load i64, i64* %active_duration1, align 8, !tbaa !83
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %.sink = phi i64 [ %5, %if.else ], [ %add, %if.then ]
  %call2 = call i32 @jiffies_to_msecs(i64 %.sink)
  %6 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %6 to i64
  ret i64 %conv
}

declare i32 @jiffies_to_msecs(i64) #2

; Function Attrs: nounwind uwtable
define internal i64 @connected_duration_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %2 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  %connect_time = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 32
  %3 = load i64, i64* %connect_time, align 8, !tbaa !82
  %sub = sub i64 %2, %3
  %call = call i32 @jiffies_to_msecs(i64 %sub)
  %4 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %4 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @level_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  call void @warn_level()
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 3
  %2 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp ne i32 %2, 8
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @level_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %conv = trunc i64 %count to i32
  %conv1 = trunc i64 %count to i32
  call void @warn_level()
  %call = call i8* @memchr(i8* %buf, i32 10, i64 %count)
  %tobool = icmp ne i8* %call, null
  %sub.ptr.lhs.cast = ptrtoint i8* %call to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %buf to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv2 = trunc i64 %sub.ptr.sub to i32
  %len.0 = select i1 %tobool, i32 %conv2, i32 %conv
  %dev3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call4 = call i32 @device_lock_interruptible(%struct.device* %dev3)
  %cmp = icmp slt i32 %call4, 0
  br i1 %cmp, label %cleanup, label %if.end7

if.end7:                                          ; preds = %entry
  %conv8 = sext i32 %len.0 to i64
  %cmp9 = icmp eq i64 %conv8, 2
  br i1 %cmp9, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end7
  %conv11 = sext i32 %len.0 to i64
  %call12 = call i32 @strncmp(i8* %buf, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @on_string, i32 0, i32 0), i64 %conv11)
  %cmp13 = icmp eq i32 %call12, 0
  br i1 %cmp13, label %if.then15, label %if.else

if.then15:                                        ; preds = %land.lhs.true
  call void @usb_disable_autosuspend(%struct.usb_device* %1)
  br label %if.end27

if.else:                                          ; preds = %land.lhs.true, %if.end7
  %conv16 = sext i32 %len.0 to i64
  %cmp17 = icmp eq i64 %conv16, 4
  br i1 %cmp17, label %land.lhs.true19, label %if.end27

land.lhs.true19:                                  ; preds = %if.else
  %conv20 = sext i32 %len.0 to i64
  %call21 = call i32 @strncmp(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.114, i32 0, i32 0), i64 %conv20)
  %cmp22 = icmp eq i32 %call21, 0
  br i1 %cmp22, label %if.then24, label %if.end27

if.then24:                                        ; preds = %land.lhs.true19
  call void @usb_enable_autosuspend(%struct.usb_device* %1)
  br label %if.end27

if.end27:                                         ; preds = %if.then24, %land.lhs.true19, %if.else, %if.then15
  %rc.1 = phi i32 [ %conv1, %if.then15 ], [ %conv1, %if.then24 ], [ -22, %land.lhs.true19 ], [ -22, %if.else ]
  %dev28 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.575(%struct.device* %dev28)
  %conv29 = sext i32 %rc.1 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end27, %entry
  %retval.0 = phi i64 [ %conv29, %if.end27 ], [ -4, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @warn_level() #0 {
entry:
  %0 = load i32, i32* @warn_level.level_warned, align 4, !tbaa !73
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, i32* @warn_level.level_warned, align 4, !tbaa !73
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare i8* @memchr(i8*, i32, i64) #2

declare i32 @strncmp(i8*, i8*, i64) #2

; Function Attrs: nounwind uwtable
define internal i64 @autosuspend_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @autosuspend_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %value = alloca i32, align 4
  %call = call i32 (i8*, i8*, ...) @sscanf(i8* %buf, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.6.592, i32 0, i32 0), i32* %value)
  %cmp = icmp ne i32 %call, 1
  %0 = load i32, i32* %value, align 4
  %cmp1 = icmp sge i32 %0, 2147483
  %or.cond = or i1 %cmp, %cmp1
  %1 = load i32, i32* %value, align 4
  %cmp3 = icmp sle i32 %1, -2147483
  %or.cond1 = or i1 %or.cond, %cmp3
  br i1 %or.cond1, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = load i32, i32* %value, align 4, !tbaa !73
  %mul = mul nsw i32 %2, 1000
  call void @pm_runtime_set_autosuspend_delay(%struct.device* %dev, i32 %mul)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %count, %if.end ], [ -22, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @usb2_lpm_besl_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @usb2_lpm_besl_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %besl = alloca i8, align 1
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %call = call i32 @kstrtou8(i8* %buf, i32 0, i8* %besl)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i8, i8* %besl, align 1, !tbaa !72
  %conv = zext i8 %2 to i32
  %cmp = icmp sgt i32 %conv, 15
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %3 = load i8, i8* %besl, align 1, !tbaa !72
  %conv2 = zext i8 %3 to i32
  %l1_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 37
  %besl3 = getelementptr inbounds %struct.anon.26, %struct.anon.26* %l1_params, i32 0, i32 0
  store i32 %conv2, i32* %besl3, align 8, !tbaa !643
  br label %cleanup

cleanup:                                          ; preds = %if.end, %lor.lhs.false, %entry
  %retval.0 = phi i64 [ %count, %if.end ], [ -22, %lor.lhs.false ], [ -22, %entry ]
  ret i64 %retval.0
}

declare i32 @kstrtou8(i8*, i32, i8*) #2

; Function Attrs: nounwind uwtable
define internal i64 @usb2_lpm_l1_timeout_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @usb2_lpm_l1_timeout_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %timeout = alloca i16, align 2
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %call = call i32 @kstrtou16(i8* %buf, i32 0, i16* %timeout)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = load i16, i16* %timeout, align 2, !tbaa !165
  %conv = zext i16 %2 to i32
  %l1_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 37
  %timeout1 = getelementptr inbounds %struct.anon.26, %struct.anon.26* %l1_params, i32 0, i32 1
  store i32 %conv, i32* %timeout1, align 4, !tbaa !644
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %count, %if.end ], [ -22, %entry ]
  ret i64 %retval.0
}

declare i32 @kstrtou16(i8*, i32, i16*) #2

; Function Attrs: nounwind uwtable
define internal i64 @usb2_hardware_lpm_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @usb2_hardware_lpm_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %value = alloca i8, align 1
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call = call i32 @device_lock_interruptible(%struct.device* %dev1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call2 = call i32 @strtobool.638(i8* %buf, i8* %value)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.end8, label %if.then3

if.then3:                                         ; preds = %if.end
  %2 = load i8, i8* %value, align 1, !tbaa !109, !range !110
  %tobool4 = trunc i8 %2 to i1
  %conv = zext i1 %tobool4 to i32
  %usb2_hw_lpm_allowed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 22
  %3 = trunc i32 %conv to i16
  %bf.load = load i16, i16* %usb2_hw_lpm_allowed, align 4
  %bf.value = and i16 %3, 1
  %bf.shl = shl i16 %bf.value, 10
  %bf.clear = and i16 %bf.load, -1025
  %bf.set = or i16 %bf.clear, %bf.shl
  store i16 %bf.set, i16* %usb2_hw_lpm_allowed, align 4
  %4 = load i8, i8* %value, align 1, !tbaa !109, !range !110
  %tobool5 = trunc i8 %4 to i1
  %conv6 = zext i1 %tobool5 to i32
  %call7 = call i32 @usb_set_usb2_hardware_lpm(%struct.usb_device* %1, i32 %conv6)
  br label %if.end8

if.end8:                                          ; preds = %if.then3, %if.end
  %ret.0 = phi i32 [ %call2, %if.end ], [ %call7, %if.then3 ]
  %dev9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.575(%struct.device* %dev9)
  %tobool10 = icmp ne i32 %ret.0, 0
  %conv13 = sext i32 %ret.0 to i64
  %conv13.count = select i1 %tobool10, i64 %conv13, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %entry
  %retval.0 = phi i64 [ -4, %entry ], [ %conv13.count, %if.end8 ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_usb_device.664(%struct.device* %dev) #1 {
entry:
  %type = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 4
  %0 = load %struct.device_type*, %struct.device_type** %type, align 8, !tbaa !91
  %cmp = icmp eq %struct.device_type* %0, @usb_device_type
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare i32 @sysfs_merge_group(%struct.kobject*, %struct.attribute_group*) #2

; Function Attrs: nounwind uwtable
define internal i64 @usb3_hardware_lpm_u2_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call = call i32 @device_lock_interruptible(%struct.device* %dev1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.575(%struct.device* %dev4)
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %2 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -4, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @usb3_hardware_lpm_u1_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call = call i32 @device_lock_interruptible(%struct.device* %dev1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.575(%struct.device* %dev4)
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %2 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -4, %entry ]
  ret i64 %retval.0
}

declare i32 @sysfs_add_file_to_group(%struct.kobject*, %struct.attribute*, i8*) #2

; Function Attrs: nounwind uwtable
define internal i64 @read_descriptors(%struct.file* %filp, %struct.kobject* %kobj, %struct.bin_attribute* %attr, i8* %buf, i64 %off, i64 %count) #0 {
entry:
  %__UNIQUE_ID_min1_12 = alloca i64, align 8
  %__UNIQUE_ID_min2_13 = alloca i64, align 8
  %0 = bitcast %struct.kobject* %kobj to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.device*
  %2 = bitcast %struct.device* %1 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 -152
  %3 = bitcast i8* %add.ptr3 to %struct.usb_device*
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %nleft.0 = phi i64 [ %count, %entry ], [ %nleft.1, %for.inc ]
  %off.addr.0 = phi i64 [ %off, %entry ], [ %off.addr.1, %for.inc ]
  %buf.addr.0 = phi i8* [ %buf, %entry ], [ %buf.addr.1, %for.inc ]
  %cfgno.0 = phi i32 [ -1, %entry ], [ %inc, %for.inc ]
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 13
  %4 = load i8, i8* %bNumConfigurations, align 1, !tbaa !193
  %conv = zext i8 %4 to i32
  %cmp = icmp slt i32 %cfgno.0, %conv
  %cmp5 = icmp ugt i64 %nleft.0, 0
  %cmp5. = select i1 %cmp, i1 %cmp5, i1 false
  br i1 %cmp5., label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %cmp7 = icmp slt i32 %cfgno.0, 0
  br i1 %cmp7, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %descriptor9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 12
  %5 = bitcast %struct.usb_device_descriptor* %descriptor9 to i8*
  br label %if.end

if.else:                                          ; preds = %for.body
  %rawdescriptors = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 18
  %6 = load i8**, i8*** %rawdescriptors, align 8, !tbaa !196
  %idxprom = sext i32 %cfgno.0 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %6, i64 %idxprom
  %7 = load i8*, i8** %arrayidx, align 8, !tbaa !52
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 14
  %8 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !194
  %idxprom10 = sext i32 %cfgno.0 to i64
  %arrayidx11 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %8, i64 %idxprom10
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx11, i32 0, i32 0
  %wTotalLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 2
  %9 = load i16, i16* %wTotalLength, align 2, !tbaa !195
  %conv12 = zext i16 %9 to i64
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %srclen.0 = phi i64 [ 18, %if.then ], [ %conv12, %if.else ]
  %src.0 = phi i8* [ %5, %if.then ], [ %7, %if.else ]
  %cmp13 = icmp ult i64 %off.addr.0, %srclen.0
  br i1 %cmp13, label %if.then15, label %if.else24

if.then15:                                        ; preds = %if.end
  store i64 %nleft.0, i64* %__UNIQUE_ID_min1_12, align 8, !tbaa !53
  %sub = sub i64 %srclen.0, %off.addr.0
  store i64 %sub, i64* %__UNIQUE_ID_min2_13, align 8, !tbaa !53
  %10 = load i64, i64* %__UNIQUE_ID_min1_12, align 8, !tbaa !53
  %11 = load i64, i64* %__UNIQUE_ID_min2_13, align 8, !tbaa !53
  %cmp19 = icmp ult i64 %10, %11
  %12 = load i64, i64* %__UNIQUE_ID_min1_12, align 8
  %13 = load i64, i64* %__UNIQUE_ID_min2_13, align 8
  %cond = select i1 %cmp19, i64 %12, i64 %13
  %add.ptr21 = getelementptr i8, i8* %src.0, i64 %off.addr.0
  %call = call i8* @__memcpy(i8* %buf.addr.0, i8* %add.ptr21, i64 %cond)
  %sub22 = sub i64 %nleft.0, %cond
  %add.ptr23 = getelementptr inbounds i8, i8* %buf.addr.0, i64 %cond
  br label %for.inc

if.else24:                                        ; preds = %if.end
  %sub25 = sub i64 %off.addr.0, %srclen.0
  br label %for.inc

for.inc:                                          ; preds = %if.else24, %if.then15
  %nleft.1 = phi i64 [ %sub22, %if.then15 ], [ %nleft.0, %if.else24 ]
  %off.addr.1 = phi i64 [ 0, %if.then15 ], [ %sub25, %if.else24 ]
  %buf.addr.1 = phi i8* [ %add.ptr23, %if.then15 ], [ %buf.addr.0, %if.else24 ]
  %inc = add nsw i32 %cfgno.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %sub27 = sub i64 %count, %nleft.0
  ret i64 %sub27
}

; Function Attrs: nounwind uwtable
define void @usb_create_sysfs_intf_files(%struct.usb_interface* %intf) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev.641(%struct.usb_interface* %intf)
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %0 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !169
  %sysfs_files_created = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load = load i8, i8* %sysfs_files_created, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %cleanup.cont, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %unregistering = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load1 = load i8, i8* %unregistering, align 8
  %bf.lshr = lshr i8 %bf.load1, 2
  %bf.clear2 = and i8 %bf.lshr, 1
  %bf.cast3 = zext i8 %bf.clear2 to i32
  %tobool4 = icmp ne i32 %bf.cast3, 0
  br i1 %tobool4, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %string = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 4
  %1 = load i8*, i8** %string, align 8, !tbaa !577
  %tobool5 = icmp ne i8* %1, null
  br i1 %tobool5, label %if.end11, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 29
  %2 = load i32, i32* %quirks, align 4, !tbaa !199
  %conv = zext i32 %2 to i64
  %and = and i64 %conv, 8
  %tobool6 = icmp ne i64 %and, 0
  br i1 %tobool6, label %if.end11, label %if.then7

if.then7:                                         ; preds = %land.lhs.true
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 0
  %iInterface = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 8
  %3 = load i8, i8* %iInterface, align 8, !tbaa !645
  %conv8 = zext i8 %3 to i32
  %call9 = call i8* @usb_cache_string(%struct.usb_device* %call, i32 %conv8)
  %string10 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 4
  store i8* %call9, i8** %string10, align 8, !tbaa !577
  br label %if.end11

if.end11:                                         ; preds = %if.then7, %land.lhs.true, %if.end
  %string12 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 4
  %4 = load i8*, i8** %string12, align 8, !tbaa !577
  %tobool13 = icmp ne i8* %4, null
  br i1 %tobool13, label %land.lhs.true14, label %if.end18

land.lhs.true14:                                  ; preds = %if.end11
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call15 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* @dev_attr_interface)
  br label %if.end18

if.end18:                                         ; preds = %land.lhs.true14, %if.end11
  %sysfs_files_created19 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load20 = load i8, i8* %sysfs_files_created19, align 8
  %bf.clear21 = and i8 %bf.load20, -2
  %bf.set = or i8 %bf.clear21, 1
  store i8 %bf.set, i8* %sysfs_files_created19, align 8
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end18, %lor.lhs.false, %entry
  ret void
}

declare i32 @device_create_file(%struct.device*, %struct.device_attribute*) #2

; Function Attrs: nounwind uwtable
define internal i64 @interface_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -48
  %1 = bitcast i8* %add.ptr to %struct.usb_interface*
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %1, i32 0, i32 1
  %2 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !169
  %string2 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 4
  %3 = load volatile i8*, i8** %string2, align 8, !tbaa !52
  %tobool = icmp ne i8* %3, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %4 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %4 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_remove_sysfs_intf_files(%struct.usb_interface* %intf) #0 {
entry:
  %sysfs_files_created = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load = load i8, i8* %sysfs_files_created, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* @dev_attr_interface)
  %sysfs_files_created1 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load2 = load i8, i8* %sysfs_files_created1, align 8
  %bf.clear3 = and i8 %bf.load2, -2
  store i8 %bf.clear3, i8* %sysfs_files_created1, align 8
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare void @device_remove_file(%struct.device*, %struct.device_attribute*) #2

; Function Attrs: nounwind uwtable
define internal void @ep_device_release(%struct.device.3441* %dev) #0 {
entry:
  %0 = bitcast %struct.device.3441* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.ep_device*
  %2 = bitcast %struct.ep_device* %1 to i8*
  call void @kfree(i8* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_create_ep_devs(%struct.device.3441* %parent, %struct.usb_host_endpoint* %endpoint, %struct.usb_device.3478* %udev) #0 {
entry:
  %call = call i8* @kzalloc.676(i64 1440, i32 20971712)
  %0 = bitcast i8* %call to %struct.ep_device*
  %tobool = icmp ne %struct.ep_device* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %endpoint, i32 0, i32 0
  %desc2 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 0
  store %struct.usb_endpoint_descriptor* %desc, %struct.usb_endpoint_descriptor** %desc2, align 8, !tbaa !646
  %udev3 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 1
  store %struct.usb_device.3478* %udev, %struct.usb_device.3478** %udev3, align 8, !tbaa !648
  %dev = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 2
  %groups = getelementptr inbounds %struct.device.3441, %struct.device.3441* %dev, i32 0, i32 34
  store %struct.attribute_group** getelementptr inbounds ([2 x %struct.attribute_group*], [2 x %struct.attribute_group*]* @ep_dev_groups, i32 0, i32 0), %struct.attribute_group*** %groups, align 8, !tbaa !649
  %dev4 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 2
  %type = getelementptr inbounds %struct.device.3441, %struct.device.3441* %dev4, i32 0, i32 4
  store %struct.device_type.3443* bitcast ({ i8*, %struct.attribute_group**, i32 (%struct.device.3441*, %struct.kobj_uevent_env*)*, i8* (%struct.device.3441*, i16*, %struct.atomic_t*, %struct.atomic_t*)*, void (%struct.device.3441*)*, %struct.dev_pm_ops.3461* }* @usb_ep_device_type to %struct.device_type.3443*), %struct.device_type.3443** %type, align 8, !tbaa !650
  %dev5 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 2
  %parent6 = getelementptr inbounds %struct.device.3441, %struct.device.3441* %dev5, i32 0, i32 0
  store %struct.device.3441* %parent, %struct.device.3441** %parent6, align 8, !tbaa !651
  %dev7 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 2
  %desc8 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %endpoint, i32 0, i32 0
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc8, i32 0, i32 2
  %1 = load i8, i8* %bEndpointAddress, align 2, !tbaa !512
  %conv = zext i8 %1 to i32
  %call9 = call i32 (%struct.device.3441*, i8*, ...) bitcast (i32 (%struct.device*, i8*, ...)* @dev_set_name to i32 (%struct.device.3441*, i8*, ...)*)(%struct.device.3441* %dev7, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1.677, i32 0, i32 0), i32 %conv)
  %dev10 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 2
  %call11 = call i32 @device_register(%struct.device.3441* %dev10)
  %tobool12 = icmp ne i32 %call11, 0
  %dev17 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 2
  br i1 %tobool12, label %error_register, label %if.end14

if.end14:                                         ; preds = %if.end
  call void @device_enable_async_suspend.678(%struct.device.3441* %dev17)
  %ep_dev16 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %endpoint, i32 0, i32 6
  store %struct.ep_device* %0, %struct.ep_device** %ep_dev16, align 8, !tbaa !652
  br label %cleanup

error_register:                                   ; preds = %if.end
  call void bitcast (void (%struct.device*)* @put_device to void (%struct.device.3441*)*)(%struct.device.3441* %dev17)
  br label %cleanup

cleanup:                                          ; preds = %error_register, %if.end14, %entry
  %retval.0 = phi i32 [ %call11, %if.end14 ], [ %call11, %error_register ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.676(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call noalias i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

declare i32 @device_register(%struct.device.3441*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_enable_async_suspend.678(%struct.device.3441* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device.3441, %struct.device.3441* %dev, i32 0, i32 11
  %is_prepared = getelementptr inbounds %struct.dev_pm_info.3447, %struct.dev_pm_info.3447* %power, i32 0, i32 1
  %bf.load = load i16, i16* %is_prepared, align 4
  %bf.lshr = lshr i16 %bf.load, 3
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = trunc i16 %bf.clear to i1
  br i1 %bf.cast, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %power1 = getelementptr inbounds %struct.device.3441, %struct.device.3441* %dev, i32 0, i32 11
  %async_suspend = getelementptr inbounds %struct.dev_pm_info.3447, %struct.dev_pm_info.3447* %power1, i32 0, i32 1
  %bf.load2 = load i16, i16* %async_suspend, align 4
  %bf.clear3 = and i16 %bf.load2, -3
  %bf.set = or i16 %bf.clear3, 2
  store i16 %bf.set, i16* %async_suspend, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @direction_show(%struct.device.3441* %dev, %struct.device_attribute.3462* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device.3441* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.ep_device*
  %desc = getelementptr inbounds %struct.ep_device, %struct.ep_device* %1, i32 0, i32 0
  %2 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %desc, align 8, !tbaa !646
  %call = call i32 @usb_endpoint_xfer_control.681(%struct.usb_endpoint_descriptor* %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end6, label %if.else

if.else:                                          ; preds = %entry
  call void @usb_endpoint_dir_in.682()
  br label %if.end6

if.end6:                                          ; preds = %if.else, %entry
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %3 to i64
  ret i64 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_control.681(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_endpoint_dir_in.682() #1 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @type_show(%struct.device.3441* %dev, %struct.device_attribute.3462* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device.3441* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.ep_device*
  %desc = getelementptr inbounds %struct.ep_device, %struct.ep_device* %1, i32 0, i32 0
  %2 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %desc, align 8, !tbaa !646
  %call = call i32 @usb_endpoint_type.688(%struct.usb_endpoint_descriptor* %2)
  %Pivot6 = icmp slt i32 %call, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %call, 3
  br i1 %Pivot4, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %call, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %NewDefault

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %call, 1
  br i1 %Pivot, label %LeafBlock, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %call, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %NewDefault

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %LeafBlock, %NodeBlock, %LeafBlock1, %NodeBlock3
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %3 to i64
  ret i64 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_type.688(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal i64 @interval_show(%struct.device.3441* %dev, %struct.device_attribute.3462* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device.3441* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.ep_device*
  %desc = getelementptr inbounds %struct.ep_device, %struct.ep_device* %1, i32 0, i32 0
  %2 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %desc, align 8, !tbaa !646
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %2, i32 0, i32 2
  %3 = load i8, i8* %bEndpointAddress, align 1, !tbaa !309
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 128
  %desc1 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %1, i32 0, i32 0
  %4 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %desc1, align 8, !tbaa !646
  %call = call i32 @usb_endpoint_type.688(%struct.usb_endpoint_descriptor* %4)
  %Pivot6 = icmp slt i32 %call, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %call, 3
  br i1 %Pivot4, label %sw.bb9, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %call, 3
  br i1 %SwitchLeaf2, label %sw.bb19, label %sw.epilog

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %call, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb5

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %call, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %udev = getelementptr inbounds %struct.ep_device, %struct.ep_device* %1, i32 0, i32 1
  %5 = load %struct.usb_device.3478*, %struct.usb_device.3478** %udev, align 8, !tbaa !648
  %speed = getelementptr inbounds %struct.usb_device.3478, %struct.usb_device.3478* %5, i32 0, i32 4
  %6 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp eq i32 %6, 3
  br i1 %cmp, label %if.then, label %sw.epilog

if.then:                                          ; preds = %sw.bb
  br label %sw.epilog

sw.bb5:                                           ; preds = %NodeBlock
  br label %sw.epilog

sw.bb9:                                           ; preds = %NodeBlock3
  %udev10 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %1, i32 0, i32 1
  %7 = load %struct.usb_device.3478*, %struct.usb_device.3478** %udev10, align 8, !tbaa !648
  %speed11 = getelementptr inbounds %struct.usb_device.3478, %struct.usb_device.3478* %7, i32 0, i32 4
  %8 = load i32, i32* %speed11, align 4, !tbaa !177
  %cmp12 = icmp ne i32 %8, 3
  %tobool = icmp ne i32 %and, 0
  %or.cond = or i1 %cmp12, %tobool
  br i1 %or.cond, label %sw.epilog, label %if.then14

if.then14:                                        ; preds = %sw.bb9
  br label %sw.epilog

sw.bb19:                                          ; preds = %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb19, %if.then14, %sw.bb9, %sw.bb5, %if.then, %sw.bb, %LeafBlock, %LeafBlock1
  %9 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv44 = sext i32 %9 to i64
  ret i64 %conv44
}

; Function Attrs: nounwind uwtable
define internal i64 @wMaxPacketSize_show(%struct.device.3441* %dev, %struct.device_attribute.3462* %attr, i8* %buf) #0 {
entry:
  call void @usb_endpoint_maxp.697()
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_endpoint_maxp.697() #1 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @bInterval_show(%struct.device.3441* %dev, %struct.device_attribute.3462* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @bmAttributes_show.702(%struct.device.3441* %dev, %struct.device_attribute.3462* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @bEndpointAddress_show(%struct.device.3441* %dev, %struct.device_attribute.3462* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @bLength_show(%struct.device.3441* %dev, %struct.device_attribute.3462* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define void @usb_remove_ep_devs(%struct.usb_host_endpoint* %endpoint) #0 {
entry:
  %ep_dev1 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %endpoint, i32 0, i32 6
  %0 = load %struct.ep_device*, %struct.ep_device** %ep_dev1, align 8, !tbaa !652
  %tobool = icmp ne %struct.ep_device* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 2
  call void @device_unregister(%struct.device.3441* %dev)
  %ep_dev2 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %endpoint, i32 0, i32 6
  store %struct.ep_device* null, %struct.ep_device** %ep_dev2, align 8, !tbaa !652
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @device_unregister(%struct.device.3441*) #2

; Function Attrs: nounwind uwtable
define internal i32 @driver_probe(%struct.usb_interface* %intf, %struct.usb_device_id* %id) #0 {
entry:
  ret i32 -19
}

; Function Attrs: nounwind uwtable
define internal void @driver_disconnect(%struct.usb_interface* %intf) #0 {
entry:
  %call = call i8* @usb_get_intfdata.713(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.usb_dev_state*
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 0
  %1 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !98
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %2 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !106
  %conv = zext i8 %2 to i32
  %tobool = icmp ne %struct.usb_dev_state* %0, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %conv1 = zext i32 %conv to i64
  %cmp = icmp ult i64 %conv1, 64
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 1)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %conv7 = zext i32 %conv to i64
  %ifclaimed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 12
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %ifclaimed, i64 %conv7, i64* %ifclaimed) #8, !srcloc !653
  br label %if.end8

if.else:                                          ; preds = %if.end
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then6
  call void @usb_set_intfdata.716(%struct.usb_interface* %intf, i8* null)
  call void @destroy_async_on_interface(%struct.usb_dev_state* %0, i32 %conv)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end8, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @driver_suspend(%struct.usb_interface* %intf, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.atomic_t, align 4
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @driver_resume(%struct.usb_interface* %intf) #0 {
entry:
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @usb_get_intfdata.713(%struct.usb_interface* %intf) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i8* @dev_get_drvdata.729(%struct.device* %dev)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_set_intfdata.716(%struct.usb_interface* %intf, i8* %data) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @dev_set_drvdata.728(%struct.device* %dev, i8* %data)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @destroy_async_on_interface(%struct.usb_dev_state* %ps, i32 %ifnum) #0 {
entry:
  %hitlist = alloca %struct.list_head, align 8
  call void @INIT_LIST_HEAD.717(%struct.list_head* %hitlist)
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %async_pending, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !252
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %.sink = phi %struct.list_head* [ %2, %for.inc ], [ %1, %entry ]
  %p.0 = phi %struct.list_head* [ %1, %entry ], [ %2, %for.inc ]
  %next13 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next13, align 8, !tbaa !252
  %async_pending6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  %cmp7 = icmp ne %struct.list_head* %p.0, %async_pending6
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = bitcast %struct.list_head* %p.0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.async*
  %ifnum10 = getelementptr inbounds %struct.async, %struct.async* %4, i32 0, i32 5
  %5 = load i32, i32* %ifnum10, align 4, !tbaa !654
  %cmp11 = icmp eq i32 %ifnum, %5
  br i1 %cmp11, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @list_move_tail(%struct.list_head* %p.0, %struct.list_head* %hitlist)
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %lock14 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %6 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock14, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %6 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #8
  call void @destroy_async(%struct.usb_dev_state* %ps, %struct.list_head* %hitlist)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.717(%struct.list_head* %list) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !72
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !87
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_move_tail(%struct.list_head* %list, %struct.list_head* %head) #1 {
entry:
  call void @__list_del_entry.722(%struct.list_head* %list)
  call void @list_add_tail.726(%struct.list_head* %list, %struct.list_head* %head)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @destroy_async(%struct.usb_dev_state* %ps, %struct.list_head* %list) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %lock17 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock17, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  %call19 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %call5 = call i32 @list_empty.720(%struct.list_head* %list)
  %tobool = icmp ne i32 %call5, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !252
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.async*
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %3, i32 0, i32 0
  call void @list_del_init.721(%struct.list_head* %asynclist)
  %urb7 = getelementptr inbounds %struct.async, %struct.async* %3, i32 0, i32 8
  %4 = load %struct.urb*, %struct.urb** %urb7, align 8, !tbaa !656
  %call8 = call %struct.urb* bitcast (%struct.urb.744* (%struct.urb.744*)* @usb_get_urb to %struct.urb* (%struct.urb*)*)(%struct.urb* %4)
  %lock9 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %5 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock9, i32 0, i32 0
  %rlock.i4 = bitcast %union.anon.1* %5 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i4, i64 %call19) #8
  call void bitcast (void (%struct.urb.744*)* @usb_kill_urb to void (%struct.urb*)*)(%struct.urb* %4)
  call void bitcast (void (%struct.urb.744*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %4)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %lock24 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %6 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock24, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %6 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call19) #8
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty.720(%struct.list_head* %head) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %0 to i64*
  %2 = load volatile i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %arraydecay to i64*
  store i64 %2, i64* %3, align 8, !tbaa !86
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  %4 = load %struct.list_head*, %struct.list_head** %__val, align 8, !tbaa !72
  %cmp = icmp eq %struct.list_head* %4, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init.721(%struct.list_head* %entry1) #1 {
entry:
  call void @__list_del_entry.722(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD.717(%struct.list_head* %entry1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry.722(%struct.list_head* %entry1) #1 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !87
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !252
  call void @__list_del.723(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del.723(%struct.list_head* %prev, %struct.list_head* %next) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !87
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !72
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.726(%struct.list_head* %new, %struct.list_head* %head) #1 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !87
  call void @__list_add.727(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add.727(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #1 {
entry:
  %__u = alloca %union.anon.59, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !87
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !252
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !87
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !72
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !86
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !86
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @dev_set_drvdata.728(%struct.device* %dev, i8* %data) #1 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  store i8* %data, i8** %driver_data, align 8, !tbaa !117
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_get_drvdata.729(%struct.device* %dev) #1 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !117
  ret i8* %0
}

declare i64 @no_seek_end_llseek(%struct.file*, i64, i32) #2

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_read(%struct.file* %file, i8* %buf, i64 %nbytes, i64* %ppos) #0 {
entry:
  %temp_desc = alloca %struct.usb_device_descriptor, align 1
  %__UNIQUE_ID_min1_24 = alloca i32, align 4
  %__UNIQUE_ID_min2_25 = alloca i32, align 4
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !657
  %1 = bitcast i8* %0 to %struct.usb_dev_state*
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !658
  %3 = load i64, i64* %ppos, align 8, !tbaa !86
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock.730(%struct.device* %dev2)
  %call = call i32 @connected(%struct.usb_dev_state* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %err

if.else:                                          ; preds = %entry
  %cmp = icmp slt i64 %3, 0
  br i1 %cmp, label %err, label %if.end4

if.end4:                                          ; preds = %if.else
  %cmp5 = icmp ult i64 %3, 18
  br i1 %cmp5, label %if.then6, label %if.end34

if.then6:                                         ; preds = %if.end4
  %4 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 12
  %5 = bitcast %struct.usb_device_descriptor* %descriptor to i8*
  %call7 = call i8* @__memcpy(i8* %4, i8* %5, i64 18)
  %sub = sub i64 18, %3
  %conv = trunc i64 %sub to i32
  %conv17 = zext i32 %conv to i64
  %cmp18 = icmp ugt i64 %conv17, %nbytes
  %conv21 = trunc i64 %nbytes to i32
  %len.0 = select i1 %cmp18, i32 %conv21, i32 %conv
  %6 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 %3
  %conv23 = zext i32 %len.0 to i64
  %7 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr, i1 false, i1 true) #8
  %conv.i1 = trunc i64 %7 to i32
  call void @kasan_check_read(i8* %add.ptr, i32 %len.0) #8
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 718) #8
  %cmp.i2 = icmp slt i32 %conv.i1, 0
  %conv3.i3 = sext i32 %conv.i1 to i64
  %cmp4.i4 = icmp uge i64 %conv3.i3, %conv23
  %8 = select i1 %cmp.i2, i1 true, i1 %cmp4.i4
  %lnot.ext.i6 = zext i1 %8 to i32
  %conv7.i7 = sext i32 %lnot.ext.i6 to i64
  %expval.i8 = call i64 @llvm.expect.i64(i64 %conv7.i7, i64 1) #8
  %tobool.i9 = icmp ne i64 %expval.i8, 0
  br i1 %tobool.i9, label %if.then.i11, label %if.else.i12

if.then.i11:                                      ; preds = %if.then6
  call void @__check_object_size(i8* %add.ptr, i64 %conv23, i1 zeroext true) #8
  %call.i10 = call i64 @_copy_to_user(i8* %buf, i8* %add.ptr, i32 %len.0) #8
  br label %copy_to_user.exit14

if.else.i12:                                      ; preds = %if.then6
  call void @copy_user_overflow(i32 %conv.i1, i64 %conv23) #8
  br label %copy_to_user.exit14

copy_to_user.exit14:                              ; preds = %if.else.i12, %if.then.i11
  %n.addr.0.i13 = phi i64 [ %call.i10, %if.then.i11 ], [ %conv23, %if.else.i12 ]
  %tobool25 = icmp ne i64 %n.addr.0.i13, 0
  br i1 %tobool25, label %cleanup, label %if.end27

if.end27:                                         ; preds = %copy_to_user.exit14
  %conv28 = zext i32 %len.0 to i64
  %9 = load i64, i64* %ppos, align 8, !tbaa !86
  %add = add nsw i64 %9, %conv28
  store i64 %add, i64* %ppos, align 8, !tbaa !86
  %idx.ext = zext i32 %len.0 to i64
  %add.ptr29 = getelementptr inbounds i8, i8* %buf, i64 %idx.ext
  %conv30 = zext i32 %len.0 to i64
  %sub31 = sub i64 %nbytes, %conv30
  %conv32 = zext i32 %len.0 to i64
  %add33 = add nsw i64 0, %conv32
  br label %cleanup

cleanup:                                          ; preds = %if.end27, %copy_to_user.exit14
  %ret.0 = phi i64 [ %add33, %if.end27 ], [ -14, %copy_to_user.exit14 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end27 ], [ 2, %copy_to_user.exit14 ]
  %nbytes.addr.0 = phi i64 [ %sub31, %if.end27 ], [ %nbytes, %copy_to_user.exit14 ]
  %buf.addr.0 = phi i8* [ %add.ptr29, %if.end27 ], [ %buf, %copy_to_user.exit14 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %cleanup
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf2, label %err, label %cleanup104

LeafBlock:                                        ; preds = %cleanup
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end34, label %cleanup104

if.end34:                                         ; preds = %LeafBlock, %if.end4
  %ret.1 = phi i64 [ 0, %if.end4 ], [ %ret.0, %LeafBlock ]
  %nbytes.addr.1 = phi i64 [ %nbytes, %if.end4 ], [ %nbytes.addr.0, %LeafBlock ]
  %buf.addr.1 = phi i8* [ %buf, %if.end4 ], [ %buf.addr.0, %LeafBlock ]
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end34
  %ret.2 = phi i64 [ %ret.1, %if.end34 ], [ %ret.5, %for.inc ]
  %pos.0 = phi i64 [ 18, %if.end34 ], [ %pos.1, %for.inc ]
  %i.0 = phi i32 [ 0, %if.end34 ], [ %inc, %for.inc ]
  %nbytes.addr.2 = phi i64 [ %nbytes.addr.1, %if.end34 ], [ %nbytes.addr.5, %for.inc ]
  %buf.addr.2 = phi i8* [ %buf.addr.1, %if.end34 ], [ %buf.addr.5, %for.inc ]
  %tobool35 = icmp ne i64 %nbytes.addr.2, 0
  br i1 %tobool35, label %land.rhs, label %err

land.rhs:                                         ; preds = %for.cond
  %descriptor36 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor36, i32 0, i32 13
  %10 = load i8, i8* %bNumConfigurations, align 1, !tbaa !193
  %conv37 = zext i8 %10 to i32
  %cmp38 = icmp slt i32 %i.0, %conv37
  br i1 %cmp38, label %for.body, label %err

for.body:                                         ; preds = %land.rhs
  %rawdescriptors = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 18
  %11 = load i8**, i8*** %rawdescriptors, align 8, !tbaa !196
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %11, i64 %idxprom
  %12 = load i8*, i8** %arrayidx, align 8, !tbaa !52
  %13 = bitcast i8* %12 to %struct.usb_config_descriptor*
  %wTotalLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %13, i32 0, i32 2
  %14 = load i16, i16* %wTotalLength, align 1, !tbaa !578
  %conv40 = zext i16 %14 to i32
  %15 = load i64, i64* %ppos, align 8, !tbaa !86
  %conv41 = zext i32 %conv40 to i64
  %add42 = add nsw i64 %pos.0, %conv41
  %cmp43 = icmp slt i64 %15, %add42
  br i1 %cmp43, label %if.then45, label %if.end96

if.then45:                                        ; preds = %for.body
  %config46 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 14
  %16 = load %struct.usb_host_config*, %struct.usb_host_config** %config46, align 8, !tbaa !194
  %idxprom47 = sext i32 %i.0 to i64
  %arrayidx48 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %16, i64 %idxprom47
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx48, i32 0, i32 0
  %wTotalLength49 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 2
  %17 = load i16, i16* %wTotalLength49, align 2, !tbaa !195
  %conv50 = zext i16 %17 to i32
  %conv51 = zext i32 %conv40 to i64
  %18 = load i64, i64* %ppos, align 8, !tbaa !86
  %sub52 = sub nsw i64 %18, %pos.0
  %sub53 = sub nsw i64 %conv51, %sub52
  %conv54 = trunc i64 %sub53 to i32
  %conv55 = zext i32 %conv54 to i64
  %cmp56 = icmp ugt i64 %conv55, %nbytes.addr.2
  %conv59 = trunc i64 %nbytes.addr.2 to i32
  %conv59.conv54 = select i1 %cmp56, i32 %conv59, i32 %conv54
  %conv61 = zext i32 %conv50 to i64
  %19 = load i64, i64* %ppos, align 8, !tbaa !86
  %sub62 = sub nsw i64 %19, %pos.0
  %cmp63 = icmp sgt i64 %conv61, %sub62
  br i1 %cmp63, label %if.then65, label %if.end84

if.then65:                                        ; preds = %if.then45
  %20 = load i64, i64* %ppos, align 8, !tbaa !86
  %sub66 = sub nsw i64 %20, %pos.0
  %conv67 = zext i32 %conv50 to i64
  %sub68 = sub nsw i64 %conv67, %sub66
  %conv69 = trunc i64 %sub68 to i32
  %rawdescriptors70 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 18
  %21 = load i8**, i8*** %rawdescriptors70, align 8, !tbaa !196
  %idxprom71 = sext i32 %i.0 to i64
  %arrayidx72 = getelementptr inbounds i8*, i8** %21, i64 %idxprom71
  %22 = load i8*, i8** %arrayidx72, align 8, !tbaa !52
  %23 = load i64, i64* %ppos, align 8, !tbaa !86
  %sub73 = sub nsw i64 %23, %pos.0
  %add.ptr74 = getelementptr inbounds i8, i8* %22, i64 %sub73
  store i32 %conv59.conv54, i32* %__UNIQUE_ID_min1_24, align 4, !tbaa !73
  store i32 %conv69, i32* %__UNIQUE_ID_min2_25, align 4, !tbaa !73
  %24 = load i32, i32* %__UNIQUE_ID_min1_24, align 4, !tbaa !73
  %25 = load i32, i32* %__UNIQUE_ID_min2_25, align 4, !tbaa !73
  %cmp77 = icmp ult i32 %24, %25
  %26 = load i32, i32* %__UNIQUE_ID_min1_24, align 4
  %27 = load i32, i32* %__UNIQUE_ID_min2_25, align 4
  %cond = select i1 %cmp77, i32 %26, i32 %27
  %conv79 = zext i32 %cond to i64
  %28 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr74, i1 false, i1 true) #8
  %conv.i = trunc i64 %28 to i32
  call void @kasan_check_read(i8* %add.ptr74, i32 %cond) #8
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 718) #8
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, %conv79
  %29 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %29 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.then65
  call void @__check_object_size(i8* %add.ptr74, i64 %conv79, i1 zeroext true) #8
  %call.i = call i64 @_copy_to_user(i8* %buf.addr.2, i8* %add.ptr74, i32 %cond) #8
  br label %copy_to_user.exit

if.else.i:                                        ; preds = %if.then65
  call void @copy_user_overflow(i32 %conv.i, i64 %conv79) #8
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ %conv79, %if.else.i ]
  %tobool81 = icmp ne i64 %n.addr.0.i, 0
  br i1 %tobool81, label %LeafBlock4, label %if.end84

if.end84:                                         ; preds = %copy_to_user.exit, %if.then45
  %conv85 = zext i32 %conv59.conv54 to i64
  %30 = load i64, i64* %ppos, align 8, !tbaa !86
  %add86 = add nsw i64 %30, %conv85
  store i64 %add86, i64* %ppos, align 8, !tbaa !86
  %idx.ext87 = zext i32 %conv59.conv54 to i64
  %add.ptr88 = getelementptr inbounds i8, i8* %buf.addr.2, i64 %idx.ext87
  %conv89 = zext i32 %conv59.conv54 to i64
  %sub90 = sub i64 %nbytes.addr.2, %conv89
  %conv91 = zext i32 %conv59.conv54 to i64
  %add92 = add nsw i64 %ret.2, %conv91
  br label %LeafBlock4

LeafBlock4:                                       ; preds = %if.end84, %copy_to_user.exit
  %ret.3 = phi i64 [ %add92, %if.end84 ], [ -14, %copy_to_user.exit ]
  %cleanup.dest.slot.1 = phi i32 [ 0, %if.end84 ], [ 2, %copy_to_user.exit ]
  %nbytes.addr.3 = phi i64 [ %sub90, %if.end84 ], [ %nbytes.addr.2, %copy_to_user.exit ]
  %buf.addr.3 = phi i8* [ %add.ptr88, %if.end84 ], [ %buf.addr.2, %copy_to_user.exit ]
  %SwitchLeaf5 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf5, label %if.end96, label %NodeBlock11

if.end96:                                         ; preds = %LeafBlock4, %for.body
  %ret.4 = phi i64 [ %ret.2, %for.body ], [ %ret.3, %LeafBlock4 ]
  %nbytes.addr.4 = phi i64 [ %nbytes.addr.2, %for.body ], [ %nbytes.addr.3, %LeafBlock4 ]
  %buf.addr.4 = phi i8* [ %buf.addr.2, %for.body ], [ %buf.addr.3, %LeafBlock4 ]
  %conv97 = zext i32 %conv40 to i64
  %add98 = add nsw i64 %pos.0, %conv97
  br label %NodeBlock11

NodeBlock11:                                      ; preds = %if.end96, %LeafBlock4
  %ret.5 = phi i64 [ %ret.4, %if.end96 ], [ %ret.3, %LeafBlock4 ]
  %pos.1 = phi i64 [ %add98, %if.end96 ], [ %pos.0, %LeafBlock4 ]
  %cleanup.dest.slot.2 = phi i32 [ 0, %if.end96 ], [ %cleanup.dest.slot.1, %LeafBlock4 ]
  %nbytes.addr.5 = phi i64 [ %nbytes.addr.4, %if.end96 ], [ %nbytes.addr.3, %LeafBlock4 ]
  %buf.addr.5 = phi i8* [ %buf.addr.4, %if.end96 ], [ %buf.addr.3, %LeafBlock4 ]
  %Pivot12 = icmp slt i32 %cleanup.dest.slot.2, 2
  br i1 %Pivot12, label %LeafBlock7, label %LeafBlock9

LeafBlock9:                                       ; preds = %NodeBlock11
  %SwitchLeaf10 = icmp eq i32 %cleanup.dest.slot.2, 2
  br i1 %SwitchLeaf10, label %err, label %cleanup104

LeafBlock7:                                       ; preds = %NodeBlock11
  %SwitchLeaf8 = icmp eq i32 %cleanup.dest.slot.2, 0
  br i1 %SwitchLeaf8, label %for.inc, label %cleanup104

for.inc:                                          ; preds = %LeafBlock7
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

err:                                              ; preds = %LeafBlock9, %land.rhs, %for.cond, %LeafBlock1, %if.else, %entry
  %ret.6 = phi i64 [ %ret.5, %LeafBlock9 ], [ %ret.0, %LeafBlock1 ], [ -19, %entry ], [ -22, %if.else ], [ %ret.2, %for.cond ], [ %ret.2, %land.rhs ]
  %dev103 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock.732(%struct.device* %dev103)
  br label %cleanup104

cleanup104:                                       ; preds = %err, %LeafBlock7, %LeafBlock9, %LeafBlock, %LeafBlock1
  %retval.0 = phi i64 [ %ret.6, %err ], [ undef, %LeafBlock1 ], [ undef, %LeafBlock ], [ undef, %LeafBlock7 ], [ undef, %LeafBlock9 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !657
  %1 = bitcast i8* %0 to %struct.usb_dev_state*
  %wait1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 7
  call void @poll_wait(%struct.file* %file, %struct.__wait_queue_head* %wait1, %struct.poll_table_struct* %wait)
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 7
  %2 = load i32, i32* %f_mode, align 4, !tbaa !660
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %async_completed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 5
  %call = call i32 @list_empty.720(%struct.list_head* %async_completed)
  %tobool2 = icmp ne i32 %call, 0
  %or = or i32 0, 260
  %.or = select i1 %tobool2, i32 0, i32 %or
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %mask.0 = phi i32 [ 0, %entry ], [ %.or, %land.lhs.true ]
  %call3 = call i32 @connected(%struct.usb_dev_state* %1)
  %tobool4 = icmp ne i32 %call3, 0
  %or6 = or i32 %mask.0, 16
  %mask.0.or6 = select i1 %tobool4, i32 %mask.0, i32 %or6
  %list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 0
  %call8 = call i32 @list_empty.720(%struct.list_head* %list)
  %tobool9 = icmp ne i32 %call8, 0
  %or11 = or i32 %mask.0.or6, 8
  %mask.2 = select i1 %tobool9, i32 %or11, i32 %mask.0.or6
  ret i32 %mask.2
}

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %call = call i64 @usbdev_do_ioctl(i32 %cmd)
  %conv = trunc i64 %call to i32
  %conv1 = sext i32 %conv to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_compat_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %conv = trunc i64 %arg to i32
  %call = call i8* @compat_ptr(i32 %conv)
  %call1 = call i64 @usbdev_do_ioctl(i32 %cmd)
  %conv2 = trunc i64 %call1 to i32
  %conv3 = sext i32 %conv2 to i64
  ret i64 %conv3
}

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_mmap(%struct.file* %file, %struct.vm_area_struct* %vma) #0 {
entry:
  %dma_handle = alloca i64, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !657
  %1 = bitcast i8* %0 to %struct.usb_dev_state*
  %vm_end = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 1
  %2 = load i64, i64* %vm_end, align 8, !tbaa !661
  %vm_start = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 0
  %3 = load i64, i64* %vm_start, align 8, !tbaa !666
  %sub = sub i64 %2, %3
  %add = add i64 %sub, 64
  %call = call i32 @usbfs_increase_memory_usage(i64 %add)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i8* @kzalloc.740(i64 64, i32 20971712)
  %4 = bitcast i8* %call1 to %struct.usb_memory*
  %tobool2 = icmp ne %struct.usb_memory* %4, null
  br i1 %tobool2, label %if.end4, label %error_decrease_mem

if.end4:                                          ; preds = %if.end
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %call5 = call i8* @usb_alloc_coherent(%struct.usb_device* %5, i64 %sub, i32 21103296, i64* %dma_handle)
  %tobool6 = icmp ne i8* %call5, null
  br i1 %tobool6, label %if.end8, label %error_free_usbm

if.end8:                                          ; preds = %if.end4
  %call9 = call i8* @__memset(i8* %call5, i32 0, i64 %sub)
  %mem10 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %4, i32 0, i32 4
  store i8* %call5, i8** %mem10, align 8, !tbaa !667
  %6 = load i64, i64* %dma_handle, align 8, !tbaa !86
  %dma_handle11 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %4, i32 0, i32 5
  store i64 %6, i64* %dma_handle11, align 8, !tbaa !669
  %conv = trunc i64 %sub to i32
  %size12 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %4, i32 0, i32 3
  store i32 %conv, i32* %size12, align 8, !tbaa !670
  %ps13 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %4, i32 0, i32 7
  store %struct.usb_dev_state* %1, %struct.usb_dev_state** %ps13, align 8, !tbaa !671
  %vm_start14 = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 0
  %7 = load i64, i64* %vm_start14, align 8, !tbaa !666
  %vm_start15 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %4, i32 0, i32 6
  store i64 %7, i64* %vm_start15, align 8, !tbaa !672
  %vma_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %4, i32 0, i32 1
  store i32 1, i32* %vma_use_count, align 8, !tbaa !673
  %memlist = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %4, i32 0, i32 0
  call void @INIT_LIST_HEAD.717(%struct.list_head* %memlist)
  %vm_start16 = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 0
  %8 = load i64, i64* %vm_start16, align 8, !tbaa !666
  %mem17 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %4, i32 0, i32 4
  %9 = load i8*, i8** %mem17, align 8, !tbaa !667
  %call18 = call i64 @virt_to_phys(i8* %9)
  %shr = lshr i64 %call18, 12
  %vm_page_prot = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 7
  %coerce.dive = getelementptr inbounds %union.anon.3, %union.anon.3* %vm_page_prot, i32 0, i32 0
  %10 = load i64, i64* %coerce.dive, align 8
  %call19 = call i32 @remap_pfn_range(%struct.vm_area_struct* %vma, i64 %8, i64 %shr, i64 %sub, i64 %10)
  %cmp = icmp slt i32 %call19, 0
  br i1 %cmp, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.end8
  %vma_use_count22 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %4, i32 0, i32 1
  call void @dec_usb_memory_use_count(%struct.usb_memory* %4, i32* %vma_use_count22)
  br label %cleanup

if.end23:                                         ; preds = %if.end8
  %vm_flags = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 8
  %11 = load i64, i64* %vm_flags, align 8, !tbaa !674
  %or = or i64 %11, 16384
  store i64 %or, i64* %vm_flags, align 8, !tbaa !674
  %vm_flags24 = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 8
  %12 = load i64, i64* %vm_flags24, align 8, !tbaa !674
  %or25 = or i64 %12, 67371008
  store i64 %or25, i64* %vm_flags24, align 8, !tbaa !674
  %vm_ops = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 12
  store %struct.vm_operations_struct* @usbdev_vm_ops, %struct.vm_operations_struct** %vm_ops, align 8, !tbaa !675
  %13 = bitcast %struct.usb_memory* %4 to i8*
  %vm_private_data = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 15
  store i8* %13, i8** %vm_private_data, align 8, !tbaa !676
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 3
  %14 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %14 to %struct.raw_spinlock*
  %call30 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %memlist33 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %4, i32 0, i32 0
  %memory_list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 6
  call void @list_add_tail.726(%struct.list_head* %memlist33, %struct.list_head* %memory_list)
  %lock34 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 3
  %15 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock34, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %15 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call30) #8
  br label %cleanup

error_free_usbm:                                  ; preds = %if.end4
  %16 = bitcast %struct.usb_memory* %4 to i8*
  call void @kfree(i8* %16)
  br label %error_decrease_mem

error_decrease_mem:                               ; preds = %error_free_usbm, %if.end
  %add35 = add i64 %sub, 64
  call void @usbfs_decrease_memory_usage(i64 %add35)
  br label %cleanup

cleanup:                                          ; preds = %error_decrease_mem, %if.end23, %if.then21, %entry
  %retval.0 = phi i32 [ -11, %if.then21 ], [ 0, %if.end23 ], [ -12, %error_decrease_mem ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
declare i32 @usbdev_open(%struct.inode*, %struct.file*) #0

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %oldbit.i = alloca i8, align 1
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !657
  %1 = bitcast i8* %0 to %struct.usb_dev_state*
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !658
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock.730(%struct.device* %dev2)
  call void @usb_hub_release_all_ports(%struct.usb_device* %2, %struct.usb_dev_state* %1)
  %list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 0
  call void @list_del_init.721(%struct.list_head* %list)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %ifnum.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %ifclaimed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 12
  %3 = load i64, i64* %ifclaimed, align 8, !tbaa !677
  %tobool = icmp ne i64 %3, 0
  %conv = zext i32 %ifnum.0 to i64
  %cmp = icmp ult i64 %conv, 64
  %4 = select i1 %tobool, i1 %cmp, i1 false
  br i1 %4, label %cond.false, label %for.end

cond.false:                                       ; preds = %for.cond
  %conv7 = zext i32 %ifnum.0 to i64
  %ifclaimed8 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 12
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %ifclaimed8, i64 %conv7) #8, !srcloc !678
  %5 = load i8, i8* %oldbit.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %5 to i1
  br i1 %tobool.i, label %if.then, label %for.inc

if.then:                                          ; preds = %cond.false
  %call11 = call i32 @releaseintf(%struct.usb_dev_state* %1, i32 %ifnum.0)
  br label %for.inc

for.inc:                                          ; preds = %if.then, %cond.false
  %inc = add i32 %ifnum.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @destroy_all_async(%struct.usb_dev_state* %1)
  call void @usb_autosuspend_device(%struct.usb_device* %2)
  %dev12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock.732(%struct.device* %dev12)
  call void @usb_put_dev(%struct.usb_device* %2)
  %disc_pid = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 9
  %6 = load %struct.pid*, %struct.pid** %disc_pid, align 8, !tbaa !679
  call void @put_pid(%struct.pid* %6)
  %cred = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 10
  %7 = load %struct.cred*, %struct.cred** %cred, align 8, !tbaa !680
  call void @put_cred(%struct.cred* %7)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %call15 = call %struct.async* @async_getcompleted(%struct.usb_dev_state* %1)
  %tobool14 = icmp ne %struct.async* %call15, null
  br i1 %tobool14, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @free_async(%struct.async* %call15)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %8 = bitcast %struct.usb_dev_state* %1 to i8*
  call void @kfree(i8* %8)
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock.730(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @releaseintf(%struct.usb_dev_state* %ps, i32 %ifnum) #0 {
entry:
  %c.i = alloca i8, align 1
  %conv = zext i32 %ifnum to i64
  %cmp = icmp uge i64 %conv, 64
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev2 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8, !tbaa !658
  %call = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %0, i32 %ifnum)
  %tobool = icmp ne %struct.usb_interface* %call, null
  br i1 %tobool, label %if.else, label %cleanup

if.else:                                          ; preds = %if.end
  %conv4 = zext i32 %ifnum to i64
  %ifclaimed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 12
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2, $0;\0A\09setc $1\0A", "=*m,=*qm,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %ifclaimed, i8* %c.i, i64 %conv4, i64* %ifclaimed) #8, !srcloc !681
  %1 = load i8, i8* %c.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %1 to i1
  br i1 %tobool.i, label %if.then6, label %cleanup

if.then6:                                         ; preds = %if.else
  call void @usb_driver_release_interface(%struct.usb_driver* @usbfs_driver, %struct.usb_interface* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.then6, %if.else, %if.end, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -2, %if.end ], [ 0, %if.then6 ], [ -22, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @destroy_all_async(%struct.usb_dev_state* %ps) #0 {
entry:
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  call void @destroy_async(%struct.usb_dev_state* %ps, %struct.list_head* %async_pending)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock.732(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

declare void @put_pid(%struct.pid*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @put_cred(%struct.cred* %_cred) #1 {
entry:
  %c.i = alloca i8, align 1
  call void @__validate_creds(%struct.cred* %_cred, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.38.738, i32 0, i32 0), i32 263)
  %usage = getelementptr inbounds %struct.cred, %struct.cred* %_cred, i32 0, i32 0
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %usage, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0;\0A\09sete $1\0A", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i8* %c.i, i32* %counter.i) #8, !srcloc !682
  %0 = load i8, i8* %c.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %0 to i1
  br i1 %tobool.i, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__put_cred(%struct.cred* %_cred)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.async* @async_getcompleted(%struct.usb_dev_state* %ps) #0 {
entry:
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %async_completed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 5
  %call5 = call i32 @list_empty.720(%struct.list_head* %async_completed)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %async_completed6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 5
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %async_completed6, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !683
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.async*
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %3, i32 0, i32 0
  call void @list_del_init.721(%struct.list_head* %asynclist)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %as.0 = phi %struct.async* [ null, %entry ], [ %3, %if.then ]
  %lock8 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock8, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #8
  ret %struct.async* %as.0
}

; Function Attrs: nounwind uwtable
define internal void @free_async(%struct.async* %as) #0 {
entry:
  %pid = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 2
  %0 = load %struct.pid*, %struct.pid** %pid, align 8, !tbaa !684
  call void @put_pid(%struct.pid* %0)
  %cred = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 3
  %1 = load %struct.cred*, %struct.cred** %cred, align 8, !tbaa !685
  %tobool = icmp ne %struct.cred* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %cred1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 3
  %2 = load %struct.cred*, %struct.cred** %cred1, align 8, !tbaa !685
  call void @put_cred(%struct.cred* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %urb = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %3 = load %struct.urb*, %struct.urb** %urb, align 8, !tbaa !656
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %3, i32 0, i32 18
  %4 = load i32, i32* %num_sgs, align 4, !tbaa !398
  %cmp = icmp slt i32 %i.0, %4
  %urb2 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %5 = load %struct.urb*, %struct.urb** %urb2, align 8, !tbaa !656
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %5, i32 0, i32 16
  %6 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8, !tbaa !397
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %6, i64 %idxprom
  %sg_magic.i = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %arrayidx, i32 0, i32 0
  %7 = load i64, i64* %sg_magic.i, align 8, !tbaa !435
  %cmp.i = icmp ne i64 %7, 2271560481
  %lnot.ext.i = zext i1 %cmp.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv.i, i64 0) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %do.body2.i, label %do.body8.i

do.body2.i:                                       ; preds = %for.body
  call void @"simpll__inlineasm$0.1"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.37.737, i32 0, i32 0), i32 123, i64 12) #8
  br label %do.body3.i

do.body3.i:                                       ; preds = %do.body3.i, %do.body2.i
  br label %do.body3.i

do.body8.i:                                       ; preds = %for.body
  %page_link.i = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %arrayidx, i32 0, i32 1
  %8 = load i64, i64* %page_link.i, align 8, !tbaa !437
  %and.i = and i64 %8, 1
  %tobool9.i = icmp ne i64 %and.i, 0
  %lnot.ext13.i = zext i1 %tobool9.i to i32
  %conv14.i = sext i32 %lnot.ext13.i to i64
  %expval15.i = call i64 @llvm.expect.i64(i64 %conv14.i, i64 0) #8
  %tobool16.i = icmp ne i64 %expval15.i, 0
  br i1 %tobool16.i, label %do.body18.i, label %sg_page.733.exit

do.body18.i:                                      ; preds = %do.body8.i
  call void @"simpll__inlineasm$0.1"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.37.737, i32 0, i32 0), i32 124, i64 12) #8
  br label %do.body19.i

do.body19.i:                                      ; preds = %do.body19.i, %do.body18.i
  br label %do.body19.i

sg_page.733.exit:                                 ; preds = %do.body8.i
  %page_link27.i = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %arrayidx, i32 0, i32 1
  %9 = load i64, i64* %page_link27.i, align 8, !tbaa !437
  %and28.i = and i64 %9, -4
  %10 = inttoptr i64 %and28.i to %struct.page*
  %tobool3 = icmp ne %struct.page* %10, null
  br i1 %tobool3, label %if.then4, label %for.inc

if.then4:                                         ; preds = %sg_page.733.exit
  %urb5 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %11 = load %struct.urb*, %struct.urb** %urb5, align 8, !tbaa !656
  %sg6 = getelementptr inbounds %struct.urb, %struct.urb* %11, i32 0, i32 16
  %12 = load %struct.scatterlist*, %struct.scatterlist** %sg6, align 8, !tbaa !397
  %idxprom7 = sext i32 %i.0 to i64
  %arrayidx8 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %12, i64 %idxprom7
  %sg_magic.i.i = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %arrayidx8, i32 0, i32 0
  %13 = load i64, i64* %sg_magic.i.i, align 8, !tbaa !435
  %cmp.i.i = icmp ne i64 %13, 2271560481
  %lnot.ext.i.i = zext i1 %cmp.i.i to i32
  %conv.i.i = sext i32 %lnot.ext.i.i to i64
  %expval.i.i = call i64 @llvm.expect.i64(i64 %conv.i.i, i64 0) #8
  %tobool.i.i = icmp ne i64 %expval.i.i, 0
  br i1 %tobool.i.i, label %do.body2.i.i, label %do.body8.i.i

do.body2.i.i:                                     ; preds = %if.then4
  call void @"simpll__inlineasm$0.1"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.37.737, i32 0, i32 0), i32 123, i64 12) #8
  br label %do.body3.i.i

do.body3.i.i:                                     ; preds = %do.body3.i.i, %do.body2.i.i
  br label %do.body3.i.i

do.body8.i.i:                                     ; preds = %if.then4
  %page_link.i.i = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %arrayidx8, i32 0, i32 1
  %14 = load i64, i64* %page_link.i.i, align 8, !tbaa !437
  %and.i.i = and i64 %14, 1
  %tobool9.i.i = icmp ne i64 %and.i.i, 0
  %lnot.ext13.i.i = zext i1 %tobool9.i.i to i32
  %conv14.i.i = sext i32 %lnot.ext13.i.i to i64
  %expval15.i.i = call i64 @llvm.expect.i64(i64 %conv14.i.i, i64 0) #8
  %tobool16.i.i = icmp ne i64 %expval15.i.i, 0
  br i1 %tobool16.i.i, label %do.body18.i.i, label %sg_virt.734.exit

do.body18.i.i:                                    ; preds = %do.body8.i.i
  call void @"simpll__inlineasm$0.1"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.37.737, i32 0, i32 0), i32 124, i64 12) #8
  br label %do.body19.i.i

do.body19.i.i:                                    ; preds = %do.body19.i.i, %do.body18.i.i
  br label %do.body19.i.i

sg_virt.734.exit:                                 ; preds = %do.body8.i.i
  %page_link27.i.i = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %arrayidx8, i32 0, i32 1
  %15 = load i64, i64* %page_link27.i.i, align 8, !tbaa !437
  %and28.i.i = and i64 %15, -4
  %16 = load i64, i64* @vmemmap_base, align 8, !tbaa !53
  %sub.ptr.sub.i.i = sub i64 %and28.i.i, %16
  %sub.ptr.div.i.i = sdiv exact i64 %sub.ptr.sub.i.i, 64
  %shl.i.i = shl i64 %sub.ptr.div.i.i, 12
  %17 = load i64, i64* @page_offset_base, align 8, !tbaa !53
  %add.i.i = add i64 %shl.i.i, %17
  %18 = inttoptr i64 %add.i.i to i8*
  %offset.i = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %arrayidx8, i32 0, i32 2
  %19 = load i32, i32* %offset.i, align 8, !tbaa !427
  %idx.ext.i = zext i32 %19 to i64
  %add.ptr.i = getelementptr i8, i8* %18, i64 %idx.ext.i
  call void @kfree(i8* %add.ptr.i)
  br label %for.inc

for.inc:                                          ; preds = %sg_virt.734.exit, %sg_page.733.exit
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %20 = bitcast %struct.scatterlist* %6 to i8*
  call void @kfree(i8* %20)
  %usbm = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 9
  %21 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8, !tbaa !686
  %cmp13 = icmp eq %struct.usb_memory* %21, null
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %for.end
  %urb15 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %22 = load %struct.urb*, %struct.urb** %urb15, align 8, !tbaa !656
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %22, i32 0, i32 14
  %23 = load i8*, i8** %transfer_buffer, align 8, !tbaa !316
  call void @kfree(i8* %23)
  br label %if.end18

if.else:                                          ; preds = %for.end
  %usbm16 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 9
  %24 = load %struct.usb_memory*, %struct.usb_memory** %usbm16, align 8, !tbaa !686
  %usbm17 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 9
  %25 = load %struct.usb_memory*, %struct.usb_memory** %usbm17, align 8, !tbaa !686
  %urb_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %25, i32 0, i32 2
  call void @dec_usb_memory_use_count(%struct.usb_memory* %24, i32* %urb_use_count)
  br label %if.end18

if.end18:                                         ; preds = %if.else, %if.then14
  %urb19 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %26 = load %struct.urb*, %struct.urb** %urb19, align 8, !tbaa !656
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %26, i32 0, i32 21
  %27 = load i8*, i8** %setup_packet, align 8, !tbaa !425
  call void @kfree(i8* %27)
  %urb20 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %28 = load %struct.urb*, %struct.urb** %urb20, align 8, !tbaa !656
  call void bitcast (void (%struct.urb.744*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %28)
  %mem_usage = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 10
  %29 = load i32, i32* %mem_usage, align 8, !tbaa !687
  %conv = zext i32 %29 to i64
  call void @usbfs_decrease_memory_usage(i64 %conv)
  %30 = bitcast %struct.async* %as to i8*
  call void @kfree(i8* %30)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @dec_usb_memory_use_count(%struct.usb_memory* %usbm, i32* %count) #0 {
entry:
  %ps1 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %usbm, i32 0, i32 7
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps1, align 8, !tbaa !671
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 3
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %1 to %struct.raw_spinlock*
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %2 = load i32, i32* %count, align 4, !tbaa !73
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* %count, align 4, !tbaa !73
  %urb_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %usbm, i32 0, i32 2
  %3 = load i32, i32* %urb_use_count, align 4, !tbaa !688
  %cmp6 = icmp eq i32 %3, 0
  br i1 %cmp6, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %vma_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %usbm, i32 0, i32 1
  %4 = load i32, i32* %vma_use_count, align 8, !tbaa !673
  %cmp8 = icmp eq i32 %4, 0
  br i1 %cmp8, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %memlist = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %usbm, i32 0, i32 0
  call void @list_del.735(%struct.list_head* %memlist)
  %lock10 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 3
  %5 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock10, i32 0, i32 0
  %rlock.i4 = bitcast %union.anon.1* %5 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i4, i64 %call3) #8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %size = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %usbm, i32 0, i32 3
  %7 = load i32, i32* %size, align 8, !tbaa !670
  %conv11 = zext i32 %7 to i64
  %mem = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %usbm, i32 0, i32 4
  %8 = load i8*, i8** %mem, align 8, !tbaa !667
  %dma_handle = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %usbm, i32 0, i32 5
  %9 = load i64, i64* %dma_handle, align 8, !tbaa !669
  call void @usb_free_coherent(%struct.usb_device* %6, i64 %conv11, i8* %8, i64 %9)
  %size12 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %usbm, i32 0, i32 3
  %10 = load i32, i32* %size12, align 8, !tbaa !670
  %conv13 = zext i32 %10 to i64
  %add = add i64 %conv13, 64
  call void @usbfs_decrease_memory_usage(i64 %add)
  %11 = bitcast %struct.usb_memory* %usbm to i8*
  call void @kfree(i8* %11)
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %lock14 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 3
  %12 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock14, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %12 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call3) #8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usbfs_decrease_memory_usage(i64 %amount) #0 {
entry:
  call void @atomic64_sub(i64 %amount, %union.anon.3* @usbfs_memory_usage)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic64_sub(i64 %i, %union.anon.3* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.3, %union.anon.3* %v, i32 0, i32 0
  %counter1 = getelementptr inbounds %union.anon.3, %union.anon.3* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subq $1,$0", "=*m,er,*m,~{dirflag},~{fpsr},~{flags}"(i64* %counter, i64 %i, i64* %counter1) #8, !srcloc !689
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del.735(%struct.list_head* %entry1) #1 {
entry:
  call void @__list_del_entry.722(%struct.list_head* %entry1)
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8, !tbaa !252
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8, !tbaa !87
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__validate_creds(%struct.cred* %cred, i8* %file, i32 %line) #1 {
entry:
  %call = call zeroext i1 @creds_are_invalid(%struct.cred* %cred)
  %lnot = xor i1 %call, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__invalid_creds(%struct.cred* %cred, i8* %file, i32 %line)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @__put_cred(%struct.cred*) #2

declare zeroext i1 @creds_are_invalid(%struct.cred*) #2

declare void @__invalid_creds(%struct.cred*, i8*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.740(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call noalias i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @imajor() #1 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usbdev_lookup_by_devt(i32 %devt) #0 {
entry:
  %conv = zext i32 %devt to i64
  %0 = inttoptr i64 %conv to i8*
  %call = call %struct.device* @bus_find_device(%struct.bus_type* @usb_bus_type, %struct.device* null, i8* %0, i32 (%struct.device*, i8*)* @match_devt)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @task_pid() #1 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @get_pid(%struct.pid* %pid) #1 {
entry:
  %tobool = icmp ne %struct.pid* %pid, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %count = getelementptr inbounds %struct.pid, %struct.pid* %pid, i32 0, i32 0
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %count, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !690
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare i32 @debug_lockdep_rcu_enabled() #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @get_cred(%struct.cred* %cred) #1 {
entry:
  call void @__validate_creds(%struct.cred* %cred, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.38.738, i32 0, i32 0), i32 244)
  call void @get_new_cred(%struct.cred* %cred)
  ret void
}

declare void @security_task_getsecid(%struct.task_struct*, i32*) #2

; Function Attrs: inlinehint nounwind uwtable
declare void @task_pid_nr() #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @get_new_cred(%struct.cred* %cred) #1 {
entry:
  %usage = getelementptr inbounds %struct.cred, %struct.cred* %cred, i32 0, i32 0
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %usage, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !690
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @match_devt(%struct.device* %dev, i8* %data) #0 {
entry:
  %devt = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 28
  %0 = load i32, i32* %devt, align 8, !tbaa !691
  %1 = ptrtoint i8* %data to i64
  %conv = trunc i64 %1 to i32
  %cmp = icmp eq i32 %0, %conv
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define internal i32 @usbfs_increase_memory_usage(i64 %amount) #0 {
entry:
  %0 = load volatile i32, i32* @usbfs_memory_mb, align 4, !tbaa !73
  %conv = zext i32 %0 to i64
  %shl = shl i64 %conv, 20
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; addq $1,$0", "=*m,er,*m,~{dirflag},~{fpsr},~{flags}"(i64* getelementptr inbounds (%union.anon.3, %union.anon.3* @usbfs_memory_usage, i64 0, i32 0), i64 %amount, i64* getelementptr inbounds (%union.anon.3, %union.anon.3* @usbfs_memory_usage, i64 0, i32 0)) #8, !srcloc !692
  %cmp = icmp ugt i64 %shl, 0
  br i1 %cmp, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %entry
  %call = call i64 @atomic64_read(%union.anon.3* @usbfs_memory_usage)
  %cmp2 = icmp ugt i64 %call, %shl
  br i1 %cmp2, label %if.then, label %cleanup

if.then:                                          ; preds = %land.lhs.true
  call void @atomic64_sub(i64 %amount, %union.anon.3* @usbfs_memory_usage)
  br label %cleanup

cleanup:                                          ; preds = %if.then, %land.lhs.true, %entry
  %retval.0 = phi i32 [ -12, %if.then ], [ 0, %land.lhs.true ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @virt_to_phys(i8* %address) #1 {
entry:
  %0 = ptrtoint i8* %address to i64
  %call = call i64 @__phys_addr(i64 %0)
  ret i64 %call
}

declare i32 @remap_pfn_range(%struct.vm_area_struct*, i64, i64, i64, i64) #2

; Function Attrs: nounwind uwtable
define internal void @usbdev_vm_open(%struct.vm_area_struct* %vma) #0 {
entry:
  %vm_private_data = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 15
  %0 = load i8*, i8** %vm_private_data, align 8, !tbaa !676
  %1 = bitcast i8* %0 to %struct.usb_memory*
  %ps = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %1, i32 0, i32 7
  %2 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8, !tbaa !671
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %2, i32 0, i32 3
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %3 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %vma_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %1, i32 0, i32 1
  %4 = load i32, i32* %vma_use_count, align 8, !tbaa !673
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %vma_use_count, align 8, !tbaa !673
  %ps5 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %1, i32 0, i32 7
  %5 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps5, align 8, !tbaa !671
  %lock6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %5, i32 0, i32 3
  %6 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock6, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %6 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usbdev_vm_close(%struct.vm_area_struct* %vma) #0 {
entry:
  %vm_private_data = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 15
  %0 = load i8*, i8** %vm_private_data, align 8, !tbaa !676
  %1 = bitcast i8* %0 to %struct.usb_memory*
  %vma_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %1, i32 0, i32 1
  call void @dec_usb_memory_use_count(%struct.usb_memory* %1, i32* %vma_use_count)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @atomic64_read(%union.anon.3* %v) #1 {
entry:
  %__u = alloca %union.anon.3, align 8
  %counter = getelementptr inbounds %union.anon.3, %union.anon.3* %v, i32 0, i32 0
  %__c = bitcast %union.anon.3* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %0 = load volatile i64, i64* %counter, align 8, !tbaa !86
  %1 = bitcast i8* %arraydecay to i64*
  store i64 %0, i64* %1, align 8, !tbaa !86
  %__val = bitcast %union.anon.3* %__u to i64*
  %2 = load i64, i64* %__val, align 8, !tbaa !72
  ret i64 %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @compat_ptr(i32 %uptr) #1 {
entry:
  %conv = zext i32 %uptr to i64
  %0 = inttoptr i64 %conv to i8*
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_do_ioctl(i32 %cmd) #0 {
entry:
  br label %if.end

if.end:                                           ; preds = %entry
  %Pivot8 = icmp slt i32 %cmd, 1074287884
  br i1 %Pivot8, label %NodeBlock, label %NodeBlock5

NodeBlock5:                                       ; preds = %if.end
  %Pivot6 = icmp slt i32 %cmd, 1074287885
  br i1 %Pivot6, label %do.body, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock5
  %SwitchLeaf4 = icmp eq i32 %cmd, 1074287885
  br i1 %SwitchLeaf4, label %do.body9, label %NodeBlock106

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %cmd, 1074025741
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, 1074025741
  br i1 %SwitchLeaf2, label %do.body27, label %NodeBlock106

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cmd, 1074025740
  br i1 %SwitchLeaf, label %do.body18, label %NodeBlock106

do.body:                                          ; preds = %NodeBlock5
  %0 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool3 = trunc i8 %0 to i1
  br i1 %tobool3, label %if.then4, label %cleanup

if.then4:                                         ; preds = %do.body
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body9:                                         ; preds = %LeafBlock3
  %1 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool10 = trunc i8 %1 to i1
  br i1 %tobool10, label %if.then11, label %cleanup

if.then11:                                        ; preds = %do.body9
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body18:                                        ; preds = %LeafBlock
  %2 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool19 = trunc i8 %2 to i1
  br i1 %tobool19, label %if.then20, label %cleanup

if.then20:                                        ; preds = %do.body18
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body27:                                        ; preds = %LeafBlock1
  %3 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool28 = trunc i8 %3 to i1
  br i1 %tobool28, label %if.then29, label %cleanup

if.then29:                                        ; preds = %do.body27
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

NodeBlock106:                                     ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  %Pivot107 = icmp slt i32 %cmd, -2144578294
  br i1 %Pivot107, label %NodeBlock50, label %NodeBlock104

NodeBlock104:                                     ; preds = %NodeBlock106
  %Pivot105 = icmp slt i32 %cmd, -1072147200
  br i1 %Pivot105, label %NodeBlock76, label %NodeBlock102

NodeBlock102:                                     ; preds = %NodeBlock104
  %Pivot103 = icmp slt i32 %cmd, 21780
  br i1 %Pivot103, label %NodeBlock86, label %NodeBlock100

NodeBlock100:                                     ; preds = %NodeBlock102
  %Pivot101 = icmp slt i32 %cmd, 1074287889
  br i1 %Pivot101, label %do.body83, label %NodeBlock98

NodeBlock98:                                      ; preds = %NodeBlock100
  %Pivot99 = icmp slt i32 %cmd, 1090802952
  br i1 %Pivot99, label %do.body116, label %do.body107

NodeBlock86:                                      ; preds = %NodeBlock102
  %Pivot87 = icmp slt i32 %cmd, -1072147198
  br i1 %Pivot87, label %do.body41, label %NodeBlock84

NodeBlock84:                                      ; preds = %NodeBlock86
  %Pivot85 = icmp slt i32 %cmd, 21771
  br i1 %Pivot85, label %do.body53, label %do.body222

NodeBlock76:                                      ; preds = %NodeBlock104
  %Pivot77 = icmp slt i32 %cmd, -1072933614
  br i1 %Pivot77, label %NodeBlock60, label %NodeBlock74

NodeBlock74:                                      ; preds = %NodeBlock76
  %Pivot75 = icmp slt i32 %cmd, -1072671486
  br i1 %Pivot75, label %NodeBlock66, label %NodeBlock72

NodeBlock72:                                      ; preds = %NodeBlock74
  %Pivot73 = icmp slt i32 %cmd, -1072671470
  br i1 %Pivot73, label %do.body173, label %do.body258

NodeBlock66:                                      ; preds = %NodeBlock74
  %Pivot67 = icmp slt i32 %cmd, -1072671488
  br i1 %Pivot67, label %do.body212, label %do.body158

NodeBlock60:                                      ; preds = %NodeBlock76
  %Pivot61 = icmp slt i32 %cmd, -2143791862
  br i1 %Pivot61, label %do.body197, label %do.body143

NodeBlock50:                                      ; preds = %NodeBlock106
  %Pivot51 = icmp slt i32 %cmd, -2147199719
  br i1 %Pivot51, label %NodeBlock26, label %NodeBlock48

NodeBlock48:                                      ; preds = %NodeBlock50
  %Pivot49 = icmp slt i32 %cmd, -2146937586
  br i1 %Pivot49, label %NodeBlock34, label %NodeBlock46

NodeBlock46:                                      ; preds = %NodeBlock48
  %Pivot47 = icmp slt i32 %cmd, -2146937571
  br i1 %Pivot47, label %do.body188, label %do.body231

NodeBlock34:                                      ; preds = %NodeBlock48
  %Pivot35 = icmp slt i32 %cmd, -2147199718
  br i1 %Pivot35, label %do.body276, label %do.body125

NodeBlock26:                                      ; preds = %NodeBlock50
  %Pivot27 = icmp slt i32 %cmd, -2147199728
  br i1 %Pivot27, label %NodeBlock16, label %NodeBlock24

NodeBlock24:                                      ; preds = %NodeBlock26
  %Pivot25 = icmp slt i32 %cmd, -2147199723
  br i1 %Pivot25, label %do.body249, label %NodeBlock22

NodeBlock22:                                      ; preds = %NodeBlock24
  %Pivot23 = icmp slt i32 %cmd, -2147199720
  br i1 %Pivot23, label %do.body92, label %do.body267

NodeBlock16:                                      ; preds = %NodeBlock26
  %Pivot17 = icmp slt i32 %cmd, -2147199739
  br i1 %Pivot17, label %do.body68, label %NodeBlock14

NodeBlock14:                                      ; preds = %NodeBlock16
  %Pivot15 = icmp slt i32 %cmd, -2147199729
  br i1 %Pivot15, label %do.body134, label %do.body240

do.body41:                                        ; preds = %NodeBlock86
  %4 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool42 = trunc i8 %4 to i1
  br i1 %tobool42, label %if.then43, label %cleanup

if.then43:                                        ; preds = %do.body41
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body53:                                        ; preds = %NodeBlock84
  %5 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool54 = trunc i8 %5 to i1
  br i1 %tobool54, label %if.then55, label %cleanup

if.then55:                                        ; preds = %do.body53
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body68:                                        ; preds = %NodeBlock16
  %6 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool69 = trunc i8 %6 to i1
  br i1 %tobool69, label %if.then70, label %cleanup

if.then70:                                        ; preds = %do.body68
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body83:                                        ; preds = %NodeBlock100
  %7 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool84 = trunc i8 %7 to i1
  br i1 %tobool84, label %if.then85, label %cleanup

if.then85:                                        ; preds = %do.body83
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body92:                                        ; preds = %NodeBlock22
  %8 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool93 = trunc i8 %8 to i1
  br i1 %tobool93, label %if.then94, label %cleanup

if.then94:                                        ; preds = %do.body92
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body107:                                       ; preds = %NodeBlock98
  %9 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool108 = trunc i8 %9 to i1
  br i1 %tobool108, label %if.then109, label %cleanup

if.then109:                                       ; preds = %do.body107
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body116:                                       ; preds = %NodeBlock98
  %10 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool117 = trunc i8 %10 to i1
  br i1 %tobool117, label %if.then118, label %cleanup

if.then118:                                       ; preds = %do.body116
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body125:                                       ; preds = %NodeBlock34
  %11 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool126 = trunc i8 %11 to i1
  br i1 %tobool126, label %if.then127, label %cleanup

if.then127:                                       ; preds = %do.body125
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body134:                                       ; preds = %NodeBlock14
  %12 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool135 = trunc i8 %12 to i1
  br i1 %tobool135, label %if.then136, label %cleanup

if.then136:                                       ; preds = %do.body134
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body143:                                       ; preds = %NodeBlock60
  %13 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool144 = trunc i8 %13 to i1
  br i1 %tobool144, label %if.then145, label %cleanup

if.then145:                                       ; preds = %do.body143
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body158:                                       ; preds = %NodeBlock66
  %14 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool159 = trunc i8 %14 to i1
  br i1 %tobool159, label %if.then160, label %cleanup

if.then160:                                       ; preds = %do.body158
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body173:                                       ; preds = %NodeBlock72
  %15 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool174 = trunc i8 %15 to i1
  br i1 %tobool174, label %if.then175, label %cleanup

if.then175:                                       ; preds = %do.body173
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body188:                                       ; preds = %NodeBlock46
  %16 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool189 = trunc i8 %16 to i1
  br i1 %tobool189, label %if.then190, label %cleanup

if.then190:                                       ; preds = %do.body188
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body197:                                       ; preds = %NodeBlock60
  %17 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool198 = trunc i8 %17 to i1
  br i1 %tobool198, label %if.then199, label %cleanup

if.then199:                                       ; preds = %do.body197
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body212:                                       ; preds = %NodeBlock66
  %18 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool213 = trunc i8 %18 to i1
  br i1 %tobool213, label %if.then214, label %cleanup

if.then214:                                       ; preds = %do.body212
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body222:                                       ; preds = %NodeBlock84
  %19 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool223 = trunc i8 %19 to i1
  br i1 %tobool223, label %if.then224, label %cleanup

if.then224:                                       ; preds = %do.body222
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body231:                                       ; preds = %NodeBlock46
  %20 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool232 = trunc i8 %20 to i1
  br i1 %tobool232, label %if.then233, label %cleanup

if.then233:                                       ; preds = %do.body231
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body240:                                       ; preds = %NodeBlock14
  %21 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool241 = trunc i8 %21 to i1
  br i1 %tobool241, label %if.then242, label %cleanup

if.then242:                                       ; preds = %do.body240
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body249:                                       ; preds = %NodeBlock24
  %22 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool250 = trunc i8 %22 to i1
  br i1 %tobool250, label %if.then251, label %cleanup

if.then251:                                       ; preds = %do.body249
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body258:                                       ; preds = %NodeBlock72
  %23 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool259 = trunc i8 %23 to i1
  br i1 %tobool259, label %if.then260, label %cleanup

if.then260:                                       ; preds = %do.body258
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body267:                                       ; preds = %NodeBlock22
  %24 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool268 = trunc i8 %24 to i1
  br i1 %tobool268, label %if.then269, label %cleanup

if.then269:                                       ; preds = %do.body267
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

do.body276:                                       ; preds = %NodeBlock34
  %25 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool277 = trunc i8 %25 to i1
  br i1 %tobool277, label %if.then278, label %cleanup

if.then278:                                       ; preds = %do.body276
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then278, %do.body276, %if.then269, %do.body267, %if.then260, %do.body258, %if.then251, %do.body249, %if.then242, %do.body240, %if.then233, %do.body231, %if.then224, %do.body222, %if.then214, %do.body212, %if.then199, %do.body197, %if.then190, %do.body188, %if.then175, %do.body173, %if.then160, %do.body158, %if.then145, %do.body143, %if.then136, %do.body134, %if.then127, %do.body125, %if.then118, %do.body116, %if.then109, %do.body107, %if.then94, %do.body92, %if.then85, %do.body83, %if.then70, %do.body68, %if.then55, %do.body53, %if.then43, %do.body41, %if.then29, %do.body27, %if.then20, %do.body18, %if.then11, %do.body9, %if.then4, %do.body
  ret i64 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @file_inode() #1 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_reapurb(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %call = call %struct.async* @reap_as(%struct.usb_dev_state* %ps)
  %tobool = icmp ne %struct.async* %call, null
  br i1 %tobool, label %do.body, label %if.end6

do.body:                                          ; preds = %entry
  %0 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool2 = trunc i8 %0 to i1
  br i1 %tobool2, label %if.then3, label %do.end

if.then3:                                         ; preds = %do.body
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then3, %do.body
  %1 = bitcast i8* %arg to i8**
  call void @processcompl(%struct.async* %call, i8** %1)
  call void @free_async(%struct.async* %call)
  br label %cleanup

if.end6:                                          ; preds = %entry
  %2 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !693
  %call8 = call i32 @signal_pending(%struct.task_struct* %2)
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_reapurbnonblock(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %call = call %struct.async* @async_getcompleted(%struct.usb_dev_state* %ps)
  %tobool = icmp ne %struct.async* %call, null
  br i1 %tobool, label %do.body, label %if.else

do.body:                                          ; preds = %entry
  %0 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool2 = trunc i8 %0 to i1
  br i1 %tobool2, label %if.then3, label %do.end

if.then3:                                         ; preds = %do.body
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then3, %do.body
  %1 = bitcast i8* %arg to i8**
  call void @processcompl(%struct.async* %call, i8** %1)
  call void @free_async(%struct.async* %call)
  br label %if.end8

if.else:                                          ; preds = %entry
  %call6 = call i32 @connected(%struct.usb_dev_state* %ps)
  br label %if.end8

if.end8:                                          ; preds = %if.else, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_reapurb_compat(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %call = call %struct.async* @reap_as(%struct.usb_dev_state* %ps)
  %tobool = icmp ne %struct.async* %call, null
  br i1 %tobool, label %do.body, label %if.end6

do.body:                                          ; preds = %entry
  %0 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool2 = trunc i8 %0 to i1
  br i1 %tobool2, label %if.then3, label %do.end

if.then3:                                         ; preds = %do.body
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then3, %do.body
  %1 = bitcast i8* %arg to i8**
  call void @processcompl_compat(%struct.async* %call, i8** %1)
  call void @free_async(%struct.async* %call)
  br label %cleanup

if.end6:                                          ; preds = %entry
  %2 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !693
  %call8 = call i32 @signal_pending(%struct.task_struct* %2)
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_reapurbnonblock_compat(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %call = call %struct.async* @async_getcompleted(%struct.usb_dev_state* %ps)
  %tobool = icmp ne %struct.async* %call, null
  br i1 %tobool, label %do.body, label %if.else

do.body:                                          ; preds = %entry
  %0 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool2 = trunc i8 %0 to i1
  br i1 %tobool2, label %if.then3, label %do.end

if.then3:                                         ; preds = %do.body
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then3, %do.body
  %1 = bitcast i8* %arg to i8**
  call void @processcompl_compat(%struct.async* %call, i8** %1)
  call void @free_async(%struct.async* %call)
  br label %if.end8

if.else:                                          ; preds = %entry
  %call6 = call i32 @connected(%struct.usb_dev_state* %ps)
  br label %if.end8

if.end8:                                          ; preds = %if.else, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @connected(%struct.usb_dev_state* %ps) #0 {
entry:
  %list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 0
  %call = call i32 @list_empty.720(%struct.list_head* %list)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp ne i32 %1, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  %land.ext = zext i1 %2 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
declare void @proc_control() #0

declare { i64, i64 } @current_time(%struct.inode*) #2

; Function Attrs: nounwind uwtable
define internal void @proc_bulk(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %bulk = alloca %struct.usbdevfs_bulktransfer, align 8
  %len2 = alloca i32, align 4
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !658
  %1 = bitcast %struct.usbdevfs_bulktransfer* %bulk to i8*
  %2 = call i64 @llvm.objectsize.i64.p0i8(i8* %1, i1 false, i1 true) #8
  %conv.i2 = trunc i64 %2 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 696) #8
  call void @kasan_check_write(i8* %1, i32 24) #8
  %cmp.i3 = icmp slt i32 %conv.i2, 0
  %conv3.i4 = sext i32 %conv.i2 to i64
  %cmp4.i5 = icmp uge i64 %conv3.i4, 24
  %3 = select i1 %cmp.i3, i1 true, i1 %cmp4.i5
  %lnot.ext.i7 = zext i1 %3 to i32
  %conv7.i8 = sext i32 %lnot.ext.i7 to i64
  %expval.i9 = call i64 @llvm.expect.i64(i64 %conv7.i8, i64 1) #8
  %tobool.i10 = icmp ne i64 %expval.i9, 0
  br i1 %tobool.i10, label %if.then.i12, label %if.else.i13

if.then.i12:                                      ; preds = %entry
  call void @__check_object_size(i8* %1, i64 24, i1 zeroext false) #8
  %call.i11 = call i64 @_copy_from_user(i8* %1, i8* %arg, i32 24) #8
  br label %copy_from_user.exit15

if.else.i13:                                      ; preds = %entry
  call void @copy_user_overflow(i32 %conv.i2, i64 24) #8
  br label %copy_from_user.exit15

copy_from_user.exit15:                            ; preds = %if.else.i13, %if.then.i12
  %n.addr.0.i14 = phi i64 [ %call.i11, %if.then.i12 ], [ 24, %if.else.i13 ]
  %tobool = icmp ne i64 %n.addr.0.i14, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %copy_from_user.exit15
  %dev2 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8, !tbaa !658
  %ep = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %5 = load i32, i32* %ep, align 8, !tbaa !694
  %call3 = call i32 @findintfep(%struct.usb_device* %4, i32 %5)
  %cmp = icmp slt i32 %call3, 0
  br i1 %cmp, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %call6 = call i32 @checkintf(%struct.usb_dev_state* %ps, i32 %call3)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %cleanup, label %if.end9

if.end9:                                          ; preds = %if.end5
  %ep10 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %6 = load i32, i32* %ep10, align 8, !tbaa !694
  %and = and i32 %6, 128
  %tobool11 = icmp ne i32 %and, 0
  %ep13 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %7 = load i32, i32* %ep13, align 8, !tbaa !694
  %and14 = and i32 %7, 127
  %call15 = call i32 @__create_pipe.788(%struct.usb_device* %0, i32 %and14)
  %or = or i32 -1073741824, %call15
  %or16 = or i32 %or, 128
  %pipe.0 = select i1 %tobool11, i32 %or16, i32 %or
  %ep22 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %8 = load i32, i32* %ep22, align 8, !tbaa !694
  %and23 = and i32 %8, 128
  %tobool24 = icmp ne i32 %and23, 0
  %lnot = xor i1 %tobool24, true
  %lnot.ext = zext i1 %lnot to i32
  %call25 = call zeroext i16 @usb_maxpacket.815(%struct.usb_device* %0, i32 %pipe.0, i32 %lnot.ext)
  %tobool26 = icmp ne i16 %call25, 0
  br i1 %tobool26, label %if.end28, label %cleanup

if.end28:                                         ; preds = %if.end9
  %len = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 1
  %9 = load i32, i32* %len, align 4, !tbaa !696
  %conv = zext i32 %9 to i64
  %cmp29 = icmp uge i64 %conv, 2147483455
  br i1 %cmp29, label %cleanup, label %if.end32

if.end32:                                         ; preds = %if.end28
  %conv33 = zext i32 %9 to i64
  %add = add i64 %conv33, 192
  %call34 = call i32 @usbfs_increase_memory_usage(i64 %add)
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %cleanup, label %if.end37

if.end37:                                         ; preds = %if.end32
  %conv38 = zext i32 %9 to i64
  %call.i = call noalias i8* @__kmalloc(i64 %conv38, i32 20971712) #8
  %tobool40 = icmp ne i8* %call.i, null
  br i1 %tobool40, label %if.end42, label %done

if.end42:                                         ; preds = %if.end37
  %timeout = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 2
  %10 = load i32, i32* %timeout, align 8, !tbaa !697
  %ep43 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %11 = load i32, i32* %ep43, align 8, !tbaa !694
  %and44 = and i32 %11, 128
  %tobool45 = icmp ne i32 %and44, 0
  %tobool47 = icmp ne i32 %9, 0
  br i1 %tobool45, label %if.then46, label %if.else128

if.then46:                                        ; preds = %if.end42
  br i1 %tobool47, label %land.lhs.true, label %if.end113

land.lhs.true:                                    ; preds = %if.then46
  %12 = call i32 asm "movl %gs:$1,$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @__preempt_count) #9, !srcloc !698
  %and.i = and i32 %12, 2147483647
  %conv49 = sext i32 %and.i to i64
  %and50 = and i64 %conv49, 2031872
  %tobool51 = icmp ne i64 %and50, 0
  %lnot52 = xor i1 %tobool51, true
  %lnot54 = xor i1 %lnot52, true
  %lnot56 = xor i1 %lnot54, true
  %lnot58 = xor i1 %lnot56, true
  %lnot.ext59 = zext i1 %lnot58 to i32
  %tobool60 = icmp ne i32 %lnot.ext59, 0
  br i1 %tobool60, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %13 = load i8, i8* @proc_bulk.__warned, align 1, !tbaa !109, !range !110
  %tobool61 = trunc i8 %13 to i1
  %lnot62 = xor i1 %tobool61, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true
  %14 = phi i1 [ false, %land.lhs.true ], [ %lnot62, %land.rhs ]
  %lnot64 = xor i1 %14, true
  %lnot66 = xor i1 %lnot64, true
  %lnot.ext67 = zext i1 %lnot66 to i32
  %conv68 = sext i32 %lnot.ext67 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv68, i64 0)
  %tobool69 = icmp ne i64 %expval, 0
  br i1 %tobool69, label %if.then70, label %if.end88

if.then70:                                        ; preds = %land.end
  store i8 1, i8* @proc_bulk.__warned, align 1, !tbaa !109
  %tobool71 = icmp ne i32 1, 0
  %lnot72 = xor i1 %tobool71, true
  %lnot74 = xor i1 %lnot72, true
  %lnot.ext75 = zext i1 %lnot74 to i32
  %conv76 = sext i32 %lnot.ext75 to i64
  %expval77 = call i64 @llvm.expect.i64(i64 %conv76, i64 0)
  %tobool78 = icmp ne i64 %expval77, 0
  br i1 %tobool78, label %if.then79, label %if.end80

if.then79:                                        ; preds = %if.then70
  call void @warn_slowpath_null(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1200)
  br label %if.end80

if.end80:                                         ; preds = %if.then79, %if.then70
  br label %if.end88

if.end88:                                         ; preds = %if.end80, %land.end
  %data = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %15 = load i8*, i8** %data, align 8, !tbaa !699
  %16 = ptrtoint i8* %15 to i64
  %conv99 = zext i32 %9 to i64
  %17 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !693
  %thread = getelementptr inbounds %struct.task_struct, %struct.task_struct* %17, i32 0, i32 212
  %addr_limit = getelementptr inbounds %struct.thread_struct, %struct.thread_struct* %thread, i32 0, i32 19
  %seg = getelementptr inbounds %union.anon.3, %union.anon.3* %addr_limit, i32 0, i32 0
  %18 = load i64, i64* %seg, align 8, !tbaa !700
  %call101 = call zeroext i1 @__chk_range_not_ok(i64 %16, i64 %conv99, i64 %18)
  %frombool = zext i1 %call101 to i8
  %tobool102 = trunc i8 %frombool to i1
  %lnot103 = xor i1 %tobool102, true
  %lnot105 = xor i1 %lnot103, true
  %lnot107 = xor i1 %lnot105, true
  %lnot.ext108 = zext i1 %lnot107 to i32
  %conv109 = sext i32 %lnot.ext108 to i64
  %expval110 = call i64 @llvm.expect.i64(i64 %conv109, i64 1)
  %tobool111 = icmp ne i64 %expval110, 0
  br i1 %tobool111, label %if.end113, label %done

if.end113:                                        ; preds = %if.end88, %if.then46
  call void @snoop_urb(i8* null, i32 0, i8* null, i32 0)
  %dev114 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock.732(%struct.device* %dev114)
  %call115 = call i32 @usb_bulk_msg(%struct.usb_device* %0, i32 %pipe.0, i8* %call.i, i32 %9, i32* %len2, i32 %10)
  %dev116 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock.730(%struct.device* %dev116)
  %19 = load i32, i32* %len2, align 4, !tbaa !73
  call void @snoop_urb(i8* null, i32 1, i8* %call.i, i32 %19)
  %tobool117 = icmp eq i32 %call115, 0
  %20 = load i32, i32* %len2, align 4
  %tobool119 = icmp ne i32 %20, 0
  %or.cond = and i1 %tobool117, %tobool119
  br i1 %or.cond, label %if.then120, label %if.end141

if.then120:                                       ; preds = %if.end113
  %data121 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %21 = load i8*, i8** %data121, align 8, !tbaa !699
  %22 = load i32, i32* %len2, align 4, !tbaa !73
  %conv122 = sext i32 %22 to i64
  %23 = call i64 @llvm.objectsize.i64.p0i8(i8* %call.i, i1 false, i1 true) #8
  %conv.i16 = trunc i64 %23 to i32
  call void @kasan_check_read(i8* %call.i, i32 %22) #8
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 718) #8
  %cmp.i17 = icmp slt i32 %conv.i16, 0
  %conv3.i18 = sext i32 %conv.i16 to i64
  %cmp4.i19 = icmp uge i64 %conv3.i18, %conv122
  %24 = select i1 %cmp.i17, i1 true, i1 %cmp4.i19
  %lnot.ext.i21 = zext i1 %24 to i32
  %conv7.i22 = sext i32 %lnot.ext.i21 to i64
  %expval.i23 = call i64 @llvm.expect.i64(i64 %conv7.i22, i64 1) #8
  %tobool.i24 = icmp ne i64 %expval.i23, 0
  br i1 %tobool.i24, label %if.then.i26, label %if.else.i27

if.then.i26:                                      ; preds = %if.then120
  call void @__check_object_size(i8* %call.i, i64 %conv122, i1 zeroext true) #8
  %call.i25 = call i64 @_copy_to_user(i8* %21, i8* %call.i, i32 %22) #8
  br label %copy_to_user.exit

if.else.i27:                                      ; preds = %if.then120
  call void @copy_user_overflow(i32 %conv.i16, i64 %conv122) #8
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i27, %if.then.i26
  %n.addr.0.i28 = phi i64 [ %call.i25, %if.then.i26 ], [ %conv122, %if.else.i27 ]
  %tobool124 = icmp ne i64 %n.addr.0.i28, 0
  br i1 %tobool124, label %done, label %if.end141

if.else128:                                       ; preds = %if.end42
  br i1 %tobool47, label %if.then130, label %if.end137

if.then130:                                       ; preds = %if.else128
  %data131 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %25 = load i8*, i8** %data131, align 8, !tbaa !699
  %conv132 = zext i32 %9 to i64
  %26 = call i64 @llvm.objectsize.i64.p0i8(i8* %call.i, i1 false, i1 true) #8
  %conv.i = trunc i64 %26 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 696) #8
  call void @kasan_check_write(i8* %call.i, i32 %9) #8
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, %conv132
  %27 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %27 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.then130
  call void @__check_object_size(i8* %call.i, i64 %conv132, i1 zeroext false) #8
  %call.i1 = call i64 @_copy_from_user(i8* %call.i, i8* %25, i32 %9) #8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %if.then130
  call void @copy_user_overflow(i32 %conv.i, i64 %conv132) #8
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i1, %if.then.i ], [ %conv132, %if.else.i ]
  %tobool134 = icmp ne i64 %n.addr.0.i, 0
  br i1 %tobool134, label %done, label %if.end137

if.end137:                                        ; preds = %copy_from_user.exit, %if.else128
  call void @snoop_urb(i8* null, i32 0, i8* %call.i, i32 %9)
  %dev138 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock.732(%struct.device* %dev138)
  %call139 = call i32 @usb_bulk_msg(%struct.usb_device* %0, i32 %pipe.0, i8* %call.i, i32 %9, i32* %len2, i32 %10)
  %dev140 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock.730(%struct.device* %dev140)
  call void @snoop_urb(i8* null, i32 1, i8* null, i32 0)
  br label %if.end141

if.end141:                                        ; preds = %if.end137, %copy_to_user.exit, %if.end113
  br label %done

done:                                             ; preds = %if.end141, %copy_from_user.exit, %copy_to_user.exit, %if.end88, %if.end37
  call void @kfree(i8* %call.i)
  %conv144 = zext i32 %9 to i64
  %add145 = add i64 %conv144, 192
  call void @usbfs_decrease_memory_usage(i64 %add145)
  br label %cleanup

cleanup:                                          ; preds = %done, %if.end32, %if.end28, %if.end9, %if.end5, %if.end, %copy_from_user.exit15
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_resetep(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1257)
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4, i8* undef) #8, !srcloc !701
  %asmresult = extractvalue { i32*, i64, i8* } %1, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %conv3 = sext i32 %3 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %call = call i32 @findintfep(%struct.usb_device* %4, i32 %conv)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %call7 = call i32 @checkintf(%struct.usb_dev_state* %ps, i32 %call)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end6
  %dev11 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev11, align 8, !tbaa !658
  call void @check_reset_of_active_ep(%struct.usb_device* %5, i32 %conv)
  %dev12 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev12, align 8, !tbaa !658
  call void @usb_reset_endpoint(%struct.usb_device* %6, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.end6, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_resetdevice(%struct.usb_dev_state* %ps) #0 {
entry:
  %oldbit.i = alloca i8, align 1
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %actconfig1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 15
  %1 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig1, align 8, !tbaa !102
  %privileges_dropped = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 15
  %2 = load i8, i8* %privileges_dropped, align 8, !tbaa !702, !range !110
  %tobool = trunc i8 %2 to i1
  %tobool2 = icmp ne %struct.usb_host_config* %1, null
  %or.cond = and i1 %tobool, %tobool2
  br i1 %or.cond, label %if.then, label %if.end21

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %1, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %3 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv = zext i8 %3 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %if.end21

for.body:                                         ; preds = %for.cond
  %interface4 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %1, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface4, i64 0, i64 %idxprom
  %4 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !52
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 1
  %5 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !169
  %desc5 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %5, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc5, i32 0, i32 2
  %6 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !106
  %conv6 = zext i8 %6 to i32
  %call = call i32 @usb_interface_claimed(%struct.usb_interface* %4)
  %tobool7 = icmp ne i32 %call, 0
  br i1 %tobool7, label %cond.false, label %for.inc

cond.false:                                       ; preds = %for.body
  %conv12 = sext i32 %conv6 to i64
  %ifclaimed13 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 12
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %ifclaimed13, i64 %conv12) #8, !srcloc !678
  %7 = load i8, i8* %oldbit.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %7 to i1
  br i1 %tobool.i, label %for.inc, label %if.then16

if.then16:                                        ; preds = %cond.false
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

for.inc:                                          ; preds = %cond.false, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end21:                                         ; preds = %for.cond, %entry
  %dev22 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %8 = load %struct.usb_device*, %struct.usb_device** %dev22, align 8, !tbaa !658
  %call23 = call i32 @usb_reset_device(%struct.usb_device* %8)
  br label %cleanup

cleanup:                                          ; preds = %if.end21, %if.then16
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_clearhalt(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1276)
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4, i8* undef) #8, !srcloc !703
  %asmresult = extractvalue { i32*, i64, i8* } %1, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %conv3 = sext i32 %3 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %call = call i32 @findintfep(%struct.usb_device* %4, i32 %conv)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %call7 = call i32 @checkintf(%struct.usb_dev_state* %ps, i32 %call)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end6
  %dev11 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev11, align 8, !tbaa !658
  call void @check_reset_of_active_ep(%struct.usb_device* %5, i32 %conv)
  %and = and i32 %conv, 128
  %tobool12 = icmp ne i32 %and, 0
  %dev14 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev14, align 8, !tbaa !658
  %and15 = and i32 %conv, 127
  %call16 = call i32 @__create_pipe.788(%struct.usb_device* %6, i32 %and15)
  %or = or i32 -1073741824, %call16
  %or17 = or i32 %or, 128
  %pipe.0 = select i1 %tobool12, i32 %or17, i32 %or
  %dev23 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %7 = load %struct.usb_device*, %struct.usb_device** %dev23, align 8, !tbaa !658
  %call24 = call i32 @usb_clear_halt(%struct.usb_device* %7, i32 %pipe.0)
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.end6, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_getdriver(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %gd = alloca %struct.usbdevfs_getdriver, align 4
  %0 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  %1 = call i64 @llvm.objectsize.i64.p0i8(i8* %0, i1 false, i1 true) #8
  %conv.i = trunc i64 %1 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 696) #8
  call void @kasan_check_write(i8* %0, i32 260) #8
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, 260
  %2 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %2 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  call void @__check_object_size(i8* %0, i64 260, i1 zeroext false) #8
  %call.i = call i64 @_copy_from_user(i8* %0, i8* %arg, i32 260) #8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %entry
  call void @copy_user_overflow(i32 %conv.i, i64 260) #8
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ 260, %if.else.i ]
  %tobool = icmp ne i64 %n.addr.0.i, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %copy_from_user.exit
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %interface = getelementptr inbounds %struct.usbdevfs_getdriver, %struct.usbdevfs_getdriver* %gd, i32 0, i32 0
  %4 = load i32, i32* %interface, align 4, !tbaa !704
  %call1 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %3, i32 %4)
  %tobool2 = icmp ne %struct.usb_interface* %call1, null
  br i1 %tobool2, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end
  %dev3 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev3, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !118
  %tobool4 = icmp ne %struct.device_driver* %5, null
  br i1 %tobool4, label %if.else, label %cleanup

if.else:                                          ; preds = %lor.lhs.false
  %driver6 = getelementptr inbounds %struct.usbdevfs_getdriver, %struct.usbdevfs_getdriver* %gd, i32 0, i32 1
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %driver6, i32 0, i32 0
  %dev7 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver8 = getelementptr inbounds %struct.device, %struct.device* %dev7, i32 0, i32 7
  %6 = load %struct.device_driver*, %struct.device_driver** %driver8, align 8, !tbaa !118
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %6, i32 0, i32 0
  %7 = load i8*, i8** %name, align 8, !tbaa !706
  %call9 = call i64 @strlcpy(i8* %arraydecay, i8* %7, i64 256)
  %8 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  %9 = call i64 @llvm.objectsize.i64.p0i8(i8* %8, i1 false, i1 true) #8
  %conv.i1 = trunc i64 %9 to i32
  call void @kasan_check_read(i8* %8, i32 260) #8
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 718) #8
  %cmp.i2 = icmp slt i32 %conv.i1, 0
  %conv3.i3 = sext i32 %conv.i1 to i64
  %cmp4.i4 = icmp uge i64 %conv3.i3, 260
  %10 = select i1 %cmp.i2, i1 true, i1 %cmp4.i4
  %lnot.ext.i6 = zext i1 %10 to i32
  %conv7.i7 = sext i32 %lnot.ext.i6 to i64
  %expval.i8 = call i64 @llvm.expect.i64(i64 %conv7.i7, i64 1) #8
  %tobool.i9 = icmp ne i64 %expval.i8, 0
  br i1 %tobool.i9, label %if.then.i11, label %if.else.i12

if.then.i11:                                      ; preds = %if.else
  call void @__check_object_size(i8* %8, i64 260, i1 zeroext true) #8
  %call.i10 = call i64 @_copy_to_user(i8* %arg, i8* %8, i32 260) #8
  br label %copy_to_user.exit

if.else.i12:                                      ; preds = %if.else
  call void @copy_user_overflow(i32 %conv.i1, i64 260) #8
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i12, %if.then.i11
  br label %cleanup

cleanup:                                          ; preds = %copy_to_user.exit, %lor.lhs.false, %if.end, %copy_from_user.exit
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_connectinfo(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %ci = alloca %struct.usbdevfs_connectinfo, align 4
  %0 = bitcast %struct.usbdevfs_connectinfo* %ci to i8*
  %call = call i8* @__memset(i8* %0, i32 0, i64 8)
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 0
  %2 = load i32, i32* %devnum, align 8, !tbaa !44
  %devnum1 = getelementptr inbounds %struct.usbdevfs_connectinfo, %struct.usbdevfs_connectinfo* %ci, i32 0, i32 0
  store i32 %2, i32* %devnum1, align 4, !tbaa !707
  %dev2 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8, !tbaa !658
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 4
  %4 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp eq i32 %4, 1
  %conv = zext i1 %cmp to i32
  %conv3 = trunc i32 %conv to i8
  %slow = getelementptr inbounds %struct.usbdevfs_connectinfo, %struct.usbdevfs_connectinfo* %ci, i32 0, i32 1
  store i8 %conv3, i8* %slow, align 4, !tbaa !709
  %5 = bitcast %struct.usbdevfs_connectinfo* %ci to i8*
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %5, i1 false, i1 true) #8
  %conv.i = trunc i64 %6 to i32
  call void @kasan_check_read(i8* %5, i32 8) #8
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 718) #8
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, 8
  %7 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %7 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  call void @__check_object_size(i8* %5, i64 8, i1 zeroext true) #8
  %call.i = call i64 @_copy_to_user(i8* %arg, i8* %5, i32 8) #8
  br label %copy_to_user.exit

if.else.i:                                        ; preds = %entry
  call void @copy_user_overflow(i32 %conv.i, i64 8) #8
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i, %if.then.i
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_setintf(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %setintf = alloca %struct.anon.26, align 4
  %0 = bitcast %struct.anon.26* %setintf to i8*
  %1 = call i64 @llvm.objectsize.i64.p0i8(i8* %0, i1 false, i1 true) #8
  %conv.i = trunc i64 %1 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 696) #8
  call void @kasan_check_write(i8* %0, i32 8) #8
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, 8
  %2 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %2 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  call void @__check_object_size(i8* %0, i64 8, i1 zeroext false) #8
  %call.i = call i64 @_copy_from_user(i8* %0, i8* %arg, i32 8) #8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %entry
  call void @copy_user_overflow(i32 %conv.i, i64 8) #8
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ 8, %if.else.i ]
  %tobool = icmp ne i64 %n.addr.0.i, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %copy_from_user.exit
  %interface = getelementptr inbounds %struct.anon.26, %struct.anon.26* %setintf, i32 0, i32 0
  %3 = load i32, i32* %interface, align 4, !tbaa !710
  %call1 = call i32 @checkintf(%struct.usb_dev_state* %ps, i32 %3)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %interface5 = getelementptr inbounds %struct.anon.26, %struct.anon.26* %setintf, i32 0, i32 0
  %4 = load i32, i32* %interface5, align 4, !tbaa !710
  call void @destroy_async_on_interface(%struct.usb_dev_state* %ps, i32 %4)
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %interface6 = getelementptr inbounds %struct.anon.26, %struct.anon.26* %setintf, i32 0, i32 0
  %6 = load i32, i32* %interface6, align 4, !tbaa !710
  %altsetting = getelementptr inbounds %struct.anon.26, %struct.anon.26* %setintf, i32 0, i32 1
  %7 = load i32, i32* %altsetting, align 4, !tbaa !712
  %call7 = call i32 @usb_set_interface(%struct.usb_device* %5, i32 %6, i32 %7)
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end, %copy_from_user.exit
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_setconfig(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1375)
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4, i8* undef) #8, !srcloc !713
  %asmresult = extractvalue { i32*, i64, i8* } %1, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %conv3 = sext i32 %3 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %actconfig4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 15
  %5 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig4, align 8, !tbaa !102
  %tobool5 = icmp ne %struct.usb_host_config* %5, null
  br i1 %tobool5, label %if.then6, label %if.end24

if.then6:                                         ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then6
  %i.0 = phi i32 [ 0, %if.then6 ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %6 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv7 = zext i8 %6 to i32
  %cmp = icmp slt i32 %i.0, %conv7
  br i1 %cmp, label %for.body, label %if.end24

for.body:                                         ; preds = %for.cond
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %7 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !52
  %call = call i32 @usb_interface_claimed(%struct.usb_interface* %7)
  %tobool9 = icmp ne i32 %call, 0
  br i1 %tobool9, label %if.then10, label %for.inc

if.then10:                                        ; preds = %for.body
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end24

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end24:                                         ; preds = %if.then10, %for.cond, %if.end
  %status.1 = phi i32 [ 0, %if.end ], [ -16, %if.then10 ], [ 0, %for.cond ]
  %cmp25 = icmp eq i32 %status.1, 0
  br i1 %cmp25, label %if.then27, label %cleanup

if.then27:                                        ; preds = %if.end24
  %tobool28 = icmp ne %struct.usb_host_config* %5, null
  br i1 %tobool28, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then27
  %desc29 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 0
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc29, i32 0, i32 4
  %8 = load i8, i8* %bConfigurationValue, align 1, !tbaa !168
  %conv30 = zext i8 %8 to i32
  %cmp31 = icmp eq i32 %conv30, %conv
  br i1 %cmp31, label %if.then33, label %if.else

if.then33:                                        ; preds = %land.lhs.true
  %dev34 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %dev34, align 8, !tbaa !658
  %call35 = call i32 @usb_reset_configuration(%struct.usb_device* %9)
  br label %cleanup

if.else:                                          ; preds = %land.lhs.true, %if.then27
  %dev36 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %dev36, align 8, !tbaa !658
  %call37 = call i32 @usb_set_configuration(%struct.usb_device* %10, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.then33, %if.end24, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_submiturb(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %uurb = alloca %struct.usbdevfs_urb, align 8
  %0 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  %1 = call i64 @llvm.objectsize.i64.p0i8(i8* %0, i1 false, i1 true) #8
  %conv.i = trunc i64 %1 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 696) #8
  call void @kasan_check_write(i8* %0, i32 56) #8
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, 56
  %2 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %2 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  call void @__check_object_size(i8* %0, i64 56, i1 zeroext false) #8
  %call.i = call i64 @_copy_from_user(i8* %0, i8* %arg, i32 56) #8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %entry
  call void @copy_user_overflow(i32 %conv.i, i64 56) #8
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ 56, %if.else.i ]
  %tobool = icmp ne i64 %n.addr.0.i, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %copy_from_user.exit
  %3 = bitcast i8* %arg to %struct.usbdevfs_urb*
  %iso_frame_desc = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %3, i32 0, i32 12
  %arraydecay = getelementptr inbounds [0 x %struct.exception_table_entry], [0 x %struct.exception_table_entry]* %iso_frame_desc, i32 0, i32 0
  call void @proc_do_submiturb(%struct.usb_dev_state* %ps, %struct.usbdevfs_urb* %uurb, %struct.exception_table_entry* %arraydecay, i8* %arg)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %copy_from_user.exit
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_control_compat(%struct.usbdevfs_ctrltransfer32* %p32) #0 {
entry:
  %call = call i8* @compat_alloc_user_space(i64 24)
  %0 = bitcast i8* %call to %struct.usbdevfs_ctrltransfer*
  %1 = bitcast %struct.usbdevfs_ctrltransfer* %0 to i8*
  %2 = bitcast %struct.usbdevfs_ctrltransfer32* %p32 to i8*
  %call1 = call i64 @copy_in_user(i8* %1, i8* %2, i32 12)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1932)
  %data = getelementptr inbounds %struct.usbdevfs_ctrltransfer32, %struct.usbdevfs_ctrltransfer32* %p32, i32 0, i32 6
  %3 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %data, i64 4, i8* undef) #8, !srcloc !714
  %asmresult = extractvalue { i32*, i64, i8* } %3, 0
  %asmresult2 = extractvalue { i32*, i64, i8* } %3, 1
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  %conv = trunc i64 %asmresult2 to i32
  %conv4 = sext i32 %5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %cleanup, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1933)
  %call7 = call i8* @compat_ptr(i32 %conv)
  %data8 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %0, i32 0, i32 6
  %6 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %call7, i8** %data8) #8, !srcloc !715
  %7 = ptrtoint i8* %6 to i64
  %8 = trunc i64 %7 to i32
  %conv10 = sext i32 %8 to i64
  %expval11 = call i64 @llvm.expect.i64(i64 %conv10, i64 0)
  %tobool12 = icmp ne i64 %expval11, 0
  br i1 %tobool12, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false6
  call void @proc_control()
  br label %cleanup

cleanup:                                          ; preds = %if.end, %lor.lhs.false6, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_bulk_compat(%struct.usb_dev_state* %ps, %struct.usb3_lpm_parameters* %p32) #0 {
entry:
  %call = call i8* @compat_alloc_user_space(i64 24)
  %0 = bitcast i8* %call to %struct.usbdevfs_bulktransfer*
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1947)
  %ep = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %p32, i32 0, i32 0
  %1 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %ep, i64 4, i8* undef) #8, !srcloc !716
  %asmresult = extractvalue { i32*, i64, i8* } %1, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %conv3 = sext i32 %3 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1947)
  %ep4 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %0, i32 0, i32 0
  %4 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv, i32* %ep4) #8, !srcloc !717
  %conv6 = sext i32 %4 to i64
  %expval7 = call i64 @llvm.expect.i64(i64 %conv6, i64 0)
  %tobool8 = icmp ne i64 %expval7, 0
  br i1 %tobool8, label %cleanup, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1948)
  %len = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %p32, i32 0, i32 1
  %5 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %len, i64 4, i8* undef) #8, !srcloc !718
  %asmresult13 = extractvalue { i32*, i64, i8* } %5, 0
  %asmresult14 = extractvalue { i32*, i64, i8* } %5, 1
  %6 = ptrtoint i32* %asmresult13 to i64
  %7 = trunc i64 %6 to i32
  %conv16 = trunc i64 %asmresult14 to i32
  %conv18 = sext i32 %7 to i64
  %expval19 = call i64 @llvm.expect.i64(i64 %conv18, i64 0)
  %tobool20 = icmp ne i64 %expval19, 0
  br i1 %tobool20, label %cleanup, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %lor.lhs.false9
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1948)
  %len24 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %0, i32 0, i32 1
  %8 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv16, i32* %len24) #8, !srcloc !719
  %conv26 = sext i32 %8 to i64
  %expval27 = call i64 @llvm.expect.i64(i64 %conv26, i64 0)
  %tobool28 = icmp ne i64 %expval27, 0
  br i1 %tobool28, label %cleanup, label %lor.lhs.false29

lor.lhs.false29:                                  ; preds = %lor.lhs.false21
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1949)
  %timeout = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %p32, i32 0, i32 2
  %9 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %timeout, i64 4, i8* undef) #8, !srcloc !720
  %asmresult33 = extractvalue { i32*, i64, i8* } %9, 0
  %asmresult34 = extractvalue { i32*, i64, i8* } %9, 1
  %10 = ptrtoint i32* %asmresult33 to i64
  %11 = trunc i64 %10 to i32
  %conv36 = trunc i64 %asmresult34 to i32
  %conv38 = sext i32 %11 to i64
  %expval39 = call i64 @llvm.expect.i64(i64 %conv38, i64 0)
  %tobool40 = icmp ne i64 %expval39, 0
  br i1 %tobool40, label %cleanup, label %lor.lhs.false41

lor.lhs.false41:                                  ; preds = %lor.lhs.false29
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1949)
  %timeout44 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %0, i32 0, i32 2
  %12 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv36, i32* %timeout44) #8, !srcloc !721
  %conv46 = sext i32 %12 to i64
  %expval47 = call i64 @llvm.expect.i64(i64 %conv46, i64 0)
  %tobool48 = icmp ne i64 %expval47, 0
  br i1 %tobool48, label %cleanup, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %lor.lhs.false41
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1950)
  %data = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %p32, i32 0, i32 3
  %13 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %data, i64 4, i8* undef) #8, !srcloc !722
  %asmresult53 = extractvalue { i32*, i64, i8* } %13, 0
  %asmresult54 = extractvalue { i32*, i64, i8* } %13, 1
  %14 = ptrtoint i32* %asmresult53 to i64
  %15 = trunc i64 %14 to i32
  %conv56 = trunc i64 %asmresult54 to i32
  %conv58 = sext i32 %15 to i64
  %expval59 = call i64 @llvm.expect.i64(i64 %conv58, i64 0)
  %tobool60 = icmp ne i64 %expval59, 0
  br i1 %tobool60, label %cleanup, label %lor.lhs.false61

lor.lhs.false61:                                  ; preds = %lor.lhs.false49
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1950)
  %call64 = call i8* @compat_ptr(i32 %conv56)
  %data65 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %0, i32 0, i32 3
  %16 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %call64, i8** %data65) #8, !srcloc !723
  %17 = ptrtoint i8* %16 to i64
  %18 = trunc i64 %17 to i32
  %conv67 = sext i32 %18 to i64
  %expval68 = call i64 @llvm.expect.i64(i64 %conv67, i64 0)
  %tobool69 = icmp ne i64 %expval68, 0
  br i1 %tobool69, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false61
  %19 = bitcast %struct.usbdevfs_bulktransfer* %0 to i8*
  call void @proc_bulk(%struct.usb_dev_state* %ps, i8* %19)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %lor.lhs.false61, %lor.lhs.false49, %lor.lhs.false41, %lor.lhs.false29, %lor.lhs.false21, %lor.lhs.false9, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_disconnectsignal_compat(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %ds = alloca %struct.anon.26, align 4
  %0 = bitcast %struct.anon.26* %ds to i8*
  %1 = call i64 @llvm.objectsize.i64.p0i8(i8* %0, i1 false, i1 true) #8
  %conv.i = trunc i64 %1 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 696) #8
  call void @kasan_check_write(i8* %0, i32 8) #8
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, 8
  %2 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %2 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  call void @__check_object_size(i8* %0, i64 8, i1 zeroext false) #8
  %call.i = call i64 @_copy_from_user(i8* %0, i8* %arg, i32 8) #8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %entry
  call void @copy_user_overflow(i32 %conv.i, i64 8) #8
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ 8, %if.else.i ]
  %tobool = icmp ne i64 %n.addr.0.i, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %copy_from_user.exit
  %signr = getelementptr inbounds %struct.anon.26, %struct.anon.26* %ds, i32 0, i32 0
  %3 = load i32, i32* %signr, align 4, !tbaa !724
  %discsignr = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 8
  store i32 %3, i32* %discsignr, align 8, !tbaa !726
  %context = getelementptr inbounds %struct.anon.26, %struct.anon.26* %ds, i32 0, i32 1
  %4 = load i32, i32* %context, align 4, !tbaa !727
  %call1 = call i8* @compat_ptr(i32 %4)
  %disccontext = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 11
  store i8* %call1, i8** %disccontext, align 8, !tbaa !728
  br label %cleanup

cleanup:                                          ; preds = %if.end, %copy_from_user.exit
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_submiturb_compat(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %uurb = alloca %struct.usbdevfs_urb, align 8
  %0 = bitcast i8* %arg to %struct.usbdevfs_urb32*
  %call = call i32 @get_urb32(%struct.usbdevfs_urb* %uurb, %struct.usbdevfs_urb32* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = bitcast i8* %arg to %struct.usbdevfs_urb32*
  %iso_frame_desc = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %1, i32 0, i32 12
  %arraydecay = getelementptr inbounds [0 x %struct.exception_table_entry], [0 x %struct.exception_table_entry]* %iso_frame_desc, i32 0, i32 0
  call void @proc_do_submiturb(%struct.usb_dev_state* %ps, %struct.usbdevfs_urb* %uurb, %struct.exception_table_entry* %arraydecay, i8* %arg)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @ptr_to_compat(i8* %uptr) #1 {
entry:
  %0 = ptrtoint i8* %uptr to i64
  %conv = trunc i64 %0 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal void @proc_ioctl_compat(%struct.usb_dev_state* %ps, i32 %arg) #0 {
entry:
  %ctrl = alloca %struct.usbdevfs_ioctl, align 8
  %conv = zext i32 %arg to i64
  %conv1 = trunc i64 %conv to i32
  %call = call i8* @compat_ptr(i32 %conv1)
  %0 = bitcast i8* %call to %struct.exception_table_entry*
  %1 = call i32 asm "movl %gs:$1,$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @__preempt_count) #9, !srcloc !698
  %and.i = and i32 %1, 2147483647
  %conv3 = sext i32 %and.i to i64
  %and = and i64 %conv3, 2031872
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot6 = xor i1 %lnot5, true
  %lnot.ext = zext i1 %lnot6 to i32
  %tobool7 = icmp ne i32 %lnot.ext, 0
  br i1 %tobool7, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load i8, i8* @proc_ioctl_compat.__warned, align 1, !tbaa !109, !range !110
  %tobool8 = trunc i8 %2 to i1
  %lnot9 = xor i1 %tobool8, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %lnot9, %land.rhs ]
  %lnot11 = xor i1 %3, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool16 = icmp ne i64 %expval, 0
  br i1 %tobool16, label %if.then, label %if.end33

if.then:                                          ; preds = %land.end
  store i8 1, i8* @proc_ioctl_compat.__warned, align 1, !tbaa !109
  %tobool17 = icmp ne i32 1, 0
  %lnot18 = xor i1 %tobool17, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  %expval23 = call i64 @llvm.expect.i64(i64 %conv22, i64 0)
  %tobool24 = icmp ne i64 %expval23, 0
  br i1 %tobool24, label %if.then25, label %if.end

if.then25:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 2206)
  br label %if.end

if.end:                                           ; preds = %if.then25, %if.then
  br label %if.end33

if.end33:                                         ; preds = %if.end, %land.end
  %4 = ptrtoint %struct.exception_table_entry* %0 to i64
  %5 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !693
  %thread = getelementptr inbounds %struct.task_struct, %struct.task_struct* %5, i32 0, i32 212
  %addr_limit = getelementptr inbounds %struct.thread_struct, %struct.thread_struct* %thread, i32 0, i32 19
  %seg = getelementptr inbounds %union.anon.3, %union.anon.3* %addr_limit, i32 0, i32 0
  %6 = load i64, i64* %seg, align 8, !tbaa !700
  %call45 = call zeroext i1 @__chk_range_not_ok(i64 %4, i64 12, i64 %6)
  %frombool = zext i1 %call45 to i8
  %tobool46 = trunc i8 %frombool to i1
  %lnot47 = xor i1 %tobool46, true
  %lnot49 = xor i1 %lnot47, true
  %lnot51 = xor i1 %lnot49, true
  %lnot.ext52 = zext i1 %lnot51 to i32
  %conv53 = sext i32 %lnot.ext52 to i64
  %expval54 = call i64 @llvm.expect.i64(i64 %conv53, i64 1)
  %tobool55 = icmp ne i64 %expval54, 0
  br i1 %tobool55, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end33
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !729
  %ifno = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %0, i32 0, i32 0
  %7 = bitcast i32* %ifno to %struct.__large_struct*
  %8 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %7, i32 -14, i32 0) #8, !srcloc !730
  %asmresult = extractvalue { i32, i64 } %8, 0
  %asmresult56 = extractvalue { i32, i64 } %8, 1
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !731
  %conv57 = trunc i64 %asmresult56 to i32
  %ifno58 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 0
  store i32 %conv57, i32* %ifno58, align 8, !tbaa !732
  %conv60 = sext i32 %asmresult to i64
  %expval61 = call i64 @llvm.expect.i64(i64 %conv60, i64 0)
  %tobool62 = icmp ne i64 %expval61, 0
  br i1 %tobool62, label %cleanup, label %lor.lhs.false63

lor.lhs.false63:                                  ; preds = %lor.lhs.false
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !729
  %ioctl_code = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %0, i32 0, i32 1
  %9 = bitcast i32* %ioctl_code to %struct.__large_struct*
  %10 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %9, i32 -14, i32 0) #8, !srcloc !734
  %asmresult67 = extractvalue { i32, i64 } %10, 0
  %asmresult68 = extractvalue { i32, i64 } %10, 1
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !731
  %conv71 = trunc i64 %asmresult68 to i32
  %ioctl_code72 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 1
  store i32 %conv71, i32* %ioctl_code72, align 4, !tbaa !735
  %conv74 = sext i32 %asmresult67 to i64
  %expval75 = call i64 @llvm.expect.i64(i64 %conv74, i64 0)
  %tobool76 = icmp ne i64 %expval75, 0
  br i1 %tobool76, label %cleanup, label %lor.lhs.false77

lor.lhs.false77:                                  ; preds = %lor.lhs.false63
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !729
  %data = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %0, i32 0, i32 2
  %11 = bitcast i32* %data to %struct.__large_struct*
  %12 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %11, i32 -14, i32 0) #8, !srcloc !736
  %asmresult81 = extractvalue { i32, i64 } %12, 0
  %asmresult82 = extractvalue { i32, i64 } %12, 1
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !731
  %conv85 = trunc i64 %asmresult82 to i32
  %conv87 = sext i32 %asmresult81 to i64
  %expval88 = call i64 @llvm.expect.i64(i64 %conv87, i64 0)
  %tobool89 = icmp ne i64 %expval88, 0
  br i1 %tobool89, label %cleanup, label %if.end91

if.end91:                                         ; preds = %lor.lhs.false77
  %call92 = call i8* @compat_ptr(i32 %conv85)
  %data93 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 2
  store i8* %call92, i8** %data93, align 8, !tbaa !737
  call void @proc_ioctl(%struct.usb_dev_state* %ps, %struct.usbdevfs_ioctl* %ctrl)
  br label %cleanup

cleanup:                                          ; preds = %if.end91, %lor.lhs.false77, %lor.lhs.false63, %lor.lhs.false, %if.end33
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_unlinkurb(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %call5 = call %struct.async* @async_getpending(%struct.usb_dev_state* %ps, i8* %arg)
  %tobool = icmp ne %struct.async* %call5, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %lock6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock6, i32 0, i32 0
  %rlock.i4 = bitcast %union.anon.1* %1 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i4, i64 %call2) #8
  br label %cleanup

if.end:                                           ; preds = %entry
  %urb7 = getelementptr inbounds %struct.async, %struct.async* %call5, i32 0, i32 8
  %2 = load %struct.urb*, %struct.urb** %urb7, align 8, !tbaa !656
  %call8 = call %struct.urb* bitcast (%struct.urb.744* (%struct.urb.744*)* @usb_get_urb to %struct.urb* (%struct.urb*)*)(%struct.urb* %2)
  %lock9 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock9, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %3 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #8
  call void bitcast (void (%struct.urb.744*)* @usb_kill_urb to void (%struct.urb*)*)(%struct.urb* %2)
  call void bitcast (void (%struct.urb.744*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %2)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_disconnectsignal(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %ds = alloca %struct.usbdevfs_disconnectsignal, align 8
  %0 = bitcast %struct.usbdevfs_disconnectsignal* %ds to i8*
  %1 = call i64 @llvm.objectsize.i64.p0i8(i8* %0, i1 false, i1 true) #8
  %conv.i = trunc i64 %1 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 696) #8
  call void @kasan_check_write(i8* %0, i32 16) #8
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, 16
  %2 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %2 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  call void @__check_object_size(i8* %0, i64 16, i1 zeroext false) #8
  %call.i = call i64 @_copy_from_user(i8* %0, i8* %arg, i32 16) #8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %entry
  call void @copy_user_overflow(i32 %conv.i, i64 16) #8
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ 16, %if.else.i ]
  %tobool = icmp ne i64 %n.addr.0.i, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %copy_from_user.exit
  %signr = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %ds, i32 0, i32 0
  %3 = load i32, i32* %signr, align 8, !tbaa !738
  %discsignr = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 8
  store i32 %3, i32* %discsignr, align 8, !tbaa !726
  %context = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %ds, i32 0, i32 1
  %4 = load i8*, i8** %context, align 8, !tbaa !740
  %disccontext = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 11
  store i8* %4, i8** %disccontext, align 8, !tbaa !728
  br label %cleanup

cleanup:                                          ; preds = %if.end, %copy_from_user.exit
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_claiminterface(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 2090)
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4, i8* undef) #8, !srcloc !741
  %asmresult = extractvalue { i32*, i64, i8* } %1, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %conv3 = sext i32 %3 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @claimintf(%struct.usb_dev_state* %ps, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_releaseinterface(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 2100)
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4, i8* undef) #8, !srcloc !742
  %asmresult = extractvalue { i32*, i64, i8* } %1, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %conv3 = sext i32 %3 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @releaseintf(%struct.usb_dev_state* %ps, i32 %conv)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  call void @destroy_async_on_interface(%struct.usb_dev_state* %ps, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_ioctl_default(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %ctrl = alloca %struct.usbdevfs_ioctl, align 8
  %0 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  %1 = call i64 @llvm.objectsize.i64.p0i8(i8* %0, i1 false, i1 true) #8
  %conv.i = trunc i64 %1 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 696) #8
  call void @kasan_check_write(i8* %0, i32 16) #8
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, 16
  %2 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %2 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  call void @__check_object_size(i8* %0, i64 16, i1 zeroext false) #8
  %call.i = call i64 @_copy_from_user(i8* %0, i8* %arg, i32 16) #8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %entry
  call void @copy_user_overflow(i32 %conv.i, i64 16) #8
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ 16, %if.else.i ]
  %tobool = icmp ne i64 %n.addr.0.i, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %copy_from_user.exit
  call void @proc_ioctl(%struct.usb_dev_state* %ps, %struct.usbdevfs_ioctl* %ctrl)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %copy_from_user.exit
  ret void
}

; Function Attrs: nounwind uwtable
declare void @proc_claim_port(%struct.usb_dev_state*, i8*) #0

; Function Attrs: nounwind uwtable
define internal void @proc_release_port(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 2235)
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4, i8* undef) #8, !srcloc !743
  %asmresult = extractvalue { i32*, i64, i8* } %1, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %conv3 = sext i32 %3 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %call = call i32 @usb_hub_release_port(%struct.usb_device* %4, i32 %conv, %struct.usb_dev_state* %ps)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_get_capabilities(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %no_stop_on_short = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %1, i32 0, i32 6
  %bf.load = load i8, i8* %no_stop_on_short, align 1
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  %or = or i32 117, 2
  %.or = select i1 %tobool, i32 117, i32 %or
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !658
  %bus2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 9
  %3 = load %struct.usb_bus*, %struct.usb_bus** %bus2, align 8, !tbaa !2
  %sg_tablesize = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %3, i32 0, i32 7
  %4 = load i32, i32* %sg_tablesize, align 4, !tbaa !526
  %tobool3 = icmp ne i32 %4, 0
  %or5 = or i32 %.or, 8
  %caps.1 = select i1 %tobool3, i32 %or5, i32 %.or
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 2252)
  %5 = bitcast i8* %arg to i32*
  %6 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %caps.1, i32* %5) #8, !srcloc !744
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_disconnect_claim(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %dc = alloca %struct.usbdevfs_disconnect_claim, align 4
  %0 = bitcast %struct.usbdevfs_disconnect_claim* %dc to i8*
  %1 = call i64 @llvm.objectsize.i64.p0i8(i8* %0, i1 false, i1 true) #8
  %conv.i = trunc i64 %1 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 696) #8
  call void @kasan_check_write(i8* %0, i32 264) #8
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, 264
  %2 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %2 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  call void @__check_object_size(i8* %0, i64 264, i1 zeroext false) #8
  %call.i = call i64 @_copy_from_user(i8* %0, i8* %arg, i32 264) #8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %entry
  call void @copy_user_overflow(i32 %conv.i, i64 264) #8
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ 264, %if.else.i ]
  %tobool = icmp ne i64 %n.addr.0.i, 0
  br i1 %tobool, label %cleanup47, label %if.end

if.end:                                           ; preds = %copy_from_user.exit
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %interface = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 0
  %4 = load i32, i32* %interface, align 4, !tbaa !745
  %call1 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %3, i32 %4)
  %tobool2 = icmp ne %struct.usb_interface* %call1, null
  br i1 %tobool2, label %if.end4, label %cleanup47

if.end4:                                          ; preds = %if.end
  %dev5 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev5, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !118
  %tobool6 = icmp ne %struct.device_driver* %5, null
  br i1 %tobool6, label %if.then7, label %if.end44

if.then7:                                         ; preds = %if.end4
  %dev9 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver10 = getelementptr inbounds %struct.device, %struct.device* %dev9, i32 0, i32 7
  %6 = load %struct.device_driver*, %struct.device_driver** %driver10, align 8, !tbaa !118
  %7 = bitcast %struct.device_driver* %6 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 -168
  %8 = bitcast i8* %add.ptr to %struct.usb_driver*
  %privileges_dropped = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 15
  %9 = load i8, i8* %privileges_dropped, align 8, !tbaa !702, !range !110
  %tobool11 = trunc i8 %9 to i1
  br i1 %tobool11, label %LeafBlock, label %if.end13

if.end13:                                         ; preds = %if.then7
  %flags = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 1
  %10 = load i32, i32* %flags, align 4, !tbaa !747
  %and = and i32 %10, 1
  %tobool14 = icmp ne i32 %and, 0
  br i1 %tobool14, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.end13
  %driver15 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 2
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %driver15, i32 0, i32 0
  %dev16 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver17 = getelementptr inbounds %struct.device, %struct.device* %dev16, i32 0, i32 7
  %11 = load %struct.device_driver*, %struct.device_driver** %driver17, align 8, !tbaa !118
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %11, i32 0, i32 0
  %12 = load i8*, i8** %name, align 8, !tbaa !706
  %call18 = call i32 @strncmp(i8* %arraydecay, i8* %12, i64 256)
  %cmp = icmp ne i32 %call18, 0
  br i1 %cmp, label %LeafBlock, label %if.end20

if.end20:                                         ; preds = %land.lhs.true, %if.end13
  %flags21 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 1
  %13 = load i32, i32* %flags21, align 4, !tbaa !747
  %and22 = and i32 %13, 2
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %land.lhs.true24, label %do.body34

land.lhs.true24:                                  ; preds = %if.end20
  %driver25 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 2
  %arraydecay26 = getelementptr inbounds [256 x i8], [256 x i8]* %driver25, i32 0, i32 0
  %dev27 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver28 = getelementptr inbounds %struct.device, %struct.device* %dev27, i32 0, i32 7
  %14 = load %struct.device_driver*, %struct.device_driver** %driver28, align 8, !tbaa !118
  %name29 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %14, i32 0, i32 0
  %15 = load i8*, i8** %name29, align 8, !tbaa !706
  %call30 = call i32 @strncmp(i8* %arraydecay26, i8* %15, i64 256)
  %cmp31 = icmp eq i32 %call30, 0
  br i1 %cmp31, label %LeafBlock, label %do.body34

do.body34:                                        ; preds = %land.lhs.true24, %if.end20
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @proc_disconnect_claim.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and35 = and i32 %bf.clear, 1
  %tobool36 = icmp ne i32 %and35, 0
  %lnot = xor i1 %tobool36, true
  %lnot37 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot37 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool38 = icmp ne i64 %expval, 0
  br i1 %tobool38, label %if.then39, label %do.end43

if.then39:                                        ; preds = %do.body34
  %dev40 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @proc_disconnect_claim.descriptor to %struct._ddebug*), %struct.device* %dev40, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.66.778, i32 0, i32 0))
  br label %do.end43

do.end43:                                         ; preds = %if.then39, %do.body34
  call void @usb_driver_release_interface(%struct.usb_driver* %8, %struct.usb_interface* %call1)
  br label %LeafBlock

LeafBlock:                                        ; preds = %do.end43, %land.lhs.true24, %land.lhs.true, %if.then7
  %cleanup.dest.slot.0 = phi i32 [ 0, %do.end43 ], [ 1, %if.then7 ], [ 1, %land.lhs.true ], [ 1, %land.lhs.true24 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end44, label %cleanup47

if.end44:                                         ; preds = %LeafBlock, %if.end4
  %interface45 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 0
  %16 = load i32, i32* %interface45, align 4, !tbaa !745
  %call46 = call i32 @claimintf(%struct.usb_dev_state* %ps, i32 %16)
  br label %cleanup47

cleanup47:                                        ; preds = %if.end44, %LeafBlock, %if.end, %copy_from_user.exit
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_alloc_streams(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %num_streams = alloca i32, align 4
  %num_eps = alloca i32, align 4
  %eps = alloca %struct.usb_host_endpoint**, align 8
  %intf = alloca %struct.usb_interface*, align 8
  %0 = bitcast i8* %arg to %struct.usbdevfs_streams*
  %call = call i32 @parse_usbdevfs_streams(%struct.usb_dev_state* %ps, %struct.usbdevfs_streams* %0, i32* %num_streams, i32* %num_eps, %struct.usb_host_endpoint*** %eps, %struct.usb_interface** %intf)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8, !tbaa !52
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %1, i32 0, i32 0
  %2 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !98
  %arrayidx = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i64 0
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %3 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !106
  %conv = zext i8 %3 to i32
  call void @destroy_async_on_interface(%struct.usb_dev_state* %ps, i32 %conv)
  %4 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8, !tbaa !52
  %5 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8, !tbaa !52
  %6 = load i32, i32* %num_eps, align 4, !tbaa !73
  %7 = load i32, i32* %num_streams, align 4, !tbaa !73
  %call1 = call i32 @usb_alloc_streams(%struct.usb_interface* %4, %struct.usb_host_endpoint** %5, i32 %6, i32 %7, i32 20971712)
  %8 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8, !tbaa !52
  %9 = bitcast %struct.usb_host_endpoint** %8 to i8*
  call void @kfree(i8* %9)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_free_streams(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %num_eps = alloca i32, align 4
  %eps = alloca %struct.usb_host_endpoint**, align 8
  %intf = alloca %struct.usb_interface*, align 8
  %0 = bitcast i8* %arg to %struct.usbdevfs_streams*
  %call = call i32 @parse_usbdevfs_streams(%struct.usb_dev_state* %ps, %struct.usbdevfs_streams* %0, i32* null, i32* %num_eps, %struct.usb_host_endpoint*** %eps, %struct.usb_interface** %intf)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8, !tbaa !52
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %1, i32 0, i32 0
  %2 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !98
  %arrayidx = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i64 0
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %3 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !106
  %conv = zext i8 %3 to i32
  call void @destroy_async_on_interface(%struct.usb_dev_state* %ps, i32 %conv)
  %4 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8, !tbaa !52
  %5 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8, !tbaa !52
  %6 = load i32, i32* %num_eps, align 4, !tbaa !73
  %call1 = call i32 @usb_free_streams(%struct.usb_interface* %4, %struct.usb_host_endpoint** %5, i32 %6, i32 20971712)
  %7 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8, !tbaa !52
  %8 = bitcast %struct.usb_host_endpoint** %7 to i8*
  call void @kfree(i8* %8)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @proc_drop_privileges(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %data = alloca i32, align 4
  %0 = bitcast i32* %data to i8*
  %1 = call i64 @llvm.objectsize.i64.p0i8(i8* %0, i1 false, i1 true) #8
  %conv.i = trunc i64 %1 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 696) #8
  call void @kasan_check_write(i8* %0, i32 4) #8
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, 4
  %2 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %2 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  call void @__check_object_size(i8* %0, i64 4, i1 zeroext false) #8
  %call.i = call i64 @_copy_from_user(i8* %0, i8* %arg, i32 4) #8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %entry
  call void @copy_user_overflow(i32 %conv.i, i64 4) #8
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ 4, %if.else.i ]
  %tobool = icmp ne i64 %n.addr.0.i, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %copy_from_user.exit
  %3 = load i32, i32* %data, align 4, !tbaa !73
  %conv = zext i32 %3 to i64
  %interface_allowed_mask = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 16
  %4 = load i64, i64* %interface_allowed_mask, align 8, !tbaa !748
  %and = and i64 %4, %conv
  store i64 %and, i64* %interface_allowed_mask, align 8, !tbaa !748
  %privileges_dropped = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 15
  store i8 1, i8* %privileges_dropped, align 8, !tbaa !702
  br label %cleanup

cleanup:                                          ; preds = %if.end, %copy_from_user.exit
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #7

declare void @__might_fault(i8*, i32) #2

declare void @kasan_check_write(i8*, i32) #2

declare i64 @_copy_from_user(i8*, i8*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @copy_user_overflow(i32 %size, i64 %count) #1 {
entry:
  %tobool = icmp ne i32 1, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 688, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.35.889, i32 0, i32 0), i32 %size, i64 %count)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @__check_object_size(i8*, i64, i1 zeroext) #2

; Function Attrs: nounwind uwtable
define internal i32 @parse_usbdevfs_streams(%struct.usb_dev_state* %ps, %struct.usbdevfs_streams* %streams, i32* %num_streams_ret, i32* %num_eps_ret, %struct.usb_host_endpoint*** %eps_ret, %struct.usb_interface** %intf_ret) #0 {
entry:
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 903)
  %num_streams1 = getelementptr inbounds %struct.usbdevfs_streams, %struct.usbdevfs_streams* %streams, i32 0, i32 0
  %0 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %num_streams1, i64 4, i8* undef) #8, !srcloc !749
  %asmresult = extractvalue { i32*, i64, i8* } %0, 0
  %asmresult2 = extractvalue { i32*, i64, i8* } %0, 1
  %1 = ptrtoint i32* %asmresult to i64
  %2 = trunc i64 %1 to i32
  %conv = trunc i64 %asmresult2 to i32
  %conv4 = sext i32 %2 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 904)
  %num_eps8 = getelementptr inbounds %struct.usbdevfs_streams, %struct.usbdevfs_streams* %streams, i32 0, i32 1
  %3 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %num_eps8, i64 4, i8* undef) #8, !srcloc !750
  %asmresult9 = extractvalue { i32*, i64, i8* } %3, 0
  %asmresult10 = extractvalue { i32*, i64, i8* } %3, 1
  %4 = ptrtoint i32* %asmresult9 to i64
  %5 = trunc i64 %4 to i32
  %conv12 = trunc i64 %asmresult10 to i32
  %conv14 = sext i32 %5 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %cmp = icmp ult i32 %conv12, 1
  %cmp19 = icmp ugt i32 %conv12, 30
  %or.cond = or i1 %cmp, %cmp19
  br i1 %or.cond, label %cleanup, label %if.end22

if.end22:                                         ; preds = %if.end
  %tobool23 = icmp ne i32* %num_streams_ret, null
  br i1 %tobool23, label %land.lhs.true, label %if.end30

land.lhs.true:                                    ; preds = %if.end22
  %cmp24 = icmp ult i32 %conv, 2
  %cmp27 = icmp ugt i32 %conv, 65536
  %or.cond1 = or i1 %cmp24, %cmp27
  br i1 %or.cond1, label %cleanup, label %if.end30

if.end30:                                         ; preds = %land.lhs.true, %if.end22
  %conv31 = zext i32 %conv12 to i64
  %mul = mul i64 %conv31, 8
  %call.i = call noalias i8* @__kmalloc(i64 %mul, i32 20971712) #8
  %6 = bitcast i8* %call.i to %struct.usb_host_endpoint**
  %tobool32 = icmp ne %struct.usb_host_endpoint** %6, null
  br i1 %tobool32, label %if.end34, label %cleanup

if.end34:                                         ; preds = %if.end30
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end34
  %i.0 = phi i32 [ 0, %if.end34 ], [ %inc, %for.inc ]
  %intf.0 = phi %struct.usb_interface* [ null, %if.end34 ], [ %intf.1, %for.inc ]
  %__sp39.0 = phi i8* [ undef, %if.end34 ], [ %asmresult43, %for.inc ]
  %cmp35 = icmp ult i32 %i.0, %conv12
  br i1 %cmp35, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 919)
  %eps40 = getelementptr inbounds %struct.usbdevfs_streams, %struct.usbdevfs_streams* %streams, i32 0, i32 2
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [0 x i8], [0 x i8]* %eps40, i64 0, i64 %idxprom
  %7 = call { i8*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i8* %arrayidx, i64 1, i8* %__sp39.0) #8, !srcloc !751
  %asmresult41 = extractvalue { i8*, i64, i8* } %7, 0
  %asmresult42 = extractvalue { i8*, i64, i8* } %7, 1
  %asmresult43 = extractvalue { i8*, i64, i8* } %7, 2
  %8 = ptrtoint i8* %asmresult41 to i64
  %9 = trunc i64 %8 to i32
  %conv44 = trunc i64 %asmresult42 to i8
  %conv46 = sext i32 %9 to i64
  %expval47 = call i64 @llvm.expect.i64(i64 %conv46, i64 0)
  %tobool48 = icmp ne i64 %expval47, 0
  br i1 %tobool48, label %error, label %if.end50

if.end50:                                         ; preds = %for.body
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %call51 = call %struct.usb_host_endpoint* @ep_to_host_endpoint(%struct.usb_device* %10, i8 zeroext %conv44)
  %idxprom52 = zext i32 %i.0 to i64
  %arrayidx53 = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %6, i64 %idxprom52
  store %struct.usb_host_endpoint* %call51, %struct.usb_host_endpoint** %arrayidx53, align 8, !tbaa !52
  %idxprom54 = zext i32 %i.0 to i64
  %arrayidx55 = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %6, i64 %idxprom54
  %11 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx55, align 8, !tbaa !52
  %tobool56 = icmp ne %struct.usb_host_endpoint* %11, null
  br i1 %tobool56, label %if.end58, label %error

if.end58:                                         ; preds = %if.end50
  %dev59 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %12 = load %struct.usb_device*, %struct.usb_device** %dev59, align 8, !tbaa !658
  %conv60 = zext i8 %conv44 to i32
  %call61 = call i32 @findintfep(%struct.usb_device* %12, i32 %conv60)
  %cmp62 = icmp slt i32 %call61, 0
  br i1 %cmp62, label %error, label %if.end65

if.end65:                                         ; preds = %if.end58
  %cmp66 = icmp eq i32 %i.0, 0
  br i1 %cmp66, label %if.then68, label %if.else

if.then68:                                        ; preds = %if.end65
  %call69 = call i32 @checkintf(%struct.usb_dev_state* %ps, i32 %call61)
  %cmp70 = icmp slt i32 %call69, 0
  br i1 %cmp70, label %error, label %if.end73

if.end73:                                         ; preds = %if.then68
  %dev74 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %13 = load %struct.usb_device*, %struct.usb_device** %dev74, align 8, !tbaa !658
  %call75 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %13, i32 %call61)
  br label %for.inc

if.else:                                          ; preds = %if.end65
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf.0, i32 0, i32 0
  %14 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !98
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %14, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %15 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !106
  %conv76 = zext i8 %15 to i32
  %cmp77 = icmp ne i32 %call61, %conv76
  br i1 %cmp77, label %error, label %for.inc

for.inc:                                          ; preds = %if.else, %if.end73
  %intf.1 = phi %struct.usb_interface* [ %call75, %if.end73 ], [ %intf.0, %if.else ]
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool82 = icmp ne i32* %num_streams_ret, null
  br i1 %tobool82, label %if.then83, label %if.end84

if.then83:                                        ; preds = %for.end
  store i32 %conv, i32* %num_streams_ret, align 4, !tbaa !73
  br label %if.end84

if.end84:                                         ; preds = %if.then83, %for.end
  store i32 %conv12, i32* %num_eps_ret, align 4, !tbaa !73
  store %struct.usb_host_endpoint** %6, %struct.usb_host_endpoint*** %eps_ret, align 8, !tbaa !52
  store %struct.usb_interface* %intf.0, %struct.usb_interface** %intf_ret, align 8, !tbaa !52
  br label %cleanup

error:                                            ; preds = %if.else, %if.then68, %if.end58, %if.end50, %for.body
  %ret.0 = phi i32 [ -14, %for.body ], [ -22, %if.end50 ], [ %call61, %if.end58 ], [ %call69, %if.then68 ], [ -22, %if.else ]
  %16 = bitcast %struct.usb_host_endpoint** %6 to i8*
  call void @kfree(i8* %16)
  br label %cleanup

cleanup:                                          ; preds = %error, %if.end84, %if.end30, %land.lhs.true, %if.end, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ %ret.0, %error ], [ 0, %if.end84 ], [ -14, %lor.lhs.false ], [ -14, %entry ], [ -22, %if.end ], [ -22, %land.lhs.true ], [ -12, %if.end30 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.usb_host_endpoint* @ep_to_host_endpoint(%struct.usb_device* %dev, i8 zeroext %ep) #0 {
entry:
  %conv = zext i8 %ep to i32
  %and = and i32 %conv, 128
  %tobool = icmp ne i32 %and, 0
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 17
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 16
  %ep_out.sink = select i1 %tobool, [16 x %struct.usb_host_endpoint*]* %ep_in, [16 x %struct.usb_host_endpoint*]* %ep_out
  %conv3 = zext i8 %ep to i32
  %and4 = and i32 %conv3, 15
  %idxprom5 = sext i32 %and4 to i64
  %arrayidx6 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out.sink, i64 0, i64 %idxprom5
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx6, align 8, !tbaa !52
  ret %struct.usb_host_endpoint* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @findintfep(%struct.usb_device* %dev, i32 %ep) #0 {
entry:
  %and = and i32 %ep, -144
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool1 = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool1, label %if.end3, label %cleanup

if.end3:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc32, %if.end3
  %i.0 = phi i32 [ 0, %if.end3 ], [ %inc33, %for.inc32 ]
  %actconfig4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %1 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig4, align 8, !tbaa !102
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %1, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %2 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv = zext i8 %2 to i32
  %cmp = icmp ult i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %actconfig6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %3 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig6, align 8, !tbaa !102
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %3, i32 0, i32 3
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %4 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !52
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc29, %for.body
  %j.0 = phi i32 [ 0, %for.body ], [ %inc30, %for.inc29 ]
  %num_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 2
  %5 = load i32, i32* %num_altsetting, align 8, !tbaa !97
  %cmp8 = icmp ult i32 %j.0, %5
  br i1 %cmp8, label %for.body10, label %for.inc32

for.body10:                                       ; preds = %for.cond7
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 0
  %6 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !98
  %idxprom11 = zext i32 %j.0 to i64
  %arrayidx12 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %6, i64 %idxprom11
  br label %for.cond13

for.cond13:                                       ; preds = %for.inc, %for.body10
  %e.0 = phi i32 [ 0, %for.body10 ], [ %inc, %for.inc ]
  %desc14 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx12, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc14, i32 0, i32 4
  %7 = load i8, i8* %bNumEndpoints, align 4, !tbaa !172
  %conv15 = zext i8 %7 to i32
  %cmp16 = icmp ult i32 %e.0, %conv15
  br i1 %cmp16, label %for.body18, label %for.inc29

for.body18:                                       ; preds = %for.cond13
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx12, i32 0, i32 3
  %8 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !173
  %idxprom19 = zext i32 %e.0 to i64
  %arrayidx20 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %8, i64 %idxprom19
  %desc21 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx20, i32 0, i32 0
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc21, i32 0, i32 2
  %9 = load i8, i8* %bEndpointAddress, align 1, !tbaa !309
  %conv22 = zext i8 %9 to i32
  %cmp23 = icmp eq i32 %conv22, %ep
  br i1 %cmp23, label %if.then25, label %for.inc

if.then25:                                        ; preds = %for.body18
  %desc26 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx12, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc26, i32 0, i32 2
  %10 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !106
  %conv27 = zext i8 %10 to i32
  br label %cleanup

for.inc:                                          ; preds = %for.body18
  %inc = add i32 %e.0, 1
  br label %for.cond13

for.inc29:                                        ; preds = %for.cond13
  %inc30 = add i32 %j.0, 1
  br label %for.cond7

for.inc32:                                        ; preds = %for.cond7
  %inc33 = add i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.then25, %for.cond, %if.end, %entry
  %retval.0 = phi i32 [ %conv27, %if.then25 ], [ -22, %entry ], [ -3, %if.end ], [ -2, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @checkintf(%struct.usb_dev_state* %ps, i32 %ifnum) #0 {
entry:
  %oldbit.i = alloca i8, align 1
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp ne i32 %1, 7
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %conv = zext i32 %ifnum to i64
  %cmp1 = icmp uge i64 %conv, 64
  br i1 %cmp1, label %return, label %cond.false

cond.false:                                       ; preds = %if.end
  %conv7 = zext i32 %ifnum to i64
  %ifclaimed8 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 12
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %ifclaimed8, i64 %conv7) #8, !srcloc !678
  %2 = load i8, i8* %oldbit.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %2 to i1
  br i1 %tobool.i, label %return, label %if.end12

if.end12:                                         ; preds = %cond.false
  call void @task_pid_nr()
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %call18 = call i32 @claimintf(%struct.usb_dev_state* %ps, i32 %ifnum)
  br label %return

return:                                           ; preds = %if.end12, %cond.false, %if.end, %entry
  %retval.0 = phi i32 [ %call18, %if.end12 ], [ -113, %entry ], [ -22, %if.end ], [ 0, %cond.false ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @claimintf(%struct.usb_dev_state* %ps, i32 %ifnum) #0 {
entry:
  %oldbit.i1 = alloca i8, align 1
  %oldbit.i = alloca i8, align 1
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !658
  %conv = zext i32 %ifnum to i64
  %cmp = icmp uge i64 %conv, 64
  br i1 %cmp, label %cleanup, label %cond.false

cond.false:                                       ; preds = %entry
  %conv5 = zext i32 %ifnum to i64
  %ifclaimed6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 12
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i1, i64* %ifclaimed6, i64 %conv5) #8, !srcloc !678
  %1 = load i8, i8* %oldbit.i1, align 1, !tbaa !109, !range !110
  %tobool.i2 = trunc i8 %1 to i1
  br i1 %tobool.i2, label %cleanup, label %if.end10

if.end10:                                         ; preds = %cond.false
  %privileges_dropped = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 15
  %2 = load i8, i8* %privileges_dropped, align 8, !tbaa !702, !range !110
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %cond.false16, label %if.end22

cond.false16:                                     ; preds = %if.end10
  %conv17 = zext i32 %ifnum to i64
  %interface_allowed_mask18 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 16
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %interface_allowed_mask18, i64 %conv17) #8, !srcloc !678
  %3 = load i8, i8* %oldbit.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %3 to i1
  br i1 %tobool.i, label %if.end22, label %cleanup

if.end22:                                         ; preds = %cond.false16, %if.end10
  %call23 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %0, i32 %ifnum)
  %tobool24 = icmp ne %struct.usb_interface* %call23, null
  br i1 %tobool24, label %if.else, label %if.end27

if.else:                                          ; preds = %if.end22
  %4 = bitcast %struct.usb_dev_state* %ps to i8*
  %call26 = call i32 @usb_driver_claim_interface(%struct.usb_driver* @usbfs_driver, %struct.usb_interface* %call23, i8* %4)
  br label %if.end27

if.end27:                                         ; preds = %if.else, %if.end22
  %err.0 = phi i32 [ %call26, %if.else ], [ -2, %if.end22 ]
  %cmp28 = icmp eq i32 %err.0, 0
  br i1 %cmp28, label %if.then30, label %cleanup

if.then30:                                        ; preds = %if.end27
  %conv31 = zext i32 %ifnum to i64
  %ifclaimed32 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 12
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %ifclaimed32, i64 %conv31, i64* %ifclaimed32) #8, !srcloc !752
  br label %cleanup

cleanup:                                          ; preds = %if.then30, %if.end27, %cond.false16, %cond.false, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ 0, %cond.false ], [ -13, %cond.false16 ], [ %err.0, %if.then30 ], [ %err.0, %if.end27 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @proc_ioctl(%struct.usb_dev_state* %ps, %struct.usbdevfs_ioctl* %ctl) #0 {
entry:
  %privileges_dropped = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 15
  %0 = load i8, i8* %privileges_dropped, align 8, !tbaa !702, !range !110
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %ioctl_code = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %1 = load i32, i32* %ioctl_code, align 4, !tbaa !735
  %shr = ashr i32 %1, 16
  %and = and i32 %shr, 16383
  %cmp = icmp sgt i32 %and, 0
  br i1 %cmp, label %if.then2, label %if.end21

if.then2:                                         ; preds = %if.end
  %conv = sext i32 %and to i64
  %call.i = call noalias i8* @__kmalloc(i64 %conv, i32 20971712) #8
  %cmp3 = icmp eq i8* %call.i, null
  br i1 %cmp3, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.then2
  %ioctl_code7 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %2 = load i32, i32* %ioctl_code7, align 4, !tbaa !735
  %shr8 = ashr i32 %2, 30
  %and9 = and i32 %shr8, 3
  %and10 = and i32 %and9, 1
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end6
  %data = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 2
  %3 = load i8*, i8** %data, align 8, !tbaa !737
  %conv13 = sext i32 %and to i64
  %4 = call i64 @llvm.objectsize.i64.p0i8(i8* %call.i, i1 false, i1 true) #8
  %conv.i = trunc i64 %4 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 696) #8
  call void @kasan_check_write(i8* %call.i, i32 %and) #8
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, %conv13
  %5 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %5 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.then12
  call void @__check_object_size(i8* %call.i, i64 %conv13, i1 zeroext false) #8
  %call.i1 = call i64 @_copy_from_user(i8* %call.i, i8* %3, i32 %and) #8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %if.then12
  call void @copy_user_overflow(i32 %conv.i, i64 %conv13) #8
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i1, %if.then.i ], [ %conv13, %if.else.i ]
  %tobool15 = icmp ne i64 %n.addr.0.i, 0
  br i1 %tobool15, label %if.then16, label %if.end21

if.then16:                                        ; preds = %copy_from_user.exit
  call void @kfree(i8* %call.i)
  br label %cleanup

if.else:                                          ; preds = %if.end6
  %conv18 = sext i32 %and to i64
  %call19 = call i8* @__memset(i8* %call.i, i32 0, i64 %conv18)
  br label %if.end21

if.end21:                                         ; preds = %if.else, %copy_from_user.exit, %if.end
  %buf.0 = phi i8* [ null, %if.end ], [ %call.i, %copy_from_user.exit ], [ %call.i, %if.else ]
  %call22 = call i32 @connected(%struct.usb_dev_state* %ps)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.end25, label %if.then24

if.then24:                                        ; preds = %if.end21
  call void @kfree(i8* %buf.0)
  br label %cleanup

if.end25:                                         ; preds = %if.end21
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 3
  %7 = load i32, i32* %state, align 8, !tbaa !54
  %cmp26 = icmp ne i32 %7, 7
  br i1 %cmp26, label %if.end89, label %if.else29

if.else29:                                        ; preds = %if.end25
  %dev30 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %8 = load %struct.usb_device*, %struct.usb_device** %dev30, align 8, !tbaa !658
  %ifno = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 0
  %9 = load i32, i32* %ifno, align 8, !tbaa !732
  %call31 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %8, i32 %9)
  %tobool32 = icmp ne %struct.usb_interface* %call31, null
  br i1 %tobool32, label %if.else34, label %if.end89

if.else34:                                        ; preds = %if.else29
  %ioctl_code35 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %10 = load i32, i32* %ioctl_code35, align 4, !tbaa !735
  %Pivot = icmp slt i32 %10, 21783
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.else34
  %SwitchLeaf2 = icmp eq i32 %10, 21783
  br i1 %SwitchLeaf2, label %sw.bb55, label %sw.default

LeafBlock:                                        ; preds = %if.else34
  %SwitchLeaf = icmp eq i32 %10, 21782
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %dev36 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call31, i32 0, i32 7
  %driver37 = getelementptr inbounds %struct.device, %struct.device* %dev36, i32 0, i32 7
  %11 = load %struct.device_driver*, %struct.device_driver** %driver37, align 8, !tbaa !118
  %tobool38 = icmp ne %struct.device_driver* %11, null
  br i1 %tobool38, label %if.then39, label %if.end89

if.then39:                                        ; preds = %sw.bb
  %dev40 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call31, i32 0, i32 7
  %driver41 = getelementptr inbounds %struct.device, %struct.device* %dev40, i32 0, i32 7
  %12 = load %struct.device_driver*, %struct.device_driver** %driver41, align 8, !tbaa !118
  %13 = bitcast %struct.device_driver* %12 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %13, i64 -168
  %14 = bitcast i8* %add.ptr to %struct.usb_driver*
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @proc_ioctl.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and43 = and i32 %bf.clear, 1
  %tobool44 = icmp ne i32 %and43, 0
  %lnot = xor i1 %tobool44, true
  %lnot45 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot45 to i32
  %conv46 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv46, i64 0)
  %tobool47 = icmp ne i64 %expval, 0
  br i1 %tobool47, label %if.then48, label %do.end52

if.then48:                                        ; preds = %if.then39
  %dev49 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call31, i32 0, i32 7
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @proc_ioctl.descriptor to %struct._ddebug*), %struct.device* %dev49, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.66.778, i32 0, i32 0))
  br label %do.end52

do.end52:                                         ; preds = %if.then48, %if.then39
  call void @usb_driver_release_interface(%struct.usb_driver* %14, %struct.usb_interface* %call31)
  br label %if.end89

sw.bb55:                                          ; preds = %LeafBlock1
  %dev56 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call31, i32 0, i32 7
  %driver57 = getelementptr inbounds %struct.device, %struct.device* %dev56, i32 0, i32 7
  %15 = load %struct.device_driver*, %struct.device_driver** %driver57, align 8, !tbaa !118
  %tobool58 = icmp ne %struct.device_driver* %15, null
  br i1 %tobool58, label %if.end89, label %if.then59

if.then59:                                        ; preds = %sw.bb55
  %dev60 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call31, i32 0, i32 7
  %call61 = call i32 @device_attach(%struct.device* %dev60)
  br label %if.end89

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %dev64 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call31, i32 0, i32 7
  %driver65 = getelementptr inbounds %struct.device, %struct.device* %dev64, i32 0, i32 7
  %16 = load %struct.device_driver*, %struct.device_driver** %driver65, align 8, !tbaa !118
  %tobool66 = icmp ne %struct.device_driver* %16, null
  br i1 %tobool66, label %if.then67, label %if.end73

if.then67:                                        ; preds = %sw.default
  %dev69 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call31, i32 0, i32 7
  %driver70 = getelementptr inbounds %struct.device, %struct.device* %dev69, i32 0, i32 7
  %17 = load %struct.device_driver*, %struct.device_driver** %driver70, align 8, !tbaa !118
  %18 = bitcast %struct.device_driver* %17 to i8*
  %add.ptr72 = getelementptr inbounds i8, i8* %18, i64 -168
  %19 = bitcast i8* %add.ptr72 to %struct.usb_driver*
  br label %if.end73

if.end73:                                         ; preds = %if.then67, %sw.default
  %driver.0 = phi %struct.usb_driver* [ %19, %if.then67 ], [ null, %sw.default ]
  %cmp74 = icmp eq %struct.usb_driver* %driver.0, null
  br i1 %cmp74, label %if.end89, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end73
  %unlocked_ioctl = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver.0, i32 0, i32 3
  %20 = load i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32, i8*)** %unlocked_ioctl, align 8, !tbaa !753
  %cmp76 = icmp eq i32 (%struct.usb_interface*, i32, i8*)* %20, null
  br i1 %cmp76, label %if.end89, label %if.else79

if.else79:                                        ; preds = %lor.lhs.false
  %unlocked_ioctl80 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver.0, i32 0, i32 3
  %21 = load i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32, i8*)** %unlocked_ioctl80, align 8, !tbaa !753
  %ioctl_code81 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %22 = load i32, i32* %ioctl_code81, align 4, !tbaa !735
  %call82 = call i32 %21(%struct.usb_interface* %call31, i32 %22, i8* %buf.0)
  %cmp83 = icmp eq i32 %call82, -515
  %.call82 = select i1 %cmp83, i32 -25, i32 %call82
  br label %if.end89

if.end89:                                         ; preds = %if.else79, %lor.lhs.false, %if.end73, %if.then59, %sw.bb55, %do.end52, %sw.bb, %if.else29, %if.end25
  %retval1.6 = phi i32 [ -113, %if.end25 ], [ -22, %if.else29 ], [ 0, %do.end52 ], [ -61, %sw.bb ], [ %call61, %if.then59 ], [ -16, %sw.bb55 ], [ %.call82, %if.else79 ], [ -25, %lor.lhs.false ], [ -25, %if.end73 ]
  %cmp90 = icmp sge i32 %retval1.6, 0
  br i1 %cmp90, label %land.lhs.true, label %if.end108

land.lhs.true:                                    ; preds = %if.end89
  %ioctl_code92 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %23 = load i32, i32* %ioctl_code92, align 4, !tbaa !735
  %shr93 = ashr i32 %23, 30
  %and94 = and i32 %shr93, 3
  %and95 = and i32 %and94, 2
  %cmp96 = icmp ne i32 %and95, 0
  %cmp99 = icmp sgt i32 %and, 0
  %or.cond = and i1 %cmp96, %cmp99
  br i1 %or.cond, label %land.lhs.true101, label %if.end108

land.lhs.true101:                                 ; preds = %land.lhs.true
  %data102 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 2
  %24 = load i8*, i8** %data102, align 8, !tbaa !737
  %conv103 = sext i32 %and to i64
  %25 = call i64 @llvm.objectsize.i64.p0i8(i8* %buf.0, i1 false, i1 true) #8
  %conv.i2 = trunc i64 %25 to i32
  call void @kasan_check_read(i8* %buf.0, i32 %and) #8
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 718) #8
  %cmp.i3 = icmp slt i32 %conv.i2, 0
  %conv3.i4 = sext i32 %conv.i2 to i64
  %cmp4.i5 = icmp uge i64 %conv3.i4, %conv103
  %26 = select i1 %cmp.i3, i1 true, i1 %cmp4.i5
  %lnot.ext.i7 = zext i1 %26 to i32
  %conv7.i8 = sext i32 %lnot.ext.i7 to i64
  %expval.i9 = call i64 @llvm.expect.i64(i64 %conv7.i8, i64 1) #8
  %tobool.i10 = icmp ne i64 %expval.i9, 0
  br i1 %tobool.i10, label %if.then.i12, label %if.else.i13

if.then.i12:                                      ; preds = %land.lhs.true101
  call void @__check_object_size(i8* %buf.0, i64 %conv103, i1 zeroext true) #8
  %call.i11 = call i64 @_copy_to_user(i8* %24, i8* %buf.0, i32 %and) #8
  br label %copy_to_user.exit

if.else.i13:                                      ; preds = %land.lhs.true101
  call void @copy_user_overflow(i32 %conv.i2, i64 %conv103) #8
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i13, %if.then.i12
  br label %if.end108

if.end108:                                        ; preds = %copy_to_user.exit, %land.lhs.true, %if.end89
  call void @kfree(i8* %buf.0)
  br label %cleanup

cleanup:                                          ; preds = %if.end108, %if.then24, %if.then16, %if.then2, %entry
  ret void
}

declare void @kasan_check_read(i8*, i32) #2

declare i64 @_copy_to_user(i8*, i8*, i32) #2

; Function Attrs: nounwind uwtable
define internal %struct.async* @async_getpending(%struct.usb_dev_state* %ps, i8* %userurb) #0 {
entry:
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %asynclist6.sink = phi %struct.list_head* [ %asynclist4, %for.inc ], [ %async_pending, %entry ]
  %next7 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist6.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next7, align 8, !tbaa !52
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr9 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr9 to %struct.async*
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 0
  %async_pending1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  %cmp = icmp ne %struct.list_head* %asynclist, %async_pending1
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 7
  %3 = load i8*, i8** %userurb2, align 8, !tbaa !754
  %cmp3 = icmp eq i8* %3, %userurb
  %asynclist4 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 0
  br i1 %cmp3, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @list_del_init.721(%struct.list_head* %asynclist4)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond
  %retval.0 = phi %struct.async* [ %2, %if.then ], [ null, %for.cond ]
  ret %struct.async* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @__chk_range_not_ok(i64 %addr, i64 %size, i64 %limit) #1 {
entry:
  %add = add i64 %addr, %size
  %cmp = icmp ult i64 %add, %size
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp2 = icmp ugt i64 %add, %limit
  %lnot4 = xor i1 %cmp2, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv8 = sext i32 %lnot.ext7 to i64
  %expval9 = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  %tobool10 = icmp ne i64 %expval9, 0
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i1 [ %tobool10, %if.end ], [ true, %entry ]
  ret i1 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @get_urb32(%struct.usbdevfs_urb* %kurb, %struct.usbdevfs_urb32* %uurb) #0 {
entry:
  %0 = call i32 asm "movl %gs:$1,$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @__preempt_count) #9, !srcloc !698
  %and.i = and i32 %0, 2147483647
  %conv = sext i32 %and.i to i64
  %and = and i64 %conv, 2031872
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  br i1 %tobool4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load i8, i8* @get_urb32.__warned, align 1, !tbaa !109, !range !110
  %tobool5 = trunc i8 %1 to i1
  %lnot6 = xor i1 %tobool5, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %lnot6, %land.rhs ]
  %lnot8 = xor i1 %2, true
  %lnot10 = xor i1 %lnot8, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  %conv12 = sext i32 %lnot.ext11 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv12, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  br i1 %tobool13, label %if.then, label %if.end30

if.then:                                          ; preds = %land.end
  store i8 1, i8* @get_urb32.__warned, align 1, !tbaa !109
  %tobool14 = icmp ne i32 1, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1970)
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then
  br label %if.end30

if.end30:                                         ; preds = %if.end, %land.end
  %3 = ptrtoint %struct.usbdevfs_urb32* %uurb to i64
  %4 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !693
  %thread = getelementptr inbounds %struct.task_struct, %struct.task_struct* %4, i32 0, i32 212
  %addr_limit = getelementptr inbounds %struct.thread_struct, %struct.thread_struct* %thread, i32 0, i32 19
  %seg = getelementptr inbounds %union.anon.3, %union.anon.3* %addr_limit, i32 0, i32 0
  %5 = load i64, i64* %seg, align 8, !tbaa !700
  %call42 = call zeroext i1 @__chk_range_not_ok(i64 %3, i64 44, i64 %5)
  %frombool = zext i1 %call42 to i8
  %tobool43 = trunc i8 %frombool to i1
  %lnot44 = xor i1 %tobool43, true
  %lnot46 = xor i1 %lnot44, true
  %lnot48 = xor i1 %lnot46, true
  %lnot.ext49 = zext i1 %lnot48 to i32
  %conv50 = sext i32 %lnot.ext49 to i64
  %expval51 = call i64 @llvm.expect.i64(i64 %conv50, i64 1)
  %tobool52 = icmp ne i64 %expval51, 0
  br i1 %tobool52, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end30
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !729
  %type = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 0
  %6 = bitcast i8* %type to %struct.__large_struct*
  %7 = call { i32, i64 } asm sideeffect "\0A1:\09movb $2,${1:b}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorb ${1:b},${1:b}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=q,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %6, i32 -14, i32 0) #8, !srcloc !755
  %asmresult = extractvalue { i32, i64 } %7, 0
  %asmresult53 = extractvalue { i32, i64 } %7, 1
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !731
  %conv54 = trunc i64 %asmresult53 to i8
  %type55 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 0
  store i8 %conv54, i8* %type55, align 8, !tbaa !756
  %conv57 = sext i32 %asmresult to i64
  %expval58 = call i64 @llvm.expect.i64(i64 %conv57, i64 0)
  %tobool59 = icmp ne i64 %expval58, 0
  br i1 %tobool59, label %cleanup, label %lor.lhs.false60

lor.lhs.false60:                                  ; preds = %lor.lhs.false
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !729
  %endpoint = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 1
  %8 = bitcast i8* %endpoint to %struct.__large_struct*
  %9 = call { i32, i64 } asm sideeffect "\0A1:\09movb $2,${1:b}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorb ${1:b},${1:b}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=q,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %8, i32 -14, i32 0) #8, !srcloc !758
  %asmresult64 = extractvalue { i32, i64 } %9, 0
  %asmresult65 = extractvalue { i32, i64 } %9, 1
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !731
  %conv68 = trunc i64 %asmresult65 to i8
  %endpoint69 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 1
  store i8 %conv68, i8* %endpoint69, align 1, !tbaa !759
  %conv71 = sext i32 %asmresult64 to i64
  %expval72 = call i64 @llvm.expect.i64(i64 %conv71, i64 0)
  %tobool73 = icmp ne i64 %expval72, 0
  br i1 %tobool73, label %cleanup, label %lor.lhs.false74

lor.lhs.false74:                                  ; preds = %lor.lhs.false60
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !729
  %status = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 2
  %10 = bitcast i32* %status to %struct.__large_struct*
  %11 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %10, i32 -14, i32 0) #8, !srcloc !760
  %asmresult78 = extractvalue { i32, i64 } %11, 0
  %asmresult79 = extractvalue { i32, i64 } %11, 1
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !731
  %conv82 = trunc i64 %asmresult79 to i32
  %status83 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 2
  store i32 %conv82, i32* %status83, align 4, !tbaa !761
  %conv85 = sext i32 %asmresult78 to i64
  %expval86 = call i64 @llvm.expect.i64(i64 %conv85, i64 0)
  %tobool87 = icmp ne i64 %expval86, 0
  br i1 %tobool87, label %cleanup, label %lor.lhs.false88

lor.lhs.false88:                                  ; preds = %lor.lhs.false74
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !729
  %flags = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 3
  %12 = bitcast i32* %flags to %struct.__large_struct*
  %13 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %12, i32 -14, i32 0) #8, !srcloc !762
  %asmresult92 = extractvalue { i32, i64 } %13, 0
  %asmresult93 = extractvalue { i32, i64 } %13, 1
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !731
  %conv96 = trunc i64 %asmresult93 to i32
  %flags97 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 3
  store i32 %conv96, i32* %flags97, align 8, !tbaa !763
  %conv99 = sext i32 %asmresult92 to i64
  %expval100 = call i64 @llvm.expect.i64(i64 %conv99, i64 0)
  %tobool101 = icmp ne i64 %expval100, 0
  br i1 %tobool101, label %cleanup, label %lor.lhs.false102

lor.lhs.false102:                                 ; preds = %lor.lhs.false88
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !729
  %buffer_length = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 5
  %14 = bitcast i32* %buffer_length to %struct.__large_struct*
  %15 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %14, i32 -14, i32 0) #8, !srcloc !764
  %asmresult106 = extractvalue { i32, i64 } %15, 0
  %asmresult107 = extractvalue { i32, i64 } %15, 1
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !731
  %conv110 = trunc i64 %asmresult107 to i32
  %buffer_length111 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 5
  store i32 %conv110, i32* %buffer_length111, align 8, !tbaa !765
  %conv113 = sext i32 %asmresult106 to i64
  %expval114 = call i64 @llvm.expect.i64(i64 %conv113, i64 0)
  %tobool115 = icmp ne i64 %expval114, 0
  br i1 %tobool115, label %cleanup, label %lor.lhs.false116

lor.lhs.false116:                                 ; preds = %lor.lhs.false102
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !729
  %actual_length = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 6
  %16 = bitcast i32* %actual_length to %struct.__large_struct*
  %17 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %16, i32 -14, i32 0) #8, !srcloc !766
  %asmresult120 = extractvalue { i32, i64 } %17, 0
  %asmresult121 = extractvalue { i32, i64 } %17, 1
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !731
  %conv124 = trunc i64 %asmresult121 to i32
  %actual_length125 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 6
  store i32 %conv124, i32* %actual_length125, align 4, !tbaa !767
  %conv127 = sext i32 %asmresult120 to i64
  %expval128 = call i64 @llvm.expect.i64(i64 %conv127, i64 0)
  %tobool129 = icmp ne i64 %expval128, 0
  br i1 %tobool129, label %cleanup, label %lor.lhs.false130

lor.lhs.false130:                                 ; preds = %lor.lhs.false116
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !729
  %start_frame = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 7
  %18 = bitcast i32* %start_frame to %struct.__large_struct*
  %19 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %18, i32 -14, i32 0) #8, !srcloc !768
  %asmresult134 = extractvalue { i32, i64 } %19, 0
  %asmresult135 = extractvalue { i32, i64 } %19, 1
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !731
  %conv138 = trunc i64 %asmresult135 to i32
  %start_frame139 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 7
  store i32 %conv138, i32* %start_frame139, align 8, !tbaa !769
  %conv141 = sext i32 %asmresult134 to i64
  %expval142 = call i64 @llvm.expect.i64(i64 %conv141, i64 0)
  %tobool143 = icmp ne i64 %expval142, 0
  br i1 %tobool143, label %cleanup, label %lor.lhs.false144

lor.lhs.false144:                                 ; preds = %lor.lhs.false130
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !729
  %number_of_packets = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 8
  %20 = bitcast i32* %number_of_packets to %struct.__large_struct*
  %21 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %20, i32 -14, i32 0) #8, !srcloc !770
  %asmresult148 = extractvalue { i32, i64 } %21, 0
  %asmresult149 = extractvalue { i32, i64 } %21, 1
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !731
  %conv152 = trunc i64 %asmresult149 to i32
  %22 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 8
  %number_of_packets153 = bitcast %struct.atomic_t* %22 to i32*
  store i32 %conv152, i32* %number_of_packets153, align 4, !tbaa !72
  %conv155 = sext i32 %asmresult148 to i64
  %expval156 = call i64 @llvm.expect.i64(i64 %conv155, i64 0)
  %tobool157 = icmp ne i64 %expval156, 0
  br i1 %tobool157, label %cleanup, label %lor.lhs.false158

lor.lhs.false158:                                 ; preds = %lor.lhs.false144
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !729
  %error_count = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 9
  %23 = bitcast i32* %error_count to %struct.__large_struct*
  %24 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %23, i32 -14, i32 0) #8, !srcloc !771
  %asmresult162 = extractvalue { i32, i64 } %24, 0
  %asmresult163 = extractvalue { i32, i64 } %24, 1
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !731
  %conv166 = trunc i64 %asmresult163 to i32
  %error_count167 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 9
  store i32 %conv166, i32* %error_count167, align 8, !tbaa !772
  %conv169 = sext i32 %asmresult162 to i64
  %expval170 = call i64 @llvm.expect.i64(i64 %conv169, i64 0)
  %tobool171 = icmp ne i64 %expval170, 0
  br i1 %tobool171, label %cleanup, label %lor.lhs.false172

lor.lhs.false172:                                 ; preds = %lor.lhs.false158
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !729
  %signr = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 10
  %25 = bitcast i32* %signr to %struct.__large_struct*
  %26 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %25, i32 -14, i32 0) #8, !srcloc !773
  %asmresult176 = extractvalue { i32, i64 } %26, 0
  %asmresult177 = extractvalue { i32, i64 } %26, 1
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !731
  %conv180 = trunc i64 %asmresult177 to i32
  %signr181 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 10
  store i32 %conv180, i32* %signr181, align 4, !tbaa !774
  %conv183 = sext i32 %asmresult176 to i64
  %expval184 = call i64 @llvm.expect.i64(i64 %conv183, i64 0)
  %tobool185 = icmp ne i64 %expval184, 0
  br i1 %tobool185, label %cleanup, label %if.end187

if.end187:                                        ; preds = %lor.lhs.false172
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !729
  %buffer = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 4
  %27 = bitcast i32* %buffer to %struct.__large_struct*
  %28 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %27, i32 -14, i32 0) #8, !srcloc !775
  %asmresult191 = extractvalue { i32, i64 } %28, 0
  %asmresult192 = extractvalue { i32, i64 } %28, 1
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !731
  %conv195 = trunc i64 %asmresult192 to i32
  %conv197 = sext i32 %asmresult191 to i64
  %expval198 = call i64 @llvm.expect.i64(i64 %conv197, i64 0)
  %tobool199 = icmp ne i64 %expval198, 0
  br i1 %tobool199, label %cleanup, label %if.end201

if.end201:                                        ; preds = %if.end187
  %call202 = call i8* @compat_ptr(i32 %conv195)
  %buffer203 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 4
  store i8* %call202, i8** %buffer203, align 8, !tbaa !776
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !729
  %usercontext = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 11
  %29 = bitcast i32* %usercontext to %struct.__large_struct*
  %30 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %29, i32 -14, i32 0) #8, !srcloc !777
  %asmresult207 = extractvalue { i32, i64 } %30, 0
  %asmresult208 = extractvalue { i32, i64 } %30, 1
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !731
  %conv211 = trunc i64 %asmresult208 to i32
  %conv213 = sext i32 %asmresult207 to i64
  %expval214 = call i64 @llvm.expect.i64(i64 %conv213, i64 0)
  %tobool215 = icmp ne i64 %expval214, 0
  br i1 %tobool215, label %cleanup, label %if.end217

if.end217:                                        ; preds = %if.end201
  %call218 = call i8* @compat_ptr(i32 %conv211)
  %usercontext219 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 11
  store i8* %call218, i8** %usercontext219, align 8, !tbaa !778
  br label %cleanup

cleanup:                                          ; preds = %if.end217, %if.end201, %if.end187, %lor.lhs.false172, %lor.lhs.false158, %lor.lhs.false144, %lor.lhs.false130, %lor.lhs.false116, %lor.lhs.false102, %lor.lhs.false88, %lor.lhs.false74, %lor.lhs.false60, %lor.lhs.false, %if.end30
  %retval.0 = phi i32 [ 0, %if.end217 ], [ -14, %lor.lhs.false172 ], [ -14, %lor.lhs.false158 ], [ -14, %lor.lhs.false144 ], [ -14, %lor.lhs.false130 ], [ -14, %lor.lhs.false116 ], [ -14, %lor.lhs.false102 ], [ -14, %lor.lhs.false88 ], [ -14, %lor.lhs.false74 ], [ -14, %lor.lhs.false60 ], [ -14, %lor.lhs.false ], [ -14, %if.end30 ], [ -14, %if.end187 ], [ -14, %if.end201 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
declare void @proc_do_submiturb(%struct.usb_dev_state*, %struct.usbdevfs_urb*, %struct.exception_table_entry*, i8*) #0

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_endpoint_xfer_control.781() #1 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @check_ctrlrecip(%struct.usb_dev_state* %ps, i32 %requesttype, i32 %request, i32 %index) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !658
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !54
  %cmp = icmp ne i32 %1, 4
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !658
  %state2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 3
  %3 = load i32, i32* %state2, align 8, !tbaa !54
  %cmp3 = icmp ne i32 %3, 6
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %dev5 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev5, align 8, !tbaa !658
  %state6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 3
  %5 = load i32, i32* %state6, align 8, !tbaa !54
  %cmp7 = icmp ne i32 %5, 7
  br i1 %cmp7, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true4, %land.lhs.true, %entry
  %and = and i32 96, %requesttype
  %cmp8 = icmp eq i32 64, %and
  br i1 %cmp8, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end
  %cmp11 = icmp eq i32 %requesttype, 161
  %cmp13 = icmp eq i32 %request, 0
  %or.cond = and i1 %cmp11, %cmp13
  br i1 %or.cond, label %if.then14, label %if.end22

if.then14:                                        ; preds = %if.end10
  %dev15 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev15, align 8, !tbaa !658
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 15
  %7 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %shr = lshr i32 %index, 8
  %and16 = and i32 %index, 255
  %call = call %struct.usb_host_interface* @usb_find_alt_setting(%struct.usb_host_config* %7, i32 %shr, i32 %and16)
  %tobool = icmp ne %struct.usb_host_interface* %call, null
  br i1 %tobool, label %land.lhs.true17, label %if.end22

land.lhs.true17:                                  ; preds = %if.then14
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %call, i32 0, i32 0
  %bInterfaceClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 5
  %8 = load i8, i8* %bInterfaceClass, align 1, !tbaa !482
  %conv = zext i8 %8 to i32
  %cmp18 = icmp eq i32 %conv, 7
  br i1 %cmp18, label %cleanup, label %if.end22

if.end22:                                         ; preds = %land.lhs.true17, %if.then14, %if.end10
  %and23 = and i32 %index, 255
  %and24 = and i32 %requesttype, 31
  %Pivot = icmp slt i32 %and24, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end22
  %SwitchLeaf2 = icmp ne i32 %and24, 2
  %and25 = and i32 %and23, -129
  %cmp26 = icmp eq i32 %and25, 0
  %or.cond3 = or i1 %SwitchLeaf2, %cmp26
  br i1 %or.cond3, label %cleanup, label %if.end29

LeafBlock:                                        ; preds = %if.end22
  %SwitchLeaf = icmp eq i32 %and24, 1
  br i1 %SwitchLeaf, label %sw.bb53, label %cleanup

if.end29:                                         ; preds = %LeafBlock1
  %dev30 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %dev30, align 8, !tbaa !658
  %call31 = call i32 @findintfep(%struct.usb_device* %9, i32 %and23)
  %cmp32 = icmp slt i32 %call31, 0
  br i1 %cmp32, label %if.then34, label %if.end47

if.then34:                                        ; preds = %if.end29
  %dev35 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %dev35, align 8, !tbaa !658
  %xor = xor i32 %and23, 128
  %call36 = call i32 @findintfep(%struct.usb_device* %10, i32 %xor)
  %cmp37 = icmp sge i32 %call36, 0
  br i1 %cmp37, label %if.then39, label %if.end47

if.then39:                                        ; preds = %if.then34
  call void @task_pid_nr()
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %if.end47

if.end47:                                         ; preds = %if.then39, %if.then34, %if.end29
  %ret.0 = phi i32 [ %call31, %if.end29 ], [ %call36, %if.then39 ], [ %call36, %if.then34 ]
  %cmp48 = icmp sge i32 %ret.0, 0
  br i1 %cmp48, label %if.then50, label %cleanup

if.then50:                                        ; preds = %if.end47
  %call51 = call i32 @checkintf(%struct.usb_dev_state* %ps, i32 %ret.0)
  br label %cleanup

sw.bb53:                                          ; preds = %LeafBlock
  %call54 = call i32 @checkintf(%struct.usb_dev_state* %ps, i32 %and23)
  br label %cleanup

cleanup:                                          ; preds = %sw.bb53, %if.then50, %if.end47, %LeafBlock, %LeafBlock1, %land.lhs.true17, %if.end, %land.lhs.true4
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_endpoint_type.783() #1 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_endpoint_xfer_int.784() #1 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_isoc.785(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 1
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

declare i8* @memdup_user(i8*, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @IS_ERR.786() #1 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @PTR_ERR.787() #1 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @alloc_async(i32 %numisoframes) #0 {
entry:
  %call = call i8* @kzalloc.740(i64 96, i32 20971712)
  %0 = bitcast i8* %call to %struct.async*
  %tobool = icmp ne %struct.async* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call %struct.urb* bitcast (%struct.urb.744* (i32, i32)* @usb_alloc_urb to %struct.urb* (i32, i32)*)(i32 %numisoframes, i32 20971712)
  %urb = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  store %struct.urb* %call1, %struct.urb** %urb, align 8, !tbaa !656
  %urb2 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  %1 = load %struct.urb*, %struct.urb** %urb2, align 8, !tbaa !656
  %tobool3 = icmp ne %struct.urb* %1, null
  br i1 %tobool3, label %cleanup, label %if.then4

if.then4:                                         ; preds = %if.end
  %2 = bitcast %struct.async* %0 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

cleanup:                                          ; preds = %if.then4, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @find_memory_area(%struct.usb_dev_state* %ps, %struct.usbdevfs_urb* %uurb) #0 {
entry:
  %buffer = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %0 = load i8*, i8** %buffer, align 8, !tbaa !776
  %1 = ptrtoint i8* %0 to i64
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %memory_list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 6
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %memlist26.sink = phi %struct.list_head* [ %memlist26, %for.inc ], [ %memory_list, %entry ]
  %next27 = getelementptr inbounds %struct.list_head, %struct.list_head* %memlist26.sink, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next27, align 8, !tbaa !52
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr29 = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr29 to %struct.usb_memory*
  %memlist = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 0
  %memory_list6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 6
  %cmp7 = icmp ne %struct.list_head* %memlist, %memory_list6
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %vm_start = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 6
  %6 = load i64, i64* %vm_start, align 8, !tbaa !672
  %cmp9 = icmp uge i64 %1, %6
  br i1 %cmp9, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %vm_start11 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 6
  %7 = load i64, i64* %vm_start11, align 8, !tbaa !672
  %size = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 3
  %8 = load i32, i32* %size, align 8, !tbaa !670
  %conv12 = zext i32 %8 to i64
  %add = add i64 %7, %conv12
  %cmp13 = icmp ult i64 %1, %add
  br i1 %cmp13, label %if.then, label %for.inc

if.then:                                          ; preds = %land.lhs.true
  %buffer_length = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %9 = load i32, i32* %buffer_length, align 8, !tbaa !765
  %conv15 = sext i32 %9 to i64
  %vm_start16 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 6
  %10 = load i64, i64* %vm_start16, align 8, !tbaa !672
  %size17 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 3
  %11 = load i32, i32* %size17, align 8, !tbaa !670
  %conv18 = zext i32 %11 to i64
  %add19 = add i64 %10, %conv18
  %sub = sub i64 %add19, %1
  %cmp20 = icmp ugt i64 %conv15, %sub
  br i1 %cmp20, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.then
  call void @ERR_PTR()
  br label %for.end

if.else:                                          ; preds = %if.then
  %urb_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 2
  %12 = load i32, i32* %urb_use_count, align 4, !tbaa !688
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %urb_use_count, align 4, !tbaa !688
  br label %for.end

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %memlist26 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %if.else, %if.then22, %for.cond
  %lock30 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %13 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock30, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %13 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #8
  ret void
}

declare void @sg_init_table(%struct.scatterlist*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_set_buf(%struct.scatterlist* %sg, i8* %buf, i32 %buflen) #1 {
entry:
  %0 = ptrtoint i8* %buf to i64
  %call = call zeroext i1 @__virt_addr_valid(i64 %0)
  %lnot = xor i1 %call, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body3, label %do.end8

do.body3:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.37.737, i32 0, i32 0), i32 140, i64 12) #8, !srcloc !779
  br label %do.body4

do.body4:                                         ; preds = %do.body4, %do.body3
  br label %do.body4

do.end8:                                          ; preds = %entry
  %1 = load i64, i64* @vmemmap_base, align 8, !tbaa !53
  %2 = inttoptr i64 %1 to %struct.page*
  %3 = ptrtoint i8* %buf to i64
  %call9 = call i64 @__phys_addr(i64 %3)
  %shr = lshr i64 %call9, 12
  %add.ptr = getelementptr inbounds %struct.page, %struct.page* %2, i64 %shr
  %4 = ptrtoint i8* %buf to i64
  %and = and i64 %4, 4095
  %conv10 = trunc i64 %and to i32
  call void @sg_set_page(%struct.scatterlist* %sg, %struct.page* %add.ptr, i32 %buflen, i32 %conv10)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__create_pipe.788(%struct.usb_device* %dev, i32 %endpoint) #1 {
entry:
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 0
  %0 = load i32, i32* %devnum, align 8, !tbaa !44
  %shl = shl i32 %0, 8
  %shl1 = shl i32 %endpoint, 15
  %or = or i32 %shl, %shl1
  ret i32 %or
}

; Function Attrs: nounwind uwtable
declare void @async_completed(%struct.urb*) #0

; Function Attrs: nounwind uwtable
define internal void @snoop_urb(i8* %userurb, i32 %when, i8* %data, i32 %data_len) #0 {
entry:
  %__UNIQUE_ID_min1_26 = alloca i32, align 4
  %__UNIQUE_ID_min2_27 = alloca i32, align 4
  %0 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %tobool8 = icmp ne i8* %userurb, null
  %cmp = icmp eq i32 %when, 0
  br i1 %tobool8, label %if.then9, label %if.else13

if.then9:                                         ; preds = %if.end
  br i1 %cmp, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then9
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %if.end20

if.else:                                          ; preds = %if.then9
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %if.end20

if.else13:                                        ; preds = %if.end
  br i1 %cmp, label %if.then15, label %if.else17

if.then15:                                        ; preds = %if.else13
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %if.end20

if.else17:                                        ; preds = %if.else13
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %if.end20

if.end20:                                         ; preds = %if.else17, %if.then15, %if.else, %if.then10
  store i32 %data_len, i32* %__UNIQUE_ID_min1_26, align 4, !tbaa !73
  %1 = load i32, i32* @usbfs_snoop_max, align 4, !tbaa !73
  store i32 %1, i32* %__UNIQUE_ID_min2_27, align 4, !tbaa !73
  %2 = load i32, i32* %__UNIQUE_ID_min1_26, align 4, !tbaa !73
  %3 = load i32, i32* %__UNIQUE_ID_min2_27, align 4, !tbaa !73
  %cmp22 = icmp ult i32 %2, %3
  %4 = load i32, i32* %__UNIQUE_ID_min1_26, align 4
  %5 = load i32, i32* %__UNIQUE_ID_min2_27, align 4
  %cond = select i1 %cmp22, i32 %4, i32 %5
  %tobool24 = icmp ne i8* %data, null
  %cmp25 = icmp ugt i32 %cond, 0
  %or.cond = and i1 %tobool24, %cmp25
  br i1 %or.cond, label %if.then27, label %cleanup.cont

if.then27:                                        ; preds = %if.end20
  %conv28 = zext i32 %cond to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.40.793, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.54.795, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %data, i64 %conv28, i1 zeroext true)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then27, %if.end20, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @snoop_urb_data(%struct.urb* %urb, i32 %len) #0 {
entry:
  %__UNIQUE_ID_min1_28 = alloca i32, align 4
  %__UNIQUE_ID_min2_29 = alloca i32, align 4
  store i32 %len, i32* %__UNIQUE_ID_min1_28, align 4, !tbaa !73
  %0 = load i32, i32* @usbfs_snoop_max, align 4, !tbaa !73
  store i32 %0, i32* %__UNIQUE_ID_min2_29, align 4, !tbaa !73
  %1 = load i32, i32* %__UNIQUE_ID_min1_28, align 4, !tbaa !73
  %2 = load i32, i32* %__UNIQUE_ID_min2_29, align 4, !tbaa !73
  %cmp1 = icmp ult i32 %1, %2
  %3 = load i32, i32* %__UNIQUE_ID_min1_28, align 4
  %4 = load i32, i32* %__UNIQUE_ID_min2_29, align 4
  %cond = select i1 %cmp1, i32 %3, i32 %4
  %5 = load i8, i8* @usbfs_snoop, align 1, !tbaa !109, !range !110
  %tobool = trunc i8 %5 to i1
  %tobool.not = xor i1 %tobool, true
  %cmp3 = icmp eq i32 %cond, 0
  %or.cond = or i1 %tobool.not, %cmp3
  br i1 %or.cond, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %6 = load i32, i32* %num_sgs, align 4, !tbaa !398
  %cmp5 = icmp eq i32 %6, 0
  br i1 %cmp5, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %7 = load i8*, i8** %transfer_buffer, align 8, !tbaa !316
  %conv8 = zext i32 %cond to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.40.793, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.54.795, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %7, i64 %conv8, i1 zeroext true)
  br label %cleanup.cont

if.end9:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %sg_virt.734.exit, %if.end9
  %i.0 = phi i32 [ 0, %if.end9 ], [ %inc, %sg_virt.734.exit ]
  %len.addr.0 = phi i32 [ %cond, %if.end9 ], [ %sub, %sg_virt.734.exit ]
  %num_sgs10 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %8 = load i32, i32* %num_sgs10, align 4, !tbaa !398
  %cmp11 = icmp slt i32 %i.0, %8
  %tobool13 = icmp ne i32 %len.addr.0, 0
  %tobool13. = select i1 %cmp11, i1 %tobool13, i1 false
  br i1 %tobool13., label %for.body, label %cleanup.cont

for.body:                                         ; preds = %for.cond
  %cmp14 = icmp ugt i32 %len.addr.0, 16384
  %.len.addr.0 = select i1 %cmp14, i32 16384, i32 %len.addr.0
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 16
  %9 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8, !tbaa !397
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %9, i64 %idxprom
  %sg_magic.i.i = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %arrayidx, i32 0, i32 0
  %10 = load i64, i64* %sg_magic.i.i, align 8, !tbaa !435
  %cmp.i.i = icmp ne i64 %10, 2271560481
  %lnot.ext.i.i = zext i1 %cmp.i.i to i32
  %conv.i.i = sext i32 %lnot.ext.i.i to i64
  %expval.i.i = call i64 @llvm.expect.i64(i64 %conv.i.i, i64 0) #8
  %tobool.i.i = icmp ne i64 %expval.i.i, 0
  br i1 %tobool.i.i, label %do.body2.i.i, label %do.body8.i.i

do.body2.i.i:                                     ; preds = %for.body
  call void @"simpll__inlineasm$0.1"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.37.737, i32 0, i32 0), i32 123, i64 12) #8
  br label %do.body3.i.i

do.body3.i.i:                                     ; preds = %do.body3.i.i, %do.body2.i.i
  br label %do.body3.i.i

do.body8.i.i:                                     ; preds = %for.body
  %page_link.i.i = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %arrayidx, i32 0, i32 1
  %11 = load i64, i64* %page_link.i.i, align 8, !tbaa !437
  %and.i.i = and i64 %11, 1
  %tobool9.i.i = icmp ne i64 %and.i.i, 0
  %lnot.ext13.i.i = zext i1 %tobool9.i.i to i32
  %conv14.i.i = sext i32 %lnot.ext13.i.i to i64
  %expval15.i.i = call i64 @llvm.expect.i64(i64 %conv14.i.i, i64 0) #8
  %tobool16.i.i = icmp ne i64 %expval15.i.i, 0
  br i1 %tobool16.i.i, label %do.body18.i.i, label %sg_virt.734.exit

do.body18.i.i:                                    ; preds = %do.body8.i.i
  call void @"simpll__inlineasm$0.1"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.37.737, i32 0, i32 0), i32 124, i64 12) #8
  br label %do.body19.i.i

do.body19.i.i:                                    ; preds = %do.body19.i.i, %do.body18.i.i
  br label %do.body19.i.i

sg_virt.734.exit:                                 ; preds = %do.body8.i.i
  %page_link27.i.i = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %arrayidx, i32 0, i32 1
  %12 = load i64, i64* %page_link27.i.i, align 8, !tbaa !437
  %and28.i.i = and i64 %12, -4
  %13 = load i64, i64* @vmemmap_base, align 8, !tbaa !53
  %sub.ptr.sub.i.i = sub i64 %and28.i.i, %13
  %sub.ptr.div.i.i = sdiv exact i64 %sub.ptr.sub.i.i, 64
  %shl.i.i = shl i64 %sub.ptr.div.i.i, 12
  %14 = load i64, i64* @page_offset_base, align 8, !tbaa !53
  %add.i.i = add i64 %shl.i.i, %14
  %15 = inttoptr i64 %add.i.i to i8*
  %offset.i = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %arrayidx, i32 0, i32 2
  %16 = load i32, i32* %offset.i, align 8, !tbaa !427
  %idx.ext.i = zext i32 %16 to i64
  %add.ptr.i = getelementptr i8, i8* %15, i64 %idx.ext.i
  %conv20 = sext i32 %.len.addr.0 to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.40.793, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.54.795, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %add.ptr.i, i64 %conv20, i1 zeroext true)
  %sub = sub i32 %len.addr.0, %.len.addr.0
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup.cont:                                     ; preds = %for.cond, %if.then7, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @async_newpending(%struct.async* %as) #0 {
entry:
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 1
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps1, align 8, !tbaa !780
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 3
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %1 to %struct.raw_spinlock*
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 0
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 4
  call void @list_add_tail.726(%struct.list_head* %asynclist, %struct.list_head* %async_pending)
  %lock6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 3
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock6, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call3) #8
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_endpoint_xfer_bulk.789() #1 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_endpoint_num.791() #1 {
entry:
  ret void
}

declare void @dev_printk(i8*, %struct.device*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define internal void @async_removepending(%struct.async* %as) #0 {
entry:
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 1
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps1, align 8, !tbaa !780
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 3
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %1 to %struct.raw_spinlock*
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 0
  call void @list_del_init.721(%struct.list_head* %asynclist)
  %lock6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 3
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock6, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call3) #8
  ret void
}

declare void @print_hex_dump(i8*, i8*, i32, i32, i32, i8*, i64, i1 zeroext) #2

; Function Attrs: nounwind uwtable
define internal void @cancel_bulk_urbs(%struct.usb_dev_state* %ps, i32 %bulk_addr) #0 {
entry:
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %asynclist13.sink = phi %struct.list_head* [ %asynclist13, %for.inc ], [ %async_pending, %entry ]
  %next14 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist13.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next14, align 8, !tbaa !52
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr16 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr16 to %struct.async*
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 0
  %async_pending1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  %cmp = icmp ne %struct.list_head* %asynclist, %async_pending1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %bulk_addr2 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 13
  %3 = load i8, i8* %bulk_addr2, align 4, !tbaa !781
  %conv = zext i8 %3 to i32
  %cmp3 = icmp eq i32 %conv, %bulk_addr
  br i1 %cmp3, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %bulk_status = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 14
  %4 = load i8, i8* %bulk_status, align 1, !tbaa !782
  %conv5 = zext i8 %4 to i32
  %cmp6 = icmp ne i32 %conv5, 1
  br i1 %cmp6, label %rescan.preheader, label %if.end

if.end:                                           ; preds = %if.then
  %bulk_status9 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 14
  store i8 2, i8* %bulk_status9, align 1, !tbaa !782
  %bulk_addr10 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 13
  store i8 0, i8* %bulk_addr10, align 4, !tbaa !781
  br label %for.inc

for.inc:                                          ; preds = %if.end, %for.body
  %asynclist13 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %shl = shl i32 1, %bulk_addr
  %disabled_bulk_eps = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 14
  %5 = load i32, i32* %disabled_bulk_eps, align 4, !tbaa !783
  %or = or i32 %5, %shl
  store i32 %or, i32* %disabled_bulk_eps, align 4, !tbaa !783
  br label %rescan.preheader

rescan.preheader:                                 ; preds = %for.end, %if.then
  br label %rescan

rescan:                                           ; preds = %if.then32, %rescan.preheader
  %async_pending18 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc38, %rescan
  %asynclist40.sink = phi %struct.list_head* [ %asynclist40, %for.inc38 ], [ %async_pending18, %rescan ]
  %next41 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist40.sink, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next41, align 8, !tbaa !52
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr43 = getelementptr inbounds i8, i8* %7, i64 0
  %8 = bitcast i8* %add.ptr43 to %struct.async*
  %asynclist23 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 0
  %async_pending24 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  %cmp25 = icmp ne %struct.list_head* %asynclist23, %async_pending24
  br i1 %cmp25, label %for.body27, label %for.end44

for.body27:                                       ; preds = %for.cond22
  %bulk_status28 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 14
  %9 = load i8, i8* %bulk_status28, align 1, !tbaa !782
  %conv29 = zext i8 %9 to i32
  %cmp30 = icmp eq i32 %conv29, 2
  br i1 %cmp30, label %if.then32, label %for.inc38

if.then32:                                        ; preds = %for.body27
  %bulk_status33 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 14
  store i8 0, i8* %bulk_status33, align 1, !tbaa !782
  %urb34 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 8
  %10 = load %struct.urb*, %struct.urb** %urb34, align 8, !tbaa !656
  %call = call %struct.urb* bitcast (%struct.urb.744* (%struct.urb.744*)* @usb_get_urb to %struct.urb* (%struct.urb*)*)(%struct.urb* %10)
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %11 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %11 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock.i1) #8
  %call35 = call i32 bitcast (i32 (%struct.urb.744*)* @usb_unlink_urb to i32 (%struct.urb*)*)(%struct.urb* %10)
  call void bitcast (void (%struct.urb.744*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %10)
  %lock36 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %12 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock36, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %12 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock.i) #8
  br label %rescan

for.inc38:                                        ; preds = %for.body27
  %asynclist40 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 0
  br label %for.cond22

for.end44:                                        ; preds = %for.cond22
  ret void
}

declare i32 @kill_pid_info_as_cred(i32, %struct.siginfo*, %struct.pid*, %struct.cred*, i32) #2

declare zeroext i1 @__virt_addr_valid(i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_set_page(%struct.scatterlist* %sg, %struct.page* %page, i32 %len, i32 %offset) #1 {
entry:
  call void @sg_assign_page(%struct.scatterlist* %sg, %struct.page* %page)
  %offset1 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 2
  store i32 %offset, i32* %offset1, align 8, !tbaa !427
  %length = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 3
  store i32 %len, i32* %length, align 4, !tbaa !480
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_assign_page(%struct.scatterlist* %sg, %struct.page* %page) #1 {
entry:
  %page_link1 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %0 = load i64, i64* %page_link1, align 8, !tbaa !437
  %and = and i64 %0, 3
  %1 = ptrtoint %struct.page* %page to i64
  %and2 = and i64 %1, 3
  %tobool = icmp ne i64 %and2, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.body11

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.37.737, i32 0, i32 0), i32 90, i64 12) #8, !srcloc !784
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.body11:                                        ; preds = %entry
  %sg_magic = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 0
  %2 = load i64, i64* %sg_magic, align 8, !tbaa !435
  %cmp = icmp ne i64 %2, 2271560481
  %lnot13 = xor i1 %cmp, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv17 = sext i32 %lnot.ext16 to i64
  %expval18 = call i64 @llvm.expect.i64(i64 %conv17, i64 0)
  %tobool19 = icmp ne i64 %expval18, 0
  br i1 %tobool19, label %do.body21, label %do.body30

do.body21:                                        ; preds = %do.body11
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.37.737, i32 0, i32 0), i32 92, i64 12) #8, !srcloc !785
  br label %do.body22

do.body22:                                        ; preds = %do.body22, %do.body21
  br label %do.body22

do.body30:                                        ; preds = %do.body11
  %page_link31 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %3 = load i64, i64* %page_link31, align 8, !tbaa !437
  %and32 = and i64 %3, 1
  %tobool33 = icmp ne i64 %and32, 0
  %lnot34 = xor i1 %tobool33, true
  %lnot36 = xor i1 %lnot34, true
  %lnot.ext37 = zext i1 %lnot36 to i32
  %conv38 = sext i32 %lnot.ext37 to i64
  %expval39 = call i64 @llvm.expect.i64(i64 %conv38, i64 0)
  %tobool40 = icmp ne i64 %expval39, 0
  br i1 %tobool40, label %do.body42, label %do.end50

do.body42:                                        ; preds = %do.body30
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.37.737, i32 0, i32 0), i32 93, i64 12) #8, !srcloc !786
  br label %do.body43

do.body43:                                        ; preds = %do.body43, %do.body42
  br label %do.body43

do.end50:                                         ; preds = %do.body30
  %4 = ptrtoint %struct.page* %page to i64
  %or = or i64 %and, %4
  %page_link51 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  store i64 %or, i64* %page_link51, align 8, !tbaa !437
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @ERR_PTR() #1 {
entry:
  ret void
}

declare i8* @compat_alloc_user_space(i64) #2

declare i64 @copy_in_user(i8*, i8*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_interface_claimed(%struct.usb_interface* %iface) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !118
  %cmp = icmp ne %struct.device_driver* %0, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare i64 @strlcpy(i8*, i8*, i64) #2

; Function Attrs: nounwind uwtable
define internal void @check_reset_of_active_ep(%struct.usb_device* %udev, i32 %epnum) #0 {
entry:
  %and = and i32 %epnum, 128
  %tobool = icmp ne i32 %and, 0
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 17
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 16
  %ep_out.sink = select i1 %tobool, [16 x %struct.usb_host_endpoint*]* %ep_in, [16 x %struct.usb_host_endpoint*]* %ep_out
  %arraydecay1 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out.sink, i32 0, i32 0
  %and2 = and i32 %epnum, 15
  %idxprom = zext i32 %and2 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arraydecay1, i64 %idxprom
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8, !tbaa !52
  %tobool3 = icmp ne %struct.usb_host_endpoint* %0, null
  br i1 %tobool3, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %urb_list = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %0, i32 0, i32 4
  %call = call i32 @list_empty.720(%struct.list_head* %urb_list)
  %tobool4 = icmp ne i32 %call, 0
  br i1 %tobool4, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  call void @task_pid_nr()
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @usb_maxpacket.815(%struct.usb_device* %udev, i32 %pipe, i32 %is_out) #1 {
entry:
  %shr = ashr i32 %pipe, 15
  %and = and i32 %shr, 15
  %tobool = icmp ne i32 %is_out, 0
  %and1 = and i32 %pipe, 128
  %tobool2 = icmp ne i32 %and1, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.55.816, i32 0, i32 0), i32 1854)
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.then
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 17
  br label %if.end47

if.else:                                          ; preds = %entry
  %lnot25 = xor i1 %lnot3, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %tobool27 = icmp ne i32 %lnot.ext26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.else
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.55.816, i32 0, i32 0), i32 1857)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.else
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 16
  br label %if.end47

if.end47:                                         ; preds = %if.end36, %if.end
  %ep_in.sink = phi [16 x %struct.usb_host_endpoint*]* [ %ep_in, %if.end36 ], [ %ep_out, %if.end ]
  %idxprom45 = zext i32 %and to i64
  %arrayidx46 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in.sink, i64 0, i64 %idxprom45
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx46, align 8, !tbaa !52
  %tobool48 = icmp ne %struct.usb_host_endpoint* %0, null
  br i1 %tobool48, label %if.end50, label %cleanup

if.end50:                                         ; preds = %if.end47
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %0, i32 0, i32 0
  %call = call i32 @usb_endpoint_maxp.817(%struct.usb_endpoint_descriptor* %desc)
  %conv51 = trunc i32 %call to i16
  br label %cleanup

cleanup:                                          ; preds = %if.end50, %if.end47
  %retval.0 = phi i16 [ %conv51, %if.end50 ], [ 0, %if.end47 ]
  ret i16 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_maxp.817(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 4
  %0 = load i16, i16* %wMaxPacketSize, align 1, !tbaa !226
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 2047
  ret i32 %and
}

declare i64 @__get_free_pages(i32, i32) #2

declare void @free_pages(i64, i32) #2

; Function Attrs: nounwind uwtable
define internal void @processcompl_compat(%struct.async* %as, i8** %arg) #0 {
entry:
  %urb1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %0 = load %struct.urb*, %struct.urb** %urb1, align 8, !tbaa !656
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 7
  %1 = load i8*, i8** %userurb2, align 8, !tbaa !754
  %2 = bitcast i8* %1 to %struct.usbdevfs_urb32*
  %userurb3 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 7
  %3 = load i8*, i8** %userurb3, align 8, !tbaa !754
  %userbuffer = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 6
  %4 = load i8*, i8** %userbuffer, align 8, !tbaa !787
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %entry
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %5 = load i32, i32* %actual_length, align 4, !tbaa !315
  %tobool4 = icmp ne i32 %5, 0
  br i1 %tobool4, label %if.then, label %if.end8

if.then:                                          ; preds = %land.lhs.true
  %userbuffer5 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 6
  %6 = load i8*, i8** %userbuffer5, align 8, !tbaa !787
  %call = call i32 @copy_urb_data_to_user(i8* %6, %struct.urb* %0)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.then, %land.lhs.true, %entry
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 2016)
  %status = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 11
  %7 = load i32, i32* %status, align 4, !tbaa !788
  %status9 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 2
  %8 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %7, i32* %status9) #8, !srcloc !789
  %conv = sext i32 %8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %cleanup, label %if.end12

if.end12:                                         ; preds = %if.end8
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 2018)
  %actual_length15 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %9 = load i32, i32* %actual_length15, align 4, !tbaa !315
  %actual_length16 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 6
  %10 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %9, i32* %actual_length16) #8, !srcloc !790
  %conv18 = sext i32 %10 to i64
  %expval19 = call i64 @llvm.expect.i64(i64 %conv18, i64 0)
  %tobool20 = icmp ne i64 %expval19, 0
  br i1 %tobool20, label %cleanup, label %if.end22

if.end22:                                         ; preds = %if.end12
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 2020)
  %error_count = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 26
  %11 = load i32, i32* %error_count, align 4, !tbaa !791
  %error_count25 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 9
  %12 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %11, i32* %error_count25) #8, !srcloc !792
  %conv27 = sext i32 %12 to i64
  %expval28 = call i64 @llvm.expect.i64(i64 %conv27, i64 0)
  %tobool29 = icmp ne i64 %expval28, 0
  br i1 %tobool29, label %cleanup, label %if.end31

if.end31:                                         ; preds = %if.end22
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 9
  %13 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !250
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %13, i32 0, i32 0
  %call32 = call i32 @usb_endpoint_xfer_isoc.785(%struct.usb_endpoint_descriptor* %desc)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %if.end65

if.then34:                                        ; preds = %if.end31
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then34
  %i.0 = phi i32 [ 0, %if.then34 ], [ %inc, %for.inc ]
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 24
  %14 = load i32, i32* %number_of_packets, align 4, !tbaa !475
  %cmp = icmp ult i32 %i.0, %14
  br i1 %cmp, label %for.body, label %if.end65

for.body:                                         ; preds = %for.cond
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 2026)
  %iso_frame_desc = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 29
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb3_lpm_parameters], [0 x %struct.usb3_lpm_parameters]* %iso_frame_desc, i64 0, i64 %idxprom
  %actual_length38 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %arrayidx, i32 0, i32 2
  %15 = load i32, i32* %actual_length38, align 8, !tbaa !479
  %iso_frame_desc39 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 12
  %idxprom40 = zext i32 %i.0 to i64
  %arrayidx41 = getelementptr inbounds [0 x %struct.exception_table_entry], [0 x %struct.exception_table_entry]* %iso_frame_desc39, i64 0, i64 %idxprom40
  %actual_length42 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %arrayidx41, i32 0, i32 1
  %16 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %15, i32* %actual_length42) #8, !srcloc !793
  %conv44 = sext i32 %16 to i64
  %expval45 = call i64 @llvm.expect.i64(i64 %conv44, i64 0)
  %tobool46 = icmp ne i64 %expval45, 0
  br i1 %tobool46, label %cleanup, label %if.end48

if.end48:                                         ; preds = %for.body
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 2029)
  %iso_frame_desc51 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 29
  %idxprom52 = zext i32 %i.0 to i64
  %arrayidx53 = getelementptr inbounds [0 x %struct.usb3_lpm_parameters], [0 x %struct.usb3_lpm_parameters]* %iso_frame_desc51, i64 0, i64 %idxprom52
  %status54 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %arrayidx53, i32 0, i32 3
  %17 = load i32, i32* %status54, align 4, !tbaa !478
  %iso_frame_desc55 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 12
  %idxprom56 = zext i32 %i.0 to i64
  %arrayidx57 = getelementptr inbounds [0 x %struct.exception_table_entry], [0 x %struct.exception_table_entry]* %iso_frame_desc55, i64 0, i64 %idxprom56
  %status58 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %arrayidx57, i32 0, i32 2
  %18 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %17, i32* %status58) #8, !srcloc !794
  %conv60 = sext i32 %18 to i64
  %expval61 = call i64 @llvm.expect.i64(i64 %conv60, i64 0)
  %tobool62 = icmp ne i64 %expval61, 0
  br i1 %tobool62, label %cleanup, label %for.inc

for.inc:                                          ; preds = %if.end48
  %inc = add i32 %i.0, 1
  br label %for.cond

if.end65:                                         ; preds = %for.cond, %if.end31
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 2034)
  %call68 = call i32 @ptr_to_compat(i8* %3)
  %19 = bitcast i8** %arg to i32*
  %20 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %call68, i32* %19) #8, !srcloc !795
  br label %cleanup

cleanup:                                          ; preds = %if.end65, %if.end48, %for.body, %if.end22, %if.end12, %if.end8, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @copy_urb_data_to_user(i8* %userbuffer, %struct.urb* %urb) #0 {
entry:
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 24
  %0 = load i32, i32* %number_of_packets, align 4, !tbaa !475
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %1 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !317
  br label %if.end

if.else:                                          ; preds = %entry
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %2 = load i32, i32* %actual_length, align 4, !tbaa !315
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %len.0 = phi i32 [ %1, %if.then ], [ %2, %if.else ]
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %3 = load i32, i32* %num_sgs, align 4, !tbaa !398
  %cmp1 = icmp eq i32 %3, 0
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %4 = load i8*, i8** %transfer_buffer, align 8, !tbaa !316
  %conv = zext i32 %len.0 to i64
  %5 = call i64 @llvm.objectsize.i64.p0i8(i8* %4, i1 false, i1 true) #8
  %conv.i1 = trunc i64 %5 to i32
  call void @kasan_check_read(i8* %4, i32 %len.0) #8
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 718) #8
  %cmp.i2 = icmp slt i32 %conv.i1, 0
  %conv3.i3 = sext i32 %conv.i1 to i64
  %cmp4.i4 = icmp uge i64 %conv3.i3, %conv
  %6 = select i1 %cmp.i2, i1 true, i1 %cmp4.i4
  %lnot.ext.i6 = zext i1 %6 to i32
  %conv7.i7 = sext i32 %lnot.ext.i6 to i64
  %expval.i8 = call i64 @llvm.expect.i64(i64 %conv7.i7, i64 1) #8
  %tobool.i9 = icmp ne i64 %expval.i8, 0
  br i1 %tobool.i9, label %if.then.i11, label %if.else.i12

if.then.i11:                                      ; preds = %if.then2
  call void @__check_object_size(i8* %4, i64 %conv, i1 zeroext true) #8
  %call.i10 = call i64 @_copy_to_user(i8* %userbuffer, i8* %4, i32 %len.0) #8
  br label %copy_to_user.exit14

if.else.i12:                                      ; preds = %if.then2
  call void @copy_user_overflow(i32 %conv.i1, i64 %conv) #8
  br label %copy_to_user.exit14

copy_to_user.exit14:                              ; preds = %if.else.i12, %if.then.i11
  %n.addr.0.i13 = phi i64 [ %call.i10, %if.then.i11 ], [ %conv, %if.else.i12 ]
  %tobool = icmp ne i64 %n.addr.0.i13, 0
  %. = select i1 %tobool, i32 -14, i32 0
  br label %cleanup

if.end5:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %if.end17, %if.end5
  %len.1 = phi i32 [ %len.0, %if.end5 ], [ %sub, %if.end17 ]
  %i.0 = phi i32 [ 0, %if.end5 ], [ %inc, %if.end17 ]
  %userbuffer.addr.0 = phi i8* [ %userbuffer, %if.end5 ], [ %add.ptr, %if.end17 ]
  %num_sgs6 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %7 = load i32, i32* %num_sgs6, align 4, !tbaa !398
  %cmp7 = icmp ult i32 %i.0, %7
  %tobool9 = icmp ne i32 %len.1, 0
  %tobool9. = select i1 %cmp7, i1 %tobool9, i1 false
  br i1 %tobool9., label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %cmp10 = icmp ugt i32 %len.1, 16384
  %.len.1 = select i1 %cmp10, i32 16384, i32 %len.1
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 16
  %8 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8, !tbaa !397
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %8, i64 %idxprom
  %sg_magic.i.i = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %arrayidx, i32 0, i32 0
  %9 = load i64, i64* %sg_magic.i.i, align 8, !tbaa !435
  %cmp.i.i = icmp ne i64 %9, 2271560481
  %lnot.ext.i.i = zext i1 %cmp.i.i to i32
  %conv.i.i = sext i32 %lnot.ext.i.i to i64
  %expval.i.i = call i64 @llvm.expect.i64(i64 %conv.i.i, i64 0) #8
  %tobool.i.i = icmp ne i64 %expval.i.i, 0
  br i1 %tobool.i.i, label %do.body2.i.i, label %do.body8.i.i

do.body2.i.i:                                     ; preds = %for.body
  call void @"simpll__inlineasm$0.1"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.37.737, i32 0, i32 0), i32 123, i64 12) #8
  br label %do.body3.i.i

do.body3.i.i:                                     ; preds = %do.body3.i.i, %do.body2.i.i
  br label %do.body3.i.i

do.body8.i.i:                                     ; preds = %for.body
  %page_link.i.i = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %arrayidx, i32 0, i32 1
  %10 = load i64, i64* %page_link.i.i, align 8, !tbaa !437
  %and.i.i = and i64 %10, 1
  %tobool9.i.i = icmp ne i64 %and.i.i, 0
  %lnot.ext13.i.i = zext i1 %tobool9.i.i to i32
  %conv14.i.i = sext i32 %lnot.ext13.i.i to i64
  %expval15.i.i = call i64 @llvm.expect.i64(i64 %conv14.i.i, i64 0) #8
  %tobool16.i.i = icmp ne i64 %expval15.i.i, 0
  br i1 %tobool16.i.i, label %do.body18.i.i, label %sg_virt.734.exit

do.body18.i.i:                                    ; preds = %do.body8.i.i
  call void @"simpll__inlineasm$0.1"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.37.737, i32 0, i32 0), i32 124, i64 12) #8
  br label %do.body19.i.i

do.body19.i.i:                                    ; preds = %do.body19.i.i, %do.body18.i.i
  br label %do.body19.i.i

sg_virt.734.exit:                                 ; preds = %do.body8.i.i
  %page_link27.i.i = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %arrayidx, i32 0, i32 1
  %11 = load i64, i64* %page_link27.i.i, align 8, !tbaa !437
  %and28.i.i = and i64 %11, -4
  %12 = load i64, i64* @vmemmap_base, align 8, !tbaa !53
  %sub.ptr.sub.i.i = sub i64 %and28.i.i, %12
  %sub.ptr.div.i.i = sdiv exact i64 %sub.ptr.sub.i.i, 64
  %shl.i.i = shl i64 %sub.ptr.div.i.i, 12
  %13 = load i64, i64* @page_offset_base, align 8, !tbaa !53
  %add.i.i = add i64 %shl.i.i, %13
  %14 = inttoptr i64 %add.i.i to i8*
  %offset.i = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %arrayidx, i32 0, i32 2
  %15 = load i32, i32* %offset.i, align 8, !tbaa !427
  %idx.ext.i = zext i32 %15 to i64
  %add.ptr.i = getelementptr i8, i8* %14, i64 %idx.ext.i
  %conv13 = zext i32 %.len.1 to i64
  %16 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr.i, i1 false, i1 true) #8
  %conv.i = trunc i64 %16 to i32
  call void @kasan_check_read(i8* %add.ptr.i, i32 %.len.1) #8
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 718) #8
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, %conv13
  %17 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %17 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %sg_virt.734.exit
  call void @__check_object_size(i8* %add.ptr.i, i64 %conv13, i1 zeroext true) #8
  %call.i = call i64 @_copy_to_user(i8* %userbuffer.addr.0, i8* %add.ptr.i, i32 %.len.1) #8
  br label %copy_to_user.exit

if.else.i:                                        ; preds = %sg_virt.734.exit
  call void @copy_user_overflow(i32 %conv.i, i64 %conv13) #8
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ %conv13, %if.else.i ]
  %tobool15 = icmp ne i64 %n.addr.0.i, 0
  br i1 %tobool15, label %cleanup, label %if.end17

if.end17:                                         ; preds = %copy_to_user.exit
  %idx.ext = zext i32 %.len.1 to i64
  %add.ptr = getelementptr inbounds i8, i8* %userbuffer.addr.0, i64 %idx.ext
  %sub = sub i32 %len.1, %.len.1
  %inc = add i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %copy_to_user.exit, %for.cond, %copy_to_user.exit14
  %retval.0 = phi i32 [ %., %copy_to_user.exit14 ], [ -14, %copy_to_user.exit ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.async* @reap_as(%struct.usb_dev_state* %ps) #0 {
entry:
  %wait = alloca %struct.__wait_queue, align 8
  %__ret = alloca i64, align 8
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !796
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 1
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !693
  %1 = bitcast %struct.task_struct* %0 to i8*
  store i8* %1, i8** %private, align 8, !tbaa !798
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @default_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !799
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  store %struct.list_head* null, %struct.list_head** %next, align 8, !tbaa !252
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  store %struct.list_head* null, %struct.list_head** %prev, align 8, !tbaa !87
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !658
  %wait2 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 7
  call void @add_wait_queue(%struct.__wait_queue_head* %wait2, %struct.__wait_queue* %wait)
  br label %for.cond

for.cond:                                         ; preds = %if.end12, %entry
  br label %__here

__here:                                           ; preds = %for.cond
  %3 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !693
  %task_state_change = getelementptr inbounds %struct.task_struct, %struct.task_struct* %3, i32 0, i32 208
  store i64 ptrtoint (i8* blockaddress(@reap_as, %__here) to i64), i64* %task_state_change, align 32, !tbaa !800
  %4 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !693
  %state = getelementptr inbounds %struct.task_struct, %struct.task_struct* %4, i32 0, i32 1
  store volatile i64 1, i64* %state, align 8, !tbaa !801
  %call5 = call %struct.async* @async_getcompleted(%struct.usb_dev_state* %ps)
  %tobool = icmp ne %struct.async* %call5, null
  br i1 %tobool, label %for.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %__here
  %call6 = call i32 @connected(%struct.usb_dev_state* %ps)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end, label %for.end

if.end:                                           ; preds = %lor.lhs.false
  %5 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !693
  %call9 = call i32 @signal_pending(%struct.task_struct* %5)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %for.end, label %if.end12

if.end12:                                         ; preds = %if.end
  %dev13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock.732(%struct.device* %dev13)
  call void @schedule()
  %dev14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock.730(%struct.device* %dev14)
  br label %for.cond

for.end:                                          ; preds = %if.end, %lor.lhs.false, %__here
  %wait15 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 7
  call void @remove_wait_queue(%struct.__wait_queue_head* %wait15, %struct.__wait_queue* %wait)
  br label %__here17

__here17:                                         ; preds = %for.end
  %6 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !693
  %task_state_change20 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %6, i32 0, i32 208
  store i64 ptrtoint (i8* blockaddress(@reap_as, %__here17) to i64), i64* %task_state_change20, align 32, !tbaa !800
  store volatile i64 0, i64* %__ret, align 8, !tbaa !53
  %7 = load volatile i64, i64* %__ret, align 8, !tbaa !53
  %8 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !693
  %state23 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %8, i32 0, i32 1
  %9 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %state23, i64 %7, i64* %state23) #8, !srcloc !802
  store volatile i64 %9, i64* %__ret, align 8, !tbaa !53
  %10 = load volatile i64, i64* %__ret, align 8, !tbaa !53
  ret %struct.async* %call5
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @signal_pending(%struct.task_struct* %p) #1 {
entry:
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* %p, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_tsk_thread_flag(%struct.task_struct* %tsk, i32 %flag) #1 {
entry:
  %call = call %union.anon.3* @task_thread_info(%struct.task_struct* %tsk)
  %call1 = call i32 @test_ti_thread_flag(%union.anon.3* %call, i32 %flag)
  ret i32 %call1
}

; Function Attrs: inlinehint nounwind uwtable
define internal %union.anon.3* @task_thread_info(%struct.task_struct* %task) #1 {
entry:
  %thread_info = getelementptr inbounds %struct.task_struct, %struct.task_struct* %task, i32 0, i32 0
  ret %union.anon.3* %thread_info
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_ti_thread_flag(%union.anon.3* %ti, i32 %flag) #1 {
entry:
  %oldbit.i = alloca i8, align 1
  %conv = sext i32 %flag to i64
  %flags = getelementptr inbounds %union.anon.3, %union.anon.3* %ti, i32 0, i32 0
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %flags, i64 %conv) #8, !srcloc !678
  %0 = load i8, i8* %oldbit.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %0 to i1
  %conv1 = zext i1 %tobool.i to i32
  ret i32 %conv1
}

declare i32 @default_wake_function(%struct.__wait_queue*, i32, i32, i8*) #2

declare void @add_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #2

declare void @remove_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #2

; Function Attrs: nounwind uwtable
define internal void @processcompl(%struct.async* %as, i8** %arg) #0 {
entry:
  %urb1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %0 = load %struct.urb*, %struct.urb** %urb1, align 8, !tbaa !656
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 7
  %1 = load i8*, i8** %userurb2, align 8, !tbaa !754
  %2 = bitcast i8* %1 to %struct.usbdevfs_urb*
  %userurb3 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 7
  %3 = load i8*, i8** %userurb3, align 8, !tbaa !754
  %userbuffer = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 6
  %4 = load i8*, i8** %userbuffer, align 8, !tbaa !787
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %entry
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %5 = load i32, i32* %actual_length, align 4, !tbaa !315
  %tobool4 = icmp ne i32 %5, 0
  br i1 %tobool4, label %if.then, label %if.end8

if.then:                                          ; preds = %land.lhs.true
  %userbuffer5 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 6
  %6 = load i8*, i8** %userbuffer5, align 8, !tbaa !787
  %call = call i32 @copy_urb_data_to_user(i8* %6, %struct.urb* %0)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.then, %land.lhs.true, %entry
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1842)
  %status = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 11
  %7 = load i32, i32* %status, align 4, !tbaa !788
  %status9 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 2
  %8 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %7, i32* %status9) #8, !srcloc !803
  %conv = sext i32 %8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %cleanup, label %if.end12

if.end12:                                         ; preds = %if.end8
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1844)
  %actual_length15 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %9 = load i32, i32* %actual_length15, align 4, !tbaa !315
  %actual_length16 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 6
  %10 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %9, i32* %actual_length16) #8, !srcloc !804
  %conv18 = sext i32 %10 to i64
  %expval19 = call i64 @llvm.expect.i64(i64 %conv18, i64 0)
  %tobool20 = icmp ne i64 %expval19, 0
  br i1 %tobool20, label %cleanup, label %if.end22

if.end22:                                         ; preds = %if.end12
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1846)
  %error_count = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 26
  %11 = load i32, i32* %error_count, align 4, !tbaa !791
  %error_count25 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 9
  %12 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %11, i32* %error_count25) #8, !srcloc !805
  %conv27 = sext i32 %12 to i64
  %expval28 = call i64 @llvm.expect.i64(i64 %conv27, i64 0)
  %tobool29 = icmp ne i64 %expval28, 0
  br i1 %tobool29, label %cleanup, label %if.end31

if.end31:                                         ; preds = %if.end22
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 9
  %13 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !250
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %13, i32 0, i32 0
  %call32 = call i32 @usb_endpoint_xfer_isoc.785(%struct.usb_endpoint_descriptor* %desc)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %if.end65

if.then34:                                        ; preds = %if.end31
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then34
  %i.0 = phi i32 [ 0, %if.then34 ], [ %inc, %for.inc ]
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 24
  %14 = load i32, i32* %number_of_packets, align 4, !tbaa !475
  %cmp = icmp ult i32 %i.0, %14
  br i1 %cmp, label %for.body, label %if.end65

for.body:                                         ; preds = %for.cond
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1852)
  %iso_frame_desc = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 29
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb3_lpm_parameters], [0 x %struct.usb3_lpm_parameters]* %iso_frame_desc, i64 0, i64 %idxprom
  %actual_length38 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %arrayidx, i32 0, i32 2
  %15 = load i32, i32* %actual_length38, align 8, !tbaa !479
  %iso_frame_desc39 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 12
  %idxprom40 = zext i32 %i.0 to i64
  %arrayidx41 = getelementptr inbounds [0 x %struct.exception_table_entry], [0 x %struct.exception_table_entry]* %iso_frame_desc39, i64 0, i64 %idxprom40
  %actual_length42 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %arrayidx41, i32 0, i32 1
  %16 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %15, i32* %actual_length42) #8, !srcloc !806
  %conv44 = sext i32 %16 to i64
  %expval45 = call i64 @llvm.expect.i64(i64 %conv44, i64 0)
  %tobool46 = icmp ne i64 %expval45, 0
  br i1 %tobool46, label %cleanup, label %if.end48

if.end48:                                         ; preds = %for.body
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1855)
  %iso_frame_desc51 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 29
  %idxprom52 = zext i32 %i.0 to i64
  %arrayidx53 = getelementptr inbounds [0 x %struct.usb3_lpm_parameters], [0 x %struct.usb3_lpm_parameters]* %iso_frame_desc51, i64 0, i64 %idxprom52
  %status54 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %arrayidx53, i32 0, i32 3
  %17 = load i32, i32* %status54, align 4, !tbaa !478
  %iso_frame_desc55 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 12
  %idxprom56 = zext i32 %i.0 to i64
  %arrayidx57 = getelementptr inbounds [0 x %struct.exception_table_entry], [0 x %struct.exception_table_entry]* %iso_frame_desc55, i64 0, i64 %idxprom56
  %status58 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %arrayidx57, i32 0, i32 2
  %18 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %17, i32* %status58) #8, !srcloc !807
  %conv60 = sext i32 %18 to i64
  %expval61 = call i64 @llvm.expect.i64(i64 %conv60, i64 0)
  %tobool62 = icmp ne i64 %expval61, 0
  br i1 %tobool62, label %cleanup, label %for.inc

for.inc:                                          ; preds = %if.end48
  %inc = add i32 %i.0, 1
  br label %for.cond

if.end65:                                         ; preds = %for.cond, %if.end31
  call void @__might_fault(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.36.775, i32 0, i32 0), i32 1860)
  %19 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %3, i8** %arg) #8, !srcloc !808
  br label %cleanup

cleanup:                                          ; preds = %if.end65, %if.end48, %for.body, %if.end22, %if.end12, %if.end8, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @poll_wait(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #1 {
entry:
  %tobool = icmp ne %struct.poll_table_struct* %p, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %0 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8, !tbaa !809
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.__wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %1 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8, !tbaa !809
  call void %1(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_devio_init() #5 section ".init.text" {
entry:
  %call = call i32 @register_chrdev_region(i32 198180864, i32 8192, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.3.823, i32 0, i32 0))
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = call i32 (i8*, ...) @printk(i8* null)
  br label %out

if.end:                                           ; preds = %entry
  call void @cdev_init(%struct.cdev* @usb_device_cdev, %struct.file_operations* @usbdev_file_operations)
  %call3 = call i32 @cdev_add(%struct.cdev* @usb_device_cdev, i32 198180864, i32 8192)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %1 = call i32 (i8*, ...) @printk(i8* null)
  call void @unregister_chrdev_region(i32 198180864, i32 8192)
  br label %out

if.end7:                                          ; preds = %if.end
  call void @usb_register_notify(%struct.notifier_block* @usbdev_nb)
  br label %out

out:                                              ; preds = %if.end7, %if.then5, %if.then
  %retval1.0 = phi i32 [ %call, %if.then ], [ %call3, %if.then5 ], [ %call3, %if.end7 ]
  ret i32 %retval1.0
}

declare i32 @register_chrdev_region(i32, i32, i8*) #2

declare void @cdev_init(%struct.cdev*, %struct.file_operations*) #2

declare i32 @cdev_add(%struct.cdev*, i32, i32) #2

declare void @unregister_chrdev_region(i32, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_notify(%struct.notifier_block* %self, i64 %action, i8* %dev) #0 {
entry:
  %Pivot = icmp slt i64 %action, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i64 %action, 2
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.epilog

LeafBlock:                                        ; preds = %entry
  ret i32 1

sw.bb:                                            ; preds = %LeafBlock1
  %0 = bitcast i8* %dev to %struct.usb_device*
  call void @usbdev_remove(%struct.usb_device* %0)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb, %LeafBlock1
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal void @usbdev_remove(%struct.usb_device* %udev) #0 {
entry:
  %sinfo = alloca %struct.siginfo, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %filelist = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 27
  %call = call i32 @list_empty.720(%struct.list_head* %filelist)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %filelist1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 27
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %filelist1, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !811
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.usb_dev_state*
  call void @destroy_all_async(%struct.usb_dev_state* %2)
  %wait = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %2, i32 0, i32 7
  call void @__wake_up(%struct.__wait_queue_head* %wait, i32 3, i32 0, i8* null)
  %list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %2, i32 0, i32 0
  call void @list_del_init.721(%struct.list_head* %list)
  %discsignr = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %2, i32 0, i32 8
  %3 = load i32, i32* %discsignr, align 8, !tbaa !726
  %tobool2 = icmp ne i32 %3, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %4 = bitcast %struct.siginfo* %sinfo to i8*
  %call3 = call i8* @__memset(i8* %4, i32 0, i64 128)
  %discsignr4 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %2, i32 0, i32 8
  %5 = load i32, i32* %discsignr4, align 8, !tbaa !726
  %si_signo = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 0
  store i32 %5, i32* %si_signo, align 8, !tbaa !812
  %si_errno = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 1
  store i32 32, i32* %si_errno, align 4, !tbaa !814
  %si_code = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 2
  store i32 -4, i32* %si_code, align 8, !tbaa !815
  %disccontext = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %2, i32 0, i32 11
  %6 = load i8*, i8** %disccontext, align 8, !tbaa !728
  %_sifields = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 3
  %_sigfault = bitcast %union.anon.12* %_sifields to %struct.anon.17*
  %_addr = getelementptr inbounds %struct.anon.17, %struct.anon.17* %_sigfault, i32 0, i32 0
  store i8* %6, i8** %_addr, align 8, !tbaa !72
  %discsignr5 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %2, i32 0, i32 8
  %7 = load i32, i32* %discsignr5, align 8, !tbaa !726
  %disc_pid = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %2, i32 0, i32 9
  %8 = load %struct.pid*, %struct.pid** %disc_pid, align 8, !tbaa !679
  %cred = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %2, i32 0, i32 10
  %9 = load %struct.cred*, %struct.cred** %cred, align 8, !tbaa !680
  %secid = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %2, i32 0, i32 13
  %10 = load i32, i32* %secid, align 8, !tbaa !816
  %call6 = call i32 @kill_pid_info_as_cred(i32 %7, %struct.siginfo* %sinfo, %struct.pid* %8, %struct.cred* %9, i32 %10)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_devio_cleanup() #0 {
entry:
  call void @usb_unregister_notify(%struct.notifier_block* @usbdev_nb)
  call void @cdev_del(%struct.cdev* @usb_device_cdev)
  call void @unregister_chrdev_region(i32 198180864, i32 8192)
  ret void
}

declare void @cdev_del(%struct.cdev*) #2

; Function Attrs: nounwind uwtable
define void @usb_unregister_notify(%struct.notifier_block* %nb) #0 {
entry:
  %call = call i32 @blocking_notifier_chain_unregister(%struct.blocking_notifier_head* @usb_notifier_list, %struct.notifier_block* %nb)
  ret void
}

declare i32 @blocking_notifier_chain_unregister(%struct.blocking_notifier_head*, %struct.notifier_block*) #2

; Function Attrs: nounwind uwtable
define void @usb_register_notify(%struct.notifier_block* %nb) #0 {
entry:
  %call = call i32 @blocking_notifier_chain_register(%struct.blocking_notifier_head* @usb_notifier_list, %struct.notifier_block* %nb)
  ret void
}

declare i32 @blocking_notifier_chain_register(%struct.blocking_notifier_head*, %struct.notifier_block*) #2

; Function Attrs: nounwind uwtable
define void @usb_notify_add_device(%struct.usb_device* %udev) #0 {
entry:
  %0 = bitcast %struct.usb_device* %udev to i8*
  %call = call i32 @blocking_notifier_call_chain(%struct.blocking_notifier_head* @usb_notifier_list, i64 1, i8* %0)
  ret void
}

declare i32 @blocking_notifier_call_chain(%struct.blocking_notifier_head*, i64, i8*) #2

; Function Attrs: nounwind uwtable
define void @usb_notify_remove_device(%struct.usb_device* %udev) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @usbfs_mutex, i32 0)
  %0 = bitcast %struct.usb_device* %udev to i8*
  %call = call i32 @blocking_notifier_call_chain(%struct.blocking_notifier_head* @usb_notifier_list, i64 2, i8* %0)
  call void @mutex_unlock(%struct.mutex* @usbfs_mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_notify_add_bus(%struct.usb_bus* %ubus) #0 {
entry:
  %0 = bitcast %struct.usb_bus* %ubus to i8*
  %call = call i32 @blocking_notifier_call_chain(%struct.blocking_notifier_head* @usb_notifier_list, i64 3, i8* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_notify_remove_bus(%struct.usb_bus* %ubus) #0 {
entry:
  %0 = bitcast %struct.usb_bus* %ubus to i8*
  %call = call i32 @blocking_notifier_call_chain(%struct.blocking_notifier_head* @usb_notifier_list, i64 4, i8* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @generic_probe(%struct.usb_device* %udev) #0 {
entry:
  %authorized = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %authorized, align 4
  %bf.lshr = lshr i16 %bf.load, 3
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end8

if.else:                                          ; preds = %entry
  %call = call i32 @usb_choose_configuration(%struct.usb_device* %udev)
  %cmp1 = icmp sge i32 %call, 0
  br i1 %cmp1, label %if.then2, label %if.end8

if.then2:                                         ; preds = %if.else
  %call3 = call i32 @usb_set_configuration(%struct.usb_device* %udev, i32 %call)
  switch i32 %call3, label %if.then5 [
    i32 0, label %if.end8
    i32 -19, label %if.end8
  ]

if.then5:                                         ; preds = %if.then2
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %if.then2, %if.then2, %if.else, %if.then
  call void @usb_notify_add_device(%struct.usb_device* %udev)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @generic_disconnect(%struct.usb_device* %udev) #0 {
entry:
  call void @usb_notify_remove_device(%struct.usb_device* %udev)
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @usb_set_configuration(%struct.usb_device* %udev, i32 -1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @generic_suspend(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.atomic_t, align 4
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool = icmp ne %struct.usb_device* %0, null
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %1 = load i32, i32* %event, align 4
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 @hcd_bus_suspend(%struct.usb_device* %udev, i32 %1)
  br label %if.end8

if.else:                                          ; preds = %entry
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.end8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %event2 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %2 = load i32, i32* %event2, align 4, !tbaa !48
  %cmp3 = icmp eq i32 %2, 8
  br i1 %cmp3, label %if.end8, label %if.else5

if.else5:                                         ; preds = %lor.lhs.false
  %coerce.dive6 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %3 = load i32, i32* %coerce.dive6, align 4
  %call7 = call i32 @usb_port_suspend(%struct.usb_device* %udev, i32 %3)
  br label %if.end8

if.end8:                                          ; preds = %if.else5, %lor.lhs.false, %if.else, %if.then
  %rc.1 = phi i32 [ %call, %if.then ], [ %call7, %if.else5 ], [ 0, %lor.lhs.false ], [ 0, %if.else ]
  ret i32 %rc.1
}

; Function Attrs: nounwind uwtable
define internal i32 @generic_resume(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.atomic_t, align 4
  %coerce.dive = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool = icmp ne %struct.usb_device* %0, null
  %coerce.dive2 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %msg, i32 0, i32 0
  %1 = load i32, i32* %coerce.dive2, align 4
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 @hcd_bus_resume(%struct.usb_device* %udev, i32 %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call3 = call i32 @usb_port_resume(%struct.usb_device* %udev, i32 %1)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %rc.0 = phi i32 [ %call3, %if.else ], [ %call, %if.then ]
  ret i32 %rc.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_choose_configuration(%struct.usb_device* %udev) #0 {
entry:
  %call = call zeroext i1 @usb_device_is_owned(%struct.usb_device* %udev)
  br i1 %call, label %cleanup68, label %if.end

if.end:                                           ; preds = %entry
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 14
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !194
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 13
  %1 = load i8, i8* %bNumConfigurations, align 1, !tbaa !193
  %conv = zext i8 %1 to i32
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %best.0 = phi %struct.usb_host_config* [ null, %if.end ], [ %best.3, %for.inc ]
  %c.0 = phi %struct.usb_host_config* [ %0, %if.end ], [ %incdec.ptr, %for.inc ]
  %insufficient_power.0 = phi i32 [ 0, %if.end ], [ %insufficient_power.1, %for.inc ]
  %i.0 = phi i32 [ 0, %if.end ], [ %inc43, %for.inc ]
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %desc2 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %c.0, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc2, i32 0, i32 3
  %2 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv3 = zext i8 %2 to i32
  %cmp4 = icmp sgt i32 %conv3, 0
  br i1 %cmp4, label %if.then6, label %if.end8

if.then6:                                         ; preds = %for.body
  %intf_cache = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %c.0, i32 0, i32 4
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache, i64 0, i64 0
  %3 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx, align 8, !tbaa !52
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %3, i32 0, i32 2
  %arraydecay = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i32 0, i32 0
  %desc7 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arraydecay, i32 0, i32 0
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %for.body
  %desc.0 = phi %struct.usb_interface_descriptor* [ %desc7, %if.then6 ], [ null, %for.body ]
  %call9 = call i32 @usb_get_max_power.846(%struct.usb_device* %udev, %struct.usb_host_config* %c.0)
  %bus_mA = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 19
  %4 = load i16, i16* %bus_mA, align 8, !tbaa !306
  %conv10 = zext i16 %4 to i32
  %cmp11 = icmp ugt i32 %call9, %conv10
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end8
  %inc = add nsw i32 %insufficient_power.0, 1
  br label %NodeBlock

if.end14:                                         ; preds = %if.end8
  %cmp15 = icmp eq i32 %i.0, 0
  %cmp17 = icmp sgt i32 %conv, 1
  %or.cond = and i1 %cmp15, %cmp17
  %tobool = icmp ne %struct.usb_interface_descriptor* %desc.0, null
  %or.cond1 = and i1 %or.cond, %tobool
  br i1 %or.cond1, label %land.lhs.true20, label %if.else

land.lhs.true20:                                  ; preds = %if.end14
  %call21 = call i32 @is_rndis(%struct.usb_interface_descriptor* %desc.0)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %NodeBlock, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true20
  %call23 = call i32 @is_activesync(%struct.usb_interface_descriptor* %desc.0)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %NodeBlock, label %if.else

if.else:                                          ; preds = %lor.lhs.false, %if.end14
  %descriptor26 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bDeviceClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor26, i32 0, i32 3
  %5 = load i8, i8* %bDeviceClass, align 4, !tbaa !278
  %conv27 = zext i8 %5 to i32
  %cmp28 = icmp ne i32 %conv27, 255
  %tobool31 = icmp ne %struct.usb_interface_descriptor* %desc.0, null
  %or.cond2 = and i1 %cmp28, %tobool31
  br i1 %or.cond2, label %land.lhs.true32, label %if.else37

land.lhs.true32:                                  ; preds = %if.else
  %bInterfaceClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc.0, i32 0, i32 5
  %6 = load i8, i8* %bInterfaceClass, align 1, !tbaa !817
  %conv33 = zext i8 %6 to i32
  %cmp34 = icmp ne i32 %conv33, 255
  br i1 %cmp34, label %NodeBlock, label %if.else37

if.else37:                                        ; preds = %land.lhs.true32, %if.else
  %tobool38 = icmp ne %struct.usb_host_config* %best.0, null
  %best.0.c.0 = select i1 %tobool38, %struct.usb_host_config* %best.0, %struct.usb_host_config* %c.0
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.else37, %land.lhs.true32, %lor.lhs.false, %land.lhs.true20, %if.then13
  %best.3 = phi %struct.usb_host_config* [ %best.0, %if.then13 ], [ %c.0, %land.lhs.true32 ], [ %best.0.c.0, %if.else37 ], [ %c.0, %lor.lhs.false ], [ %c.0, %land.lhs.true20 ]
  %insufficient_power.1 = phi i32 [ %inc, %if.then13 ], [ %insufficient_power.0, %land.lhs.true32 ], [ %insufficient_power.0, %land.lhs.true20 ], [ %insufficient_power.0, %lor.lhs.false ], [ %insufficient_power.0, %if.else37 ]
  %cleanup.dest.slot.0 = phi i32 [ 4, %if.then13 ], [ 2, %land.lhs.true32 ], [ 0, %land.lhs.true20 ], [ 0, %lor.lhs.false ], [ 0, %if.else37 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 4
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 2
  %or.cond3 = and i1 %Pivot, %SwitchLeaf
  br i1 %or.cond3, label %for.end, label %for.inc

for.inc:                                          ; preds = %NodeBlock
  %inc43 = add nsw i32 %i.0, 1
  %incdec.ptr = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %c.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %NodeBlock, %for.cond
  %best.4 = phi %struct.usb_host_config* [ %best.0, %for.cond ], [ %best.3, %NodeBlock ]
  %insufficient_power.2 = phi i32 [ %insufficient_power.0, %for.cond ], [ %insufficient_power.1, %NodeBlock ]
  %cmp44 = icmp sgt i32 %insufficient_power.2, 0
  br i1 %cmp44, label %if.then46, label %if.end48

if.then46:                                        ; preds = %for.end
  %call47 = call i8* @plural.847(i32 %insufficient_power.2)
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %if.end48

if.end48:                                         ; preds = %if.then46, %for.end
  %tobool49 = icmp ne %struct.usb_host_config* %best.4, null
  br i1 %tobool49, label %if.then50, label %if.else64

if.then50:                                        ; preds = %if.end48
  %desc51 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %best.4, i32 0, i32 0
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc51, i32 0, i32 4
  %7 = load i8, i8* %bConfigurationValue, align 1, !tbaa !168
  %conv52 = zext i8 %7 to i32
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_choose_configuration.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool54 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool54, true
  %lnot55 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot55 to i32
  %conv56 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv56, i64 0)
  %tobool57 = icmp ne i64 %expval, 0
  br i1 %tobool57, label %if.then58, label %cleanup68

if.then58:                                        ; preds = %if.then50
  %dev59 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call60 = call i8* @plural.847(i32 %conv)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_choose_configuration.descriptor to %struct._ddebug*), %struct.device* %dev59, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.3.849, i32 0, i32 0), i32 %conv52, i32 %conv, i8* %call60)
  br label %cleanup68

if.else64:                                        ; preds = %if.end48
  %call66 = call i8* @plural.847(i32 %conv)
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup68

cleanup68:                                        ; preds = %if.else64, %if.then58, %if.then50, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ -1, %if.else64 ], [ %conv52, %if.then58 ], [ %conv52, %if.then50 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_get_max_power.846(%struct.usb_device* %udev, %struct.usb_host_config* %c) #1 {
entry:
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !177
  %cmp = icmp uge i32 %0, 5
  %cond = select i1 %cmp, i32 8, i32 2
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %c, i32 0, i32 0
  %bMaxPower = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 7
  %1 = load i8, i8* %bMaxPower, align 8, !tbaa !331
  %conv = zext i8 %1 to i32
  %mul1 = mul i32 %conv, %cond
  ret i32 %mul1
}

; Function Attrs: nounwind uwtable
define internal i32 @is_rndis(%struct.usb_interface_descriptor* %desc) #0 {
entry:
  %bInterfaceClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 5
  %0 = load i8, i8* %bInterfaceClass, align 1, !tbaa !817
  %conv = zext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 2
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %bInterfaceSubClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 6
  %1 = load i8, i8* %bInterfaceSubClass, align 1, !tbaa !818
  %conv2 = zext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 2
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %bInterfaceProtocol = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 7
  %2 = load i8, i8* %bInterfaceProtocol, align 1, !tbaa !819
  %conv5 = zext i8 %2 to i32
  %cmp6 = icmp eq i32 %conv5, 255
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %3 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp6, %land.rhs ]
  %land.ext = zext i1 %3 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define internal i32 @is_activesync(%struct.usb_interface_descriptor* %desc) #0 {
entry:
  %bInterfaceClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 5
  %0 = load i8, i8* %bInterfaceClass, align 1, !tbaa !817
  %conv = zext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 239
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %bInterfaceSubClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 6
  %1 = load i8, i8* %bInterfaceSubClass, align 1, !tbaa !818
  %conv2 = zext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 1
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %bInterfaceProtocol = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 7
  %2 = load i8, i8* %bInterfaceProtocol, align 1, !tbaa !819
  %conv5 = zext i8 %2 to i32
  %cmp6 = icmp eq i32 %conv5, 1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %3 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp6, %land.rhs ]
  %land.ext = zext i1 %3 to i32
  ret i32 %land.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @plural.847(i32 %n) #1 {
entry:
  %cmp = icmp eq i32 %n, 1
  %cond = select i1 %cmp, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.28.900, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.7.854, i32 0, i32 0)
  ret i8* %cond
}

; Function Attrs: nounwind uwtable
define void @usb_detect_quirks(%struct.usb_device* %udev) #0 {
entry:
  %call = call i32 @__usb_detect_quirks(%struct.usb_device* %udev, %struct.usb_device_id* getelementptr inbounds ([62 x %struct.usb_device_id], [62 x %struct.usb_device_id]* @usb_quirk_list, i32 0, i32 0))
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  store i32 %call, i32* %quirks, align 4, !tbaa !199
  %call1 = call i32 @usb_amd_resume_quirk(%struct.usb_device* %udev)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call i32 @__usb_detect_quirks(%struct.usb_device* %udev, %struct.usb_device_id* getelementptr inbounds ([6 x %struct.usb_device_id], [6 x %struct.usb_device_id]* @usb_amd_resume_quirk_list, i32 0, i32 0))
  %quirks3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %0 = load i32, i32* %quirks3, align 4, !tbaa !199
  %or = or i32 %0, %call2
  store i32 %or, i32* %quirks3, align 4, !tbaa !199
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %quirks4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %1 = load i32, i32* %quirks4, align 4, !tbaa !199
  %tobool5 = icmp ne i32 %1, 0
  br i1 %tobool5, label %do.body7, label %if.end15

do.body7:                                         ; preds = %if.end
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_detect_quirks.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool8 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool8, true
  %lnot9 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then11, label %if.end15

if.then11:                                        ; preds = %do.body7
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %quirks12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %2 = load i32, i32* %quirks12, align 4, !tbaa !199
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_detect_quirks.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.2.858, i32 0, i32 0), i32 %2)
  br label %if.end15

if.end15:                                         ; preds = %if.then11, %do.body7, %if.end
  %quirks16 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %3 = load i32, i32* %quirks16, align 4, !tbaa !199
  %conv17 = zext i32 %3 to i64
  %and18 = and i64 %conv17, 16
  %tobool19 = icmp ne i64 %and18, 0
  br i1 %tobool19, label %if.end23, label %if.then20

if.then20:                                        ; preds = %if.end15
  %persist_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load21 = load i16, i16* %persist_enabled, align 4
  %bf.clear22 = and i16 %bf.load21, -3
  %bf.set = or i16 %bf.clear22, 2
  store i16 %bf.set, i16* %persist_enabled, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.then20, %if.end15
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @__usb_detect_quirks(%struct.usb_device* %udev, %struct.usb_device_id* %id) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %id.addr.0 = phi %struct.usb_device_id* [ %id, %entry ], [ %incdec.ptr, %for.inc ]
  %quirks.0 = phi i32 [ 0, %entry ], [ %quirks.1, %for.inc ]
  %match_flags = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 0, i32 0
  %0 = load i16, i16* %match_flags, align 8, !tbaa !270
  %tobool = icmp ne i16 %0, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @usb_match_device(%struct.usb_device* %udev, %struct.usb_device_id* %id.addr.0)
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.end, label %for.inc

if.end:                                           ; preds = %for.body
  %match_flags2 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 0, i32 0
  %1 = load i16, i16* %match_flags2, align 8, !tbaa !270
  %conv = zext i16 %1 to i32
  %and = and i32 %conv, 896
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %call4 = call zeroext i1 @usb_match_any_interface(%struct.usb_device* %udev, %struct.usb_device_id* %id.addr.0)
  br i1 %call4, label %if.end6, label %for.inc

if.end6:                                          ; preds = %land.lhs.true, %if.end
  %driver_info = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 0, i32 12
  %2 = load i64, i64* %driver_info, align 8, !tbaa !292
  %conv7 = trunc i64 %2 to i32
  %or = or i32 %quirks.0, %conv7
  br label %for.inc

for.inc:                                          ; preds = %if.end6, %land.lhs.true, %for.body
  %quirks.1 = phi i32 [ %or, %if.end6 ], [ %quirks.0, %for.body ], [ %quirks.0, %land.lhs.true ]
  %incdec.ptr = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret i32 %quirks.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_amd_resume_quirk(%struct.usb_device* %udev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.861(%struct.usb_bus* %0)
  %level = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 21
  %1 = load i8, i8* %level, align 1, !tbaa !78
  %conv = zext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %amd_resume_bug = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 12
  %bf.load = load i16, i16* %amd_resume_bug, align 8
  %bf.lshr = lshr i16 %bf.load, 7
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %cmp2 = icmp eq i32 %bf.cast, 1
  br i1 %cmp2, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  br label %cleanup

cleanup:                                          ; preds = %if.end, %land.lhs.true
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %land.lhs.true ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd* @bus_to_hcd.861(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd*
  ret %struct.usb_hcd* %1
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @usb_match_any_interface(%struct.usb_device* %udev, %struct.usb_device_id* %id) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc20, %for.inc19 ]
  %retval.0 = phi i1 [ undef, %entry ], [ %retval.3, %for.inc19 ]
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 13
  %0 = load i8, i8* %bNumConfigurations, align 1, !tbaa !193
  %conv = zext i8 %0 to i32
  %cmp = icmp ult i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %cleanup22

for.body:                                         ; preds = %for.cond
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 14
  %1 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !194
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %1, i64 %idxprom
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %for.body
  %j.0 = phi i32 [ 0, %for.body ], [ %inc, %for.inc ]
  %retval.1 = phi i1 [ %retval.0, %for.body ], [ %retval.2, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %2 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv3 = zext i8 %2 to i32
  %cmp4 = icmp ult i32 %j.0, %conv3
  br i1 %cmp4, label %for.body6, label %LeafBlock4

for.body6:                                        ; preds = %for.cond2
  %intf_cache = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx, i32 0, i32 4
  %idxprom7 = zext i32 %j.0 to i64
  %arrayidx8 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache, i64 0, i64 %idxprom7
  %3 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx8, align 8, !tbaa !52
  %num_altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %3, i32 0, i32 0
  %4 = load i32, i32* %num_altsetting, align 8, !tbaa !107
  %cmp9 = icmp eq i32 %4, 0
  br i1 %cmp9, label %NodeBlock, label %if.end

if.end:                                           ; preds = %for.body6
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %3, i32 0, i32 2
  %arrayidx11 = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i64 0, i64 0
  %call = call i32 @usb_match_one_id_intf(%struct.usb_device* %udev, %struct.usb_host_interface* %arrayidx11, %struct.usb_device_id* %id)
  %tobool = icmp ne i32 %call, 0
  %. = select i1 %tobool, i32 1, i32 0
  %.retval.1 = select i1 %tobool, i1 true, i1 %retval.1
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end, %for.body6
  %cleanup.dest.slot.0 = phi i32 [ 7, %for.body6 ], [ %., %if.end ]
  %retval.2 = phi i1 [ %retval.1, %for.body6 ], [ %.retval.1, %if.end ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 7
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 7
  br i1 %SwitchLeaf2, label %for.inc, label %LeafBlock4

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc, label %LeafBlock4

for.inc:                                          ; preds = %LeafBlock, %LeafBlock1
  %inc = add i32 %j.0, 1
  br label %for.cond2

LeafBlock4:                                       ; preds = %LeafBlock, %LeafBlock1, %for.cond2
  %cleanup.dest.slot.1 = phi i32 [ 0, %for.cond2 ], [ %cleanup.dest.slot.0, %LeafBlock1 ], [ %cleanup.dest.slot.0, %LeafBlock ]
  %retval.3 = phi i1 [ %retval.1, %for.cond2 ], [ %retval.2, %LeafBlock1 ], [ %retval.2, %LeafBlock ]
  %SwitchLeaf5 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf5, label %for.inc19, label %cleanup22

for.inc19:                                        ; preds = %LeafBlock4
  %inc20 = add i32 %i.0, 1
  br label %for.cond

cleanup22:                                        ; preds = %LeafBlock4, %for.cond
  %retval.4 = phi i1 [ false, %for.cond ], [ %retval.3, %LeafBlock4 ]
  ret i1 %retval.4
}

; Function Attrs: nounwind uwtable
define void @usb_detect_interface_quirks(%struct.usb_device* %udev) #0 {
entry:
  %call = call i32 @__usb_detect_quirks(%struct.usb_device* %udev, %struct.usb_device_id* getelementptr inbounds ([2 x %struct.usb_device_id], [2 x %struct.usb_device_id]* @usb_interface_quirk_list, i32 0, i32 0))
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %cleanup.cont, label %do.body1

do.body1:                                         ; preds = %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_detect_interface_quirks.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.end7

if.then4:                                         ; preds = %do.body1
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_detect_interface_quirks.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.3.864, i32 0, i32 0), i32 %call)
  br label %do.end7

do.end7:                                          ; preds = %if.then4, %do.body1
  %quirks8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %0 = load i32, i32* %quirks8, align 4, !tbaa !199
  %or = or i32 %0, %call
  store i32 %or, i32* %quirks8, align 4, !tbaa !199
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %do.end7, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @usb_device_read(%struct.file* %file, i8* %buf, i64 %nbytes, i64* %ppos) #0 {
entry:
  %buf.addr = alloca i8*, align 8
  %nbytes.addr = alloca i64, align 8
  %skip_bytes = alloca i64, align 8
  %id = alloca i32, align 4
  store i8* %buf, i8** %buf.addr, align 8, !tbaa !52
  store i64 %nbytes, i64* %nbytes.addr, align 8, !tbaa !53
  %0 = load i64, i64* %ppos, align 8, !tbaa !86
  store i64 %0, i64* %skip_bytes, align 8, !tbaa !86
  %1 = load i64, i64* %ppos, align 8, !tbaa !86
  %cmp = icmp slt i64 %1, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = load i64, i64* %nbytes.addr, align 8, !tbaa !53
  %cmp1 = icmp ule i64 %2, 0
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %3 = call i32 asm "movl %gs:$1,$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @__preempt_count) #9, !srcloc !820
  %and.i = and i32 %3, 2147483647
  %conv = sext i32 %and.i to i64
  %and = and i64 %conv, 2031872
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot6 = xor i1 %lnot5, true
  %lnot.ext = zext i1 %lnot6 to i32
  %tobool7 = icmp ne i32 %lnot.ext, 0
  br i1 %tobool7, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end3
  %4 = load i8, i8* @usb_device_read.__warned, align 1, !tbaa !109, !range !110
  %tobool8 = trunc i8 %4 to i1
  %lnot9 = xor i1 %tobool8, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end3
  %5 = phi i1 [ false, %if.end3 ], [ %lnot9, %land.rhs ]
  %lnot11 = xor i1 %5, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool16 = icmp ne i64 %expval, 0
  br i1 %tobool16, label %if.then17, label %if.end35

if.then17:                                        ; preds = %land.end
  store i8 1, i8* @usb_device_read.__warned, align 1, !tbaa !109
  %tobool18 = icmp ne i32 1, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.then17
  call void @warn_slowpath_null(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.1.872, i32 0, i32 0), i32 614)
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %if.then17
  br label %if.end35

if.end35:                                         ; preds = %if.end27, %land.end
  %6 = load i8*, i8** %buf.addr, align 8, !tbaa !52
  %7 = ptrtoint i8* %6 to i64
  %8 = load i64, i64* %nbytes.addr, align 8, !tbaa !53
  %9 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !821
  %thread = getelementptr inbounds %struct.task_struct, %struct.task_struct* %9, i32 0, i32 212
  %addr_limit = getelementptr inbounds %struct.thread_struct, %struct.thread_struct* %thread, i32 0, i32 19
  %seg = getelementptr inbounds %union.anon.3, %union.anon.3* %addr_limit, i32 0, i32 0
  %10 = load i64, i64* %seg, align 8, !tbaa !700
  %call47 = call zeroext i1 @__chk_range_not_ok.874(i64 %7, i64 %8, i64 %10)
  %frombool = zext i1 %call47 to i8
  %tobool48 = trunc i8 %frombool to i1
  %lnot49 = xor i1 %tobool48, true
  %lnot51 = xor i1 %lnot49, true
  %lnot53 = xor i1 %lnot51, true
  %lnot.ext54 = zext i1 %lnot53 to i32
  %conv55 = sext i32 %lnot.ext54 to i64
  %expval56 = call i64 @llvm.expect.i64(i64 %conv55, i64 1)
  %tobool57 = icmp ne i64 %expval56, 0
  br i1 %tobool57, label %if.end59, label %cleanup

if.end59:                                         ; preds = %if.end35
  call void @mutex_lock_nested(%struct.mutex* @usb_bus_idr_lock, i32 0)
  store i32 0, i32* %id, align 4, !tbaa !73
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end59
  %total_written.0 = phi i64 [ 0, %if.end59 ], [ %total_written.1, %for.inc ]
  %call60 = call i8* @idr_get_next(%struct.idr* @usb_bus_idr, i32* %id)
  %11 = bitcast i8* %call60 to %struct.usb_bus*
  %cmp61 = icmp ne %struct.usb_bus* %11, null
  br i1 %cmp61, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call63 = call %struct.usb_hcd* @bus_to_hcd.875(%struct.usb_bus* %11)
  %rh_registered = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call63, i32 0, i32 12
  %bf.load = load i16, i16* %rh_registered, align 8
  %bf.clear = and i16 %bf.load, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool64 = icmp ne i32 %bf.cast, 0
  br i1 %tobool64, label %if.end66, label %for.inc

if.end66:                                         ; preds = %for.body
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %11, i32 0, i32 11
  %12 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !264
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 11
  call void @device_lock.876(%struct.device* %dev)
  %root_hub67 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %11, i32 0, i32 11
  %13 = load %struct.usb_device*, %struct.usb_device** %root_hub67, align 8, !tbaa !264
  %call68 = call i64 @usb_device_dump(i8** %buf.addr, i64* %nbytes.addr, i64* %skip_bytes, i64* %ppos, %struct.usb_device* %13, i32 0)
  %root_hub69 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %11, i32 0, i32 11
  %14 = load %struct.usb_device*, %struct.usb_device** %root_hub69, align 8, !tbaa !264
  %dev70 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %14, i32 0, i32 11
  call void @device_unlock.877(%struct.device* %dev70)
  %cmp71 = icmp slt i64 %call68, 0
  br i1 %cmp71, label %if.then73, label %if.end74

if.then73:                                        ; preds = %if.end66
  call void @mutex_unlock(%struct.mutex* @usb_bus_idr_lock)
  br label %cleanup

if.end74:                                         ; preds = %if.end66
  %add = add nsw i64 %total_written.0, %call68
  br label %for.inc

for.inc:                                          ; preds = %if.end74, %for.body
  %total_written.1 = phi i64 [ %add, %if.end74 ], [ %total_written.0, %for.body ]
  %15 = load i32, i32* %id, align 4, !tbaa !73
  %inc = add nsw i32 %15, 1
  store i32 %inc, i32* %id, align 4, !tbaa !73
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @mutex_unlock(%struct.mutex* @usb_bus_idr_lock)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then73, %if.end35, %if.end, %entry
  %retval.0 = phi i64 [ %call68, %if.then73 ], [ %total_written.0, %for.end ], [ -22, %entry ], [ 0, %if.end ], [ -14, %if.end35 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_device_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  call void @poll_wait.867(%struct.file* %file, %struct.__wait_queue_head* getelementptr inbounds (%struct.ctl_table_poll, %struct.ctl_table_poll* @device_event, i32 0, i32 1), %struct.poll_table_struct* %wait)
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %0 = load volatile i32, i32* getelementptr inbounds (%struct.ctl_table_poll, %struct.ctl_table_poll* @device_event, i32 0, i32 0, i32 0), align 4, !tbaa !73
  %1 = bitcast i8* %arraydecay.i to i32*
  store i32 %0, i32* %1, align 4, !tbaa !73
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %2 = load i32, i32* %__val.i, align 4, !tbaa !72
  %f_version = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 13
  %3 = load i64, i64* %f_version, align 8, !tbaa !822
  %conv = zext i32 %2 to i64
  %cmp = icmp ne i64 %3, %conv
  br i1 %cmp, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  %conv2 = zext i32 %2 to i64
  %f_version3 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 13
  store i64 %conv2, i64* %f_version3, align 8, !tbaa !822
  br label %cleanup

cleanup:                                          ; preds = %if.then, %entry
  %retval.0 = phi i32 [ 65, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @poll_wait.867(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #1 {
entry:
  %tobool = icmp ne %struct.poll_table_struct* %p, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %0 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8, !tbaa !809
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.__wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %1 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8, !tbaa !809
  call void %1(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @__chk_range_not_ok.874(i64 %addr, i64 %size, i64 %limit) #1 {
entry:
  %add = add i64 %addr, %size
  %cmp = icmp ult i64 %add, %size
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp2 = icmp ugt i64 %add, %limit
  %lnot4 = xor i1 %cmp2, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv8 = sext i32 %lnot.ext7 to i64
  %expval9 = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  %tobool10 = icmp ne i64 %expval9, 0
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i1 [ %tobool10, %if.end ], [ true, %entry ]
  ret i1 %retval.0
}

declare i8* @idr_get_next(%struct.idr*, i32*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd* @bus_to_hcd.875(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd*
  ret %struct.usb_hcd* %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock.876(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @usb_device_dump(i8** %buffer, i64* %nbytes, i64* %skip_bytes, i64* %file_offset, %struct.usb_device* %usbdev, i32 %level) #0 {
entry:
  %0 = load i64, i64* %nbytes, align 8, !tbaa !53
  %cmp = icmp ule i64 %0, 0
  %cmp1 = icmp sgt i32 %level, 6
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %entry
  %call = call i64 @__get_free_pages(i32 20971520, i32 1)
  %1 = inttoptr i64 %call to i8*
  %tobool = icmp ne i8* %1, null
  br i1 %tobool, label %if.end5, label %cleanup

if.end5:                                          ; preds = %if.end3
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usbdev, i32 0, i32 8
  %2 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool6 = icmp ne %struct.usb_device* %2, null
  br i1 %tobool6, label %land.lhs.true, label %if.end12

land.lhs.true:                                    ; preds = %if.end5
  %parent7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usbdev, i32 0, i32 8
  %3 = load %struct.usb_device*, %struct.usb_device** %parent7, align 8, !tbaa !79
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 0
  %4 = load i32, i32* %devnum, align 8, !tbaa !44
  %cmp8 = icmp ne i32 %4, -1
  br i1 %cmp8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %land.lhs.true
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %land.lhs.true, %if.end5
  %speed13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usbdev, i32 0, i32 4
  %5 = load i32, i32* %speed13, align 4, !tbaa !177
  %Pivot10 = icmp slt i32 %5, 3
  br i1 %Pivot10, label %NodeBlock1, label %NodeBlock7

NodeBlock7:                                       ; preds = %if.end12
  %Pivot8 = icmp slt i32 %5, 5
  br i1 %Pivot8, label %sw.epilog, label %NodeBlock5

NodeBlock5:                                       ; preds = %NodeBlock7
  %Pivot6 = icmp slt i32 %5, 6
  br i1 %Pivot6, label %sw.epilog, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock5
  %SwitchLeaf4 = icmp eq i32 %5, 6
  br i1 %SwitchLeaf4, label %sw.epilog, label %sw.default

NodeBlock1:                                       ; preds = %if.end12
  %Pivot2 = icmp slt i32 %5, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %5, 2
  br i1 %Pivot, label %sw.epilog, label %sw.bb14

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %5, 0
  br i1 %SwitchLeaf, label %sw.bb14, label %sw.default

sw.bb14:                                          ; preds = %LeafBlock, %NodeBlock
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock3
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb14, %NodeBlock, %LeafBlock3, %NodeBlock5, %NodeBlock7
  %6 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext = sext i32 %6 to i64
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 %idx.ext
  %cmp20 = icmp eq i32 %level, 0
  br i1 %cmp20, label %if.then21, label %if.end33

if.then21:                                        ; preds = %sw.epilog
  %speed22 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usbdev, i32 0, i32 4
  %7 = load i32, i32* %speed22, align 4, !tbaa !177
  %cmp23 = icmp eq i32 %7, 3
  br i1 %cmp23, label %if.end27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then21
  br label %if.end27

if.end27:                                         ; preds = %lor.lhs.false, %if.then21
  %8 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext31 = sext i32 %8 to i64
  %add.ptr32 = getelementptr inbounds i8, i8* %add.ptr, i64 %idx.ext31
  br label %if.end33

if.end33:                                         ; preds = %if.end27, %sw.epilog
  %data_end.0 = phi i8* [ %add.ptr32, %if.end27 ], [ %add.ptr, %sw.epilog ]
  %add.ptr34 = getelementptr inbounds i8, i8* %1, i64 8192
  %add.ptr35 = getelementptr inbounds i8, i8* %add.ptr34, i64 -256
  %call36 = call i8* @usb_dump_desc(i8* %data_end.0, i8* %add.ptr35, %struct.usb_device* %usbdev)
  %add.ptr37 = getelementptr inbounds i8, i8* %1, i64 8192
  %add.ptr38 = getelementptr inbounds i8, i8* %add.ptr37, i64 -256
  %cmp39 = icmp ugt i8* %call36, %add.ptr38
  br i1 %cmp39, label %if.then40, label %if.end44

if.then40:                                        ; preds = %if.end33
  %9 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext42 = sext i32 %9 to i64
  %add.ptr43 = getelementptr inbounds i8, i8* %call36, i64 %idx.ext42
  br label %if.end44

if.end44:                                         ; preds = %if.then40, %if.end33
  %data_end.1 = phi i8* [ %add.ptr43, %if.then40 ], [ %call36, %if.end33 ]
  %sub.ptr.lhs.cast = ptrtoint i8* %data_end.1 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  %conv45 = zext i32 %conv to i64
  %10 = load i64, i64* %skip_bytes, align 8, !tbaa !86
  %cmp46 = icmp sgt i64 %conv45, %10
  br i1 %cmp46, label %if.then48, label %if.else71

if.then48:                                        ; preds = %if.end44
  %11 = load i64, i64* %skip_bytes, align 8, !tbaa !86
  %conv49 = zext i32 %conv to i64
  %sub = sub nsw i64 %conv49, %11
  %conv50 = trunc i64 %sub to i32
  %conv51 = zext i32 %conv50 to i64
  %12 = load i64, i64* %nbytes, align 8, !tbaa !53
  %cmp52 = icmp ugt i64 %conv51, %12
  br i1 %cmp52, label %if.then54, label %if.end56

if.then54:                                        ; preds = %if.then48
  %13 = load i64, i64* %nbytes, align 8, !tbaa !53
  %conv55 = trunc i64 %13 to i32
  br label %if.end56

if.end56:                                         ; preds = %if.then54, %if.then48
  %length.0 = phi i32 [ %conv55, %if.then54 ], [ %conv50, %if.then48 ]
  %14 = load i8*, i8** %buffer, align 8, !tbaa !52
  %15 = load i64, i64* %skip_bytes, align 8, !tbaa !86
  %add.ptr57 = getelementptr inbounds i8, i8* %1, i64 %15
  %conv58 = zext i32 %length.0 to i64
  %16 = call i64 @llvm.objectsize.i64.p0i8(i8* %add.ptr57, i1 false, i1 true) #8
  %conv.i = trunc i64 %16 to i32
  call void @kasan_check_read(i8* %add.ptr57, i32 %length.0) #8
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 718) #8
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, %conv58
  %17 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %17 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.end56
  call void @__check_object_size(i8* %add.ptr57, i64 %conv58, i1 zeroext true) #8
  %call.i = call i64 @_copy_to_user(i8* %14, i8* %add.ptr57, i32 %length.0) #8
  br label %copy_to_user.885.exit

if.else.i:                                        ; preds = %if.end56
  call void @copy_user_overflow.888(i32 %conv.i, i64 %conv58) #8
  br label %copy_to_user.885.exit

copy_to_user.885.exit:                            ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ %conv58, %if.else.i ]
  %tobool60 = icmp ne i64 %n.addr.0.i, 0
  br i1 %tobool60, label %if.then61, label %if.end62

if.then61:                                        ; preds = %copy_to_user.885.exit
  %18 = ptrtoint i8* %1 to i64
  call void @free_pages(i64 %18, i32 1)
  br label %cleanup

if.end62:                                         ; preds = %copy_to_user.885.exit
  %conv63 = zext i32 %length.0 to i64
  %19 = load i64, i64* %nbytes, align 8, !tbaa !53
  %sub64 = sub i64 %19, %conv63
  store i64 %sub64, i64* %nbytes, align 8, !tbaa !53
  %conv65 = zext i32 %length.0 to i64
  %20 = load i64, i64* %file_offset, align 8, !tbaa !86
  %add66 = add nsw i64 %20, %conv65
  store i64 %add66, i64* %file_offset, align 8, !tbaa !86
  %conv67 = zext i32 %length.0 to i64
  %add68 = add nsw i64 0, %conv67
  %21 = load i8*, i8** %buffer, align 8, !tbaa !52
  %idx.ext69 = zext i32 %length.0 to i64
  %add.ptr70 = getelementptr inbounds i8, i8* %21, i64 %idx.ext69
  store i8* %add.ptr70, i8** %buffer, align 8, !tbaa !52
  br label %if.end74

if.else71:                                        ; preds = %if.end44
  %conv72 = zext i32 %conv to i64
  %22 = load i64, i64* %skip_bytes, align 8, !tbaa !86
  %sub73 = sub nsw i64 %22, %conv72
  br label %if.end74

if.end74:                                         ; preds = %if.else71, %if.end62
  %sub73.sink = phi i64 [ %sub73, %if.else71 ], [ 0, %if.end62 ]
  %total_written.0 = phi i64 [ %add68, %if.end62 ], [ 0, %if.else71 ]
  store i64 %sub73.sink, i64* %skip_bytes, align 8, !tbaa !86
  %23 = ptrtoint i8* %1 to i64
  call void @free_pages(i64 %23, i32 1)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end74
  %inc94.sink = phi i32 [ %inc94, %for.inc ], [ 1, %if.end74 ]
  %chix.0 = phi i32 [ 1, %if.end74 ], [ %inc94, %for.inc ]
  %cnt.0 = phi i32 [ 0, %if.end74 ], [ %cnt.1, %for.inc ]
  %total_written.1 = phi i64 [ %total_written.0, %if.end74 ], [ %total_written.2, %for.inc ]
  %call95 = call %struct.usb_device* @usb_hub_find_child(%struct.usb_device* %usbdev, i32 %inc94.sink)
  %maxchild76 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usbdev, i32 0, i32 28
  %24 = load i32, i32* %maxchild76, align 8, !tbaa !111
  %cmp77 = icmp sle i32 %chix.0, %24
  br i1 %cmp77, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %tobool79 = icmp ne %struct.usb_device* %call95, null
  br i1 %tobool79, label %if.else81, label %for.inc

if.else81:                                        ; preds = %for.body
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call95, i32 0, i32 11
  call void @device_lock.876(%struct.device* %dev)
  %add82 = add nsw i32 %level, 1
  %inc = add nsw i32 %cnt.0, 1
  %call84 = call i64 @usb_device_dump(i8** %buffer, i64* %nbytes, i64* %skip_bytes, i64* %file_offset, %struct.usb_device* %call95, i32 %add82)
  %conv85 = trunc i64 %call84 to i32
  %dev86 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call95, i32 0, i32 11
  call void @device_unlock.877(%struct.device* %dev86)
  %cmp87 = icmp eq i32 %conv85, -14
  br i1 %cmp87, label %cleanup, label %if.end90

if.end90:                                         ; preds = %if.else81
  %conv91 = sext i32 %conv85 to i64
  %add92 = add nsw i64 %total_written.1, %conv91
  br label %for.inc

for.inc:                                          ; preds = %if.end90, %for.body
  %cnt.1 = phi i32 [ %inc, %if.end90 ], [ %cnt.0, %for.body ]
  %total_written.2 = phi i64 [ %add92, %if.end90 ], [ %total_written.1, %for.body ]
  %inc94 = add nsw i32 %chix.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.else81, %for.cond, %if.then61, %if.end3, %entry
  %retval.0 = phi i64 [ -14, %if.then61 ], [ 0, %entry ], [ -12, %if.end3 ], [ %total_written.1, %if.else81 ], [ %total_written.1, %for.cond ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock.877(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_desc(i8* %start, i8* %end, %struct.usb_device* %dev) #0 {
entry:
  %cmp = icmp ugt i8* %start, %end
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %call = call i8* @usb_dump_device_descriptor(i8* %start, i8* %end, %struct.usb_device_descriptor* %descriptor)
  %cmp1 = icmp ugt i8* %call, %end
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %call4 = call i8* @usb_dump_device_strings(i8* %call, i8* %end, %struct.usb_device* %dev)
  br label %for.cond

for.cond:                                         ; preds = %if.end11, %if.end3
  %i.0 = phi i32 [ 0, %if.end3 ], [ %inc, %if.end11 ]
  %start.addr.0 = phi i8* [ %call4, %if.end3 ], [ %call17, %if.end11 ]
  %descriptor5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor5, i32 0, i32 13
  %0 = load i8, i8* %bNumConfigurations, align 1, !tbaa !193
  %conv = zext i8 %0 to i32
  %cmp6 = icmp sge i32 %i.0, %conv
  %cmp8 = icmp ugt i8* %start.addr.0, %end
  %or.cond = or i1 %cmp6, %cmp8
  br i1 %or.cond, label %cleanup, label %if.end11

if.end11:                                         ; preds = %for.cond
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 4
  %1 = load i32, i32* %speed, align 4, !tbaa !177
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !194
  %idx.ext = sext i32 %i.0 to i64
  %add.ptr = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i64 %idx.ext
  %call17 = call i8* @usb_dump_config(i32 %1, i8* %start.addr.0, i8* %end, %struct.usb_host_config* %add.ptr)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %if.end, %entry
  %retval.0 = phi i8* [ %start, %entry ], [ %call, %if.end ], [ %start.addr.0, %for.cond ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @copy_user_overflow.888(i32 %size, i64 %count) #1 {
entry:
  %tobool = icmp ne i32 1, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.886, i32 0, i32 0), i32 688, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.35.889, i32 0, i32 0), i32 %size, i64 %count)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_device_descriptor(i8* %start, i8* %end, %struct.usb_device_descriptor* %desc) #0 {
entry:
  %cmp = icmp ugt i8* %start, %end
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %bDeviceClass5 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %desc, i32 0, i32 3
  %0 = load i8, i8* %bDeviceClass5, align 1, !tbaa !823
  %conv6 = zext i8 %0 to i32
  call void @class_decode(i32 %conv6)
  %1 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds i8, i8* %start, i64 %idx.ext
  %cmp12 = icmp ugt i8* %add.ptr, %end
  br i1 %cmp12, label %cleanup, label %if.end15

if.end15:                                         ; preds = %if.end
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext23 = sext i32 %2 to i64
  %add.ptr24 = getelementptr inbounds i8, i8* %add.ptr, i64 %idx.ext23
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.end, %entry
  %retval.0 = phi i8* [ %add.ptr24, %if.end15 ], [ %start, %entry ], [ %add.ptr, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_device_strings(i8* %start, i8* %end, %struct.usb_device* %dev) #0 {
entry:
  %cmp = icmp ugt i8* %start, %end
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %manufacturer = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 25
  %0 = load i8*, i8** %manufacturer, align 8, !tbaa !46
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then1, label %if.end3

if.then1:                                         ; preds = %if.end
  %1 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds i8, i8* %start, i64 %idx.ext
  br label %if.end3

if.end3:                                          ; preds = %if.then1, %if.end
  %start.addr.0 = phi i8* [ %add.ptr, %if.then1 ], [ %start, %if.end ]
  %cmp4 = icmp ugt i8* %start.addr.0, %end
  br i1 %cmp4, label %return, label %if.end6

if.end6:                                          ; preds = %if.end3
  %product = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 24
  %2 = load i8*, i8** %product, align 8, !tbaa !45
  %tobool7 = icmp ne i8* %2, null
  br i1 %tobool7, label %if.then8, label %if.end13

if.then8:                                         ; preds = %if.end6
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext11 = sext i32 %3 to i64
  %add.ptr12 = getelementptr inbounds i8, i8* %start.addr.0, i64 %idx.ext11
  br label %if.end13

if.end13:                                         ; preds = %if.then8, %if.end6
  %start.addr.1 = phi i8* [ %add.ptr12, %if.then8 ], [ %start.addr.0, %if.end6 ]
  %cmp14 = icmp ugt i8* %start.addr.1, %end
  br i1 %cmp14, label %return, label %if.end16

if.end16:                                         ; preds = %if.end13
  %serial = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 26
  %4 = load i8*, i8** %serial, align 8, !tbaa !47
  %tobool17 = icmp ne i8* %4, null
  br i1 %tobool17, label %if.then18, label %return

if.then18:                                        ; preds = %if.end16
  %5 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext21 = sext i32 %5 to i64
  %add.ptr22 = getelementptr inbounds i8, i8* %start.addr.1, i64 %idx.ext21
  br label %return

return:                                           ; preds = %if.then18, %if.end16, %if.end13, %if.end3, %entry
  %retval.0 = phi i8* [ %start, %entry ], [ %start.addr.0, %if.end3 ], [ %start.addr.1, %if.end13 ], [ %add.ptr22, %if.then18 ], [ %start.addr.1, %if.end16 ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_config(i32 %speed, i8* %start, i8* %end, %struct.usb_host_config* %config) #0 {
entry:
  %cmp = icmp ugt i8* %start, %end
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %tobool = icmp ne %struct.usb_host_config* %config, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext = sext i32 %0 to i64
  %add.ptr = getelementptr inbounds i8, i8* %start, i64 %idx.ext
  br label %cleanup

if.end2:                                          ; preds = %if.end
  %call3 = call i8* @usb_dump_config_descriptor(i8* %start, i8* %end)
  br label %for.cond

for.cond:                                         ; preds = %if.end7, %if.end2
  %i.0 = phi i32 [ 0, %if.end2 ], [ %inc, %if.end7 ]
  %start.addr.0 = phi i8* [ %call3, %if.end2 ], [ %call11, %if.end7 ]
  %cmp4 = icmp slt i32 %i.0, 16
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %intf_assoc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 2
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x %struct.usb_interface_assoc_descriptor*], [16 x %struct.usb_interface_assoc_descriptor*]* %intf_assoc, i64 0, i64 %idxprom
  %1 = load %struct.usb_interface_assoc_descriptor*, %struct.usb_interface_assoc_descriptor** %arrayidx, align 8, !tbaa !52
  %cmp5 = icmp eq %struct.usb_interface_assoc_descriptor* %1, null
  br i1 %cmp5, label %for.end, label %if.end7

if.end7:                                          ; preds = %for.body
  %intf_assoc8 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 2
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [16 x %struct.usb_interface_assoc_descriptor*], [16 x %struct.usb_interface_assoc_descriptor*]* %intf_assoc8, i64 0, i64 %idxprom9
  %2 = load %struct.usb_interface_assoc_descriptor*, %struct.usb_interface_assoc_descriptor** %arrayidx10, align 8, !tbaa !52
  %call11 = call i8* @usb_dump_iad_descriptor(i8* %start.addr.0, i8* %end, %struct.usb_interface_assoc_descriptor* %2)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  br label %for.cond12

for.cond12:                                       ; preds = %for.inc34, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc35, %for.inc34 ]
  %start.addr.1 = phi i8* [ %start.addr.0, %for.end ], [ %start.addr.2, %for.inc34 ]
  %desc13 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc13, i32 0, i32 3
  %3 = load i8, i8* %bNumInterfaces, align 4, !tbaa !103
  %conv = zext i8 %3 to i32
  %cmp14 = icmp slt i32 %i.1, %conv
  br i1 %cmp14, label %for.body16, label %cleanup

for.body16:                                       ; preds = %for.cond12
  %intf_cache = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 4
  %idxprom17 = sext i32 %i.1 to i64
  %arrayidx18 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache, i64 0, i64 %idxprom17
  %4 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx18, align 8, !tbaa !52
  %interface19 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 3
  %idxprom20 = sext i32 %i.1 to i64
  %arrayidx21 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface19, i64 0, i64 %idxprom20
  %5 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx21, align 8, !tbaa !52
  br label %for.cond22

for.cond22:                                       ; preds = %if.end29, %for.body16
  %j.0 = phi i32 [ 0, %for.body16 ], [ %inc32, %if.end29 ]
  %start.addr.2 = phi i8* [ %start.addr.1, %for.body16 ], [ %call30, %if.end29 ]
  %num_altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %4, i32 0, i32 0
  %6 = load i32, i32* %num_altsetting, align 8, !tbaa !107
  %cmp23 = icmp ult i32 %j.0, %6
  br i1 %cmp23, label %for.body25, label %for.inc34

for.body25:                                       ; preds = %for.cond22
  %cmp26 = icmp ugt i8* %start.addr.2, %end
  br i1 %cmp26, label %cleanup, label %if.end29

if.end29:                                         ; preds = %for.body25
  %call30 = call i8* @usb_dump_interface(i32 %speed, i8* %start.addr.2, i8* %end, %struct.usb_interface_cache* %4, %struct.usb_interface* %5, i32 %j.0)
  %inc32 = add nsw i32 %j.0, 1
  br label %for.cond22

for.inc34:                                        ; preds = %for.cond22
  %inc35 = add nsw i32 %i.1, 1
  br label %for.cond12

cleanup:                                          ; preds = %for.body25, %for.cond12, %if.then1, %entry
  %retval.0 = phi i8* [ %add.ptr, %if.then1 ], [ %start, %entry ], [ %start.addr.2, %for.body25 ], [ %start.addr.1, %for.cond12 ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_config_descriptor(i8* %start, i8* %end) #0 {
entry:
  %cmp = icmp ugt i8* %start, %end
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext = sext i32 %0 to i64
  %add.ptr = getelementptr inbounds i8, i8* %start, i64 %idx.ext
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i8* [ %add.ptr, %if.end ], [ %start, %entry ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_iad_descriptor(i8* %start, i8* %end, %struct.usb_interface_assoc_descriptor* %iad) #0 {
entry:
  %cmp = icmp ugt i8* %start, %end
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %bFunctionClass3 = getelementptr inbounds %struct.usb_interface_assoc_descriptor, %struct.usb_interface_assoc_descriptor* %iad, i32 0, i32 4
  %0 = load i8, i8* %bFunctionClass3, align 1, !tbaa !824
  %conv4 = zext i8 %0 to i32
  call void @class_decode(i32 %conv4)
  %1 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds i8, i8* %start, i64 %idx.ext
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i8* [ %add.ptr, %if.end ], [ %start, %entry ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_interface(i32 %speed, i8* %start, i8* %end, %struct.usb_interface_cache* %intfc, %struct.usb_interface* %iface, i32 %setno) #0 {
entry:
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intfc, i32 0, i32 2
  %idxprom = sext i32 %setno to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i64 0, i64 %idxprom
  %call = call i8* @usb_dump_interface_descriptor(i8* %start, i8* %end, %struct.usb_interface_cache* %intfc, %struct.usb_interface* %iface, i32 %setno)
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %if.end ]
  %start.addr.0 = phi i8* [ %call, %entry ], [ %call8, %if.end ]
  %desc1 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc1, i32 0, i32 4
  %0 = load i8, i8* %bNumEndpoints, align 4, !tbaa !172
  %conv = zext i8 %0 to i32
  %cmp = icmp sge i32 %i.0, %conv
  %cmp3 = icmp ugt i8* %start.addr.0, %end
  %or.cond = or i1 %cmp, %cmp3
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %for.cond
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 3
  %1 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !173
  %idxprom5 = sext i32 %i.0 to i64
  %arrayidx6 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %1, i64 %idxprom5
  %desc7 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx6, i32 0, i32 0
  %call8 = call i8* @usb_dump_endpoint_descriptor(i32 %speed, i8* %start.addr.0, i8* %end, %struct.usb_endpoint_descriptor* %desc7)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond
  ret i8* %start.addr.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_interface_descriptor(i8* %start, i8* %end, %struct.usb_interface_cache* %intfc, %struct.usb_interface* %iface, i32 %setno) #0 {
entry:
  %cmp = icmp ugt i8* %start, %end
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intfc, i32 0, i32 2
  %idxprom = sext i32 %setno to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i64 0, i64 %idxprom
  %desc1 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %tobool = icmp ne %struct.usb_interface* %iface, null
  br i1 %tobool, label %if.then2, label %if.end8

if.then2:                                         ; preds = %if.end
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !118
  %tobool3 = icmp ne %struct.device_driver* %0, null
  br i1 %tobool3, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.then2
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.then2
  br label %if.end8

if.end8:                                          ; preds = %cond.end, %if.end
  %bInterfaceClass15 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc1, i32 0, i32 5
  %1 = load i8, i8* %bInterfaceClass15, align 1, !tbaa !817
  %conv16 = zext i8 %1 to i32
  call void @class_decode(i32 %conv16)
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext = sext i32 %2 to i64
  %add.ptr = getelementptr inbounds i8, i8* %start, i64 %idx.ext
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %entry
  %retval.0 = phi i8* [ %add.ptr, %if.end8 ], [ %start, %entry ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_endpoint_descriptor(i32 %speed, i8* %start, i8* %end, %struct.usb_endpoint_descriptor* %desc) #0 {
entry:
  %cmp = icmp ugt i8* %start, %end
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @usb_endpoint_dir_in.891(%struct.usb_endpoint_descriptor* %desc)
  %tobool = icmp ne i32 %call, 0
  %cond = select i1 %tobool, i32 73, i32 79
  %conv = trunc i32 %cond to i8
  %cmp1 = icmp eq i32 %speed, 3
  br i1 %cmp1, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  call void @usb_endpoint_maxp_mult.892()
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %call6 = call i32 @usb_endpoint_type.893(%struct.usb_endpoint_descriptor* %desc)
  %Pivot6 = icmp slt i32 %call6, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %if.end5
  %Pivot4 = icmp slt i32 %call6, 3
  br i1 %Pivot4, label %sw.bb15, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %call6, 3
  br i1 %SwitchLeaf2, label %sw.bb26, label %cleanup

NodeBlock:                                        ; preds = %if.end5
  %Pivot = icmp slt i32 %call6, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb12

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %call6, 0
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %LeafBlock
  %cmp7 = icmp eq i32 %speed, 3
  br i1 %cmp7, label %if.then9, label %sw.epilog

if.then9:                                         ; preds = %sw.bb
  br label %sw.epilog

sw.bb12:                                          ; preds = %NodeBlock
  br label %sw.epilog

sw.bb15:                                          ; preds = %NodeBlock3
  %cmp16 = icmp eq i32 %speed, 3
  %conv18 = sext i8 %conv to i32
  %cmp19 = icmp eq i32 %conv18, 79
  %or.cond = and i1 %cmp16, %cmp19
  br i1 %or.cond, label %if.then21, label %sw.epilog

if.then21:                                        ; preds = %sw.bb15
  br label %sw.epilog

sw.bb26:                                          ; preds = %LeafBlock1
  %cmp27 = icmp eq i32 %speed, 3
  %cmp29 = icmp sge i32 %speed, 5
  %or.cond7 = or i1 %cmp27, %cmp29
  br i1 %or.cond7, label %if.then31, label %sw.epilog

if.then31:                                        ; preds = %sw.bb26
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then31, %sw.bb26, %if.then21, %sw.bb15, %sw.bb12, %if.then9, %sw.bb
  call void @usb_endpoint_maxp.898()
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext = sext i32 %0 to i64
  %add.ptr = getelementptr inbounds i8, i8* %start, i64 %idx.ext
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %LeafBlock, %LeafBlock1, %entry
  %retval.0 = phi i8* [ %add.ptr, %sw.epilog ], [ %start, %entry ], [ %start, %LeafBlock ], [ %start, %LeafBlock1 ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_dir_in.891(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !309
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 128
  %cmp = icmp eq i32 %and, 128
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_endpoint_maxp_mult.892() #1 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_type.893(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !332
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_endpoint_maxp.898() #1 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @class_decode(i32 %class) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %ix.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %idxprom = sext i32 %ix.0 to i64
  %arrayidx = getelementptr inbounds [18 x %struct.usbdevfs_disconnectsignal], [18 x %struct.usbdevfs_disconnectsignal]* @clas_info, i64 0, i64 %idxprom
  %class1 = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %arrayidx, i32 0, i32 0
  %0 = load i32, i32* %class1, align 16, !tbaa !825
  %cmp = icmp ne i32 %0, -1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom2 = sext i32 %ix.0 to i64
  %arrayidx3 = getelementptr inbounds [18 x %struct.usbdevfs_disconnectsignal], [18 x %struct.usbdevfs_disconnectsignal]* @clas_info, i64 0, i64 %idxprom2
  %class4 = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %arrayidx3, i32 0, i32 0
  %1 = load i32, i32* %class4, align 16, !tbaa !825
  %cmp5 = icmp eq i32 %1, %class
  br i1 %cmp5, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %ix.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define void @usbfs_conn_disc_event() #0 {
entry:
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; addl $1,$0", "=*m,ir,*m,~{dirflag},~{fpsr},~{flags}"(i32* getelementptr inbounds (%struct.ctl_table_poll, %struct.ctl_table_poll* @device_event, i64 0, i32 0, i32 0), i32 2, i32* getelementptr inbounds (%struct.ctl_table_poll, %struct.ctl_table_poll* @device_event, i64 0, i32 0, i32 0)) #8, !srcloc !827
  call void @__wake_up(%struct.__wait_queue_head* getelementptr inbounds (%struct.ctl_table_poll, %struct.ctl_table_poll* @device_event, i32 0, i32 1), i32 3, i32 1, i8* null)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usb_port_device_release(%struct.device.5257* %dev) #0 {
entry:
  %0 = bitcast %struct.device.5257* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -8
  %1 = bitcast i8* %add.ptr to %struct.usb_port.5576*
  %req = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 4
  %2 = load %struct.dev_pm_qos_request.5568*, %struct.dev_pm_qos_request.5568** %req, align 8, !tbaa !828
  %3 = bitcast %struct.dev_pm_qos_request.5568* %2 to i8*
  call void @kfree(i8* %3)
  %4 = bitcast %struct.usb_port.5576* %1 to i8*
  call void @kfree(i8* %4)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_port_runtime_suspend(%struct.device.5257* %dev) #0 {
entry:
  %0 = bitcast %struct.device.5257* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -8
  %1 = bitcast i8* %add.ptr to %struct.usb_port.5576*
  %parent = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev, i32 0, i32 0
  %2 = load %struct.device.5257*, %struct.device.5257** %parent, align 8, !tbaa !532
  %parent2 = getelementptr inbounds %struct.device.5257, %struct.device.5257* %2, i32 0, i32 0
  %3 = load %struct.device.5257*, %struct.device.5257** %parent2, align 8, !tbaa !532
  %4 = bitcast %struct.device.5257* %3 to i8*
  %add.ptr4 = getelementptr inbounds i8, i8* %4, i64 -152
  %5 = bitcast i8* %add.ptr4 to %struct.usb_device.5577*
  %parent6 = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev, i32 0, i32 0
  %6 = load %struct.device.5257*, %struct.device.5257** %parent6, align 8, !tbaa !532
  %7 = bitcast %struct.device.5257* %6 to i8*
  %add.ptr8 = getelementptr inbounds i8, i8* %7, i64 -48
  %8 = bitcast i8* %add.ptr8 to %struct.usb_interface.5601*
  %call = call %struct.usb_hub.5605* bitcast (%struct.usb_hub* (%struct.usb_device*)* @usb_hub_to_struct_hub to %struct.usb_hub.5605* (%struct.usb_device.5577*)*)(%struct.usb_device.5577* %5)
  %peer9 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 3
  %9 = load %struct.usb_port.5576*, %struct.usb_port.5576** %peer9, align 8, !tbaa !829
  %portnum = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 8
  %10 = load i8, i8* %portnum, align 8, !tbaa !203
  %conv = zext i8 %10 to i32
  %tobool = icmp ne %struct.usb_hub.5605* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %in_reset = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %call, i32 0, i32 20
  %bf.load = load i8, i8* %in_reset, align 8
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool11 = icmp ne i32 %bf.cast, 0
  br i1 %tobool11, label %cleanup, label %if.end13

if.end13:                                         ; preds = %if.end
  %dev14 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  %call15 = call i32 @dev_pm_qos_flags(%struct.device.5257* %dev14, i32 1)
  %cmp = icmp eq i32 %call15, 2
  br i1 %cmp, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end13
  %11 = load i32, i32* @usb_port_block_power_off, align 4, !tbaa !73
  %tobool19 = icmp ne i32 %11, 0
  br i1 %tobool19, label %cleanup, label %if.end21

if.end21:                                         ; preds = %if.end18
  %call22 = call i32 bitcast (i32 (%struct.usb_interface*)* @usb_autopm_get_interface to i32 (%struct.usb_interface.5601*)*)(%struct.usb_interface.5601* %8)
  %call23 = call i32 bitcast (i32 (%struct.usb_device*, %struct.usb_hub*, i32, i1)* @usb_hub_set_port_power to i32 (%struct.usb_device.5577*, %struct.usb_hub.5605*, i32, i1)*)(%struct.usb_device.5577* %5, %struct.usb_hub.5605* %call, i32 %conv, i1 zeroext false)
  %call24 = call i32 bitcast (i32 (%struct.usb_device*, i32, i32)* @usb_clear_port_feature to i32 (%struct.usb_device.5577*, i32, i32)*)(%struct.usb_device.5577* %5, i32 %conv, i32 16)
  %is_superspeed = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 9
  %bf.load25 = load i8, i8* %is_superspeed, align 1
  %bf.clear26 = and i8 %bf.load25, 1
  %bf.cast27 = zext i8 %bf.clear26 to i32
  %tobool28 = icmp ne i32 %bf.cast27, 0
  br i1 %tobool28, label %if.end31, label %if.then29

if.then29:                                        ; preds = %if.end21
  %call30 = call i32 bitcast (i32 (%struct.usb_device*, i32, i32)* @usb_clear_port_feature to i32 (%struct.usb_device.5577*, i32, i32)*)(%struct.usb_device.5577* %5, i32 %conv, i32 17)
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end21
  call void bitcast (void (%struct.usb_interface*)* @usb_autopm_put_interface to void (%struct.usb_interface.5601*)*)(%struct.usb_interface.5601* %8)
  %is_superspeed32 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 9
  %bf.load33 = load i8, i8* %is_superspeed32, align 1
  %bf.clear34 = and i8 %bf.load33, 1
  %bf.cast35 = zext i8 %bf.clear34 to i32
  %tobool36 = icmp eq i32 %bf.cast35, 0
  %tobool37 = icmp ne %struct.usb_port.5576* %9, null
  %or.cond = and i1 %tobool36, %tobool37
  br i1 %or.cond, label %if.then38, label %cleanup

if.then38:                                        ; preds = %if.end31
  %dev39 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %9, i32 0, i32 1
  call void @pm_runtime_put.930(%struct.device.5257* %dev39)
  br label %cleanup

cleanup:                                          ; preds = %if.then38, %if.end31, %if.end18, %if.end13, %if.end, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -16, %if.end ], [ -11, %if.end13 ], [ -16, %if.end18 ], [ %call23, %if.end31 ], [ %call23, %if.then38 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_port_runtime_resume(%struct.device.5257* %dev) #0 {
entry:
  %c.i = alloca i8, align 1
  %0 = bitcast %struct.device.5257* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -8
  %1 = bitcast i8* %add.ptr to %struct.usb_port.5576*
  %parent = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev, i32 0, i32 0
  %2 = load %struct.device.5257*, %struct.device.5257** %parent, align 8, !tbaa !532
  %parent2 = getelementptr inbounds %struct.device.5257, %struct.device.5257* %2, i32 0, i32 0
  %3 = load %struct.device.5257*, %struct.device.5257** %parent2, align 8, !tbaa !532
  %4 = bitcast %struct.device.5257* %3 to i8*
  %add.ptr4 = getelementptr inbounds i8, i8* %4, i64 -152
  %5 = bitcast i8* %add.ptr4 to %struct.usb_device.5577*
  %parent6 = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev, i32 0, i32 0
  %6 = load %struct.device.5257*, %struct.device.5257** %parent6, align 8, !tbaa !532
  %7 = bitcast %struct.device.5257* %6 to i8*
  %add.ptr8 = getelementptr inbounds i8, i8* %7, i64 -48
  %8 = bitcast i8* %add.ptr8 to %struct.usb_interface.5601*
  %call = call %struct.usb_hub.5605* bitcast (%struct.usb_hub* (%struct.usb_device*)* @usb_hub_to_struct_hub to %struct.usb_hub.5605* (%struct.usb_device.5577*)*)(%struct.usb_device.5577* %5)
  %child = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 0
  %9 = load %struct.usb_device.5577*, %struct.usb_device.5577** %child, align 8, !tbaa !115
  %peer9 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 3
  %10 = load %struct.usb_port.5576*, %struct.usb_port.5576** %peer9, align 8, !tbaa !829
  %portnum = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 8
  %11 = load i8, i8* %portnum, align 8, !tbaa !203
  %conv = zext i8 %11 to i32
  %tobool = icmp ne %struct.usb_hub.5605* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %in_reset = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %call, i32 0, i32 20
  %bf.load = load i8, i8* %in_reset, align 8
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool11 = icmp ne i32 %bf.cast, 0
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end
  %conv13 = sext i32 %conv to i64
  %power_bits = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %call, i32 0, i32 13
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %power_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i64 %conv13, i64* %arraydecay) #8, !srcloc !830
  br label %cleanup

if.end14:                                         ; preds = %if.end
  %is_superspeed = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 9
  %bf.load15 = load i8, i8* %is_superspeed, align 1
  %bf.clear16 = and i8 %bf.load15, 1
  %bf.cast17 = zext i8 %bf.clear16 to i32
  %tobool18 = icmp eq i32 %bf.cast17, 0
  %tobool19 = icmp ne %struct.usb_port.5576* %10, null
  %or.cond = and i1 %tobool18, %tobool19
  br i1 %or.cond, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end14
  %dev21 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %10, i32 0, i32 1
  call void @pm_runtime_get_sync.921(%struct.device.5257* %dev21)
  br label %if.end23

if.end23:                                         ; preds = %if.then20, %if.end14
  %call24 = call i32 bitcast (i32 (%struct.usb_interface*)* @usb_autopm_get_interface to i32 (%struct.usb_interface.5601*)*)(%struct.usb_interface.5601* %8)
  %call25 = call i32 bitcast (i32 (%struct.usb_device*, %struct.usb_hub*, i32, i1)* @usb_hub_set_port_power to i32 (%struct.usb_device.5577*, %struct.usb_hub.5605*, i32, i1)*)(%struct.usb_device.5577* %5, %struct.usb_hub.5605* %call, i32 %conv, i1 zeroext true)
  %call26 = call i32 @hub_power_on_good_delay.922(%struct.usb_hub.5605* %call)
  call void @msleep(i32 %call26)
  %tobool27 = icmp eq %struct.usb_device.5577* %9, null
  %tobool29 = icmp ne i32 %call25, 0
  %or.cond1 = or i1 %tobool27, %tobool29
  br i1 %or.cond1, label %if.end62, label %if.then30

if.then30:                                        ; preds = %if.end23
  %call31 = call i32 @hub_port_debounce_be_connected(%struct.usb_hub.5605* %call, i32 %conv)
  %cmp = icmp slt i32 %call31, 0
  br i1 %cmp, label %do.body34, label %if.end53

do.body34:                                        ; preds = %if.then30
  %bf.load35 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_runtime_resume.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr36 = lshr i32 %bf.load35, 18
  %bf.clear37 = and i32 %bf.lshr36, 255
  %and = and i32 %bf.clear37, 1
  %tobool38 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool38, true
  %lnot39 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot39 to i32
  %conv40 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv40, i64 0)
  %tobool41 = icmp ne i64 %expval, 0
  br i1 %tobool41, label %if.then42, label %do.end46

if.then42:                                        ; preds = %do.body34
  %dev43 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  call void (%struct._ddebug*, %struct.device.5257*, i8*, ...) bitcast (void (%struct._ddebug*, %struct.device*, i8*, ...)* @__dynamic_dev_dbg to void (%struct._ddebug*, %struct.device.5257*, i8*, ...)*)(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_runtime_resume.descriptor to %struct._ddebug*), %struct.device.5257* %dev43, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.6.923, i32 0, i32 0))
  br label %do.end46

do.end46:                                         ; preds = %if.then42, %do.body34
  %call47 = call i32 @hub_is_superspeed.924(%struct.usb_device.5577* %5)
  %tobool48 = icmp ne i32 %call47, 0
  br i1 %tobool48, label %if.then49, label %if.end53

if.then49:                                        ; preds = %do.end46
  %conv50 = sext i32 %conv to i64
  %warm_reset_bits = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %call, i32 0, i32 15
  %arraydecay51 = getelementptr inbounds [1 x i64], [1 x i64]* %warm_reset_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay51, i64 %conv50, i64* %arraydecay51) #8, !srcloc !830
  br label %if.end53

if.end53:                                         ; preds = %if.then49, %do.end46, %if.then30
  %conv54 = sext i32 %conv to i64
  %child_usage_bits = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %call, i32 0, i32 14
  %arraydecay55 = getelementptr inbounds [1 x i64], [1 x i64]* %child_usage_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $2, $0;\0A\09setc $1\0A", "=*m,=*qm,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay55, i8* %c.i, i64 %conv54, i64* %arraydecay55) #8, !srcloc !831
  %12 = load i8, i8* %c.i, align 1, !tbaa !109, !range !110
  %tobool.i = trunc i8 %12 to i1
  br i1 %tobool.i, label %if.end62, label %if.then57

if.then57:                                        ; preds = %if.end53
  %dev58 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  call void @pm_runtime_get_noresume.926(%struct.device.5257* %dev58)
  %dev59 = getelementptr inbounds %struct.usb_device.5577, %struct.usb_device.5577* %9, i32 0, i32 11
  call void @pm_request_resume(%struct.device.5257* %dev59)
  br label %if.end62

if.end62:                                         ; preds = %if.then57, %if.end53, %if.end23
  call void bitcast (void (%struct.usb_interface*)* @usb_autopm_put_interface to void (%struct.usb_interface.5601*)*)(%struct.usb_interface.5601* %8)
  br label %cleanup

cleanup:                                          ; preds = %if.end62, %if.then12, %entry
  %retval.0 = phi i32 [ 0, %if.then12 ], [ %call25, %if.end62 ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_get_sync.921(%struct.device.5257* %dev) #1 {
entry:
  %call = call i32 bitcast (i32 (%struct.device*, i32)* @__pm_runtime_resume to i32 (%struct.device.5257*, i32)*)(%struct.device.5257* %dev, i32 4)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hub_power_on_good_delay.922(%struct.usb_hub.5605* %hub) #1 {
entry:
  %__UNIQUE_ID_max1_12 = alloca i32, align 4
  %__UNIQUE_ID_max2_13 = alloca i32, align 4
  %descriptor = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %hub, i32 0, i32 16
  %0 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !232
  %bPwrOn2PwrGood = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %0, i32 0, i32 4
  %1 = load i8, i8* %bPwrOn2PwrGood, align 1, !tbaa !298
  %conv = zext i8 %1 to i32
  %mul = mul nsw i32 %conv, 2
  store i32 %mul, i32* %__UNIQUE_ID_max1_12, align 4, !tbaa !73
  store i32 100, i32* %__UNIQUE_ID_max2_13, align 4, !tbaa !73
  %2 = load i32, i32* %__UNIQUE_ID_max1_12, align 4, !tbaa !73
  %3 = load i32, i32* %__UNIQUE_ID_max2_13, align 4, !tbaa !73
  %cmp2 = icmp ugt i32 %2, %3
  %4 = load i32, i32* %__UNIQUE_ID_max1_12, align 4
  %5 = load i32, i32* %__UNIQUE_ID_max2_13, align 4
  %cond = select i1 %cmp2, i32 %4, i32 %5
  ret i32 %cond
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hub_port_debounce_be_connected(%struct.usb_hub.5605* %hub, i32 %port1) #1 {
entry:
  %call = call i32 bitcast (i32 (%struct.usb_hub*, i32, i1)* @hub_port_debounce to i32 (%struct.usb_hub.5605*, i32, i1)*)(%struct.usb_hub.5605* %hub, i32 %port1, i1 zeroext true)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hub_is_superspeed.924(%struct.usb_device.5577* %hdev) #1 {
entry:
  %descriptor = getelementptr inbounds %struct.usb_device.5577, %struct.usb_device.5577* %hdev, i32 0, i32 12
  %bDeviceProtocol = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 5
  %0 = load i8, i8* %bDeviceProtocol, align 2, !tbaa !205
  %conv = zext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 3
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_get_noresume.926(%struct.device.5257* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev, i32 0, i32 11
  %usage_count = getelementptr inbounds %struct.dev_pm_info.5265, %struct.dev_pm_info.5265* %power, i32 0, i32 12
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %usage_count, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !832
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_request_resume(%struct.device.5257* %dev) #1 {
entry:
  %call = call i32 bitcast (i32 (%struct.device*, i32)* @__pm_runtime_resume to i32 (%struct.device.5257*, i32)*)(%struct.device.5257* %dev, i32 1)
  ret void
}

declare i32 @dev_pm_qos_flags(%struct.device.5257*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put.930(%struct.device.5257* %dev) #1 {
entry:
  %call = call i32 bitcast (i32 (%struct.device*, i32)* @__pm_runtime_idle to i32 (%struct.device.5257*, i32)*)(%struct.device.5257* %dev, i32 5)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_hub_create_port_device(%struct.usb_hub.5605* %hub, i32 %port1) #0 {
entry:
  %hdev1 = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %hub, i32 0, i32 1
  %0 = load %struct.usb_device.5577*, %struct.usb_device.5577** %hdev1, align 8, !tbaa !176
  %call = call i8* @kzalloc.933(i64 1632, i32 20971712)
  %1 = bitcast i8* %call to %struct.usb_port.5576*
  %tobool = icmp ne %struct.usb_port.5576* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call3 = call i8* @kzalloc.933(i64 56, i32 20971712)
  %2 = bitcast i8* %call3 to %struct.dev_pm_qos_request.5568*
  %req = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 4
  store %struct.dev_pm_qos_request.5568* %2, %struct.dev_pm_qos_request.5568** %req, align 8, !tbaa !828
  %req4 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 4
  %3 = load %struct.dev_pm_qos_request.5568*, %struct.dev_pm_qos_request.5568** %req4, align 8, !tbaa !828
  %tobool5 = icmp ne %struct.dev_pm_qos_request.5568* %3, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  %4 = bitcast %struct.usb_port.5576* %1 to i8*
  call void @kfree(i8* %4)
  br label %cleanup

if.end7:                                          ; preds = %if.end
  %ports = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %hub, i32 0, i32 25
  %5 = load %struct.usb_port.5576**, %struct.usb_port.5576*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port.5576*, %struct.usb_port.5576** %5, i64 %idxprom
  store %struct.usb_port.5576* %1, %struct.usb_port.5576** %arrayidx, align 8, !tbaa !52
  %conv = trunc i32 %port1 to i8
  %portnum = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 8
  store i8 %conv, i8* %portnum, align 8, !tbaa !203
  %conv8 = sext i32 %port1 to i64
  %power_bits = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %hub, i32 0, i32 13
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %power_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i64 %conv8, i64* %arraydecay) #8, !srcloc !830
  %intfdev = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %hub, i32 0, i32 0
  %6 = load %struct.device.5257*, %struct.device.5257** %intfdev, align 8, !tbaa !204
  %dev = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  %parent = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev, i32 0, i32 0
  store %struct.device.5257* %6, %struct.device.5257** %parent, align 8, !tbaa !833
  %call9 = call i32 @hub_is_superspeed.924(%struct.usb_device.5577* %0)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then11, label %if.end18

if.then11:                                        ; preds = %if.end7
  %usb3_lpm_u1_permit = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 9
  %bf.load = load i8, i8* %usb3_lpm_u1_permit, align 1
  %bf.clear = and i8 %bf.load, -3
  %bf.set = or i8 %bf.clear, 2
  store i8 %bf.set, i8* %usb3_lpm_u1_permit, align 1
  %usb3_lpm_u2_permit = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 9
  %bf.load12 = load i8, i8* %usb3_lpm_u2_permit, align 1
  %bf.clear13 = and i8 %bf.load12, -5
  %bf.set14 = or i8 %bf.clear13, 4
  store i8 %bf.set14, i8* %usb3_lpm_u2_permit, align 1
  br label %if.end18

if.end18:                                         ; preds = %if.then11, %if.end7
  %.sink = phi %struct.attribute_group** [ getelementptr inbounds ([3 x %struct.attribute_group*], [3 x %struct.attribute_group*]* @port_dev_usb3_group, i32 0, i32 0), %if.then11 ], [ getelementptr inbounds ([2 x %struct.attribute_group*], [2 x %struct.attribute_group*]* @port_dev_group, i32 0, i32 0), %if.end7 ]
  %dev16 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  %groups17 = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev16, i32 0, i32 34
  store %struct.attribute_group** %.sink, %struct.attribute_group*** %groups17, align 8, !tbaa !834
  %dev19 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  %type = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev19, i32 0, i32 4
  store %struct.device_type.5260* bitcast ({ i8*, %struct.attribute_group**, i32 (%struct.device.5257*, %struct.kobj_uevent_env*)*, i8* (%struct.device.5257*, i16*, %struct.atomic_t*, %struct.atomic_t*)*, void (%struct.device.5257*)*, %struct.dev_pm_ops.5256* }* @usb_port_device_type to %struct.device_type.5260*), %struct.device_type.5260** %type, align 8, !tbaa !835
  %dev20 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  %driver = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev20, i32 0, i32 7
  store %struct.device_driver.5263* @usb_port_driver, %struct.device_driver.5263** %driver, align 8, !tbaa !836
  %hdev21 = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %hub, i32 0, i32 1
  %7 = load %struct.usb_device.5577*, %struct.usb_device.5577** %hdev21, align 8, !tbaa !176
  %call22 = call i32 @hub_is_superspeed.924(%struct.usb_device.5577* %7)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.then24, label %if.end28

if.then24:                                        ; preds = %if.end18
  %is_superspeed = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 9
  %bf.load25 = load i8, i8* %is_superspeed, align 1
  %bf.clear26 = and i8 %bf.load25, -2
  %bf.set27 = or i8 %bf.clear26, 1
  store i8 %bf.set27, i8* %is_superspeed, align 1
  br label %if.end28

if.end28:                                         ; preds = %if.then24, %if.end18
  %dev29 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  %hdev30 = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %hub, i32 0, i32 1
  %8 = load %struct.usb_device.5577*, %struct.usb_device.5577** %hdev30, align 8, !tbaa !176
  %dev31 = getelementptr inbounds %struct.usb_device.5577, %struct.usb_device.5577* %8, i32 0, i32 11
  %call32 = call i8* @dev_name.934(%struct.device.5257* %dev31)
  %call33 = call i32 (%struct.device.5257*, i8*, ...) bitcast (i32 (%struct.device*, i8*, ...)* @dev_set_name to i32 (%struct.device.5257*, i8*, ...)*)(%struct.device.5257* %dev29, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1.935, i32 0, i32 0), i8* %call32, i32 %port1)
  %status_lock = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 7
  call void @__mutex_init(%struct.mutex* %status_lock, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.2.936, i32 0, i32 0), %struct.lock_class_key* @usb_hub_create_port_device.__key)
  %dev34 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  %call35 = call i32 bitcast (i32 (%struct.device.3441*)* @device_register to i32 (%struct.device.5257*)*)(%struct.device.5257* %dev34)
  %tobool36 = icmp ne i32 %call35, 0
  %dev38 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  br i1 %tobool36, label %if.then37, label %if.end39

if.then37:                                        ; preds = %if.end28
  call void bitcast (void (%struct.device*)* @put_device to void (%struct.device.5257*)*)(%struct.device.5257* %dev38)
  br label %cleanup

if.end39:                                         ; preds = %if.end28
  %req41 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 4
  %9 = load %struct.dev_pm_qos_request.5568*, %struct.dev_pm_qos_request.5568** %req41, align 8, !tbaa !828
  %call42 = call i32 @dev_pm_qos_add_request(%struct.device.5257* %dev38, %struct.dev_pm_qos_request.5568* %9, i32 3, i32 1)
  %cmp = icmp slt i32 %call42, 0
  br i1 %cmp, label %if.then44, label %if.end46

if.then44:                                        ; preds = %if.end39
  %dev45 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  call void bitcast (void (%struct.device.3441*)* @device_unregister to void (%struct.device.5257*)*)(%struct.device.5257* %dev45)
  br label %cleanup

if.end46:                                         ; preds = %if.end39
  call void @find_and_link_peer(%struct.usb_hub.5605* %hub, i32 %port1)
  %dev47 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  call void @pm_runtime_set_active.937(%struct.device.5257* %dev47)
  %dev49 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  call void @pm_runtime_get_noresume.926(%struct.device.5257* %dev49)
  %dev50 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  call void bitcast (void (%struct.device*)* @pm_runtime_enable to void (%struct.device.5257*)*)(%struct.device.5257* %dev50)
  %dev51 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  call void @device_enable_async_suspend.938(%struct.device.5257* %dev51)
  %call52 = call zeroext i1 @hub_is_port_power_switchable.939(%struct.usb_hub.5605* %hub)
  br i1 %call52, label %if.end54, label %cleanup

if.end54:                                         ; preds = %if.end46
  %dev55 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  %call56 = call i32 @dev_pm_qos_expose_flags(%struct.device.5257* %dev55, i32 1)
  %cmp57 = icmp slt i32 %call56, 0
  br i1 %cmp57, label %if.then59, label %if.end61

if.then59:                                        ; preds = %if.end54
  %dev60 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  call void (%struct.device.5257*, i8*, ...) bitcast (void (%struct.device*, i8*, ...)* @dev_warn to void (%struct.device.5257*, i8*, ...)*)(%struct.device.5257* %dev60, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.3.940, i32 0, i32 0))
  br label %cleanup

if.end61:                                         ; preds = %if.end54
  %req62 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 4
  %10 = load %struct.dev_pm_qos_request.5568*, %struct.dev_pm_qos_request.5568** %req62, align 8, !tbaa !828
  %call63 = call i32 @dev_pm_qos_remove_request(%struct.dev_pm_qos_request.5568* %10)
  %cmp64 = icmp sge i32 %call63, 0
  br i1 %cmp64, label %if.then66, label %cleanup

if.then66:                                        ; preds = %if.end61
  %req67 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 4
  %11 = load %struct.dev_pm_qos_request.5568*, %struct.dev_pm_qos_request.5568** %req67, align 8, !tbaa !828
  %12 = bitcast %struct.dev_pm_qos_request.5568* %11 to i8*
  call void @kfree(i8* %12)
  %req68 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 4
  store %struct.dev_pm_qos_request.5568* null, %struct.dev_pm_qos_request.5568** %req68, align 8, !tbaa !828
  br label %cleanup

cleanup:                                          ; preds = %if.then66, %if.end61, %if.then59, %if.end46, %if.then44, %if.then37, %if.then6, %entry
  %retval.0 = phi i32 [ %call35, %if.then37 ], [ %call42, %if.then44 ], [ 0, %if.then59 ], [ -12, %if.then6 ], [ -12, %entry ], [ 0, %if.end46 ], [ 0, %if.then66 ], [ 0, %if.end61 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.933(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call noalias i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name.934(%struct.device.5257* %dev) #1 {
entry:
  %init_name = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !299
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !299
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev, i32 0, i32 2
  %call = call i8* @kobject_name.950(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

declare i32 @dev_pm_qos_add_request(%struct.device.5257*, %struct.dev_pm_qos_request.5568*, i32, i32) #2

; Function Attrs: nounwind uwtable
define internal void @find_and_link_peer(%struct.usb_hub.5605* %hub, i32 %port1) #0 {
entry:
  %ports = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %hub, i32 0, i32 25
  %0 = load %struct.usb_port.5576**, %struct.usb_port.5576*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port.5576*, %struct.usb_port.5576** %0, i64 %idxprom
  %1 = load %struct.usb_port.5576*, %struct.usb_port.5576** %arrayidx, align 8, !tbaa !52
  %hdev1 = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %hub, i32 0, i32 1
  %2 = load %struct.usb_device.5577*, %struct.usb_device.5577** %hdev1, align 8, !tbaa !176
  %location = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 6
  %3 = load i32, i32* %location, align 4, !tbaa !837
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = bitcast %struct.usb_port.5576* %1 to i8*
  %call = call i32 bitcast (i32 (i8*, i32 (%struct.usb_device*, i8*)*)* @usb_for_each_dev to i32 (i8*, i32 (%struct.usb_device.5577*, i8*)*)*)(i8* %4, i32 (%struct.usb_device.5577*, i8*)* @match_location)
  br label %cleanup.cont54

if.else:                                          ; preds = %entry
  %parent = getelementptr inbounds %struct.usb_device.5577, %struct.usb_device.5577* %2, i32 0, i32 8
  %5 = load %struct.usb_device.5577*, %struct.usb_device.5577** %parent, align 8, !tbaa !79
  %tobool2 = icmp ne %struct.usb_device.5577* %5, null
  br i1 %tobool2, label %if.else8, label %if.then3

if.then3:                                         ; preds = %if.else
  %bus = getelementptr inbounds %struct.usb_device.5577, %struct.usb_device.5577* %2, i32 0, i32 9
  %6 = load %struct.usb_bus.5580*, %struct.usb_bus.5580** %bus, align 8, !tbaa !2
  %call4 = call %struct.usb_hcd.5612* @bus_to_hcd.941(%struct.usb_bus.5580* %6)
  %shared_hcd = getelementptr inbounds %struct.usb_hcd.5612, %struct.usb_hcd.5612* %call4, i32 0, i32 22
  %7 = load %struct.usb_hcd.5612*, %struct.usb_hcd.5612** %shared_hcd, align 8, !tbaa !408
  %tobool5 = icmp ne %struct.usb_hcd.5612* %7, null
  br i1 %tobool5, label %if.end, label %LeafBlock

if.end:                                           ; preds = %if.then3
  %self = getelementptr inbounds %struct.usb_hcd.5612, %struct.usb_hcd.5612* %7, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus.5580, %struct.usb_bus.5580* %self, i32 0, i32 11
  %8 = load %struct.usb_device.5577*, %struct.usb_device.5577** %root_hub, align 8, !tbaa !175
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end, %if.then3
  %peer_hdev.0 = phi %struct.usb_device.5577* [ %8, %if.end ], [ undef, %if.then3 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end ], [ 1, %if.then3 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end31, label %cleanup.cont54

if.else8:                                         ; preds = %if.else
  %parent10 = getelementptr inbounds %struct.usb_device.5577, %struct.usb_device.5577* %2, i32 0, i32 8
  %9 = load %struct.usb_device.5577*, %struct.usb_device.5577** %parent10, align 8, !tbaa !79
  %call11 = call %struct.usb_hub.5605* bitcast (%struct.usb_hub* (%struct.usb_device*)* @usb_hub_to_struct_hub to %struct.usb_hub.5605* (%struct.usb_device.5577*)*)(%struct.usb_device.5577* %9)
  %tobool12 = icmp ne %struct.usb_hub.5605* %call11, null
  br i1 %tobool12, label %if.end14, label %LeafBlock2

if.end14:                                         ; preds = %if.else8
  %ports15 = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %call11, i32 0, i32 25
  %10 = load %struct.usb_port.5576**, %struct.usb_port.5576*** %ports15, align 8, !tbaa !112
  %portnum = getelementptr inbounds %struct.usb_device.5577, %struct.usb_device.5577* %2, i32 0, i32 20
  %11 = load i8, i8* %portnum, align 2, !tbaa !81
  %conv = zext i8 %11 to i32
  %sub16 = sub nsw i32 %conv, 1
  %idxprom17 = sext i32 %sub16 to i64
  %arrayidx18 = getelementptr inbounds %struct.usb_port.5576*, %struct.usb_port.5576** %10, i64 %idxprom17
  %12 = load %struct.usb_port.5576*, %struct.usb_port.5576** %arrayidx18, align 8, !tbaa !52
  %tobool19 = icmp ne %struct.usb_port.5576* %12, null
  br i1 %tobool19, label %lor.lhs.false, label %LeafBlock2

lor.lhs.false:                                    ; preds = %if.end14
  %peer20 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %12, i32 0, i32 3
  %13 = load %struct.usb_port.5576*, %struct.usb_port.5576** %peer20, align 8, !tbaa !829
  %tobool21 = icmp ne %struct.usb_port.5576* %13, null
  br i1 %tobool21, label %if.end23, label %LeafBlock2

if.end23:                                         ; preds = %lor.lhs.false
  %peer24 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %12, i32 0, i32 3
  %14 = load %struct.usb_port.5576*, %struct.usb_port.5576** %peer24, align 8, !tbaa !829
  %child = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %14, i32 0, i32 0
  %15 = load %struct.usb_device.5577*, %struct.usb_device.5577** %child, align 8, !tbaa !115
  br label %LeafBlock2

LeafBlock2:                                       ; preds = %if.end23, %lor.lhs.false, %if.end14, %if.else8
  %peer_hdev.1 = phi %struct.usb_device.5577* [ %15, %if.end23 ], [ undef, %if.else8 ], [ undef, %lor.lhs.false ], [ undef, %if.end14 ]
  %cleanup.dest.slot.1 = phi i32 [ 0, %if.end23 ], [ 1, %if.else8 ], [ 1, %lor.lhs.false ], [ 1, %if.end14 ]
  %SwitchLeaf3 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf3, label %if.end31, label %cleanup.cont54

if.end31:                                         ; preds = %LeafBlock2, %LeafBlock
  %peer_hdev.2 = phi %struct.usb_device.5577* [ %peer_hdev.0, %LeafBlock ], [ %peer_hdev.1, %LeafBlock2 ]
  %call32 = call %struct.usb_hub.5605* bitcast (%struct.usb_hub* (%struct.usb_device*)* @usb_hub_to_struct_hub to %struct.usb_hub.5605* (%struct.usb_device.5577*)*)(%struct.usb_device.5577* %peer_hdev.2)
  %tobool33 = icmp ne %struct.usb_hub.5605* %call32, null
  br i1 %tobool33, label %lor.lhs.false34, label %cleanup.cont54

lor.lhs.false34:                                  ; preds = %if.end31
  %maxchild = getelementptr inbounds %struct.usb_device.5577, %struct.usb_device.5577* %peer_hdev.2, i32 0, i32 28
  %16 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp = icmp sgt i32 %port1, %16
  br i1 %cmp, label %cleanup.cont54, label %if.end37

if.end37:                                         ; preds = %lor.lhs.false34
  %ports38 = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %call32, i32 0, i32 25
  %17 = load %struct.usb_port.5576**, %struct.usb_port.5576*** %ports38, align 8, !tbaa !112
  %sub39 = sub nsw i32 %port1, 1
  %idxprom40 = sext i32 %sub39 to i64
  %arrayidx41 = getelementptr inbounds %struct.usb_port.5576*, %struct.usb_port.5576** %17, i64 %idxprom40
  %18 = load %struct.usb_port.5576*, %struct.usb_port.5576** %arrayidx41, align 8, !tbaa !52
  %tobool42 = icmp ne %struct.usb_port.5576* %18, null
  br i1 %tobool42, label %land.lhs.true, label %cleanup.cont54

land.lhs.true:                                    ; preds = %if.end37
  %location43 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %18, i32 0, i32 6
  %19 = load i32, i32* %location43, align 4, !tbaa !837
  %cmp44 = icmp eq i32 %19, 0
  br i1 %cmp44, label %if.then46, label %cleanup.cont54

if.then46:                                        ; preds = %land.lhs.true
  call void @link_peers_report(%struct.usb_port.5576* %1, %struct.usb_port.5576* %18)
  br label %cleanup.cont54

cleanup.cont54:                                   ; preds = %if.then46, %land.lhs.true, %if.end37, %lor.lhs.false34, %if.end31, %LeafBlock2, %LeafBlock, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_set_active.937(%struct.device.5257* %dev) #1 {
entry:
  %call = call i32 bitcast (i32 (%struct.device*, i32)* @__pm_runtime_set_status to i32 (%struct.device.5257*, i32)*)(%struct.device.5257* %dev, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_enable_async_suspend.938(%struct.device.5257* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev, i32 0, i32 11
  %is_prepared = getelementptr inbounds %struct.dev_pm_info.5265, %struct.dev_pm_info.5265* %power, i32 0, i32 1
  %bf.load = load i16, i16* %is_prepared, align 4
  %bf.lshr = lshr i16 %bf.load, 3
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = trunc i16 %bf.clear to i1
  br i1 %bf.cast, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %power1 = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev, i32 0, i32 11
  %async_suspend = getelementptr inbounds %struct.dev_pm_info.5265, %struct.dev_pm_info.5265* %power1, i32 0, i32 1
  %bf.load2 = load i16, i16* %async_suspend, align 4
  %bf.clear3 = and i16 %bf.load2, -3
  %bf.set = or i16 %bf.clear3, 2
  store i16 %bf.set, i16* %async_suspend, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @hub_is_port_power_switchable.939(%struct.usb_hub.5605* %hub) #1 {
entry:
  %tobool = icmp ne %struct.usb_hub.5605* %hub, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %descriptor = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %hub, i32 0, i32 16
  %0 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !232
  %wHubCharacteristics = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %0, i32 0, i32 3
  %1 = load i16, i16* %wHubCharacteristics, align 1, !tbaa !262
  %conv = zext i16 %1 to i32
  %and = and i32 %conv, 3
  %cmp = icmp slt i32 %and, 2
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i1 [ %cmp, %if.end ], [ false, %entry ]
  ret i1 %retval.0
}

declare i32 @dev_pm_qos_expose_flags(%struct.device.5257*, i32) #2

declare i32 @dev_pm_qos_remove_request(%struct.dev_pm_qos_request.5568*) #2

; Function Attrs: nounwind uwtable
define internal i32 @match_location(%struct.usb_device.5577* %peer_hdev, i8* %p) #0 {
entry:
  %0 = bitcast i8* %p to %struct.usb_port.5576*
  %call = call %struct.usb_hub.5605* bitcast (%struct.usb_hub* (%struct.usb_device*)* @usb_hub_to_struct_hub to %struct.usb_hub.5605* (%struct.usb_device.5577*)*)(%struct.usb_device.5577* %peer_hdev)
  %dev = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %0, i32 0, i32 1
  %parent = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev, i32 0, i32 0
  %1 = load %struct.device.5257*, %struct.device.5257** %parent, align 8, !tbaa !833
  %parent1 = getelementptr inbounds %struct.device.5257, %struct.device.5257* %1, i32 0, i32 0
  %2 = load %struct.device.5257*, %struct.device.5257** %parent1, align 8, !tbaa !532
  %3 = bitcast %struct.device.5257* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -152
  %4 = bitcast i8* %add.ptr to %struct.usb_device.5577*
  %tobool = icmp ne %struct.usb_hub.5605* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %bus = getelementptr inbounds %struct.usb_device.5577, %struct.usb_device.5577* %4, i32 0, i32 9
  %5 = load %struct.usb_bus.5580*, %struct.usb_bus.5580** %bus, align 8, !tbaa !2
  %call2 = call %struct.usb_hcd.5612* @bus_to_hcd.941(%struct.usb_bus.5580* %5)
  %bus3 = getelementptr inbounds %struct.usb_device.5577, %struct.usb_device.5577* %peer_hdev, i32 0, i32 9
  %6 = load %struct.usb_bus.5580*, %struct.usb_bus.5580** %bus3, align 8, !tbaa !2
  %call4 = call %struct.usb_hcd.5612* @bus_to_hcd.941(%struct.usb_bus.5580* %6)
  %shared_hcd = getelementptr inbounds %struct.usb_hcd.5612, %struct.usb_hcd.5612* %call2, i32 0, i32 22
  %7 = load %struct.usb_hcd.5612*, %struct.usb_hcd.5612** %shared_hcd, align 8, !tbaa !408
  %cmp = icmp ne %struct.usb_hcd.5612* %call4, %7
  br i1 %cmp, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %port1.0 = phi i32 [ 1, %if.end6 ], [ %inc, %for.inc ]
  %maxchild = getelementptr inbounds %struct.usb_device.5577, %struct.usb_device.5577* %peer_hdev, i32 0, i32 28
  %8 = load i32, i32* %maxchild, align 8, !tbaa !111
  %cmp7 = icmp sle i32 %port1.0, %8
  br i1 %cmp7, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %call, i32 0, i32 25
  %9 = load %struct.usb_port.5576**, %struct.usb_port.5576*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %port1.0, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port.5576*, %struct.usb_port.5576** %9, i64 %idxprom
  %10 = load %struct.usb_port.5576*, %struct.usb_port.5576** %arrayidx, align 8, !tbaa !52
  %tobool8 = icmp ne %struct.usb_port.5576* %10, null
  br i1 %tobool8, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %location = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %10, i32 0, i32 6
  %11 = load i32, i32* %location, align 4, !tbaa !837
  %location9 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %0, i32 0, i32 6
  %12 = load i32, i32* %location9, align 4, !tbaa !837
  %cmp10 = icmp eq i32 %11, %12
  br i1 %cmp10, label %if.then11, label %for.inc

if.then11:                                        ; preds = %land.lhs.true
  call void @link_peers_report(%struct.usb_port.5576* %0, %struct.usb_port.5576* %10)
  br label %cleanup

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %inc = add nsw i32 %port1.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.then11, %for.cond, %if.end, %entry
  %retval.0 = phi i32 [ 1, %if.then11 ], [ 0, %entry ], [ 0, %if.end ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd.5612* @bus_to_hcd.941(%struct.usb_bus.5580* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus.5580* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd.5612*
  ret %struct.usb_hcd.5612* %1
}

; Function Attrs: nounwind uwtable
define internal void @link_peers_report(%struct.usb_port.5576* %left, %struct.usb_port.5576* %right) #0 {
entry:
  %call = call i32 @link_peers(%struct.usb_port.5576* %left, %struct.usb_port.5576* %right)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %do.body1, label %do.body10

do.body1:                                         ; preds = %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @link_peers_report.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %if.end46

if.then4:                                         ; preds = %do.body1
  %dev = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 1
  %dev5 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right, i32 0, i32 1
  %call6 = call i8* @dev_name.934(%struct.device.5257* %dev5)
  call void (%struct._ddebug*, %struct.device.5257*, i8*, ...) bitcast (void (%struct._ddebug*, %struct.device*, i8*, ...)* @__dynamic_dev_dbg to void (%struct._ddebug*, %struct.device.5257*, i8*, ...)*)(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @link_peers_report.descriptor to %struct._ddebug*), %struct.device.5257* %dev, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.19.942, i32 0, i32 0), i8* %call6)
  br label %if.end46

do.body10:                                        ; preds = %entry
  %bf.load11 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @link_peers_report.descriptor.20 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr12 = lshr i32 %bf.load11, 18
  %bf.clear13 = and i32 %bf.lshr12, 255
  %and14 = and i32 %bf.clear13, 1
  %tobool15 = icmp ne i32 %and14, 0
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot.ext19 = zext i1 %lnot18 to i32
  %conv20 = sext i32 %lnot.ext19 to i64
  %expval21 = call i64 @llvm.expect.i64(i64 %conv20, i64 0)
  %tobool22 = icmp ne i64 %expval21, 0
  br i1 %tobool22, label %if.then23, label %do.end31

if.then23:                                        ; preds = %do.body10
  %dev24 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 1
  %dev25 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right, i32 0, i32 1
  %call26 = call i8* @dev_name.934(%struct.device.5257* %dev25)
  call void (%struct._ddebug*, %struct.device.5257*, i8*, ...) bitcast (void (%struct._ddebug*, %struct.device*, i8*, ...)* @__dynamic_dev_dbg to void (%struct._ddebug*, %struct.device.5257*, i8*, ...)*)(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @link_peers_report.descriptor.20 to %struct._ddebug*), %struct.device.5257* %dev24, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.21.943, i32 0, i32 0), i8* %call26, i32 %call)
  br label %do.end31

do.end31:                                         ; preds = %if.then23, %do.body10
  %0 = load i8, i8* @link_peers_report.__print_once, align 1, !tbaa !109, !range !110
  %tobool35 = trunc i8 %0 to i1
  br i1 %tobool35, label %if.end38, label %if.then36

if.then36:                                        ; preds = %do.end31
  store i8 1, i8* @link_peers_report.__print_once, align 1, !tbaa !109
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %do.end31
  store i32 1, i32* @usb_port_block_power_off, align 4, !tbaa !73
  br label %if.end46

if.end46:                                         ; preds = %if.end38, %if.then4, %do.body1
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @link_peers(%struct.usb_port.5576* %left, %struct.usb_port.5576* %right) #0 {
entry:
  %peer = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 3
  %0 = load %struct.usb_port.5576*, %struct.usb_port.5576** %peer, align 8, !tbaa !829
  %cmp = icmp eq %struct.usb_port.5576* %0, %right
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %peer1 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right, i32 0, i32 3
  %1 = load %struct.usb_port.5576*, %struct.usb_port.5576** %peer1, align 8, !tbaa !829
  %cmp2 = icmp eq %struct.usb_port.5576* %1, %left
  br i1 %cmp2, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %peer3 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 3
  %2 = load %struct.usb_port.5576*, %struct.usb_port.5576** %peer3, align 8, !tbaa !829
  %tobool = icmp ne %struct.usb_port.5576* %2, null
  br i1 %tobool, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %peer4 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right, i32 0, i32 3
  %3 = load %struct.usb_port.5576*, %struct.usb_port.5576** %peer4, align 8, !tbaa !829
  %tobool5 = icmp ne %struct.usb_port.5576* %3, null
  br i1 %tobool5, label %if.then6, label %if.end37

if.then6:                                         ; preds = %lor.lhs.false, %if.end
  %peer7 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 3
  %4 = load %struct.usb_port.5576*, %struct.usb_port.5576** %peer7, align 8, !tbaa !829
  %peer8 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right, i32 0, i32 3
  %5 = load %struct.usb_port.5576*, %struct.usb_port.5576** %peer8, align 8, !tbaa !829
  %location = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 6
  %6 = load i32, i32* %location, align 4, !tbaa !837
  %tobool9 = icmp ne i32 %6, 0
  br i1 %tobool9, label %land.lhs.true10, label %if.else

land.lhs.true10:                                  ; preds = %if.then6
  %location11 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 6
  %7 = load i32, i32* %location11, align 4, !tbaa !837
  %location12 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right, i32 0, i32 6
  %8 = load i32, i32* %location12, align 4, !tbaa !837
  %cmp13 = icmp eq i32 %7, %8
  br i1 %cmp13, label %do.body, label %if.else

if.else:                                          ; preds = %land.lhs.true10, %if.then6
  br label %do.body

do.body:                                          ; preds = %if.else, %land.lhs.true10
  %method.0 = phi i8* [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.24.945, i32 0, i32 0), %if.else ], [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.23.946, i32 0, i32 0), %land.lhs.true10 ]
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @link_peers.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool16 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool16, true
  %lnot17 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot17 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool18 = icmp ne i64 %expval, 0
  br i1 %tobool18, label %if.then19, label %cleanup

if.then19:                                        ; preds = %do.body
  %dev = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 1
  %call = call i8* @dev_name.934(%struct.device.5257* %dev)
  %dev20 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right, i32 0, i32 1
  %call21 = call i8* @dev_name.934(%struct.device.5257* %dev20)
  %dev22 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 1
  %call23 = call i8* @dev_name.934(%struct.device.5257* %dev22)
  %tobool24 = icmp ne %struct.usb_port.5576* %4, null
  br i1 %tobool24, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.then19
  %dev25 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %4, i32 0, i32 1
  %call26 = call i8* @dev_name.934(%struct.device.5257* %dev25)
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.then19
  %cond = phi i8* [ %call26, %cond.true ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.26.947, i32 0, i32 0), %if.then19 ]
  %dev27 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right, i32 0, i32 1
  %call28 = call i8* @dev_name.934(%struct.device.5257* %dev27)
  %tobool29 = icmp ne %struct.usb_port.5576* %5, null
  br i1 %tobool29, label %cond.true30, label %cond.end34

cond.true30:                                      ; preds = %cond.end
  %dev31 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %5, i32 0, i32 1
  %call32 = call i8* @dev_name.934(%struct.device.5257* %dev31)
  br label %cond.end34

cond.end34:                                       ; preds = %cond.true30, %cond.end
  %cond35 = phi i8* [ %call32, %cond.true30 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.26.947, i32 0, i32 0), %cond.end ]
  call void (%struct._ddebug*, i8*, ...) @__dynamic_pr_debug(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @link_peers.descriptor to %struct._ddebug*), i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.25.948, i32 0, i32 0), i8* %call, i8* %call21, i8* %method.0, i8* %call23, i8* %cond, i8* %call28, i8* %cond35)
  br label %cleanup

if.end37:                                         ; preds = %lor.lhs.false
  %dev38 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 1
  %kobj = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev38, i32 0, i32 2
  %dev39 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right, i32 0, i32 1
  %kobj40 = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev39, i32 0, i32 2
  %call41 = call i32 @sysfs_create_link(%struct.kobject* %kobj, %struct.kobject* %kobj40, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27.949, i32 0, i32 0))
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %cleanup, label %if.end44

if.end44:                                         ; preds = %if.end37
  %dev45 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right, i32 0, i32 1
  %kobj46 = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev45, i32 0, i32 2
  %dev47 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 1
  %kobj48 = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev47, i32 0, i32 2
  %call49 = call i32 @sysfs_create_link(%struct.kobject* %kobj46, %struct.kobject* %kobj48, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27.949, i32 0, i32 0))
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %if.then51, label %if.end54

if.then51:                                        ; preds = %if.end44
  %dev52 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 1
  %kobj53 = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev52, i32 0, i32 2
  call void @sysfs_remove_link(%struct.kobject* %kobj53, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27.949, i32 0, i32 0))
  br label %cleanup

if.end54:                                         ; preds = %if.end44
  %is_superspeed = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 9
  %bf.load55 = load i8, i8* %is_superspeed, align 1
  %bf.clear56 = and i8 %bf.load55, 1
  %bf.cast = zext i8 %bf.clear56 to i32
  %tobool57 = icmp ne i32 %bf.cast, 0
  %is_superspeed59 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right, i32 0, i32 9
  %bf.load60 = load i8, i8* %is_superspeed59, align 1
  %bf.clear61 = and i8 %bf.load60, 1
  %bf.cast62 = zext i8 %bf.clear61 to i32
  %tobool63 = icmp ne i32 %bf.cast62, 0
  %lnot64 = xor i1 %tobool63, true
  %lnot66 = xor i1 %lnot64, true
  br i1 %tobool57, label %if.then58, label %if.else85

if.then58:                                        ; preds = %if.end54
  %lnot.ext67 = zext i1 %lnot66 to i32
  %tobool68 = icmp ne i32 %lnot.ext67, 0
  %lnot69 = xor i1 %tobool68, true
  %lnot71 = xor i1 %lnot69, true
  %lnot.ext72 = zext i1 %lnot71 to i32
  %conv73 = sext i32 %lnot.ext72 to i64
  %expval74 = call i64 @llvm.expect.i64(i64 %conv73, i64 0)
  %tobool75 = icmp ne i64 %expval74, 0
  br i1 %tobool75, label %if.then76, label %if.end77

if.then76:                                        ; preds = %if.then58
  call void @warn_slowpath_null(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.5.929, i32 0, i32 0), i32 315)
  br label %if.end77

if.end77:                                         ; preds = %if.then76, %if.then58
  br label %if.end116

if.else85:                                        ; preds = %if.end54
  %lnot96 = xor i1 %lnot66, true
  %lnot.ext97 = zext i1 %lnot96 to i32
  %tobool98 = icmp ne i32 %lnot.ext97, 0
  %lnot99 = xor i1 %tobool98, true
  %lnot101 = xor i1 %lnot99, true
  %lnot.ext102 = zext i1 %lnot101 to i32
  %conv103 = sext i32 %lnot.ext102 to i64
  %expval104 = call i64 @llvm.expect.i64(i64 %conv103, i64 0)
  %tobool105 = icmp ne i64 %expval104, 0
  br i1 %tobool105, label %if.then106, label %if.end107

if.then106:                                       ; preds = %if.else85
  call void @warn_slowpath_null(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.5.929, i32 0, i32 0), i32 319)
  br label %if.end107

if.end107:                                        ; preds = %if.then106, %if.else85
  br label %if.end116

if.end116:                                        ; preds = %if.end107, %if.end77
  %hs_port.0 = phi %struct.usb_port.5576* [ %right, %if.end77 ], [ %left, %if.end107 ]
  %ss_port.0 = phi %struct.usb_port.5576* [ %left, %if.end77 ], [ %right, %if.end107 ]
  %dev117 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %hs_port.0, i32 0, i32 1
  call void @pm_runtime_get_sync.921(%struct.device.5257* %dev117)
  %peer119 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 3
  store %struct.usb_port.5576* %right, %struct.usb_port.5576** %peer119, align 8, !tbaa !829
  %peer120 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right, i32 0, i32 3
  store %struct.usb_port.5576* %left, %struct.usb_port.5576** %peer120, align 8, !tbaa !829
  %dev121 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %ss_port.0, i32 0, i32 1
  call void @pm_runtime_get_sync.921(%struct.device.5257* %dev121)
  %dev123 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %hs_port.0, i32 0, i32 1
  call void @pm_runtime_put.930(%struct.device.5257* %dev123)
  br label %cleanup

cleanup:                                          ; preds = %if.end116, %if.then51, %if.end37, %cond.end34, %do.body, %land.lhs.true
  %retval.0 = phi i32 [ %call49, %if.then51 ], [ 0, %if.end116 ], [ 0, %land.lhs.true ], [ -16, %cond.end34 ], [ -16, %do.body ], [ %call41, %if.end37 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name.950(%struct.kobject* %kobj) #1 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !409
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i64 @connect_type_show(%struct.device.5257* %dev, %struct.device_attribute.5555* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device.5257* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -8
  %1 = bitcast i8* %add.ptr to %struct.usb_port.5576*
  %connect_type = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 5
  %2 = load i32, i32* %connect_type, align 8, !tbaa !230
  %Pivot4 = icmp slt i32 %2, 2
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %2, 3
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %2, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %2, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock, %LeafBlock1, %NodeBlock
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @usb3_lpm_permit_show(%struct.device.5257* %dev, %struct.device_attribute.5555* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @usb3_lpm_permit_store(%struct.device.5257* %dev, %struct.device_attribute.5555* %attr, i8* %buf, i64 %count) #0 {
entry:
  %0 = bitcast %struct.device.5257* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -8
  %1 = bitcast i8* %add.ptr to %struct.usb_port.5576*
  %child = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 0
  %2 = load %struct.usb_device.5577*, %struct.usb_device.5577** %child, align 8, !tbaa !115
  %call = call i32 @strncmp(i8* %buf, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.14.959, i32 0, i32 0), i64 5)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %usb3_lpm_u1_permit = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 9
  %bf.load = load i8, i8* %usb3_lpm_u1_permit, align 1
  %bf.clear = and i8 %bf.load, -3
  %bf.set = or i8 %bf.clear, 2
  store i8 %bf.set, i8* %usb3_lpm_u1_permit, align 1
  %usb3_lpm_u2_permit = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 9
  %bf.load1 = load i8, i8* %usb3_lpm_u2_permit, align 1
  %bf.clear2 = and i8 %bf.load1, -5
  %bf.set3 = or i8 %bf.clear2, 4
  store i8 %bf.set3, i8* %usb3_lpm_u2_permit, align 1
  br label %if.end38

if.else:                                          ; preds = %entry
  %call4 = call i32 @strncmp(i8* %buf, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.15.960, i32 0, i32 0), i64 2)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.else14, label %if.then6

if.then6:                                         ; preds = %if.else
  %usb3_lpm_u1_permit7 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 9
  %bf.load8 = load i8, i8* %usb3_lpm_u1_permit7, align 1
  %bf.clear9 = and i8 %bf.load8, -3
  %bf.set10 = or i8 %bf.clear9, 2
  store i8 %bf.set10, i8* %usb3_lpm_u1_permit7, align 1
  %usb3_lpm_u2_permit11 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 9
  %bf.load12 = load i8, i8* %usb3_lpm_u2_permit11, align 1
  %bf.clear13 = and i8 %bf.load12, -5
  store i8 %bf.clear13, i8* %usb3_lpm_u2_permit11, align 1
  br label %if.end38

if.else14:                                        ; preds = %if.else
  %call15 = call i32 @strncmp(i8* %buf, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16.961, i32 0, i32 0), i64 2)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.else25, label %if.then17

if.then17:                                        ; preds = %if.else14
  %usb3_lpm_u1_permit18 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 9
  %bf.load19 = load i8, i8* %usb3_lpm_u1_permit18, align 1
  %bf.clear20 = and i8 %bf.load19, -3
  store i8 %bf.clear20, i8* %usb3_lpm_u1_permit18, align 1
  %usb3_lpm_u2_permit21 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 9
  %bf.load22 = load i8, i8* %usb3_lpm_u2_permit21, align 1
  %bf.clear23 = and i8 %bf.load22, -5
  %bf.set24 = or i8 %bf.clear23, 4
  store i8 %bf.set24, i8* %usb3_lpm_u2_permit21, align 1
  br label %if.end38

if.else25:                                        ; preds = %if.else14
  %call26 = call i32 @strncmp(i8* %buf, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.17.962, i32 0, i32 0), i64 1)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %cleanup, label %if.then28

if.then28:                                        ; preds = %if.else25
  %usb3_lpm_u1_permit29 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 9
  %bf.load30 = load i8, i8* %usb3_lpm_u1_permit29, align 1
  %bf.clear31 = and i8 %bf.load30, -3
  store i8 %bf.clear31, i8* %usb3_lpm_u1_permit29, align 1
  %usb3_lpm_u2_permit32 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 9
  %bf.load33 = load i8, i8* %usb3_lpm_u2_permit32, align 1
  %bf.clear34 = and i8 %bf.load33, -5
  store i8 %bf.clear34, i8* %usb3_lpm_u2_permit32, align 1
  br label %if.end38

if.end38:                                         ; preds = %if.then28, %if.then17, %if.then6, %if.then
  %tobool39 = icmp ne %struct.usb_device.5577* %2, null
  br i1 %tobool39, label %if.then40, label %cleanup

if.then40:                                        ; preds = %if.end38
  %bus = getelementptr inbounds %struct.usb_device.5577, %struct.usb_device.5577* %2, i32 0, i32 9
  %3 = load %struct.usb_bus.5580*, %struct.usb_bus.5580** %bus, align 8, !tbaa !2
  %call41 = call %struct.usb_hcd.5612* @bus_to_hcd.941(%struct.usb_bus.5580* %3)
  %tobool42 = icmp ne %struct.usb_hcd.5612* %call41, null
  br i1 %tobool42, label %if.end44, label %cleanup

if.end44:                                         ; preds = %if.then40
  %dev45 = getelementptr inbounds %struct.usb_device.5577, %struct.usb_device.5577* %2, i32 0, i32 11
  call void @device_lock.963(%struct.device.5257* %dev45)
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd.5612, %struct.usb_hcd.5612* %call41, i32 0, i32 21
  %4 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !167
  call void @mutex_lock_nested(%struct.mutex* %4, i32 0)
  %call46 = call i32 bitcast (i32 (%struct.usb_device*)* @usb_disable_lpm to i32 (%struct.usb_device.5577*)*)(%struct.usb_device.5577* %2)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %if.end49, label %if.then48

if.then48:                                        ; preds = %if.end44
  call void bitcast (void (%struct.usb_device*)* @usb_enable_lpm to void (%struct.usb_device.5577*)*)(%struct.usb_device.5577* %2)
  br label %if.end49

if.end49:                                         ; preds = %if.then48, %if.end44
  %bandwidth_mutex50 = getelementptr inbounds %struct.usb_hcd.5612, %struct.usb_hcd.5612* %call41, i32 0, i32 21
  %5 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex50, align 8, !tbaa !167
  call void @mutex_unlock(%struct.mutex* %5)
  %dev51 = getelementptr inbounds %struct.usb_device.5577, %struct.usb_device.5577* %2, i32 0, i32 11
  call void @device_unlock.964(%struct.device.5257* %dev51)
  br label %cleanup

cleanup:                                          ; preds = %if.end49, %if.then40, %if.end38, %if.else25
  %retval.0 = phi i64 [ -22, %if.else25 ], [ -22, %if.then40 ], [ %count, %if.end49 ], [ %count, %if.end38 ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock.963(%struct.device.5257* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock.964(%struct.device.5257* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_hub_remove_port_device(%struct.usb_hub.5605* %hub, i32 %port1) #0 {
entry:
  %ports = getelementptr inbounds %struct.usb_hub.5605, %struct.usb_hub.5605* %hub, i32 0, i32 25
  %0 = load %struct.usb_port.5576**, %struct.usb_port.5576*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port.5576*, %struct.usb_port.5576** %0, i64 %idxprom
  %1 = load %struct.usb_port.5576*, %struct.usb_port.5576** %arrayidx, align 8, !tbaa !52
  %peer1 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 3
  %2 = load %struct.usb_port.5576*, %struct.usb_port.5576** %peer1, align 8, !tbaa !829
  %tobool = icmp ne %struct.usb_port.5576* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @unlink_peers(%struct.usb_port.5576* %1, %struct.usb_port.5576* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %dev = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %1, i32 0, i32 1
  call void bitcast (void (%struct.device.3441*)* @device_unregister to void (%struct.device.5257*)*)(%struct.device.5257* %dev)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @unlink_peers(%struct.usb_port.5576* %left, %struct.usb_port.5576* %right) #0 {
entry:
  %peer = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right, i32 0, i32 3
  %0 = load %struct.usb_port.5576*, %struct.usb_port.5576** %peer, align 8, !tbaa !829
  %cmp = icmp ne %struct.usb_port.5576* %0, %left
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %peer1 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 3
  %1 = load %struct.usb_port.5576*, %struct.usb_port.5576** %peer1, align 8, !tbaa !829
  %cmp2 = icmp ne %struct.usb_port.5576* %1, %right
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  %lnot = xor i1 %2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  %dev = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 1
  %call = call i8* @dev_name.934(%struct.device.5257* %dev)
  %dev9 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right, i32 0, i32 1
  %call10 = call i8* @dev_name.934(%struct.device.5257* %dev9)
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.5.929, i32 0, i32 0), i32 362, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.28.968, i32 0, i32 0), i8* %call, i8* %call10)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %is_superspeed = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 9
  %bf.load = load i8, i8* %is_superspeed, align 1
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool18 = icmp ne i32 %bf.cast, 0
  %left.right = select i1 %tobool18, %struct.usb_port.5576* %left, %struct.usb_port.5576* %right
  %right.left = select i1 %tobool18, %struct.usb_port.5576* %right, %struct.usb_port.5576* %left
  %dev21 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right.left, i32 0, i32 1
  call void @pm_runtime_get_sync.921(%struct.device.5257* %dev21)
  %dev23 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 1
  %kobj = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev23, i32 0, i32 2
  call void @sysfs_remove_link(%struct.kobject* %kobj, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27.949, i32 0, i32 0))
  %peer24 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right, i32 0, i32 3
  store %struct.usb_port.5576* null, %struct.usb_port.5576** %peer24, align 8, !tbaa !829
  %dev25 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right, i32 0, i32 1
  %kobj26 = getelementptr inbounds %struct.device.5257, %struct.device.5257* %dev25, i32 0, i32 2
  call void @sysfs_remove_link(%struct.kobject* %kobj26, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27.949, i32 0, i32 0))
  %peer27 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left, i32 0, i32 3
  store %struct.usb_port.5576* null, %struct.usb_port.5576** %peer27, align 8, !tbaa !829
  %dev28 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %left.right, i32 0, i32 1
  call void @pm_runtime_put.930(%struct.device.5257* %dev28)
  %dev30 = getelementptr inbounds %struct.usb_port.5576, %struct.usb_port.5576* %right.left, i32 0, i32 1
  call void @pm_runtime_put.930(%struct.device.5257* %dev30)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.device_node* @usb_of_get_child_node(%struct.device_node* %parent, i32 %portnum) #0 {
entry:
  %port = alloca i32, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %node.0.sink = phi %struct.device_node* [ %call5, %for.inc ], [ null, %entry ]
  %call5 = call %struct.device_node* @of_get_next_child(%struct.device_node* %parent, %struct.device_node* %node.0.sink)
  %cmp = icmp ne %struct.device_node* %call5, null
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %call1 = call i32 @of_property_read_u32(%struct.device_node* %call5, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.972, i32 0, i32 0), i32* %port)
  %tobool = icmp eq i32 %call1, 0
  %0 = load i32, i32* %port, align 4
  %cmp2 = icmp eq i32 %0, %portnum
  %or.cond = and i1 %tobool, %cmp2
  br i1 %or.cond, label %cleanup, label %for.inc

for.inc:                                          ; preds = %for.body
  br label %for.cond

cleanup:                                          ; preds = %for.body, %for.cond
  %retval.0 = phi %struct.device_node* [ null, %for.cond ], [ %call5, %for.body ]
  ret %struct.device_node* %retval.0
}

declare %struct.device_node* @of_get_next_child(%struct.device_node*, %struct.device_node*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @of_property_read_u32(%struct.device_node* %np, i8* %propname, i32* %out_value) #1 {
entry:
  %call = call i32 @of_property_read_u32_array(%struct.device_node* %np, i8* %propname, i32* %out_value, i64 1)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @of_property_read_u32_array(%struct.device_node* %np, i8* %propname, i32* %out_values, i64 %sz) #1 {
entry:
  %call = call i32 @of_property_read_variable_u32_array(%struct.device_node* %np, i8* %propname, i32* %out_values, i64 %sz, i64 0)
  %cmp = icmp sge i32 %call, 0
  %.call = select i1 %cmp, i32 0, i32 %call
  ret i32 %.call
}

declare i32 @of_property_read_variable_u32_array(%struct.device_node*, i8*, i32*, i64, i64) #2

; Function Attrs: nounwind uwtable
define internal i32 @hcd_pci_suspend(%struct.device* %dev) #0 {
entry:
  %call = call zeroext i1 @device_may_wakeup.981(%struct.device* %dev)
  %call1 = call i32 @suspend_common(%struct.device* %dev, i1 zeroext %call)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @hcd_pci_resume(%struct.device* %dev) #0 {
entry:
  %call = call i32 @resume_common(%struct.device* %dev, i32 16)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @check_root_hub_suspended(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -160
  %1 = bitcast i8* %add.ptr to %struct.pci_dev*
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %1)
  %2 = bitcast i8* %call to %struct.usb_hcd*
  %flags = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 11
  %3 = load i64, i64* %flags, align 8, !tbaa !84
  %and = and i64 %3, 32
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  %shared_hcd = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 22
  %4 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd, align 8, !tbaa !408
  %tobool1 = icmp ne %struct.usb_hcd* %4, null
  br i1 %tobool1, label %if.then2, label %cleanup

if.then2:                                         ; preds = %if.end
  %shared_hcd3 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 22
  %5 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd3, align 8, !tbaa !408
  %flags4 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %5, i32 0, i32 11
  %6 = load i64, i64* %flags4, align 8, !tbaa !84
  %and5 = and i64 %6, 32
  %tobool6 = icmp ne i64 %and5, 0
  br i1 %tobool6, label %if.then7, label %cleanup

if.then7:                                         ; preds = %if.then2
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then7, %if.then2, %if.end, %if.then
  %retval.0 = phi i32 [ -16, %if.then ], [ -16, %if.then7 ], [ 0, %if.then2 ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @hcd_pci_restore(%struct.device* %dev) #0 {
entry:
  %call = call i32 @resume_common(%struct.device* %dev, i32 64)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @hcd_pci_suspend_noirq(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -160
  %1 = bitcast i8* %add.ptr to %struct.pci_dev*
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %1)
  %2 = bitcast i8* %call to %struct.usb_hcd*
  %call2 = call i32 @check_root_hub_suspended(%struct.device* %dev)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call3 = call i32 @pci_save_state(%struct.pci_dev* %1)
  %flags = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 11
  %3 = load i64, i64* %flags, align 8, !tbaa !84
  %and = and i64 %3, 64
  %tobool4 = icmp ne i64 %and, 0
  br i1 %tobool4, label %if.then5, label %do.body8

if.then5:                                         ; preds = %if.end
  %call6 = call i32 @device_set_wakeup_enable(%struct.device* %dev, i1 zeroext false)
  br label %do.body8

do.body8:                                         ; preds = %if.then5, %if.end
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_suspend_noirq.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and9 = and i32 %bf.clear, 1
  %tobool10 = icmp ne i32 %and9, 0
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.then13, label %do.end18

if.then13:                                        ; preds = %do.body8
  %call14 = call zeroext i1 @device_may_wakeup.981(%struct.device* %dev)
  %conv15 = zext i1 %call14 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_suspend_noirq.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.19.982, i32 0, i32 0), i32 %conv15)
  br label %do.end18

do.end18:                                         ; preds = %if.then13, %do.body8
  %call19 = call i32 @pci_prepare_to_sleep(%struct.pci_dev* %1)
  switch i32 %call19, label %do.body67 [
    i32 -5, label %do.body23
    i32 0, label %do.body46
  ]

do.body23:                                        ; preds = %do.end18
  %bf.load24 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_suspend_noirq.descriptor.20 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr25 = lshr i32 %bf.load24, 18
  %bf.clear26 = and i32 %bf.lshr25, 255
  %and27 = and i32 %bf.clear26, 1
  %tobool28 = icmp ne i32 %and27, 0
  %lnot29 = xor i1 %tobool28, true
  %lnot31 = xor i1 %lnot29, true
  %lnot.ext32 = zext i1 %lnot31 to i32
  %conv33 = sext i32 %lnot.ext32 to i64
  %expval34 = call i64 @llvm.expect.i64(i64 %conv33, i64 0)
  %tobool35 = icmp ne i64 %expval34, 0
  br i1 %tobool35, label %if.then36, label %if.end71

if.then36:                                        ; preds = %do.body23
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_suspend_noirq.descriptor.20 to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.21.983, i32 0, i32 0))
  br label %if.end71

do.body46:                                        ; preds = %do.end18
  %bf.load47 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_suspend_noirq.descriptor.22 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr48 = lshr i32 %bf.load47, 18
  %bf.clear49 = and i32 %bf.lshr48, 255
  %and50 = and i32 %bf.clear49, 1
  %tobool51 = icmp ne i32 %and50, 0
  %lnot52 = xor i1 %tobool51, true
  %lnot54 = xor i1 %lnot52, true
  %lnot.ext55 = zext i1 %lnot54 to i32
  %conv56 = sext i32 %lnot.ext55 to i64
  %expval57 = call i64 @llvm.expect.i64(i64 %conv56, i64 0)
  %tobool58 = icmp ne i64 %expval57, 0
  br i1 %tobool58, label %if.then59, label %if.end71

if.then59:                                        ; preds = %do.body46
  %current_state = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %1, i32 0, i32 27
  %4 = load i32, i32* %current_state, align 8, !tbaa !838
  %call60 = call i8* @pci_power_name(i32 %4)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_suspend_noirq.descriptor.22 to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23.984, i32 0, i32 0), i8* %call60)
  br label %if.end71

do.body67:                                        ; preds = %do.end18
  call void @__suspend_report_result(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.hcd_pci_suspend_noirq, i32 0, i32 0), i8* bitcast (i32 (%struct.pci_dev*)* @pci_prepare_to_sleep to i8*), i32 %call19)
  br label %cleanup

if.end71:                                         ; preds = %if.then59, %do.body46, %if.then36, %do.body23
  %retval1.0 = phi i32 [ 0, %if.then36 ], [ 0, %do.body23 ], [ %call19, %do.body46 ], [ %call19, %if.then59 ]
  call void @powermac_set_asic()
  br label %cleanup

cleanup:                                          ; preds = %if.end71, %do.body67, %entry
  %retval.0 = phi i32 [ %retval1.0, %if.end71 ], [ %call19, %do.body67 ], [ %call2, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @hcd_pci_resume_noirq(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -160
  %1 = bitcast i8* %add.ptr to %struct.pci_dev*
  call void @powermac_set_asic()
  %call = call i32 @pci_back_from_sleep(%struct.pci_dev* %1)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @hcd_pci_runtime_suspend(%struct.device* %dev) #0 {
entry:
  %call = call i32 @suspend_common(%struct.device* %dev, i1 zeroext true)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %do.body2

if.then:                                          ; preds = %entry
  call void @powermac_set_asic()
  br label %do.body2

do.body2:                                         ; preds = %if.then, %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_runtime_suspend.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then5, label %do.end8

if.then5:                                         ; preds = %do.body2
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_runtime_suspend.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.24.980, i32 0, i32 0), i32 %call)
  br label %do.end8

do.end8:                                          ; preds = %if.then5, %do.body2
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @hcd_pci_runtime_resume(%struct.device* %dev) #0 {
entry:
  call void @powermac_set_asic()
  %call = call i32 @resume_common(%struct.device* %dev, i32 1040)
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_runtime_resume.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %do.end6

if.then:                                          ; preds = %entry
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_runtime_resume.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.25.973, i32 0, i32 0), i32 %call)
  br label %do.end6

do.end6:                                          ; preds = %if.then, %entry
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @powermac_set_asic() #1 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @resume_common(%struct.device* %dev, i32 %event) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -160
  %1 = bitcast i8* %add.ptr to %struct.pci_dev*
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %1)
  %2 = bitcast i8* %call to %struct.usb_hcd*
  %flags = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 11
  %3 = load i64, i64* %flags, align 8, !tbaa !84
  %and = and i64 %3, 32
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %do.body7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %shared_hcd = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 22
  %4 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd, align 8, !tbaa !408
  %tobool2 = icmp ne %struct.usb_hcd* %4, null
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %lor.lhs.false
  %shared_hcd3 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 22
  %5 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd3, align 8, !tbaa !408
  %flags4 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %5, i32 0, i32 11
  %6 = load i64, i64* %flags4, align 8, !tbaa !84
  %and5 = and i64 %6, 32
  %tobool6 = icmp ne i64 %and5, 0
  br i1 %tobool6, label %do.body7, label %if.end15

do.body7:                                         ; preds = %land.lhs.true, %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @resume_common.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and8 = and i32 %bf.clear, 1
  %tobool9 = icmp ne i32 %and8, 0
  %lnot = xor i1 %tobool9, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %if.then12, label %cleanup

if.then12:                                        ; preds = %do.body7
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @resume_common.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.14.976, i32 0, i32 0))
  br label %cleanup

if.end15:                                         ; preds = %land.lhs.true, %lor.lhs.false
  %call16 = call i32 @pci_enable_device(%struct.pci_dev* %1)
  %cmp = icmp slt i32 %call16, 0
  br i1 %cmp, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end19:                                         ; preds = %if.end15
  call void @pci_set_master(%struct.pci_dev* %1)
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 8
  %7 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %pci_resume = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %7, i32 0, i32 8
  %8 = load i32 (%struct.usb_hcd*, i1)*, i32 (%struct.usb_hcd*, i1)** %pci_resume, align 8, !tbaa !841
  %tobool20 = icmp ne i32 (%struct.usb_hcd*, i1)* %8, null
  br i1 %tobool20, label %land.lhs.true21, label %cleanup

land.lhs.true21:                                  ; preds = %if.end19
  %flags22 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 11
  %9 = load i64, i64* %flags22, align 8, !tbaa !84
  %and23 = and i64 %9, 64
  %tobool24 = icmp ne i64 %and23, 0
  br i1 %tobool24, label %cleanup, label %if.then25

if.then25:                                        ; preds = %land.lhs.true21
  %class = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %1, i32 0, i32 11
  %10 = load i32, i32* %class, align 4, !tbaa !842
  %cmp26 = icmp eq i32 %10, 787232
  %cmp29 = icmp ne i32 %event, 1040
  %or.cond = and i1 %cmp26, %cmp29
  br i1 %or.cond, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.then25
  call void @for_each_companion(%struct.pci_dev* %1, %struct.usb_hcd* %2, void (%struct.pci_dev*, %struct.usb_hcd*, %struct.pci_dev*, %struct.usb_hcd*)* @ehci_wait_for_companions)
  br label %if.end32

if.end32:                                         ; preds = %if.then31, %if.then25
  %driver33 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 8
  %11 = load %struct.hc_driver*, %struct.hc_driver** %driver33, align 8, !tbaa !57
  %pci_resume34 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %11, i32 0, i32 8
  %12 = load i32 (%struct.usb_hcd*, i1)*, i32 (%struct.usb_hcd*, i1)** %pci_resume34, align 8, !tbaa !841
  %cmp35 = icmp eq i32 %event, 64
  %call37 = call i32 %12(%struct.usb_hcd* %2, i1 zeroext %cmp35)
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.then39, label %cleanup

if.then39:                                        ; preds = %if.end32
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %shared_hcd40 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 22
  %13 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd40, align 8, !tbaa !408
  %tobool41 = icmp ne %struct.usb_hcd* %13, null
  br i1 %tobool41, label %if.then42, label %if.end44

if.then42:                                        ; preds = %if.then39
  %shared_hcd43 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 22
  %14 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd43, align 8, !tbaa !408
  call void bitcast (void (%struct.usb_hcd.712*)* @usb_hc_died to void (%struct.usb_hcd*)*)(%struct.usb_hcd* %14)
  br label %if.end44

if.end44:                                         ; preds = %if.then42, %if.then39
  call void bitcast (void (%struct.usb_hcd.712*)* @usb_hc_died to void (%struct.usb_hcd*)*)(%struct.usb_hcd* %2)
  br label %cleanup

cleanup:                                          ; preds = %if.end44, %if.end32, %land.lhs.true21, %if.end19, %if.then18, %if.then12, %do.body7
  %retval.0 = phi i32 [ %call16, %if.then18 ], [ 0, %if.then12 ], [ 0, %do.body7 ], [ %call16, %land.lhs.true21 ], [ %call16, %if.end19 ], [ %call37, %if.end44 ], [ %call37, %if.end32 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @pci_get_drvdata(%struct.pci_dev* %pdev) #1 {
entry:
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  %call = call i8* @dev_get_drvdata.979(%struct.device* %dev)
  ret i8* %call
}

declare i32 @pci_enable_device(%struct.pci_dev*) #2

declare void @pci_set_master(%struct.pci_dev*) #2

; Function Attrs: nounwind uwtable
define internal void @ehci_wait_for_companions(%struct.pci_dev* %pdev, %struct.usb_hcd* %hcd, %struct.pci_dev* %companion, %struct.usb_hcd* %companion_hcd) #0 {
entry:
  %call = call i32 @is_ohci_or_uhci(%struct.pci_dev* %companion)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  %dev1 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %companion, i32 0, i32 35
  %call2 = call i32 @device_pm_wait_for_dev(%struct.device* %dev, %struct.device* %dev1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @for_each_companion(%struct.pci_dev* %pdev, %struct.usb_hcd* %hcd, void (%struct.pci_dev*, %struct.usb_hcd*, %struct.pci_dev*, %struct.usb_hcd*)* %fn) #0 {
entry:
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 6
  %0 = load i32, i32* %devfn, align 8, !tbaa !843
  %shr = lshr i32 %0, 3
  %and = and i32 %shr, 31
  br label %while.cond

while.cond:                                       ; preds = %while.cond.backedge, %entry
  %companion.0 = phi %struct.pci_dev* [ null, %entry ], [ %call, %while.cond.backedge ]
  %call = call %struct.pci_dev* @pci_get_device(i32 -1, i32 -1, %struct.pci_dev* %companion.0)
  %cmp = icmp ne %struct.pci_dev* %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %call, i32 0, i32 1
  %1 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !844
  %bus1 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 1
  %2 = load %struct.pci_bus*, %struct.pci_bus** %bus1, align 8, !tbaa !844
  %cmp2 = icmp ne %struct.pci_bus* %1, %2
  br i1 %cmp2, label %while.cond.backedge, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %devfn3 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %call, i32 0, i32 6
  %3 = load i32, i32* %devfn3, align 8, !tbaa !843
  %shr4 = lshr i32 %3, 3
  %and5 = and i32 %shr4, 31
  %cmp6 = icmp ne i32 %and5, %and
  br i1 %cmp6, label %while.cond.backedge, label %if.end

while.cond.backedge:                              ; preds = %if.end19, %lor.lhs.false16, %if.end14, %land.lhs.true10, %lor.lhs.false, %while.body
  br label %while.cond

if.end:                                           ; preds = %lor.lhs.false
  %class = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %call, i32 0, i32 11
  %4 = load i32, i32* %class, align 4, !tbaa !842
  %cmp7 = icmp ne i32 %4, 787200
  br i1 %cmp7, label %land.lhs.true, label %if.end14

land.lhs.true:                                    ; preds = %if.end
  %class8 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %call, i32 0, i32 11
  %5 = load i32, i32* %class8, align 4, !tbaa !842
  %cmp9 = icmp ne i32 %5, 787216
  br i1 %cmp9, label %land.lhs.true10, label %if.end14

land.lhs.true10:                                  ; preds = %land.lhs.true
  %class11 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %call, i32 0, i32 11
  %6 = load i32, i32* %class11, align 4, !tbaa !842
  %cmp12 = icmp ne i32 %6, 787232
  br i1 %cmp12, label %while.cond.backedge, label %if.end14

if.end14:                                         ; preds = %land.lhs.true10, %land.lhs.true, %if.end
  %call15 = call i8* @pci_get_drvdata(%struct.pci_dev* %call)
  %7 = bitcast i8* %call15 to %struct.usb_hcd*
  %tobool = icmp ne %struct.usb_hcd* %7, null
  br i1 %tobool, label %lor.lhs.false16, label %while.cond.backedge

lor.lhs.false16:                                  ; preds = %if.end14
  %self = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %7, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 11
  %8 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !175
  %tobool17 = icmp ne %struct.usb_device* %8, null
  br i1 %tobool17, label %if.end19, label %while.cond.backedge

if.end19:                                         ; preds = %lor.lhs.false16
  call void %fn(%struct.pci_dev* %pdev, %struct.usb_hcd* %hcd, %struct.pci_dev* %call, %struct.usb_hcd* %7)
  br label %while.cond.backedge

while.end:                                        ; preds = %while.cond
  ret void
}

declare %struct.pci_dev* @pci_get_device(i32, i32, %struct.pci_dev*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_ohci_or_uhci(%struct.pci_dev* %pdev) #1 {
entry:
  %class = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 11
  %0 = load i32, i32* %class, align 4, !tbaa !842
  %cmp = icmp eq i32 %0, 787216
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %class1 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 11
  %1 = load i32, i32* %class1, align 4, !tbaa !842
  %cmp2 = icmp eq i32 %1, 787200
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  %lor.ext = zext i1 %2 to i32
  ret i32 %lor.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_get_drvdata.979(%struct.device* %dev) #1 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !117
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @suspend_common(%struct.device* %dev, i1 zeroext %do_wakeup) #0 {
entry:
  %frombool = zext i1 %do_wakeup to i8
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -160
  %1 = bitcast i8* %add.ptr to %struct.pci_dev*
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %1)
  %2 = bitcast i8* %call to %struct.usb_hcd*
  %call2 = call i32 @check_root_hub_suspended(%struct.device* %dev)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 8
  %3 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %pci_suspend = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %3, i32 0, i32 7
  %4 = load i32 (%struct.usb_hcd*, i1)*, i32 (%struct.usb_hcd*, i1)** %pci_suspend, align 8, !tbaa !845
  %tobool3 = icmp ne i32 (%struct.usb_hcd*, i1)* %4, null
  br i1 %tobool3, label %land.lhs.true, label %if.end58

land.lhs.true:                                    ; preds = %if.end
  %flags = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 11
  %5 = load i64, i64* %flags, align 8, !tbaa !84
  %and = and i64 %5, 64
  %tobool4 = icmp ne i64 %and, 0
  br i1 %tobool4, label %if.end58, label %if.then5

if.then5:                                         ; preds = %land.lhs.true
  %tobool6 = trunc i8 %frombool to i1
  br i1 %tobool6, label %land.lhs.true7, label %if.end12

land.lhs.true7:                                   ; preds = %if.then5
  %flags8 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 11
  %6 = load i64, i64* %flags8, align 8, !tbaa !84
  %and9 = and i64 %6, 16
  %tobool10 = icmp ne i64 %and9, 0
  br i1 %tobool10, label %cleanup, label %if.end12

if.end12:                                         ; preds = %land.lhs.true7, %if.then5
  %tobool13 = trunc i8 %frombool to i1
  br i1 %tobool13, label %land.lhs.true14, label %if.end22

land.lhs.true14:                                  ; preds = %if.end12
  %shared_hcd = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 22
  %7 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd, align 8, !tbaa !408
  %tobool15 = icmp ne %struct.usb_hcd* %7, null
  br i1 %tobool15, label %land.lhs.true16, label %if.end22

land.lhs.true16:                                  ; preds = %land.lhs.true14
  %shared_hcd17 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 22
  %8 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd17, align 8, !tbaa !408
  %flags18 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %8, i32 0, i32 11
  %9 = load i64, i64* %flags18, align 8, !tbaa !84
  %and19 = and i64 %9, 16
  %tobool20 = icmp ne i64 %and19, 0
  br i1 %tobool20, label %cleanup, label %if.end22

if.end22:                                         ; preds = %land.lhs.true16, %land.lhs.true14, %if.end12
  %driver23 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 8
  %10 = load %struct.hc_driver*, %struct.hc_driver** %driver23, align 8, !tbaa !57
  %pci_suspend24 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %10, i32 0, i32 7
  %11 = load i32 (%struct.usb_hcd*, i1)*, i32 (%struct.usb_hcd*, i1)** %pci_suspend24, align 8, !tbaa !845
  %tobool25 = trunc i8 %frombool to i1
  %call26 = call i32 %11(%struct.usb_hcd* %2, i1 zeroext %tobool25)
  %driver27 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 8
  %12 = load %struct.hc_driver*, %struct.hc_driver** %driver27, align 8, !tbaa !57
  %pci_suspend28 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %12, i32 0, i32 7
  %13 = load i32 (%struct.usb_hcd*, i1)*, i32 (%struct.usb_hcd*, i1)** %pci_suspend28, align 8, !tbaa !845
  %14 = bitcast i32 (%struct.usb_hcd*, i1)* %13 to i8*
  call void @__suspend_report_result(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.suspend_common, i32 0, i32 0), i8* %14, i32 %call26)
  %cond = icmp eq i32 %call26, 0
  br i1 %cond, label %land.lhs.true29, label %if.end54

land.lhs.true29:                                  ; preds = %if.end22
  %tobool30 = trunc i8 %frombool to i1
  br i1 %tobool30, label %land.lhs.true31, label %lor.lhs.false

land.lhs.true31:                                  ; preds = %land.lhs.true29
  %flags32 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 11
  %15 = load i64, i64* %flags32, align 8, !tbaa !84
  %and33 = and i64 %15, 16
  %tobool34 = icmp ne i64 %and33, 0
  br i1 %tobool34, label %if.then46, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true31, %land.lhs.true29
  %cmp35 = icmp eq i32 %call26, 0
  br i1 %cmp35, label %land.lhs.true36, label %if.end54

land.lhs.true36:                                  ; preds = %lor.lhs.false
  %tobool37 = trunc i8 %frombool to i1
  br i1 %tobool37, label %land.lhs.true38, label %if.end54

land.lhs.true38:                                  ; preds = %land.lhs.true36
  %shared_hcd39 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 22
  %16 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd39, align 8, !tbaa !408
  %tobool40 = icmp ne %struct.usb_hcd* %16, null
  br i1 %tobool40, label %land.lhs.true41, label %if.end54

land.lhs.true41:                                  ; preds = %land.lhs.true38
  %shared_hcd42 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 22
  %17 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd42, align 8, !tbaa !408
  %flags43 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %17, i32 0, i32 11
  %18 = load i64, i64* %flags43, align 8, !tbaa !84
  %and44 = and i64 %18, 16
  %tobool45 = icmp ne i64 %and44, 0
  br i1 %tobool45, label %if.then46, label %if.end54

if.then46:                                        ; preds = %land.lhs.true41, %land.lhs.true31
  %driver47 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 8
  %19 = load %struct.hc_driver*, %struct.hc_driver** %driver47, align 8, !tbaa !57
  %pci_resume = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %19, i32 0, i32 8
  %20 = load i32 (%struct.usb_hcd*, i1)*, i32 (%struct.usb_hcd*, i1)** %pci_resume, align 8, !tbaa !841
  %tobool48 = icmp ne i32 (%struct.usb_hcd*, i1)* %20, null
  br i1 %tobool48, label %if.then49, label %if.end54

if.then49:                                        ; preds = %if.then46
  %driver50 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 8
  %21 = load %struct.hc_driver*, %struct.hc_driver** %driver50, align 8, !tbaa !57
  %pci_resume51 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %21, i32 0, i32 8
  %22 = load i32 (%struct.usb_hcd*, i1)*, i32 (%struct.usb_hcd*, i1)** %pci_resume51, align 8, !tbaa !841
  %call52 = call i32 %22(%struct.usb_hcd* %2, i1 zeroext false)
  br label %if.end54

if.end54:                                         ; preds = %if.then49, %if.then46, %land.lhs.true41, %land.lhs.true38, %land.lhs.true36, %lor.lhs.false, %if.end22
  %retval1.0 = phi i32 [ %call26, %land.lhs.true41 ], [ %call26, %land.lhs.true38 ], [ %call26, %land.lhs.true36 ], [ %call26, %lor.lhs.false ], [ %call26, %if.end22 ], [ -16, %if.then49 ], [ -16, %if.then46 ]
  %tobool55 = icmp ne i32 %retval1.0, 0
  br i1 %tobool55, label %cleanup, label %if.end58

if.end58:                                         ; preds = %if.end54, %land.lhs.true, %if.end
  %retval1.1 = phi i32 [ %call2, %land.lhs.true ], [ %call2, %if.end ], [ %retval1.0, %if.end54 ]
  %msix_enabled = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 12
  %bf.load = load i16, i16* %msix_enabled, align 8
  %bf.lshr = lshr i16 %bf.load, 2
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool59 = icmp ne i32 %bf.cast, 0
  br i1 %tobool59, label %if.end61, label %if.then60

if.then60:                                        ; preds = %if.end58
  %irq = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %1, i32 0, i32 37
  %23 = load i32, i32* %irq, align 4, !tbaa !846
  call void @synchronize_irq(i32 %23)
  br label %if.end61

if.end61:                                         ; preds = %if.then60, %if.end58
  call void @pci_disable_device(%struct.pci_dev* %1)
  br label %cleanup

cleanup:                                          ; preds = %if.end61, %if.end54, %land.lhs.true16, %land.lhs.true7, %entry
  %retval.0 = phi i32 [ %retval1.1, %if.end61 ], [ %call2, %entry ], [ -16, %land.lhs.true7 ], [ -16, %land.lhs.true16 ], [ %retval1.0, %if.end54 ]
  ret i32 %retval.0
}

declare void @__suspend_report_result(i8*, i8*, i32) #2

declare void @synchronize_irq(i32) #2

declare void @pci_disable_device(%struct.pci_dev*) #2

declare i32 @pci_back_from_sleep(%struct.pci_dev*) #2

declare i32 @pci_save_state(%struct.pci_dev*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @device_may_wakeup.981(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %can_wakeup = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i16, i16* %can_wakeup, align 4
  %bf.clear = and i16 %bf.load, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %power1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %wakeup = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power1, i32 0, i32 5
  %0 = load %struct.wakeup_source*, %struct.wakeup_source** %wakeup, align 8, !tbaa !457
  %tobool2 = icmp ne %struct.wakeup_source* %0, null
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %1 = phi i1 [ false, %entry ], [ %lnot3, %land.rhs ]
  ret i1 %1
}

declare i32 @pci_prepare_to_sleep(%struct.pci_dev*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @pci_power_name(i32 %state) #1 {
entry:
  %add = add nsw i32 1, %state
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds [0 x i8*], [0 x i8*]* @pci_power_names, i64 0, i64 %idxprom
  %0 = load i8*, i8** %arrayidx, align 8, !tbaa !52
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_pci_shutdown(%struct.pci_dev* %dev) #0 {
entry:
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %dev)
  %0 = bitcast i8* %call to %struct.usb_hcd*
  %tobool = icmp ne %struct.usb_hcd* %0, null
  br i1 %tobool, label %cond.true, label %cleanup.cont

cond.true:                                        ; preds = %entry
  %flags = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 11
  %1 = load volatile i64, i64* %flags, align 8, !tbaa !53
  %and1.i = and i64 1, %1
  %cmp.i = icmp ne i64 %and1.i, 0
  br i1 %cmp.i, label %land.lhs.true, label %cleanup.cont

land.lhs.true:                                    ; preds = %cond.true
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 8
  %2 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %shutdown = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %2, i32 0, i32 10
  %3 = load void (%struct.usb_hcd*)*, void (%struct.usb_hcd*)** %shutdown, align 8, !tbaa !353
  %tobool4 = icmp ne void (%struct.usb_hcd*)* %3, null
  br i1 %tobool4, label %if.then5, label %cleanup.cont

if.then5:                                         ; preds = %land.lhs.true
  %driver6 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 8
  %4 = load %struct.hc_driver*, %struct.hc_driver** %driver6, align 8, !tbaa !57
  %shutdown7 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %4, i32 0, i32 10
  %5 = load void (%struct.usb_hcd*)*, void (%struct.usb_hcd*)** %shutdown7, align 8, !tbaa !353
  call void %5(%struct.usb_hcd* %0)
  %call8 = call i32 bitcast (i32 (%struct.usb_hcd.712*)* @usb_hcd_is_primary_hcd to i32 (%struct.usb_hcd*)*)(%struct.usb_hcd* %0)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %land.lhs.true10, label %if.end13

land.lhs.true10:                                  ; preds = %if.then5
  %irq = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 13
  %6 = load i32, i32* %irq, align 4, !tbaa !358
  %cmp = icmp ugt i32 %6, 0
  br i1 %cmp, label %if.then11, label %if.end13

if.then11:                                        ; preds = %land.lhs.true10
  %irq12 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 13
  %7 = load i32, i32* %irq12, align 4, !tbaa !358
  %8 = bitcast %struct.usb_hcd* %0 to i8*
  call void @free_irq(i32 %7, i8* %8)
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %land.lhs.true10, %if.then5
  call void @pci_disable_device(%struct.pci_dev* %dev)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end13, %land.lhs.true, %cond.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_pci_remove(%struct.pci_dev* %dev) #0 {
entry:
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %dev)
  %0 = bitcast i8* %call to %struct.usb_hcd*
  %tobool = icmp ne %struct.usb_hcd* %0, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %call1 = call zeroext i1 @pci_dev_run_wake(%struct.pci_dev* %dev)
  br i1 %call1, label %if.then2, label %do.body

if.then2:                                         ; preds = %if.end
  %dev3 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void @pm_runtime_get_noresume.989(%struct.device* %dev3)
  br label %do.body

do.body:                                          ; preds = %if.then2, %if.end
  call void @arch_local_irq_disable.990()
  call void @trace_hardirqs_off()
  %1 = bitcast %struct.usb_hcd* %0 to i8*
  %call5 = call i32 @usb_hcd_irq(i32 undef, i8* %1)
  call void @trace_hardirqs_on()
  call void @arch_local_irq_enable()
  %class = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 11
  %2 = load i32, i32* %class, align 4, !tbaa !842
  %cmp = icmp eq i32 %2, 787232
  br i1 %cmp, label %if.then9, label %if.else

if.then9:                                         ; preds = %do.body
  call void @down_write(%struct.rw_semaphore* @companions_rwsem)
  call void @for_each_companion(%struct.pci_dev* %dev, %struct.usb_hcd* %0, void (%struct.pci_dev*, %struct.usb_hcd*, %struct.pci_dev*, %struct.usb_hcd*)* @ehci_remove)
  call void bitcast (void (%struct.usb_hcd.712*)* @usb_remove_hcd to void (%struct.usb_hcd*)*)(%struct.usb_hcd* %0)
  %dev10 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void @dev_set_drvdata.991(%struct.device* %dev10, i8* null)
  call void @up_write(%struct.rw_semaphore* @companions_rwsem)
  br label %if.end12

if.else:                                          ; preds = %do.body
  call void @down_read(%struct.rw_semaphore* @companions_rwsem)
  %self = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 0
  %hs_companion = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 12
  store %struct.usb_bus* null, %struct.usb_bus** %hs_companion, align 8, !tbaa !847
  call void bitcast (void (%struct.usb_hcd.712*)* @usb_remove_hcd to void (%struct.usb_hcd*)*)(%struct.usb_hcd* %0)
  %dev11 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void @dev_set_drvdata.991(%struct.device* %dev11, i8* null)
  call void @up_read(%struct.rw_semaphore* @companions_rwsem)
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then9
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 8
  %3 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !57
  %flags = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %3, i32 0, i32 4
  %4 = load i32, i32* %flags, align 8, !tbaa !376
  %and = and i32 %4, 1
  %tobool13 = icmp ne i32 %and, 0
  br i1 %tobool13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.end12
  %regs = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 14
  %5 = load i8*, i8** %regs, align 8, !tbaa !848
  call void @iounmap(i8* %5)
  %rsrc_start = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 15
  %6 = load i64, i64* %rsrc_start, align 8, !tbaa !370
  %rsrc_len = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 16
  %7 = load i64, i64* %rsrc_len, align 8, !tbaa !849
  call void @__release_region(%struct.resource* @iomem_resource, i64 %6, i64 %7)
  br label %if.end18

if.else15:                                        ; preds = %if.end12
  %rsrc_start16 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 15
  %8 = load i64, i64* %rsrc_start16, align 8, !tbaa !370
  %rsrc_len17 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 16
  %9 = load i64, i64* %rsrc_len17, align 8, !tbaa !849
  call void @__release_region(%struct.resource* @ioport_resource, i64 %8, i64 %9)
  br label %if.end18

if.end18:                                         ; preds = %if.else15, %if.then14
  call void bitcast (void (%struct.usb_hcd.712*)* @usb_put_hcd to void (%struct.usb_hcd*)*)(%struct.usb_hcd* %0)
  call void @pci_disable_device(%struct.pci_dev* %dev)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end18, %entry
  ret void
}

declare zeroext i1 @pci_dev_run_wake(%struct.pci_dev*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_get_noresume.989(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %usage_count = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 12
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %usage_count, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #8, !srcloc !850
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @arch_local_irq_disable.990() #1 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 2, i32 0), align 8, !tbaa !394
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.13.994, i32 0, i32 0), i32 783, i64 12) #8, !srcloc !851
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call { i64, i8* } asm sideeffect "771:\0A\09call *${3:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${2:c}\0A  .byte 772b-771b\0A  .short ${4:c}\0A.popsection\0A", "={ax},={rsp},i,i,i,1,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 41, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 2, i32 0), i32 1, i8* undef) #8, !srcloc !852
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @arch_local_irq_enable() #1 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 3, i32 0), align 8, !tbaa !853
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.13.994, i32 0, i32 0), i32 788, i64 12) #8, !srcloc !854
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call { i64, i8* } asm sideeffect "771:\0A\09call *${3:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${2:c}\0A  .byte 772b-771b\0A  .short ${4:c}\0A.popsection\0A", "={ax},={rsp},i,i,i,1,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 42, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 3, i32 0), i32 1, i8* undef) #8, !srcloc !855
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @ehci_remove(%struct.pci_dev* %pdev, %struct.usb_hcd* %hcd, %struct.pci_dev* %companion, %struct.usb_hcd* %companion_hcd) #0 {
entry:
  %call = call i32 @is_ohci_or_uhci(%struct.pci_dev* %companion)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %self = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %companion_hcd, i32 0, i32 0
  %hs_companion = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 12
  store %struct.usb_bus* null, %struct.usb_bus** %hs_companion, align 8, !tbaa !847
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @dev_set_drvdata.991(%struct.device* %dev, i8* %data) #1 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  store i8* %data, i8** %driver_data, align 8, !tbaa !117
  ret void
}

declare void @iounmap(i8*) #2

declare void @__release_region(%struct.resource*, i64, i64) #2

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_pci_probe(%struct.pci_dev* %dev, %struct.pci_device_id* %id) #0 {
entry:
  %call = call i32 @usb_disabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup220, label %if.end

if.end:                                           ; preds = %entry
  %tobool2 = icmp ne %struct.pci_device_id* %id, null
  br i1 %tobool2, label %if.end4, label %cleanup220

if.end4:                                          ; preds = %if.end
  %driver_data = getelementptr inbounds %struct.pci_device_id, %struct.pci_device_id* %id, i32 0, i32 6
  %0 = load i64, i64* %driver_data, align 8, !tbaa !856
  %1 = inttoptr i64 %0 to %struct.hc_driver*
  %tobool5 = icmp ne %struct.hc_driver* %1, null
  br i1 %tobool5, label %if.end7, label %cleanup220

if.end7:                                          ; preds = %if.end4
  %call8 = call i32 @pci_enable_device(%struct.pci_dev* %dev)
  %cmp = icmp slt i32 %call8, 0
  br i1 %cmp, label %cleanup220, label %if.end10

if.end10:                                         ; preds = %if.end7
  %flags = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 4
  %2 = load i32, i32* %flags, align 8, !tbaa !376
  %and = and i32 %2, 112
  %cmp11 = icmp slt i32 %and, 64
  br i1 %cmp11, label %if.then12, label %if.end19

if.then12:                                        ; preds = %if.end10
  %irq = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 37
  %3 = load i32, i32* %irq, align 4, !tbaa !846
  %tobool13 = icmp ne i32 %3, 0
  br i1 %tobool13, label %if.end17, label %if.then14

if.then14:                                        ; preds = %if.then12
  %call16 = call i8* @pci_name(%struct.pci_dev* %dev)
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %disable_pci

if.end17:                                         ; preds = %if.then12
  %irq18 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 37
  %4 = load i32, i32* %irq18, align 4, !tbaa !846
  br label %if.end19

if.end19:                                         ; preds = %if.end17, %if.end10
  %hcd_irq.0 = phi i32 [ %4, %if.end17 ], [ 0, %if.end10 ]
  %dev20 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  %call21 = call i8* @pci_name(%struct.pci_dev* %dev)
  %call22 = call %struct.usb_hcd* bitcast (%struct.usb_hcd.712* (%struct.hc_driver.713*, %struct.device*, i8*)* @usb_create_hcd to %struct.usb_hcd* (%struct.hc_driver*, %struct.device*, i8*)*)(%struct.hc_driver* %1, %struct.device* %dev20, i8* %call21)
  %tobool23 = icmp ne %struct.usb_hcd* %call22, null
  br i1 %tobool23, label %if.end25, label %disable_pci

if.end25:                                         ; preds = %if.end19
  %call26 = call i32 @usb_hcd_amd_remote_wakeup_quirk(%struct.pci_dev* %dev)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end25
  %flags28 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 4
  %5 = load i32, i32* %flags28, align 8, !tbaa !376
  %and29 = and i32 %5, 80
  %tobool30 = icmp ne i32 %and29, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end25
  %6 = phi i1 [ false, %if.end25 ], [ %tobool30, %land.rhs ]
  %cond = select i1 %6, i32 1, i32 0
  %amd_resume_bug = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 12
  %7 = trunc i32 %cond to i16
  %bf.load = load i16, i16* %amd_resume_bug, align 8
  %bf.value = and i16 %7, 1
  %bf.shl = shl i16 %bf.value, 7
  %bf.clear = and i16 %bf.load, -129
  %bf.set = or i16 %bf.clear, %bf.shl
  store i16 %bf.set, i16* %amd_resume_bug, align 8
  %flags31 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 4
  %8 = load i32, i32* %flags31, align 8, !tbaa !376
  %and32 = and i32 %8, 1
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %if.then34, label %if.else

if.then34:                                        ; preds = %land.end
  %resource = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 38
  %arrayidx = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource, i64 0, i64 0
  %start = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx, i32 0, i32 0
  %9 = load i64, i64* %start, align 8, !tbaa !858
  %rsrc_start = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 15
  store i64 %9, i64* %rsrc_start, align 8, !tbaa !370
  %resource35 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 38
  %arrayidx36 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource35, i64 0, i64 0
  %start37 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx36, i32 0, i32 0
  %10 = load i64, i64* %start37, align 8, !tbaa !858
  %cmp38 = icmp eq i64 %10, 0
  br i1 %cmp38, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.then34
  %resource39 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 38
  %arrayidx40 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource39, i64 0, i64 0
  %end = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx40, i32 0, i32 1
  %11 = load i64, i64* %end, align 8, !tbaa !860
  %resource41 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 38
  %arrayidx42 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource41, i64 0, i64 0
  %start43 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx42, i32 0, i32 0
  %12 = load i64, i64* %start43, align 8, !tbaa !858
  %cmp44 = icmp eq i64 %11, %12
  br i1 %cmp44, label %cond.end, label %cond.false

cond.false:                                       ; preds = %land.lhs.true, %if.then34
  %resource45 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 38
  %arrayidx46 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource45, i64 0, i64 0
  %end47 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx46, i32 0, i32 1
  %13 = load i64, i64* %end47, align 8, !tbaa !860
  %resource48 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 38
  %arrayidx49 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource48, i64 0, i64 0
  %start50 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx49, i32 0, i32 0
  %14 = load i64, i64* %start50, align 8, !tbaa !858
  %sub = sub i64 %13, %14
  %add = add i64 %sub, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %land.lhs.true
  %cond51 = phi i64 [ %add, %cond.false ], [ 0, %land.lhs.true ]
  %rsrc_len = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 16
  store i64 %cond51, i64* %rsrc_len, align 8, !tbaa !849
  %rsrc_start52 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 15
  %15 = load i64, i64* %rsrc_start52, align 8, !tbaa !370
  %rsrc_len53 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 16
  %16 = load i64, i64* %rsrc_len53, align 8, !tbaa !849
  %description = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 0
  %17 = load i8*, i8** %description, align 8, !tbaa !368
  %call54 = call %struct.resource* @__request_region(%struct.resource* @iomem_resource, i64 %15, i64 %16, i8* %17, i32 0)
  %tobool55 = icmp ne %struct.resource* %call54, null
  br i1 %tobool55, label %if.end69, label %do.body57

do.body57:                                        ; preds = %cond.end
  %bf.load58 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_pci_probe.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load58, 18
  %bf.clear59 = and i32 %bf.lshr, 255
  %and60 = and i32 %bf.clear59, 1
  %tobool61 = icmp ne i32 %and60, 0
  %lnot = xor i1 %tobool61, true
  %lnot62 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot62 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool63 = icmp ne i64 %expval, 0
  br i1 %tobool63, label %if.then64, label %put_hcd

if.then64:                                        ; preds = %do.body57
  %dev65 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_pci_probe.descriptor to %struct._ddebug*), %struct.device* %dev65, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3.997, i32 0, i32 0))
  br label %put_hcd

if.end69:                                         ; preds = %cond.end
  %rsrc_start70 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 15
  %18 = load i64, i64* %rsrc_start70, align 8, !tbaa !370
  %rsrc_len71 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 16
  %19 = load i64, i64* %rsrc_len71, align 8, !tbaa !849
  %call72 = call i8* @ioremap_nocache(i64 %18, i64 %19)
  %regs = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 14
  store i8* %call72, i8** %regs, align 8, !tbaa !848
  %regs73 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 14
  %20 = load i8*, i8** %regs73, align 8, !tbaa !848
  %cmp74 = icmp eq i8* %20, null
  br i1 %cmp74, label %do.body78, label %if.end177

do.body78:                                        ; preds = %if.end69
  %bf.load79 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_pci_probe.descriptor.4 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr80 = lshr i32 %bf.load79, 18
  %bf.clear81 = and i32 %bf.lshr80, 255
  %and82 = and i32 %bf.clear81, 1
  %tobool83 = icmp ne i32 %and82, 0
  %lnot84 = xor i1 %tobool83, true
  %lnot86 = xor i1 %lnot84, true
  %lnot.ext87 = zext i1 %lnot86 to i32
  %conv88 = sext i32 %lnot.ext87 to i64
  %expval89 = call i64 @llvm.expect.i64(i64 %conv88, i64 0)
  %tobool90 = icmp ne i64 %expval89, 0
  br i1 %tobool90, label %if.then91, label %release_mem_region

if.then91:                                        ; preds = %do.body78
  %dev92 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_pci_probe.descriptor.4 to %struct._ddebug*), %struct.device* %dev92, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5.998, i32 0, i32 0))
  br label %release_mem_region

if.else:                                          ; preds = %land.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %region.0 = phi i32 [ 0, %if.else ], [ %inc, %for.inc ]
  %cmp99 = icmp slt i32 %region.0, 6
  br i1 %cmp99, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %resource101 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 38
  %idxprom = sext i32 %region.0 to i64
  %arrayidx102 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource101, i64 0, i64 %idxprom
  %flags103 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx102, i32 0, i32 3
  %21 = load i64, i64* %flags103, align 8, !tbaa !861
  %and104 = and i64 %21, 256
  %tobool105 = icmp ne i64 %and104, 0
  br i1 %tobool105, label %if.end107, label %for.inc

if.end107:                                        ; preds = %for.body
  %resource108 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 38
  %idxprom109 = sext i32 %region.0 to i64
  %arrayidx110 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource108, i64 0, i64 %idxprom109
  %start111 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx110, i32 0, i32 0
  %22 = load i64, i64* %start111, align 8, !tbaa !858
  %rsrc_start112 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 15
  store i64 %22, i64* %rsrc_start112, align 8, !tbaa !370
  %resource113 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 38
  %idxprom114 = sext i32 %region.0 to i64
  %arrayidx115 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource113, i64 0, i64 %idxprom114
  %start116 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx115, i32 0, i32 0
  %23 = load i64, i64* %start116, align 8, !tbaa !858
  %cmp117 = icmp eq i64 %23, 0
  br i1 %cmp117, label %land.lhs.true119, label %cond.false131

land.lhs.true119:                                 ; preds = %if.end107
  %resource120 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 38
  %idxprom121 = sext i32 %region.0 to i64
  %arrayidx122 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource120, i64 0, i64 %idxprom121
  %end123 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx122, i32 0, i32 1
  %24 = load i64, i64* %end123, align 8, !tbaa !860
  %resource124 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 38
  %idxprom125 = sext i32 %region.0 to i64
  %arrayidx126 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource124, i64 0, i64 %idxprom125
  %start127 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx126, i32 0, i32 0
  %25 = load i64, i64* %start127, align 8, !tbaa !858
  %cmp128 = icmp eq i64 %24, %25
  br i1 %cmp128, label %cond.end142, label %cond.false131

cond.false131:                                    ; preds = %land.lhs.true119, %if.end107
  %resource132 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 38
  %idxprom133 = sext i32 %region.0 to i64
  %arrayidx134 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource132, i64 0, i64 %idxprom133
  %end135 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx134, i32 0, i32 1
  %26 = load i64, i64* %end135, align 8, !tbaa !860
  %resource136 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 38
  %idxprom137 = sext i32 %region.0 to i64
  %arrayidx138 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource136, i64 0, i64 %idxprom137
  %start139 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx138, i32 0, i32 0
  %27 = load i64, i64* %start139, align 8, !tbaa !858
  %sub140 = sub i64 %26, %27
  %add141 = add i64 %sub140, 1
  br label %cond.end142

cond.end142:                                      ; preds = %cond.false131, %land.lhs.true119
  %cond143 = phi i64 [ %add141, %cond.false131 ], [ 0, %land.lhs.true119 ]
  %rsrc_len144 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 16
  store i64 %cond143, i64* %rsrc_len144, align 8, !tbaa !849
  %rsrc_start145 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 15
  %28 = load i64, i64* %rsrc_start145, align 8, !tbaa !370
  %rsrc_len146 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 16
  %29 = load i64, i64* %rsrc_len146, align 8, !tbaa !849
  %description147 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 0
  %30 = load i8*, i8** %description147, align 8, !tbaa !368
  %call148 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %28, i64 %29, i8* %30, i32 0)
  %tobool149 = icmp ne %struct.resource* %call148, null
  br i1 %tobool149, label %for.end, label %for.inc

for.inc:                                          ; preds = %cond.end142, %for.body
  %inc = add nsw i32 %region.0, 1
  br label %for.cond

for.end:                                          ; preds = %cond.end142, %for.cond
  %cmp152 = icmp eq i32 %region.0, 6
  br i1 %cmp152, label %do.body156, label %NodeBlock

do.body156:                                       ; preds = %for.end
  %bf.load157 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_pci_probe.descriptor.6 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr158 = lshr i32 %bf.load157, 18
  %bf.clear159 = and i32 %bf.lshr158, 255
  %and160 = and i32 %bf.clear159, 1
  %tobool161 = icmp ne i32 %and160, 0
  %lnot162 = xor i1 %tobool161, true
  %lnot164 = xor i1 %lnot162, true
  %lnot.ext165 = zext i1 %lnot164 to i32
  %conv166 = sext i32 %lnot.ext165 to i64
  %expval167 = call i64 @llvm.expect.i64(i64 %conv166, i64 0)
  %tobool168 = icmp ne i64 %expval167, 0
  br i1 %tobool168, label %if.then169, label %NodeBlock

if.then169:                                       ; preds = %do.body156
  %dev170 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_pci_probe.descriptor.6 to %struct._ddebug*), %struct.device* %dev170, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7.999, i32 0, i32 0))
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.then169, %do.body156, %for.end
  %cleanup.dest.slot.0 = phi i32 [ 7, %if.then169 ], [ 7, %do.body156 ], [ 0, %for.end ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 7
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 7
  br i1 %SwitchLeaf2, label %put_hcd, label %cleanup220

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end177, label %cleanup220

if.end177:                                        ; preds = %LeafBlock, %if.end69
  call void @pci_set_master(%struct.pci_dev* %dev)
  %class = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 11
  %31 = load i32, i32* %class, align 4, !tbaa !842
  %cmp178 = icmp eq i32 %31, 787232
  br i1 %cmp178, label %if.then180, label %if.else188

if.then180:                                       ; preds = %if.end177
  call void @down_write(%struct.rw_semaphore* @companions_rwsem)
  %dev181 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  %32 = bitcast %struct.usb_hcd* %call22 to i8*
  call void @dev_set_drvdata.991(%struct.device* %dev181, i8* %32)
  call void @for_each_companion(%struct.pci_dev* %dev, %struct.usb_hcd* %call22, void (%struct.pci_dev*, %struct.usb_hcd*, %struct.pci_dev*, %struct.usb_hcd*)* @ehci_pre_add)
  %call182 = call i32 bitcast (i32 (%struct.usb_hcd.712*, i32, i64)* @usb_add_hcd to i32 (%struct.usb_hcd*, i32, i64)*)(%struct.usb_hcd* %call22, i32 %hcd_irq.0, i64 128)
  %cmp183 = icmp ne i32 %call182, 0
  br i1 %cmp183, label %if.then185, label %if.end187

if.then185:                                       ; preds = %if.then180
  %dev186 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void @dev_set_drvdata.991(%struct.device* %dev186, i8* null)
  br label %if.end187

if.end187:                                        ; preds = %if.then185, %if.then180
  call void @for_each_companion(%struct.pci_dev* %dev, %struct.usb_hcd* %call22, void (%struct.pci_dev*, %struct.usb_hcd*, %struct.pci_dev*, %struct.usb_hcd*)* @ehci_post_add)
  call void @up_write(%struct.rw_semaphore* @companions_rwsem)
  br label %if.end197

if.else188:                                       ; preds = %if.end177
  call void @down_read(%struct.rw_semaphore* @companions_rwsem)
  %dev189 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  %33 = bitcast %struct.usb_hcd* %call22 to i8*
  call void @dev_set_drvdata.991(%struct.device* %dev189, i8* %33)
  %call190 = call i32 bitcast (i32 (%struct.usb_hcd.712*, i32, i64)* @usb_add_hcd to i32 (%struct.usb_hcd*, i32, i64)*)(%struct.usb_hcd* %call22, i32 %hcd_irq.0, i64 128)
  %cmp191 = icmp ne i32 %call190, 0
  br i1 %cmp191, label %if.then193, label %if.else195

if.then193:                                       ; preds = %if.else188
  %dev194 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void @dev_set_drvdata.991(%struct.device* %dev194, i8* null)
  br label %if.end196

if.else195:                                       ; preds = %if.else188
  call void @for_each_companion(%struct.pci_dev* %dev, %struct.usb_hcd* %call22, void (%struct.pci_dev*, %struct.usb_hcd*, %struct.pci_dev*, %struct.usb_hcd*)* @non_ehci_add)
  br label %if.end196

if.end196:                                        ; preds = %if.else195, %if.then193
  call void @up_read(%struct.rw_semaphore* @companions_rwsem)
  br label %if.end197

if.end197:                                        ; preds = %if.end196, %if.end187
  %retval1.1 = phi i32 [ %call182, %if.end187 ], [ %call190, %if.end196 ]
  %cmp198 = icmp ne i32 %retval1.1, 0
  br i1 %cmp198, label %unmap_registers, label %if.end201

if.end201:                                        ; preds = %if.end197
  %self = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %34 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !356
  %call202 = call i32 @device_wakeup_enable(%struct.device* %34)
  %call203 = call zeroext i1 @pci_dev_run_wake(%struct.pci_dev* %dev)
  br i1 %call203, label %if.then204, label %cleanup220

if.then204:                                       ; preds = %if.end201
  %dev205 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void @pm_runtime_put_noidle.1000(%struct.device* %dev205)
  br label %cleanup220

unmap_registers:                                  ; preds = %if.end197
  %flags207 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 4
  %35 = load i32, i32* %flags207, align 8, !tbaa !376
  %and208 = and i32 %35, 1
  %tobool209 = icmp ne i32 %and208, 0
  br i1 %tobool209, label %if.then210, label %if.else214

if.then210:                                       ; preds = %unmap_registers
  %regs211 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 14
  %36 = load i8*, i8** %regs211, align 8, !tbaa !848
  call void @iounmap(i8* %36)
  br label %release_mem_region

release_mem_region:                               ; preds = %if.then210, %if.then91, %do.body78
  %retval1.2 = phi i32 [ %retval1.1, %if.then210 ], [ -14, %if.then91 ], [ -14, %do.body78 ]
  %rsrc_start212 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 15
  %37 = load i64, i64* %rsrc_start212, align 8, !tbaa !370
  %rsrc_len213 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 16
  %38 = load i64, i64* %rsrc_len213, align 8, !tbaa !849
  call void @__release_region(%struct.resource* @iomem_resource, i64 %37, i64 %38)
  br label %put_hcd

if.else214:                                       ; preds = %unmap_registers
  %rsrc_start215 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 15
  %39 = load i64, i64* %rsrc_start215, align 8, !tbaa !370
  %rsrc_len216 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call22, i32 0, i32 16
  %40 = load i64, i64* %rsrc_len216, align 8, !tbaa !849
  call void @__release_region(%struct.resource* @ioport_resource, i64 %39, i64 %40)
  br label %put_hcd

put_hcd:                                          ; preds = %if.else214, %release_mem_region, %LeafBlock1, %if.then64, %do.body57
  %retval1.4 = phi i32 [ -16, %LeafBlock1 ], [ -16, %if.then64 ], [ -16, %do.body57 ], [ %retval1.2, %release_mem_region ], [ %retval1.1, %if.else214 ]
  call void bitcast (void (%struct.usb_hcd.712*)* @usb_put_hcd to void (%struct.usb_hcd*)*)(%struct.usb_hcd* %call22)
  br label %disable_pci

disable_pci:                                      ; preds = %put_hcd, %if.end19, %if.then14
  %retval1.5 = phi i32 [ %retval1.4, %put_hcd ], [ -19, %if.then14 ], [ -12, %if.end19 ]
  call void @pci_disable_device(%struct.pci_dev* %dev)
  %call219 = call i8* @pci_name(%struct.pci_dev* %dev)
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup220

cleanup220:                                       ; preds = %disable_pci, %if.then204, %if.end201, %LeafBlock, %LeafBlock1, %if.end7, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %retval1.5, %disable_pci ], [ -19, %entry ], [ -22, %if.end ], [ -22, %if.end4 ], [ -19, %if.end7 ], [ %retval1.1, %if.then204 ], [ %retval1.1, %if.end201 ], [ undef, %LeafBlock1 ], [ undef, %LeafBlock ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @pci_name(%struct.pci_dev* %pdev) #1 {
entry:
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  %call = call i8* @dev_name.1007(%struct.device* %dev)
  ret i8* %call
}

declare i32 @usb_hcd_amd_remote_wakeup_quirk(%struct.pci_dev*) #2

declare %struct.resource* @__request_region(%struct.resource*, i64, i64, i8*, i32) #2

declare i8* @ioremap_nocache(i64, i64) #2

; Function Attrs: nounwind uwtable
define internal void @ehci_pre_add(%struct.pci_dev* %pdev, %struct.usb_hcd* %hcd, %struct.pci_dev* %companion, %struct.usb_hcd* %companion_hcd) #0 {
entry:
  %call = call i32 @is_ohci_or_uhci(%struct.pci_dev* %companion)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %self = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %companion_hcd, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 11
  %0 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !175
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock.1012(%struct.device* %dev)
  %call1 = call i32 @usb_set_configuration(%struct.usb_device* %0, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @ehci_post_add(%struct.pci_dev* %pdev, %struct.usb_hcd* %hcd, %struct.pci_dev* %companion, %struct.usb_hcd* %companion_hcd) #0 {
entry:
  %call = call i32 @is_ohci_or_uhci(%struct.pci_dev* %companion)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end19

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  %call1 = call i8* @dev_get_drvdata.979(%struct.device* %dev)
  %tobool2 = icmp ne i8* %call1, null
  br i1 %tobool2, label %do.body4, label %if.end15

do.body4:                                         ; preds = %if.then
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @ehci_post_add.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool5 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool5, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then8, label %do.end13

if.then8:                                         ; preds = %do.body4
  %dev9 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  %dev10 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %companion, i32 0, i32 35
  %call11 = call i8* @dev_name.1007(%struct.device* %dev10)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @ehci_post_add.descriptor to %struct._ddebug*), %struct.device* %dev9, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.11.1010, i32 0, i32 0), i8* %call11)
  br label %do.end13

do.end13:                                         ; preds = %if.then8, %do.body4
  %self = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %hcd, i32 0, i32 0
  %self14 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %companion_hcd, i32 0, i32 0
  %hs_companion = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self14, i32 0, i32 12
  store %struct.usb_bus* %self, %struct.usb_bus** %hs_companion, align 8, !tbaa !847
  br label %if.end15

if.end15:                                         ; preds = %do.end13, %if.then
  %self16 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %companion_hcd, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self16, i32 0, i32 11
  %0 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !175
  %call17 = call i32 @usb_set_configuration(%struct.usb_device* %0, i32 1)
  %dev18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock.1011(%struct.device* %dev18)
  br label %if.end19

if.end19:                                         ; preds = %if.end15, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @non_ehci_add(%struct.pci_dev* %pdev, %struct.usb_hcd* %hcd, %struct.pci_dev* %companion, %struct.usb_hcd* %companion_hcd) #0 {
entry:
  %call = call i32 @is_ohci_or_uhci(%struct.pci_dev* %pdev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %entry
  %class = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %companion, i32 0, i32 11
  %0 = load i32, i32* %class, align 4, !tbaa !842
  %cmp = icmp eq i32 %0, 787232
  br i1 %cmp, label %do.body1, label %if.end10

do.body1:                                         ; preds = %land.lhs.true
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @non_ehci_add.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool2 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then5, label %do.end8

if.then5:                                         ; preds = %do.body1
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  %dev6 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %companion, i32 0, i32 35
  %call7 = call i8* @dev_name.1007(%struct.device* %dev6)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @non_ehci_add.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.12.1008, i32 0, i32 0), i8* %call7)
  br label %do.end8

do.end8:                                          ; preds = %if.then5, %do.body1
  %self = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %companion_hcd, i32 0, i32 0
  %self9 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %hcd, i32 0, i32 0
  %hs_companion = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self9, i32 0, i32 12
  store %struct.usb_bus* %self, %struct.usb_bus** %hs_companion, align 8, !tbaa !847
  br label %if.end10

if.end10:                                         ; preds = %do.end8, %land.lhs.true, %entry
  ret void
}

declare i32 @device_wakeup_enable(%struct.device*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put_noidle.1000(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %usage_count = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 12
  call void @atomic_add_unless.1002(%struct.atomic_t* %usage_count, i32 -1, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_add_unless.1002(%struct.atomic_t* %v, i32 %a, i32 %u) #1 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %0 = load volatile i32, i32* %counter.i, align 4, !tbaa !73
  %1 = bitcast i8* %arraydecay.i to i32*
  store i32 %0, i32* %1, align 4, !tbaa !73
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %2 = load i32, i32* %__val.i, align 4, !tbaa !72
  br label %for.cond.i

for.cond.i:                                       ; preds = %if.end13.i, %entry
  %c.0.i = phi i32 [ %2, %entry ], [ %3, %if.end13.i ]
  %cmp.i = icmp eq i32 %c.0.i, %u
  %lnot.ext.i = zext i1 %cmp.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv.i, i64 0) #8
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %__atomic_add_unless.1003.exit, label %if.end.i

if.end.i:                                         ; preds = %for.cond.i
  %add.i = add nsw i32 %c.0.i, %a
  %counter.i1 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %3 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; cmpxchgl $2,$1", "={ax},=*m,r,0,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter.i1, i32 %add.i, i32 %c.0.i, i32* %counter.i1) #8, !srcloc !862
  %cmp3.i = icmp eq i32 %3, %c.0.i
  %lnot.ext8.i = zext i1 %cmp3.i to i32
  %conv9.i = sext i32 %lnot.ext8.i to i64
  %expval10.i = call i64 @llvm.expect.i64(i64 %conv9.i, i64 1) #8
  %tobool11.i = icmp ne i64 %expval10.i, 0
  br i1 %tobool11.i, label %__atomic_add_unless.1003.exit, label %if.end13.i

if.end13.i:                                       ; preds = %if.end.i
  br label %for.cond.i

__atomic_add_unless.1003.exit:                    ; preds = %if.end.i, %for.cond.i
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name.1007(%struct.device* %dev) #1 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !299
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !299
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name.1009(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name.1009(%struct.kobject* %kobj) #1 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !409
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock.1011(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock.1012(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_acpi_set_power_state(%struct.usb_device* %hdev, i32 %index, i1 zeroext %enable) #0 {
entry:
  %frombool = zext i1 %enable to i8
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  %add = add nsw i32 %index, 1
  %tobool = icmp ne %struct.usb_hub* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 25
  %0 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !112
  %sub = sub nsw i32 %add, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %0, i64 %idxprom
  %1 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !52
  %call1 = call i8* @usb_get_hub_port_acpi_handle(%struct.usb_device* %hdev, i32 %add)
  %tobool2 = icmp ne i8* %call1, null
  br i1 %tobool2, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %tobool5 = trunc i8 %frombool to i1
  %. = select i1 %tobool5, i8 0, i8 4
  %conv = zext i8 %. to i32
  %call8 = call i32 @acpi_bus_set_power(i8* %call1, i32 %conv)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %do.body24, label %do.body11

do.body11:                                        ; preds = %if.end4
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_acpi_set_power_state.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool12 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool12, true
  %lnot13 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot13 to i32
  %conv14 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool15 = icmp ne i64 %expval, 0
  br i1 %tobool15, label %if.then16, label %cleanup

if.then16:                                        ; preds = %do.body11
  %dev = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  %tobool17 = trunc i8 %frombool to i1
  %conv18 = zext i1 %tobool17 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_acpi_set_power_state.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.1014, i32 0, i32 0), i32 %conv18)
  br label %cleanup

do.body24:                                        ; preds = %if.end4
  %bf.load25 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_acpi_set_power_state.descriptor.3 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr26 = lshr i32 %bf.load25, 18
  %bf.clear27 = and i32 %bf.lshr26, 255
  %and28 = and i32 %bf.clear27, 1
  %tobool29 = icmp ne i32 %and28, 0
  %lnot30 = xor i1 %tobool29, true
  %lnot32 = xor i1 %lnot30, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %expval35 = call i64 @llvm.expect.i64(i64 %conv34, i64 0)
  %tobool36 = icmp ne i64 %expval35, 0
  br i1 %tobool36, label %if.then37, label %cleanup

if.then37:                                        ; preds = %do.body24
  %dev38 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_acpi_set_power_state.descriptor.3 to %struct._ddebug*), %struct.device* %dev38, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.4.1015, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %if.then37, %do.body24, %if.then16, %do.body11, %if.end, %entry
  %retval.0 = phi i32 [ -19, %entry ], [ -22, %if.end ], [ %call8, %do.body24 ], [ %call8, %if.then37 ], [ %call8, %do.body11 ], [ %call8, %if.then16 ]
  ret i32 %retval.0
}

declare i32 @acpi_bus_set_power(i8*, i32) #2

; Function Attrs: nounwind uwtable
define zeroext i1 @usb_acpi_power_manageable(%struct.usb_device* %hdev, i32 %index) #0 {
entry:
  %add = add nsw i32 %index, 1
  %call = call i8* @usb_get_hub_port_acpi_handle(%struct.usb_device* %hdev, i32 %add)
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  %call1 = call zeroext i1 @acpi_bus_power_manageable(i8* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.then, %entry
  %retval.0 = phi i1 [ %call1, %if.then ], [ false, %entry ]
  ret i1 %retval.0
}

declare zeroext i1 @acpi_bus_power_manageable(i8*) #2

; Function Attrs: nounwind uwtable
define i32 @usb_acpi_register() #0 {
entry:
  %call = call i32 @register_acpi_bus_type(%struct.acpi_bus_type* @usb_acpi_bus)
  ret i32 %call
}

declare i32 @register_acpi_bus_type(%struct.acpi_bus_type*) #2

; Function Attrs: nounwind uwtable
define internal zeroext i1 @usb_acpi_bus_match(%struct.device* %dev) #0 {
entry:
  %call = call i32 @is_usb_device.1021(%struct.device* %dev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %call1 = call i32 @is_usb_port(%struct.device* %dev)
  %tobool2 = icmp ne i32 %call1, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %tobool2, %lor.rhs ]
  ret i1 %0
}

; Function Attrs: nounwind uwtable
define internal %struct.acpi_device* @usb_acpi_find_companion(%struct.device* %dev) #0 {
entry:
  %adev = alloca %struct.acpi_device*, align 8
  %pld = alloca %struct.acpi_pld_info*, align 8
  %call = call i32 @is_usb_device.1021(%struct.device* %dev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 8
  %2 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !79
  %tobool1 = icmp ne %struct.usb_device* %2, null
  br i1 %tobool1, label %cleanup63, label %if.end

if.end:                                           ; preds = %if.then
  %parent3 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %3 = load %struct.device*, %struct.device** %parent3, align 8, !tbaa !532
  %fwnode = getelementptr inbounds %struct.device, %struct.device* %3, i32 0, i32 27
  %4 = load %struct.fwnode_handle*, %struct.fwnode_handle** %fwnode, align 8, !tbaa !333
  %call4 = call %struct.acpi_device* @to_acpi_device_node.1022(%struct.fwnode_handle* %4)
  store %struct.acpi_device* %call4, %struct.acpi_device** %adev, align 8, !tbaa !52
  %5 = load %struct.acpi_device*, %struct.acpi_device** %adev, align 8, !tbaa !52
  %call5 = call %struct.acpi_device* @acpi_find_child_device(%struct.acpi_device* %5, i64 0, i1 zeroext false)
  br label %cleanup63

if.else:                                          ; preds = %entry
  %call6 = call i32 @is_usb_port(%struct.device* %dev)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %cleanup63

if.then8:                                         ; preds = %if.else
  %6 = bitcast %struct.device* %dev to i8*
  %add.ptr11 = getelementptr inbounds i8, i8* %6, i64 -8
  %7 = bitcast i8* %add.ptr11 to %struct.usb_port*
  %portnum = getelementptr inbounds %struct.usb_port, %struct.usb_port* %7, i32 0, i32 8
  %8 = load i8, i8* %portnum, align 8, !tbaa !203
  %conv = zext i8 %8 to i32
  %parent13 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %9 = load %struct.device*, %struct.device** %parent13, align 8, !tbaa !532
  %parent14 = getelementptr inbounds %struct.device, %struct.device* %9, i32 0, i32 0
  %10 = load %struct.device*, %struct.device** %parent14, align 8, !tbaa !532
  %11 = bitcast %struct.device* %10 to i8*
  %add.ptr16 = getelementptr inbounds i8, i8* %11, i64 -152
  %12 = bitcast i8* %add.ptr16 to %struct.usb_device*
  %parent17 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 8
  %13 = load %struct.usb_device*, %struct.usb_device** %parent17, align 8, !tbaa !79
  %tobool18 = icmp ne %struct.usb_device* %13, null
  br i1 %tobool18, label %if.else31, label %if.then19

if.then19:                                        ; preds = %if.then8
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 9
  %14 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call20 = call %struct.usb_hcd* @bus_to_hcd.1023(%struct.usb_bus* %14)
  %call21 = call i32 bitcast (i32 (%struct.usb_hcd.712*, i32)* @usb_hcd_find_raw_port_number to i32 (%struct.usb_hcd*, i32)*)(%struct.usb_hcd* %call20, i32 %conv)
  %dev22 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 11
  %fwnode23 = getelementptr inbounds %struct.device, %struct.device* %dev22, i32 0, i32 27
  %15 = load %struct.fwnode_handle*, %struct.fwnode_handle** %fwnode23, align 8, !tbaa !333
  %call24 = call %struct.acpi_device* @to_acpi_device_node.1022(%struct.fwnode_handle* %15)
  %conv25 = sext i32 %call21 to i64
  %call26 = call %struct.acpi_device* @acpi_find_child_device(%struct.acpi_device* %call24, i64 %conv25, i1 zeroext false)
  store %struct.acpi_device* %call26, %struct.acpi_device** %adev, align 8, !tbaa !52
  %16 = load %struct.acpi_device*, %struct.acpi_device** %adev, align 8, !tbaa !52
  %tobool27 = icmp ne %struct.acpi_device* %16, null
  %. = select i1 %tobool27, i32 0, i32 1
  %SwitchLeaf = icmp eq i32 %., 0
  br i1 %SwitchLeaf, label %if.end45, label %cleanup56

if.else31:                                        ; preds = %if.then8
  %parent32 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 8
  %17 = load %struct.usb_device*, %struct.usb_device** %parent32, align 8, !tbaa !79
  %portnum33 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 20
  %18 = load i8, i8* %portnum33, align 2, !tbaa !81
  %conv34 = zext i8 %18 to i32
  %call35 = call i8* @usb_get_hub_port_acpi_handle(%struct.usb_device* %17, i32 %conv34)
  %19 = bitcast i8* %call35 to i8**
  %tobool36 = icmp ne i8** %19, null
  br i1 %tobool36, label %if.end38, label %cleanup56

if.end38:                                         ; preds = %if.else31
  %20 = bitcast i8** %19 to i8*
  %call39 = call i32 @acpi_bus_get_device(i8* %20, %struct.acpi_device** %adev)
  %21 = load %struct.acpi_device*, %struct.acpi_device** %adev, align 8, !tbaa !52
  %conv40 = sext i32 %conv to i64
  %call41 = call %struct.acpi_device* @acpi_find_child_device(%struct.acpi_device* %21, i64 %conv40, i1 zeroext false)
  store %struct.acpi_device* %call41, %struct.acpi_device** %adev, align 8, !tbaa !52
  %22 = load %struct.acpi_device*, %struct.acpi_device** %adev, align 8, !tbaa !52
  %tobool42 = icmp ne %struct.acpi_device* %22, null
  br i1 %tobool42, label %if.end45, label %cleanup56

if.end45:                                         ; preds = %if.end38, %if.then19
  %23 = load %struct.acpi_device*, %struct.acpi_device** %adev, align 8, !tbaa !52
  %handle46 = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %23, i32 0, i32 1
  %24 = load i8*, i8** %handle46, align 8, !tbaa !334
  %25 = bitcast i8* %24 to i8**
  %26 = bitcast i8** %25 to i8*
  %call47 = call i32 @acpi_get_physical_device_location(i8* %26, %struct.acpi_pld_info** %pld)
  %tobool48 = icmp eq i32 %call47, 0
  %27 = load %struct.acpi_pld_info*, %struct.acpi_pld_info** %pld, align 8
  %tobool49 = icmp ne %struct.acpi_pld_info* %27, null
  %or.cond = and i1 %tobool48, %tobool49
  br i1 %or.cond, label %if.end51, label %if.then50

if.then50:                                        ; preds = %if.end45
  %28 = load %struct.acpi_device*, %struct.acpi_device** %adev, align 8, !tbaa !52
  br label %cleanup56

if.end51:                                         ; preds = %if.end45
  %29 = load %struct.acpi_pld_info*, %struct.acpi_pld_info** %pld, align 8, !tbaa !52
  %group_token = getelementptr inbounds %struct.acpi_pld_info, %struct.acpi_pld_info* %29, i32 0, i32 15
  %30 = load i8, i8* %group_token, align 2, !tbaa !863
  %conv52 = zext i8 %30 to i32
  %shl = shl i32 %conv52, 8
  %or = or i32 -2147483648, %shl
  %31 = load %struct.acpi_pld_info*, %struct.acpi_pld_info** %pld, align 8, !tbaa !52
  %group_position = getelementptr inbounds %struct.acpi_pld_info, %struct.acpi_pld_info* %31, i32 0, i32 16
  %32 = load i8, i8* %group_position, align 1, !tbaa !865
  %conv53 = zext i8 %32 to i32
  %or54 = or i32 %or, %conv53
  %location = getelementptr inbounds %struct.usb_port, %struct.usb_port* %7, i32 0, i32 6
  store i32 %or54, i32* %location, align 4, !tbaa !837
  %33 = bitcast i8** %25 to i8*
  %34 = load %struct.acpi_pld_info*, %struct.acpi_pld_info** %pld, align 8, !tbaa !52
  %call55 = call i32 @usb_acpi_get_connect_type(i8* %33, %struct.acpi_pld_info* %34)
  %connect_type = getelementptr inbounds %struct.usb_port, %struct.usb_port* %7, i32 0, i32 5
  store i32 %call55, i32* %connect_type, align 8, !tbaa !230
  %35 = load %struct.acpi_pld_info*, %struct.acpi_pld_info** %pld, align 8, !tbaa !52
  %36 = bitcast %struct.acpi_pld_info* %35 to i8*
  call void @acpi_os_free(i8* %36)
  %37 = load %struct.acpi_device*, %struct.acpi_device** %adev, align 8, !tbaa !52
  br label %cleanup56

cleanup56:                                        ; preds = %if.end51, %if.then50, %if.end38, %if.else31, %if.then19
  %retval.1 = phi %struct.acpi_device* [ %28, %if.then50 ], [ %37, %if.end51 ], [ null, %if.else31 ], [ null, %if.end38 ], [ null, %if.then19 ]
  br label %cleanup63

cleanup63:                                        ; preds = %cleanup56, %if.else, %if.end, %if.then
  %retval.2 = phi %struct.acpi_device* [ %call5, %if.end ], [ %retval.1, %cleanup56 ], [ null, %if.then ], [ null, %if.else ]
  ret %struct.acpi_device* %retval.2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_usb_device.1021(%struct.device* %dev) #1 {
entry:
  %type = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 4
  %0 = load %struct.device_type*, %struct.device_type** %type, align 8, !tbaa !91
  %cmp = icmp eq %struct.device_type* %0, @usb_device_type
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.acpi_device* @to_acpi_device_node.1022(%struct.fwnode_handle* %fwnode) #1 {
entry:
  %call = call zeroext i1 @is_acpi_device_node.1025(%struct.fwnode_handle* %fwnode)
  %0 = bitcast %struct.fwnode_handle* %fwnode to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.acpi_device*
  %cond = select i1 %call, %struct.acpi_device* %1, %struct.acpi_device* null
  ret %struct.acpi_device* %cond
}

declare %struct.acpi_device* @acpi_find_child_device(%struct.acpi_device*, i64, i1 zeroext) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_usb_port(%struct.device* %dev) #1 {
entry:
  %type = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 4
  %0 = load %struct.device_type*, %struct.device_type** %type, align 8, !tbaa !91
  %cmp = icmp eq %struct.device_type* %0, bitcast ({ i8*, %struct.attribute_group**, i32 (%struct.device.5257*, %struct.kobj_uevent_env*)*, i8* (%struct.device.5257*, i16*, %struct.atomic_t*, %struct.atomic_t*)*, void (%struct.device.5257*)*, %struct.dev_pm_ops.5256* }* @usb_port_device_type to %struct.device_type*)
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd* @bus_to_hcd.1023(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd*
  ret %struct.usb_hcd* %1
}

declare i32 @acpi_bus_get_device(i8*, %struct.acpi_device**) #2

declare i32 @acpi_get_physical_device_location(i8*, %struct.acpi_pld_info**) #2

; Function Attrs: nounwind uwtable
define internal i32 @usb_acpi_get_connect_type(i8* %handle, %struct.acpi_pld_info* %pld) #0 {
entry:
  %buffer = alloca %struct.kernel_symbol, align 8
  %0 = bitcast %struct.kernel_symbol* %buffer to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast (%struct.kernel_symbol* @usb_acpi_get_connect_type.buffer to i8*), i64 16, i32 8, i1 false)
  %call = call i32 @acpi_evaluate_object(i8* %handle, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.6.1024, i32 0, i32 0), %struct.acpi_object_list* null, %struct.kernel_symbol* %buffer)
  %pointer = getelementptr inbounds %struct.kernel_symbol, %struct.kernel_symbol* %buffer, i32 0, i32 1
  %1 = load i8*, i8** %pointer, align 8, !tbaa !866
  %2 = bitcast i8* %1 to %union.acpi_object*
  %tobool = icmp ne %union.acpi_object* %2, null
  br i1 %tobool, label %lor.lhs.false, label %out

lor.lhs.false:                                    ; preds = %entry
  %type = bitcast %union.acpi_object* %2 to i32*
  %3 = load i32, i32* %type, align 8, !tbaa !72
  %cmp = icmp ne i32 %3, 4
  br i1 %cmp, label %out, label %lor.lhs.false1

lor.lhs.false1:                                   ; preds = %lor.lhs.false
  %package = bitcast %union.acpi_object* %2 to %struct.anon.65.6589*
  %count = getelementptr inbounds %struct.anon.65.6589, %struct.anon.65.6589* %package, i32 0, i32 1
  %4 = load i32, i32* %count, align 4, !tbaa !72
  %cmp2 = icmp ne i32 %4, 4
  br i1 %cmp2, label %out, label %if.end

if.end:                                           ; preds = %lor.lhs.false1
  %package3 = bitcast %union.acpi_object* %2 to %struct.anon.65.6589*
  %elements = getelementptr inbounds %struct.anon.65.6589, %struct.anon.65.6589* %package3, i32 0, i32 2
  %5 = load %union.acpi_object*, %union.acpi_object** %elements, align 8, !tbaa !72
  %arrayidx = getelementptr inbounds %union.acpi_object, %union.acpi_object* %5, i64 0
  %integer = bitcast %union.acpi_object* %arrayidx to %struct.device_dma_parameters*
  %value = getelementptr inbounds %struct.device_dma_parameters, %struct.device_dma_parameters* %integer, i32 0, i32 1
  %6 = load i64, i64* %value, align 8, !tbaa !72
  %tobool4 = icmp ne i64 %6, 0
  %user_visible = getelementptr inbounds %struct.acpi_pld_info, %struct.acpi_pld_info* %pld, i32 0, i32 7
  %7 = load i8, i8* %user_visible, align 2, !tbaa !868
  %tobool6 = icmp ne i8 %7, 0
  %. = select i1 %tobool6, i32 1, i32 2
  %.1 = select i1 %tobool6, i32 0, i32 3
  %connect_type.2 = select i1 %tobool4, i32 %., i32 %.1
  br label %out

out:                                              ; preds = %if.end, %lor.lhs.false1, %lor.lhs.false, %entry
  %connect_type.3 = phi i32 [ 0, %lor.lhs.false1 ], [ 0, %lor.lhs.false ], [ 0, %entry ], [ %connect_type.2, %if.end ]
  %8 = bitcast %union.acpi_object* %2 to i8*
  call void @kfree(i8* %8)
  ret i32 %connect_type.3
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @acpi_os_free(i8* %memory) #1 {
entry:
  call void @kfree(i8* %memory)
  ret void
}

declare i32 @acpi_evaluate_object(i8*, i8*, %struct.acpi_object_list*, %struct.kernel_symbol*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @is_acpi_device_node.1025(%struct.fwnode_handle* %fwnode) #1 {
entry:
  %0 = bitcast %struct.fwnode_handle* %fwnode to i8*
  %call = call zeroext i1 @IS_ERR_OR_NULL.1026(i8* %0)
  br i1 %call, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %type = getelementptr inbounds %struct.fwnode_handle, %struct.fwnode_handle* %fwnode, i32 0, i32 0
  %1 = load i32, i32* %type, align 8, !tbaa !350
  %cmp = icmp eq i32 %1, 2
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  ret i1 %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR_OR_NULL.1026(i8* %ptr) #1 {
entry:
  %tobool = icmp ne i8* %ptr, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot5 = xor i1 %cmp, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %expval10 = call i64 @llvm.expect.i64(i64 %conv9, i64 0)
  %tobool11 = icmp ne i64 %expval10, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %tobool11, %lor.rhs ]
  ret i1 %3
}

; Function Attrs: nounwind uwtable
define void @usb_acpi_unregister() #0 {
entry:
  %call = call i32 @unregister_acpi_bus_type(%struct.acpi_bus_type* @usb_acpi_bus)
  ret void
}

declare i32 @unregister_acpi_bus_type(%struct.acpi_bus_type*) #2

declare %struct.task_struct* @"simpll__inlineasm$0"(%struct.task_struct**)

declare void @"simpll__inlineasm$0.1"(i8*, i32, i64)

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind }
attributes #4 = { nounwind readnone }
attributes #5 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { inlinehint nounwind readnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind readnone speculatable }
attributes #8 = { nounwind }
attributes #9 = { nounwind readonly }

!llvm.ident = !{!0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{!3, !7, i64 64}
!3 = !{!"usb_device", !4, i64 0, !5, i64 4, !4, i64 20, !5, i64 24, !5, i64 28, !7, i64 32, !4, i64 40, !5, i64 44, !7, i64 56, !7, i64 64, !8, i64 72, !14, i64 152, !38, i64 1576, !7, i64 1600, !7, i64 1608, !7, i64 1616, !5, i64 1624, !5, i64 1752, !7, i64 1880, !10, i64 1888, !5, i64 1890, !5, i64 1891, !4, i64 1892, !4, i64 1892, !4, i64 1892, !4, i64 1892, !4, i64 1892, !4, i64 1892, !4, i64 1892, !4, i64 1892, !4, i64 1893, !4, i64 1893, !4, i64 1893, !4, i64 1893, !4, i64 1893, !4, i64 1896, !7, i64 1904, !7, i64 1912, !7, i64 1920, !13, i64 1928, !4, i64 1944, !4, i64 1948, !18, i64 1952, !22, i64 1960, !22, i64 1968, !4, i64 1976, !4, i64 1976, !4, i64 1976, !7, i64 1984, !4, i64 1992, !5, i64 1996, !39, i64 2000, !40, i64 2008, !40, i64 2024, !4, i64 2040}
!4 = !{!"int", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!"any pointer", !5, i64 0}
!8 = !{!"usb_host_endpoint", !9, i64 0, !11, i64 9, !12, i64 15, !13, i64 24, !7, i64 40, !7, i64 48, !7, i64 56, !4, i64 64, !4, i64 68, !4, i64 72}
!9 = !{!"usb_endpoint_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !10, i64 4, !5, i64 6, !5, i64 7, !5, i64 8}
!10 = !{!"short", !5, i64 0}
!11 = !{!"usb_ss_ep_comp_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !10, i64 4}
!12 = !{!"usb_ssp_isoc_ep_comp_descriptor", !5, i64 0, !5, i64 1, !10, i64 2, !4, i64 4}
!13 = !{!"list_head", !7, i64 0, !7, i64 8}
!14 = !{!"device", !7, i64 0, !7, i64 8, !15, i64 16, !7, i64 280, !7, i64 288, !26, i64 296, !7, i64 456, !7, i64 464, !7, i64 472, !7, i64 480, !29, i64 488, !30, i64 528, !7, i64 1104, !7, i64 1112, !7, i64 1120, !13, i64 1128, !4, i64 1144, !7, i64 1152, !7, i64 1160, !35, i64 1168, !22, i64 1176, !7, i64 1184, !13, i64 1192, !7, i64 1208, !7, i64 1216, !36, i64 1224, !7, i64 1232, !7, i64 1240, !4, i64 1248, !4, i64 1252, !27, i64 1256, !13, i64 1328, !37, i64 1344, !7, i64 1376, !7, i64 1384, !7, i64 1392, !7, i64 1400, !7, i64 1408, !32, i64 1416, !32, i64 1416}
!15 = !{!"kobject", !7, i64 0, !13, i64 8, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !16, i64 56, !19, i64 64, !4, i64 256, !4, i64 256, !4, i64 256, !4, i64 256, !4, i64 256}
!16 = !{!"kref", !17, i64 0}
!17 = !{!"refcount_struct", !18, i64 0}
!18 = !{!"", !4, i64 0}
!19 = !{!"delayed_work", !20, i64 0, !24, i64 80, !7, i64 176, !4, i64 184}
!20 = !{!"work_struct", !21, i64 0, !13, i64 8, !7, i64 24, !23, i64 32}
!21 = !{!"", !22, i64 0}
!22 = !{!"long", !5, i64 0}
!23 = !{!"lockdep_map", !7, i64 0, !5, i64 8, !7, i64 24, !4, i64 32, !22, i64 40}
!24 = !{!"timer_list", !25, i64 0, !22, i64 16, !7, i64 24, !22, i64 32, !4, i64 40, !23, i64 48}
!25 = !{!"hlist_node", !7, i64 0, !7, i64 8}
!26 = !{!"mutex", !21, i64 0, !27, i64 8, !28, i64 80, !13, i64 88, !7, i64 104, !23, i64 112}
!27 = !{!"spinlock", !5, i64 0}
!28 = !{!"optimistic_spin_queue", !18, i64 0}
!29 = !{!"dev_links_info", !13, i64 0, !13, i64 16, !5, i64 32}
!30 = !{!"dev_pm_info", !31, i64 0, !4, i64 4, !4, i64 4, !32, i64 4, !32, i64 4, !32, i64 4, !32, i64 4, !32, i64 4, !32, i64 4, !32, i64 5, !27, i64 8, !13, i64 80, !33, i64 96, !7, i64 192, !32, i64 200, !32, i64 200, !32, i64 200, !24, i64 208, !22, i64 304, !20, i64 312, !34, i64 392, !7, i64 480, !18, i64 488, !18, i64 492, !4, i64 496, !4, i64 496, !4, i64 496, !4, i64 496, !4, i64 496, !4, i64 496, !32, i64 497, !4, i64 497, !4, i64 497, !4, i64 497, !4, i64 497, !4, i64 497, !4, i64 500, !5, i64 504, !5, i64 508, !4, i64 512, !4, i64 516, !22, i64 520, !22, i64 528, !22, i64 536, !22, i64 544, !7, i64 552, !7, i64 560, !7, i64 568}
!31 = !{!"pm_message", !4, i64 0}
!32 = !{!"_Bool", !5, i64 0}
!33 = !{!"completion", !4, i64 0, !34, i64 8}
!34 = !{!"__wait_queue_head", !27, i64 0, !13, i64 72}
!35 = !{!"long long", !5, i64 0}
!36 = !{!"dev_archdata", !7, i64 0}
!37 = !{!"klist_node", !7, i64 0, !13, i64 8, !16, i64 24}
!38 = !{!"usb_device_descriptor", !5, i64 0, !5, i64 1, !10, i64 2, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7, !10, i64 8, !10, i64 10, !10, i64 12, !5, i64 14, !5, i64 15, !5, i64 16, !5, i64 17}
!39 = !{!"usb2_lpm_parameters", !4, i64 0, !4, i64 4}
!40 = !{!"usb3_lpm_parameters", !4, i64 0, !4, i64 4, !4, i64 8, !4, i64 12}
!41 = !{!42, !4, i64 8}
!42 = !{!"usb_bus", !7, i64 0, !4, i64 8, !7, i64 16, !5, i64 24, !5, i64 25, !5, i64 26, !4, i64 27, !4, i64 27, !4, i64 27, !4, i64 27, !4, i64 28, !4, i64 32, !26, i64 40, !43, i64 200, !7, i64 216, !7, i64 224, !4, i64 232, !4, i64 236, !4, i64 240, !4, i64 244, !7, i64 248, !4, i64 256}
!43 = !{!"usb_devmap", !5, i64 0}
!44 = !{!3, !4, i64 0}
!45 = !{!3, !7, i64 1904}
!46 = !{!3, !7, i64 1912}
!47 = !{!3, !7, i64 1920}
!48 = !{!31, !4, i64 0}
!49 = !{!50, !5, i64 0}
!50 = !{!"usb_descriptor_header", !5, i64 0, !5, i64 1}
!51 = !{!50, !5, i64 1}
!52 = !{!7, !7, i64 0}
!53 = !{!22, !22, i64 0}
!54 = !{!3, !5, i64 24}
!55 = !{!56, !5, i64 36}
!56 = !{!"usb_interface", !7, i64 0, !7, i64 8, !4, i64 16, !7, i64 24, !4, i64 32, !5, i64 36, !4, i64 40, !4, i64 40, !4, i64 40, !4, i64 40, !4, i64 40, !4, i64 40, !4, i64 40, !4, i64 40, !14, i64 48, !7, i64 1472, !18, i64 1480, !20, i64 1488}
!57 = !{!58, !7, i64 496}
!58 = !{!"usb_hcd", !42, i64 0, !16, i64 264, !7, i64 272, !4, i64 280, !5, i64 284, !24, i64 312, !7, i64 408, !20, i64 416, !7, i64 496, !7, i64 504, !7, i64 512, !22, i64 520, !4, i64 528, !4, i64 528, !4, i64 528, !4, i64 528, !4, i64 528, !4, i64 528, !4, i64 528, !4, i64 528, !4, i64 529, !4, i64 529, !4, i64 529, !4, i64 532, !7, i64 536, !35, i64 544, !35, i64 552, !4, i64 560, !59, i64 568, !59, i64 712, !7, i64 856, !7, i64 864, !7, i64 872, !7, i64 880, !5, i64 888, !4, i64 920, !5, i64 928}
!59 = !{!"giveback_urb_bh", !32, i64 0, !27, i64 8, !13, i64 80, !60, i64 96, !7, i64 136}
!60 = !{!"tasklet_struct", !7, i64 0, !22, i64 8, !18, i64 16, !7, i64 24, !22, i64 32}
!61 = !{!62, !7, i64 208}
!62 = !{!"hc_driver", !7, i64 0, !7, i64 8, !22, i64 16, !7, i64 24, !4, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !7, i64 112, !7, i64 120, !7, i64 128, !7, i64 136, !7, i64 144, !7, i64 152, !7, i64 160, !7, i64 168, !7, i64 176, !7, i64 184, !7, i64 192, !7, i64 200, !7, i64 208, !7, i64 216, !7, i64 224, !7, i64 232, !7, i64 240, !7, i64 248, !7, i64 256, !7, i64 264, !7, i64 272, !7, i64 280, !7, i64 288, !7, i64 296, !7, i64 304, !7, i64 312, !7, i64 320, !7, i64 328, !7, i64 336, !7, i64 344}
!63 = !{!3, !7, i64 608}
!64 = !{!3, !7, i64 440}
!65 = !{!3, !7, i64 1536}
!66 = !{!42, !7, i64 0}
!67 = !{!14, !7, i64 1160}
!68 = !{!3, !7, i64 1312}
!69 = !{!14, !22, i64 1176}
!70 = !{!3, !22, i64 1328}
!71 = !{!3, !4, i64 2040}
!72 = !{!5, !5, i64 0}
!73 = !{!4, !4, i64 0}
!74 = !{!3, !5, i64 72}
!75 = !{!3, !5, i64 73}
!76 = !{!3, !4, i64 20}
!77 = !{!3, !7, i64 152}
!78 = !{!3, !5, i64 1891}
!79 = !{!3, !7, i64 56}
!80 = !{!3, !7, i64 1384}
!81 = !{!3, !5, i64 1890}
!82 = !{!3, !22, i64 1968}
!83 = !{!3, !22, i64 1960}
!84 = !{!58, !22, i64 520}
!85 = !{!14, !4, i64 1144}
!86 = !{!35, !35, i64 0}
!87 = !{!13, !7, i64 8}
!88 = !{!89, !7, i64 0}
!89 = !{!"each_dev_arg", !7, i64 0, !7, i64 8}
!90 = !{!89, !7, i64 8}
!91 = !{!14, !7, i64 288}
!92 = !{!93, !4, i64 0}
!93 = !{!"find_interface_arg", !4, i64 0, !7, i64 8}
!94 = !{!93, !7, i64 8}
!95 = !{!14, !7, i64 464}
!96 = !{!56, !4, i64 32}
!97 = !{!56, !4, i64 16}
!98 = !{!56, !7, i64 0}
!99 = !{!100, !5, i64 3}
!100 = !{!"usb_host_interface", !101, i64 0, !4, i64 12, !7, i64 16, !7, i64 24, !7, i64 32}
!101 = !{!"usb_interface_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7, !5, i64 8}
!102 = !{!3, !7, i64 1616}
!103 = !{!104, !5, i64 4}
!104 = !{!"usb_host_config", !105, i64 0, !7, i64 16, !5, i64 24, !5, i64 152, !5, i64 408, !7, i64 664, !4, i64 672}
!105 = !{!"usb_config_descriptor", !5, i64 0, !5, i64 1, !10, i64 2, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7, !5, i64 8}
!106 = !{!100, !5, i64 2}
!107 = !{!108, !4, i64 0}
!108 = !{!"usb_interface_cache", !4, i64 0, !16, i64 4, !5, i64 8}
!109 = !{!32, !32, i64 0}
!110 = !{i8 0, i8 2}
!111 = !{!3, !4, i64 1944}
!112 = !{!113, !7, i64 976}
!113 = !{!"usb_hub", !7, i64 0, !7, i64 8, !16, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !26, i64 48, !4, i64 208, !4, i64 212, !5, i64 216, !5, i64 224, !5, i64 232, !5, i64 240, !5, i64 248, !5, i64 256, !5, i64 264, !7, i64 272, !114, i64 280, !4, i64 472, !4, i64 476, !4, i64 480, !4, i64 480, !4, i64 480, !4, i64 480, !4, i64 480, !4, i64 480, !5, i64 481, !19, i64 512, !19, i64 704, !20, i64 896, !7, i64 976}
!114 = !{!"usb_tt", !7, i64 0, !4, i64 8, !4, i64 12, !7, i64 16, !27, i64 24, !13, i64 96, !20, i64 112}
!115 = !{!116, !7, i64 0}
!116 = !{!"usb_port", !7, i64 0, !14, i64 8, !7, i64 1432, !7, i64 1440, !7, i64 1448, !5, i64 1456, !4, i64 1460, !26, i64 1464, !5, i64 1624, !4, i64 1625, !4, i64 1625, !4, i64 1625}
!117 = !{!14, !7, i64 480}
!118 = !{!56, !7, i64 512}
!119 = !{!120, !7, i64 56}
!120 = !{!"usb_driver", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !121, i64 80, !122, i64 168, !4, i64 296, !4, i64 296, !4, i64 296, !4, i64 296}
!121 = !{!"usb_dynids", !27, i64 0, !13, i64 72}
!122 = !{!"usbdrv_wrap", !123, i64 0, !4, i64 120}
!123 = !{!"device_driver", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !32, i64 32, !5, i64 36, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !7, i64 112}
!124 = !{!120, !7, i64 64}
!125 = !{i32 -2146478321}
!126 = !{!127, !4, i64 28}
!127 = !{!"task_struct", !128, i64 0, !22, i64 8, !7, i64 16, !18, i64 24, !4, i64 28, !4, i64 32, !129, i64 40, !4, i64 48, !4, i64 52, !4, i64 56, !22, i64 64, !7, i64 72, !4, i64 80, !4, i64 84, !4, i64 88, !4, i64 92, !4, i64 96, !4, i64 100, !7, i64 104, !130, i64 128, !135, i64 576, !7, i64 648, !136, i64 656, !139, i64 808, !4, i64 816, !4, i64 820, !4, i64 824, !140, i64 832, !22, i64 1856, !32, i64 1864, !13, i64 1872, !4, i64 1888, !141, i64 1896, !13, i64 1928, !142, i64 1944, !132, i64 1984, !7, i64 2008, !7, i64 2016, !143, i64 2024, !144, i64 2064, !4, i64 2084, !4, i64 2088, !4, i64 2092, !4, i64 2096, !22, i64 2104, !4, i64 2112, !4, i64 2116, !4, i64 2116, !4, i64 2116, !4, i64 2116, !4, i64 2120, !4, i64 2120, !4, i64 2120, !4, i64 2120, !4, i64 2120, !4, i64 2120, !4, i64 2120, !4, i64 2120, !22, i64 2128, !145, i64 2136, !4, i64 2184, !4, i64 2188, !7, i64 2192, !7, i64 2200, !13, i64 2208, !13, i64 2224, !7, i64 2240, !13, i64 2248, !13, i64 2264, !5, i64 2280, !13, i64 2352, !13, i64 2368, !7, i64 2384, !7, i64 2392, !7, i64 2400, !35, i64 2408, !35, i64 2416, !35, i64 2424, !146, i64 2432, !22, i64 2520, !22, i64 2528, !35, i64 2536, !35, i64 2544, !22, i64 2552, !22, i64 2560, !149, i64 2568, !5, i64 2592, !7, i64 2640, !7, i64 2648, !7, i64 2656, !5, i64 2664, !7, i64 2680, !150, i64 2688, !151, i64 2696, !22, i64 2712, !7, i64 2720, !7, i64 2728, !7, i64 2736, !7, i64 2744, !7, i64 2752, !152, i64 2760, !152, i64 2768, !152, i64 2776, !153, i64 2784, !22, i64 2808, !22, i64 2816, !4, i64 2824, !7, i64 2832, !7, i64 2840, !18, i64 2848, !4, i64 2852, !154, i64 2856, !4, i64 2872, !4, i64 2876, !27, i64 2880, !147, i64 2952, !155, i64 3024, !156, i64 3032, !7, i64 3040, !7, i64 3048, !7, i64 3056, !4, i64 3064, !22, i64 3072, !22, i64 3080, !4, i64 3088, !4, i64 3092, !4, i64 3096, !4, i64 3100, !22, i64 3104, !22, i64 3112, !4, i64 3120, !4, i64 3124, !4, i64 3128, !4, i64 3132, !35, i64 3136, !4, i64 3144, !4, i64 3148, !5, i64 3152, !4, i64 5840, !4, i64 5844, !7, i64 5848, !7, i64 5856, !7, i64 5864, !7, i64 5872, !7, i64 5880, !7, i64 5888, !22, i64 5896, !7, i64 5904, !157, i64 5912, !35, i64 5968, !35, i64 5976, !35, i64 5984, !152, i64 5992, !158, i64 6120, !4, i64 6176, !4, i64 6180, !7, i64 6184, !13, i64 6192, !4, i64 6208, !7, i64 6216, !7, i64 6224, !13, i64 6232, !7, i64 6248, !5, i64 6256, !26, i64 6272, !13, i64 6432, !7, i64 6448, !10, i64 6456, !10, i64 6458, !4, i64 6460, !4, i64 6464, !4, i64 6468, !4, i64 6472, !22, i64 6480, !35, i64 6488, !35, i64 6496, !35, i64 6504, !159, i64 6512, !13, i64 6528, !7, i64 6544, !7, i64 6552, !22, i64 6560, !5, i64 6568, !22, i64 6592, !160, i64 6600, !159, i64 7632, !7, i64 7648, !161, i64 7656, !7, i64 7672, !4, i64 7680, !4, i64 7684, !4, i64 7688, !22, i64 7696, !4, i64 7704, !5, i64 7712, !35, i64 11552, !35, i64 11560, !4, i64 11568, !4, i64 11572, !7, i64 11576, !35, i64 11584, !18, i64 11592, !18, i64 11596, !22, i64 11600, !22, i64 11608, !5, i64 11616, !4, i64 11620, !7, i64 11624, !7, i64 11632, !7, i64 11640, !4, i64 11648, !4, i64 11652, !4, i64 11656, !7, i64 11664, !4, i64 11672, !4, i64 11676, !22, i64 11680, !4, i64 11688, !7, i64 11696, !18, i64 11704, !162, i64 11712}
!128 = !{!"thread_info", !22, i64 0}
!129 = !{!"llist_node", !7, i64 0}
!130 = !{!"sched_entity", !131, i64 0, !132, i64 16, !13, i64 40, !4, i64 56, !35, i64 64, !35, i64 72, !35, i64 80, !35, i64 88, !35, i64 96, !133, i64 104, !4, i64 320, !7, i64 328, !7, i64 336, !7, i64 344, !134, i64 384}
!131 = !{!"load_weight", !22, i64 0, !4, i64 8}
!132 = !{!"rb_node", !22, i64 0, !7, i64 8, !7, i64 16}
!133 = !{!"sched_statistics", !35, i64 0, !35, i64 8, !35, i64 16, !35, i64 24, !35, i64 32, !35, i64 40, !35, i64 48, !35, i64 56, !35, i64 64, !35, i64 72, !35, i64 80, !35, i64 88, !35, i64 96, !35, i64 104, !35, i64 112, !35, i64 120, !35, i64 128, !35, i64 136, !35, i64 144, !35, i64 152, !35, i64 160, !35, i64 168, !35, i64 176, !35, i64 184, !35, i64 192, !35, i64 200, !35, i64 208}
!134 = !{!"sched_avg", !35, i64 0, !35, i64 8, !4, i64 16, !4, i64 20, !22, i64 24, !22, i64 32}
!135 = !{!"sched_rt_entity", !13, i64 0, !22, i64 16, !22, i64 24, !4, i64 32, !10, i64 36, !10, i64 38, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64}
!136 = !{!"sched_dl_entity", !132, i64 0, !35, i64 24, !35, i64 32, !35, i64 40, !35, i64 48, !35, i64 56, !35, i64 64, !4, i64 72, !4, i64 76, !4, i64 80, !4, i64 84, !137, i64 88}
!137 = !{!"hrtimer", !138, i64 0, !35, i64 32, !7, i64 40, !7, i64 48, !5, i64 56, !5, i64 57}
!138 = !{!"timerqueue_node", !132, i64 0, !35, i64 24}
!139 = !{!"hlist_head", !7, i64 0}
!140 = !{!"cpumask", !5, i64 0}
!141 = !{!"sched_info", !22, i64 0, !35, i64 8, !35, i64 16, !35, i64 24}
!142 = !{!"plist_node", !4, i64 0, !13, i64 8, !13, i64 24}
!143 = !{!"vmacache", !4, i64 0, !5, i64 8}
!144 = !{!"task_rss_stat", !4, i64 0, !5, i64 4}
!145 = !{!"restart_block", !7, i64 0, !5, i64 8}
!146 = !{!"prev_cputime", !35, i64 0, !35, i64 8, !147, i64 16}
!147 = !{!"raw_spinlock", !148, i64 0, !4, i64 4, !4, i64 8, !7, i64 16, !23, i64 24}
!148 = !{!"qspinlock", !18, i64 0}
!149 = !{!"task_cputime", !35, i64 0, !35, i64 8, !35, i64 16}
!150 = !{!"sysv_sem", !7, i64 0}
!151 = !{!"sysv_shm", !13, i64 0}
!152 = !{!"", !5, i64 0}
!153 = !{!"sigpending", !13, i64 0, !152, i64 16}
!154 = !{!"seccomp", !4, i64 0, !7, i64 8}
!155 = !{!"wake_q_node", !7, i64 0}
!156 = !{!"rb_root", !7, i64 0}
!157 = !{!"task_io_accounting", !35, i64 0, !35, i64 8, !35, i64 16, !35, i64 24, !35, i64 32, !35, i64 40, !35, i64 48}
!158 = !{!"seqcount", !4, i64 0, !23, i64 8}
!159 = !{!"callback_head", !7, i64 0, !7, i64 8}
!160 = !{!"tlbflush_unmap_batch", !140, i64 0, !32, i64 1024, !32, i64 1025}
!161 = !{!"page_frag", !7, i64 0, !4, i64 8, !4, i64 12}
!162 = !{!"thread_struct", !5, i64 0, !22, i64 24, !22, i64 32, !10, i64 40, !10, i64 42, !10, i64 44, !10, i64 46, !4, i64 48, !22, i64 56, !22, i64 64, !5, i64 72, !22, i64 104, !22, i64 112, !22, i64 120, !22, i64 128, !22, i64 136, !7, i64 144, !22, i64 152, !4, i64 160, !21, i64 168, !4, i64 176, !4, i64 176, !163, i64 192}
!163 = !{!"fpu", !4, i64 0, !5, i64 4, !5, i64 5, !5, i64 64}
!164 = !{i64 0, i64 1, !72, i64 1, i64 1, !72, i64 2, i64 2, !165, i64 4, i64 1, !72, i64 5, i64 1, !72, i64 6, i64 1, !72, i64 7, i64 1, !72, i64 8, i64 2, !165, i64 10, i64 2, !165, i64 12, i64 2, !165, i64 14, i64 1, !72, i64 15, i64 1, !72, i64 16, i64 1, !72, i64 17, i64 1, !72}
!165 = !{!10, !10, i64 0}
!166 = !{!3, !7, i64 1600}
!167 = !{!58, !7, i64 864}
!168 = !{!104, !5, i64 5}
!169 = !{!56, !7, i64 8}
!170 = !{!101, !5, i64 3}
!171 = !{!101, !5, i64 2}
!172 = !{!100, !5, i64 4}
!173 = !{!100, !7, i64 24}
!174 = !{!8, !4, i64 72}
!175 = !{!58, !7, i64 216}
!176 = !{!113, !7, i64 8}
!177 = !{!3, !5, i64 28}
!178 = !{!42, !5, i64 26}
!179 = !{!58, !7, i64 856}
!180 = !{!3, !10, i64 76}
!181 = !{!3, !7, i64 32}
!182 = !{!3, !4, i64 40}
!183 = !{!113, !7, i64 280}
!184 = !{!38, !5, i64 7}
!185 = !{!38, !5, i64 1}
!186 = !{!3, !5, i64 1583}
!187 = !{!3, !10, i64 1578}
!188 = !{!62, !7, i64 304}
!189 = !{!190, !7, i64 0}
!190 = !{!"usb_host_bos", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40}
!191 = !{!192, !10, i64 2}
!192 = !{!"usb_bos_descriptor", !5, i64 0, !5, i64 1, !10, i64 2, !5, i64 4}
!193 = !{!3, !5, i64 1593}
!194 = !{!3, !7, i64 1608}
!195 = !{!104, !10, i64 2}
!196 = !{!3, !7, i64 1880}
!197 = !{!105, !5, i64 5}
!198 = !{!3, !5, i64 1592}
!199 = !{!3, !4, i64 1948}
!200 = !{!104, !5, i64 7}
!201 = !{i32 -2146811766, i32 -2146811727, i32 -2146811706, i32 -2146811669, i32 -2146811646, i32 -2146811776}
!202 = !{!113, !4, i64 208}
!203 = !{!116, !5, i64 1624}
!204 = !{!113, !7, i64 0}
!205 = !{!3, !5, i64 1582}
!206 = !{!190, !7, i64 16}
!207 = !{!208, !5, i64 3}
!208 = !{!"usb_ss_cap_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !10, i64 4, !5, i64 6, !5, i64 7, !10, i64 8}
!209 = !{!62, !7, i64 320}
!210 = !{!62, !7, i64 328}
!211 = !{!208, !5, i64 7}
!212 = !{!208, !10, i64 8}
!213 = !{!3, !4, i64 2016}
!214 = !{!3, !4, i64 2012}
!215 = !{!3, !4, i64 2032}
!216 = !{!3, !4, i64 2028}
!217 = !{!218, !5, i64 0}
!218 = !{!"usb_set_sel_req", !5, i64 0, !5, i64 1, !10, i64 2, !10, i64 4}
!219 = !{!218, !5, i64 1}
!220 = !{!218, !10, i64 2}
!221 = !{!218, !10, i64 4}
!222 = !{i32 -2146811020, i32 -2146810981, i32 -2146810960, i32 -2146810923, i32 -2146810900, i32 -2146811030}
!223 = !{!62, !7, i64 296}
!224 = !{!62, !7, i64 280}
!225 = !{!62, !7, i64 272}
!226 = !{!9, !10, i64 4}
!227 = !{!190, !7, i64 8}
!228 = !{!229, !4, i64 3}
!229 = !{!"usb_ext_cap_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !4, i64 3}
!230 = !{!116, !5, i64 1456}
!231 = !{!40, !4, i64 0}
!232 = !{!113, !7, i64 272}
!233 = !{!40, !4, i64 4}
!234 = !{!40, !4, i64 8}
!235 = !{i32 641440, i32 641451, i32 -2146801706}
!236 = !{!190, !7, i64 24}
!237 = !{!113, !7, i64 40}
!238 = !{!239, !4, i64 4}
!239 = !{!"usb_ssp_cap_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !4, i64 4, !10, i64 8, !10, i64 10, !5, i64 12}
!240 = !{!3, !4, i64 2020}
!241 = !{!3, !4, i64 2036}
!242 = !{!243, !7, i64 72}
!243 = !{!"urb", !16, i64 0, !7, i64 8, !18, i64 16, !18, i64 20, !4, i64 24, !13, i64 32, !13, i64 48, !7, i64 64, !7, i64 72, !7, i64 80, !4, i64 88, !4, i64 92, !4, i64 96, !4, i64 100, !7, i64 104, !35, i64 112, !7, i64 120, !4, i64 128, !4, i64 132, !4, i64 136, !4, i64 140, !7, i64 144, !35, i64 152, !4, i64 160, !4, i64 164, !4, i64 168, !4, i64 172, !7, i64 176, !7, i64 184, !5, i64 192}
!244 = !{!243, !4, i64 88}
!245 = !{!114, !4, i64 8}
!246 = !{!247, !4, i64 16}
!247 = !{!"usb_tt_clear", !13, i64 0, !4, i64 16, !10, i64 20, !7, i64 24, !7, i64 32}
!248 = !{!247, !10, i64 20}
!249 = !{!247, !7, i64 24}
!250 = !{!243, !7, i64 80}
!251 = !{!247, !7, i64 32}
!252 = !{!13, !7, i64 0}
!253 = !{!116, !7, i64 1432}
!254 = !{i32 -2146804634, i32 -2146804595, i32 -2146804574, i32 -2146804537, i32 -2146804514, i32 -2146804505, i32 -2146804451}
!255 = !{i32 -2146803446, i32 -2146803407, i32 -2146803386, i32 -2146803349, i32 -2146803326, i32 -2146803317, i32 -2146803263}
!256 = !{!62, !7, i64 216}
!257 = !{!3, !4, i64 1400}
!258 = !{i32 -2146191124, i32 -2146191085, i32 -2146191064, i32 -2146191027, i32 -2146191004, i32 -2146191134}
!259 = !{!3, !5, i64 1591}
!260 = !{!3, !5, i64 1590}
!261 = !{!3, !5, i64 1996}
!262 = !{!263, !10, i64 3}
!263 = !{!"usb_hub_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !10, i64 3, !5, i64 5, !5, i64 6, !5, i64 7}
!264 = !{!42, !7, i64 216}
!265 = !{!266, !5, i64 2}
!266 = !{!"usb_otg_descriptor", !5, i64 0, !5, i64 1, !5, i64 2}
!267 = !{!266, !5, i64 0}
!268 = !{!3, !10, i64 1584}
!269 = !{!3, !10, i64 1586}
!270 = !{!271, !10, i64 0}
!271 = !{!"usb_device_id", !10, i64 0, !10, i64 2, !10, i64 4, !10, i64 6, !10, i64 8, !5, i64 10, !5, i64 11, !5, i64 12, !5, i64 13, !5, i64 14, !5, i64 15, !5, i64 16, !22, i64 24}
!272 = !{!271, !10, i64 2}
!273 = !{!271, !10, i64 4}
!274 = !{!271, !10, i64 6}
!275 = !{!3, !10, i64 1588}
!276 = !{!271, !10, i64 8}
!277 = !{!271, !5, i64 10}
!278 = !{!3, !5, i64 1580}
!279 = !{!271, !5, i64 11}
!280 = !{!3, !5, i64 1581}
!281 = !{!271, !5, i64 12}
!282 = !{!113, !4, i64 476}
!283 = !{!3, !4, i64 1196}
!284 = !{!62, !7, i64 160}
!285 = !{!62, !7, i64 168}
!286 = !{!100, !5, i64 6}
!287 = !{!21, !22, i64 0}
!288 = !{i64 0, i64 8, !53}
!289 = !{!20, !7, i64 24}
!290 = !{!24, !7, i64 24}
!291 = !{!24, !22, i64 32}
!292 = !{!271, !22, i64 24}
!293 = !{!113, !7, i64 24}
!294 = !{!113, !7, i64 32}
!295 = !{!296, !5, i64 0}
!296 = !{!"usbdevfs_hub_portinfo", !5, i64 0, !5, i64 1}
!297 = !{!62, !7, i64 288}
!298 = !{!263, !5, i64 5}
!299 = !{!14, !7, i64 280}
!300 = !{!56, !7, i64 48}
!301 = !{!113, !4, i64 212}
!302 = !{!263, !5, i64 2}
!303 = !{!113, !4, i64 288}
!304 = !{!113, !4, i64 292}
!305 = !{!58, !4, i64 560}
!306 = !{!3, !10, i64 1888}
!307 = !{!113, !4, i64 472}
!308 = !{!263, !5, i64 6}
!309 = !{!9, !5, i64 2}
!310 = !{!9, !5, i64 6}
!311 = !{!113, !7, i64 376}
!312 = !{!62, !7, i64 200}
!313 = !{!243, !7, i64 176}
!314 = !{!243, !4, i64 96}
!315 = !{!243, !4, i64 140}
!316 = !{!243, !7, i64 104}
!317 = !{!243, !4, i64 136}
!318 = !{!243, !7, i64 184}
!319 = !{!243, !4, i64 168}
!320 = !{!243, !4, i64 160}
!321 = !{!14, !5, i64 1036}
!322 = !{!58, !7, i64 504}
!323 = !{!62, !7, i64 192}
!324 = !{!62, !7, i64 184}
!325 = !{!326, !7, i64 224}
!326 = !{!"usb_phy", !7, i64 0, !7, i64 8, !4, i64 16, !5, i64 20, !5, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !327, i64 64, !10, i64 144, !10, i64 146, !13, i64 152, !7, i64 168, !7, i64 176, !7, i64 184, !7, i64 192, !7, i64 200, !7, i64 208, !7, i64 216, !7, i64 224}
!327 = !{!"atomic_notifier_head", !27, i64 0, !7, i64 72}
!328 = !{i32 -2142508339, i32 -2142508314, i32 -2142508044, i32 -2142508247, i32 -2142508216, i32 -2142508186}
!329 = !{!42, !4, i64 32}
!330 = !{!326, !7, i64 216}
!331 = !{!104, !5, i64 8}
!332 = !{!9, !5, i64 3}
!333 = !{!14, !7, i64 1240}
!334 = !{!335, !7, i64 8}
!335 = !{!"acpi_device", !4, i64 0, !7, i64 8, !336, i64 16, !7, i64 32, !13, i64 40, !13, i64 56, !13, i64 72, !13, i64 88, !337, i64 104, !338, i64 108, !339, i64 112, !341, i64 232, !343, i64 400, !346, i64 552, !348, i64 576, !349, i64 584, !7, i64 624, !7, i64 632, !7, i64 640, !7, i64 648, !7, i64 656, !14, i64 664, !4, i64 2088, !4, i64 2092, !13, i64 2096, !26, i64 2112, !7, i64 2272}
!336 = !{!"fwnode_handle", !5, i64 0, !7, i64 8}
!337 = !{!"acpi_device_status", !4, i64 0, !4, i64 0, !4, i64 0, !4, i64 0, !4, i64 0, !4, i64 0}
!338 = !{!"acpi_device_flags", !4, i64 0, !4, i64 0, !4, i64 0, !4, i64 0, !4, i64 0, !4, i64 0, !4, i64 0, !4, i64 0, !4, i64 1, !4, i64 1, !4, i64 1, !4, i64 1, !4, i64 1}
!339 = !{!"acpi_device_pnp", !5, i64 0, !340, i64 8, !22, i64 16, !7, i64 24, !13, i64 32, !5, i64 48, !5, i64 88, !7, i64 112}
!340 = !{!"acpi_pnp_type", !4, i64 0, !4, i64 0, !4, i64 0, !4, i64 0}
!341 = !{!"acpi_device_power", !4, i64 0, !342, i64 4, !5, i64 8}
!342 = !{!"acpi_device_power_flags", !4, i64 0, !4, i64 0, !4, i64 0, !4, i64 0, !4, i64 0, !4, i64 0, !4, i64 0}
!343 = !{!"acpi_device_wakeup", !7, i64 0, !35, i64 8, !35, i64 16, !13, i64 24, !344, i64 40, !345, i64 48, !7, i64 136, !4, i64 144}
!344 = !{!"acpi_device_wakeup_flags", !5, i64 0, !5, i64 0, !5, i64 0, !5, i64 0}
!345 = !{!"acpi_device_wakeup_context", !20, i64 0, !7, i64 80}
!346 = !{!"acpi_device_perf", !4, i64 0, !347, i64 4, !4, i64 8, !7, i64 16}
!347 = !{!"acpi_device_perf_flags", !5, i64 0}
!348 = !{!"acpi_device_dir", !7, i64 0}
!349 = !{!"acpi_device_data", !7, i64 0, !7, i64 8, !7, i64 16, !13, i64 24}
!350 = !{!336, !5, i64 0}
!351 = !{i32 -2142151624}
!352 = !{i32 -2142152931}
!353 = !{!62, !7, i64 80}
!354 = !{i32 -2146841108, i32 -2146841069, i32 -2146841048, i32 -2146841011, i32 -2146840988, i32 -2146841118}
!355 = !{!58, !4, i64 920}
!356 = !{!58, !7, i64 0}
!357 = !{!62, !7, i64 72}
!358 = !{!58, !4, i64 532}
!359 = !{!58, !7, i64 512}
!360 = !{!58, !7, i64 880}
!361 = !{!326, !7, i64 176}
!362 = !{i32 -2146841854, i32 -2146841815, i32 -2146841794, i32 -2146841757, i32 -2146841734, i32 -2146841864}
!363 = !{!58, !4, i64 280}
!364 = !{!62, !7, i64 40}
!365 = !{!62, !7, i64 48}
!366 = !{!326, !7, i64 168}
!367 = !{!62, !7, i64 24}
!368 = !{!62, !7, i64 0}
!369 = !{!58, !4, i64 8}
!370 = !{!58, !35, i64 544}
!371 = !{!14, !7, i64 1232}
!372 = !{!58, !7, i64 408}
!373 = !{!62, !7, i64 144}
!374 = !{!243, !4, i64 24}
!375 = !{!59, !32, i64 0}
!376 = !{!62, !4, i64 32}
!377 = !{!243, !7, i64 64}
!378 = !{!243, !7, i64 8}
!379 = !{!243, !4, i64 100}
!380 = !{i32 -2146270911, i32 -2146270872, i32 -2146270851, i32 -2146270814, i32 -2146270791, i32 -2146270921}
!381 = !{i32 -2146834722, i32 -2146834683, i32 -2146834662, i32 -2146834625, i32 -2146834602, i32 -2146834593, i32 -2146834539}
!382 = !{!62, !7, i64 120}
!383 = !{!42, !4, i64 256}
!384 = !{!385, !7, i64 16}
!385 = !{!"usb_mon_operations", !7, i64 0, !7, i64 8, !7, i64 16}
!386 = !{!387, !7, i64 8}
!387 = !{!"pv_irq_ops", !388, i64 0, !388, i64 8, !388, i64 16, !388, i64 24, !7, i64 32, !7, i64 40, !7, i64 48}
!388 = !{!"paravirt_callee_save", !7, i64 0}
!389 = !{i32 -2145796561, i32 -2145796536, i32 -2145796266, i32 -2145796469, i32 -2145796438, i32 -2145796408}
!390 = !{i32 -2145797062, i32 -2145796040, i32 -2145796018, i32 -2145796005, i32 -2145795682, i32 -2145795615, i32 -2145795913, i32 -2145795886, i32 -2145795858, i32 -2145795828}
!391 = !{!387, !7, i64 0}
!392 = !{i32 -2145800441, i32 -2145800416, i32 -2145800146, i32 -2145800349, i32 -2145800318, i32 -2145800288}
!393 = !{i32 -2145800912, i32 -2145798907, i32 -2145798885, i32 -2145798872, i32 -2145798549, i32 -2145798482, i32 -2145798780, i32 -2145798753, i32 -2145798725, i32 -2145798695}
!394 = !{!387, !7, i64 16}
!395 = !{i32 -2145793985, i32 -2145793960, i32 -2145793690, i32 -2145793893, i32 -2145793862, i32 -2145793832}
!396 = !{i32 -2145794470, i32 -2145793464, i32 -2145793442, i32 -2145793429, i32 -2145793106, i32 -2145793039, i32 -2145793337, i32 -2145793310, i32 -2145793282, i32 -2145793252}
!397 = !{!243, !7, i64 120}
!398 = !{!243, !4, i64 132}
!399 = !{!243, !35, i64 112}
!400 = !{!243, !35, i64 152}
!401 = !{i32 -2143150079, i32 -2143150054, i32 -2143149784, i32 -2143149987, i32 -2143149956, i32 -2143149926}
!402 = !{!403, !7, i64 56}
!403 = !{!"dma_map_ops", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !7, i64 112, !7, i64 120, !7, i64 128, !4, i64 136}
!404 = !{i32 -2143148862, i32 -2143148837, i32 -2143148567, i32 -2143148770, i32 -2143148739, i32 -2143148709}
!405 = !{!403, !7, i64 40}
!406 = !{i32 -2143151855, i32 -2143151830, i32 -2143151560, i32 -2143151763, i32 -2143151732, i32 -2143151702}
!407 = !{!14, !7, i64 1152}
!408 = !{!58, !7, i64 872}
!409 = !{!15, !7, i64 0}
!410 = !{!59, !7, i64 136}
!411 = !{!62, !22, i64 16}
!412 = !{!58, !7, i64 16}
!413 = !{!58, !5, i64 24}
!414 = !{!58, !7, i64 336}
!415 = !{!58, !22, i64 344}
!416 = !{!62, !7, i64 8}
!417 = !{!58, !7, i64 272}
!418 = !{!42, !4, i64 232}
!419 = !{!42, !4, i64 236}
!420 = !{!42, !4, i64 240}
!421 = !{!62, !7, i64 176}
!422 = !{!62, !7, i64 232}
!423 = !{!62, !7, i64 224}
!424 = !{!58, !5, i64 25}
!425 = !{!243, !7, i64 144}
!426 = !{!243, !4, i64 128}
!427 = !{!428, !4, i64 16}
!428 = !{!"scatterlist", !22, i64 0, !22, i64 8, !4, i64 16, !4, i64 20, !35, i64 24, !4, i64 32}
!429 = !{i32 -2143153078, i32 -2143153053, i32 -2143152783, i32 -2143152986, i32 -2143152955, i32 -2143152925}
!430 = !{!403, !7, i64 32}
!431 = !{!403, !7, i64 112}
!432 = !{i32 -2143151175, i32 -2143151150, i32 -2143150880, i32 -2143151083, i32 -2143151052, i32 -2143151022}
!433 = !{!403, !7, i64 48}
!434 = !{i32 -2143150672, i32 -2143150647, i32 -2143150377, i32 -2143150580, i32 -2143150549, i32 -2143150519}
!435 = !{!428, !22, i64 0}
!436 = !{i32 -2143176592, i32 -2143176567, i32 -2143176297, i32 -2143176500, i32 -2143176469, i32 -2143176439}
!437 = !{!428, !22, i64 8}
!438 = !{i32 -2143176025, i32 -2143176000, i32 -2143175730, i32 -2143175933, i32 -2143175902, i32 -2143175872}
!439 = !{i32 -2143149455, i32 -2143149430, i32 -2143149160, i32 -2143149363, i32 -2143149332, i32 -2143149302}
!440 = !{!8, !4, i64 68}
!441 = !{!42, !4, i64 244}
!442 = !{i32 -2146259796, i32 -2146259757, i32 -2146259736, i32 -2146259699, i32 -2146259676, i32 -2146259667}
!443 = !{i32 -2146271161, i32 -2146271122, i32 -2146271101, i32 -2146271064, i32 -2146271041, i32 -2146271171}
!444 = !{!62, !7, i64 96}
!445 = !{!385, !7, i64 0}
!446 = !{!62, !7, i64 112}
!447 = !{!385, !7, i64 8}
!448 = !{!449, !5, i64 0}
!449 = !{!"usb_ctrlrequest", !5, i64 0, !5, i64 1, !10, i64 2, !10, i64 4, !10, i64 6}
!450 = !{!449, !5, i64 1}
!451 = !{!449, !10, i64 2}
!452 = !{!449, !10, i64 4}
!453 = !{!449, !10, i64 6}
!454 = !{!62, !7, i64 152}
!455 = !{!105, !5, i64 7}
!456 = !{!38, !5, i64 6}
!457 = !{!14, !7, i64 720}
!458 = !{!62, !7, i64 104}
!459 = !{!8, !7, i64 32}
!460 = !{!62, !7, i64 256}
!461 = !{!62, !7, i64 248}
!462 = !{!62, !7, i64 240}
!463 = !{!62, !7, i64 264}
!464 = !{!62, !7, i64 128}
!465 = !{!62, !7, i64 136}
!466 = !{!62, !7, i64 88}
!467 = !{!62, !7, i64 336}
!468 = !{!469, !7, i64 8}
!469 = !{!"usb_anchor", !13, i64 0, !34, i64 16, !27, i64 104, !18, i64 176, !4, i64 180}
!470 = !{!469, !7, i64 0}
!471 = !{i32 -2146344735, i32 -2146344696, i32 -2146344675, i32 -2146344638, i32 -2146344615, i32 -2146344745}
!472 = !{i32 -2146344985, i32 -2146344946, i32 -2146344925, i32 -2146344888, i32 -2146344865, i32 -2146344995}
!473 = !{!8, !5, i64 11}
!474 = !{!8, !5, i64 12}
!475 = !{!243, !4, i64 164}
!476 = !{!477, !4, i64 4}
!477 = !{!"usb_iso_packet_descriptor", !4, i64 0, !4, i64 4, !4, i64 8, !4, i64 12}
!478 = !{!477, !4, i64 12}
!479 = !{!477, !4, i64 8}
!480 = !{!428, !4, i64 20}
!481 = !{i32 540830}
!482 = !{!100, !5, i64 5}
!483 = !{!100, !5, i64 7}
!484 = !{!485, !32, i64 112}
!485 = !{!"usb_cdc_parsed_header", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !32, i64 112}
!486 = !{!485, !7, i64 32}
!487 = !{!485, !7, i64 24}
!488 = !{!485, !7, i64 16}
!489 = !{!485, !7, i64 56}
!490 = !{!485, !7, i64 88}
!491 = !{!485, !7, i64 96}
!492 = !{!485, !7, i64 104}
!493 = !{!485, !7, i64 0}
!494 = !{!485, !7, i64 8}
!495 = !{!485, !7, i64 72}
!496 = !{!485, !7, i64 64}
!497 = !{!485, !7, i64 48}
!498 = !{!499, !7, i64 0}
!499 = !{!"set_config_request", !7, i64 0, !4, i64 8, !20, i64 16, !13, i64 96}
!500 = !{!499, !4, i64 8}
!501 = !{!56, !7, i64 24}
!502 = !{!56, !7, i64 504}
!503 = !{!56, !7, i64 336}
!504 = !{!56, !7, i64 1432}
!505 = !{!56, !7, i64 1208}
!506 = !{!56, !22, i64 1224}
!507 = !{!104, !7, i64 16}
!508 = !{!104, !5, i64 6}
!509 = !{!510, !5, i64 3}
!510 = !{!"usb_interface_assoc_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7}
!511 = !{!510, !5, i64 2}
!512 = !{!8, !5, i64 2}
!513 = !{!3, !4, i64 1896}
!514 = !{!515, !4, i64 96}
!515 = !{!"api_context", !33, i64 0, !4, i64 96}
!516 = !{i32 -2146365212}
!517 = !{!33, !4, i64 0}
!518 = !{!519, !4, i64 0}
!519 = !{!"usb_sg_request", !4, i64 0, !22, i64 8, !27, i64 16, !7, i64 88, !4, i64 96, !4, i64 100, !7, i64 104, !4, i64 112, !33, i64 120}
!520 = !{!519, !4, i64 100}
!521 = !{!519, !7, i64 104}
!522 = !{!519, !7, i64 88}
!523 = !{i32 1163974}
!524 = !{!519, !4, i64 112}
!525 = !{!519, !4, i64 96}
!526 = !{!42, !4, i64 28}
!527 = !{!519, !22, i64 8}
!528 = !{i32 -2143062422, i32 -2143062397, i32 -2143062127, i32 -2143062330, i32 -2143062299, i32 -2143062269}
!529 = !{i32 -2143061855, i32 -2143061830, i32 -2143061560, i32 -2143061763, i32 -2143061732, i32 -2143061702}
!530 = !{!8, !5, i64 3}
!531 = !{!8, !5, i64 6}
!532 = !{!14, !7, i64 0}
!533 = !{!120, !7, i64 72}
!534 = !{!122, !4, i64 120}
!535 = !{!271, !5, i64 13}
!536 = !{!271, !5, i64 14}
!537 = !{!271, !5, i64 15}
!538 = !{!271, !5, i64 16}
!539 = !{i32 -2146507254, i32 -2146507215, i32 -2146507194, i32 -2146507157, i32 -2146507134, i32 -2146507264}
!540 = !{i32 -2146495889, i32 -2146495850, i32 -2146495829, i32 -2146495792, i32 -2146495769, i32 -2146495760}
!541 = !{i32 -2146507004, i32 -2146506965, i32 -2146506944, i32 -2146506907, i32 -2146506884, i32 -2146507014}
!542 = !{!120, !7, i64 8}
!543 = !{!544, !7, i64 0}
!544 = !{!"usb_dynid", !13, i64 0, !271, i64 16}
!545 = !{!544, !10, i64 18}
!546 = !{!544, !10, i64 20}
!547 = !{!544, !10, i64 16}
!548 = !{!544, !5, i64 29}
!549 = !{!544, !22, i64 40}
!550 = !{!120, !4, i64 288}
!551 = !{!120, !7, i64 0}
!552 = !{!120, !7, i64 168}
!553 = !{!120, !7, i64 176}
!554 = !{!120, !7, i64 224}
!555 = !{!120, !7, i64 232}
!556 = !{!120, !7, i64 184}
!557 = !{!120, !7, i64 192}
!558 = !{!120, !7, i64 16}
!559 = !{!560, !4, i64 160}
!560 = !{!"usb_device_driver", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !122, i64 40, !4, i64 168}
!561 = !{!560, !7, i64 0}
!562 = !{!560, !7, i64 40}
!563 = !{!560, !7, i64 48}
!564 = !{!560, !7, i64 96}
!565 = !{!560, !7, i64 104}
!566 = !{!560, !7, i64 56}
!567 = !{!560, !7, i64 8}
!568 = !{!560, !7, i64 16}
!569 = !{!120, !7, i64 32}
!570 = !{!120, !7, i64 40}
!571 = !{!3, !7, i64 616}
!572 = !{!560, !7, i64 24}
!573 = !{!120, !7, i64 48}
!574 = !{!42, !7, i64 224}
!575 = !{!560, !7, i64 32}
!576 = !{!62, !7, i64 312}
!577 = !{!100, !7, i64 32}
!578 = !{!105, !10, i64 2}
!579 = !{!104, !5, i64 1}
!580 = !{!104, !5, i64 0}
!581 = !{!101, !5, i64 0}
!582 = !{!104, !7, i64 664}
!583 = !{!104, !4, i64 672}
!584 = !{!100, !7, i64 16}
!585 = !{!100, !4, i64 12}
!586 = !{!9, !5, i64 0}
!587 = !{i32 798740}
!588 = !{!8, !10, i64 4}
!589 = !{!8, !7, i64 56}
!590 = !{!8, !4, i64 64}
!591 = !{!11, !5, i64 1}
!592 = !{!8, !5, i64 9}
!593 = !{!8, !5, i64 10}
!594 = !{!8, !10, i64 13}
!595 = !{!11, !5, i64 0}
!596 = !{!11, !5, i64 2}
!597 = !{!11, !5, i64 3}
!598 = !{!11, !10, i64 4}
!599 = !{!12, !5, i64 1}
!600 = !{!192, !5, i64 0}
!601 = !{!192, !5, i64 4}
!602 = !{!603, !5, i64 0}
!603 = !{!"usb_dev_cap_header", !5, i64 0, !5, i64 1, !5, i64 2}
!604 = !{!603, !5, i64 1}
!605 = !{!603, !5, i64 2}
!606 = !{!190, !7, i64 32}
!607 = !{!190, !7, i64 40}
!608 = !{!609, !7, i64 8}
!609 = !{!"usb_class", !16, i64 0, !7, i64 8}
!610 = !{!56, !7, i64 1472}
!611 = !{!612, !7, i64 16}
!612 = !{!"usb_class_driver", !7, i64 0, !7, i64 8, !7, i64 16, !4, i64 24}
!613 = !{!612, !7, i64 0}
!614 = !{!615, !7, i64 56}
!615 = !{!"class", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !7, i64 112, !7, i64 120}
!616 = !{!612, !7, i64 8}
!617 = !{!618, !7, i64 0}
!618 = !{!"file_operations", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !7, i64 112, !7, i64 120, !7, i64 128, !7, i64 136, !7, i64 144, !7, i64 152, !7, i64 160, !7, i64 168, !7, i64 176, !7, i64 184, !7, i64 192, !7, i64 200, !7, i64 208, !7, i64 216, !7, i64 224, !7, i64 232}
!619 = !{!620, !7, i64 40}
!620 = !{!"file", !5, i64 0, !621, i64 16, !7, i64 32, !7, i64 40, !27, i64 48, !21, i64 120, !4, i64 128, !4, i64 132, !26, i64 136, !35, i64 296, !622, i64 304, !7, i64 400, !625, i64 408, !35, i64 440, !7, i64 448, !7, i64 456, !13, i64 464, !13, i64 480, !7, i64 496}
!621 = !{!"path", !7, i64 0, !7, i64 8}
!622 = !{!"fown_struct", !623, i64 0, !7, i64 72, !5, i64 80, !18, i64 84, !18, i64 88, !4, i64 92}
!623 = !{!"", !624, i64 0, !4, i64 8, !4, i64 12, !7, i64 16, !23, i64 24}
!624 = !{!"qrwlock", !18, i64 0, !148, i64 4}
!625 = !{!"file_ra_state", !22, i64 0, !4, i64 8, !4, i64 12, !4, i64 16, !4, i64 20, !35, i64 24}
!626 = !{i32 -2143124808, i32 -2143124783, i32 -2143124513, i32 -2143124716, i32 -2143124685, i32 -2143124655}
!627 = !{!618, !7, i64 96}
!628 = !{!629, !4, i64 76}
!629 = !{!"inode", !10, i64 0, !10, i64 2, !18, i64 4, !18, i64 8, !4, i64 12, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !22, i64 64, !5, i64 72, !4, i64 76, !35, i64 80, !630, i64 88, !630, i64 104, !630, i64 120, !27, i64 136, !10, i64 208, !4, i64 212, !22, i64 216, !22, i64 224, !631, i64 232, !22, i64 392, !22, i64 400, !25, i64 408, !13, i64 424, !7, i64 440, !4, i64 448, !10, i64 452, !10, i64 454, !13, i64 456, !13, i64 472, !13, i64 488, !5, i64 504, !35, i64 520, !18, i64 528, !18, i64 532, !18, i64 536, !18, i64 540, !7, i64 544, !7, i64 552, !632, i64 560, !13, i64 976, !5, i64 992, !4, i64 1000, !4, i64 1004, !139, i64 1008, !7, i64 1016, !7, i64 1024}
!630 = !{!"timespec", !22, i64 0, !22, i64 8}
!631 = !{!"rw_semaphore", !21, i64 0, !13, i64 8, !147, i64 24, !28, i64 96, !7, i64 104, !23, i64 112}
!632 = !{!"address_space", !7, i64 0, !633, i64 8, !27, i64 24, !18, i64 96, !156, i64 104, !631, i64 112, !22, i64 272, !22, i64 280, !22, i64 288, !7, i64 296, !22, i64 304, !27, i64 312, !4, i64 384, !13, i64 392, !7, i64 408}
!633 = !{!"radix_tree_root", !4, i64 0, !7, i64 8}
!634 = !{i32 -2143244581, i32 -2143244556, i32 -2143244286, i32 -2143244489, i32 -2143244458, i32 -2143244428}
!635 = !{!403, !7, i64 0}
!636 = !{i32 -2143243981, i32 -2143243956, i32 -2143243686, i32 -2143243889, i32 -2143243858, i32 -2143243828}
!637 = !{!403, !7, i64 8}
!638 = !{i32 -2145902792, i32 -2145902767, i32 -2145902497, i32 -2145902700, i32 -2145902669, i32 -2145902639}
!639 = !{i32 -2145903263, i32 -2145901258, i32 -2145901236, i32 -2145901223, i32 -2145900900, i32 -2145900833, i32 -2145901131, i32 -2145901104, i32 -2145901076, i32 -2145901046}
!640 = !{!641, !10, i64 8}
!641 = !{!"attribute", !7, i64 0, !10, i64 8, !32, i64 10, !7, i64 16, !642, i64 24}
!642 = !{!"lock_class_key", !5, i64 0}
!643 = !{!3, !4, i64 2000}
!644 = !{!3, !4, i64 2004}
!645 = !{!100, !5, i64 8}
!646 = !{!647, !7, i64 0}
!647 = !{!"ep_device", !7, i64 0, !7, i64 8, !14, i64 16}
!648 = !{!647, !7, i64 8}
!649 = !{!647, !7, i64 1400}
!650 = !{!647, !7, i64 304}
!651 = !{!647, !7, i64 16}
!652 = !{!8, !7, i64 48}
!653 = !{i32 -2146738842, i32 -2146738803, i32 -2146738782, i32 -2146738745, i32 -2146738722, i32 -2146738852}
!654 = !{!655, !4, i64 44}
!655 = !{!"async", !13, i64 0, !7, i64 16, !7, i64 24, !7, i64 32, !4, i64 40, !4, i64 44, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !4, i64 80, !4, i64 84, !4, i64 88, !5, i64 92, !5, i64 93}
!656 = !{!655, !7, i64 64}
!657 = !{!620, !7, i64 456}
!658 = !{!659, !7, i64 16}
!659 = !{!"usb_dev_state", !13, i64 0, !7, i64 16, !7, i64 24, !27, i64 32, !13, i64 104, !13, i64 120, !13, i64 136, !34, i64 152, !4, i64 240, !7, i64 248, !7, i64 256, !7, i64 264, !22, i64 272, !4, i64 280, !4, i64 284, !32, i64 288, !22, i64 296}
!660 = !{!620, !4, i64 132}
!661 = !{!662, !22, i64 8}
!662 = !{!"vm_area_struct", !22, i64 0, !22, i64 8, !7, i64 16, !7, i64 24, !132, i64 32, !22, i64 56, !7, i64 64, !663, i64 72, !22, i64 80, !664, i64 88, !13, i64 120, !7, i64 136, !7, i64 144, !22, i64 152, !7, i64 160, !7, i64 168, !7, i64 176, !665, i64 184}
!663 = !{!"pgprot", !22, i64 0}
!664 = !{!"", !132, i64 0, !22, i64 24}
!665 = !{!"vm_userfaultfd_ctx", !7, i64 0}
!666 = !{!662, !22, i64 0}
!667 = !{!668, !7, i64 32}
!668 = !{!"usb_memory", !13, i64 0, !4, i64 16, !4, i64 20, !4, i64 24, !7, i64 32, !35, i64 40, !22, i64 48, !7, i64 56}
!669 = !{!668, !35, i64 40}
!670 = !{!668, !4, i64 24}
!671 = !{!668, !7, i64 56}
!672 = !{!668, !22, i64 48}
!673 = !{!668, !4, i64 16}
!674 = !{!662, !22, i64 80}
!675 = !{!662, !7, i64 144}
!676 = !{!662, !7, i64 168}
!677 = !{!659, !22, i64 272}
!678 = !{i32 713618, i32 713629, i32 -2146729528}
!679 = !{!659, !7, i64 248}
!680 = !{!659, !7, i64 256}
!681 = !{i32 -2146731268, i32 -2146731229, i32 -2146731208, i32 -2146731171, i32 -2146731148, i32 -2146731139, i32 -2146731085}
!682 = !{i32 -2146202534, i32 -2146202495, i32 -2146202474, i32 -2146202437, i32 -2146202414, i32 -2146202405, i32 -2146202361}
!683 = !{!659, !7, i64 120}
!684 = !{!655, !7, i64 24}
!685 = !{!655, !7, i64 32}
!686 = !{!655, !7, i64 72}
!687 = !{!655, !4, i64 80}
!688 = !{!668, !4, i64 20}
!689 = !{i32 -2146180755, i32 -2146180716, i32 -2146180695, i32 -2146180658, i32 -2146180635, i32 -2146180765}
!690 = !{i32 -2146203536, i32 -2146203497, i32 -2146203476, i32 -2146203439, i32 -2146203416, i32 -2146203546}
!691 = !{!14, !4, i64 1248}
!692 = !{i32 -2146180967, i32 -2146180928, i32 -2146180907, i32 -2146180870, i32 -2146180847, i32 -2146180977}
!693 = !{i32 -2146497869}
!694 = !{!695, !4, i64 0}
!695 = !{!"usbdevfs_bulktransfer", !4, i64 0, !4, i64 4, !4, i64 8, !7, i64 16}
!696 = !{!695, !4, i64 4}
!697 = !{!695, !4, i64 8}
!698 = !{i32 -2145656600}
!699 = !{!695, !7, i64 16}
!700 = !{!127, !22, i64 11880}
!701 = !{i32 -2142070743}
!702 = !{!659, !32, i64 288}
!703 = !{i32 -2142069823}
!704 = !{!705, !4, i64 0}
!705 = !{!"usbdevfs_getdriver", !4, i64 0, !5, i64 4}
!706 = !{!123, !7, i64 0}
!707 = !{!708, !4, i64 0}
!708 = !{!"usbdevfs_connectinfo", !4, i64 0, !5, i64 4}
!709 = !{!708, !5, i64 4}
!710 = !{!711, !4, i64 0}
!711 = !{!"usbdevfs_setinterface", !4, i64 0, !4, i64 4}
!712 = !{!711, !4, i64 4}
!713 = !{i32 -2142068514}
!714 = !{i32 -2142045611}
!715 = !{i32 -2142043671}
!716 = !{i32 -2142043173}
!717 = !{i32 -2142041503}
!718 = !{i32 -2142040808}
!719 = !{i32 -2142039120}
!720 = !{i32 -2142038418}
!721 = !{i32 -2142036658}
!722 = !{i32 -2142035928}
!723 = !{i32 -2142033990}
!724 = !{!725, !4, i64 0}
!725 = !{!"usbdevfs_disconnectsignal32", !4, i64 0, !4, i64 4}
!726 = !{!659, !4, i64 240}
!727 = !{!725, !4, i64 4}
!728 = !{!659, !7, i64 264}
!729 = !{i32 -2143441282, i32 -2143441275, i32 -2143441259, i32 -2143441243, i32 -2143440954, i32 -2143441607, i32 -2143440948, i32 -2143440900, i32 -2143440836, i32 -2143440774, i32 -2143440717, i32 -2143440661, i32 -2143441527, i32 -2143441502, i32 -2143440333, i32 -2143440406, i32 -2143440319, i32 -2143440365}
!730 = !{i32 -2141947494, i32 -2141947474, i32 -2141947433, i32 -2141947412, i32 -2141947373, i32 -2141947344, i32 -2141947298, i32 -2141947273, i32 -2141947001, i32 -2141946957, i32 -2141946934, i32 -2141946901, i32 -2141946870, i32 -2141946814}
!731 = !{i32 -2143442912, i32 -2143442905, i32 -2143442889, i32 -2143442873, i32 -2143442584, i32 -2143443237, i32 -2143442578, i32 -2143442530, i32 -2143442466, i32 -2143442404, i32 -2143442347, i32 -2143442291, i32 -2143443157, i32 -2143443132, i32 -2143441963, i32 -2143442036, i32 -2143441949, i32 -2143441995}
!732 = !{!733, !4, i64 0}
!733 = !{!"usbdevfs_ioctl", !4, i64 0, !4, i64 4, !7, i64 8}
!734 = !{i32 -2141942663, i32 -2141942643, i32 -2141942602, i32 -2141942581, i32 -2141942542, i32 -2141942513, i32 -2141942467, i32 -2141942442, i32 -2141942164, i32 -2141942120, i32 -2141942097, i32 -2141942064, i32 -2141942033, i32 -2141941977}
!735 = !{!733, !4, i64 4}
!736 = !{i32 -2141937924, i32 -2141937904, i32 -2141937863, i32 -2141937842, i32 -2141937803, i32 -2141937774, i32 -2141937728, i32 -2141937703, i32 -2141937431, i32 -2141937387, i32 -2141937364, i32 -2141937331, i32 -2141937300, i32 -2141937244}
!737 = !{!733, !7, i64 8}
!738 = !{!739, !4, i64 0}
!739 = !{!"usbdevfs_disconnectsignal", !4, i64 0, !7, i64 8}
!740 = !{!739, !7, i64 8}
!741 = !{i32 -2141957410}
!742 = !{i32 -2141956487}
!743 = !{i32 -2141934746}
!744 = !{i32 -2141932783}
!745 = !{!746, !4, i64 0}
!746 = !{!"usbdevfs_disconnect_claim", !4, i64 0, !4, i64 4, !5, i64 8}
!747 = !{!746, !4, i64 4}
!748 = !{!659, !22, i64 296}
!749 = !{i32 -2142086026}
!750 = !{i32 -2142085131}
!751 = !{i32 -2142084061}
!752 = !{i32 -2146739588, i32 -2146739549, i32 -2146739528, i32 -2146739491, i32 -2146739468, i32 -2146739598}
!753 = !{!120, !7, i64 24}
!754 = !{!655, !7, i64 56}
!755 = !{i32 -2142030509, i32 -2142030489, i32 -2142030448, i32 -2142030427, i32 -2142030388, i32 -2142030359, i32 -2142030313, i32 -2142030288, i32 -2142030016, i32 -2142029972, i32 -2142029949, i32 -2142029916, i32 -2142029885, i32 -2142029829}
!756 = !{!757, !5, i64 0}
!757 = !{!"usbdevfs_urb", !5, i64 0, !5, i64 1, !4, i64 4, !4, i64 8, !7, i64 16, !4, i64 24, !4, i64 28, !4, i64 32, !5, i64 36, !4, i64 40, !4, i64 44, !7, i64 48, !5, i64 56}
!758 = !{i32 -2142025730, i32 -2142025710, i32 -2142025669, i32 -2142025648, i32 -2142025609, i32 -2142025580, i32 -2142025534, i32 -2142025509, i32 -2142025233, i32 -2142025189, i32 -2142025166, i32 -2142025133, i32 -2142025102, i32 -2142025046}
!759 = !{!757, !5, i64 1}
!760 = !{i32 -2142019295, i32 -2142019275, i32 -2142019234, i32 -2142019213, i32 -2142019174, i32 -2142019145, i32 -2142019099, i32 -2142019074, i32 -2142018800, i32 -2142018756, i32 -2142018733, i32 -2142018700, i32 -2142018669, i32 -2142018613}
!761 = !{!757, !4, i64 4}
!762 = !{i32 -2142014547, i32 -2142014527, i32 -2142014486, i32 -2142014465, i32 -2142014426, i32 -2142014397, i32 -2142014351, i32 -2142014326, i32 -2142014053, i32 -2142014009, i32 -2142013986, i32 -2142013953, i32 -2142013922, i32 -2142013866}
!763 = !{!757, !4, i64 8}
!764 = !{i32 -2142009652, i32 -2142009632, i32 -2142009591, i32 -2142009570, i32 -2142009531, i32 -2142009502, i32 -2142009456, i32 -2142009431, i32 -2142009150, i32 -2142009106, i32 -2142009083, i32 -2142009050, i32 -2142009019, i32 -2142008963}
!765 = !{!757, !4, i64 24}
!766 = !{i32 -2142004717, i32 -2142004697, i32 -2142004656, i32 -2142004635, i32 -2142004596, i32 -2142004567, i32 -2142004521, i32 -2142004496, i32 -2142004215, i32 -2142004171, i32 -2142004148, i32 -2142004115, i32 -2142004084, i32 -2142004028}
!767 = !{!757, !4, i64 28}
!768 = !{i32 -2141999820, i32 -2141999800, i32 -2141999759, i32 -2141999738, i32 -2141999699, i32 -2141999670, i32 -2141999624, i32 -2141999599, i32 -2141999320, i32 -2141999276, i32 -2141999253, i32 -2141999220, i32 -2141999189, i32 -2141999133}
!769 = !{!757, !4, i64 32}
!770 = !{i32 -2141994819, i32 -2141994799, i32 -2141994758, i32 -2141994737, i32 -2141994698, i32 -2141994669, i32 -2141994623, i32 -2141994598, i32 -2141994313, i32 -2141994269, i32 -2141994246, i32 -2141994213, i32 -2141994182, i32 -2141994126}
!771 = !{i32 -2141989902, i32 -2141989882, i32 -2141989841, i32 -2141989820, i32 -2141989781, i32 -2141989752, i32 -2141989706, i32 -2141989681, i32 -2141989402, i32 -2141989358, i32 -2141989335, i32 -2141989302, i32 -2141989271, i32 -2141989215}
!772 = !{!757, !4, i64 40}
!773 = !{i32 -2141985129, i32 -2141985109, i32 -2141985068, i32 -2141985047, i32 -2141985008, i32 -2141984979, i32 -2141984933, i32 -2141984908, i32 -2141984635, i32 -2141984591, i32 -2141984568, i32 -2141984535, i32 -2141984504, i32 -2141984448}
!774 = !{!757, !4, i64 44}
!775 = !{i32 -2141980380, i32 -2141980360, i32 -2141980319, i32 -2141980298, i32 -2141980259, i32 -2141980230, i32 -2141980184, i32 -2141980159, i32 -2141979885, i32 -2141979841, i32 -2141979818, i32 -2141979785, i32 -2141979754, i32 -2141979698}
!776 = !{!757, !7, i64 16}
!777 = !{i32 -2141975541, i32 -2141975521, i32 -2141975480, i32 -2141975459, i32 -2141975420, i32 -2141975391, i32 -2141975345, i32 -2141975320, i32 -2141975041, i32 -2141974997, i32 -2141974974, i32 -2141974941, i32 -2141974910, i32 -2141974854}
!778 = !{!757, !7, i64 48}
!779 = !{i32 -2142627329, i32 -2142627304, i32 -2142627034, i32 -2142627237, i32 -2142627206, i32 -2142627176}
!780 = !{!655, !7, i64 16}
!781 = !{!655, !5, i64 92}
!782 = !{!655, !5, i64 93}
!783 = !{!659, !4, i64 284}
!784 = !{i32 -2142630350, i32 -2142630325, i32 -2142630055, i32 -2142630258, i32 -2142630227, i32 -2142630197}
!785 = !{i32 -2142629801, i32 -2142629776, i32 -2142629506, i32 -2142629709, i32 -2142629678, i32 -2142629648}
!786 = !{i32 -2142629235, i32 -2142629210, i32 -2142628940, i32 -2142629143, i32 -2142629112, i32 -2142629082}
!787 = !{!655, !7, i64 48}
!788 = !{!655, !4, i64 84}
!789 = !{i32 -2141968513}
!790 = !{i32 -2141966662}
!791 = !{!243, !4, i64 172}
!792 = !{i32 -2141964788}
!793 = !{i32 -2141962668}
!794 = !{i32 -2141960499}
!795 = !{i32 -2141958593}
!796 = !{!797, !4, i64 0}
!797 = !{!"__wait_queue", !4, i64 0, !7, i64 8, !7, i64 16, !13, i64 24}
!798 = !{!797, !7, i64 8}
!799 = !{!797, !7, i64 16}
!800 = !{!127, !22, i64 11680}
!801 = !{!127, !22, i64 8}
!802 = !{i32 -2142046280}
!803 = !{i32 -2142058843}
!804 = !{i32 -2142056995}
!805 = !{i32 -2142055124}
!806 = !{i32 -2142053007}
!807 = !{i32 -2142050841}
!808 = !{i32 -2142048562}
!809 = !{!810, !7, i64 0}
!810 = !{!"poll_table_struct", !7, i64 0, !22, i64 8}
!811 = !{!3, !7, i64 1928}
!812 = !{!813, !4, i64 0}
!813 = !{!"siginfo", !4, i64 0, !4, i64 4, !4, i64 8, !5, i64 16}
!814 = !{!813, !4, i64 4}
!815 = !{!813, !4, i64 8}
!816 = !{!659, !4, i64 280}
!817 = !{!101, !5, i64 5}
!818 = !{!101, !5, i64 6}
!819 = !{!101, !5, i64 7}
!820 = !{i32 -2145704775}
!821 = !{i32 -2146546044}
!822 = !{!620, !35, i64 440}
!823 = !{!38, !5, i64 4}
!824 = !{!510, !5, i64 4}
!825 = !{!826, !4, i64 0}
!826 = !{!"class_info", !4, i64 0, !7, i64 8}
!827 = !{i32 -2146253107, i32 -2146253068, i32 -2146253047, i32 -2146253010, i32 -2146252987, i32 -2146253117}
!828 = !{!116, !7, i64 1448}
!829 = !{!116, !7, i64 1440}
!830 = !{i32 -2146909773, i32 -2146909734, i32 -2146909713, i32 -2146909676, i32 -2146909653, i32 -2146909783}
!831 = !{i32 -2146902641, i32 -2146902602, i32 -2146902581, i32 -2146902544, i32 -2146902521, i32 -2146902512, i32 -2146902458}
!832 = !{i32 -2146319913, i32 -2146319874, i32 -2146319853, i32 -2146319816, i32 -2146319793, i32 -2146319923}
!833 = !{!116, !7, i64 8}
!834 = !{!116, !7, i64 1392}
!835 = !{!116, !7, i64 296}
!836 = !{!116, !7, i64 472}
!837 = !{!116, !4, i64 1460}
!838 = !{!839, !4, i64 128}
!839 = !{!"pci_dev", !13, i64 0, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !4, i64 56, !10, i64 60, !10, i64 62, !10, i64 64, !10, i64 66, !4, i64 68, !5, i64 72, !5, i64 73, !10, i64 74, !5, i64 76, !5, i64 77, !5, i64 78, !5, i64 79, !5, i64 80, !5, i64 81, !10, i64 82, !7, i64 88, !7, i64 96, !35, i64 104, !840, i64 112, !4, i64 128, !5, i64 132, !4, i64 133, !4, i64 133, !4, i64 133, !4, i64 133, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 135, !4, i64 135, !4, i64 136, !4, i64 140, !7, i64 144, !4, i64 152, !14, i64 160, !4, i64 1584, !4, i64 1588, !5, i64 1592, !32, i64 2680, !4, i64 2681, !4, i64 2681, !4, i64 2681, !4, i64 2681, !4, i64 2681, !4, i64 2681, !4, i64 2681, !4, i64 2681, !4, i64 2682, !4, i64 2682, !4, i64 2682, !4, i64 2682, !4, i64 2682, !4, i64 2682, !4, i64 2682, !4, i64 2683, !4, i64 2683, !4, i64 2683, !4, i64 2683, !4, i64 2683, !4, i64 2683, !4, i64 2683, !4, i64 2683, !4, i64 2684, !4, i64 2684, !4, i64 2684, !4, i64 2684, !10, i64 2686, !18, i64 2688, !5, i64 2692, !139, i64 2760, !7, i64 2768, !4, i64 2776, !5, i64 2784, !5, i64 2920, !4, i64 3056, !4, i64 3056, !5, i64 3057, !7, i64 3064, !7, i64 3072, !5, i64 3080, !10, i64 3088, !5, i64 3090, !18, i64 3092, !35, i64 3096, !22, i64 3104, !7, i64 3112}
!840 = !{!"device_dma_parameters", !4, i64 0, !22, i64 8}
!841 = !{!62, !7, i64 64}
!842 = !{!839, !4, i64 68}
!843 = !{!839, !4, i64 56}
!844 = !{!839, !7, i64 16}
!845 = !{!62, !7, i64 56}
!846 = !{!839, !4, i64 1588}
!847 = !{!58, !7, i64 224}
!848 = !{!58, !7, i64 536}
!849 = !{!58, !35, i64 552}
!850 = !{i32 -2146343407, i32 -2146343368, i32 -2146343347, i32 -2146343310, i32 -2146343287, i32 -2146343417}
!851 = !{i32 -2145866231, i32 -2145866206, i32 -2145865936, i32 -2145866139, i32 -2145866108, i32 -2145866078}
!852 = !{i32 -2145866716, i32 -2145865710, i32 -2145865688, i32 -2145865675, i32 -2145865352, i32 -2145865285, i32 -2145865583, i32 -2145865556, i32 -2145865528, i32 -2145865498}
!853 = !{!387, !7, i64 24}
!854 = !{i32 -2145863684, i32 -2145863659, i32 -2145863389, i32 -2145863592, i32 -2145863561, i32 -2145863531}
!855 = !{i32 -2145864165, i32 -2145863163, i32 -2145863141, i32 -2145863128, i32 -2145862805, i32 -2145862738, i32 -2145863036, i32 -2145863009, i32 -2145862981, i32 -2145862951}
!856 = !{!857, !22, i64 24}
!857 = !{!"pci_device_id", !4, i64 0, !4, i64 4, !4, i64 8, !4, i64 12, !4, i64 16, !4, i64 20, !22, i64 24}
!858 = !{!859, !35, i64 0}
!859 = !{!"resource", !35, i64 0, !35, i64 8, !7, i64 16, !22, i64 24, !22, i64 32, !7, i64 40, !7, i64 48, !7, i64 56}
!860 = !{!859, !35, i64 8}
!861 = !{!859, !22, i64 24}
!862 = !{i32 -2146332042, i32 -2146332003, i32 -2146331982, i32 -2146331945, i32 -2146331922, i32 -2146331913}
!863 = !{!864, !5, i64 18}
!864 = !{!"acpi_pld_info", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !5, i64 4, !10, i64 6, !10, i64 8, !5, i64 10, !5, i64 11, !5, i64 12, !5, i64 13, !5, i64 14, !5, i64 15, !5, i64 16, !5, i64 17, !5, i64 18, !5, i64 19, !5, i64 20, !5, i64 21, !5, i64 22, !5, i64 23, !5, i64 24, !5, i64 25, !5, i64 26, !5, i64 27, !5, i64 28, !10, i64 30, !10, i64 32}
!865 = !{!864, !5, i64 19}
!866 = !{!867, !7, i64 8}
!867 = !{!"acpi_buffer", !35, i64 0, !7, i64 8}
!868 = !{!864, !5, i64 10}
