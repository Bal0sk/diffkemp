; ModuleID = 'tests/regression/kernel_modules/usbcore/usbcore_old-usbfs_memory_mb.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.arch_spinlock, i8 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.4 }
%union.anon.4 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.list_head, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.arch_spinlock = type { %union.anon.5 }
%union.anon.5 = type { i32 }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.shrink_control*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %union.anon.3, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.mutex = type { %union.anon.5, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8*, i8*, %struct.lockdep_map }
%struct.task_struct = type { i64, i8*, %union.anon.5, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.hlist_head, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, i8, i32, i32, i32, i32, i32, i32, i8, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.load_weight, i64, i64, %struct.load_weight, %struct.load_weight, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, i64, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %union.anon.25, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %union.anon.5, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i64, %struct.callback_head, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, %struct.ftrace_ret_stack*, i64, %union.anon.5, %union.anon.5, i64, i64, %struct.memcg_batch_info, i32, %union.anon.5, %struct.uprobe_task*, i32, i32 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.cpumask = type { [64 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgprot*, %union.anon.5, %union.anon.5, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.task_struct*, %struct.file*, %struct.mmu_notifier_mm*, %struct.page*, %struct.cpumask, i64, i64, i64, i32, i32, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head, %struct.lockdep_map }
%struct.mm_rss_stat = type { [3 x %struct.pgprot] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %union.anon.5, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.file = type { %union.anon.25, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.pgprot, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space*, i64 }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %union.anon.5, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.25, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %struct.pgprot, i8* }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %union.anon.5, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [44 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.pgprot, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.kernel_symbol*, i64*, i8, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, i32, i64*, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.load_weight*, void ()**, i32 }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.3 }
%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.arch_spinlock, void ()*, void ()*, %struct.tracepoint_func* }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %union.anon.5, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.5, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head, [3 x %struct.lockdep_map] }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.pgprot }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.5, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.21, i64, %union.anon.5, %union.anon.5, %union.anon.5, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.24, i32, i32, %struct.hlist_head, %union.anon.5, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.load_weight*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.21 = type { %struct.callback_head }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.22 }
%struct.pid = type { %union.anon.5, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.22 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type { i8*, i64 }
%struct.read_descriptor_t = type { i64, i64, %union.anon.3, i32 }
%struct.swap_info_struct = type opaque
%union.anon.24 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %struct.pgprot, i32, i32, i8*, %struct.lockdep_map }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.mmu_notifier_mm = type opaque
%struct.page = type { i64, %struct.address_space*, %struct.anon.8, %union.anon.25, %struct.pgprot, i64 }
%struct.anon.8 = type { %struct.pgprot, %struct.pgprot }
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type { %struct.__wait_queue_head, %union.anon.5, i64*, %struct.page*, i64 }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.load_weight = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %union.anon.5, %union.anon.5, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %union.anon.5, i32, %union.anon.27, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %struct.pgprot, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.25, %struct.pgprot }
%union.anon.27 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%struct.user_struct = type { %union.anon.5, %union.anon.5, %union.anon.5, %union.anon.5, %union.anon.5, %union.anon.5, %union.anon.5, %struct.pgprot, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.pgprot }
%struct.user_namespace = type { %struct.uid_gid_map, %struct.uid_gid_map, %struct.uid_gid_map, %union.anon.5, %struct.user_namespace*, i32, i32, i32, i8, i8 }
%struct.uid_gid_map = type { i32, [5 x %struct.uid_gid_extent] }
%struct.uid_gid_extent = type { i32, i32, i32 }
%struct.group_info = type { %union.anon.5, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.31 }
%union.anon.31 = type { %struct.exception_table_entry }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.34, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.37 }
%union.anon.34 = type { %struct.load_weight }
%union.anon.37 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type { %union.anon.5, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net* }
%struct.uts_namespace = type { %struct.arch_spinlock, %struct.new_utsname, %struct.user_namespace*, i32 }
%struct.new_utsname = type { [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8] }
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.net = type opaque
%struct.signal_struct = type { %union.anon.5, %union.anon.5, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %struct.pgprot, [2 x %struct.if_dqinfo], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, i64, i64, i64, i64, i64, i64, %struct.load_weight, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.load_weight], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %struct.pgprot, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %struct.pgprot }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %struct.pgprot, i64 ()*, %struct.pgprot, %struct.pgprot }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %struct.pgprot, i32, i32, i64, i64, i64, %struct.pgprot, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.autogroup = type opaque
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %union.anon.5, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%union.anon.25 = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, i8* }
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.39 }
%union.anon.39 = type { %struct.anon.43, [80 x i8] }
%struct.anon.43 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %union.anon.5, i32, i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.load_weight, %struct.load_weight, i64, i64, i32, i32, %struct.load_weight, %struct.load_weight, i64, i32 }
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.memcg_batch_info = type { i32, %struct.mem_cgroup*, i64, i64 }
%struct.mem_cgroup = type opaque
%struct.uprobe_task = type { i32, %struct.arch_uprobe_task, %struct.return_instance*, i32, %struct.uprobe*, i64, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.return_instance = type opaque
%struct.uprobe = type opaque
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.driver_private = type opaque
%struct.dev_pm_info = type { %union.anon.5, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %union.anon.5, %union.anon.5, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.pgprot, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8], %struct.lockdep_map }
%struct.tvec_base = type opaque
%struct.work_struct = type { %struct.pgprot, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type { %struct.pm_qos_constraints, %struct.pm_qos_flags, %struct.dev_pm_qos_request*, %struct.dev_pm_qos_request* }
%struct.pm_qos_constraints = type { %union.anon.25, i32, i32, i32, %struct.blocking_notifier_head* }
%struct.blocking_notifier_head = type { %struct.rw_semaphore, %struct.notifier_block* }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.pm_qos_flags = type { %struct.list_head, i32 }
%struct.dev_pm_qos_request = type { i32, %union.anon.47, %struct.device* }
%union.anon.47 = type { %struct.plist_node }
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.shrink_control = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i8*, i64, %struct.sigset_t*)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, %struct.sigset_t*)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, %struct.sigset_t*)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i64, i32, %struct.sigset_t*)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)*, void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.device_node = type opaque
%union.anon.3 = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.arch_spinlock }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.iommu_group = type opaque
%struct.workqueue_struct = type opaque
%struct.usb_device_id = type { i16, i16, i16, i16, i16, i8, i8, i8, i8, i8, i8, i8, i64 }
%struct.usb_driver = type { i8*, i32 (%struct.usb_interface*, %struct.usb_device_id*)*, void (%struct.usb_interface*)*, i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, %struct.usb_device_id*, %struct.__wait_queue_head, %struct.usbdrv_wrap, i8 }
%struct.usb_interface = type { %struct.usb_host_interface*, %struct.usb_host_interface*, i32, %struct.usb_interface_assoc_descriptor*, i32, i32, i8, %struct.device, %struct.device*, %union.anon.5, %struct.work_struct }
%struct.usb_host_interface = type { %struct.usb_interface_descriptor, i32, i8*, %struct.usb_host_endpoint*, i8* }
%struct.usb_interface_descriptor = type { i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.usb_host_endpoint = type <{ %struct.usb_endpoint_descriptor, %struct.usb_ss_ep_comp_descriptor, i8, %struct.list_head, i8*, %struct.ep_device*, i8*, i32, i32 }>
%struct.usb_endpoint_descriptor = type <{ i8, i8, i8, i8, i16, i8, i8, i8 }>
%struct.usb_ss_ep_comp_descriptor = type { i8, i8, i8, i8, i16 }
%struct.ep_device = type { %struct.usb_endpoint_descriptor*, %struct.usb_device.2852*, %struct.device.2626 }
%struct.usb_device.2852 = type { i32, [16 x i8], i32, i32, i32, %struct.usb_tt*, i32, [2 x i32], %struct.usb_device.2852*, %struct.usb_bus.2854*, %struct.usb_host_endpoint, %struct.device.2626, %struct.usb_device_descriptor, %struct.usb_host_bos*, %struct.usb_host_config.2858*, %struct.usb_host_config.2858*, [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*], i8**, i16, i8, i8, i16, i32, i8*, i8*, i8*, %struct.list_head, i32, i32, %union.anon.5, i64, i64, i8, %struct.wusb_dev*, i32, i32, %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters, i32 }
%struct.usb_tt = type { %struct.usb_device*, i32, i32, %struct.spinlock, %struct.list_head, %struct.work_struct }
%struct.usb_device = type { i32, [16 x i8], i32, i32, i32, %struct.usb_tt*, i32, [2 x i32], %struct.usb_device*, %struct.usb_bus*, %struct.usb_host_endpoint, %struct.device, %struct.usb_device_descriptor, %struct.usb_host_bos*, %struct.usb_host_config*, %struct.usb_host_config*, [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*], i8**, i16, i8, i8, i16, i32, i8*, i8*, i8*, %struct.list_head, i32, i32, %union.anon.5, i64, i64, i8, %struct.wusb_dev*, i32, i32, %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters, i32 }
%struct.usb_bus = type { %struct.device*, i32, i8*, i8, i8, i8, i8, i32, i32, %struct.usb_devmap, %struct.usb_device*, %struct.usb_bus*, %struct.list_head, i32, i32, i32, i32, %struct.mon_bus*, i32 }
%struct.usb_devmap = type { [2 x i64] }
%struct.mon_bus = type opaque
%struct.usb_host_config = type { %struct.usb_config_descriptor, i8*, [16 x %struct.usb_interface_assoc_descriptor*], [32 x %struct.usb_interface*], [32 x %struct.usb_interface_cache*], i8*, i32 }
%struct.usb_config_descriptor = type <{ i8, i8, i16, i8, i8, i8, i8, i8 }>
%struct.usb_interface_cache = type { i32, %struct.arch_spinlock, [0 x %struct.usb_host_interface] }
%struct.usb_bus.2854 = type { %struct.device.2626*, i32, i8*, i8, i8, i8, i8, i32, i32, %struct.usb_devmap, %struct.usb_device.2852*, %struct.usb_bus.2854*, %struct.list_head, i32, i32, i32, i32, %struct.mon_bus*, i32 }
%struct.usb_device_descriptor = type { i8, i8, i16, i8, i8, i8, i8, i16, i16, i16, i8, i8, i8, i8 }
%struct.usb_host_bos = type { %struct.usb_bos_descriptor*, %struct.usb_ext_cap_descriptor*, %struct.usb_ss_cap_descriptor*, %struct.usb_ss_container_id_descriptor* }
%struct.usb_bos_descriptor = type <{ i8, i8, i16, i8 }>
%struct.usb_ext_cap_descriptor = type <{ i8, i8, i8, i32 }>
%struct.usb_ss_cap_descriptor = type { i8, i8, i8, i8, i16, i8, i8, i16 }
%struct.usb_ss_container_id_descriptor = type { i8, i8, i8, i8, [16 x i8] }
%struct.usb_host_config.2858 = type { %struct.usb_config_descriptor, i8*, [16 x %struct.usb_interface_assoc_descriptor*], [32 x %struct.usb_interface.2870*], [32 x %struct.usb_interface_cache*], i8*, i32 }
%struct.usb_interface.2870 = type { %struct.usb_host_interface*, %struct.usb_host_interface*, i32, %struct.usb_interface_assoc_descriptor*, i32, i32, i8, %struct.device.2626, %struct.device.2626*, %union.anon.5, %struct.work_struct }
%struct.wusb_dev = type opaque
%struct.usb3_lpm_parameters = type { i32, i32, i32, i32 }
%struct.device.2626 = type { %struct.device.2626*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type.2628*, %struct.mutex, %struct.bus_type.2630*, %struct.device_driver.2631*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain.2633*, i32, i64*, i64, %struct.shrink_control*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %union.anon.3, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class.2638*, %struct.attribute_group**, void (%struct.device.2626*)*, %struct.iommu_group* }
%struct.device_type.2628 = type { i8*, %struct.attribute_group**, {}*, i8* (%struct.device.2626*, i16*, i32*, i32*)*, void (%struct.device.2626*)*, %struct.dev_pm_ops.2640* }
%struct.dev_pm_ops.2640 = type { i32 (%struct.device.2626*)*, void (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)* }
%struct.bus_type.2630 = type { i8*, i8*, %struct.device.2626*, %struct.bus_attribute.2823*, %struct.device_attribute.2824*, %struct.driver_attribute.2825*, i32 (%struct.device.2626*, %struct.device_driver.2631*)*, {}*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, void (%struct.device.2626*)*, i32 (%struct.device.2626*, i32)*, i32 (%struct.device.2626*)*, %struct.dev_pm_ops.2640*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute.2823 = type { %struct.attribute, i64 (%struct.bus_type.2630*, i8*)*, i64 (%struct.bus_type.2630*, i8*, i64)* }
%struct.device_attribute.2824 = type { %struct.attribute, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*)*, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*, i64)* }
%struct.driver_attribute.2825 = type { %struct.attribute, i64 (%struct.device_driver.2631*, i8*)*, i64 (%struct.device_driver.2631*, i8*, i64)* }
%struct.device_driver.2631 = type { i8*, %struct.bus_type.2630*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device.2626*)*, i32 (%struct.device.2626*)*, void (%struct.device.2626*)*, i32 (%struct.device.2626*, i32)*, i32 (%struct.device.2626*)*, %struct.attribute_group**, %struct.dev_pm_ops.2640*, %struct.driver_private* }
%struct.dev_pm_domain.2633 = type { %struct.dev_pm_ops.2640 }
%struct.class.2638 = type { i8*, %struct.module*, %struct.class_attribute.2838*, %struct.device_attribute.2824*, %struct.bin_attribute*, %struct.kobject*, {}*, i8* (%struct.device.2626*, i16*)*, void (%struct.class.2638*)*, void (%struct.device.2626*)*, i32 (%struct.device.2626*, i32)*, i32 (%struct.device.2626*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device.2626*)*, %struct.dev_pm_ops.2640*, %struct.subsys_private* }
%struct.class_attribute.2838 = type { %struct.attribute, i64 (%struct.class.2638*, %struct.class_attribute.2838*, i8*)*, i64 (%struct.class.2638*, %struct.class_attribute.2838*, i8*, i64)*, i8* (%struct.class.2638*, %struct.class_attribute.2838*)* }
%struct.usb_interface_assoc_descriptor = type { i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.usbdrv_wrap = type { %struct.device_driver, i32 }
%struct.usb_mon_operations = type { void (%struct.usb_bus*, %struct.urb*)*, void (%struct.usb_bus*, %struct.urb*, i32)*, void (%struct.usb_bus*, %struct.urb*, i32)* }
%struct.urb = type { %struct.arch_spinlock, i8*, %union.anon.5, %union.anon.5, i32, %struct.list_head, %struct.list_head, %struct.usb_anchor*, %struct.usb_device*, %struct.usb_host_endpoint*, i32, i32, i32, i32, i8*, i64, %struct.scatterlist*, i32, i32, i32, i32, i8*, i64, i32, i32, i32, i32, i8*, void (%struct.urb*)*, [0 x %struct.usb3_lpm_parameters] }
%struct.usb_anchor = type { %struct.list_head, %struct.__wait_queue_head, %struct.spinlock, i8 }
%struct.pv_irq_ops.581 = type { %union.anon.3, %union.anon.3, %union.anon.3, %union.anon.3, void ()*, void ()*, void ()* }
%struct.usb_class = type { %struct.arch_spinlock, %struct.class* }
%struct.cdev = type { %struct.kobject, %struct.module*, %struct.file_operations*, %struct.list_head, i32, i32 }
%struct.usb_device_driver = type { i8*, i32 (%struct.usb_device*)*, void (%struct.usb_device*)*, i32 (%struct.usb_device*, i32)*, i32 (%struct.usb_device*, i32)*, %struct.usbdrv_wrap, i8 }
%struct.device_connect_event = type { %union.anon.5, %struct.__wait_queue_head }
%struct.usbdevfs_disconnectsignal = type { i32, i8* }
%struct.device.4311 = type { %struct.device.4311*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type.4314*, %struct.mutex, %struct.bus_type.4316*, %struct.device_driver.4317*, i8*, %struct.dev_pm_info.4318, %struct.dev_pm_domain.4319*, i32, i64*, i64, %struct.shrink_control*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %union.anon.3, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class.4326*, %struct.attribute_group**, void (%struct.device.4311*)*, %struct.iommu_group* }
%struct.device_type.4314 = type { i8*, %struct.attribute_group**, {}*, i8* (%struct.device.4311*, i16*, i32*, i32*)*, void (%struct.device.4311*)*, %struct.dev_pm_ops.4310* }
%struct.bus_type.4316 = type { i8*, i8*, %struct.device.4311*, %struct.bus_attribute.4529*, %struct.device_attribute.4530*, %struct.driver_attribute.4531*, i32 (%struct.device.4311*, %struct.device_driver.4317*)*, {}*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, void (%struct.device.4311*)*, i32 (%struct.device.4311*, i32)*, i32 (%struct.device.4311*)*, %struct.dev_pm_ops.4310*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute.4529 = type { %struct.attribute, i64 (%struct.bus_type.4316*, i8*)*, i64 (%struct.bus_type.4316*, i8*, i64)* }
%struct.device_attribute.4530 = type { %struct.attribute, i64 (%struct.device.4311*, %struct.device_attribute.4530*, i8*)*, i64 (%struct.device.4311*, %struct.device_attribute.4530*, i8*, i64)* }
%struct.driver_attribute.4531 = type { %struct.attribute, i64 (%struct.device_driver.4317*, i8*)*, i64 (%struct.device_driver.4317*, i8*, i64)* }
%struct.device_driver.4317 = type { i8*, %struct.bus_type.4316*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, void (%struct.device.4311*)*, i32 (%struct.device.4311*, i32)*, i32 (%struct.device.4311*)*, %struct.attribute_group**, %struct.dev_pm_ops.4310*, %struct.driver_private* }
%struct.dev_pm_info.4318 = type { %union.anon.5, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %union.anon.5, %union.anon.5, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, %struct.dev_pm_qos.4541* }
%struct.dev_pm_qos.4541 = type { %struct.pm_qos_constraints, %struct.pm_qos_flags, %struct.dev_pm_qos_request.4545*, %struct.dev_pm_qos_request.4545* }
%struct.dev_pm_qos_request.4545 = type { i32, %union.anon.47, %struct.device.4311* }
%struct.dev_pm_domain.4319 = type { %struct.dev_pm_ops.4310 }
%struct.dev_pm_ops.4310 = type { i32 (%struct.device.4311*)*, void (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)*, i32 (%struct.device.4311*)* }
%struct.class.4326 = type { i8*, %struct.module*, %struct.class_attribute.4550*, %struct.device_attribute.4530*, %struct.bin_attribute*, %struct.kobject*, {}*, i8* (%struct.device.4311*, i16*)*, void (%struct.class.4326*)*, void (%struct.device.4311*)*, i32 (%struct.device.4311*, i32)*, i32 (%struct.device.4311*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device.4311*)*, %struct.dev_pm_ops.4310*, %struct.subsys_private* }
%struct.class_attribute.4550 = type { %struct.attribute, i64 (%struct.class.4326*, %struct.class_attribute.4550*, i8*)*, i64 (%struct.class.4326*, %struct.class_attribute.4550*, i8*, i64)*, i8* (%struct.class.4326*, %struct.class_attribute.4550*)* }
%struct.resource = type { i64, i64, i8*, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.acpi_bus_type = type { %struct.list_head, i8*, i1 (%struct.device*)*, i32 (%struct.device*, i8**)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.usb_hcd = type { %struct.usb_bus, %struct.arch_spinlock, i8*, i32, [24 x i8], %struct.timer_list, %struct.urb*, %struct.work_struct, %struct.hc_driver*, %struct.usb_phy*, i64, i8, i32, i8*, i64, i64, i32, %struct.mutex*, %struct.usb_hcd*, %struct.usb_hcd*, [4 x %struct.dma_pool*], i32, [0 x i64] }
%struct.hc_driver = type { i8*, i8*, i64, i32 (%struct.usb_hcd*)*, i32, i32 (%struct.usb_hcd*)*, i32 (%struct.usb_hcd*)*, i32 (%struct.usb_hcd*, i1)*, i32 (%struct.usb_hcd*, i1)*, void (%struct.usb_hcd*)*, void (%struct.usb_hcd*)*, i32 (%struct.usb_hcd*)*, i32 (%struct.usb_hcd*, %struct.urb*, i32)*, i32 (%struct.usb_hcd*, %struct.urb*, i32)*, i32 (%struct.usb_hcd*, %struct.urb*, i32)*, void (%struct.usb_hcd*, %struct.urb*)*, void (%struct.usb_hcd*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd*, i8*)*, i32 (%struct.usb_hcd*, i16, i16, i16, i8*, i16)*, i32 (%struct.usb_hcd*)*, i32 (%struct.usb_hcd*)*, i32 (%struct.usb_hcd*, i32)*, void (%struct.usb_hcd*, i32)*, i32 (%struct.usb_hcd*, i32)*, void (%struct.usb_hcd*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)*, void (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)*, void (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, i32)* }
%struct.usb_phy = type { %struct.device*, i8*, i32, i32, i32, i32, %struct.usb_otg*, %struct.device*, %struct.usb_phy_io_ops*, i8*, %struct.atomic_notifier_head, i16, i16, %struct.list_head, i32 (%struct.usb_phy*)*, void (%struct.usb_phy*)*, i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32)* }
%struct.usb_otg = type { i8, %struct.usb_phy*, %struct.usb_bus*, %struct.usb_gadget*, i32 (%struct.usb_otg*, %struct.usb_bus*)*, i32 (%struct.usb_otg*, %struct.usb_gadget*)*, i32 (%struct.usb_otg*, i1)*, i32 (%struct.usb_otg*)*, i32 (%struct.usb_otg*)* }
%struct.usb_gadget = type opaque
%struct.usb_phy_io_ops = type { i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32, i32)* }
%struct.atomic_notifier_head = type { %struct.spinlock, %struct.notifier_block* }
%struct.dma_pool = type opaque
%struct.usb_descriptor_header = type { i8, i8 }
%struct.find_interface_arg = type { i32, %struct.device_driver* }
%struct.usb_hub = type { %struct.device*, %struct.usb_device*, %struct.arch_spinlock, %struct.urb*, [8 x i8]*, %union.anon.48*, %struct.mutex, i32, i32, %struct.list_head, [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], %struct.usb_hub_descriptor*, %struct.usb_tt, i32, i8, [31 x i8], %struct.delayed_work, %struct.delayed_work, %struct.usb_port** }
%union.anon.48 = type { %struct.usb_hub_status }
%struct.usb_hub_status = type { i16, i16 }
%struct.usb_hub_descriptor = type <{ i8, i8, i8, i16, i8, i8, %union.anon.49 }>
%union.anon.49 = type { %struct.anon.50 }
%struct.anon.50 = type { [4 x i8], [4 x i8] }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.usb_port = type { %struct.usb_device*, %struct.device, %struct.dev_state*, i32, i8, i8 }
%struct.dev_state = type { %struct.list_head, %struct.usb_device*, %struct.file*, %struct.spinlock, %struct.list_head, %struct.list_head, %struct.__wait_queue_head, i32, %struct.pid*, %struct.cred*, i8*, i64, i32, i32 }
%struct._ddebug = type { i8*, i8*, i8*, i8*, i32 }
%struct.usb_set_sel_req = type { i8, i8, i16, i16 }
%struct.anon.51 = type <{ i8, i16, i16 }>
%struct.usb_tt_clear = type { %struct.list_head, i32, i16, %struct.usb_hcd*, %struct.usb_host_endpoint* }
%struct.usb_otg_descriptor = type { i8, i8, i8 }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }
%struct.thread_info = type { %struct.task_struct*, %struct.exec_domain*, i32, i32, i32, i32, %struct.pgprot, %struct.restart_block, i8*, i8 }
%struct.exec_domain = type { i8*, void (i32, %struct.pt_regs*)*, i8, i8, i64*, i64*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.module*, %struct.exec_domain* }
%struct.pt_regs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.map_segment = type opaque
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.52 }
%union.anon.52 = type { %struct.anon.53 }
%struct.anon.53 = type { i32*, i32, i32, i32, i64, i32* }
%struct.usb_qualifier_descriptor = type { i8, i8, i16, i8, i8, i8, i8, i8, i8 }
%struct.usbdevfs_hub_portinfo = type { i8, [127 x i8] }
%struct.platform_device = type { i8*, i32, i8, %struct.device, i32, %struct.resource*, %struct.platform_device_id*, %struct.mfd_cell*, %struct.mod_arch_specific }
%struct.platform_device_id = type { [20 x i8], i64 }
%struct.mfd_cell = type opaque
%struct.usb_hcd.588 = type { %struct.usb_bus, %struct.arch_spinlock, i8*, i32, [24 x i8], %struct.timer_list, %struct.urb*, %struct.work_struct, %struct.hc_driver.589*, %struct.usb_phy*, i64, i8, i32, i8*, i64, i64, i32, %struct.mutex*, %struct.usb_hcd.588*, %struct.usb_hcd.588*, [4 x %struct.dma_pool*], i32, [0 x i64] }
%struct.hc_driver.589 = type { i8*, i8*, i64, i32 (%struct.usb_hcd.588*)*, i32, i32 (%struct.usb_hcd.588*)*, i32 (%struct.usb_hcd.588*)*, i32 (%struct.usb_hcd.588*, i1)*, i32 (%struct.usb_hcd.588*, i1)*, {}*, {}*, i32 (%struct.usb_hcd.588*)*, i32 (%struct.usb_hcd.588*, %struct.urb*, i32)*, i32 (%struct.usb_hcd.588*, %struct.urb*, i32)*, i32 (%struct.usb_hcd.588*, %struct.urb*, i32)*, void (%struct.usb_hcd.588*, %struct.urb*)*, void (%struct.usb_hcd.588*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd.588*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.588*, i8*)*, i32 (%struct.usb_hcd.588*, i16, i16, i16, i8*, i16)*, i32 (%struct.usb_hcd.588*)*, i32 (%struct.usb_hcd.588*)*, i32 (%struct.usb_hcd.588*, i32)*, void (%struct.usb_hcd.588*, i32)*, i32 (%struct.usb_hcd.588*, i32)*, void (%struct.usb_hcd.588*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*)*, void (%struct.usb_hcd.588*, %struct.usb_device*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32, i32)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*)*, void (%struct.usb_hcd.588*, %struct.usb_device*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_tt*, i32)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd.588*, i32)* }
%struct.usb_ctrlrequest = type { i8, i8, i16, i16, i16 }
%struct.urb.824 = type { %struct.arch_spinlock, i8*, %union.anon.5, %union.anon.5, i32, %struct.list_head, %struct.list_head, %struct.usb_anchor*, %struct.usb_device*, %struct.usb_host_endpoint*, i32, i32, i32, i32, i8*, i64, %struct.scatterlist*, i32, i32, i32, i32, i8*, i64, i32, i32, i32, i32, i8*, {}*, [0 x %struct.usb3_lpm_parameters] }
%struct.set_config_request = type { %struct.usb_device*, i32, %struct.work_struct, %struct.list_head }
%struct.api_context = type { %struct.completion, i32 }
%struct.usb_sg_request = type { i32, i64, %struct.spinlock, %struct.usb_device*, i32, i32, %struct.urb**, i32, %struct.completion }
%struct.usb_dynid = type { %struct.list_head, %struct.usb_device_id }
%struct.usb_class_driver = type { i8*, i8* (%struct.device*, i16*)*, %struct.file_operations*, i32 }
%struct.usb_hcd.2297 = type { %struct.usb_bus, %struct.arch_spinlock, i8*, i32, [24 x i8], %struct.timer_list, %struct.urb*, %struct.work_struct, %struct.hc_driver.2300*, %struct.usb_phy*, i64, i8, i32, i8*, i64, i64, i32, %struct.mutex*, %struct.usb_hcd.2297*, %struct.usb_hcd.2297*, [4 x %struct.dma_pool*], i32, [0 x i64] }
%struct.hc_driver.2300 = type { i8*, i8*, i64, i32 (%struct.usb_hcd.2297*)*, i32, {}*, {}*, i32 (%struct.usb_hcd.2297*, i1)*, i32 (%struct.usb_hcd.2297*, i1)*, void (%struct.usb_hcd.2297*)*, void (%struct.usb_hcd.2297*)*, {}*, i32 (%struct.usb_hcd.2297*, %struct.urb*, i32)*, i32 (%struct.usb_hcd.2297*, %struct.urb*, i32)*, i32 (%struct.usb_hcd.2297*, %struct.urb*, i32)*, void (%struct.usb_hcd.2297*, %struct.urb*)*, void (%struct.usb_hcd.2297*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd.2297*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.2297*, i8*)*, i32 (%struct.usb_hcd.2297*, i16, i16, i16, i8*, i16)*, {}*, {}*, i32 (%struct.usb_hcd.2297*, i32)*, void (%struct.usb_hcd.2297*, i32)*, i32 (%struct.usb_hcd.2297*, i32)*, void (%struct.usb_hcd.2297*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.2297*, %struct.usb_device*)*, void (%struct.usb_hcd.2297*, %struct.usb_device*)*, i32 (%struct.usb_hcd.2297*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32, i32)*, i32 (%struct.usb_hcd.2297*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32)*, i32 (%struct.usb_hcd.2297*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.2297*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.2297*, %struct.usb_device*)*, void (%struct.usb_hcd.2297*, %struct.usb_device*)*, i32 (%struct.usb_hcd.2297*, %struct.usb_device*)*, i32 (%struct.usb_hcd.2297*, %struct.usb_device*, %struct.usb_tt*, i32)*, i32 (%struct.usb_hcd.2297*, %struct.usb_device*)*, i32 (%struct.usb_hcd.2297*, %struct.usb_device*)*, i32 (%struct.usb_hcd.2297*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd.2297*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd.2297*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd.2297*, i32)* }
%struct.async = type { %struct.list_head, %struct.dev_state*, %struct.pid*, %struct.cred*, i32, i32, i8*, i8*, %struct.urb*, i32, i32, i32, i8, i8 }
%struct.usbdevfs_ctrltransfer32 = type { i8, i8, i16, i16, i16, i32, i32 }
%struct.usbdevfs_ctrltransfer = type { i8, i8, i16, i16, i16, i32, i8* }
%struct.usbdevfs_bulktransfer = type { i32, i32, i32, i8* }
%struct.usbdevfs_getdriver = type { i32, [256 x i8] }
%struct.usbdevfs_connectinfo = type { i32, i8 }
%struct.usbdevfs_urb = type { i8, i8, i32, i32, i8*, i32, i32, i32, i32, i32, i32, i8*, [0 x %struct.uid_gid_extent] }
%struct.usbdevfs_urb32 = type { i8, i8, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [0 x %struct.uid_gid_extent] }
%struct.usbdevfs_ioctl = type { i32, i32, i8* }
%struct.__large_struct = type { [100 x i64] }
%struct.usbdevfs_disconnect_claim = type { i32, i32, [256 x i8] }
%struct.anon.41 = type { i8*, i16 }
%struct.usb_port.4562 = type { %struct.usb_device.4563*, %struct.device.4311, %struct.dev_state*, i32, i8, i8 }
%struct.usb_device.4563 = type { i32, [16 x i8], i32, i32, i32, %struct.usb_tt.4565*, i32, [2 x i32], %struct.usb_device.4563*, %struct.usb_bus.4566*, %struct.usb_host_endpoint, %struct.device.4311, %struct.usb_device_descriptor, %struct.usb_host_bos*, %struct.usb_host_config.4570*, %struct.usb_host_config.4570*, [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*], i8**, i16, i8, i8, i16, i32, i8*, i8*, i8*, %struct.list_head, i32, i32, %union.anon.5, i64, i64, i8, %struct.wusb_dev*, i32, i32, %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters, i32 }
%struct.usb_tt.4565 = type { %struct.usb_device.4563*, i32, i32, %struct.spinlock, %struct.list_head, %struct.work_struct }
%struct.usb_bus.4566 = type { %struct.device.4311*, i32, i8*, i8, i8, i8, i8, i32, i32, %struct.usb_devmap, %struct.usb_device.4563*, %struct.usb_bus.4566*, %struct.list_head, i32, i32, i32, i32, %struct.mon_bus*, i32 }
%struct.usb_host_config.4570 = type { %struct.usb_config_descriptor, i8*, [16 x %struct.usb_interface_assoc_descriptor*], [32 x %struct.usb_interface.4584*], [32 x %struct.usb_interface_cache*], i8*, i32 }
%struct.usb_interface.4584 = type { %struct.usb_host_interface*, %struct.usb_host_interface*, i32, %struct.usb_interface_assoc_descriptor*, i32, i32, i8, %struct.device.4311, %struct.device.4311*, %union.anon.5, %struct.work_struct }
%struct.usb_hub.4588 = type { %struct.device.4311*, %struct.usb_device.4563*, %struct.arch_spinlock, %struct.urb.4589*, [8 x i8]*, %union.anon.48*, %struct.mutex, i32, i32, %struct.list_head, [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], %struct.usb_hub_descriptor*, %struct.usb_tt.4565, i32, i8, [31 x i8], %struct.delayed_work, %struct.delayed_work, %struct.usb_port.4562** }
%struct.urb.4589 = type { %struct.arch_spinlock, i8*, %union.anon.5, %union.anon.5, i32, %struct.list_head, %struct.list_head, %struct.usb_anchor*, %struct.usb_device.4563*, %struct.usb_host_endpoint*, i32, i32, i32, i32, i8*, i64, %struct.scatterlist*, i32, i32, i32, i32, i8*, i64, i32, i32, i32, i32, i8*, void (%struct.urb.4589*)*, [0 x %struct.usb3_lpm_parameters] }
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i8, i8, i8, i8, i8, i8, i16, [6 x i8], %struct.pci_driver*, i64, %struct.shrink_control, i32, i8, i16, i8, i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [17 x %struct.resource], i8, [3 x i8], i16, [2 x i8], %union.anon.5, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [17 x %struct.bin_attribute*], [17 x %struct.bin_attribute*], %struct.list_head, %struct.kset*, %struct.pci_vpd*, %union.anon.47.4869, %struct.pci_ats*, i64, i64 }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.pci_ops = type { i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.proc_dir_entry = type opaque
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, {}*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.__wait_queue_head }
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)* }
%struct.pcie_link_state = type opaque
%struct.pci_vpd = type opaque
%union.anon.47.4869 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.pci_ats = type opaque
%struct.acpi_pld_info = type { i8, i8, i32, i16, i16, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i16, i16 }
%struct.acpi_object_list = type { i32, %union.acpi_object* }
%union.acpi_object = type { %struct.anon.52 }
%struct.anon.52 = type { i32, i32, i64, i32 }
%struct.anon.50.5205 = type { i32, i32, %union.acpi_object* }

@usbcore_name = global i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), align 8
@usb_device_type = global %struct.device_type { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.3.756, i32 0, i32 0), %struct.attribute_group** null, i32 (%struct.device*, %struct.kobj_uevent_env*)* @usb_dev_uevent, i8* (%struct.device*, i16*, i32*, i32*)* @usb_devnode, void (%struct.device*)* @usb_release_dev, %struct.dev_pm_ops* @usb_device_pm_ops }, align 8
@usb_device_pm_ops = internal constant %struct.dev_pm_ops { i32 (%struct.device*)* @usb_dev_prepare, void (%struct.device*)* @usb_dev_complete, i32 (%struct.device*)* @usb_dev_suspend, i32 (%struct.device*)* @usb_dev_resume, i32 (%struct.device*)* @usb_dev_freeze, i32 (%struct.device*)* @usb_dev_thaw, i32 (%struct.device*)* @usb_dev_poweroff, i32 (%struct.device*)* @usb_dev_restore, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* @usb_runtime_suspend, i32 (%struct.device*)* @usb_runtime_resume, i32 (%struct.device*)* @usb_runtime_idle }, align 8
@.str.11 = private unnamed_addr constant [18 x i8] c"bus/usb/%03d/%03d\00", align 1
@.str.9 = private unnamed_addr constant [12 x i8] c"BUSNUM=%03d\00", align 1
@.str.10 = private unnamed_addr constant [12 x i8] c"DEVNUM=%03d\00", align 1
@usb_debug_root = common global %struct.dentry* null, align 8
@llvm.used = appending global [271 x i8*] [i8* bitcast (%struct.kernel_param* @__param_autosuspend to i8*), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__UNIQUE_ID_autosuspendtype55, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @__UNIQUE_ID_autosuspend56, i32 0, i32 0), i8* bitcast (i64* @__kcrctab_usb_find_alt_setting to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_find_alt_setting to i8*), i8* bitcast (i64* @__kcrctab_usb_ifnum_to_if to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_ifnum_to_if to i8*), i8* bitcast (i64* @__kcrctab_usb_altnum_to_altsetting to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_altnum_to_altsetting to i8*), i8* bitcast (i64* @__kcrctab_usb_find_interface to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_find_interface to i8*), i8* bitcast (i64* @__kcrctab_usb_get_dev to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_get_dev to i8*), i8* bitcast (i64* @__kcrctab_usb_put_dev to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_put_dev to i8*), i8* bitcast (i64* @__kcrctab_usb_get_intf to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_get_intf to i8*), i8* bitcast (i64* @__kcrctab_usb_put_intf to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_put_intf to i8*), i8* bitcast (i64* @__kcrctab_usb_lock_device_for_reset to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_lock_device_for_reset to i8*), i8* bitcast (i64* @__kcrctab_usb_get_current_frame_number to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_get_current_frame_number to i8*), i8* bitcast (i64* @__kcrctab___usb_get_extra_descriptor to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab___usb_get_extra_descriptor to i8*), i8* bitcast (i64* @__kcrctab_usb_alloc_coherent to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_alloc_coherent to i8*), i8* bitcast (i64* @__kcrctab_usb_free_coherent to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_free_coherent to i8*), i8* bitcast (%struct.kernel_param* @__param_nousb to i8*), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__UNIQUE_ID_nousbtype923, i32 0, i32 0), i8* bitcast (i64* @__kcrctab_usb_disabled to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_disabled to i8*), i8* bitcast (i64* @__kcrctab_usb_debug_root to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_debug_root to i8*), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license1074, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_blinkenlights to i8*), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__UNIQUE_ID_blinkenlightstype67, i32 0, i32 0), i8* getelementptr inbounds ([46 x i8], [46 x i8]* @__UNIQUE_ID_blinkenlights68, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_initial_descriptor_timeout to i8*), i8* getelementptr inbounds ([40 x i8], [40 x i8]* @__UNIQUE_ID_initial_descriptor_timeouttype76, i32 0, i32 0), i8* getelementptr inbounds ([120 x i8], [120 x i8]* @__UNIQUE_ID_initial_descriptor_timeout79, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_old_scheme_first to i8*), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__UNIQUE_ID_old_scheme_firsttype96, i32 0, i32 0), i8* getelementptr inbounds ([70 x i8], [70 x i8]* @__UNIQUE_ID_old_scheme_first98, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_use_both_schemes to i8*), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__UNIQUE_ID_use_both_schemestype101, i32 0, i32 0), i8* getelementptr inbounds ([88 x i8], [88 x i8]* @__UNIQUE_ID_use_both_schemes104, i32 0, i32 0), i8* bitcast (i64* @__kcrctab_ehci_cf_port_reset_rwsem to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_ehci_cf_port_reset_rwsem to i8*), i8* bitcast (i64* @__kcrctab_usb_wakeup_notification to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_wakeup_notification to i8*), i8* bitcast (i64* @__kcrctab_usb_hub_clear_tt_buffer to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hub_clear_tt_buffer to i8*), i8* bitcast (i64* @__kcrctab_usb_set_device_state to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_set_device_state to i8*), i8* bitcast (i64* @__kcrctab_usb_disable_ltm to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_disable_ltm to i8*), i8* bitcast (i64* @__kcrctab_usb_enable_ltm to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_enable_ltm to i8*), i8* bitcast (i64* @__kcrctab_usb_root_hub_lost_power to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_root_hub_lost_power to i8*), i8* bitcast (i64* @__kcrctab_usb_disable_lpm to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_disable_lpm to i8*), i8* bitcast (i64* @__kcrctab_usb_unlocked_disable_lpm to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_unlocked_disable_lpm to i8*), i8* bitcast (i64* @__kcrctab_usb_enable_lpm to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_enable_lpm to i8*), i8* bitcast (i64* @__kcrctab_usb_unlocked_enable_lpm to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_unlocked_enable_lpm to i8*), i8* bitcast (i64* @__kcrctab_usb_ep0_reinit to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_ep0_reinit to i8*), i8* bitcast (i64* @__kcrctab_usb_reset_device to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_reset_device to i8*), i8* bitcast (i64* @__kcrctab_usb_queue_reset_device to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_queue_reset_device to i8*), i8* bitcast (i64* @__kcrctab_usb_hub_find_child to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hub_find_child to i8*), i8* bitcast (i64* @__kcrctab_usb_hcds_loaded to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcds_loaded to i8*), i8* bitcast (i64* @__kcrctab_usb_bus_list to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_bus_list to i8*), i8* bitcast (i64* @__kcrctab_usb_bus_list_lock to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_bus_list_lock to i8*), i8* bitcast (%struct.kernel_param* @__param_authorized_default to i8*), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__UNIQUE_ID_authorized_defaulttype347, i32 0, i32 0), i8* getelementptr inbounds ([161 x i8], [161 x i8]* @__UNIQUE_ID_authorized_default351, i32 0, i32 0), i8* bitcast (i64* @__kcrctab_usb_hcd_poll_rh_status to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_poll_rh_status to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_start_port_resume to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_start_port_resume to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_end_port_resume to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_end_port_resume to i8*), i8* bitcast (i64* @__kcrctab_usb_calc_bus_time to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_calc_bus_time to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_link_urb_to_ep to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_link_urb_to_ep to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_check_unlink_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_check_unlink_urb to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_unlink_urb_from_ep to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_unlink_urb_from_ep to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_unmap_urb_setup_for_dma to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_unmap_urb_setup_for_dma to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_unmap_urb_for_dma to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_unmap_urb_for_dma to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_map_urb_for_dma to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_map_urb_for_dma to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_giveback_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_giveback_urb to i8*), i8* bitcast (i64* @__kcrctab_usb_alloc_streams to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_alloc_streams to i8*), i8* bitcast (i64* @__kcrctab_usb_free_streams to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_free_streams to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_resume_root_hub to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_resume_root_hub to i8*), i8* bitcast (i64* @__kcrctab_usb_bus_start_enum to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_bus_start_enum to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_irq to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_irq to i8*), i8* bitcast (i64* @__kcrctab_usb_hc_died to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hc_died to i8*), i8* bitcast (i64* @__kcrctab_usb_create_shared_hcd to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_create_shared_hcd to i8*), i8* bitcast (i64* @__kcrctab_usb_create_hcd to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_create_hcd to i8*), i8* bitcast (i64* @__kcrctab_usb_get_hcd to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_get_hcd to i8*), i8* bitcast (i64* @__kcrctab_usb_put_hcd to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_put_hcd to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_is_primary_hcd to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_is_primary_hcd to i8*), i8* bitcast (i64* @__kcrctab_usb_add_hcd to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_add_hcd to i8*), i8* bitcast (i64* @__kcrctab_usb_remove_hcd to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_remove_hcd to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_platform_shutdown to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_platform_shutdown to i8*), i8* bitcast (i64* @__kcrctab_usb_mon_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_mon_register to i8*), i8* bitcast (i64* @__kcrctab_usb_mon_deregister to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_mon_deregister to i8*), i8* bitcast (i64* @__kcrctab_usb_init_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_init_urb to i8*), i8* bitcast (i64* @__kcrctab_usb_alloc_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_alloc_urb to i8*), i8* bitcast (i64* @__kcrctab_usb_free_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_free_urb to i8*), i8* bitcast (i64* @__kcrctab_usb_get_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_get_urb to i8*), i8* bitcast (i64* @__kcrctab_usb_anchor_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_anchor_urb to i8*), i8* bitcast (i64* @__kcrctab_usb_unanchor_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_unanchor_urb to i8*), i8* bitcast (i64* @__kcrctab_usb_submit_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_submit_urb to i8*), i8* bitcast (i64* @__kcrctab_usb_unlink_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_unlink_urb to i8*), i8* bitcast (i64* @__kcrctab_usb_kill_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_kill_urb to i8*), i8* bitcast (i64* @__kcrctab_usb_poison_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_poison_urb to i8*), i8* bitcast (i64* @__kcrctab_usb_unpoison_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_unpoison_urb to i8*), i8* bitcast (i64* @__kcrctab_usb_block_urb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_block_urb to i8*), i8* bitcast (i64* @__kcrctab_usb_kill_anchored_urbs to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_kill_anchored_urbs to i8*), i8* bitcast (i64* @__kcrctab_usb_poison_anchored_urbs to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_poison_anchored_urbs to i8*), i8* bitcast (i64* @__kcrctab_usb_unpoison_anchored_urbs to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_unpoison_anchored_urbs to i8*), i8* bitcast (i64* @__kcrctab_usb_unlink_anchored_urbs to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_unlink_anchored_urbs to i8*), i8* bitcast (i64* @__kcrctab_usb_wait_anchor_empty_timeout to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_wait_anchor_empty_timeout to i8*), i8* bitcast (i64* @__kcrctab_usb_get_from_anchor to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_get_from_anchor to i8*), i8* bitcast (i64* @__kcrctab_usb_scuttle_anchored_urbs to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_scuttle_anchored_urbs to i8*), i8* bitcast (i64* @__kcrctab_usb_anchor_empty to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_anchor_empty to i8*), i8* bitcast (i64* @__kcrctab_usb_control_msg to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_control_msg to i8*), i8* bitcast (i64* @__kcrctab_usb_interrupt_msg to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_interrupt_msg to i8*), i8* bitcast (i64* @__kcrctab_usb_bulk_msg to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_bulk_msg to i8*), i8* bitcast (i64* @__kcrctab_usb_sg_init to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_sg_init to i8*), i8* bitcast (i64* @__kcrctab_usb_sg_wait to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_sg_wait to i8*), i8* bitcast (i64* @__kcrctab_usb_sg_cancel to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_sg_cancel to i8*), i8* bitcast (i64* @__kcrctab_usb_get_descriptor to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_get_descriptor to i8*), i8* bitcast (i64* @__kcrctab_usb_string to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_string to i8*), i8* bitcast (i64* @__kcrctab_usb_get_status to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_get_status to i8*), i8* bitcast (i64* @__kcrctab_usb_clear_halt to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_clear_halt to i8*), i8* bitcast (i64* @__kcrctab_usb_reset_endpoint to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_reset_endpoint to i8*), i8* bitcast (i64* @__kcrctab_usb_set_interface to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_set_interface to i8*), i8* bitcast (i64* @__kcrctab_usb_reset_configuration to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_reset_configuration to i8*), i8* bitcast (i64* @__kcrctab_usb_driver_set_configuration to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_driver_set_configuration to i8*), i8* bitcast (i64* @__kcrctab_usb_store_new_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_store_new_id to i8*), i8* bitcast (i64* @__kcrctab_usb_show_dynids to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_show_dynids to i8*), i8* bitcast (i64* @__kcrctab_usb_driver_claim_interface to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_driver_claim_interface to i8*), i8* bitcast (i64* @__kcrctab_usb_driver_release_interface to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_driver_release_interface to i8*), i8* bitcast (i64* @__kcrctab_usb_match_one_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_match_one_id to i8*), i8* bitcast (i64* @__kcrctab_usb_match_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_match_id to i8*), i8* bitcast (i64* @__kcrctab_usb_register_device_driver to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_register_device_driver to i8*), i8* bitcast (i64* @__kcrctab_usb_deregister_device_driver to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_deregister_device_driver to i8*), i8* bitcast (i64* @__kcrctab_usb_register_driver to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_register_driver to i8*), i8* bitcast (i64* @__kcrctab_usb_deregister to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_deregister to i8*), i8* bitcast (i64* @__kcrctab_usb_enable_autosuspend to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_enable_autosuspend to i8*), i8* bitcast (i64* @__kcrctab_usb_disable_autosuspend to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_disable_autosuspend to i8*), i8* bitcast (i64* @__kcrctab_usb_autopm_put_interface to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_autopm_put_interface to i8*), i8* bitcast (i64* @__kcrctab_usb_autopm_put_interface_async to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_autopm_put_interface_async to i8*), i8* bitcast (i64* @__kcrctab_usb_autopm_put_interface_no_suspend to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_autopm_put_interface_no_suspend to i8*), i8* bitcast (i64* @__kcrctab_usb_autopm_get_interface to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_autopm_get_interface to i8*), i8* bitcast (i64* @__kcrctab_usb_autopm_get_interface_async to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_autopm_get_interface_async to i8*), i8* bitcast (i64* @__kcrctab_usb_autopm_get_interface_no_resume to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_autopm_get_interface_no_resume to i8*), i8* bitcast (i64* @__kcrctab_usb_register_dev to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_register_dev to i8*), i8* bitcast (i64* @__kcrctab_usb_deregister_dev to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_deregister_dev to i8*), i8* bitcast (%struct.kernel_param* @__param_usbfs_snoop to i8*), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__UNIQUE_ID_usbfs_snooptype100, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @__UNIQUE_ID_usbfs_snoop101, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_usbfs_memory_mb to i8*), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__UNIQUE_ID_usbfs_memory_mbtype117, i32 0, i32 0), i8* getelementptr inbounds ([73 x i8], [73 x i8]* @__UNIQUE_ID_usbfs_memory_mb119, i32 0, i32 0), i8* bitcast (i64* @__kcrctab_usb_register_notify to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_register_notify to i8*), i8* bitcast (i64* @__kcrctab_usb_unregister_notify to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_unregister_notify to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_pci_probe to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_pci_probe to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_pci_remove to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_pci_remove to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_pci_shutdown to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_pci_shutdown to i8*), i8* bitcast (i64* @__kcrctab_usb_hcd_pci_pm_ops to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_hcd_pci_pm_ops to i8*), i8* bitcast (i64* @__kcrctab_usb_acpi_power_manageable to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_acpi_power_manageable to i8*), i8* bitcast (i64* @__kcrctab_usb_acpi_set_power_state to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_usb_acpi_set_power_state to i8*)], section "llvm.metadata"
@__param_autosuspend = internal constant %struct.kernel_param { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.51.608, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 420, i16 -1, %union.anon.3 { i8* bitcast (i32* @usb_autosuspend_delay to i8*) } }, section "__param", align 8
@__UNIQUE_ID_autosuspendtype55 = internal constant [25 x i8] c"parmtype=autosuspend:int\00", section ".modinfo", align 1
@__UNIQUE_ID_autosuspend56 = internal constant [43 x i8] c"parm=autosuspend:default autosuspend delay\00", section ".modinfo", align 1
@__kcrctab_usb_find_alt_setting = internal constant i64 ptrtoint (i8** @__crc_usb_find_alt_setting to i64), section "___kcrctab_gpl+usb_find_alt_setting", align 8
@__ksymtab_usb_find_alt_setting = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_host_interface* (%struct.usb_host_config*, i32, i32)* @usb_find_alt_setting to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_usb_find_alt_setting, i32 0, i32 0) }, section "___ksymtab_gpl+usb_find_alt_setting", align 8
@__kcrctab_usb_ifnum_to_if = internal constant i64 ptrtoint (i8** @__crc_usb_ifnum_to_if to i64), section "___kcrctab_gpl+usb_ifnum_to_if", align 8
@__ksymtab_usb_ifnum_to_if = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_interface* (%struct.usb_device*, i32)* @usb_ifnum_to_if to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_usb_ifnum_to_if, i32 0, i32 0) }, section "___ksymtab_gpl+usb_ifnum_to_if", align 8
@__kcrctab_usb_altnum_to_altsetting = internal constant i64 ptrtoint (i8** @__crc_usb_altnum_to_altsetting to i64), section "___kcrctab_gpl+usb_altnum_to_altsetting", align 8
@__ksymtab_usb_altnum_to_altsetting = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_host_interface* (%struct.usb_interface*, i32)* @usb_altnum_to_altsetting to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_altnum_to_altsetting, i32 0, i32 0) }, section "___ksymtab_gpl+usb_altnum_to_altsetting", align 8
@__kcrctab_usb_find_interface = internal constant i64 ptrtoint (i8** @__crc_usb_find_interface to i64), section "___kcrctab_gpl+usb_find_interface", align 8
@__ksymtab_usb_find_interface = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_interface* (%struct.usb_driver*, i32)* @usb_find_interface to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_find_interface, i32 0, i32 0) }, section "___ksymtab_gpl+usb_find_interface", align 8
@__kcrctab_usb_get_dev = internal constant i64 ptrtoint (i8** @__crc_usb_get_dev to i64), section "___kcrctab_gpl+usb_get_dev", align 8
@__ksymtab_usb_get_dev = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_device* (%struct.usb_device*)* @usb_get_dev to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_get_dev, i32 0, i32 0) }, section "___ksymtab_gpl+usb_get_dev", align 8
@__kcrctab_usb_put_dev = internal constant i64 ptrtoint (i8** @__crc_usb_put_dev to i64), section "___kcrctab_gpl+usb_put_dev", align 8
@__ksymtab_usb_put_dev = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*)* @usb_put_dev to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_put_dev, i32 0, i32 0) }, section "___ksymtab_gpl+usb_put_dev", align 8
@__kcrctab_usb_get_intf = internal constant i64 ptrtoint (i8** @__crc_usb_get_intf to i64), section "___kcrctab_gpl+usb_get_intf", align 8
@__ksymtab_usb_get_intf = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_interface* (%struct.usb_interface*)* @usb_get_intf to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_get_intf, i32 0, i32 0) }, section "___ksymtab_gpl+usb_get_intf", align 8
@__kcrctab_usb_put_intf = internal constant i64 ptrtoint (i8** @__crc_usb_put_intf to i64), section "___kcrctab_gpl+usb_put_intf", align 8
@__ksymtab_usb_put_intf = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_interface*)* @usb_put_intf to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_put_intf, i32 0, i32 0) }, section "___ksymtab_gpl+usb_put_intf", align 8
@__kcrctab_usb_lock_device_for_reset = internal constant i64 ptrtoint (i8** @__crc_usb_lock_device_for_reset to i64), section "___kcrctab_gpl+usb_lock_device_for_reset", align 8
@__ksymtab_usb_lock_device_for_reset = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, %struct.usb_interface*)* @usb_lock_device_for_reset to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_usb_lock_device_for_reset, i32 0, i32 0) }, section "___ksymtab_gpl+usb_lock_device_for_reset", align 8
@__kcrctab_usb_get_current_frame_number = internal constant i64 ptrtoint (i8** @__crc_usb_get_current_frame_number to i64), section "___kcrctab_gpl+usb_get_current_frame_number", align 8
@__ksymtab_usb_get_current_frame_number = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*)* @usb_get_current_frame_number to i64), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__kstrtab_usb_get_current_frame_number, i32 0, i32 0) }, section "___ksymtab_gpl+usb_get_current_frame_number", align 8
@__kcrctab___usb_get_extra_descriptor = internal constant i64 ptrtoint (i8** @__crc___usb_get_extra_descriptor to i64), section "___kcrctab_gpl+__usb_get_extra_descriptor", align 8
@__ksymtab___usb_get_extra_descriptor = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i8*, i32, i8, i8**)* @__usb_get_extra_descriptor to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab___usb_get_extra_descriptor, i32 0, i32 0) }, section "___ksymtab_gpl+__usb_get_extra_descriptor", align 8
@__kcrctab_usb_alloc_coherent = internal constant i64 ptrtoint (i8** @__crc_usb_alloc_coherent to i64), section "___kcrctab_gpl+usb_alloc_coherent", align 8
@__ksymtab_usb_alloc_coherent = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (%struct.usb_device*, i64, i32, i64*)* @usb_alloc_coherent to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_alloc_coherent, i32 0, i32 0) }, section "___ksymtab_gpl+usb_alloc_coherent", align 8
@__kcrctab_usb_free_coherent = internal constant i64 ptrtoint (i8** @__crc_usb_free_coherent to i64), section "___kcrctab_gpl+usb_free_coherent", align 8
@__ksymtab_usb_free_coherent = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*, i64, i8*, i64)* @usb_free_coherent to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_usb_free_coherent, i32 0, i32 0) }, section "___ksymtab_gpl+usb_free_coherent", align 8
@__param_nousb = internal constant %struct.kernel_param { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_nousb, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 292, i16 -1, %union.anon.3 { i8* @nousb } }, section "__param", align 8
@__UNIQUE_ID_nousbtype923 = internal constant [20 x i8] c"parmtype=nousb:bool\00", section ".modinfo", align 1
@__kcrctab_usb_disabled = internal constant i64 ptrtoint (i8** @__crc_usb_disabled to i64), section "___kcrctab_gpl+usb_disabled", align 8
@__ksymtab_usb_disabled = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 ()* @usb_disabled to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_disabled, i32 0, i32 0) }, section "___ksymtab_gpl+usb_disabled", align 8
@__kcrctab_usb_debug_root = internal constant i64 ptrtoint (i8** @__crc_usb_debug_root to i64), section "___kcrctab_gpl+usb_debug_root", align 8
@__ksymtab_usb_debug_root = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.dentry** @usb_debug_root to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_debug_root, i32 0, i32 0) }, section "___ksymtab_gpl+usb_debug_root", align 8
@__UNIQUE_ID_license1074 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__kstrtab_usb_debug_root = internal constant [15 x i8] c"usb_debug_root\00", section "__ksymtab_strings", align 1
@__crc_usb_debug_root = extern_weak global i8*, align 8
@__kstrtab_usb_disabled = internal constant [13 x i8] c"usb_disabled\00", section "__ksymtab_strings", align 1
@nousb = internal global i8 0, align 1
@__crc_usb_disabled = extern_weak global i8*, align 8
@__param_str_nousb = internal constant [6 x i8] c"nousb\00", align 1
@param_ops_bool = external global %struct.kernel_param_ops, align 8
@__kstrtab_usb_free_coherent = internal constant [18 x i8] c"usb_free_coherent\00", section "__ksymtab_strings", align 1
@__crc_usb_free_coherent = extern_weak global i8*, align 8
@__kstrtab_usb_alloc_coherent = internal constant [19 x i8] c"usb_alloc_coherent\00", section "__ksymtab_strings", align 1
@__crc_usb_alloc_coherent = extern_weak global i8*, align 8
@__kstrtab___usb_get_extra_descriptor = internal constant [27 x i8] c"__usb_get_extra_descriptor\00", section "__ksymtab_strings", align 1
@.str.7 = private unnamed_addr constant [43 x i8] c"\013%s: bogus descriptor, type %d length %d\0A\00", align 1
@__crc___usb_get_extra_descriptor = extern_weak global i8*, align 8
@__kstrtab_usb_get_current_frame_number = internal constant [29 x i8] c"usb_get_current_frame_number\00", section "__ksymtab_strings", align 1
@__crc_usb_get_current_frame_number = extern_weak global i8*, align 8
@__kstrtab_usb_lock_device_for_reset = internal constant [26 x i8] c"usb_lock_device_for_reset\00", section "__ksymtab_strings", align 1
@jiffies = external global i64, align 8
@__crc_usb_lock_device_for_reset = extern_weak global i8*, align 8
@__kstrtab_usb_put_intf = internal constant [13 x i8] c"usb_put_intf\00", section "__ksymtab_strings", align 1
@__crc_usb_put_intf = extern_weak global i8*, align 8
@__kstrtab_usb_get_intf = internal constant [13 x i8] c"usb_get_intf\00", section "__ksymtab_strings", align 1
@__crc_usb_get_intf = extern_weak global i8*, align 8
@__kstrtab_usb_put_dev = internal constant [12 x i8] c"usb_put_dev\00", section "__ksymtab_strings", align 1
@__crc_usb_put_dev = extern_weak global i8*, align 8
@__kstrtab_usb_get_dev = internal constant [12 x i8] c"usb_get_dev\00", section "__ksymtab_strings", align 1
@__crc_usb_get_dev = extern_weak global i8*, align 8
@__kstrtab_usb_find_interface = internal constant [19 x i8] c"usb_find_interface\00", section "__ksymtab_strings", align 1
@__crc_usb_find_interface = extern_weak global i8*, align 8
@__kstrtab_usb_altnum_to_altsetting = internal constant [25 x i8] c"usb_altnum_to_altsetting\00", section "__ksymtab_strings", align 1
@__crc_usb_altnum_to_altsetting = extern_weak global i8*, align 8
@__kstrtab_usb_ifnum_to_if = internal constant [16 x i8] c"usb_ifnum_to_if\00", section "__ksymtab_strings", align 1
@__crc_usb_ifnum_to_if = extern_weak global i8*, align 8
@__kstrtab_usb_find_alt_setting = internal constant [21 x i8] c"usb_find_alt_setting\00", section "__ksymtab_strings", align 1
@.str.1 = private unnamed_addr constant [54 x i8] c"\017Did not find alt setting %u for intf %u, config %u\0A\00", align 1
@__crc_usb_find_alt_setting = extern_weak global i8*, align 8
@param_ops_int = external global %struct.kernel_param_ops, align 8
@usb_autosuspend_delay = internal global i32 2, align 4
@.str.3 = private unnamed_addr constant [6 x i8] c"usb%d\00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"%s.%d\00", align 1
@.str.6 = private unnamed_addr constant [6 x i8] c"%d-%s\00", align 1
@.str.12 = private unnamed_addr constant [28 x i8] c"\016%s: USB support disabled\0A\00", align 1
@usb_bus_nb = internal global %struct.notifier_block { i32 (%struct.notifier_block*, i64, i8*)* @usb_bus_notify, %struct.notifier_block* null, i32 0 }, align 8
@__this_module = external global %struct.module, align 8
@usb_debug_devices = internal global %struct.dentry* null, align 8
@.str.14 = private unnamed_addr constant [8 x i8] c"devices\00", align 1
@ehci_cf_port_reset_rwsem = global %struct.rw_semaphore { i64 0, %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.8, i32 0, i32 0), i32 0, i64 0 } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rw_semaphore* @ehci_cf_port_reset_rwsem to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rw_semaphore* @ehci_cf_port_reset_rwsem to i8*), i64 80) to %struct.list_head*) }, %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.1.9, i32 0, i32 0), i32 0, i64 0 } }, align 8
@.str.8 = private unnamed_addr constant [35 x i8] c"ehci_cf_port_reset_rwsem.wait_lock\00", align 1
@.str.1.9 = private unnamed_addr constant [25 x i8] c"ehci_cf_port_reset_rwsem\00", align 1
@__param_blinkenlights = internal constant %struct.kernel_param { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__param_str_blinkenlights, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 292, i16 -1, %union.anon.3 { i8* @blinkenlights } }, section "__param", align 8
@__UNIQUE_ID_blinkenlightstype67 = internal constant [28 x i8] c"parmtype=blinkenlights:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_blinkenlights68 = internal constant [46 x i8] c"parm=blinkenlights:true to cycle leds on hubs\00", section ".modinfo", align 1
@__param_initial_descriptor_timeout = internal constant %struct.kernel_param { i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__param_str_initial_descriptor_timeout, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 420, i16 -1, %union.anon.3 { i8* bitcast (i32* @initial_descriptor_timeout to i8*) } }, section "__param", align 8
@__UNIQUE_ID_initial_descriptor_timeouttype76 = internal constant [40 x i8] c"parmtype=initial_descriptor_timeout:int\00", section ".modinfo", align 1
@__UNIQUE_ID_initial_descriptor_timeout79 = internal constant [120 x i8] c"parm=initial_descriptor_timeout:initial 64-byte descriptor request timeout in milliseconds (default 5000 - 5.0 seconds)\00", section ".modinfo", align 1
@__param_old_scheme_first = internal constant %struct.kernel_param { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__param_str_old_scheme_first, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 420, i16 -1, %union.anon.3 { i8* @old_scheme_first } }, section "__param", align 8
@__UNIQUE_ID_old_scheme_firsttype96 = internal constant [31 x i8] c"parmtype=old_scheme_first:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_old_scheme_first98 = internal constant [70 x i8] c"parm=old_scheme_first:start with the old device initialization scheme\00", section ".modinfo", align 1
@__param_use_both_schemes = internal constant %struct.kernel_param { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__param_str_use_both_schemes, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 420, i16 -1, %union.anon.3 { i8* @use_both_schemes } }, section "__param", align 8
@__UNIQUE_ID_use_both_schemestype101 = internal constant [31 x i8] c"parmtype=use_both_schemes:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_use_both_schemes104 = internal constant [88 x i8] c"parm=use_both_schemes:try the other device initialization scheme if the first one fails\00", section ".modinfo", align 1
@__kcrctab_ehci_cf_port_reset_rwsem = internal constant i64 ptrtoint (i8** @__crc_ehci_cf_port_reset_rwsem to i64), section "___kcrctab_gpl+ehci_cf_port_reset_rwsem", align 8
@__ksymtab_ehci_cf_port_reset_rwsem = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rw_semaphore* @ehci_cf_port_reset_rwsem to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_ehci_cf_port_reset_rwsem, i32 0, i32 0) }, section "___ksymtab_gpl+ehci_cf_port_reset_rwsem", align 8
@__kcrctab_usb_wakeup_notification = internal constant i64 ptrtoint (i8** @__crc_usb_wakeup_notification to i64), section "___kcrctab_gpl+usb_wakeup_notification", align 8
@__ksymtab_usb_wakeup_notification = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*, i32)* @usb_wakeup_notification to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_wakeup_notification, i32 0, i32 0) }, section "___ksymtab_gpl+usb_wakeup_notification", align 8
@__kcrctab_usb_hub_clear_tt_buffer = internal constant i64 ptrtoint (i8** @__crc_usb_hub_clear_tt_buffer to i64), section "___kcrctab_gpl+usb_hub_clear_tt_buffer", align 8
@__ksymtab_usb_hub_clear_tt_buffer = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.urb*)* @usb_hub_clear_tt_buffer to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_hub_clear_tt_buffer, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hub_clear_tt_buffer", align 8
@__kcrctab_usb_set_device_state = internal constant i64 ptrtoint (i8** @__crc_usb_set_device_state to i64), section "___kcrctab_gpl+usb_set_device_state", align 8
@__ksymtab_usb_set_device_state = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*, i32)* @usb_set_device_state to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_usb_set_device_state, i32 0, i32 0) }, section "___ksymtab_gpl+usb_set_device_state", align 8
@__kcrctab_usb_disable_ltm = internal constant i64 ptrtoint (i8** @__crc_usb_disable_ltm to i64), section "___kcrctab_gpl+usb_disable_ltm", align 8
@__ksymtab_usb_disable_ltm = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*)* @usb_disable_ltm to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_usb_disable_ltm, i32 0, i32 0) }, section "___ksymtab_gpl+usb_disable_ltm", align 8
@__kcrctab_usb_enable_ltm = internal constant i64 ptrtoint (i8** @__crc_usb_enable_ltm to i64), section "___kcrctab_gpl+usb_enable_ltm", align 8
@__ksymtab_usb_enable_ltm = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*)* @usb_enable_ltm to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_enable_ltm, i32 0, i32 0) }, section "___ksymtab_gpl+usb_enable_ltm", align 8
@__kcrctab_usb_root_hub_lost_power = internal constant i64 ptrtoint (i8** @__crc_usb_root_hub_lost_power to i64), section "___kcrctab_gpl+usb_root_hub_lost_power", align 8
@__ksymtab_usb_root_hub_lost_power = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*)* @usb_root_hub_lost_power to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_root_hub_lost_power, i32 0, i32 0) }, section "___ksymtab_gpl+usb_root_hub_lost_power", align 8
@__kcrctab_usb_disable_lpm = internal constant i64 ptrtoint (i8** @__crc_usb_disable_lpm to i64), section "___kcrctab_gpl+usb_disable_lpm", align 8
@__ksymtab_usb_disable_lpm = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*)* @usb_disable_lpm to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_usb_disable_lpm, i32 0, i32 0) }, section "___ksymtab_gpl+usb_disable_lpm", align 8
@__kcrctab_usb_unlocked_disable_lpm = internal constant i64 ptrtoint (i8** @__crc_usb_unlocked_disable_lpm to i64), section "___kcrctab_gpl+usb_unlocked_disable_lpm", align 8
@__ksymtab_usb_unlocked_disable_lpm = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*)* @usb_unlocked_disable_lpm to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_unlocked_disable_lpm, i32 0, i32 0) }, section "___ksymtab_gpl+usb_unlocked_disable_lpm", align 8
@__kcrctab_usb_enable_lpm = internal constant i64 ptrtoint (i8** @__crc_usb_enable_lpm to i64), section "___kcrctab_gpl+usb_enable_lpm", align 8
@__ksymtab_usb_enable_lpm = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*)* @usb_enable_lpm to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_enable_lpm, i32 0, i32 0) }, section "___ksymtab_gpl+usb_enable_lpm", align 8
@__kcrctab_usb_unlocked_enable_lpm = internal constant i64 ptrtoint (i8** @__crc_usb_unlocked_enable_lpm to i64), section "___kcrctab_gpl+usb_unlocked_enable_lpm", align 8
@__ksymtab_usb_unlocked_enable_lpm = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*)* @usb_unlocked_enable_lpm to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_unlocked_enable_lpm, i32 0, i32 0) }, section "___ksymtab_gpl+usb_unlocked_enable_lpm", align 8
@__kcrctab_usb_ep0_reinit = internal constant i64 ptrtoint (i8** @__crc_usb_ep0_reinit to i64), section "___kcrctab_gpl+usb_ep0_reinit", align 8
@__ksymtab_usb_ep0_reinit = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*)* @usb_ep0_reinit to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_ep0_reinit, i32 0, i32 0) }, section "___ksymtab_gpl+usb_ep0_reinit", align 8
@__kcrctab_usb_reset_device = internal constant i64 ptrtoint (i8** @__crc_usb_reset_device to i64), section "___kcrctab_gpl+usb_reset_device", align 8
@__ksymtab_usb_reset_device = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*)* @usb_reset_device to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_reset_device, i32 0, i32 0) }, section "___ksymtab_gpl+usb_reset_device", align 8
@__kcrctab_usb_queue_reset_device = internal constant i64 ptrtoint (i8** @__crc_usb_queue_reset_device to i64), section "___kcrctab_gpl+usb_queue_reset_device", align 8
@__ksymtab_usb_queue_reset_device = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_interface*)* @usb_queue_reset_device to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_usb_queue_reset_device, i32 0, i32 0) }, section "___ksymtab_gpl+usb_queue_reset_device", align 8
@__kcrctab_usb_hub_find_child = internal constant i64 ptrtoint (i8** @__crc_usb_hub_find_child to i64), section "___kcrctab_gpl+usb_hub_find_child", align 8
@__ksymtab_usb_hub_find_child = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_device* (%struct.usb_device*, i32)* @usb_hub_find_child to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_hub_find_child, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hub_find_child", align 8
@__kstrtab_usb_hub_find_child = internal constant [19 x i8] c"usb_hub_find_child\00", section "__ksymtab_strings", align 1
@__crc_usb_hub_find_child = extern_weak global i8*, align 8
@__kstrtab_usb_queue_reset_device = internal constant [23 x i8] c"usb_queue_reset_device\00", section "__ksymtab_strings", align 1
@system_wq = external global %struct.workqueue_struct*, align 8
@__crc_usb_queue_reset_device = extern_weak global i8*, align 8
@__kstrtab_usb_reset_device = internal constant [17 x i8] c"usb_reset_device\00", section "__ksymtab_strings", align 1
@usb_reset_device.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.usb_reset_device, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.38, i32 0, i32 0), i8 64, i8 20, i8 4, i8 0 }, section "__verbose", align 8
@.str.38 = private unnamed_addr constant [38 x i8] c"device reset not allowed in state %d\0A\00", align 1
@current_task = external global %struct.task_struct*, align 8
@usb_reset_and_verify_device.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.usb_reset_and_verify_device, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.38, i32 0, i32 0), i8 -91, i8 19, i8 4, i8 0 }, section "__verbose", align 8
@usb_reset_and_verify_device.descriptor.258 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.usb_reset_and_verify_device, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.259, i32 0, i32 0), i8 -85, i8 19, i8 4, i8 0 }, section "__verbose", align 8
@.str.259 = private unnamed_addr constant [18 x i8] c"%s for root hub!\0A\00", align 1
@__func__.usb_reset_and_verify_device = private unnamed_addr constant [28 x i8] c"usb_reset_and_verify_device\00", align 1
@.str.261 = private unnamed_addr constant [27 x i8] c"%s Failed to disable LTM\0A.\00", align 1
@use_both_schemes = internal global i8 1, align 1
@.str.262 = private unnamed_addr constant [25 x i8] c"device firmware changed\0A\00", align 1
@.str.263 = private unnamed_addr constant [61 x i8] c"Busted HC?  Not enough HCD resources for old configuration.\0A\00", align 1
@.str.264 = private unnamed_addr constant [44 x i8] c"can't restore configuration #%d (error=%d)\0A\00", align 1
@.str.265 = private unnamed_addr constant [57 x i8] c"failed to restore interface %d altsetting %d (error=%d)\0A\00", align 1
@hub_port_logical_disconnect.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.hub_port_logical_disconnect, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.44, i32 0, i32 0), i8 -91, i8 3, i8 4, i8 0 }, section "__verbose", align 8
@.str.44 = private unnamed_addr constant [31 x i8] c"logical disconnect on port %d\0A\00", align 1
@hub_event_lock = internal global %struct.spinlock { %union.anon.4 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.42, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@hub_event_list = internal global %struct.list_head { %struct.list_head* @hub_event_list, %struct.list_head* @hub_event_list }, align 8
@khubd_wait = internal global %struct.__wait_queue_head { %struct.spinlock { %union.anon.4 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.43, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.__wait_queue_head* @khubd_wait to i8*), i64 72) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.__wait_queue_head* @khubd_wait to i8*), i64 72) to %struct.list_head*) } }, align 8
@.str.43 = private unnamed_addr constant [16 x i8] c"khubd_wait.lock\00", align 1
@.str.42 = private unnamed_addr constant [15 x i8] c"hub_event_lock\00", align 1
@.str.45 = private unnamed_addr constant [35 x i8] c"cannot disable port %d (err = %d)\0A\00", align 1
@.str.46 = private unnamed_addr constant [39 x i8] c"Could not disable port %d after %d ms\0A\00", align 1
@.str.60 = private unnamed_addr constant [22 x i8] c"%s failed (err = %d)\0A\00", align 1
@__func__.hub_port_status = private unnamed_addr constant [16 x i8] c"hub_port_status\00", align 1
@__func__.hub_port_logical_disconnect = private unnamed_addr constant [28 x i8] c"hub_port_logical_disconnect\00", align 1
@.str.5.13 = private unnamed_addr constant [23 x i8] c"drivers/usb/core/hub.c\00", align 1
@usb3_lpm_names = internal constant [4 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.83, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.84, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.85, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.86, i32 0, i32 0)], align 16
@.str.87 = private unnamed_addr constant [41 x i8] c"Set SEL for device-initiated %s failed.\0A\00", align 1
@.str.88 = private unnamed_addr constant [48 x i8] c"Could not enable %s link state, xHCI error %i.\0A\00", align 1
@.str.77 = private unnamed_addr constant [7 x i8] c"enable\00", align 1
@.str.78 = private unnamed_addr constant [8 x i8] c"disable\00", align 1
@.str.76 = private unnamed_addr constant [34 x i8] c"%s: Can't %s non-U1 or U2 state.\0A\00", align 1
@__func__.usb_set_device_initiated_lpm = private unnamed_addr constant [29 x i8] c"usb_set_device_initiated_lpm\00", align 1
@usb_set_device_initiated_lpm.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__func__.usb_set_device_initiated_lpm, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.79, i32 0, i32 0), i8 -97, i8 13, i8 4, i8 0 }, section "__verbose", align 8
@.str.79 = private unnamed_addr constant [48 x i8] c"%s: Can't %s %s state for unconfigured device.\0A\00", align 1
@.str.81 = private unnamed_addr constant [7 x i8] c"Enable\00", align 1
@.str.82 = private unnamed_addr constant [8 x i8] c"Disable\00", align 1
@.str.80 = private unnamed_addr constant [35 x i8] c"%s of device-initiated %s failed.\0A\00", align 1
@.str.73 = private unnamed_addr constant [47 x i8] c"%s: Can't set timeout for non-U1 or U2 state.\0A\00", align 1
@__func__.usb_set_lpm_timeout = private unnamed_addr constant [20 x i8] c"usb_set_lpm_timeout\00", align 1
@.str.74 = private unnamed_addr constant [62 x i8] c"Failed to set %s timeout to 0x%x, which is a reserved value.\0A\00", align 1
@.str.75 = private unnamed_addr constant [48 x i8] c"Failed to set %s timeout to 0x%x,error code %i\0A\00", align 1
@.str.83 = private unnamed_addr constant [3 x i8] c"U0\00", align 1
@.str.84 = private unnamed_addr constant [3 x i8] c"U1\00", align 1
@.str.85 = private unnamed_addr constant [3 x i8] c"U2\00", align 1
@.str.86 = private unnamed_addr constant [3 x i8] c"U3\00", align 1
@usb_req_set_sel.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usb_req_set_sel, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.89, i32 0, i32 0), i8 88, i8 13, i8 4, i8 0 }, section "__verbose", align 8
@.str.89 = private unnamed_addr constant [69 x i8] c"Device-initiated %s disabled due to long SEL %llu us or PEL %llu us\0A\00", align 1
@__func__.usb_req_set_sel = private unnamed_addr constant [16 x i8] c"usb_req_set_sel\00", align 1
@device_state_lock = internal global %struct.spinlock { %union.anon.4 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.47, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@.str.47 = private unnamed_addr constant [18 x i8] c"device_state_lock\00", align 1
@.str.266 = private unnamed_addr constant [39 x i8] c"no mem to re-read configs after reset\0A\00", align 1
@descriptors_changed.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.descriptors_changed, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.267, i32 0, i32 0), i8 91, i8 19, i8 4, i8 0 }, section "__verbose", align 8
@.str.267 = private unnamed_addr constant [27 x i8] c"config index %d, error %d\0A\00", align 1
@descriptors_changed.descriptor.268 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.descriptors_changed, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.269, i32 0, i32 0), i8 100, i8 19, i8 4, i8 0 }, section "__verbose", align 8
@.str.269 = private unnamed_addr constant [31 x i8] c"config index %d changed (#%d)\0A\00", align 1
@descriptors_changed.descriptor.270 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.descriptors_changed, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.271, i32 0, i32 0), i8 111, i8 19, i8 4, i8 0 }, section "__verbose", align 8
@.str.271 = private unnamed_addr constant [24 x i8] c"serial string error %d\0A\00", align 1
@descriptors_changed.descriptor.272 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.descriptors_changed, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.273, i32 0, i32 0), i8 114, i8 19, i8 4, i8 0 }, section "__verbose", align 8
@.str.273 = private unnamed_addr constant [23 x i8] c"serial string changed\0A\00", align 1
@__func__.descriptors_changed = private unnamed_addr constant [20 x i8] c"descriptors_changed\00", align 1
@hub_port_init.usb_address0_mutex = internal global %struct.mutex { %union.anon.5 { i32 1 }, %struct.spinlock { %union.anon.4 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.233, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @hub_port_init.usb_address0_mutex to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @hub_port_init.usb_address0_mutex to i8*), i64 80) to %struct.list_head*) }, %struct.task_struct* null, i8* null, i8* bitcast (%struct.mutex* @hub_port_init.usb_address0_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.234, i32 0, i32 0), i32 0, i64 0 } }, align 8
@hub_port_init.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_port_init, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.235, i32 0, i32 0), i8 123, i8 15, i8 4, i8 0 }, section "__verbose", align 8
@.str.235 = private unnamed_addr constant [29 x i8] c"device reset changed speed!\0A\00", align 1
@.str.236 = private unnamed_addr constant [24 x i8] c"variable speed Wireless\00", align 1
@.str.238 = private unnamed_addr constant [6 x i8] c"reset\00", align 1
@.str.239 = private unnamed_addr constant [4 x i8] c"new\00", align 1
@.str.237 = private unnamed_addr constant [37 x i8] c"%s %s USB device number %d using %s\0A\00", align 1
@.str.240 = private unnamed_addr constant [22 x i8] c"parent hub has no TT\0A\00", align 1
@old_scheme_first = internal global i8 0, align 1
@initial_descriptor_timeout = internal global i32 5000, align 4
@hub_port_init.descriptor.241 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_port_init, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.235, i32 0, i32 0), i8 -15, i8 15, i8 4, i8 0 }, section "__verbose", align 8
@.str.242 = private unnamed_addr constant [37 x i8] c"device descriptor read/64, error %d\0A\00", align 1
@.str.243 = private unnamed_addr constant [43 x i8] c"device not accepting address %d, error %d\0A\00", align 1
@.str.244 = private unnamed_addr constant [45 x i8] c"%s SuperSpeed USB device number %d using %s\0A\00", align 1
@.str.245 = private unnamed_addr constant [36 x i8] c"device descriptor read/8, error %d\0A\00", align 1
@.str.246 = private unnamed_addr constant [50 x i8] c"got a wrong device descriptor, warm reset device\0A\00", align 1
@.str.247 = private unnamed_addr constant [27 x i8] c"Invalid ep0 maxpacket: %d\0A\00", align 1
@hub_port_init.descriptor.248 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_port_init, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.249, i32 0, i32 0), i8 82, i8 16, i8 4, i8 0 }, section "__verbose", align 8
@.str.249 = private unnamed_addr constant [20 x i8] c"ep0 maxpacket = %d\0A\00", align 1
@.str.250 = private unnamed_addr constant [25 x i8] c"Using ep0 maxpacket: %d\0A\00", align 1
@.str.251 = private unnamed_addr constant [38 x i8] c"device descriptor read/all, error %d\0A\00", align 1
@.str.252 = private unnamed_addr constant [69 x i8] c"No LPM exit latency info found.  Power management will be impacted.\0A\00", align 1
@.str.253 = private unnamed_addr constant [79 x i8] c"Parent hub missing LPM exit latency info.  Power management will be impacted.\0A\00", align 1
@__func__.hub_port_init = private unnamed_addr constant [14 x i8] c"hub_port_init\00", align 1
@.str.210 = private unnamed_addr constant [34 x i8] c"only USB3 hub support warm reset\0A\00", align 1
@.str.212 = private unnamed_addr constant [6 x i8] c"warm \00", align 1
@.str.211 = private unnamed_addr constant [35 x i8] c"cannot %sreset port %d (err = %d)\0A\00", align 1
@hub_port_reset.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.hub_port_reset, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.213, i32 0, i32 0), i8 99, i8 10, i8 4, i8 0 }, section "__verbose", align 8
@.str.213 = private unnamed_addr constant [27 x i8] c"port_wait_reset: err = %d\0A\00", align 1
@hub_port_reset.descriptor.214 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.hub_port_reset, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.215, i32 0, i32 0), i8 126, i8 10, i8 4, i8 0 }, section "__verbose", align 8
@.str.215 = private unnamed_addr constant [38 x i8] c"hot reset failed, warm reset port %d\0A\00", align 1
@hub_port_reset.descriptor.216 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.hub_port_reset, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.217, i32 0, i32 0), i8 -123, i8 10, i8 4, i8 0 }, section "__verbose", align 8
@.str.217 = private unnamed_addr constant [46 x i8] c"port %d not enabled, trying %sreset again...\0A\00", align 1
@.str.218 = private unnamed_addr constant [53 x i8] c"Cannot enable port %i.  Maybe the USB cable is bad?\0A\00", align 1
@__func__.hub_port_reset = private unnamed_addr constant [15 x i8] c"hub_port_reset\00", align 1
@hub_port_wait_reset.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.hub_port_wait_reset, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.219, i32 0, i32 0), i8 -27, i8 9, i8 4, i8 0 }, section "__verbose", align 8
@.str.219 = private unnamed_addr constant [39 x i8] c"port %d not %sreset yet, waiting %dms\0A\00", align 1
@__func__.hub_port_wait_reset = private unnamed_addr constant [20 x i8] c"hub_port_wait_reset\00", align 1
@.str.233 = private unnamed_addr constant [29 x i8] c"usb_address0_mutex.wait_lock\00", align 1
@.str.234 = private unnamed_addr constant [19 x i8] c"usb_address0_mutex\00", align 1
@.str.71 = private unnamed_addr constant [39 x i8] c"%s: Can't disable non-U1 or U2 state.\0A\00", align 1
@__func__.usb_disable_link_state = private unnamed_addr constant [23 x i8] c"usb_disable_link_state\00", align 1
@.str.72 = private unnamed_addr constant [76 x i8] c"Could not disable xHCI %s timeout, bus schedule bandwidth may be impacted.\0A\00", align 1
@__func__.usb_reset_device = private unnamed_addr constant [17 x i8] c"usb_reset_device\00", align 1
@__crc_usb_reset_device = extern_weak global i8*, align 8
@__kstrtab_usb_ep0_reinit = internal constant [15 x i8] c"usb_ep0_reinit\00", section "__ksymtab_strings", align 1
@__crc_usb_ep0_reinit = extern_weak global i8*, align 8
@__kstrtab_usb_unlocked_enable_lpm = internal constant [24 x i8] c"usb_unlocked_enable_lpm\00", section "__ksymtab_strings", align 1
@__crc_usb_unlocked_enable_lpm = extern_weak global i8*, align 8
@__kstrtab_usb_enable_lpm = internal constant [15 x i8] c"usb_enable_lpm\00", section "__ksymtab_strings", align 1
@__crc_usb_enable_lpm = extern_weak global i8*, align 8
@__kstrtab_usb_unlocked_disable_lpm = internal constant [25 x i8] c"usb_unlocked_disable_lpm\00", section "__ksymtab_strings", align 1
@__crc_usb_unlocked_disable_lpm = extern_weak global i8*, align 8
@__kstrtab_usb_disable_lpm = internal constant [16 x i8] c"usb_disable_lpm\00", section "__ksymtab_strings", align 1
@__crc_usb_disable_lpm = extern_weak global i8*, align 8
@__kstrtab_usb_root_hub_lost_power = internal constant [24 x i8] c"usb_root_hub_lost_power\00", section "__ksymtab_strings", align 1
@.str.33 = private unnamed_addr constant [34 x i8] c"root hub lost power or was reset\0A\00", align 1
@__crc_usb_root_hub_lost_power = extern_weak global i8*, align 8
@__kstrtab_usb_enable_ltm = internal constant [15 x i8] c"usb_enable_ltm\00", section "__ksymtab_strings", align 1
@__crc_usb_enable_ltm = extern_weak global i8*, align 8
@__kstrtab_usb_disable_ltm = internal constant [16 x i8] c"usb_disable_ltm\00", section "__ksymtab_strings", align 1
@__crc_usb_disable_ltm = extern_weak global i8*, align 8
@__kstrtab_usb_set_device_state = internal constant [21 x i8] c"usb_set_device_state\00", section "__ksymtab_strings", align 1
@__crc_usb_set_device_state = extern_weak global i8*, align 8
@__kstrtab_usb_hub_clear_tt_buffer = internal constant [24 x i8] c"usb_hub_clear_tt_buffer\00", section "__ksymtab_strings", align 1
@.str.2.15 = private unnamed_addr constant [34 x i8] c"can't save CLEAR_TT_BUFFER state\0A\00", align 1
@__crc_usb_hub_clear_tt_buffer = extern_weak global i8*, align 8
@__kstrtab_usb_wakeup_notification = internal constant [24 x i8] c"usb_wakeup_notification\00", section "__ksymtab_strings", align 1
@__crc_usb_wakeup_notification = extern_weak global i8*, align 8
@__kstrtab_ehci_cf_port_reset_rwsem = internal constant [25 x i8] c"ehci_cf_port_reset_rwsem\00", section "__ksymtab_strings", align 1
@__crc_ehci_cf_port_reset_rwsem = extern_weak global i8*, align 8
@__param_str_use_both_schemes = internal constant [17 x i8] c"use_both_schemes\00", align 16
@__param_str_old_scheme_first = internal constant [17 x i8] c"old_scheme_first\00", align 16
@__param_str_initial_descriptor_timeout = internal constant [27 x i8] c"initial_descriptor_timeout\00", align 16
@__param_str_blinkenlights = internal constant [14 x i8] c"blinkenlights\00", align 1
@blinkenlights = internal global i8 0, align 1
@.str.3.16 = private unnamed_addr constant [34 x i8] c"USB disconnect, device number %d\0A\00", align 1
@usb_disconnect.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.usb_disconnect, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.6.17, i32 0, i32 0), i8 -16, i8 7, i8 4, i8 0 }, section "__verbose", align 8
@.str.6.17 = private unnamed_addr constant [22 x i8] c"unregistering device\0A\00", align 1
@.str.7.18 = private unnamed_addr constant [5 x i8] c"port\00", align 1
@.str.8.19 = private unnamed_addr constant [7 x i8] c"device\00", align 1
@__func__.usb_disconnect = private unnamed_addr constant [15 x i8] c"usb_disconnect\00", align 1
@usb_new_device.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.usb_new_device, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.9.20, i32 0, i32 0), i8 2, i8 9, i8 4, i8 0 }, section "__verbose", align 8
@.str.9.20 = private unnamed_addr constant [32 x i8] c"udev %d, busnum %d, minor = %d\0A\00", align 1
@.str.10.21 = private unnamed_addr constant [28 x i8] c"can't device_add, error %d\0A\00", align 1
@.str.54 = private unnamed_addr constant [53 x i8] c"New USB device found, idVendor=%04x, idProduct=%04x\0A\00", align 1
@.str.55 = private unnamed_addr constant [61 x i8] c"New USB device strings: Mfr=%d, Product=%d, SerialNumber=%d\0A\00", align 1
@.str.56 = private unnamed_addr constant [8 x i8] c"Product\00", align 1
@.str.57 = private unnamed_addr constant [13 x i8] c"Manufacturer\00", align 1
@.str.58 = private unnamed_addr constant [13 x i8] c"SerialNumber\00", align 1
@.str.59 = private unnamed_addr constant [8 x i8] c"%s: %s\0A\00", align 1
@__func__.usb_new_device = private unnamed_addr constant [15 x i8] c"usb_new_device\00", align 1
@.str.48 = private unnamed_addr constant [37 x i8] c"can't read configurations, error %d\0A\00", align 1
@.str.11.22 = private unnamed_addr constant [19 x i8] c"n/a (unauthorized)\00", align 1
@.str.50 = private unnamed_addr constant [5 x i8] c"non-\00", align 1
@.str.49 = private unnamed_addr constant [36 x i8] c"Dual-Role OTG device on %sHNP port\0A\00", align 1
@.str.51 = private unnamed_addr constant [24 x i8] c"can't set HNP mode: %d\0A\00", align 1
@usb_enumerate_device_otg.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.usb_enumerate_device_otg, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.52, i32 0, i32 0), i8 120, i8 8, i8 4, i8 0 }, section "__verbose", align 8
@.str.52 = private unnamed_addr constant [14 x i8] c"HNP fail, %d\0A\00", align 1
@__func__.usb_enumerate_device_otg = private unnamed_addr constant [25 x i8] c"usb_enumerate_device_otg\00", align 1
@usb_port_suspend.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.usb_port_suspend, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.16, i32 0, i32 0), i8 120, i8 11, i8 4, i8 0 }, section "__verbose", align 8
@.str.16 = private unnamed_addr constant [32 x i8] c"won't remote wakeup, status %d\0A\00", align 1
@.str.17 = private unnamed_addr constant [42 x i8] c"%s Failed to disable LTM before suspend\0A.\00", align 1
@__func__.usb_port_suspend = private unnamed_addr constant [17 x i8] c"usb_port_suspend\00", align 1
@.str.18 = private unnamed_addr constant [42 x i8] c"%s Failed to disable LPM before suspend\0A.\00", align 1
@usb_port_suspend.descriptor.19 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.usb_port_suspend, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.20, i32 0, i32 0), i8 -96, i8 11, i8 4, i8 0 }, section "__verbose", align 8
@.str.20 = private unnamed_addr constant [34 x i8] c"can't suspend port %d, status %d\0A\00", align 1
@usb_port_suspend.descriptor.21 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.usb_port_suspend, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.22, i32 0, i32 0), i8 -65, i8 11, i8 4, i8 0 }, section "__verbose", align 8
@.str.22 = private unnamed_addr constant [26 x i8] c"usb %ssuspend, wakeup %d\0A\00", align 1
@whitelist_table = internal global [4 x %struct.usb_device_id] [%struct.usb_device_id { i16 112, i16 0, i16 0, i16 0, i16 0, i8 9, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 0 }, %struct.usb_device_id { i16 112, i16 0, i16 0, i16 0, i16 0, i8 9, i8 0, i8 1, i8 0, i8 0, i8 0, i8 0, i64 0 }, %struct.usb_device_id { i16 3, i16 1317, i16 -23392, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 0 }, %struct.usb_device_id zeroinitializer], align 16
@.str.53 = private unnamed_addr constant [37 x i8] c"device v%04x p%04x is not supported\0A\00", align 1
@.str.12.23 = private unnamed_addr constant [40 x i8] c"can't autoresume for authorization: %d\0A\00", align 1
@.str.13.24 = private unnamed_addr constant [55 x i8] c"can't re-read device descriptor for authorization: %d\0A\00", align 1
@.str.15 = private unnamed_addr constant [23 x i8] c"authorized to connect\0A\00", align 1
@usb_port_resume.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usb_port_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.25, i32 0, i32 0), i8 103, i8 12, i8 4, i8 0 }, section "__verbose", align 8
@.str.25 = private unnamed_addr constant [34 x i8] c"can't resume usb port, status %d\0A\00", align 1
@usb_port_resume.descriptor.26 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usb_port_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.27, i32 0, i32 0), i8 125, i8 12, i8 4, i8 0 }, section "__verbose", align 8
@.str.27 = private unnamed_addr constant [33 x i8] c"can't resume port %d, status %d\0A\00", align 1
@usb_port_resume.descriptor.28 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usb_port_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.23.138, i32 0, i32 0), i8 -127, i8 12, i8 4, i8 0 }, section "__verbose", align 8
@usb_port_resume.descriptor.30 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usb_port_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.31, i32 0, i32 0), i8 -93, i8 12, i8 4, i8 0 }, section "__verbose", align 8
@.str.31 = private unnamed_addr constant [25 x i8] c"can't resume, status %d\0A\00", align 1
@__func__.usb_port_resume = private unnamed_addr constant [16 x i8] c"usb_port_resume\00", align 1
@finish_port_resume.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.finish_port_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11.859, i32 0, i32 0), i8 -21, i8 11, i8 4, i8 0 }, section "__verbose", align 8
@.str.63 = private unnamed_addr constant [20 x i8] c"finish reset-resume\00", align 1
@.str.64 = private unnamed_addr constant [14 x i8] c"finish resume\00", align 1
@finish_port_resume.descriptor.65 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.finish_port_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.66, i32 0, i32 0), i8 11, i8 12, i8 4, i8 0 }, section "__verbose", align 8
@.str.66 = private unnamed_addr constant [25 x i8] c"retry with reset-resume\0A\00", align 1
@finish_port_resume.descriptor.67 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.finish_port_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.68, i32 0, i32 0), i8 19, i8 12, i8 4, i8 0 }, section "__verbose", align 8
@.str.68 = private unnamed_addr constant [34 x i8] c"gone after usb resume? status %d\0A\00", align 1
@finish_port_resume.descriptor.69 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.finish_port_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.70, i32 0, i32 0), i8 50, i8 12, i8 4, i8 0 }, section "__verbose", align 8
@.str.70 = private unnamed_addr constant [34 x i8] c"disable remote wakeup, status %d\0A\00", align 1
@__func__.finish_port_resume = private unnamed_addr constant [19 x i8] c"finish_port_resume\00", align 1
@check_port_resume_type.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.check_port_resume_type, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.61, i32 0, i32 0), i8 -45, i8 10, i8 4, i8 0 }, section "__verbose", align 8
@.str.61 = private unnamed_addr constant [43 x i8] c"port %d status %04x.%04x after resume, %d\0A\00", align 1
@__func__.check_port_resume_type = private unnamed_addr constant [23 x i8] c"check_port_resume_type\00", align 1
@usb_remote_wakeup.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.usb_remote_wakeup, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.23.138, i32 0, i32 0), i8 -68, i8 12, i8 4, i8 0 }, section "__verbose", align 8
@.str.32 = private unnamed_addr constant [8 x i8] c"wakeup-\00", align 1
@__func__.usb_remote_wakeup = private unnamed_addr constant [18 x i8] c"usb_remote_wakeup\00", align 1
@hub_port_debounce.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.hub_port_debounce, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.34, i32 0, i32 0), i8 26, i8 15, i8 4, i8 0 }, section "__verbose", align 8
@.str.34 = private unnamed_addr constant [55 x i8] c"debounce: port %d: total %dms stable %dms status 0x%x\0A\00", align 1
@__func__.hub_port_debounce = private unnamed_addr constant [18 x i8] c"hub_port_debounce\00", align 1
@hub_driver = internal global %struct.usb_driver { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16.830, i32 0, i32 0), i32 (%struct.usb_interface*, %struct.usb_device_id*)* @hub_probe, void (%struct.usb_interface*)* @hub_disconnect, i32 (%struct.usb_interface*, i32, i8*)* @hub_ioctl, i32 (%struct.usb_interface*, i32)* @hub_suspend, i32 (%struct.usb_interface*)* @hub_resume, i32 (%struct.usb_interface*)* @hub_reset_resume, i32 (%struct.usb_interface*)* @hub_pre_reset, i32 (%struct.usb_interface*)* @hub_post_reset, %struct.usb_device_id* getelementptr inbounds ([4 x %struct.usb_device_id], [4 x %struct.usb_device_id]* @hub_id_table, i32 0, i32 0), %struct.__wait_queue_head zeroinitializer, %struct.usbdrv_wrap zeroinitializer, i8 2 }, align 8
@.str.35 = private unnamed_addr constant [33 x i8] c"\013%s: can't register hub driver\0A\00", align 1
@.str.36 = private unnamed_addr constant [6 x i8] c"khubd\00", align 1
@khubd_task = internal global %struct.task_struct* null, align 8
@.str.37 = private unnamed_addr constant [25 x i8] c"\013%s: can't start khubd\0A\00", align 1
@hub_thread.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.hub_thread, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.182, i32 0, i32 0), i8 -17, i8 18, i8 4, i8 0 }, section "__verbose", align 8
@.str.182 = private unnamed_addr constant [19 x i8] c"%s: khubd exiting\0A\00", align 1
@__func__.hub_thread = private unnamed_addr constant [11 x i8] c"hub_thread\00", align 1
@.str.257 = private unnamed_addr constant [24 x i8] c"include/linux/freezer.h\00", align 1
@system_freezing_cnt = external global %union.anon.5, align 4
@hub_events.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.hub_events, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.183, i32 0, i32 0), i8 14, i8 18, i8 4, i8 0 }, section "__verbose", align 8
@.str.183 = private unnamed_addr constant [37 x i8] c"state %d ports %d chg %04x evt %04x\0A\00", align 1
@hub_events.descriptor.184 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.hub_events, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.185, i32 0, i32 0), i8 32, i8 18, i8 4, i8 0 }, section "__verbose", align 8
@.str.185 = private unnamed_addr constant [22 x i8] c"Can't autoresume: %d\0A\00", align 1
@hub_events.descriptor.186 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.hub_events, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.187, i32 0, i32 0), i8 42, i8 18, i8 4, i8 0 }, section "__verbose", align 8
@.str.187 = private unnamed_addr constant [24 x i8] c"resetting for error %d\0A\00", align 1
@hub_events.descriptor.188 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.hub_events, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.189, i32 0, i32 0), i8 47, i8 18, i8 4, i8 0 }, section "__verbose", align 8
@.str.189 = private unnamed_addr constant [25 x i8] c"error resetting hub: %d\0A\00", align 1
@hub_events.descriptor.190 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.hub_events, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.191, i32 0, i32 0), i8 81, i8 18, i8 4, i8 0 }, section "__verbose", align 8
@.str.191 = private unnamed_addr constant [36 x i8] c"port %d enable change, status %08x\0A\00", align 1
@.str.192 = private unnamed_addr constant [48 x i8] c"port %i disabled by hub (EMI?), re-enabling...\0A\00", align 1
@hub_events.descriptor.193 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.hub_events, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.194, i32 0, i32 0), i8 112, i8 18, i8 4, i8 0 }, section "__verbose", align 8
@.str.194 = private unnamed_addr constant [32 x i8] c"over-current change on port %d\0A\00", align 1
@.str.195 = private unnamed_addr constant [35 x i8] c"over-current condition on port %d\0A\00", align 1
@hub_events.descriptor.196 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.hub_events, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.197, i32 0, i32 0), i8 126, i8 18, i8 4, i8 0 }, section "__verbose", align 8
@.str.197 = private unnamed_addr constant [25 x i8] c"reset change on port %d\0A\00", align 1
@hub_events.descriptor.198 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.hub_events, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.199, i32 0, i32 0), i8 -122, i8 18, i8 4, i8 0 }, section "__verbose", align 8
@.str.199 = private unnamed_addr constant [30 x i8] c"warm reset change on port %d\0A\00", align 1
@.str.200 = private unnamed_addr constant [25 x i8] c"config error on port %d\0A\00", align 1
@hub_events.descriptor.201 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.hub_events, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.202, i32 0, i32 0), i8 -98, i8 18, i8 4, i8 0 }, section "__verbose", align 8
@.str.202 = private unnamed_addr constant [20 x i8] c"warm reset port %d\0A\00", align 1
@.str.203 = private unnamed_addr constant [23 x i8] c"get_hub_status failed\0A\00", align 1
@hub_events.descriptor.204 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.hub_events, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.205, i32 0, i32 0), i8 -71, i8 18, i8 4, i8 0 }, section "__verbose", align 8
@.str.205 = private unnamed_addr constant [14 x i8] c"power change\0A\00", align 1
@hub_events.descriptor.206 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.hub_events, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.207, i32 0, i32 0), i8 -59, i8 18, i8 4, i8 0 }, section "__verbose", align 8
@.str.207 = private unnamed_addr constant [21 x i8] c"over-current change\0A\00", align 1
@.str.208 = private unnamed_addr constant [24 x i8] c"over-current condition\0A\00", align 1
@__func__.hub_events = private unnamed_addr constant [11 x i8] c"hub_events\00", align 1
@__func__.hub_hub_status = private unnamed_addr constant [15 x i8] c"hub_hub_status\00", align 1
@hub_port_connect_change.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.hub_port_connect_change, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.220, i32 0, i32 0), i8 -43, i8 16, i8 4, i8 0 }, section "__verbose", align 8
@.str.220 = private unnamed_addr constant [39 x i8] c"port %d, status %04x, change %04x, %s\0A\00", align 1
@__func__.hub_port_connect_change = private unnamed_addr constant [24 x i8] c"hub_port_connect_change\00", align 1
@.str.221 = private unnamed_addr constant [43 x i8] c"connect-debounce failed, port %d disabled\0A\00", align 1
@.str.222 = private unnamed_addr constant [38 x i8] c"couldn't allocate port %d usb_device\0A\00", align 1
@hub_port_connect_change.descriptor.223 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.hub_port_connect_change, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.224, i32 0, i32 0), i8 101, i8 17, i8 4, i8 0 }, section "__verbose", align 8
@.str.224 = private unnamed_addr constant [17 x i8] c"get status %d ?\0A\00", align 1
@.str.225 = private unnamed_addr constant [44 x i8] c"can't connect bus-powered hub to this port\0A\00", align 1
@highspeed_hubs = internal global i32 0, align 4
@hub_port_connect_change.descriptor.226 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.hub_port_connect_change, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.227, i32 0, i32 0), i8 -99, i8 17, i8 4, i8 0 }, section "__verbose", align 8
@.str.227 = private unnamed_addr constant [24 x i8] c"%dmA power budget left\0A\00", align 1
@.str.228 = private unnamed_addr constant [43 x i8] c"unable to enumerate USB device on port %d\0A\00", align 1
@.str.255 = private unnamed_addr constant [39 x i8] c"%dmA is over %umA budget for port %d!\0A\00", align 1
@.str.256 = private unnamed_addr constant [25 x i8] c"%dmA over power budget!\0A\00", align 1
@.str.254 = private unnamed_addr constant [55 x i8] c"not running at top speed; connect to a high speed hub\0A\00", align 1
@set_port_led.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__func__.set_port_led, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.104, i32 0, i32 0), i8 -75, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@.str.105 = private unnamed_addr constant [6 x i8] c"amber\00", align 1
@.str.106 = private unnamed_addr constant [6 x i8] c"green\00", align 1
@.str.107 = private unnamed_addr constant [4 x i8] c"off\00", align 1
@.str.108 = private constant [5 x i8] c"auto\00", align 1
@.str.104 = private unnamed_addr constant [32 x i8] c"port %d indicator %s status %d\0A\00", align 1
@__func__.set_port_led = private unnamed_addr constant [13 x i8] c"set_port_led\00", align 1
@.str.231 = private unnamed_addr constant [9 x i8] c"1.5 Mb/s\00", align 1
@.str.232 = private unnamed_addr constant [8 x i8] c"12 Mb/s\00", align 1
@.str.229 = private unnamed_addr constant [9 x i8] c"5.0 Gb/s\00", align 1
@.str.230 = private unnamed_addr constant [9 x i8] c"480 Mb/s\00", align 1
@hub_power_on.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__func__.hub_power_on, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.177, i32 0, i32 0), i8 48, i8 3, i8 4, i8 0 }, section "__verbose", align 8
@.str.177 = private unnamed_addr constant [29 x i8] c"enabling power on all ports\0A\00", align 1
@hub_power_on.descriptor.178 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__func__.hub_power_on, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.179, i32 0, i32 0), i8 51, i8 3, i8 4, i8 0 }, section "__verbose", align 8
@.str.179 = private unnamed_addr constant [51 x i8] c"trying to enable port power on non-switchable hub\0A\00", align 1
@__func__.hub_power_on = private unnamed_addr constant [13 x i8] c"hub_power_on\00", align 1
@hub_handle_remote_wakeup.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.hub_handle_remote_wakeup, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.209, i32 0, i32 0), i8 -35, i8 17, i8 4, i8 0 }, section "__verbose", align 8
@.str.209 = private unnamed_addr constant [30 x i8] c"resume on port %d, status %d\0A\00", align 1
@__func__.hub_handle_remote_wakeup = private unnamed_addr constant [25 x i8] c"hub_handle_remote_wakeup\00", align 1
@kref_get.__warned = internal global i8 0, section ".data.unlikely", align 1
@hub_id_table = internal constant [4 x %struct.usb_device_id] [%struct.usb_device_id { i16 129, i16 1507, i16 0, i16 0, i16 0, i8 0, i8 0, i8 0, i8 9, i8 0, i8 0, i8 0, i64 1 }, %struct.usb_device_id { i16 16, i16 0, i16 0, i16 0, i16 0, i8 9, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 0 }, %struct.usb_device_id { i16 128, i16 0, i16 0, i16 0, i16 0, i8 0, i8 0, i8 0, i8 9, i8 0, i8 0, i8 0, i64 0 }, %struct.usb_device_id zeroinitializer], align 16
@.str.172 = private unnamed_addr constant [22 x i8] c"set hub depth failed\0A\00", align 1
@.str.173 = private unnamed_addr constant [37 x i8] c"Host not accepting hub info update.\0A\00", align 1
@.str.174 = private unnamed_addr constant [53 x i8] c"LS/FS devices and hubs may not work under this hub\0A.\00", align 1
@hub_activate.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__func__.hub_activate, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.175, i32 0, i32 0), i8 56, i8 4, i8 4, i8 0 }, section "__verbose", align 8
@.str.175 = private unnamed_addr constant [34 x i8] c"port %d: status %04x change %04x\0A\00", align 1
@.str.176 = private unnamed_addr constant [17 x i8] c"activate --> %d\0A\00", align 1
@__func__.hub_activate = private unnamed_addr constant [13 x i8] c"hub_activate\00", align 1
@hub_reset_resume.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.hub_reset_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11.859, i32 0, i32 0), i8 19, i8 13, i8 4, i8 0 }, section "__verbose", align 8
@__func__.hub_reset_resume = private unnamed_addr constant [17 x i8] c"hub_reset_resume\00", align 1
@hub_resume.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.hub_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11.859, i32 0, i32 0), i8 10, i8 13, i8 4, i8 0 }, section "__verbose", align 8
@__func__.hub_resume = private unnamed_addr constant [11 x i8] c"hub_resume\00", align 1
@.str.181 = private unnamed_addr constant [24 x i8] c"port %d nyet suspended\0A\00", align 1
@hub_suspend.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.hub_suspend, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11.859, i32 0, i32 0), i8 -1, i8 12, i8 4, i8 0 }, section "__verbose", align 8
@__func__.hub_suspend = private unnamed_addr constant [12 x i8] c"hub_suspend\00", align 1
@.str.92 = private unnamed_addr constant [47 x i8] c"Unsupported bus topology: hub nested too deep\0A\00", align 1
@.str.93 = private unnamed_addr constant [23 x i8] c"ignoring external hub\0A\00", align 1
@.str.94 = private unnamed_addr constant [30 x i8] c"bad descriptor, ignoring hub\0A\00", align 1
@.str.95 = private unnamed_addr constant [15 x i8] c"USB hub found\0A\00", align 1
@hub_probe.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__func__.hub_probe, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.96, i32 0, i32 0), i8 -91, i8 6, i8 4, i8 0 }, section "__verbose", align 8
@.str.96 = private unnamed_addr constant [29 x i8] c"couldn't kmalloc hub struct\0A\00", align 1
@.str.97 = private unnamed_addr constant [22 x i8] c"(&(&hub->leds)->work)\00", align 1
@hub_probe.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.99 = private unnamed_addr constant [23 x i8] c"(&(&hub->leds)->timer)\00", align 1
@hub_probe.__key.98 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.101 = private unnamed_addr constant [27 x i8] c"(&(&hub->init_work)->work)\00", align 1
@hub_probe.__key.100 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.103 = private unnamed_addr constant [28 x i8] c"(&(&hub->init_work)->timer)\00", align 1
@hub_probe.__key.102 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.111 = private unnamed_addr constant [19 x i8] c"&hub->status_mutex\00", align 1
@hub_configure.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.115 = private unnamed_addr constant [20 x i8] c"%d port%s detected\0A\00", align 1
@hub_configure.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.117, i32 0, i32 0), i8 76, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.117 = private unnamed_addr constant [44 x i8] c"compound device; port removable status: %s\0A\00", align 1
@hub_configure.descriptor.118 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.119, i32 0, i32 0), i8 78, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.119 = private unnamed_addr constant [16 x i8] c"standalone hub\0A\00", align 1
@hub_configure.descriptor.120 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.121, i32 0, i32 0), i8 82, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.121 = private unnamed_addr constant [24 x i8] c"ganged power switching\0A\00", align 1
@hub_configure.descriptor.122 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.123, i32 0, i32 0), i8 85, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.123 = private unnamed_addr constant [33 x i8] c"individual port power switching\0A\00", align 1
@hub_configure.descriptor.124 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.125, i32 0, i32 0), i8 89, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.125 = private unnamed_addr constant [30 x i8] c"no power switching (usb 1.0)\0A\00", align 1
@hub_configure.descriptor.126 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.127, i32 0, i32 0), i8 95, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.127 = private unnamed_addr constant [32 x i8] c"global over-current protection\0A\00", align 1
@hub_configure.descriptor.128 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.129, i32 0, i32 0), i8 98, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.129 = private unnamed_addr constant [41 x i8] c"individual port over-current protection\0A\00", align 1
@hub_configure.descriptor.130 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.131, i32 0, i32 0), i8 102, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.131 = private unnamed_addr constant [28 x i8] c"no over-current protection\0A\00", align 1
@.str.133 = private unnamed_addr constant [24 x i8] c"&(&hub->tt.lock)->rlock\00", align 1
@hub_configure.__key.132 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.135 = private unnamed_addr constant [22 x i8] c"(&hub->tt.clear_work)\00", align 1
@hub_configure.__key.134 = internal global %struct.lock_class_key zeroinitializer, align 1
@hub_configure.descriptor.136 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.137, i32 0, i32 0), i8 113, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.137 = private unnamed_addr constant [11 x i8] c"Single TT\0A\00", align 1
@hub_configure.descriptor.138 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.139, i32 0, i32 0), i8 119, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.139 = private unnamed_addr constant [13 x i8] c"TT per port\0A\00", align 1
@.str.140 = private unnamed_addr constant [26 x i8] c"Using single TT (err %d)\0A\00", align 1
@hub_configure.descriptor.141 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.142, i32 0, i32 0), i8 -125, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.142 = private unnamed_addr constant [30 x i8] c"Unrecognized hub protocol %d\0A\00", align 1
@hub_configure.descriptor.143 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.144, i32 0, i32 0), i8 -114, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.144 = private unnamed_addr constant [45 x i8] c"TT requires at most %d FS bit times (%d ns)\0A\00", align 1
@hub_configure.descriptor.145 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.144, i32 0, i32 0), i8 -107, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@hub_configure.descriptor.146 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.144, i32 0, i32 0), i8 -101, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@hub_configure.descriptor.147 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.144, i32 0, i32 0), i8 -95, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@hub_configure.descriptor.148 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.149, i32 0, i32 0), i8 -88, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.149 = private unnamed_addr constant [31 x i8] c"Port indicators are supported\0A\00", align 1
@hub_configure.descriptor.150 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.151, i32 0, i32 0), i8 -84, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.151 = private unnamed_addr constant [35 x i8] c"power on to power good time: %dms\0A\00", align 1
@hub_configure.descriptor.153 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.154, i32 0, i32 0), i8 -56, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.154 = private unnamed_addr constant [42 x i8] c"hub controller current requirement: %dmA\0A\00", align 1
@.str.155 = private unnamed_addr constant [58 x i8] c"insufficient power available to use all downstream ports\0A\00", align 1
@hub_configure.descriptor.156 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.157, i32 0, i32 0), i8 -40, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.157 = private unnamed_addr constant [38 x i8] c"%umA bus power budget for each child\0A\00", align 1
@hub_configure.descriptor.159 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.160, i32 0, i32 0), i8 -16, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.161 = private unnamed_addr constant [16 x i8] c"lost (inactive)\00", align 1
@.str.162 = private unnamed_addr constant [5 x i8] c"good\00", align 1
@.str.160 = private unnamed_addr constant [26 x i8] c"local power source is %s\0A\00", align 1
@hub_configure.descriptor.163 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.hub_configure, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.164, i32 0, i32 0), i8 -12, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.165 = private unnamed_addr constant [4 x i8] c"no \00", align 1
@.str.164 = private unnamed_addr constant [33 x i8] c"%sover-current condition exists\0A\00", align 1
@.str.166 = private unnamed_addr constant [32 x i8] c"couldn't create port%d device.\0A\00", align 1
@.str.110 = private unnamed_addr constant [14 x i8] c"out of memory\00", align 1
@.str.112 = private unnamed_addr constant [26 x i8] c"can't read hub descriptor\00", align 1
@.str.113 = private unnamed_addr constant [24 x i8] c"hub has too many ports!\00", align 1
@.str.114 = private unnamed_addr constant [28 x i8] c"hub doesn't have any ports!\00", align 1
@.str.152 = private unnamed_addr constant [21 x i8] c"can't get hub status\00", align 1
@.str.158 = private unnamed_addr constant [26 x i8] c"can't update HCD hub info\00", align 1
@.str.167 = private unnamed_addr constant [28 x i8] c"config failed, %s (err %d)\0A\00", align 1
@usb_hub_adjust_deviceremovable.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__func__.usb_hub_adjust_deviceremovable, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.str.39, i32 0, i32 0), i8 -16, i8 20, i8 4, i8 0 }, section "__verbose", align 8
@.str.39 = private unnamed_addr constant [81 x i8] c"usb port%d's DeviceRemovable is changed to 1 according to platform information.\0A\00", align 1
@usb_hub_adjust_deviceremovable.descriptor.40 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__func__.usb_hub_adjust_deviceremovable, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.str.39, i32 0, i32 0), i8 0, i8 21, i8 4, i8 0 }, section "__verbose", align 8
@__func__.usb_hub_adjust_deviceremovable = private unnamed_addr constant [31 x i8] c"usb_hub_adjust_deviceremovable\00", align 1
@hub_irq.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @__func__.hub_irq, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.170, i32 0, i32 0), i8 125, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.170 = private unnamed_addr constant [17 x i8] c"transfer --> %d\0A\00", align 1
@.str.171 = private unnamed_addr constant [17 x i8] c"resubmit --> %d\0A\00", align 1
@__func__.hub_irq = private unnamed_addr constant [8 x i8] c"hub_irq\00", align 1
@__func__.hub_configure = private unnamed_addr constant [14 x i8] c"hub_configure\00", align 1
@.str.168 = private unnamed_addr constant [29 x i8] c"clear tt %d (%04x) error %d\0A\00", align 1
@__func__.hub_probe = private unnamed_addr constant [10 x i8] c"hub_probe\00", align 1
@usb_hcds_loaded = common global i64 0, align 8
@usb_bus_list = global %struct.list_head { %struct.list_head* @usb_bus_list, %struct.list_head* @usb_bus_list }, align 8
@usb_bus_list_lock = global %struct.mutex { %union.anon.5 { i32 1 }, %struct.spinlock { %union.anon.4 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.40, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usb_bus_list_lock to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usb_bus_list_lock to i8*), i64 80) to %struct.list_head*) }, %struct.task_struct* null, i8* null, i8* bitcast (%struct.mutex* @usb_bus_list_lock to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.1.41, i32 0, i32 0), i32 0, i64 0 } }, align 8
@.str.40 = private unnamed_addr constant [28 x i8] c"usb_bus_list_lock.wait_lock\00", align 1
@.str.1.41 = private unnamed_addr constant [18 x i8] c"usb_bus_list_lock\00", align 1
@usb_kill_urb_queue = global %struct.__wait_queue_head { %struct.spinlock { %union.anon.4 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.2.42, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.__wait_queue_head* @usb_kill_urb_queue to i8*), i64 72) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.__wait_queue_head* @usb_kill_urb_queue to i8*), i64 72) to %struct.list_head*) } }, align 8
@.str.2.42 = private unnamed_addr constant [24 x i8] c"usb_kill_urb_queue.lock\00", align 1
@mon_ops = common global %struct.usb_mon_operations* null, align 8
@__kcrctab_usb_hcds_loaded = internal constant i64 ptrtoint (i8** @__crc_usb_hcds_loaded to i64), section "___kcrctab_gpl+usb_hcds_loaded", align 8
@__ksymtab_usb_hcds_loaded = internal constant %struct.kernel_symbol { i64 ptrtoint (i64* @usb_hcds_loaded to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_usb_hcds_loaded, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcds_loaded", align 8
@__kcrctab_usb_bus_list = internal constant i64 ptrtoint (i8** @__crc_usb_bus_list to i64), section "___kcrctab_gpl+usb_bus_list", align 8
@__ksymtab_usb_bus_list = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.list_head* @usb_bus_list to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_bus_list, i32 0, i32 0) }, section "___ksymtab_gpl+usb_bus_list", align 8
@__kcrctab_usb_bus_list_lock = internal constant i64 ptrtoint (i8** @__crc_usb_bus_list_lock to i64), section "___kcrctab_gpl+usb_bus_list_lock", align 8
@__ksymtab_usb_bus_list_lock = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.mutex* @usb_bus_list_lock to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_usb_bus_list_lock, i32 0, i32 0) }, section "___ksymtab_gpl+usb_bus_list_lock", align 8
@__param_authorized_default = internal constant %struct.kernel_param { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.74.54, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 420, i16 -1, %union.anon.3 { i8* bitcast (i32* @authorized_default to i8*) } }, section "__param", align 8
@__UNIQUE_ID_authorized_defaulttype347 = internal constant [32 x i8] c"parmtype=authorized_default:int\00", section ".modinfo", align 1
@__UNIQUE_ID_authorized_default351 = internal constant [161 x i8] c"parm=authorized_default:Default USB device authorization: 0 is not authorized, 1 is authorized, -1 is authorized except for wireless USB (default, old behaviour\00", section ".modinfo", align 1
@__kcrctab_usb_hcd_poll_rh_status = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_poll_rh_status to i64), section "___kcrctab_gpl+usb_hcd_poll_rh_status", align 8
@__ksymtab_usb_hcd_poll_rh_status = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.588*)* @usb_hcd_poll_rh_status to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_usb_hcd_poll_rh_status, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_poll_rh_status", align 8
@__kcrctab_usb_hcd_start_port_resume = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_start_port_resume to i64), section "___kcrctab_gpl+usb_hcd_start_port_resume", align 8
@__ksymtab_usb_hcd_start_port_resume = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_bus*, i32)* @usb_hcd_start_port_resume to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_usb_hcd_start_port_resume, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_start_port_resume", align 8
@__kcrctab_usb_hcd_end_port_resume = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_end_port_resume to i64), section "___kcrctab_gpl+usb_hcd_end_port_resume", align 8
@__ksymtab_usb_hcd_end_port_resume = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_bus*, i32)* @usb_hcd_end_port_resume to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_hcd_end_port_resume, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_end_port_resume", align 8
@__kcrctab_usb_calc_bus_time = internal constant i64 ptrtoint (i8** @__crc_usb_calc_bus_time to i64), section "___kcrctab_gpl+usb_calc_bus_time", align 8
@__ksymtab_usb_calc_bus_time = internal constant %struct.kernel_symbol { i64 ptrtoint (i64 (i32, i32, i32, i32)* @usb_calc_bus_time to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_usb_calc_bus_time, i32 0, i32 0) }, section "___ksymtab_gpl+usb_calc_bus_time", align 8
@__kcrctab_usb_hcd_link_urb_to_ep = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_link_urb_to_ep to i64), section "___kcrctab_gpl+usb_hcd_link_urb_to_ep", align 8
@__ksymtab_usb_hcd_link_urb_to_ep = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_hcd.588*, %struct.urb*)* @usb_hcd_link_urb_to_ep to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_usb_hcd_link_urb_to_ep, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_link_urb_to_ep", align 8
@__kcrctab_usb_hcd_check_unlink_urb = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_check_unlink_urb to i64), section "___kcrctab_gpl+usb_hcd_check_unlink_urb", align 8
@__ksymtab_usb_hcd_check_unlink_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_hcd.588*, %struct.urb*, i32)* @usb_hcd_check_unlink_urb to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_hcd_check_unlink_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_check_unlink_urb", align 8
@__kcrctab_usb_hcd_unlink_urb_from_ep = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_unlink_urb_from_ep to i64), section "___kcrctab_gpl+usb_hcd_unlink_urb_from_ep", align 8
@__ksymtab_usb_hcd_unlink_urb_from_ep = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.588*, %struct.urb*)* @usb_hcd_unlink_urb_from_ep to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab_usb_hcd_unlink_urb_from_ep, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_unlink_urb_from_ep", align 8
@__kcrctab_usb_hcd_unmap_urb_setup_for_dma = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_unmap_urb_setup_for_dma to i64), section "___kcrctab_gpl+usb_hcd_unmap_urb_setup_for_dma", align 8
@__ksymtab_usb_hcd_unmap_urb_setup_for_dma = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.588*, %struct.urb*)* @usb_hcd_unmap_urb_setup_for_dma to i64), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__kstrtab_usb_hcd_unmap_urb_setup_for_dma, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_unmap_urb_setup_for_dma", align 8
@__kcrctab_usb_hcd_unmap_urb_for_dma = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_unmap_urb_for_dma to i64), section "___kcrctab_gpl+usb_hcd_unmap_urb_for_dma", align 8
@__ksymtab_usb_hcd_unmap_urb_for_dma = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.588*, %struct.urb*)* @usb_hcd_unmap_urb_for_dma to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_usb_hcd_unmap_urb_for_dma, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_unmap_urb_for_dma", align 8
@__kcrctab_usb_hcd_map_urb_for_dma = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_map_urb_for_dma to i64), section "___kcrctab_gpl+usb_hcd_map_urb_for_dma", align 8
@__ksymtab_usb_hcd_map_urb_for_dma = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_hcd.588*, %struct.urb*, i32)* @usb_hcd_map_urb_for_dma to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_hcd_map_urb_for_dma, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_map_urb_for_dma", align 8
@__kcrctab_usb_hcd_giveback_urb = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_giveback_urb to i64), section "___kcrctab_gpl+usb_hcd_giveback_urb", align 8
@__ksymtab_usb_hcd_giveback_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.588*, %struct.urb*, i32)* @usb_hcd_giveback_urb to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_usb_hcd_giveback_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_giveback_urb", align 8
@__kcrctab_usb_alloc_streams = internal constant i64 ptrtoint (i8** @__crc_usb_alloc_streams to i64), section "___kcrctab_gpl+usb_alloc_streams", align 8
@__ksymtab_usb_alloc_streams = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_interface*, %struct.usb_host_endpoint**, i32, i32, i32)* @usb_alloc_streams to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_usb_alloc_streams, i32 0, i32 0) }, section "___ksymtab_gpl+usb_alloc_streams", align 8
@__kcrctab_usb_free_streams = internal constant i64 ptrtoint (i8** @__crc_usb_free_streams to i64), section "___kcrctab_gpl+usb_free_streams", align 8
@__ksymtab_usb_free_streams = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_interface*, %struct.usb_host_endpoint**, i32, i32)* @usb_free_streams to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_free_streams, i32 0, i32 0) }, section "___ksymtab_gpl+usb_free_streams", align 8
@__kcrctab_usb_hcd_resume_root_hub = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_resume_root_hub to i64), section "___kcrctab_gpl+usb_hcd_resume_root_hub", align 8
@__ksymtab_usb_hcd_resume_root_hub = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.588*)* @usb_hcd_resume_root_hub to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_hcd_resume_root_hub, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_resume_root_hub", align 8
@__kcrctab_usb_bus_start_enum = internal constant i64 ptrtoint (i8** @__crc_usb_bus_start_enum to i64), section "___kcrctab_gpl+usb_bus_start_enum", align 8
@__ksymtab_usb_bus_start_enum = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_bus*, i32)* @usb_bus_start_enum to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_bus_start_enum, i32 0, i32 0) }, section "___ksymtab_gpl+usb_bus_start_enum", align 8
@__kcrctab_usb_hcd_irq = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_irq to i64), section "___kcrctab_gpl+usb_hcd_irq", align 8
@__ksymtab_usb_hcd_irq = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, i8*)* @usb_hcd_irq to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_hcd_irq, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_irq", align 8
@__kcrctab_usb_hc_died = internal constant i64 ptrtoint (i8** @__crc_usb_hc_died to i64), section "___kcrctab_gpl+usb_hc_died", align 8
@__ksymtab_usb_hc_died = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.588*)* @usb_hc_died to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_hc_died, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hc_died", align 8
@__kcrctab_usb_create_shared_hcd = internal constant i64 ptrtoint (i8** @__crc_usb_create_shared_hcd to i64), section "___kcrctab_gpl+usb_create_shared_hcd", align 8
@__ksymtab_usb_create_shared_hcd = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_hcd.588* (%struct.hc_driver.589*, %struct.device*, i8*, %struct.usb_hcd.588*)* @usb_create_shared_hcd to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_usb_create_shared_hcd, i32 0, i32 0) }, section "___ksymtab_gpl+usb_create_shared_hcd", align 8
@__kcrctab_usb_create_hcd = internal constant i64 ptrtoint (i8** @__crc_usb_create_hcd to i64), section "___kcrctab_gpl+usb_create_hcd", align 8
@__ksymtab_usb_create_hcd = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_hcd.588* (%struct.hc_driver.589*, %struct.device*, i8*)* @usb_create_hcd to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_create_hcd, i32 0, i32 0) }, section "___ksymtab_gpl+usb_create_hcd", align 8
@__kcrctab_usb_get_hcd = internal constant i64 ptrtoint (i8** @__crc_usb_get_hcd to i64), section "___kcrctab_gpl+usb_get_hcd", align 8
@__ksymtab_usb_get_hcd = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_hcd.588* (%struct.usb_hcd.588*)* @usb_get_hcd to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_get_hcd, i32 0, i32 0) }, section "___ksymtab_gpl+usb_get_hcd", align 8
@__kcrctab_usb_put_hcd = internal constant i64 ptrtoint (i8** @__crc_usb_put_hcd to i64), section "___kcrctab_gpl+usb_put_hcd", align 8
@__ksymtab_usb_put_hcd = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.588*)* @usb_put_hcd to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_put_hcd, i32 0, i32 0) }, section "___ksymtab_gpl+usb_put_hcd", align 8
@__kcrctab_usb_hcd_is_primary_hcd = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_is_primary_hcd to i64), section "___kcrctab_gpl+usb_hcd_is_primary_hcd", align 8
@__ksymtab_usb_hcd_is_primary_hcd = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_hcd.588*)* @usb_hcd_is_primary_hcd to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_usb_hcd_is_primary_hcd, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_is_primary_hcd", align 8
@__kcrctab_usb_add_hcd = internal constant i64 ptrtoint (i8** @__crc_usb_add_hcd to i64), section "___kcrctab_gpl+usb_add_hcd", align 8
@__ksymtab_usb_add_hcd = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_hcd.588*, i32, i64)* @usb_add_hcd to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_add_hcd, i32 0, i32 0) }, section "___ksymtab_gpl+usb_add_hcd", align 8
@__kcrctab_usb_remove_hcd = internal constant i64 ptrtoint (i8** @__crc_usb_remove_hcd to i64), section "___kcrctab_gpl+usb_remove_hcd", align 8
@__ksymtab_usb_remove_hcd = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_hcd.588*)* @usb_remove_hcd to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_remove_hcd, i32 0, i32 0) }, section "___ksymtab_gpl+usb_remove_hcd", align 8
@__kcrctab_usb_hcd_platform_shutdown = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_platform_shutdown to i64), section "___kcrctab_gpl+usb_hcd_platform_shutdown", align 8
@__ksymtab_usb_hcd_platform_shutdown = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.platform_device*)* @usb_hcd_platform_shutdown to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_usb_hcd_platform_shutdown, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_platform_shutdown", align 8
@__kcrctab_usb_mon_register = internal constant i64 ptrtoint (i8** @__crc_usb_mon_register to i64), section "___kcrctab_gpl+usb_mon_register", align 8
@__ksymtab_usb_mon_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_mon_operations*)* @usb_mon_register to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_mon_register, i32 0, i32 0) }, section "___ksymtab_gpl+usb_mon_register", align 8
@__kcrctab_usb_mon_deregister = internal constant i64 ptrtoint (i8** @__crc_usb_mon_deregister to i64), section "___kcrctab_gpl+usb_mon_deregister", align 8
@__ksymtab_usb_mon_deregister = internal constant %struct.kernel_symbol { i64 ptrtoint (void ()* @usb_mon_deregister to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_mon_deregister, i32 0, i32 0) }, section "___ksymtab_gpl+usb_mon_deregister", align 8
@__kstrtab_usb_mon_deregister = internal constant [19 x i8] c"usb_mon_deregister\00", section "__ksymtab_strings", align 1
@.str.47.44 = private unnamed_addr constant [35 x i8] c"\013USB: monitor was not registered\0A\00", align 1
@__crc_usb_mon_deregister = extern_weak global i8*, align 8
@__kstrtab_usb_mon_register = internal constant [17 x i8] c"usb_mon_register\00", section "__ksymtab_strings", align 1
@__crc_usb_mon_register = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_platform_shutdown = internal constant [26 x i8] c"usb_hcd_platform_shutdown\00", section "__ksymtab_strings", align 1
@__crc_usb_hcd_platform_shutdown = extern_weak global i8*, align 8
@__kstrtab_usb_remove_hcd = internal constant [15 x i8] c"usb_remove_hcd\00", section "__ksymtab_strings", align 1
@.str.45.45 = private unnamed_addr constant [18 x i8] c"remove, state %x\0A\00", align 1
@usb_bus_attr_group = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([2 x %struct.attribute*], [2 x %struct.attribute*]* @usb_bus_attrs, i32 0, i32 0) }, align 8
@usb_remove_hcd.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.usb_remove_hcd, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.46.47, i32 0, i32 0), i8 83, i8 10, i8 4, i8 0 }, section "__verbose", align 8
@.str.46.47 = private unnamed_addr constant [29 x i8] c"roothub graceful disconnect\0A\00", align 1
@hcd_root_hub_lock = internal global %struct.spinlock { %union.anon.4 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.49.51, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@.str.76.50 = private unnamed_addr constant [25 x i8] c"USB bus %d deregistered\0A\00", align 1
@busmap = internal global %struct.sigset_t zeroinitializer, align 8
@.str.49.51 = private unnamed_addr constant [18 x i8] c"hcd_root_hub_lock\00", align 1
@__func__.usb_remove_hcd = private unnamed_addr constant [15 x i8] c"usb_remove_hcd\00", align 1
@.str.4.53 = private unnamed_addr constant [23 x i8] c"drivers/usb/core/hcd.c\00", align 1
@usb_bus_attrs = internal global [2 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_authorized_default, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_authorized_default = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.74.54, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @usb_host_authorized_default_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @usb_host_authorized_default_store }, align 8
@.str.74.54 = private constant [19 x i8] c"authorized_default\00", align 16
@__crc_usb_remove_hcd = extern_weak global i8*, align 8
@__kstrtab_usb_add_hcd = internal constant [12 x i8] c"usb_add_hcd\00", section "__ksymtab_strings", align 1
@authorized_default = internal global i32 -1, align 4
@usb_add_hcd.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.usb_add_hcd, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.38.59, i32 0, i32 0), i8 -67, i8 9, i8 4, i8 0 }, section "__verbose", align 8
@.str.38.59 = private unnamed_addr constant [19 x i8] c"pool alloc failed\0A\00", align 1
@.str.39.60 = private unnamed_addr constant [29 x i8] c"unable to allocate root hub\0A\00", align 1
@.str.40.61 = private unnamed_addr constant [13 x i8] c"can't setup\0A\00", align 1
@usb_add_hcd.descriptor.41 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.usb_add_hcd, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.42.62, i32 0, i32 0), i8 -14, i8 9, i8 4, i8 0 }, section "__verbose", align 8
@.str.42.62 = private unnamed_addr constant [28 x i8] c"supports USB remote wakeup\0A\00", align 1
@.str.43.63 = private unnamed_addr constant [18 x i8] c"startup error %d\0A\00", align 1
@.str.44.64 = private unnamed_addr constant [48 x i8] c"\013Cannot register USB bus sysfs attributes: %d\0A\00", align 1
@.str.51.68 = private unnamed_addr constant [41 x i8] c"include/asm-generic/dma-mapping-common.h\00", align 1
@dma_ops = external global %struct.dma_map_ops*, align 8
@hcd_urb_list_lock = internal global %struct.spinlock { %union.anon.4 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.50.71, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@.str.50.71 = private unnamed_addr constant [18 x i8] c"hcd_urb_list_lock\00", align 1
@register_root_hub.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.register_root_hub, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.70.72, i32 0, i32 0), i8 -22, i8 3, i8 4, i8 0 }, section "__verbose", align 8
@.str.70.72 = private unnamed_addr constant [36 x i8] c"can't read %s device descriptor %d\0A\00", align 1
@register_root_hub.descriptor.71 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.register_root_hub, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.72.73, i32 0, i32 0), i8 -14, i8 3, i8 4, i8 0 }, section "__verbose", align 8
@.str.72.73 = private unnamed_addr constant [33 x i8] c"can't read %s bos descriptor %d\0A\00", align 1
@.str.73.74 = private unnamed_addr constant [36 x i8] c"can't register root hub for %s, %d\0A\00", align 1
@.str.27.75 = private unnamed_addr constant [22 x i8] c"HC died; cleaning up\0A\00", align 1
@__func__.register_root_hub = private unnamed_addr constant [18 x i8] c"register_root_hub\00", align 1
@.str.64.76 = private unnamed_addr constant [9 x i8] c"%s:usb%d\00", align 1
@.str.65 = private unnamed_addr constant [29 x i8] c"request interrupt %d failed\0A\00", align 1
@.str.67 = private unnamed_addr constant [7 x i8] c"io mem\00", align 1
@.str.68.77 = private unnamed_addr constant [8 x i8] c"io base\00", align 1
@.str.66.78 = private unnamed_addr constant [21 x i8] c"irq %d, %s 0x%08llx\0A\00", align 1
@.str.69 = private unnamed_addr constant [13 x i8] c"%s 0x%08llx\0A\00", align 1
@pv_irq_ops = external global %struct.pv_irq_ops.581, align 8
@__func__.usb_add_hcd = private unnamed_addr constant [12 x i8] c"usb_add_hcd\00", align 1
@.str.62.80 = private unnamed_addr constant [22 x i8] c"\013%s: too many buses\0A\00", align 1
@.str.63.81 = private unnamed_addr constant [48 x i8] c"new USB bus registered, assigned bus number %d\0A\00", align 1
@__crc_usb_add_hcd = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_is_primary_hcd = internal constant [23 x i8] c"usb_hcd_is_primary_hcd\00", section "__ksymtab_strings", align 1
@__crc_usb_hcd_is_primary_hcd = extern_weak global i8*, align 8
@__kstrtab_usb_put_hcd = internal constant [12 x i8] c"usb_put_hcd\00", section "__ksymtab_strings", align 1
@__crc_usb_put_hcd = extern_weak global i8*, align 8
@__kstrtab_usb_get_hcd = internal constant [12 x i8] c"usb_get_hcd\00", section "__ksymtab_strings", align 1
@kref_get.__warned.92 = internal global i8 0, section ".data.unlikely", align 1
@__crc_usb_get_hcd = extern_weak global i8*, align 8
@__kstrtab_usb_create_hcd = internal constant [15 x i8] c"usb_create_hcd\00", section "__ksymtab_strings", align 1
@usb_create_shared_hcd.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.usb_create_shared_hcd, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.28, i32 0, i32 0), i8 4, i8 9, i8 4, i8 0 }, section "__verbose", align 8
@.str.28 = private unnamed_addr constant [18 x i8] c"hcd alloc failed\0A\00", align 1
@usb_create_shared_hcd.descriptor.29 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.usb_create_shared_hcd, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.30, i32 0, i32 0), i8 12, i8 9, i8 4, i8 0 }, section "__verbose", align 8
@.str.30 = private unnamed_addr constant [34 x i8] c"hcd bandwidth mutex alloc failed\0A\00", align 1
@.str.31.95 = private unnamed_addr constant [21 x i8] c"hcd->bandwidth_mutex\00", align 1
@usb_create_shared_hcd.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.33.97 = private unnamed_addr constant [17 x i8] c"(&hcd->rh_timer)\00", align 1
@usb_create_shared_hcd.__key.32 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.35.98 = private unnamed_addr constant [20 x i8] c"(&hcd->wakeup_work)\00", align 1
@usb_create_shared_hcd.__key.34 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.36.99 = private unnamed_addr constant [20 x i8] c"USB Host Controller\00", align 1
@__func__.usb_create_shared_hcd = private unnamed_addr constant [22 x i8] c"usb_create_shared_hcd\00", align 1
@__crc_usb_create_hcd = extern_weak global i8*, align 8
@__kstrtab_usb_create_shared_hcd = internal constant [22 x i8] c"usb_create_shared_hcd\00", section "__ksymtab_strings", align 1
@__crc_usb_create_shared_hcd = extern_weak global i8*, align 8
@__kstrtab_usb_hc_died = internal constant [12 x i8] c"usb_hc_died\00", section "__ksymtab_strings", align 1
@__crc_usb_hc_died = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_irq = internal constant [12 x i8] c"usb_hcd_irq\00", section "__ksymtab_strings", align 1
@__crc_usb_hcd_irq = extern_weak global i8*, align 8
@__kstrtab_usb_bus_start_enum = internal constant [19 x i8] c"usb_bus_start_enum\00", section "__ksymtab_strings", align 1
@__crc_usb_bus_start_enum = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_resume_root_hub = internal constant [24 x i8] c"usb_hcd_resume_root_hub\00", section "__ksymtab_strings", align 1
@pm_wq = external global %struct.workqueue_struct*, align 8
@__crc_usb_hcd_resume_root_hub = extern_weak global i8*, align 8
@__kstrtab_usb_free_streams = internal constant [17 x i8] c"usb_free_streams\00", section "__ksymtab_strings", align 1
@__crc_usb_free_streams = extern_weak global i8*, align 8
@__kstrtab_usb_alloc_streams = internal constant [18 x i8] c"usb_alloc_streams\00", section "__ksymtab_strings", align 1
@__crc_usb_alloc_streams = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_giveback_urb = internal constant [21 x i8] c"usb_hcd_giveback_urb\00", section "__ksymtab_strings", align 1
@__crc_usb_hcd_giveback_urb = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_map_urb_for_dma = internal constant [24 x i8] c"usb_hcd_map_urb_for_dma\00", section "__ksymtab_strings", align 1
@hcd_alloc_coherent.__warned = internal global i8 0, section ".data.unlikely", align 1
@__crc_usb_hcd_map_urb_for_dma = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_unmap_urb_for_dma = internal constant [26 x i8] c"usb_hcd_unmap_urb_for_dma\00", section "__ksymtab_strings", align 1
@__crc_usb_hcd_unmap_urb_for_dma = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_unmap_urb_setup_for_dma = internal constant [32 x i8] c"usb_hcd_unmap_urb_setup_for_dma\00", section "__ksymtab_strings", align 1
@__crc_usb_hcd_unmap_urb_setup_for_dma = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_unlink_urb_from_ep = internal constant [27 x i8] c"usb_hcd_unlink_urb_from_ep\00", section "__ksymtab_strings", align 1
@__crc_usb_hcd_unlink_urb_from_ep = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_check_unlink_urb = internal constant [25 x i8] c"usb_hcd_check_unlink_urb\00", section "__ksymtab_strings", align 1
@__crc_usb_hcd_check_unlink_urb = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_link_urb_to_ep = internal constant [23 x i8] c"usb_hcd_link_urb_to_ep\00", section "__ksymtab_strings", align 1
@__crc_usb_hcd_link_urb_to_ep = extern_weak global i8*, align 8
@__kstrtab_usb_calc_bus_time = internal constant [18 x i8] c"usb_calc_bus_time\00", section "__ksymtab_strings", align 1
@usb_calc_bus_time.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.usb_calc_bus_time, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.5.107, i32 0, i32 0), i8 95, i8 4, i8 4, i8 0 }, section "__verbose", align 8
@.str.5.107 = private unnamed_addr constant [25 x i8] c"%s: bogus device speed!\0A\00", align 1
@__func__.usb_calc_bus_time = private unnamed_addr constant [18 x i8] c"usb_calc_bus_time\00", align 1
@__crc_usb_calc_bus_time = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_end_port_resume = internal constant [24 x i8] c"usb_hcd_end_port_resume\00", section "__ksymtab_strings", align 1
@__crc_usb_hcd_end_port_resume = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_start_port_resume = internal constant [26 x i8] c"usb_hcd_start_port_resume\00", section "__ksymtab_strings", align 1
@__crc_usb_hcd_start_port_resume = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_poll_rh_status = internal constant [23 x i8] c"usb_hcd_poll_rh_status\00", section "__ksymtab_strings", align 1
@__crc_usb_hcd_poll_rh_status = extern_weak global i8*, align 8
@__kstrtab_usb_bus_list_lock = internal constant [18 x i8] c"usb_bus_list_lock\00", section "__ksymtab_strings", align 1
@__crc_usb_bus_list_lock = extern_weak global i8*, align 8
@__kstrtab_usb_bus_list = internal constant [13 x i8] c"usb_bus_list\00", section "__ksymtab_strings", align 1
@__crc_usb_bus_list = extern_weak global i8*, align 8
@__kstrtab_usb_hcds_loaded = internal constant [16 x i8] c"usb_hcds_loaded\00", section "__ksymtab_strings", align 1
@__crc_usb_hcds_loaded = extern_weak global i8*, align 8
@usb3_rh_dev_descriptor = internal constant [18 x i8] c"\12\01\00\03\09\00\03\09k\1D\03\00\10\03\03\02\01\01", align 16
@usb2_rh_dev_descriptor = internal constant [18 x i8] c"\12\01\00\02\09\00\00@k\1D\02\00\10\03\03\02\01\01", align 16
@usb11_rh_dev_descriptor = internal constant [18 x i8] c"\12\01\10\01\09\00\00@k\1D\01\00\10\03\03\02\01\01", align 16
@ss_rh_config_descriptor = internal constant [31 x i8] c"\09\02\1F\00\01\01\00\C0\00\09\04\00\00\01\09\00\00\00\07\05\81\03\04\00\0C\060\00\00\02\00", align 16
@hs_rh_config_descriptor = internal constant [25 x i8] c"\09\02\19\00\01\01\00\C0\00\09\04\00\00\01\09\00\00\00\07\05\81\03\04\00\0C", align 16
@fs_rh_config_descriptor = internal constant [25 x i8] c"\09\02\19\00\01\01\00\C0\00\09\04\00\00\01\09\00\00\00\07\05\81\03\02\00\FF", align 16
@rh_call_control.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.rh_call_control, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.54.111, i32 0, i32 0), i8 73, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.54.111 = private unnamed_addr constant [28 x i8] c"root hub device address %d\0A\00", align 1
@rh_call_control.descriptor.55 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.rh_call_control, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.56.112, i32 0, i32 0), i8 88, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.56.112 = private unnamed_addr constant [26 x i8] c"no endpoint features yet\0A\00", align 1
@rh_call_control.descriptor.57 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.rh_call_control, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.58.113, i32 0, i32 0), i8 -128, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.58.113 = private unnamed_addr constant [52 x i8] c"CTRL: TypeReq=0x%x val=0x%x idx=0x%x len=%d ==> %d\0A\00", align 1
@__func__.rh_call_control = private unnamed_addr constant [16 x i8] c"rh_call_control\00", align 1
@rh_string.langids = internal constant [4 x i8] c"\04\03\09\04", align 1
@.str.59.114 = private unnamed_addr constant [9 x i8] c"%s %s %s\00", align 1
@init_uts_ns = external global %struct.uts_namespace, align 8
@rh_queue_status.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.rh_queue_status, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.53.115, i32 0, i32 0), i8 -12, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.53.115 = private unnamed_addr constant [27 x i8] c"not queuing rh status urb\0A\00", align 1
@__func__.rh_queue_status = private unnamed_addr constant [16 x i8] c"rh_queue_status\00", align 1
@hcd_urb_unlink_lock = internal global %struct.spinlock { %union.anon.4 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.60.117, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@usb_hcd_unlink_urb.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.usb_hcd_unlink_urb, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.6.116, i32 0, i32 0), i8 84, i8 6, i8 4, i8 0 }, section "__verbose", align 8
@.str.6.116 = private unnamed_addr constant [27 x i8] c"hcd_unlink_urb %p fail %d\0A\00", align 1
@__func__.usb_hcd_unlink_urb = private unnamed_addr constant [19 x i8] c"usb_hcd_unlink_urb\00", align 1
@.str.60.117 = private unnamed_addr constant [20 x i8] c"hcd_urb_unlink_lock\00", align 1
@usb_hcd_flush_endpoint.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.usb_hcd_flush_endpoint, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7.124, i32 0, i32 0), i8 -77, i8 6, i8 4, i8 0 }, section "__verbose", align 8
@.str.13.120 = private unnamed_addr constant [5 x i8] c"-iso\00", align 1
@.str.11.122 = private unnamed_addr constant [6 x i8] c"-bulk\00", align 1
@.str.12.123 = private unnamed_addr constant [6 x i8] c"-intr\00", align 1
@.str.7.124 = private unnamed_addr constant [26 x i8] c"shutdown urb %p ep%d%s%s\0A\00", align 1
@__func__.usb_hcd_flush_endpoint = private unnamed_addr constant [23 x i8] c"usb_hcd_flush_endpoint\00", align 1
@hcd_bus_suspend.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.hcd_bus_suspend, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.14.133, i32 0, i32 0), i8 -20, i8 7, i8 4, i8 0 }, section "__verbose", align 8
@.str.15.132 = private unnamed_addr constant [6 x i8] c"auto-\00", align 1
@.str.14.133 = private unnamed_addr constant [26 x i8] c"bus %ssuspend, wakeup %d\0A\00", align 1
@hcd_bus_suspend.descriptor.16 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.hcd_bus_suspend, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.17.134, i32 0, i32 0), i8 -18, i8 7, i8 4, i8 0 }, section "__verbose", align 8
@.str.17.134 = private unnamed_addr constant [24 x i8] c"skipped %s of dead bus\0A\00", align 1
@.str.18.135 = private unnamed_addr constant [8 x i8] c"suspend\00", align 1
@hcd_bus_suspend.descriptor.19 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.hcd_bus_suspend, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.20.136, i32 0, i32 0), i8 3, i8 8, i8 4, i8 0 }, section "__verbose", align 8
@.str.20.136 = private unnamed_addr constant [33 x i8] c"suspend raced with wakeup event\0A\00", align 1
@hcd_bus_suspend.descriptor.21 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.hcd_bus_suspend, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.22.137, i32 0, i32 0), i8 16, i8 8, i8 4, i8 0 }, section "__verbose", align 8
@.str.22.137 = private unnamed_addr constant [21 x i8] c"bus %s fail, err %d\0A\00", align 1
@__func__.hcd_bus_suspend = private unnamed_addr constant [16 x i8] c"hcd_bus_suspend\00", align 1
@hcd_bus_resume.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.hcd_bus_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.23.138, i32 0, i32 0), i8 28, i8 8, i8 4, i8 0 }, section "__verbose", align 8
@.str.23.138 = private unnamed_addr constant [14 x i8] c"usb %sresume\0A\00", align 1
@hcd_bus_resume.descriptor.24 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.hcd_bus_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.17.134, i32 0, i32 0), i8 30, i8 8, i8 4, i8 0 }, section "__verbose", align 8
@.str.25.139 = private unnamed_addr constant [7 x i8] c"resume\00", align 1
@hcd_bus_resume.descriptor.26 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.hcd_bus_resume, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.22.137, i32 0, i32 0), i8 71, i8 8, i8 4, i8 0 }, section "__verbose", align 8
@__func__.hcd_bus_resume = private unnamed_addr constant [15 x i8] c"hcd_bus_resume\00", align 1
@__kcrctab_usb_init_urb = internal constant i64 ptrtoint (i8** @__crc_usb_init_urb to i64), section "___kcrctab_gpl+usb_init_urb", align 8
@__ksymtab_usb_init_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.urb.824*)* @usb_init_urb to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_init_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_init_urb", align 8
@__kcrctab_usb_alloc_urb = internal constant i64 ptrtoint (i8** @__crc_usb_alloc_urb to i64), section "___kcrctab_gpl+usb_alloc_urb", align 8
@__ksymtab_usb_alloc_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.urb.824* (i32, i32)* @usb_alloc_urb to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_usb_alloc_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_alloc_urb", align 8
@__kcrctab_usb_free_urb = internal constant i64 ptrtoint (i8** @__crc_usb_free_urb to i64), section "___kcrctab_gpl+usb_free_urb", align 8
@__ksymtab_usb_free_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.urb.824*)* @usb_free_urb to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_free_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_free_urb", align 8
@__kcrctab_usb_get_urb = internal constant i64 ptrtoint (i8** @__crc_usb_get_urb to i64), section "___kcrctab_gpl+usb_get_urb", align 8
@__ksymtab_usb_get_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.urb.824* (%struct.urb.824*)* @usb_get_urb to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_get_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_get_urb", align 8
@__kcrctab_usb_anchor_urb = internal constant i64 ptrtoint (i8** @__crc_usb_anchor_urb to i64), section "___kcrctab_gpl+usb_anchor_urb", align 8
@__ksymtab_usb_anchor_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.urb.824*, %struct.usb_anchor*)* @usb_anchor_urb to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_anchor_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_anchor_urb", align 8
@__kcrctab_usb_unanchor_urb = internal constant i64 ptrtoint (i8** @__crc_usb_unanchor_urb to i64), section "___kcrctab_gpl+usb_unanchor_urb", align 8
@__ksymtab_usb_unanchor_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.urb.824*)* @usb_unanchor_urb to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_unanchor_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_unanchor_urb", align 8
@__kcrctab_usb_submit_urb = internal constant i64 ptrtoint (i8** @__crc_usb_submit_urb to i64), section "___kcrctab_gpl+usb_submit_urb", align 8
@__ksymtab_usb_submit_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.urb.824*, i32)* @usb_submit_urb to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_submit_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_submit_urb", align 8
@__kcrctab_usb_unlink_urb = internal constant i64 ptrtoint (i8** @__crc_usb_unlink_urb to i64), section "___kcrctab_gpl+usb_unlink_urb", align 8
@__ksymtab_usb_unlink_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.urb.824*)* @usb_unlink_urb to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_unlink_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_unlink_urb", align 8
@__kcrctab_usb_kill_urb = internal constant i64 ptrtoint (i8** @__crc_usb_kill_urb to i64), section "___kcrctab_gpl+usb_kill_urb", align 8
@__ksymtab_usb_kill_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.urb.824*)* @usb_kill_urb to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_kill_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_kill_urb", align 8
@__kcrctab_usb_poison_urb = internal constant i64 ptrtoint (i8** @__crc_usb_poison_urb to i64), section "___kcrctab_gpl+usb_poison_urb", align 8
@__ksymtab_usb_poison_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.urb.824*)* @usb_poison_urb to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_poison_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_poison_urb", align 8
@__kcrctab_usb_unpoison_urb = internal constant i64 ptrtoint (i8** @__crc_usb_unpoison_urb to i64), section "___kcrctab_gpl+usb_unpoison_urb", align 8
@__ksymtab_usb_unpoison_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.urb.824*)* @usb_unpoison_urb to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_unpoison_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_unpoison_urb", align 8
@__kcrctab_usb_block_urb = internal constant i64 ptrtoint (i8** @__crc_usb_block_urb to i64), section "___kcrctab_gpl+usb_block_urb", align 8
@__ksymtab_usb_block_urb = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.urb.824*)* @usb_block_urb to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_usb_block_urb, i32 0, i32 0) }, section "___ksymtab_gpl+usb_block_urb", align 8
@__kcrctab_usb_kill_anchored_urbs = internal constant i64 ptrtoint (i8** @__crc_usb_kill_anchored_urbs to i64), section "___kcrctab_gpl+usb_kill_anchored_urbs", align 8
@__ksymtab_usb_kill_anchored_urbs = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_anchor*)* @usb_kill_anchored_urbs to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_usb_kill_anchored_urbs, i32 0, i32 0) }, section "___ksymtab_gpl+usb_kill_anchored_urbs", align 8
@__kcrctab_usb_poison_anchored_urbs = internal constant i64 ptrtoint (i8** @__crc_usb_poison_anchored_urbs to i64), section "___kcrctab_gpl+usb_poison_anchored_urbs", align 8
@__ksymtab_usb_poison_anchored_urbs = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_anchor*)* @usb_poison_anchored_urbs to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_poison_anchored_urbs, i32 0, i32 0) }, section "___ksymtab_gpl+usb_poison_anchored_urbs", align 8
@__kcrctab_usb_unpoison_anchored_urbs = internal constant i64 ptrtoint (i8** @__crc_usb_unpoison_anchored_urbs to i64), section "___kcrctab_gpl+usb_unpoison_anchored_urbs", align 8
@__ksymtab_usb_unpoison_anchored_urbs = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_anchor*)* @usb_unpoison_anchored_urbs to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab_usb_unpoison_anchored_urbs, i32 0, i32 0) }, section "___ksymtab_gpl+usb_unpoison_anchored_urbs", align 8
@__kcrctab_usb_unlink_anchored_urbs = internal constant i64 ptrtoint (i8** @__crc_usb_unlink_anchored_urbs to i64), section "___kcrctab_gpl+usb_unlink_anchored_urbs", align 8
@__ksymtab_usb_unlink_anchored_urbs = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_anchor*)* @usb_unlink_anchored_urbs to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_unlink_anchored_urbs, i32 0, i32 0) }, section "___ksymtab_gpl+usb_unlink_anchored_urbs", align 8
@__kcrctab_usb_wait_anchor_empty_timeout = internal constant i64 ptrtoint (i8** @__crc_usb_wait_anchor_empty_timeout to i64), section "___kcrctab_gpl+usb_wait_anchor_empty_timeout", align 8
@__ksymtab_usb_wait_anchor_empty_timeout = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_anchor*, i32)* @usb_wait_anchor_empty_timeout to i64), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__kstrtab_usb_wait_anchor_empty_timeout, i32 0, i32 0) }, section "___ksymtab_gpl+usb_wait_anchor_empty_timeout", align 8
@__kcrctab_usb_get_from_anchor = internal constant i64 ptrtoint (i8** @__crc_usb_get_from_anchor to i64), section "___kcrctab_gpl+usb_get_from_anchor", align 8
@__ksymtab_usb_get_from_anchor = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.urb.824* (%struct.usb_anchor*)* @usb_get_from_anchor to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_usb_get_from_anchor, i32 0, i32 0) }, section "___ksymtab_gpl+usb_get_from_anchor", align 8
@__kcrctab_usb_scuttle_anchored_urbs = internal constant i64 ptrtoint (i8** @__crc_usb_scuttle_anchored_urbs to i64), section "___kcrctab_gpl+usb_scuttle_anchored_urbs", align 8
@__ksymtab_usb_scuttle_anchored_urbs = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_anchor*)* @usb_scuttle_anchored_urbs to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_usb_scuttle_anchored_urbs, i32 0, i32 0) }, section "___ksymtab_gpl+usb_scuttle_anchored_urbs", align 8
@__kcrctab_usb_anchor_empty = internal constant i64 ptrtoint (i8** @__crc_usb_anchor_empty to i64), section "___kcrctab_gpl+usb_anchor_empty", align 8
@__ksymtab_usb_anchor_empty = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_anchor*)* @usb_anchor_empty to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_anchor_empty, i32 0, i32 0) }, section "___ksymtab_gpl+usb_anchor_empty", align 8
@__kstrtab_usb_anchor_empty = internal constant [17 x i8] c"usb_anchor_empty\00", section "__ksymtab_strings", align 1
@__crc_usb_anchor_empty = extern_weak global i8*, align 8
@__kstrtab_usb_scuttle_anchored_urbs = internal constant [26 x i8] c"usb_scuttle_anchored_urbs\00", section "__ksymtab_strings", align 1
@__crc_usb_scuttle_anchored_urbs = extern_weak global i8*, align 8
@__kstrtab_usb_get_from_anchor = internal constant [20 x i8] c"usb_get_from_anchor\00", section "__ksymtab_strings", align 1
@kref_get.__warned.154 = internal global i8 0, section ".data.unlikely", align 1
@__crc_usb_get_from_anchor = extern_weak global i8*, align 8
@__kstrtab_usb_wait_anchor_empty_timeout = internal constant [30 x i8] c"usb_wait_anchor_empty_timeout\00", section "__ksymtab_strings", align 1
@__crc_usb_wait_anchor_empty_timeout = extern_weak global i8*, align 8
@__kstrtab_usb_unlink_anchored_urbs = internal constant [25 x i8] c"usb_unlink_anchored_urbs\00", section "__ksymtab_strings", align 1
@__crc_usb_unlink_anchored_urbs = extern_weak global i8*, align 8
@__kstrtab_usb_unpoison_anchored_urbs = internal constant [27 x i8] c"usb_unpoison_anchored_urbs\00", section "__ksymtab_strings", align 1
@__crc_usb_unpoison_anchored_urbs = extern_weak global i8*, align 8
@__kstrtab_usb_poison_anchored_urbs = internal constant [25 x i8] c"usb_poison_anchored_urbs\00", section "__ksymtab_strings", align 1
@.str.1.159 = private unnamed_addr constant [23 x i8] c"drivers/usb/core/urb.c\00", align 1
@__crc_usb_poison_anchored_urbs = extern_weak global i8*, align 8
@__kstrtab_usb_kill_anchored_urbs = internal constant [23 x i8] c"usb_kill_anchored_urbs\00", section "__ksymtab_strings", align 1
@__crc_usb_kill_anchored_urbs = extern_weak global i8*, align 8
@__kstrtab_usb_block_urb = internal constant [14 x i8] c"usb_block_urb\00", section "__ksymtab_strings", align 1
@__crc_usb_block_urb = extern_weak global i8*, align 8
@__kstrtab_usb_unpoison_urb = internal constant [17 x i8] c"usb_unpoison_urb\00", section "__ksymtab_strings", align 1
@__crc_usb_unpoison_urb = extern_weak global i8*, align 8
@__kstrtab_usb_poison_urb = internal constant [15 x i8] c"usb_poison_urb\00", section "__ksymtab_strings", align 1
@__crc_usb_poison_urb = extern_weak global i8*, align 8
@__kstrtab_usb_kill_urb = internal constant [13 x i8] c"usb_kill_urb\00", section "__ksymtab_strings", align 1
@__crc_usb_kill_urb = extern_weak global i8*, align 8
@__kstrtab_usb_unlink_urb = internal constant [15 x i8] c"usb_unlink_urb\00", section "__ksymtab_strings", align 1
@__crc_usb_unlink_urb = extern_weak global i8*, align 8
@__kstrtab_usb_submit_urb = internal constant [15 x i8] c"usb_submit_urb\00", section "__ksymtab_strings", align 1
@usb_submit_urb.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.2.166 = private unnamed_addr constant [31 x i8] c"URB %p submitted while active\0A\00", align 1
@usb_submit_urb.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.usb_submit_urb, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1.159, i32 0, i32 0), i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4.173, i32 0, i32 0), i8 123, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@.str.4.173 = private unnamed_addr constant [48 x i8] c"bogus endpoint ep%d%s in %s (bad maxpacket %d)\0A\00", align 1
@__func__.usb_submit_urb = private unnamed_addr constant [15 x i8] c"usb_submit_urb\00", align 1
@usb_submit_urb.pipetypes = internal global [4 x i32] [i32 2, i32 0, i32 3, i32 1], align 16
@.str.7.174 = private unnamed_addr constant [47 x i8] c"Device: %s\0ABOGUS urb xfer, pipe %x != type %x\0A\00", align 1
@.str.8.175 = private unnamed_addr constant [39 x i8] c"Device: %s\0ABOGUS urb flags, %x --> %x\0A\00", align 1
@__crc_usb_submit_urb = extern_weak global i8*, align 8
@__kstrtab_usb_unanchor_urb = internal constant [17 x i8] c"usb_unanchor_urb\00", section "__ksymtab_strings", align 1
@__crc_usb_unanchor_urb = extern_weak global i8*, align 8
@__kstrtab_usb_anchor_urb = internal constant [15 x i8] c"usb_anchor_urb\00", section "__ksymtab_strings", align 1
@__crc_usb_anchor_urb = extern_weak global i8*, align 8
@__kstrtab_usb_get_urb = internal constant [12 x i8] c"usb_get_urb\00", section "__ksymtab_strings", align 1
@__crc_usb_get_urb = extern_weak global i8*, align 8
@__kstrtab_usb_free_urb = internal constant [13 x i8] c"usb_free_urb\00", section "__ksymtab_strings", align 1
@__crc_usb_free_urb = extern_weak global i8*, align 8
@__kstrtab_usb_alloc_urb = internal constant [14 x i8] c"usb_alloc_urb\00", section "__ksymtab_strings", align 1
@.str.184 = private unnamed_addr constant [29 x i8] c"\013alloc_urb: kmalloc failed\0A\00", align 1
@__crc_usb_alloc_urb = extern_weak global i8*, align 8
@__kstrtab_usb_init_urb = internal constant [13 x i8] c"usb_init_urb\00", section "__ksymtab_strings", align 1
@__crc_usb_init_urb = extern_weak global i8*, align 8
@usb_if_device_type = global %struct.device_type { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.17.190, i32 0, i32 0), %struct.attribute_group** null, i32 (%struct.device*, %struct.kobj_uevent_env*)* @usb_if_uevent, i8* (%struct.device*, i16*, i32*, i32*)* null, void (%struct.device*)* @usb_release_interface, %struct.dev_pm_ops* null }, align 8
@.str.17.190 = private unnamed_addr constant [14 x i8] c"usb_interface\00", align 1
@.str.36.196 = private unnamed_addr constant [19 x i8] c"INTERFACE=%d/%d/%d\00", align 1
@.str.37.197 = private unnamed_addr constant [73 x i8] c"MODALIAS=usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02Xin%02X\00", align 1
@__kcrctab_usb_control_msg = internal constant i64 ptrtoint (i8** @__crc_usb_control_msg to i64), section "___kcrctab_gpl+usb_control_msg", align 8
@__ksymtab_usb_control_msg = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32, i8, i8, i16, i16, i8*, i16, i32)* @usb_control_msg to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_usb_control_msg, i32 0, i32 0) }, section "___ksymtab_gpl+usb_control_msg", align 8
@__kcrctab_usb_interrupt_msg = internal constant i64 ptrtoint (i8** @__crc_usb_interrupt_msg to i64), section "___kcrctab_gpl+usb_interrupt_msg", align 8
@__ksymtab_usb_interrupt_msg = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32, i8*, i32, i32*, i32)* @usb_interrupt_msg to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_usb_interrupt_msg, i32 0, i32 0) }, section "___ksymtab_gpl+usb_interrupt_msg", align 8
@__kcrctab_usb_bulk_msg = internal constant i64 ptrtoint (i8** @__crc_usb_bulk_msg to i64), section "___kcrctab_gpl+usb_bulk_msg", align 8
@__ksymtab_usb_bulk_msg = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32, i8*, i32, i32*, i32)* @usb_bulk_msg to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_bulk_msg, i32 0, i32 0) }, section "___ksymtab_gpl+usb_bulk_msg", align 8
@__kcrctab_usb_sg_init = internal constant i64 ptrtoint (i8** @__crc_usb_sg_init to i64), section "___kcrctab_gpl+usb_sg_init", align 8
@__ksymtab_usb_sg_init = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_sg_request*, %struct.usb_device*, i32, i32, %struct.scatterlist*, i32, i64, i32)* @usb_sg_init to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_sg_init, i32 0, i32 0) }, section "___ksymtab_gpl+usb_sg_init", align 8
@__kcrctab_usb_sg_wait = internal constant i64 ptrtoint (i8** @__crc_usb_sg_wait to i64), section "___kcrctab_gpl+usb_sg_wait", align 8
@__ksymtab_usb_sg_wait = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_sg_request*)* @usb_sg_wait to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_usb_sg_wait, i32 0, i32 0) }, section "___ksymtab_gpl+usb_sg_wait", align 8
@__kcrctab_usb_sg_cancel = internal constant i64 ptrtoint (i8** @__crc_usb_sg_cancel to i64), section "___kcrctab_gpl+usb_sg_cancel", align 8
@__ksymtab_usb_sg_cancel = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_sg_request*)* @usb_sg_cancel to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_usb_sg_cancel, i32 0, i32 0) }, section "___ksymtab_gpl+usb_sg_cancel", align 8
@__kcrctab_usb_get_descriptor = internal constant i64 ptrtoint (i8** @__crc_usb_get_descriptor to i64), section "___kcrctab_gpl+usb_get_descriptor", align 8
@__ksymtab_usb_get_descriptor = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i8, i8, i8*, i32)* @usb_get_descriptor to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_get_descriptor, i32 0, i32 0) }, section "___ksymtab_gpl+usb_get_descriptor", align 8
@__kcrctab_usb_string = internal constant i64 ptrtoint (i8** @__crc_usb_string to i64), section "___kcrctab_gpl+usb_string", align 8
@__ksymtab_usb_string = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32, i8*, i64)* @usb_string to i64), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__kstrtab_usb_string, i32 0, i32 0) }, section "___ksymtab_gpl+usb_string", align 8
@__kcrctab_usb_get_status = internal constant i64 ptrtoint (i8** @__crc_usb_get_status to i64), section "___kcrctab_gpl+usb_get_status", align 8
@__ksymtab_usb_get_status = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32, i32, i8*)* @usb_get_status to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_get_status, i32 0, i32 0) }, section "___ksymtab_gpl+usb_get_status", align 8
@__kcrctab_usb_clear_halt = internal constant i64 ptrtoint (i8** @__crc_usb_clear_halt to i64), section "___kcrctab_gpl+usb_clear_halt", align 8
@__ksymtab_usb_clear_halt = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32)* @usb_clear_halt to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_clear_halt, i32 0, i32 0) }, section "___ksymtab_gpl+usb_clear_halt", align 8
@__kcrctab_usb_reset_endpoint = internal constant i64 ptrtoint (i8** @__crc_usb_reset_endpoint to i64), section "___kcrctab_gpl+usb_reset_endpoint", align 8
@__ksymtab_usb_reset_endpoint = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*, i32)* @usb_reset_endpoint to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_reset_endpoint, i32 0, i32 0) }, section "___ksymtab_gpl+usb_reset_endpoint", align 8
@__kcrctab_usb_set_interface = internal constant i64 ptrtoint (i8** @__crc_usb_set_interface to i64), section "___kcrctab_gpl+usb_set_interface", align 8
@__ksymtab_usb_set_interface = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32, i32)* @usb_set_interface to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_usb_set_interface, i32 0, i32 0) }, section "___ksymtab_gpl+usb_set_interface", align 8
@__kcrctab_usb_reset_configuration = internal constant i64 ptrtoint (i8** @__crc_usb_reset_configuration to i64), section "___kcrctab_gpl+usb_reset_configuration", align 8
@__ksymtab_usb_reset_configuration = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*)* @usb_reset_configuration to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_reset_configuration, i32 0, i32 0) }, section "___ksymtab_gpl+usb_reset_configuration", align 8
@__kcrctab_usb_driver_set_configuration = internal constant i64 ptrtoint (i8** @__crc_usb_driver_set_configuration to i64), section "___kcrctab_gpl+usb_driver_set_configuration", align 8
@__ksymtab_usb_driver_set_configuration = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32)* @usb_driver_set_configuration to i64), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__kstrtab_usb_driver_set_configuration, i32 0, i32 0) }, section "___ksymtab_gpl+usb_driver_set_configuration", align 8
@__kstrtab_usb_driver_set_configuration = internal constant [29 x i8] c"usb_driver_set_configuration\00", section "__ksymtab_strings", align 1
@.str.25.200 = private unnamed_addr constant [13 x i8] c"(&req->work)\00", align 1
@usb_driver_set_configuration.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@set_config_lock = internal global %struct.spinlock { %union.anon.4 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.40.207, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@set_config_list = internal global %struct.list_head { %struct.list_head* @set_config_list, %struct.list_head* @set_config_list }, align 8
@.str.40.207 = private unnamed_addr constant [16 x i8] c"set_config_lock\00", align 1
@.str.18.213 = private unnamed_addr constant [23 x i8] c"config 0 descriptor??\0A\00", align 1
@.str.19 = private unnamed_addr constant [15 x i8] c"Out of memory\0A\00", align 1
@.str.20.216 = private unnamed_addr constant [44 x i8] c"new config #%d exceeds power limit by %dmA\0A\00", align 1
@.str.13.219 = private unnamed_addr constant [27 x i8] c"%s Failed to disable LPM\0A.\00", align 1
@__func__.usb_set_configuration = private unnamed_addr constant [22 x i8] c"usb_set_configuration\00", align 1
@.str.21 = private unnamed_addr constant [18 x i8] c"(&intf->reset_ws)\00", align 1
@usb_set_configuration.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.22.223 = private unnamed_addr constant [12 x i8] c"%d-%s:%d.%d\00", align 1
@usb_set_configuration.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.usb_set_configuration, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.237, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.23.232, i32 0, i32 0), i8 104, i8 7, i8 4, i8 0 }, section "__verbose", align 8
@.str.23.232 = private unnamed_addr constant [38 x i8] c"adding %s (config #%d, interface %d)\0A\00", align 1
@.str.24.234 = private unnamed_addr constant [23 x i8] c"device_add(%s) --> %d\0A\00", align 1
@.str.2.237 = private unnamed_addr constant [27 x i8] c"drivers/usb/core/message.c\00", align 1
@usb_string.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.usb_string, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.237, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.5.240, i32 0, i32 0), i8 72, i8 3, i8 4, i8 0 }, section "__verbose", align 8
@.str.5.240 = private unnamed_addr constant [49 x i8] c"wrong descriptor type %02x for string %d (\22%s\22)\0A\00", align 1
@__func__.usb_string = private unnamed_addr constant [11 x i8] c"usb_string\00", align 1
@_ctype = external constant [0 x i8], align 1
@.str.33.241 = private unnamed_addr constant [64 x i8] c"string descriptor 0 malformed (err = %d), defaulting to 0x%04x\0A\00", align 1
@.str.34.242 = private unnamed_addr constant [36 x i8] c"string descriptor 0 read error: %d\0A\00", align 1
@usb_get_langid.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.usb_get_langid, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.237, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.35.243, i32 0, i32 0), i8 21, i8 3, i8 4, i8 0 }, section "__verbose", align 8
@.str.35.243 = private unnamed_addr constant [25 x i8] c"default language 0x%04x\0A\00", align 1
@__func__.usb_get_langid = private unnamed_addr constant [15 x i8] c"usb_get_langid\00", align 1
@usb_start_wait_urb.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.usb_start_wait_urb, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.237, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.27.251, i32 0, i32 0), i8 68, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.27.251 = private unnamed_addr constant [34 x i8] c"%s timed out on ep%d%s len=%u/%u\0A\00", align 1
@__func__.usb_start_wait_urb = private unnamed_addr constant [19 x i8] c"usb_start_wait_urb\00", align 1
@.str.32.252 = private unnamed_addr constant [9 x i8] c"&x->wait\00", align 1
@init_completion.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.39.257 = private unnamed_addr constant [43 x i8] c"Interface #%d referenced by multiple IADs\0A\00", align 1
@kref_get.__warned.259 = internal global i8 0, section ".data.unlikely", align 1
@usb_disable_device.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.usb_disable_device, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.237, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.6.260, i32 0, i32 0), i8 -117, i8 4, i8 4, i8 0 }, section "__verbose", align 8
@.str.6.260 = private unnamed_addr constant [28 x i8] c"unregistering interface %s\0A\00", align 1
@usb_disable_device.descriptor.7 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.usb_disable_device, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.237, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.8.263, i32 0, i32 0), i8 -97, i8 4, i8 4, i8 0 }, section "__verbose", align 8
@.str.9.261 = private unnamed_addr constant [8 x i8] c"non-ep0\00", align 1
@.str.8.263 = private unnamed_addr constant [19 x i8] c"%s nuking %s URBs\0A\00", align 1
@__func__.usb_disable_device = private unnamed_addr constant [19 x i8] c"usb_disable_device\00", align 1
@__crc_usb_driver_set_configuration = extern_weak global i8*, align 8
@__kstrtab_usb_reset_configuration = internal constant [24 x i8] c"usb_reset_configuration\00", section "__ksymtab_strings", align 1
@__func__.usb_reset_configuration = private unnamed_addr constant [24 x i8] c"usb_reset_configuration\00", align 1
@__crc_usb_reset_configuration = extern_weak global i8*, align 8
@__kstrtab_usb_set_interface = internal constant [18 x i8] c"usb_set_interface\00", section "__ksymtab_strings", align 1
@usb_set_interface.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.usb_set_interface, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.237, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.11.266, i32 0, i32 0), i8 14, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.11.266 = private unnamed_addr constant [32 x i8] c"selecting invalid interface %d\0A\00", align 1
@.str.12.267 = private unnamed_addr constant [33 x i8] c"selecting invalid altsetting %d\0A\00", align 1
@__func__.usb_set_interface = private unnamed_addr constant [18 x i8] c"usb_set_interface\00", align 1
@.str.14.268 = private unnamed_addr constant [40 x i8] c"Not enough bandwidth for altsetting %d\0A\00", align 1
@usb_set_interface.descriptor.15 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.usb_set_interface, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.237, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.16.269, i32 0, i32 0), i8 61, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@.str.16.269 = private unnamed_addr constant [43 x i8] c"manual set_interface for iface %d, alt %d\0A\00", align 1
@__crc_usb_set_interface = extern_weak global i8*, align 8
@__kstrtab_usb_reset_endpoint = internal constant [19 x i8] c"usb_reset_endpoint\00", section "__ksymtab_strings", align 1
@__crc_usb_reset_endpoint = extern_weak global i8*, align 8
@__kstrtab_usb_clear_halt = internal constant [15 x i8] c"usb_clear_halt\00", section "__ksymtab_strings", align 1
@__crc_usb_clear_halt = extern_weak global i8*, align 8
@__kstrtab_usb_get_status = internal constant [15 x i8] c"usb_get_status\00", section "__ksymtab_strings", align 1
@__crc_usb_get_status = extern_weak global i8*, align 8
@__kstrtab_usb_string = internal constant [11 x i8] c"usb_string\00", section "__ksymtab_strings", align 1
@__crc_usb_string = extern_weak global i8*, align 8
@__kstrtab_usb_get_descriptor = internal constant [19 x i8] c"usb_get_descriptor\00", section "__ksymtab_strings", align 1
@__crc_usb_get_descriptor = extern_weak global i8*, align 8
@__kstrtab_usb_sg_cancel = internal constant [14 x i8] c"usb_sg_cancel\00", section "__ksymtab_strings", align 1
@.str.4.275 = private unnamed_addr constant [19 x i8] c"%s, unlink --> %d\0A\00", align 1
@__func__.usb_sg_cancel = private unnamed_addr constant [14 x i8] c"usb_sg_cancel\00", align 1
@__crc_usb_sg_cancel = extern_weak global i8*, align 8
@__kstrtab_usb_sg_wait = internal constant [12 x i8] c"usb_sg_wait\00", section "__ksymtab_strings", align 1
@usb_sg_wait.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.usb_sg_wait, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.237, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.279, i32 0, i32 0), i8 32, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.3.279 = private unnamed_addr constant [19 x i8] c"%s, submit --> %d\0A\00", align 1
@__func__.usb_sg_wait = private unnamed_addr constant [12 x i8] c"usb_sg_wait\00", align 1
@__crc_usb_sg_wait = extern_weak global i8*, align 8
@__kstrtab_usb_sg_init = internal constant [12 x i8] c"usb_sg_init\00", section "__ksymtab_strings", align 1
@.str.280 = private unnamed_addr constant [20 x i8] c"&(&io->lock)->rlock\00", align 1
@usb_sg_init.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.30.285 = private unnamed_addr constant [39 x i8] c"dev %s ep%d%s scatterlist error %d/%d\0A\00", align 1
@__func__.sg_complete = private unnamed_addr constant [12 x i8] c"sg_complete\00", align 1
@__crc_usb_sg_init = extern_weak global i8*, align 8
@__kstrtab_usb_bulk_msg = internal constant [13 x i8] c"usb_bulk_msg\00", section "__ksymtab_strings", align 1
@__crc_usb_bulk_msg = extern_weak global i8*, align 8
@__kstrtab_usb_interrupt_msg = internal constant [18 x i8] c"usb_interrupt_msg\00", section "__ksymtab_strings", align 1
@__crc_usb_interrupt_msg = extern_weak global i8*, align 8
@__kstrtab_usb_control_msg = internal constant [16 x i8] c"usb_control_msg\00", section "__ksymtab_strings", align 1
@__crc_usb_control_msg = extern_weak global i8*, align 8
@usb_bus_type = global %struct.bus_type { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.774, i32 0, i32 0), i8* null, %struct.device* null, %struct.bus_attribute* null, %struct.device_attribute* null, %struct.driver_attribute* null, i32 (%struct.device*, %struct.device_driver*)* @usb_device_match, i32 (%struct.device*, %struct.kobj_uevent_env*)* @usb_uevent, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.dev_pm_ops* null, %struct.iommu_ops* null, %struct.subsys_private* null, %struct.lock_class_key zeroinitializer }, align 8
@usb_uevent.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.usb_uevent, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12.301, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.30.296, i32 0, i32 0), i8 25, i8 3, i8 4, i8 0 }, section "__verbose", align 8
@.str.30.296 = private unnamed_addr constant [26 x i8] c"usb %s: already deleted?\0A\00", align 1
@usb_uevent.descriptor.31 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.usb_uevent, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12.301, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.32.297, i32 0, i32 0), i8 29, i8 3, i8 4, i8 0 }, section "__verbose", align 8
@.str.32.297 = private unnamed_addr constant [22 x i8] c"usb %s: bus removed?\0A\00", align 1
@.str.33.298 = private unnamed_addr constant [17 x i8] c"PRODUCT=%x/%x/%x\00", align 1
@.str.34.299 = private unnamed_addr constant [14 x i8] c"TYPE=%d/%d/%d\00", align 1
@__func__.usb_uevent = private unnamed_addr constant [11 x i8] c"usb_uevent\00", align 1
@.str.12.301 = private unnamed_addr constant [26 x i8] c"drivers/usb/core/driver.c\00", align 1
@__kcrctab_usb_store_new_id = internal constant i64 ptrtoint (i8** @__crc_usb_store_new_id to i64), section "___kcrctab_gpl+usb_store_new_id", align 8
@__ksymtab_usb_store_new_id = internal constant %struct.kernel_symbol { i64 ptrtoint (i64 (%struct.__wait_queue_head*, %struct.device_driver*, i8*, i64)* @usb_store_new_id to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_store_new_id, i32 0, i32 0) }, section "___ksymtab_gpl+usb_store_new_id", align 8
@__kcrctab_usb_show_dynids = internal constant i64 ptrtoint (i8** @__crc_usb_show_dynids to i64), section "___kcrctab_gpl+usb_show_dynids", align 8
@__ksymtab_usb_show_dynids = internal constant %struct.kernel_symbol { i64 ptrtoint (i64 (%struct.__wait_queue_head*, i8*)* @usb_show_dynids to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_usb_show_dynids, i32 0, i32 0) }, section "___ksymtab_gpl+usb_show_dynids", align 8
@__kcrctab_usb_driver_claim_interface = internal constant i64 ptrtoint (i8** @__crc_usb_driver_claim_interface to i64), section "___kcrctab_gpl+usb_driver_claim_interface", align 8
@__ksymtab_usb_driver_claim_interface = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_driver*, %struct.usb_interface*, i8*)* @usb_driver_claim_interface to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab_usb_driver_claim_interface, i32 0, i32 0) }, section "___ksymtab_gpl+usb_driver_claim_interface", align 8
@__kcrctab_usb_driver_release_interface = internal constant i64 ptrtoint (i8** @__crc_usb_driver_release_interface to i64), section "___kcrctab_gpl+usb_driver_release_interface", align 8
@__ksymtab_usb_driver_release_interface = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_driver*, %struct.usb_interface*)* @usb_driver_release_interface to i64), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__kstrtab_usb_driver_release_interface, i32 0, i32 0) }, section "___ksymtab_gpl+usb_driver_release_interface", align 8
@__kcrctab_usb_match_one_id = internal constant i64 ptrtoint (i8** @__crc_usb_match_one_id to i64), section "___kcrctab_gpl+usb_match_one_id", align 8
@__ksymtab_usb_match_one_id = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_interface*, %struct.usb_device_id*)* @usb_match_one_id to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_match_one_id, i32 0, i32 0) }, section "___ksymtab_gpl+usb_match_one_id", align 8
@__kcrctab_usb_match_id = internal constant i64 ptrtoint (i8** @__crc_usb_match_id to i64), section "___kcrctab_gpl+usb_match_id", align 8
@__ksymtab_usb_match_id = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.usb_device_id* (%struct.usb_interface*, %struct.usb_device_id*)* @usb_match_id to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_usb_match_id, i32 0, i32 0) }, section "___ksymtab_gpl+usb_match_id", align 8
@__kcrctab_usb_register_device_driver = internal constant i64 ptrtoint (i8** @__crc_usb_register_device_driver to i64), section "___kcrctab_gpl+usb_register_device_driver", align 8
@__ksymtab_usb_register_device_driver = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device_driver*, %struct.module*)* @usb_register_device_driver to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab_usb_register_device_driver, i32 0, i32 0) }, section "___ksymtab_gpl+usb_register_device_driver", align 8
@__kcrctab_usb_deregister_device_driver = internal constant i64 ptrtoint (i8** @__crc_usb_deregister_device_driver to i64), section "___kcrctab_gpl+usb_deregister_device_driver", align 8
@__ksymtab_usb_deregister_device_driver = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device_driver*)* @usb_deregister_device_driver to i64), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__kstrtab_usb_deregister_device_driver, i32 0, i32 0) }, section "___ksymtab_gpl+usb_deregister_device_driver", align 8
@__kcrctab_usb_register_driver = internal constant i64 ptrtoint (i8** @__crc_usb_register_driver to i64), section "___kcrctab_gpl+usb_register_driver", align 8
@__ksymtab_usb_register_driver = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_driver*, %struct.module*, i8*)* @usb_register_driver to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_usb_register_driver, i32 0, i32 0) }, section "___ksymtab_gpl+usb_register_driver", align 8
@__kcrctab_usb_deregister = internal constant i64 ptrtoint (i8** @__crc_usb_deregister to i64), section "___kcrctab_gpl+usb_deregister", align 8
@__ksymtab_usb_deregister = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_driver*)* @usb_deregister to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_usb_deregister, i32 0, i32 0) }, section "___ksymtab_gpl+usb_deregister", align 8
@__kcrctab_usb_enable_autosuspend = internal constant i64 ptrtoint (i8** @__crc_usb_enable_autosuspend to i64), section "___kcrctab_gpl+usb_enable_autosuspend", align 8
@__ksymtab_usb_enable_autosuspend = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*)* @usb_enable_autosuspend to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_usb_enable_autosuspend, i32 0, i32 0) }, section "___ksymtab_gpl+usb_enable_autosuspend", align 8
@__kcrctab_usb_disable_autosuspend = internal constant i64 ptrtoint (i8** @__crc_usb_disable_autosuspend to i64), section "___kcrctab_gpl+usb_disable_autosuspend", align 8
@__ksymtab_usb_disable_autosuspend = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_device*)* @usb_disable_autosuspend to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_usb_disable_autosuspend, i32 0, i32 0) }, section "___ksymtab_gpl+usb_disable_autosuspend", align 8
@__kcrctab_usb_autopm_put_interface = internal constant i64 ptrtoint (i8** @__crc_usb_autopm_put_interface to i64), section "___kcrctab_gpl+usb_autopm_put_interface", align 8
@__ksymtab_usb_autopm_put_interface = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_interface*)* @usb_autopm_put_interface to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_autopm_put_interface, i32 0, i32 0) }, section "___ksymtab_gpl+usb_autopm_put_interface", align 8
@__kcrctab_usb_autopm_put_interface_async = internal constant i64 ptrtoint (i8** @__crc_usb_autopm_put_interface_async to i64), section "___kcrctab_gpl+usb_autopm_put_interface_async", align 8
@__ksymtab_usb_autopm_put_interface_async = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_interface*)* @usb_autopm_put_interface_async to i64), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__kstrtab_usb_autopm_put_interface_async, i32 0, i32 0) }, section "___ksymtab_gpl+usb_autopm_put_interface_async", align 8
@__kcrctab_usb_autopm_put_interface_no_suspend = internal constant i64 ptrtoint (i8** @__crc_usb_autopm_put_interface_no_suspend to i64), section "___kcrctab_gpl+usb_autopm_put_interface_no_suspend", align 8
@__ksymtab_usb_autopm_put_interface_no_suspend = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_interface*)* @usb_autopm_put_interface_no_suspend to i64), i8* getelementptr inbounds ([36 x i8], [36 x i8]* @__kstrtab_usb_autopm_put_interface_no_suspend, i32 0, i32 0) }, section "___ksymtab_gpl+usb_autopm_put_interface_no_suspend", align 8
@__kcrctab_usb_autopm_get_interface = internal constant i64 ptrtoint (i8** @__crc_usb_autopm_get_interface to i64), section "___kcrctab_gpl+usb_autopm_get_interface", align 8
@__ksymtab_usb_autopm_get_interface = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_interface*)* @usb_autopm_get_interface to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_autopm_get_interface, i32 0, i32 0) }, section "___ksymtab_gpl+usb_autopm_get_interface", align 8
@__kcrctab_usb_autopm_get_interface_async = internal constant i64 ptrtoint (i8** @__crc_usb_autopm_get_interface_async to i64), section "___kcrctab_gpl+usb_autopm_get_interface_async", align 8
@__ksymtab_usb_autopm_get_interface_async = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_interface*)* @usb_autopm_get_interface_async to i64), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__kstrtab_usb_autopm_get_interface_async, i32 0, i32 0) }, section "___ksymtab_gpl+usb_autopm_get_interface_async", align 8
@__kcrctab_usb_autopm_get_interface_no_resume = internal constant i64 ptrtoint (i8** @__crc_usb_autopm_get_interface_no_resume to i64), section "___kcrctab_gpl+usb_autopm_get_interface_no_resume", align 8
@__ksymtab_usb_autopm_get_interface_no_resume = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_interface*)* @usb_autopm_get_interface_no_resume to i64), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @__kstrtab_usb_autopm_get_interface_no_resume, i32 0, i32 0) }, section "___ksymtab_gpl+usb_autopm_get_interface_no_resume", align 8
@__kstrtab_usb_autopm_get_interface_no_resume = internal constant [35 x i8] c"usb_autopm_get_interface_no_resume\00", section "__ksymtab_strings", align 1
@__crc_usb_autopm_get_interface_no_resume = extern_weak global i8*, align 8
@__kstrtab_usb_autopm_get_interface_async = internal constant [31 x i8] c"usb_autopm_get_interface_async\00", section "__ksymtab_strings", align 1
@__crc_usb_autopm_get_interface_async = extern_weak global i8*, align 8
@__kstrtab_usb_autopm_get_interface = internal constant [25 x i8] c"usb_autopm_get_interface\00", section "__ksymtab_strings", align 1
@__crc_usb_autopm_get_interface = extern_weak global i8*, align 8
@__kstrtab_usb_autopm_put_interface_no_suspend = internal constant [36 x i8] c"usb_autopm_put_interface_no_suspend\00", section "__ksymtab_strings", align 1
@__crc_usb_autopm_put_interface_no_suspend = extern_weak global i8*, align 8
@__kstrtab_usb_autopm_put_interface_async = internal constant [31 x i8] c"usb_autopm_put_interface_async\00", section "__ksymtab_strings", align 1
@__crc_usb_autopm_put_interface_async = extern_weak global i8*, align 8
@__kstrtab_usb_autopm_put_interface = internal constant [25 x i8] c"usb_autopm_put_interface\00", section "__ksymtab_strings", align 1
@__crc_usb_autopm_put_interface = extern_weak global i8*, align 8
@__kstrtab_usb_disable_autosuspend = internal constant [24 x i8] c"usb_disable_autosuspend\00", section "__ksymtab_strings", align 1
@__crc_usb_disable_autosuspend = extern_weak global i8*, align 8
@__kstrtab_usb_enable_autosuspend = internal constant [23 x i8] c"usb_enable_autosuspend\00", section "__ksymtab_strings", align 1
@__crc_usb_enable_autosuspend = extern_weak global i8*, align 8
@__kstrtab_usb_deregister = internal constant [15 x i8] c"usb_deregister\00", section "__ksymtab_strings", align 1
@.str.10.335 = private unnamed_addr constant [41 x i8] c"\016%s: deregistering interface driver %s\0A\00", align 1
@driver_attr_remove_id = internal global %struct.driver_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.22.344, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device_driver*, i8*)* @show_dynids, i64 (%struct.device_driver*, i8*, i64)* @store_remove_id }, align 8
@driver_attr_new_id = internal global %struct.driver_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.21.336, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device_driver*, i8*)* @show_dynids, i64 (%struct.device_driver*, i8*, i64)* @store_new_id }, align 8
@.str.21.336 = private unnamed_addr constant [7 x i8] c"new_id\00", align 1
@.str.337 = private unnamed_addr constant [9 x i8] c"%x %x %x\00", align 1
@.str.1.342 = private unnamed_addr constant [16 x i8] c"%04x %04x %02x\0A\00", align 1
@.str.2.343 = private unnamed_addr constant [11 x i8] c"%04x %04x\0A\00", align 1
@.str.22.344 = private unnamed_addr constant [10 x i8] c"remove_id\00", align 1
@.str.23.345 = private unnamed_addr constant [6 x i8] c"%x %x\00", align 1
@__crc_usb_deregister = extern_weak global i8*, align 8
@__kstrtab_usb_register_driver = internal constant [20 x i8] c"usb_register_driver\00", section "__ksymtab_strings", align 1
@.str.7.349 = private unnamed_addr constant [35 x i8] c"&(&new_driver->dynids.lock)->rlock\00", align 1
@usb_register_driver.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.8.350 = private unnamed_addr constant [42 x i8] c"\016%s: registered new interface driver %s\0A\00", align 1
@.str.9.351 = private unnamed_addr constant [49 x i8] c"\013%s: error %d registering interface \09driver %s\0A\00", align 1
@usb_probe_interface.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.usb_probe_interface, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12.301, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11.859, i32 0, i32 0), i8 16, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@__func__.usb_probe_interface = private unnamed_addr constant [20 x i8] c"usb_probe_interface\00", align 1
@usb_probe_interface.descriptor.19 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.usb_probe_interface, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12.301, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.20.363, i32 0, i32 0), i8 34, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@.str.20.363 = private unnamed_addr constant [13 x i8] c"%s - got id\0A\00", align 1
@.str.3.366 = private unnamed_addr constant [41 x i8] c"%s Failed to disable LPM for driver %s\0A.\00", align 1
@__crc_usb_register_driver = extern_weak global i8*, align 8
@__kstrtab_usb_deregister_device_driver = internal constant [29 x i8] c"usb_deregister_device_driver\00", section "__ksymtab_strings", align 1
@.str.6.369 = private unnamed_addr constant [38 x i8] c"\016%s: deregistering device driver %s\0A\00", align 1
@__crc_usb_deregister_device_driver = extern_weak global i8*, align 8
@__kstrtab_usb_register_device_driver = internal constant [27 x i8] c"usb_register_device_driver\00", section "__ksymtab_strings", align 1
@.str.4.372 = private unnamed_addr constant [39 x i8] c"\016%s: registered new device driver %s\0A\00", align 1
@.str.5.373 = private unnamed_addr constant [46 x i8] c"\013%s: error %d registering device \09driver %s\0A\00", align 1
@usb_probe_device.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.usb_probe_device, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12.301, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11.859, i32 0, i32 0), i8 -36, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@__func__.usb_probe_device = private unnamed_addr constant [17 x i8] c"usb_probe_device\00", align 1
@__crc_usb_register_device_driver = extern_weak global i8*, align 8
@__kstrtab_usb_match_id = internal constant [13 x i8] c"usb_match_id\00", section "__ksymtab_strings", align 1
@__crc_usb_match_id = extern_weak global i8*, align 8
@__kstrtab_usb_match_one_id = internal constant [17 x i8] c"usb_match_one_id\00", section "__ksymtab_strings", align 1
@__crc_usb_match_one_id = extern_weak global i8*, align 8
@__kstrtab_usb_driver_release_interface = internal constant [29 x i8] c"usb_driver_release_interface\00", section "__ksymtab_strings", align 1
@__crc_usb_driver_release_interface = extern_weak global i8*, align 8
@__kstrtab_usb_driver_claim_interface = internal constant [27 x i8] c"usb_driver_claim_interface\00", section "__ksymtab_strings", align 1
@__func__.usb_driver_claim_interface = private unnamed_addr constant [27 x i8] c"usb_driver_claim_interface\00", align 1
@__crc_usb_driver_claim_interface = extern_weak global i8*, align 8
@__kstrtab_usb_show_dynids = internal constant [16 x i8] c"usb_show_dynids\00", section "__ksymtab_strings", align 1
@__crc_usb_show_dynids = extern_weak global i8*, align 8
@__kstrtab_usb_store_new_id = internal constant [17 x i8] c"usb_store_new_id\00", section "__ksymtab_strings", align 1
@__crc_usb_store_new_id = extern_weak global i8*, align 8
@usb_forced_unbind_intf.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.usb_forced_unbind_intf, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12.301, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.13.379, i32 0, i32 0), i8 -61, i8 3, i8 4, i8 0 }, section "__verbose", align 8
@.str.13.379 = private unnamed_addr constant [15 x i8] c"forced unbind\0A\00", align 1
@__func__.usb_forced_unbind_intf = private unnamed_addr constant [23 x i8] c"usb_forced_unbind_intf\00", align 1
@.str.14.382 = private unnamed_addr constant [19 x i8] c"rebind failed: %d\0A\00", align 1
@.str.25.385 = private unnamed_addr constant [13 x i8] c"%s error %d\0A\00", align 1
@.str.26 = private unnamed_addr constant [13 x i8] c"reset_resume\00", align 1
@.str.27.386 = private unnamed_addr constant [22 x i8] c"no %s for driver %s?\0A\00", align 1
@.str.28.387 = private unnamed_addr constant [17 x i8] c"resume error %d\0A\00", align 1
@.str.24.388 = private unnamed_addr constant [18 x i8] c"suspend error %d\0A\00", align 1
@autosuspend_check.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.autosuspend_check, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12.301, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.29.397, i32 0, i32 0), i8 -78, i8 6, i8 4, i8 0 }, section "__verbose", align 8
@.str.29.397 = private unnamed_addr constant [38 x i8] c"remote wakeup needed for autosuspend\0A\00", align 1
@__func__.autosuspend_check = private unnamed_addr constant [18 x i8] c"autosuspend_check\00", align 1
@.str.415 = private unnamed_addr constant [56 x i8] c"too many configurations: %d, using maximum allowed: %d\0A\00", align 1
@.str.1.416 = private unnamed_addr constant [19 x i8] c"no configurations\0A\00", align 1
@.str.2.419 = private unnamed_addr constant [50 x i8] c"unable to read config index %d descriptor/%s: %d\0A\00", align 1
@.str.3.420 = private unnamed_addr constant [6 x i8] c"start\00", align 1
@.str.4.421 = private unnamed_addr constant [26 x i8] c"chopping to %d config(s)\0A\00", align 1
@.str.5.422 = private unnamed_addr constant [60 x i8] c"config index %d descriptor too short (expected %i, got %i)\0A\00", align 1
@.str.6.423 = private unnamed_addr constant [46 x i8] c"unable to read config index %d descriptor/%s\0A\00", align 1
@.str.7.424 = private unnamed_addr constant [4 x i8] c"all\00", align 1
@.str.8.425 = private unnamed_addr constant [15 x i8] c"out of memory\0A\00", align 1
@.str.14.426 = private unnamed_addr constant [66 x i8] c"invalid descriptor for config index %d: type = 0x%X, length = %d\0A\00", align 1
@.str.15.427 = private unnamed_addr constant [66 x i8] c"config %d has too many interfaces: %d, using maximum allowed: %d\0A\00", align 1
@.str.16.428 = private unnamed_addr constant [53 x i8] c"config %d descriptor has %d excess byte%s, ignoring\0A\00", align 1
@.str.17.429 = private unnamed_addr constant [84 x i8] c"config %d has an invalid descriptor of length %d, skipping remainder of the config\0A\00", align 1
@.str.18.430 = private unnamed_addr constant [70 x i8] c"config %d has an invalid interface descriptor of length %d, skipping\0A\00", align 1
@.str.19.431 = private unnamed_addr constant [109 x i8] c"config %d has more interface descriptors, than it declares in bNumInterfaces, ignoring interface number: %d\0A\00", align 1
@.str.20.432 = private unnamed_addr constant [61 x i8] c"config %d has an invalid interface number: %d but max is %d\0A\00", align 1
@.str.21.433 = private unnamed_addr constant [85 x i8] c"found more Interface Association Descriptors than allocated for in configuration %d\0A\00", align 1
@.str.22.434 = private unnamed_addr constant [68 x i8] c"config %d contains an unexpected descriptor of type 0x%X, skipping\0A\00", align 1
@.str.23.435 = private unnamed_addr constant [73 x i8] c"config %d has %d interface%s, different from the descriptor's value: %d\0A\00", align 1
@.str.24.436 = private unnamed_addr constant [30 x i8] c"config %d has no interfaces?\0A\00", align 1
@.str.25.437 = private unnamed_addr constant [38 x i8] c"config %d has no interface number %d\0A\00", align 1
@.str.26.438 = private unnamed_addr constant [87 x i8] c"too many alternate settings for config %d interface %d: %d, using maximum allowed: %d\0A\00", align 1
@usb_parse_configuration.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.usb_parse_configuration, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.28.459, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.29.440, i32 0, i32 0), i8 70, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.29.440 = private unnamed_addr constant [34 x i8] c"skipped %d descriptor%s after %s\0A\00", align 1
@.str.31.442 = private unnamed_addr constant [45 x i8] c"config %d interface %d has no altsetting %d\0A\00", align 1
@.str.34.443 = private unnamed_addr constant [73 x i8] c"Duplicate descriptor for config %d interface %d altsetting %d, skipping\0A\00", align 1
@usb_parse_interface.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.usb_parse_interface, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.28.459, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.29.440, i32 0, i32 0), i8 102, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@.str.36.445 = private unnamed_addr constant [92 x i8] c"too many endpoints for config %d interface %d altsetting %d: %d, using maximum allowed: %d\0A\00", align 1
@.str.37.446 = private unnamed_addr constant [120 x i8] c"config %d interface %d altsetting %d has %d endpoint descriptor%s, different from the interface descriptor's value: %d\0A\00", align 1
@.str.38.447 = private unnamed_addr constant [96 x i8] c"config %d interface %d altsetting %d has an invalid endpoint descriptor of length %d, skipping\0A\00", align 1
@.str.39.448 = private unnamed_addr constant [90 x i8] c"config %d interface %d altsetting %d has an invalid endpoint with address 0x%X, skipping\0A\00", align 1
@.str.40.453 = private unnamed_addr constant [96 x i8] c"config %d interface %d altsetting %d endpoint 0x%X has an invalid bInterval %d, changing to %d\0A\00", align 1
@.str.41 = private unnamed_addr constant [83 x i8] c"config %d interface %d altsetting %d endpoint 0x%X is Bulk; changing to Interrupt\0A\00", align 1
@.str.42.456 = private unnamed_addr constant [82 x i8] c"config %d interface %d altsetting %d bulk endpoint 0x%X has invalid maxpacket %d\0A\00", align 1
@usb_parse_endpoint.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.usb_parse_endpoint, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.28.459, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.29.440, i32 0, i32 0), i8 23, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@.str.43.457 = private unnamed_addr constant [9 x i8] c"endpoint\00", align 1
@__func__.usb_parse_endpoint = private unnamed_addr constant [19 x i8] c"usb_parse_endpoint\00", align 1
@.str.28.459 = private unnamed_addr constant [26 x i8] c"drivers/usb/core/config.c\00", align 1
@.str.44.460 = private unnamed_addr constant [104 x i8] c"No SuperSpeed endpoint companion for config %d  interface %d altsetting %d ep %d: using minimum values\0A\00", align 1
@.str.45.462 = private unnamed_addr constant [101 x i8] c"Control endpoint with bMaxBurst = %d in config %d interface %d altsetting %d ep %d: setting to zero\0A\00", align 1
@.str.46.463 = private unnamed_addr constant [91 x i8] c"Endpoint with bMaxBurst = %d in config %d interface %d altsetting %d ep %d: setting to 15\0A\00", align 1
@.str.47.466 = private unnamed_addr constant [99 x i8] c"%s endpoint with bmAttributes = %d in config %d interface %d altsetting %d ep %d: setting to zero\0A\00", align 1
@.str.50.467 = private unnamed_addr constant [106 x i8] c"Bulk endpoint with more than 65536 streams in config %d interface %d altsetting %d ep %d: setting to max\0A\00", align 1
@.str.51.468 = private unnamed_addr constant [90 x i8] c"Isoc endpoint has Mult of %d in config %d interface %d altsetting %d ep %d: setting to 3\0A\00", align 1
@.str.54.470 = private unnamed_addr constant [4 x i8] c"Int\00", align 1
@.str.52.471 = private unnamed_addr constant [103 x i8] c"%s endpoint with wBytesPerInterval of %d in config %d interface %d altsetting %d ep %d: setting to %d\0A\00", align 1
@__func__.usb_parse_interface = private unnamed_addr constant [20 x i8] c"usb_parse_interface\00", align 1
@__func__.usb_parse_configuration = private unnamed_addr constant [24 x i8] c"usb_parse_configuration\00", align 1
@.str.9.479 = private unnamed_addr constant [30 x i8] c"unable to get BOS descriptor\0A\00", align 1
@.str.10.480 = private unnamed_addr constant [34 x i8] c"unable to get BOS descriptor set\0A\00", align 1
@.str.11.481 = private unnamed_addr constant [31 x i8] c"descriptor type invalid, skip\0A\00", align 1
@__kcrctab_usb_register_dev = internal constant i64 ptrtoint (i8** @__crc_usb_register_dev to i64), section "___kcrctab_gpl+usb_register_dev", align 8
@__ksymtab_usb_register_dev = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_interface*, %struct.usb_class_driver*)* @usb_register_dev to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_usb_register_dev, i32 0, i32 0) }, section "___ksymtab_gpl+usb_register_dev", align 8
@__kcrctab_usb_deregister_dev = internal constant i64 ptrtoint (i8** @__crc_usb_deregister_dev to i64), section "___kcrctab_gpl+usb_deregister_dev", align 8
@__ksymtab_usb_deregister_dev = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.usb_interface*, %struct.usb_class_driver*)* @usb_deregister_dev to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_deregister_dev, i32 0, i32 0) }, section "___ksymtab_gpl+usb_deregister_dev", align 8
@__kstrtab_usb_deregister_dev = internal constant [19 x i8] c"usb_deregister_dev\00", section "__ksymtab_strings", align 1
@usb_deregister_dev.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.usb_deregister_dev, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.3.491, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.6.483, i32 0, i32 0), i8 -14, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.6.483 = private unnamed_addr constant [19 x i8] c"removing %d minor\0A\00", align 1
@minor_rwsem = internal global %struct.rw_semaphore { i64 0, %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.11.488, i32 0, i32 0), i32 0, i64 0 } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rw_semaphore* @minor_rwsem to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rw_semaphore* @minor_rwsem to i8*), i64 80) to %struct.list_head*) }, %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.12.489, i32 0, i32 0), i32 0, i64 0 } }, align 8
@usb_minors = internal global [256 x %struct.file_operations*] zeroinitializer, align 16
@usb_class = internal global %struct.usb_class* null, align 8
@.str.10.486 = private unnamed_addr constant [21 x i8] c"include/linux/kref.h\00", align 1
@.str.11.488 = private unnamed_addr constant [22 x i8] c"minor_rwsem.wait_lock\00", align 1
@.str.12.489 = private unnamed_addr constant [12 x i8] c"minor_rwsem\00", align 1
@__func__.usb_deregister_dev = private unnamed_addr constant [19 x i8] c"usb_deregister_dev\00", align 1
@.str.3.491 = private unnamed_addr constant [24 x i8] c"drivers/usb/core/file.c\00", align 1
@__crc_usb_deregister_dev = extern_weak global i8*, align 8
@__kstrtab_usb_register_dev = internal constant [17 x i8] c"usb_register_dev\00", section "__ksymtab_strings", align 1
@usb_register_dev.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.usb_register_dev, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.3.491, i32 0, i32 0), i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.4.492, i32 0, i32 0), i8 -70, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.4.492 = private unnamed_addr constant [37 x i8] c"looking for a minor, starting at %d\0A\00", align 1
@.str.5.493 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@__func__.usb_register_dev = private unnamed_addr constant [17 x i8] c"usb_register_dev\00", align 1
@.str.8.498 = private unnamed_addr constant [8 x i8] c"usbmisc\00", align 1
@init_usb_class.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.9.499 = private unnamed_addr constant [39 x i8] c"\013class_create failed for usb devices\0A\00", align 1
@kref_get.__warned.503 = internal global i8 0, section ".data.unlikely", align 1
@__crc_usb_register_dev = extern_weak global i8*, align 8
@usb_fops = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @noop_llseek, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @usb_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* null, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@.str.1.507 = private unnamed_addr constant [42 x i8] c"\013Unable to get major %d for usb devices\0A\00", align 1
@pool_max = internal constant [4 x i64] [i64 32, i64 128, i64 512, i64 2048], align 16
@.str.512 = private unnamed_addr constant [10 x i8] c"buffer-%d\00", align 1
@x86_dma_fallback_dev = external global %struct.device, align 8
@.str.1.524 = private unnamed_addr constant [63 x i8] c"/diffkemp/kernel/linux-3.10/arch/x86/include/asm/dma-mapping.h\00", align 1
@usb_device_groups = global [3 x %struct.attribute_group*] [%struct.attribute_group* @dev_attr_grp, %struct.attribute_group* @dev_string_attr_grp, %struct.attribute_group* null], align 16
@dev_attr_grp = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([27 x %struct.attribute*], [27 x %struct.attribute*]* @dev_attrs, i32 0, i32 0) }, align 8
@dev_string_attr_grp = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* @dev_string_attrs_are_visible, %struct.attribute** getelementptr inbounds ([4 x %struct.attribute*], [4 x %struct.attribute*]* @dev_string_attrs, i32 0, i32 0) }, align 8
@dev_string_attrs = internal global [4 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_manufacturer, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_product, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_serial, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_manufacturer = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.46.533, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_manufacturer, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_product = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47.532, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_product, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_serial = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.48.528, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_serial, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.48.528 = private unnamed_addr constant [7 x i8] c"serial\00", align 1
@.str.47.532 = private unnamed_addr constant [8 x i8] c"product\00", align 1
@.str.46.533 = private unnamed_addr constant [13 x i8] c"manufacturer\00", align 1
@dev_attrs = internal global [27 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_configuration, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bNumInterfaces, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bConfigurationValue, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bmAttributes, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bMaxPower, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_urbnum, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_idVendor, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_idProduct, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bcdDevice, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bDeviceClass, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bDeviceSubClass, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bDeviceProtocol, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bNumConfigurations, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bMaxPacketSize0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_speed, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_busnum, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_devnum, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_devpath, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_version, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_maxchild, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_quirks, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_avoid_reset_quirk, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_authorized, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_remove, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_removable, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_ltm_capable, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_configuration = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.1.580, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_configuration_string, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bNumInterfaces = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.3.578, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_bNumInterfaces, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bConfigurationValue = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.5.577, i32 0, i32 0), i16 420, i8 1, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_bConfigurationValue, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_bConfigurationValue }, align 8
@dev_attr_bmAttributes = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6.647, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_bmAttributes, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bMaxPower = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10.572, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_bMaxPower, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_urbnum = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12.570, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_urbnum, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_idVendor = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.14.569, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_idVendor, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_idProduct = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.16.568, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_idProduct, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bcdDevice = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.17.566, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_bcdDevice, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bDeviceClass = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.18.565, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_bDeviceClass, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bDeviceSubClass = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.20.564, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_bDeviceSubClass, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bDeviceProtocol = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.21.562, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_bDeviceProtocol, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bNumConfigurations = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.22.561, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_bNumConfigurations, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bMaxPacketSize0 = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.23.560, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_bMaxPacketSize0, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_speed = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.24.555, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_speed, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_busnum = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.30.554, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_busnum, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_devnum = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.31.553, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_devnum, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_devpath = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.32.552, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_devpath, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_version = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.33.550, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_version, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_maxchild = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.35.549, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_maxchild, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_quirks = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.36.547, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_quirks, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_avoid_reset_quirk = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.38.544, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_avoid_reset_quirk, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_avoid_reset_quirk }, align 8
@dev_attr_authorized = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.39.542, i32 0, i32 0), i16 420, i8 1, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @usb_dev_authorized_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @usb_dev_authorized_store }, align 8
@dev_attr_remove = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.40.541, i32 0, i32 0), i16 128, i8 1, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* null, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @usb_remove_store }, align 8
@dev_attr_removable = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.41.538, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_removable, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_ltm_capable = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.43.534, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_ltm_capable, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.43.534 = private unnamed_addr constant [12 x i8] c"ltm_capable\00", align 1
@.str.44.536 = private unnamed_addr constant [4 x i8] c"yes\00", align 1
@.str.45.537 = private unnamed_addr constant [3 x i8] c"no\00", align 1
@.str.41.538 = private unnamed_addr constant [10 x i8] c"removable\00", align 1
@.str.42.540 = private unnamed_addr constant [6 x i8] c"fixed\00", align 1
@.str.40.541 = private unnamed_addr constant [7 x i8] c"remove\00", align 1
@.str.39.542 = private unnamed_addr constant [11 x i8] c"authorized\00", align 1
@.str.6.543 = private unnamed_addr constant [4 x i8] c"%u\0A\00", align 1
@.str.38.544 = private unnamed_addr constant [18 x i8] c"avoid_reset_quirk\00", align 1
@.str.7.545 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.13.546 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.36.547 = private unnamed_addr constant [7 x i8] c"quirks\00", align 1
@.str.37.548 = private unnamed_addr constant [6 x i8] c"0x%x\0A\00", align 1
@.str.35.549 = private unnamed_addr constant [9 x i8] c"maxchild\00", align 1
@.str.33.550 = private unnamed_addr constant [8 x i8] c"version\00", align 1
@.str.34.551 = private unnamed_addr constant [10 x i8] c"%2x.%02x\0A\00", align 1
@.str.32.552 = private unnamed_addr constant [8 x i8] c"devpath\00", align 1
@.str.31.553 = private unnamed_addr constant [7 x i8] c"devnum\00", align 1
@.str.30.554 = private unnamed_addr constant [7 x i8] c"busnum\00", align 1
@.str.24.555 = private unnamed_addr constant [6 x i8] c"speed\00", align 1
@.str.23.560 = private unnamed_addr constant [16 x i8] c"bMaxPacketSize0\00", align 1
@.str.22.561 = private unnamed_addr constant [19 x i8] c"bNumConfigurations\00", align 1
@.str.21.562 = private unnamed_addr constant [16 x i8] c"bDeviceProtocol\00", align 1
@.str.20.564 = private unnamed_addr constant [16 x i8] c"bDeviceSubClass\00", align 1
@.str.18.565 = private unnamed_addr constant [13 x i8] c"bDeviceClass\00", align 1
@.str.17.566 = private unnamed_addr constant [10 x i8] c"bcdDevice\00", align 1
@.str.16.568 = private unnamed_addr constant [10 x i8] c"idProduct\00", align 1
@.str.14.569 = private unnamed_addr constant [9 x i8] c"idVendor\00", align 1
@.str.12.570 = private unnamed_addr constant [7 x i8] c"urbnum\00", align 1
@.str.10.572 = private unnamed_addr constant [10 x i8] c"bMaxPower\00", align 1
@.str.11.574 = private unnamed_addr constant [6 x i8] c"%dmA\0A\00", align 1
@.str.9.576 = private unnamed_addr constant [5 x i8] c"%2x\0A\00", align 1
@.str.5.577 = private unnamed_addr constant [20 x i8] c"bConfigurationValue\00", align 1
@.str.3.578 = private unnamed_addr constant [15 x i8] c"bNumInterfaces\00", align 1
@.str.4.579 = private unnamed_addr constant [5 x i8] c"%2d\0A\00", align 1
@.str.1.580 = private unnamed_addr constant [14 x i8] c"configuration\00", align 1
@usb_interface_groups = global [3 x %struct.attribute_group*] [%struct.attribute_group* @intf_attr_grp, %struct.attribute_group* @intf_assoc_attr_grp, %struct.attribute_group* null], align 16
@intf_attr_grp = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([9 x %struct.attribute*], [9 x %struct.attribute*]* @intf_attrs, i32 0, i32 0) }, align 8
@intf_assoc_attr_grp = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* @intf_assoc_attrs_are_visible, %struct.attribute** getelementptr inbounds ([6 x %struct.attribute*], [6 x %struct.attribute*]* @intf_assoc_attrs, i32 0, i32 0) }, align 8
@intf_assoc_attrs = internal global [6 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_iad_bFirstInterface, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_iad_bInterfaceCount, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_iad_bFunctionClass, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_iad_bFunctionSubClass, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_iad_bFunctionProtocol, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_iad_bFirstInterface = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.68.588, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_iad_bFirstInterface, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_iad_bInterfaceCount = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.69.586, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_iad_bInterfaceCount, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_iad_bFunctionClass = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.71.585, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_iad_bFunctionClass, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_iad_bFunctionSubClass = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.72.584, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_iad_bFunctionSubClass, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_iad_bFunctionProtocol = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.73.583, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_iad_bFunctionProtocol, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.73.583 = private unnamed_addr constant [22 x i8] c"iad_bFunctionProtocol\00", align 1
@.str.72.584 = private unnamed_addr constant [22 x i8] c"iad_bFunctionSubClass\00", align 1
@.str.71.585 = private unnamed_addr constant [19 x i8] c"iad_bFunctionClass\00", align 1
@.str.69.586 = private unnamed_addr constant [20 x i8] c"iad_bInterfaceCount\00", align 1
@.str.70.587 = private unnamed_addr constant [6 x i8] c"%02d\0A\00", align 1
@.str.68.588 = private unnamed_addr constant [20 x i8] c"iad_bFirstInterface\00", align 1
@intf_attrs = internal global [9 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bInterfaceNumber, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bAlternateSetting, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bNumEndpoints, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bInterfaceClass, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bInterfaceSubClass, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_bInterfaceProtocol, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_modalias, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_supports_autosuspend, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_bInterfaceNumber = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.59.598, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_bInterfaceNumber, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bAlternateSetting = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.60.597, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_bAlternateSetting, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bNumEndpoints = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.61.596, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_bNumEndpoints, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bInterfaceClass = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.62.595, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_bInterfaceClass, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bInterfaceSubClass = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.63.594, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_bInterfaceSubClass, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_bInterfaceProtocol = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.64.593, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_bInterfaceProtocol, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_modalias = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.65.591, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_modalias, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_supports_autosuspend = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.67.589, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_supports_autosuspend, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.67.589 = private unnamed_addr constant [21 x i8] c"supports_autosuspend\00", align 1
@.str.65.591 = private unnamed_addr constant [9 x i8] c"modalias\00", align 1
@.str.66.592 = private unnamed_addr constant [65 x i8] c"usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02Xin%02X\0A\00", align 1
@.str.64.593 = private unnamed_addr constant [19 x i8] c"bInterfaceProtocol\00", align 1
@.str.63.594 = private unnamed_addr constant [19 x i8] c"bInterfaceSubClass\00", align 1
@.str.62.595 = private unnamed_addr constant [16 x i8] c"bInterfaceClass\00", align 1
@.str.61.596 = private unnamed_addr constant [14 x i8] c"bNumEndpoints\00", align 1
@.str.60.597 = private unnamed_addr constant [18 x i8] c"bAlternateSetting\00", align 1
@.str.59.598 = private unnamed_addr constant [17 x i8] c"bInterfaceNumber\00", align 1
@dev_bin_attr_descriptors = internal global %struct.bin_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.49.613, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 65553, i8* null, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)* @read_descriptors, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)* null, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* null }, align 8
@dev_attr_persist = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.50.603, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_persist, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_persist }, align 8
@power_group_name = external constant [0 x i8], align 1
@.str.50.603 = private unnamed_addr constant [8 x i8] c"persist\00", align 1
@usb2_hardware_lpm_attr_group = internal global %struct.attribute_group { i8* getelementptr inbounds ([0 x i8], [0 x i8]* @power_group_name, i32 0, i32 0), i16 (%struct.kobject*, %struct.attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([2 x %struct.attribute*], [2 x %struct.attribute*]* @usb2_hardware_lpm_attr, i32 0, i32 0) }, align 8
@power_attr_group = internal global %struct.attribute_group { i8* getelementptr inbounds ([0 x i8], [0 x i8]* @power_group_name, i32 0, i32 0), i16 (%struct.kobject*, %struct.attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([5 x %struct.attribute*], [5 x %struct.attribute*]* @power_attrs, i32 0, i32 0) }, align 8
@power_attrs = internal global [5 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_autosuspend, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_level, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_connected_duration, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_active_duration, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_autosuspend = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.51.608, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_autosuspend, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_autosuspend }, align 8
@dev_attr_level = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.52.606, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_level, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_level }, align 8
@dev_attr_connected_duration = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.54.605, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_connected_duration, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_active_duration = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.55.604, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_active_duration, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.55.604 = private unnamed_addr constant [16 x i8] c"active_duration\00", align 1
@.str.54.605 = private unnamed_addr constant [19 x i8] c"connected_duration\00", align 1
@.str.52.606 = private unnamed_addr constant [6 x i8] c"level\00", align 1
@on_string = internal constant [3 x i8] c"on\00", align 1
@warn_level.level_warned = internal global i32 0, align 4
@.str.53.607 = private unnamed_addr constant [65 x i8] c"\014WARNING! power/level is deprecated; use power/control instead\0A\00", align 1
@.str.51.608 = private constant [12 x i8] c"autosuspend\00", align 1
@usb2_hardware_lpm_attr = internal global [2 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_usb2_hardware_lpm, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_usb2_hardware_lpm = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.56.609, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_usb2_hardware_lpm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_usb2_hardware_lpm }, align 8
@.str.56.609 = private unnamed_addr constant [18 x i8] c"usb2_hardware_lpm\00", align 1
@.str.57.610 = private unnamed_addr constant [8 x i8] c"enabled\00", align 1
@.str.58.611 = private unnamed_addr constant [9 x i8] c"disabled\00", align 1
@.str.49.613 = private unnamed_addr constant [12 x i8] c"descriptors\00", align 1
@dev_attr_interface = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.74.616, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_interface_string, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.74.616 = private unnamed_addr constant [10 x i8] c"interface\00", align 1
@usb_ep_device_type = global { i8*, %struct.attribute_group**, i32 (%struct.device.2626*, %struct.kobj_uevent_env*)*, i8* (%struct.device.2626*, i16*, i32*, i32*)*, void (%struct.device.2626*)*, %struct.dev_pm_ops.2640* } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.619, i32 0, i32 0), %struct.attribute_group** null, i32 (%struct.device.2626*, %struct.kobj_uevent_env*)* null, i8* (%struct.device.2626*, i16*, i32*, i32*)* null, void (%struct.device.2626*)* @ep_device_release, %struct.dev_pm_ops.2640* null }, align 8
@.str.619 = private unnamed_addr constant [13 x i8] c"usb_endpoint\00", align 1
@ep_dev_groups = internal global [2 x %struct.attribute_group*] [%struct.attribute_group* @ep_dev_attr_grp, %struct.attribute_group* null], align 16
@.str.1.623 = private unnamed_addr constant [8 x i8] c"ep_%02x\00", align 1
@ep_dev_attr_grp = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([9 x %struct.attribute*], [9 x %struct.attribute*]* @ep_dev_attrs, i32 0, i32 0) }, align 8
@ep_dev_attrs = internal global [9 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute.2824, %struct.device_attribute.2824* @dev_attr_bLength, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute.2824, %struct.device_attribute.2824* @dev_attr_bEndpointAddress, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute.2824, %struct.device_attribute.2824* @dev_attr_bmAttributes.625, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute.2824, %struct.device_attribute.2824* @dev_attr_bInterval, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute.2824, %struct.device_attribute.2824* @dev_attr_wMaxPacketSize, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute.2824, %struct.device_attribute.2824* @dev_attr_interval, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute.2824, %struct.device_attribute.2824* @dev_attr_type, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute.2824, %struct.device_attribute.2824* @dev_attr_direction, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_bLength = internal global %struct.device_attribute.2824 { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.3.649, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*)* @show_ep_bLength, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*, i64)* null }, align 8
@dev_attr_bEndpointAddress = internal global %struct.device_attribute.2824 { %struct.attribute { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5.648, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*)* @show_ep_bEndpointAddress, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*, i64)* null }, align 8
@dev_attr_bmAttributes.625 = internal global %struct.device_attribute.2824 { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6.647, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*)* @show_ep_bmAttributes, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*, i64)* null }, align 8
@dev_attr_bInterval = internal global %struct.device_attribute.2824 { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.7.645, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*)* @show_ep_bInterval, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*, i64)* null }, align 8
@dev_attr_wMaxPacketSize = internal global %struct.device_attribute.2824 { %struct.attribute { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.8.642, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*)* @show_ep_wMaxPacketSize, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*, i64)* null }, align 8
@dev_attr_interval = internal global %struct.device_attribute.2824 { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.10.640, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*)* @show_ep_interval, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*, i64)* null }, align 8
@dev_attr_type = internal global %struct.device_attribute.2824 { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12.633, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*)* @show_ep_type, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*, i64)* null }, align 8
@dev_attr_direction = internal global %struct.device_attribute.2824 { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.19.626, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*)* @show_ep_direction, i64 (%struct.device.2626*, %struct.device_attribute.2824*, i8*, i64)* null }, align 8
@.str.19.626 = private unnamed_addr constant [10 x i8] c"direction\00", align 1
@.str.20.631 = private unnamed_addr constant [5 x i8] c"both\00", align 1
@.str.12.633 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.14.636 = private unnamed_addr constant [8 x i8] c"Control\00", align 1
@.str.17.639 = private unnamed_addr constant [10 x i8] c"Interrupt\00", align 1
@.str.10.640 = private unnamed_addr constant [9 x i8] c"interval\00", align 1
@.str.11.641 = private unnamed_addr constant [7 x i8] c"%d%cs\0A\00", align 1
@.str.8.642 = private unnamed_addr constant [15 x i8] c"wMaxPacketSize\00", align 1
@.str.9.644 = private unnamed_addr constant [6 x i8] c"%04x\0A\00", align 1
@.str.7.645 = private unnamed_addr constant [10 x i8] c"bInterval\00", align 1
@.str.4.646 = private unnamed_addr constant [6 x i8] c"%02x\0A\00", align 1
@.str.6.647 = private unnamed_addr constant [13 x i8] c"bmAttributes\00", align 1
@.str.5.648 = private unnamed_addr constant [17 x i8] c"bEndpointAddress\00", align 1
@.str.3.649 = private unnamed_addr constant [8 x i8] c"bLength\00", align 1
@usbfs_mutex = global %struct.mutex { %union.anon.5 { i32 1 }, %struct.spinlock { %union.anon.4 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.653, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usbfs_mutex to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usbfs_mutex to i8*), i64 80) to %struct.list_head*) }, %struct.task_struct* null, i8* null, i8* bitcast (%struct.mutex* @usbfs_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.1.654, i32 0, i32 0), i32 0, i64 0 } }, align 8
@.str.653 = private unnamed_addr constant [22 x i8] c"usbfs_mutex.wait_lock\00", align 1
@.str.1.654 = private unnamed_addr constant [12 x i8] c"usbfs_mutex\00", align 1
@usbfs_driver = global %struct.usb_driver { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2.657, i32 0, i32 0), i32 (%struct.usb_interface*, %struct.usb_device_id*)* @driver_probe, void (%struct.usb_interface*)* @driver_disconnect, i32 (%struct.usb_interface*, i32, i8*)* null, i32 (%struct.usb_interface*, i32)* @driver_suspend, i32 (%struct.usb_interface*)* @driver_resume, i32 (%struct.usb_interface*)* null, i32 (%struct.usb_interface*)* null, i32 (%struct.usb_interface*)* null, %struct.usb_device_id* null, %struct.__wait_queue_head zeroinitializer, %struct.usbdrv_wrap zeroinitializer, i8 0 }, align 8
@.str.2.657 = private unnamed_addr constant [6 x i8] c"usbfs\00", align 1
@.str.7.660 = private unnamed_addr constant [34 x i8] c"interface number %u out of range\0A\00", align 1
@usbdev_file_operations = constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @usbdev_lseek, i64 (%struct.file*, i8*, i64, i64*)* @usbdev_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @usbdev_poll, i64 (%struct.file*, i32, i64)* @usbdev_ioctl, i64 (%struct.file*, i32, i64)* @usbdev_compat_ioctl, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @usbdev_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @usbdev_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@usbfs_memory_usage = internal global %union.anon.5 zeroinitializer, align 4
@.str.56.674 = private unnamed_addr constant [28 x i8] c"include/linux/scatterlist.h\00", align 1
@.str.58.675 = private unnamed_addr constant [21 x i8] c"include/linux/cred.h\00", align 1
@.str.62.678 = private unnamed_addr constant [20 x i8] c"&(&ps->lock)->rlock\00", align 1
@usbdev_open.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.64.679 = private unnamed_addr constant [10 x i8] c"&ps->wait\00", align 1
@usbdev_open.__key.63 = internal global %struct.lock_class_key zeroinitializer, align 1
@usbfs_snoop = internal global i8 0, align 1
@.str.65.681 = private unnamed_addr constant [26 x i8] c"opened by process %d: %s\0A\00", align 1
@.str.8.683 = private unnamed_addr constant [13 x i8] c"%s: CONTROL\0A\00", align 1
@__func__.usbdev_do_ioctl = private unnamed_addr constant [16 x i8] c"usbdev_do_ioctl\00", align 1
@.str.9.684 = private unnamed_addr constant [10 x i8] c"%s: BULK\0A\00", align 1
@.str.10.685 = private unnamed_addr constant [13 x i8] c"%s: RESETEP\0A\00", align 1
@.str.11.686 = private unnamed_addr constant [11 x i8] c"%s: RESET\0A\00", align 1
@.str.12.687 = private unnamed_addr constant [16 x i8] c"%s: CLEAR_HALT\0A\00", align 1
@.str.13.688 = private unnamed_addr constant [15 x i8] c"%s: GETDRIVER\0A\00", align 1
@.str.14.689 = private unnamed_addr constant [17 x i8] c"%s: CONNECTINFO\0A\00", align 1
@.str.15.690 = private unnamed_addr constant [18 x i8] c"%s: SETINTERFACE\0A\00", align 1
@.str.16.691 = private unnamed_addr constant [22 x i8] c"%s: SETCONFIGURATION\0A\00", align 1
@.str.17.692 = private unnamed_addr constant [15 x i8] c"%s: SUBMITURB\0A\00", align 1
@.str.18.693 = private unnamed_addr constant [15 x i8] c"%s: CONTROL32\0A\00", align 1
@.str.19.694 = private unnamed_addr constant [12 x i8] c"%s: BULK32\0A\00", align 1
@.str.20.695 = private unnamed_addr constant [18 x i8] c"%s: DISCSIGNAL32\0A\00", align 1
@.str.21.696 = private unnamed_addr constant [17 x i8] c"%s: SUBMITURB32\0A\00", align 1
@.str.22.697 = private unnamed_addr constant [15 x i8] c"%s: REAPURB32\0A\00", align 1
@.str.23.698 = private unnamed_addr constant [21 x i8] c"%s: REAPURBNDELAY32\0A\00", align 1
@.str.24.699 = private unnamed_addr constant [13 x i8] c"%s: IOCTL32\0A\00", align 1
@.str.25.700 = private unnamed_addr constant [16 x i8] c"%s: DISCARDURB\0A\00", align 1
@.str.26.701 = private unnamed_addr constant [13 x i8] c"%s: REAPURB\0A\00", align 1
@.str.27.702 = private unnamed_addr constant [19 x i8] c"%s: REAPURBNDELAY\0A\00", align 1
@.str.28.703 = private unnamed_addr constant [16 x i8] c"%s: DISCSIGNAL\0A\00", align 1
@.str.29.704 = private unnamed_addr constant [20 x i8] c"%s: CLAIMINTERFACE\0A\00", align 1
@.str.30.705 = private unnamed_addr constant [22 x i8] c"%s: RELEASEINTERFACE\0A\00", align 1
@.str.31.706 = private unnamed_addr constant [11 x i8] c"%s: IOCTL\0A\00", align 1
@.str.32.707 = private unnamed_addr constant [16 x i8] c"%s: CLAIM_PORT\0A\00", align 1
@.str.33.708 = private unnamed_addr constant [18 x i8] c"%s: RELEASE_PORT\0A\00", align 1
@proc_disconnect_claim.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.proc_disconnect_claim, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.53.712, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.60.709, i32 0, i32 0), i8 -84, i8 7, i8 4, i8 0 }, section "__verbose", align 8
@.str.60.709 = private unnamed_addr constant [21 x i8] c"disconnect by usbfs\0A\00", align 1
@__func__.proc_disconnect_claim = private unnamed_addr constant [22 x i8] c"proc_disconnect_claim\00", align 1
@.str.53.712 = private unnamed_addr constant [25 x i8] c"drivers/usb/core/devio.c\00", align 1
@.str.37.713 = private unnamed_addr constant [62 x i8] c"/diffkemp/kernel/linux-3.10/arch/x86/include/asm/uaccess_64.h\00", align 1
@.str.38.714 = private unnamed_addr constant [27 x i8] c"Buffer overflow detected!\0A\00", align 1
@.str.61.715 = private unnamed_addr constant [35 x i8] c"port %d claimed by process %d: %s\0A\00", align 1
@proc_ioctl.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.proc_ioctl, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.53.712, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.60.709, i32 0, i32 0), i8 42, i8 7, i8 4, i8 0 }, section "__verbose", align 8
@__func__.proc_ioctl = private unnamed_addr constant [11 x i8] c"proc_ioctl\00", align 1
@kernel_stack = external global i64, align 8
@.str.34.721 = private unnamed_addr constant [83 x i8] c"control urb: bRequestType=%02x bRequest=%02x wValue=%04x wIndex=%04x wLength=%04x\0A\00", align 1
@.str.35.729 = private unnamed_addr constant [3 x i8] c"\017\00", align 1
@.str.55.730 = private unnamed_addr constant [35 x i8] c"usbfs: usb_submit_urb returned %d\0A\00", align 1
@.str.50.731 = private unnamed_addr constant [7 x i8] c"data: \00", align 1
@snoop_urb.types = internal global [4 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.40.738, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.41.739, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.42.740, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.43.741, i32 0, i32 0)], align 16
@snoop_urb.dirs = internal global [2 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.44.736, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.45.737, i32 0, i32 0)], align 16
@.str.46.732 = private unnamed_addr constant [35 x i8] c"userurb %p, ep%d %s-%s, length %u\0A\00", align 1
@.str.47.733 = private unnamed_addr constant [52 x i8] c"userurb %p, ep%d %s-%s, actual_length %u status %d\0A\00", align 1
@.str.48.734 = private unnamed_addr constant [35 x i8] c"ep%d %s-%s, length %u, timeout %d\0A\00", align 1
@.str.49.735 = private unnamed_addr constant [41 x i8] c"ep%d %s-%s, actual_length %u, status %d\0A\00", align 1
@.str.44.736 = private unnamed_addr constant [4 x i8] c"out\00", align 1
@.str.45.737 = private unnamed_addr constant [3 x i8] c"in\00", align 1
@.str.40.738 = private unnamed_addr constant [5 x i8] c"isoc\00", align 1
@.str.41.739 = private unnamed_addr constant [4 x i8] c"int\00", align 1
@.str.42.740 = private unnamed_addr constant [5 x i8] c"ctrl\00", align 1
@.str.43.741 = private unnamed_addr constant [5 x i8] c"bulk\00", align 1
@.str.57.743 = private unnamed_addr constant [14 x i8] c"urb complete\0A\00", align 1
@usbfs_memory_mb = internal global i32 16, align 4
@.str.39.747 = private unnamed_addr constant [62 x i8] c"usbfs: process %d (%s) did not claim interface %u before use\0A\00", align 1
@.str.52.748 = private unnamed_addr constant [62 x i8] c"usbfs: interface %d claimed by %s while '%s' sets config #%d\0A\00", align 1
@.str.51.750 = private unnamed_addr constant [20 x i8] c"include/linux/usb.h\00", align 1
@.str.36.752 = private unnamed_addr constant [66 x i8] c"usbfs: USBDEVFS_CONTROL failed cmd %s rqt %u rq %u len %u ret %d\0A\00", align 1
@__param_usbfs_snoop = internal constant %struct.kernel_param { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__param_str_usbfs_snoop, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 420, i16 -1, %union.anon.3 { i8* @usbfs_snoop } }, section "__param", align 8
@__UNIQUE_ID_usbfs_snooptype100 = internal constant [26 x i8] c"parmtype=usbfs_snoop:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_usbfs_snoop101 = internal constant [47 x i8] c"parm=usbfs_snoop:true to log all usbfs traffic\00", section ".modinfo", align 1
@__param_usbfs_memory_mb = internal constant %struct.kernel_param { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__param_str_usbfs_memory_mb, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_uint, i16 420, i16 -1, %union.anon.3 { i8* bitcast (i32* @usbfs_memory_mb to i8*) } }, section "__param", align 8
@__UNIQUE_ID_usbfs_memory_mbtype117 = internal constant [30 x i8] c"parmtype=usbfs_memory_mb:uint\00", section ".modinfo", align 1
@__UNIQUE_ID_usbfs_memory_mb119 = internal constant [73 x i8] c"parm=usbfs_memory_mb:maximum MB allowed for usbfs buffers (0 = no limit)\00", section ".modinfo", align 1
@__param_str_usbfs_memory_mb = internal constant [16 x i8] c"usbfs_memory_mb\00", align 16
@param_ops_uint = external global %struct.kernel_param_ops, align 8
@__param_str_usbfs_snoop = internal constant [12 x i8] c"usbfs_snoop\00", align 1
@.str.3.756 = private unnamed_addr constant [11 x i8] c"usb_device\00", align 1
@.str.4.757 = private unnamed_addr constant [44 x i8] c"\013Unable to register minors for usb_device\0A\00", align 1
@usb_device_cdev = internal global %struct.cdev zeroinitializer, align 8
@.str.5.758 = private unnamed_addr constant [37 x i8] c"\013Unable to get usb_device major %d\0A\00", align 1
@usbdev_nb = internal global %struct.notifier_block { i32 (%struct.notifier_block*, i64, i8*)* @usbdev_notify, %struct.notifier_block* null, i32 0 }, align 8
@__kcrctab_usb_register_notify = internal constant i64 ptrtoint (i8** @__crc_usb_register_notify to i64), section "___kcrctab_gpl+usb_register_notify", align 8
@__ksymtab_usb_register_notify = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.notifier_block*)* @usb_register_notify to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_usb_register_notify, i32 0, i32 0) }, section "___ksymtab_gpl+usb_register_notify", align 8
@__kcrctab_usb_unregister_notify = internal constant i64 ptrtoint (i8** @__crc_usb_unregister_notify to i64), section "___kcrctab_gpl+usb_unregister_notify", align 8
@__ksymtab_usb_unregister_notify = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.notifier_block*)* @usb_unregister_notify to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_usb_unregister_notify, i32 0, i32 0) }, section "___ksymtab_gpl+usb_unregister_notify", align 8
@__kstrtab_usb_unregister_notify = internal constant [22 x i8] c"usb_unregister_notify\00", section "__ksymtab_strings", align 1
@usb_notifier_list = internal global %struct.blocking_notifier_head { %struct.rw_semaphore { i64 0, %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.1.764, i32 0, i32 0), i32 0, i64 0 } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.blocking_notifier_head* @usb_notifier_list to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.blocking_notifier_head* @usb_notifier_list to i8*), i64 80) to %struct.list_head*) }, %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2.765, i32 0, i32 0), i32 0, i64 0 } }, %struct.notifier_block* null }, align 8
@.str.1.764 = private unnamed_addr constant [36 x i8] c"(usb_notifier_list).rwsem.wait_lock\00", align 1
@.str.2.765 = private unnamed_addr constant [26 x i8] c"(usb_notifier_list).rwsem\00", align 1
@__crc_usb_unregister_notify = extern_weak global i8*, align 8
@__kstrtab_usb_register_notify = internal constant [20 x i8] c"usb_register_notify\00", section "__ksymtab_strings", align 1
@__crc_usb_register_notify = extern_weak global i8*, align 8
@usb_generic_driver = global %struct.usb_device_driver { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.774, i32 0, i32 0), i32 (%struct.usb_device*)* @generic_probe, void (%struct.usb_device*)* @generic_disconnect, i32 (%struct.usb_device*, i32)* @generic_suspend, i32 (%struct.usb_device*, i32)* @generic_resume, %struct.usbdrv_wrap zeroinitializer, i8 1 }, align 8
@.str.5.774 = private unnamed_addr constant [4 x i8] c"usb\00", align 1
@.str.9.775 = private unnamed_addr constant [36 x i8] c"Device is not authorized for usage\0A\00", align 1
@.str.10.778 = private unnamed_addr constant [32 x i8] c"can't set config #%d, error %d\0A\00", align 1
@.str.781 = private unnamed_addr constant [69 x i8] c"rejected %d configuration%s due to insufficient available bus power\0A\00", align 1
@usb_choose_configuration.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.usb_choose_configuration, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.785, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.3.782, i32 0, i32 0), i8 -107, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.3.782 = private unnamed_addr constant [43 x i8] c"configuration #%d chosen from %d choice%s\0A\00", align 1
@.str.4.783 = private unnamed_addr constant [42 x i8] c"no configuration chosen from %d choice%s\0A\00", align 1
@__func__.usb_choose_configuration = private unnamed_addr constant [25 x i8] c"usb_choose_configuration\00", align 1
@.str.2.785 = private unnamed_addr constant [27 x i8] c"drivers/usb/core/generic.c\00", align 1
@.str.8.787 = private unnamed_addr constant [2 x i8] c"s\00", align 1
@usb_quirk_list = internal constant [33 x %struct.usb_device_id] [%struct.usb_device_id { i16 3, i16 516, i16 24613, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1008, i16 1793, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 1 }, %struct.usb_device_id { i16 3, i16 1054, i16 12320, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1118, i16 1904, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1133, i16 2241, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1133, i16 2242, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1133, i16 2243, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1133, i16 2245, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1133, i16 2246, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1133, i16 2247, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1133, i16 -16094, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 64 }, %struct.usb_device_id { i16 3, i16 1137, i16 341, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1204, i16 1318, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 8 }, %struct.usb_device_id { i16 3, i16 1240, i16 12, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 8 }, %struct.usb_device_id { i16 3, i16 1256, i16 26113, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 8 }, %struct.usb_device_id { i16 3, i16 1410, i16 7, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1410, i16 39, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1423, i16 -28076, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1452, i16 538, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1592, i16 2579, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 1 }, %struct.usb_device_id { i16 3, i16 1699, i16 6, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 8 }, %struct.usb_device_id { i16 3, i16 1784, i16 2052, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1784, i16 12293, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 1891, i16 402, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 2284, i16 4096, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 2342, i16 13107, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 8 }, %struct.usb_device_id { i16 3, i16 2417, i16 8192, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 4 }, %struct.usb_device_id { i16 3, i16 2652, i16 8225, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 4310, i16 8704, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 1 }, %struct.usb_device_id { i16 3, i16 5398, i16 -31192, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 3, i16 6408, i16 4885, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 32 }, %struct.usb_device_id { i16 3, i16 -32634, i16 -3675, i16 0, i16 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i64 2 }, %struct.usb_device_id zeroinitializer], align 16
@usb_detect_quirks.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.usb_detect_quirks, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1.792, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.2.790, i32 0, i32 0), i8 -51, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.2.790 = private unnamed_addr constant [32 x i8] c"USB quirks for this device: %x\0A\00", align 1
@__func__.usb_detect_quirks = private unnamed_addr constant [18 x i8] c"usb_detect_quirks\00", align 1
@.str.1.792 = private unnamed_addr constant [26 x i8] c"drivers/usb/core/quirks.c\00", align 1
@usb_interface_quirk_list = internal constant [2 x %struct.usb_device_id] [%struct.usb_device_id { i16 897, i16 1133, i16 0, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 2 }, %struct.usb_device_id zeroinitializer], align 16
@usb_detect_interface_quirks.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.usb_detect_interface_quirks, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1.792, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.3.795, i32 0, i32 0), i8 -30, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.3.795 = private unnamed_addr constant [42 x i8] c"USB interface quirks for this device: %x\0A\00", align 1
@__func__.usb_detect_interface_quirks = private unnamed_addr constant [28 x i8] c"usb_detect_interface_quirks\00", align 1
@usbfs_devices_fops = constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @usb_device_lseek, i64 (%struct.file*, i8*, i64, i64*)* @usb_device_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @usb_device_poll, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* null, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* null, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@device_event = internal global %struct.device_connect_event { %union.anon.5 { i32 1 }, %struct.__wait_queue_head { %struct.spinlock { %union.anon.4 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1.800, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.device_connect_event* @device_event to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.device_connect_event* @device_event to i8*), i64 80) to %struct.list_head*) } } }, align 8
@.str.1.800 = private unnamed_addr constant [23 x i8] c"device_event.wait.lock\00", align 1
@.str.6.805 = private unnamed_addr constant [3 x i8] c"??\00", align 1
@.str.2.806 = private unnamed_addr constant [4 x i8] c"1.5\00", align 1
@.str.3.807 = private unnamed_addr constant [3 x i8] c"12\00", align 1
@.str.4.808 = private unnamed_addr constant [4 x i8] c"480\00", align 1
@.str.5.809 = private unnamed_addr constant [5 x i8] c"5000\00", align 1
@format_topo = internal constant [85 x i8] c"\0AT:  Bus=%2.2d Lev=%2.2d Prnt=%2.2d Port=%2.2d Cnt=%2.2d Dev#=%3d Spd=%-4s MxCh=%2d\0A\00", align 16
@format_bandwidth = internal constant [50 x i8] c"B:  Alloc=%3d/%3d us (%2d%%), #Int=%3d, #Iso=%3d\0A\00", align 16
@.str.7.810 = private unnamed_addr constant [13 x i8] c"(truncated)\0A\00", align 1
@.str.26.812 = private unnamed_addr constant [19 x i8] c"(null Cfg. desc.)\0A\00", align 1
@.str.30.816 = private unnamed_addr constant [5 x i8] c"Isoc\00", align 1
@.str.29.817 = private unnamed_addr constant [5 x i8] c"Ctrl\00", align 1
@.str.31.818 = private unnamed_addr constant [5 x i8] c"Bulk\00", align 1
@.str.32.819 = private unnamed_addr constant [5 x i8] c"Int.\00", align 1
@format_endpt = internal constant [51 x i8] c"E:  Ad=%02x(%c) Atr=%02x(%-4s) MxPS=%4d Ivl=%d%cs\0A\00", align 16
@.str.28.820 = private unnamed_addr constant [7 x i8] c"(none)\00", align 1
@.str.27.821 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@format_iface = internal constant [75 x i8] c"I:%c If#=%2d Alt=%2d #EPs=%2d Cls=%02x(%-5s) Sub=%02x Prot=%02x Driver=%s\0A\00", align 16
@clas_info = internal constant [18 x %struct.usbdevfs_disconnectsignal] [%struct.usbdevfs_disconnectsignal { i32 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.8.822, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9.823, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.10.824, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11.825, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 5, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12.826, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 6, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13.827, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 7, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.14.828, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 8, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.15.829, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 9, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16.830, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 10, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.17.831, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 11, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.18.832, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 13, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.19.833, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 14, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.20.834, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 224, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.21.835, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 239, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.22.836, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 254, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.23.837, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 255, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.24.838, i32 0, i32 0) }, %struct.usbdevfs_disconnectsignal { i32 -1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.25.839, i32 0, i32 0) }], align 16
@.str.8.822 = private unnamed_addr constant [5 x i8] c">ifc\00", align 1
@.str.9.823 = private unnamed_addr constant [6 x i8] c"audio\00", align 1
@.str.10.824 = private unnamed_addr constant [6 x i8] c"comm.\00", align 1
@.str.11.825 = private unnamed_addr constant [4 x i8] c"HID\00", align 1
@.str.12.826 = private unnamed_addr constant [4 x i8] c"PID\00", align 1
@.str.13.827 = private unnamed_addr constant [6 x i8] c"still\00", align 1
@.str.14.828 = private unnamed_addr constant [6 x i8] c"print\00", align 1
@.str.15.829 = private unnamed_addr constant [6 x i8] c"stor.\00", align 1
@.str.16.830 = private unnamed_addr constant [4 x i8] c"hub\00", align 1
@.str.17.831 = private unnamed_addr constant [5 x i8] c"data\00", align 1
@.str.18.832 = private unnamed_addr constant [6 x i8] c"scard\00", align 1
@.str.19.833 = private unnamed_addr constant [6 x i8] c"c-sec\00", align 1
@.str.20.834 = private unnamed_addr constant [6 x i8] c"video\00", align 1
@.str.21.835 = private unnamed_addr constant [6 x i8] c"wlcon\00", align 1
@.str.22.836 = private unnamed_addr constant [5 x i8] c"misc\00", align 1
@.str.23.837 = private unnamed_addr constant [5 x i8] c"app.\00", align 1
@.str.24.838 = private unnamed_addr constant [6 x i8] c"vend.\00", align 1
@.str.25.839 = private unnamed_addr constant [5 x i8] c"unk.\00", align 1
@format_iad = internal constant [64 x i8] c"A:  FirstIf#=%2d IfCount=%2d Cls=%02x(%-5s) Sub=%02x Prot=%02x\0A\00", align 16
@format_config = internal constant [45 x i8] c"C:%c #Ifs=%2d Cfg#=%2d Atr=%02x MxPwr=%3dmA\0A\00", align 16
@format_string_manufacturer = internal constant [25 x i8] c"S:  Manufacturer=%.100s\0A\00", align 16
@format_string_product = internal constant [20 x i8] c"S:  Product=%.100s\0A\00", align 16
@format_string_serialnumber = internal constant [25 x i8] c"S:  SerialNumber=%.100s\0A\00", align 16
@format_device1 = internal constant [71 x i8] c"D:  Ver=%2x.%02x Cls=%02x(%-5s) Sub=%02x Prot=%02x MxPS=%2d #Cfgs=%3d\0A\00", align 16
@format_device2 = internal constant [42 x i8] c"P:  Vendor=%04x ProdID=%04x Rev=%2x.%02x\0A\00", align 16
@usb_port_device_type = global { i8*, %struct.attribute_group**, i32 (%struct.device.4311*, %struct.kobj_uevent_env*)*, i8* (%struct.device.4311*, i16*, i32*, i32*)*, void (%struct.device.4311*)*, %struct.dev_pm_ops.4310* } { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.842, i32 0, i32 0), %struct.attribute_group** null, i32 (%struct.device.4311*, %struct.kobj_uevent_env*)* null, i8* (%struct.device.4311*, i16*, i32*, i32*)* null, void (%struct.device.4311*)* @usb_port_device_release, %struct.dev_pm_ops.4310* @usb_port_pm_ops }, align 8
@.str.842 = private unnamed_addr constant [9 x i8] c"usb_port\00", align 1
@usb_port_pm_ops = internal constant %struct.dev_pm_ops.4310 { i32 (%struct.device.4311*)* null, void (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* null, i32 (%struct.device.4311*)* @usb_port_runtime_suspend, i32 (%struct.device.4311*)* @usb_port_runtime_resume, i32 (%struct.device.4311*)* @pm_generic_runtime_idle }, align 8
@usb_port_runtime_resume.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.usb_port_runtime_resume, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.4.847, i32 0, i32 0), i8* getelementptr inbounds ([64 x i8], [64 x i8]* @.str.5.844, i32 0, i32 0), i8 98, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.5.844 = private unnamed_addr constant [64 x i8] c"can't get reconnection after setting port  power on, status %d\0A\00", align 1
@__func__.usb_port_runtime_resume = private unnamed_addr constant [24 x i8] c"usb_port_runtime_resume\00", align 1
@.str.4.847 = private unnamed_addr constant [24 x i8] c"drivers/usb/core/port.c\00", align 1
@port_dev_group = internal global [2 x %struct.attribute_group*] [%struct.attribute_group* @port_dev_attr_grp, %struct.attribute_group* null], align 16
@port_dev_attr_grp = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([2 x %struct.attribute*], [2 x %struct.attribute*]* @port_dev_attrs, i32 0, i32 0) }, align 8
@port_dev_attrs = internal global [2 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute.4530, %struct.device_attribute.4530* @dev_attr_connect_type, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_connect_type = internal global %struct.device_attribute.4530 { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6.854, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device.4311*, %struct.device_attribute.4530*, i8*)* @show_port_connect_type, i64 (%struct.device.4311*, %struct.device_attribute.4530*, i8*, i64)* null }, align 8
@.str.6.854 = private unnamed_addr constant [13 x i8] c"connect_type\00", align 1
@.str.10.855 = private unnamed_addr constant [8 x i8] c"unknown\00", align 1
@.str.7.856 = private unnamed_addr constant [8 x i8] c"hotplug\00", align 1
@.str.8.857 = private unnamed_addr constant [10 x i8] c"hardwired\00", align 1
@.str.9.858 = private unnamed_addr constant [9 x i8] c"not used\00", align 1
@.str.11.859 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@usb_hcd_pci_pm_ops = constant %struct.dev_pm_ops { i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*)* @hcd_pci_suspend, i32 (%struct.device*)* @hcd_pci_resume, i32 (%struct.device*)* @check_root_hub_suspended, i32 (%struct.device*)* null, i32 (%struct.device*)* @hcd_pci_suspend, i32 (%struct.device*)* @hcd_pci_restore, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* @hcd_pci_suspend_noirq, i32 (%struct.device*)* @hcd_pci_resume_noirq, i32 (%struct.device*)* @check_root_hub_suspended, i32 (%struct.device*)* null, i32 (%struct.device*)* @hcd_pci_suspend_noirq, i32 (%struct.device*)* @hcd_pci_resume_noirq, i32 (%struct.device*)* @hcd_pci_runtime_suspend, i32 (%struct.device*)* @hcd_pci_runtime_resume, i32 (%struct.device*)* null }, align 8
@hcd_pci_runtime_resume.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.hcd_pci_runtime_resume, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.865, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.25.863, i32 0, i32 0), i8 110, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.25.863 = private unnamed_addr constant [28 x i8] c"hcd_pci_runtime_resume: %d\0A\00", align 1
@__func__.hcd_pci_runtime_resume = private unnamed_addr constant [23 x i8] c"hcd_pci_runtime_resume\00", align 1
@.str.2.865 = private unnamed_addr constant [27 x i8] c"drivers/usb/core/hcd-pci.c\00", align 1
@resume_common.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.resume_common, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.865, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.14.866, i32 0, i32 0), i8 -22, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@.str.14.866 = private unnamed_addr constant [30 x i8] c"can't resume, not suspended!\0A\00", align 1
@.str.15.867 = private unnamed_addr constant [35 x i8] c"can't re-enable after resume, %d!\0A\00", align 1
@.str.16.868 = private unnamed_addr constant [27 x i8] c"PCI post-resume error %d!\0A\00", align 1
@__func__.resume_common = private unnamed_addr constant [14 x i8] c"resume_common\00", align 1
@hcd_pci_runtime_suspend.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.hcd_pci_runtime_suspend, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.865, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.24.869, i32 0, i32 0), i8 100, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.24.869 = private unnamed_addr constant [29 x i8] c"hcd_pci_runtime_suspend: %d\0A\00", align 1
@__func__.hcd_pci_runtime_suspend = private unnamed_addr constant [24 x i8] c"hcd_pci_runtime_suspend\00", align 1
@__func__.suspend_common = private unnamed_addr constant [15 x i8] c"suspend_common\00", align 1
@hcd_pci_suspend_noirq.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.hcd_pci_suspend_noirq, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.865, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.19.871, i32 0, i32 0), i8 39, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.19.871 = private unnamed_addr constant [12 x i8] c"wakeup: %d\0A\00", align 1
@hcd_pci_suspend_noirq.descriptor.20 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.hcd_pci_suspend_noirq, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.865, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.21.872, i32 0, i32 0), i8 46, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.21.872 = private unnamed_addr constant [19 x i8] c"--> PCI D0 legacy\0A\00", align 1
@hcd_pci_suspend_noirq.descriptor.22 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.hcd_pci_suspend_noirq, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.865, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23.873, i32 0, i32 0), i8 50, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.23.873 = private unnamed_addr constant [12 x i8] c"--> PCI %s\0A\00", align 1
@__func__.hcd_pci_suspend_noirq = private unnamed_addr constant [22 x i8] c"hcd_pci_suspend_noirq\00", align 1
@pci_power_names = external global [0 x i8*], align 8
@.str.17.874 = private unnamed_addr constant [27 x i8] c"Root hub is not suspended\0A\00", align 1
@.str.18.875 = private unnamed_addr constant [37 x i8] c"Secondary root hub is not suspended\0A\00", align 1
@__kcrctab_usb_hcd_pci_probe = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_pci_probe to i64), section "___kcrctab_gpl+usb_hcd_pci_probe", align 8
@__ksymtab_usb_hcd_pci_probe = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.pci_dev*, %struct.pci_device_id*)* @usb_hcd_pci_probe to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_usb_hcd_pci_probe, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_pci_probe", align 8
@__kcrctab_usb_hcd_pci_remove = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_pci_remove to i64), section "___kcrctab_gpl+usb_hcd_pci_remove", align 8
@__ksymtab_usb_hcd_pci_remove = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.pci_dev*)* @usb_hcd_pci_remove to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_hcd_pci_remove, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_pci_remove", align 8
@__kcrctab_usb_hcd_pci_shutdown = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_pci_shutdown to i64), section "___kcrctab_gpl+usb_hcd_pci_shutdown", align 8
@__ksymtab_usb_hcd_pci_shutdown = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.pci_dev*)* @usb_hcd_pci_shutdown to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_usb_hcd_pci_shutdown, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_pci_shutdown", align 8
@__kcrctab_usb_hcd_pci_pm_ops = internal constant i64 ptrtoint (i8** @__crc_usb_hcd_pci_pm_ops to i64), section "___kcrctab_gpl+usb_hcd_pci_pm_ops", align 8
@__ksymtab_usb_hcd_pci_pm_ops = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.dev_pm_ops* @usb_hcd_pci_pm_ops to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_usb_hcd_pci_pm_ops, i32 0, i32 0) }, section "___ksymtab_gpl+usb_hcd_pci_pm_ops", align 8
@__kstrtab_usb_hcd_pci_pm_ops = internal constant [19 x i8] c"usb_hcd_pci_pm_ops\00", section "__ksymtab_strings", align 1
@__crc_usb_hcd_pci_pm_ops = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_pci_shutdown = internal constant [21 x i8] c"usb_hcd_pci_shutdown\00", section "__ksymtab_strings", align 1
@__crc_usb_hcd_pci_shutdown = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_pci_remove = internal constant [19 x i8] c"usb_hcd_pci_remove\00", section "__ksymtab_strings", align 1
@companions_rwsem = internal global %struct.rw_semaphore { i64 0, %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.10.879, i32 0, i32 0), i32 0, i64 0 } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rw_semaphore* @companions_rwsem to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rw_semaphore* @companions_rwsem to i8*), i64 80) to %struct.list_head*) }, %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.11.880, i32 0, i32 0), i32 0, i64 0 } }, align 8
@iomem_resource = external global %struct.resource, align 8
@ioport_resource = external global %struct.resource, align 8
@.str.10.879 = private unnamed_addr constant [27 x i8] c"companions_rwsem.wait_lock\00", align 1
@.str.11.880 = private unnamed_addr constant [17 x i8] c"companions_rwsem\00", align 1
@.str.9.881 = private unnamed_addr constant [60 x i8] c"/diffkemp/kernel/linux-3.10/arch/x86/include/asm/paravirt.h\00", align 1
@__crc_usb_hcd_pci_remove = extern_weak global i8*, align 8
@__kstrtab_usb_hcd_pci_probe = internal constant [18 x i8] c"usb_hcd_pci_probe\00", section "__ksymtab_strings", align 1
@.str.883 = private unnamed_addr constant [48 x i8] c"Found HC with no IRQ. Check BIOS/PCI %s setup!\0A\00", align 1
@usb_hcd_pci_probe.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.usb_hcd_pci_probe, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.865, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3.884, i32 0, i32 0), i8 -34, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.3.884 = private unnamed_addr constant [27 x i8] c"controller already in use\0A\00", align 1
@usb_hcd_pci_probe.descriptor.4 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.usb_hcd_pci_probe, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.865, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5.885, i32 0, i32 0), i8 -28, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.5.885 = private unnamed_addr constant [22 x i8] c"error mapping memory\0A\00", align 1
@usb_hcd_pci_probe.descriptor.6 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.usb_hcd_pci_probe, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.865, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7.886, i32 0, i32 0), i8 -7, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.7.886 = private unnamed_addr constant [26 x i8] c"no i/o regions available\0A\00", align 1
@.str.8.888 = private unnamed_addr constant [18 x i8] c"init %s fail, %d\0A\00", align 1
@non_ehci_add.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__func__.non_ehci_add, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.865, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.13.894, i32 0, i32 0), i8 -123, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.13.894 = private unnamed_addr constant [24 x i8] c"FS/LS companion for %s\0A\00", align 1
@__func__.non_ehci_add = private unnamed_addr constant [13 x i8] c"non_ehci_add\00", align 1
@ehci_post_add.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.ehci_post_add, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.2.865, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.12.896, i32 0, i32 0), i8 115, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.12.896 = private unnamed_addr constant [21 x i8] c"HS companion for %s\0A\00", align 1
@__func__.ehci_post_add = private unnamed_addr constant [14 x i8] c"ehci_post_add\00", align 1
@__func__.usb_hcd_pci_probe = private unnamed_addr constant [18 x i8] c"usb_hcd_pci_probe\00", align 1
@__crc_usb_hcd_pci_probe = extern_weak global i8*, align 8
@__kcrctab_usb_acpi_power_manageable = internal constant i64 ptrtoint (i8** @__crc_usb_acpi_power_manageable to i64), section "___kcrctab_gpl+usb_acpi_power_manageable", align 8
@__ksymtab_usb_acpi_power_manageable = internal constant %struct.kernel_symbol { i64 ptrtoint (i1 (%struct.usb_device*, i32)* @usb_acpi_power_manageable to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_usb_acpi_power_manageable, i32 0, i32 0) }, section "___ksymtab_gpl+usb_acpi_power_manageable", align 8
@__kcrctab_usb_acpi_set_power_state = internal constant i64 ptrtoint (i8** @__crc_usb_acpi_set_power_state to i64), section "___kcrctab_gpl+usb_acpi_set_power_state", align 8
@__ksymtab_usb_acpi_set_power_state = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.usb_device*, i32, i1)* @usb_acpi_set_power_state to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_usb_acpi_set_power_state, i32 0, i32 0) }, section "___ksymtab_gpl+usb_acpi_set_power_state", align 8
@__kstrtab_usb_acpi_set_power_state = internal constant [25 x i8] c"usb_acpi_set_power_state\00", section "__ksymtab_strings", align 1
@usb_acpi_set_power_state.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.usb_acpi_set_power_state, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.1.903, i32 0, i32 0), i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.2.900, i32 0, i32 0), i8 77, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.2.900 = private unnamed_addr constant [40 x i8] c"The power of hub port %d was set to %d\0A\00", align 1
@usb_acpi_set_power_state.descriptor.3 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.usb_acpi_set_power_state, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.1.903, i32 0, i32 0), i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.4.901, i32 0, i32 0), i8 79, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.4.901 = private unnamed_addr constant [40 x i8] c"The power of hub port failed to be set\0A\00", align 1
@.str.902 = private unnamed_addr constant [8 x i8] c"usbcore\00", align 1
@__func__.usb_acpi_set_power_state = private unnamed_addr constant [25 x i8] c"usb_acpi_set_power_state\00", align 1
@.str.1.903 = private unnamed_addr constant [28 x i8] c"drivers/usb/core/usb-acpi.c\00", align 1
@__crc_usb_acpi_set_power_state = extern_weak global i8*, align 8
@__kstrtab_usb_acpi_power_manageable = internal constant [26 x i8] c"usb_acpi_power_manageable\00", section "__ksymtab_strings", align 1
@__crc_usb_acpi_power_manageable = extern_weak global i8*, align 8
@usb_acpi_bus = internal global %struct.acpi_bus_type { %struct.list_head zeroinitializer, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6.906, i32 0, i32 0), i1 (%struct.device*)* @usb_acpi_bus_match, i32 (%struct.device*, i8**)* @usb_acpi_find_device, void (%struct.device*)* null, void (%struct.device*)* null }, align 8
@.str.6.906 = private unnamed_addr constant [4 x i8] c"USB\00", align 1
@.str.7.909 = private unnamed_addr constant [7 x i8] c"port%d\00", align 1
@usb_acpi_check_port_connect_type.buffer = private unnamed_addr constant %struct.kernel_symbol { i64 -1, i8* null }, align 8
@.str.8.911 = private unnamed_addr constant [5 x i8] c"_UPC\00", align 1

@init_module = alias i32 (), i32 ()* @usb_init
@cleanup_module = alias void (), void ()* @usb_exit
@__mod_usb_device_table = alias %struct.usb_device_id, getelementptr inbounds ([4 x %struct.usb_device_id], [4 x %struct.usb_device_id]* @hub_id_table, i32 0, i32 0)

; Function Attrs: nounwind uwtable
define internal i32 @usb_dev_uevent(%struct.device* %dev, %struct.kobj_uevent_env* %env) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %busnum = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %2, i32 0, i32 1
  %3 = load i32, i32* %busnum, align 8, !tbaa !35
  %call = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.9, i32 0, i32 0), i32 %3)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 0
  %4 = load i32, i32* %devnum, align 8, !tbaa !38
  %call1 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.10, i32 0, i32 0), i32 %4)
  %tobool2 = icmp ne i32 %call1, 0
  %. = select i1 %tobool2, i32 -12, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ -12, %entry ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_devnode(%struct.device* %dev, i16* %mode, i32* %uid, i32* %gid) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %busnum = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %2, i32 0, i32 1
  %3 = load i32, i32* %busnum, align 8, !tbaa !35
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 0
  %4 = load i32, i32* %devnum, align 8, !tbaa !38
  %call = call i8* (i32, i8*, ...) @kasprintf(i32 208, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.11, i32 0, i32 0), i32 %3, i32 %4)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define internal void @usb_release_dev(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd(%struct.usb_bus* %2)
  call void @usb_destroy_configuration(%struct.usb_device* %1)
  call void @usb_release_bos_descriptor(%struct.usb_device* %1)
  call void bitcast (void (%struct.usb_hcd.588*)* @usb_put_hcd to void (%struct.usb_hcd*)*)(%struct.usb_hcd* %call)
  %product = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 24
  %3 = load i8*, i8** %product, align 8, !tbaa !39
  call void @kfree(i8* %3)
  %manufacturer = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 25
  %4 = load i8*, i8** %manufacturer, align 8, !tbaa !40
  call void @kfree(i8* %4)
  %serial = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 26
  %5 = load i8*, i8** %serial, align 8, !tbaa !41
  call void @kfree(i8* %5)
  %6 = bitcast %struct.usb_device* %1 to i8*
  call void @kfree(i8* %6)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_dev_prepare(%struct.device* %dev) #0 {
entry:
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @usb_dev_complete(%struct.device* %dev) #0 {
entry:
  %call = call i32 @usb_resume_complete(%struct.device* %dev)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_dev_suspend(%struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %union.anon.5, align 4
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  store i32 2, i32* %event, align 4, !tbaa !42
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  %0 = load i32, i32* %coerce.dive, align 4
  %call = call i32 @usb_suspend(%struct.device* %dev, i32 %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_dev_resume(%struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %union.anon.5, align 4
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  store i32 16, i32* %event, align 4, !tbaa !42
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  %0 = load i32, i32* %coerce.dive, align 4
  %call = call i32 @usb_resume(%struct.device* %dev, i32 %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_dev_freeze(%struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %union.anon.5, align 4
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  store i32 1, i32* %event, align 4, !tbaa !42
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  %0 = load i32, i32* %coerce.dive, align 4
  %call = call i32 @usb_suspend(%struct.device* %dev, i32 %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_dev_thaw(%struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %union.anon.5, align 4
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  store i32 32, i32* %event, align 4, !tbaa !42
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  %0 = load i32, i32* %coerce.dive, align 4
  %call = call i32 @usb_resume(%struct.device* %dev, i32 %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_dev_poweroff(%struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %union.anon.5, align 4
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  store i32 4, i32* %event, align 4, !tbaa !42
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  %0 = load i32, i32* %coerce.dive, align 4
  %call = call i32 @usb_suspend(%struct.device* %dev, i32 %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_dev_restore(%struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %union.anon.5, align 4
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  store i32 64, i32* %event, align 4, !tbaa !42
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  %0 = load i32, i32* %coerce.dive, align 4
  %call = call i32 @usb_resume(%struct.device* %dev, i32 %0)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd* @bus_to_hcd(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd*
  ret %struct.usb_hcd* %1
}

declare void @kfree(i8*) #2

declare i8* @kasprintf(i32, i8*, ...) #2

declare i32 @add_uevent_var(%struct.kobj_uevent_env*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define i32 @usb_disabled() #0 {
entry:
  %0 = load i8, i8* @nousb, align 1, !tbaa !43, !range !44
  %tobool = trunc i8 %0 to i1
  %conv = zext i1 %tobool to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define void @usb_free_coherent(%struct.usb_device* %dev, i64 %size, i8* %addr, i64 %dma) #0 {
entry:
  %tobool = icmp ne %struct.usb_device* %dev, null
  br i1 %tobool, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %entry
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %tobool1 = icmp ne %struct.usb_bus* %0, null
  %tobool2 = icmp ne i8* %addr, null
  %or.cond = and i1 %tobool1, %tobool2
  br i1 %or.cond, label %if.end4, label %return

if.end4:                                          ; preds = %lor.lhs.false
  %bus5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus5, align 8, !tbaa !2
  call void @hcd_buffer_free(%struct.usb_bus* %1, i64 %size, i8* %addr, i64 %dma)
  br label %return

return:                                           ; preds = %if.end4, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @usb_alloc_coherent(%struct.usb_device* %dev, i64 %size, i32 %mem_flags, i64* %dma) #0 {
entry:
  %tobool = icmp ne %struct.usb_device* %dev, null
  br i1 %tobool, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %entry
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %tobool1 = icmp ne %struct.usb_bus* %0, null
  br i1 %tobool1, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  %bus2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus2, align 8, !tbaa !2
  %call = call i8* @hcd_buffer_alloc(%struct.usb_bus* %1, i64 %size, i32 %mem_flags, i64* %dma)
  br label %return

return:                                           ; preds = %if.end, %lor.lhs.false, %entry
  %retval.0 = phi i8* [ %call, %if.end ], [ null, %lor.lhs.false ], [ null, %entry ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @__usb_get_extra_descriptor(i8* %buffer, i32 %size, i8 zeroext %type, i8** %ptr) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %if.end14, %entry
  %size.addr.0 = phi i32 [ %size, %entry ], [ %sub, %if.end14 ]
  %buffer.addr.0 = phi i8* [ %buffer, %entry ], [ %add.ptr, %if.end14 ]
  %conv = zext i32 %size.addr.0 to i64
  %cmp = icmp uge i64 %conv, 2
  br i1 %cmp, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %0 = bitcast i8* %buffer.addr.0 to %struct.usb_descriptor_header*
  %bLength = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %0, i32 0, i32 0
  %1 = load i8, i8* %bLength, align 1, !tbaa !45
  %conv2 = zext i8 %1 to i32
  %cmp3 = icmp slt i32 %conv2, 2
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %while.body
  %bDescriptorType8 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %0, i32 0, i32 1
  %3 = load i8, i8* %bDescriptorType8, align 1, !tbaa !47
  %conv9 = zext i8 %3 to i32
  %conv10 = zext i8 %type to i32
  %cmp11 = icmp eq i32 %conv9, %conv10
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end
  %4 = bitcast %struct.usb_descriptor_header* %0 to i8*
  store i8* %4, i8** %ptr, align 8, !tbaa !48
  br label %cleanup

if.end14:                                         ; preds = %if.end
  %bLength15 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %0, i32 0, i32 0
  %5 = load i8, i8* %bLength15, align 1, !tbaa !45
  %conv16 = zext i8 %5 to i32
  %idx.ext = sext i32 %conv16 to i64
  %add.ptr = getelementptr inbounds i8, i8* %buffer.addr.0, i64 %idx.ext
  %bLength17 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %0, i32 0, i32 0
  %6 = load i8, i8* %bLength17, align 1, !tbaa !45
  %conv18 = zext i8 %6 to i32
  %sub = sub i32 %size.addr.0, %conv18
  br label %while.cond

cleanup:                                          ; preds = %if.then13, %if.then, %while.cond
  %retval.0 = phi i32 [ -1, %if.then ], [ 0, %if.then13 ], [ -1, %while.cond ]
  ret i32 %retval.0
}

declare i32 @printk(i8*, ...) #2

; Function Attrs: nounwind uwtable
define i32 @usb_get_current_frame_number(%struct.usb_device* %dev) #0 {
entry:
  %call = call i32 @usb_hcd_get_frame_number(%struct.usb_device* %dev)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @usb_lock_device_for_reset(%struct.usb_device* %udev, %struct.usb_interface* %iface) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy14 = alloca i64, align 8
  %__dummy215 = alloca i64, align 8
  %0 = load volatile i64, i64* @jiffies, align 8, !tbaa !49
  %add = add i64 %0, 250
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %state1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %2 = load i32, i32* %state1, align 8, !tbaa !50
  %cmp2 = icmp eq i32 %2, 8
  br i1 %cmp2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %tobool = icmp ne %struct.usb_interface* %iface, null
  br i1 %tobool, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %if.end4
  %condition = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 5
  %3 = load i32, i32* %condition, align 4, !tbaa !51
  %cmp5 = icmp eq i32 %3, 3
  br i1 %cmp5, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %condition6 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 5
  %4 = load i32, i32* %condition6, align 4, !tbaa !51
  %cmp7 = icmp eq i32 %4, 0
  br i1 %cmp7, label %cleanup, label %if.end9

if.end9:                                          ; preds = %lor.lhs.false, %if.end4
  br label %while.cond

while.cond:                                       ; preds = %if.end45, %if.end9
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call = call i32 @device_trylock(%struct.device* %dev)
  %tobool10 = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool10, true
  br i1 %lnot, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %5 = bitcast i64* %__dummy to i8*
  %6 = bitcast i64* %__dummy2 to i8*
  %7 = bitcast i64* %__dummy2 to i8*
  %8 = bitcast i64* %__dummy to i8*
  %tobool12 = icmp ne i32 1, 0
  br i1 %tobool12, label %land.lhs.true13, label %if.end24

land.lhs.true13:                                  ; preds = %while.body
  %9 = bitcast i64* %__dummy14 to i8*
  %10 = bitcast i64* %__dummy215 to i8*
  %11 = bitcast i64* %__dummy215 to i8*
  %12 = bitcast i64* %__dummy14 to i8*
  %13 = load volatile i64, i64* @jiffies, align 8, !tbaa !49
  %sub = sub nsw i64 %add, %13
  %cmp21 = icmp slt i64 %sub, 0
  br i1 %cmp21, label %cleanup, label %if.end24

if.end24:                                         ; preds = %land.lhs.true13, %while.body
  call void @msleep(i32 15)
  %state25 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %14 = load i32, i32* %state25, align 8, !tbaa !50
  %cmp26 = icmp eq i32 %14, 0
  br i1 %cmp26, label %cleanup, label %if.end29

if.end29:                                         ; preds = %if.end24
  %state30 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %15 = load i32, i32* %state30, align 8, !tbaa !50
  %cmp31 = icmp eq i32 %15, 8
  br i1 %cmp31, label %cleanup, label %if.end34

if.end34:                                         ; preds = %if.end29
  %tobool35 = icmp ne %struct.usb_interface* %iface, null
  br i1 %tobool35, label %land.lhs.true36, label %if.end45

land.lhs.true36:                                  ; preds = %if.end34
  %condition37 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 5
  %16 = load i32, i32* %condition37, align 4, !tbaa !51
  %cmp38 = icmp eq i32 %16, 3
  br i1 %cmp38, label %cleanup, label %lor.lhs.false40

lor.lhs.false40:                                  ; preds = %land.lhs.true36
  %condition41 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 5
  %17 = load i32, i32* %condition41, align 4, !tbaa !51
  %cmp42 = icmp eq i32 %17, 0
  br i1 %cmp42, label %cleanup, label %if.end45

if.end45:                                         ; preds = %lor.lhs.false40, %if.end34
  br label %while.cond

cleanup:                                          ; preds = %lor.lhs.false40, %land.lhs.true36, %if.end29, %if.end24, %land.lhs.true13, %while.cond, %lor.lhs.false, %land.lhs.true, %if.end, %entry
  %retval.0 = phi i32 [ -19, %entry ], [ -113, %if.end ], [ -4, %lor.lhs.false ], [ -4, %land.lhs.true ], [ -16, %land.lhs.true13 ], [ -19, %if.end24 ], [ -113, %if.end29 ], [ -4, %lor.lhs.false40 ], [ -4, %land.lhs.true36 ], [ 0, %while.cond ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @device_trylock(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  %call = call i32 @mutex_trylock(%struct.mutex* %mutex)
  ret i32 %call
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #3

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #3

declare void @msleep(i32) #2

declare i32 @mutex_trylock(%struct.mutex*) #2

; Function Attrs: nounwind uwtable
define void @usb_put_intf(%struct.usb_interface* %intf) #0 {
entry:
  %tobool = icmp ne %struct.usb_interface* %intf, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @put_device(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @put_device(%struct.device*) #2

; Function Attrs: nounwind uwtable
define %struct.usb_interface* @usb_get_intf(%struct.usb_interface* %intf) #0 {
entry:
  %tobool = icmp ne %struct.usb_interface* %intf, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call %struct.device* @get_device(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.usb_interface* %intf
}

declare %struct.device* @get_device(%struct.device*) #2

; Function Attrs: nounwind uwtable
define void @usb_put_dev(%struct.usb_device* %dev) #0 {
entry:
  %tobool = icmp ne %struct.usb_device* %dev, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  call void @put_device(%struct.device* %dev1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.usb_device* @usb_get_dev(%struct.usb_device* %dev) #0 {
entry:
  %tobool = icmp ne %struct.usb_device* %dev, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %call = call %struct.device* @get_device(%struct.device* %dev1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.usb_device* %dev
}

; Function Attrs: nounwind uwtable
define %struct.usb_interface* @usb_find_interface(%struct.usb_driver* %drv, i32 %minor) #0 {
entry:
  %argb = alloca %struct.find_interface_arg, align 8
  %0 = bitcast %struct.find_interface_arg* %argb to i8*
  %minor1 = getelementptr inbounds %struct.find_interface_arg, %struct.find_interface_arg* %argb, i32 0, i32 0
  store i32 %minor, i32* %minor1, align 8, !tbaa !53
  %drvwrap = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %drv, i32 0, i32 11
  %driver = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 0
  %drv2 = getelementptr inbounds %struct.find_interface_arg, %struct.find_interface_arg* %argb, i32 0, i32 1
  store %struct.device_driver* %driver, %struct.device_driver** %drv2, align 8, !tbaa !55
  %1 = bitcast %struct.find_interface_arg* %argb to i8*
  %call = call %struct.device* @bus_find_device(%struct.bus_type* @usb_bus_type, %struct.device* null, i8* %1, i32 (%struct.device*, i8*)* @__find_interface)
  call void @put_device(%struct.device* %call)
  %tobool = icmp ne %struct.device* %call, null
  %2 = bitcast %struct.device* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -48
  %3 = bitcast i8* %add.ptr to %struct.usb_interface*
  %cond = select i1 %tobool, %struct.usb_interface* %3, %struct.usb_interface* null
  %4 = bitcast %struct.find_interface_arg* %argb to i8*
  ret %struct.usb_interface* %cond
}

; Function Attrs: nounwind uwtable
define internal i32 @__find_interface(%struct.device* %dev, i8* %data) #0 {
entry:
  %0 = bitcast i8* %data to %struct.find_interface_arg*
  %call = call i32 @is_usb_interface(%struct.device* %dev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %1 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !56
  %drv = getelementptr inbounds %struct.find_interface_arg, %struct.find_interface_arg* %0, i32 0, i32 1
  %2 = load %struct.device_driver*, %struct.device_driver** %drv, align 8, !tbaa !55
  %cmp = icmp ne %struct.device_driver* %1, %2
  br i1 %cmp, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -48
  %4 = bitcast i8* %add.ptr to %struct.usb_interface*
  %minor = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 4
  %5 = load i32, i32* %minor, align 8, !tbaa !57
  %minor3 = getelementptr inbounds %struct.find_interface_arg, %struct.find_interface_arg* %0, i32 0, i32 0
  %6 = load i32, i32* %minor3, align 8, !tbaa !53
  %cmp4 = icmp eq i32 %5, %6
  %conv = zext i1 %cmp4 to i32
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i32 [ %conv, %if.end2 ], [ 0, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare %struct.device* @bus_find_device(%struct.bus_type*, %struct.device*, i8*, i32 (%struct.device*, i8*)*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_usb_interface(%struct.device* %dev) #1 {
entry:
  %type = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 4
  %0 = load %struct.device_type*, %struct.device_type** %type, align 8, !tbaa !58
  %cmp = icmp eq %struct.device_type* %0, @usb_if_device_type
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define %struct.usb_host_interface* @usb_altnum_to_altsetting(%struct.usb_interface* %intf, i32 %altnum) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %num_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 2
  %0 = load i32, i32* %num_altsetting, align 8, !tbaa !59
  %cmp = icmp ult i32 %i.0, %0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 0
  %1 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !60
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i64 %idxprom
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bAlternateSetting = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 3
  %2 = load i8, i8* %bAlternateSetting, align 1, !tbaa !61
  %conv = zext i8 %2 to i32
  %cmp1 = icmp eq i32 %conv, %altnum
  br i1 %cmp1, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %altsetting3 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 0
  %3 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting3, align 8, !tbaa !60
  %idxprom4 = sext i32 %i.0 to i64
  %arrayidx5 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %3, i64 %idxprom4
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond
  %retval.0 = phi %struct.usb_host_interface* [ %arrayidx5, %if.then ], [ null, %for.cond ]
  ret %struct.usb_host_interface* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %dev, i32 %ifnum) #0 {
entry:
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %1 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %2 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !48
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %2, i32 0, i32 0
  %3 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !60
  %arrayidx2 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %3, i64 0
  %desc3 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx2, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc3, i32 0, i32 2
  %4 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !68
  %conv4 = zext i8 %4 to i32
  %cmp5 = icmp eq i32 %conv4, %ifnum
  br i1 %cmp5, label %if.then7, label %for.inc

if.then7:                                         ; preds = %for.body
  %interface8 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 3
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface8, i64 0, i64 %idxprom9
  %5 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx10, align 8, !tbaa !48
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.then7, %for.cond, %entry
  %retval.0 = phi %struct.usb_interface* [ %5, %if.then7 ], [ null, %entry ], [ null, %for.cond ]
  ret %struct.usb_interface* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.usb_host_interface* @usb_find_alt_setting(%struct.usb_host_config* %config, i32 %iface_num, i32 %alt_num) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %0 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv = zext i8 %0 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %intf_cache2 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 4
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache2, i64 0, i64 %idxprom
  %1 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx, align 8, !tbaa !48
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %1, i32 0, i32 2
  %arrayidx3 = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i64 0, i64 0
  %desc4 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx3, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc4, i32 0, i32 2
  %2 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !68
  %conv5 = zext i8 %2 to i32
  %cmp6 = icmp eq i32 %conv5, %iface_num
  br i1 %cmp6, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %intf_cache8 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 4
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache8, i64 0, i64 %idxprom9
  %3 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx10, align 8, !tbaa !48
  br label %for.end

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %intf_cache.0 = phi %struct.usb_interface_cache* [ %3, %if.then ], [ null, %for.cond ]
  %tobool = icmp ne %struct.usb_interface_cache* %intf_cache.0, null
  br i1 %tobool, label %if.end12, label %cleanup

if.end12:                                         ; preds = %for.end
  br label %for.cond13

for.cond13:                                       ; preds = %for.inc29, %if.end12
  %i.1 = phi i32 [ 0, %if.end12 ], [ %inc30, %for.inc29 ]
  %num_altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intf_cache.0, i32 0, i32 0
  %4 = load i32, i32* %num_altsetting, align 8, !tbaa !69
  %cmp14 = icmp ult i32 %i.1, %4
  br i1 %cmp14, label %for.body16, label %for.end31

for.body16:                                       ; preds = %for.cond13
  %altsetting17 = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intf_cache.0, i32 0, i32 2
  %idxprom18 = sext i32 %i.1 to i64
  %arrayidx19 = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting17, i64 0, i64 %idxprom18
  %desc20 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx19, i32 0, i32 0
  %bAlternateSetting = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc20, i32 0, i32 3
  %5 = load i8, i8* %bAlternateSetting, align 1, !tbaa !61
  %conv21 = zext i8 %5 to i32
  %cmp22 = icmp eq i32 %conv21, %alt_num
  br i1 %cmp22, label %if.then24, label %for.inc29

if.then24:                                        ; preds = %for.body16
  %altsetting25 = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intf_cache.0, i32 0, i32 2
  %idxprom26 = sext i32 %i.1 to i64
  %arrayidx27 = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting25, i64 0, i64 %idxprom26
  br label %cleanup

for.inc29:                                        ; preds = %for.body16
  %inc30 = add nsw i32 %i.1, 1
  br label %for.cond13

for.end31:                                        ; preds = %for.cond13
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %for.end31, %if.then24, %for.end
  %retval.0 = phi %struct.usb_host_interface* [ %arrayidx27, %if.then24 ], [ null, %for.end31 ], [ null, %for.end ]
  ret %struct.usb_host_interface* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.usb_device* @usb_alloc_dev(%struct.usb_device* %parent, %struct.usb_bus* %bus, i32 %port1) #0 {
entry:
  %call = call %struct.usb_hcd* @bus_to_hcd(%struct.usb_bus* %bus)
  %call1 = call i8* @kzalloc(i64 1736, i32 208)
  %0 = bitcast i8* %call1 to %struct.usb_device*
  %tobool = icmp ne %struct.usb_device* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call2 = call %struct.usb_hcd* bitcast (%struct.usb_hcd.588* (%struct.usb_hcd.588*)* @usb_get_hcd to %struct.usb_hcd* (%struct.usb_hcd*)*)(%struct.usb_hcd* %call)
  %tobool3 = icmp ne %struct.usb_hcd* %call2, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  %1 = bitcast %struct.usb_device* %0 to i8*
  call void @kfree(i8* %1)
  br label %cleanup

if.end5:                                          ; preds = %if.end
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %2 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %alloc_dev = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %2, i32 0, i32 26
  %3 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %alloc_dev, align 8, !tbaa !73
  %tobool6 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*)* %3, null
  %tobool7 = icmp ne %struct.usb_device* %parent, null
  %or.cond = and i1 %tobool6, %tobool7
  br i1 %or.cond, label %land.lhs.true8, label %if.end15

land.lhs.true8:                                   ; preds = %if.end5
  %driver9 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %4 = load %struct.hc_driver*, %struct.hc_driver** %driver9, align 8, !tbaa !71
  %alloc_dev10 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %4, i32 0, i32 26
  %5 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %alloc_dev10, align 8, !tbaa !73
  %call11 = call i32 %5(%struct.usb_hcd* %call, %struct.usb_device* %0)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.end15, label %if.then13

if.then13:                                        ; preds = %land.lhs.true8
  %call14 = call %struct.usb_hcd* @bus_to_hcd(%struct.usb_bus* %bus)
  call void bitcast (void (%struct.usb_hcd.588*)* @usb_put_hcd to void (%struct.usb_hcd*)*)(%struct.usb_hcd* %call14)
  %6 = bitcast %struct.usb_device* %0 to i8*
  call void @kfree(i8* %6)
  br label %cleanup

if.end15:                                         ; preds = %land.lhs.true8, %if.end5
  %dev16 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_initialize(%struct.device* %dev16)
  %dev17 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %bus18 = getelementptr inbounds %struct.device, %struct.device* %dev17, i32 0, i32 6
  store %struct.bus_type* @usb_bus_type, %struct.bus_type** %bus18, align 8, !tbaa !75
  %dev19 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %type = getelementptr inbounds %struct.device, %struct.device* %dev19, i32 0, i32 4
  store %struct.device_type* @usb_device_type, %struct.device_type** %type, align 8, !tbaa !76
  %dev20 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %groups = getelementptr inbounds %struct.device, %struct.device* %dev20, i32 0, i32 26
  store %struct.attribute_group** getelementptr inbounds ([3 x %struct.attribute_group*], [3 x %struct.attribute_group*]* @usb_device_groups, i32 0, i32 0), %struct.attribute_group*** %groups, align 8, !tbaa !77
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 0
  %7 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !78
  %dma_mask = getelementptr inbounds %struct.device, %struct.device* %7, i32 0, i32 12
  %8 = load i64*, i64** %dma_mask, align 8, !tbaa !79
  %dev21 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %dma_mask22 = getelementptr inbounds %struct.device, %struct.device* %dev21, i32 0, i32 12
  store i64* %8, i64** %dma_mask22, align 8, !tbaa !80
  %dev23 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %controller24 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 0
  %9 = load %struct.device*, %struct.device** %controller24, align 8, !tbaa !78
  %call25 = call i32 @dev_to_node(%struct.device* %9)
  call void @set_dev_node(%struct.device* %dev23, i32 %call25)
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 3
  store i32 1, i32* %state, align 8, !tbaa !50
  %lpm_disable_count = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 39
  store i32 1, i32* %lpm_disable_count, align 8, !tbaa !81
  %urbnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 30
  call void @atomic_set(%union.anon.5* %urbnum, i32 0)
  %ep0 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 10
  %urb_list = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep0, i32 0, i32 3
  call void @INIT_LIST_HEAD(%struct.list_head* %urb_list)
  %ep026 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 10
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep026, i32 0, i32 0
  %bLength = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc, i32 0, i32 0
  store i8 7, i8* %bLength, align 8, !tbaa !82
  %ep027 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 10
  %desc28 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep027, i32 0, i32 0
  %bDescriptorType = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc28, i32 0, i32 1
  store i8 5, i8* %bDescriptorType, align 1, !tbaa !83
  %ep029 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 10
  call void @usb_enable_endpoint(%struct.usb_device* %0, %struct.usb_host_endpoint* %ep029, i1 zeroext false)
  %can_submit = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 22
  %bf.load = load i16, i16* %can_submit, align 4
  %bf.clear = and i16 %bf.load, -2
  %bf.set = or i16 %bf.clear, 1
  store i16 %bf.set, i16* %can_submit, align 4
  %tobool30 = icmp ne %struct.usb_device* %parent, null
  %lnot = xor i1 %tobool30, true
  %lnot31 = xor i1 %lnot, true
  %lnot32 = xor i1 %lnot31, true
  %lnot.ext = zext i1 %lnot32 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool33 = icmp ne i64 %expval, 0
  br i1 %tobool33, label %if.then34, label %if.else

if.then34:                                        ; preds = %if.end15
  %devpath = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 1
  %arrayidx = getelementptr inbounds [16 x i8], [16 x i8]* %devpath, i64 0, i64 0
  store i8 48, i8* %arrayidx, align 4, !tbaa !84
  %route = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 2
  store i32 0, i32* %route, align 4, !tbaa !85
  %controller35 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 0
  %10 = load %struct.device*, %struct.device** %controller35, align 8, !tbaa !78
  %dev36 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %parent37 = getelementptr inbounds %struct.device, %struct.device* %dev36, i32 0, i32 0
  store %struct.device* %10, %struct.device** %parent37, align 8, !tbaa !86
  %dev38 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %busnum = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 1
  %11 = load i32, i32* %busnum, align 8, !tbaa !35
  %call39 = call i32 (%struct.device*, i8*, ...) @dev_set_name(%struct.device* %dev38, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0), i32 %11)
  br label %if.end79

if.else:                                          ; preds = %if.end15
  %devpath40 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %parent, i32 0, i32 1
  %arrayidx41 = getelementptr inbounds [16 x i8], [16 x i8]* %devpath40, i64 0, i64 0
  %12 = load i8, i8* %arrayidx41, align 4, !tbaa !84
  %conv42 = sext i8 %12 to i32
  %cmp = icmp eq i32 %conv42, 48
  %devpath45 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %devpath45, i32 0, i32 0
  br i1 %cmp, label %if.then44, label %if.else48

if.then44:                                        ; preds = %if.else
  %call46 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 16, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.7.545, i32 0, i32 0), i32 %port1)
  br label %if.end70

if.else48:                                        ; preds = %if.else
  %devpath51 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %parent, i32 0, i32 1
  %arraydecay52 = getelementptr inbounds [16 x i8], [16 x i8]* %devpath51, i32 0, i32 0
  %call53 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 16, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0), i8* %arraydecay52, i32 %port1)
  %cmp54 = icmp ult i32 %port1, 15
  %route57 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %parent, i32 0, i32 2
  %13 = load i32, i32* %route57, align 4, !tbaa !85
  %level = getelementptr inbounds %struct.usb_device, %struct.usb_device* %parent, i32 0, i32 21
  %14 = load i8, i8* %level, align 1, !tbaa !87
  %conv58 = zext i8 %14 to i32
  %sub = sub nsw i32 %conv58, 1
  %mul = mul nsw i32 %sub, 4
  %.sink = select i1 %cmp54, i32 %port1, i32 15
  %shl66 = shl i32 %.sink, %mul
  %add67 = add i32 %13, %shl66
  br label %if.end70

if.end70:                                         ; preds = %if.else48, %if.then44
  %add67.sink = phi i32 [ %add67, %if.else48 ], [ 0, %if.then44 ]
  %route68 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 2
  store i32 %add67.sink, i32* %route68, align 4, !tbaa !85
  %dev71 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %parent, i32 0, i32 11
  %dev72 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %parent73 = getelementptr inbounds %struct.device, %struct.device* %dev72, i32 0, i32 0
  store %struct.device* %dev71, %struct.device** %parent73, align 8, !tbaa !86
  %dev74 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %busnum75 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 1
  %15 = load i32, i32* %busnum75, align 8, !tbaa !35
  %devpath76 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 1
  %arraydecay77 = getelementptr inbounds [16 x i8], [16 x i8]* %devpath76, i32 0, i32 0
  %call78 = call i32 (%struct.device*, i8*, ...) @dev_set_name(%struct.device* %dev74, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.6, i32 0, i32 0), i32 %15, i8* %arraydecay77)
  br label %if.end79

if.end79:                                         ; preds = %if.end70, %if.then34
  %root_hub.0 = phi i32 [ 1, %if.then34 ], [ 0, %if.end70 ]
  %conv80 = trunc i32 %port1 to i8
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 20
  store i8 %conv80, i8* %portnum, align 2, !tbaa !88
  %bus81 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  store %struct.usb_bus* %bus, %struct.usb_bus** %bus81, align 8, !tbaa !2
  %parent82 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  store %struct.usb_device* %parent, %struct.usb_device** %parent82, align 8, !tbaa !89
  %filelist = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 27
  call void @INIT_LIST_HEAD(%struct.list_head* %filelist)
  %dev83 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %16 = load i32, i32* @usb_autosuspend_delay, align 4, !tbaa !90
  %mul84 = mul nsw i32 %16, 1000
  call void @pm_runtime_set_autosuspend_delay(%struct.device* %dev83, i32 %mul84)
  %17 = load volatile i64, i64* @jiffies, align 8, !tbaa !49
  %connect_time = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 32
  store i64 %17, i64* %connect_time, align 8, !tbaa !91
  %18 = load volatile i64, i64* @jiffies, align 8, !tbaa !49
  %sub85 = sub i64 0, %18
  %active_duration = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 31
  store i64 %sub85, i64* %active_duration, align 8, !tbaa !92
  %tobool86 = icmp ne i32 %root_hub.0, 0
  br i1 %tobool86, label %if.then87, label %if.else91

if.then87:                                        ; preds = %if.end79
  %authorized = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 22
  %bf.load88 = load i16, i16* %authorized, align 4
  %bf.clear89 = and i16 %bf.load88, -9
  %bf.set90 = or i16 %bf.clear89, 8
  store i16 %bf.set90, i16* %authorized, align 4
  br label %cleanup

if.else91:                                        ; preds = %if.end79
  %authorized_default = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 11
  %bf.load92 = load i8, i8* %authorized_default, align 8
  %bf.lshr = lshr i8 %bf.load92, 5
  %bf.clear93 = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear93 to i32
  %authorized94 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 22
  %19 = trunc i32 %bf.cast to i16
  %bf.load95 = load i16, i16* %authorized94, align 4
  %bf.value = and i16 %19, 1
  %bf.shl = shl i16 %bf.value, 3
  %bf.clear96 = and i16 %bf.load95, -9
  %bf.set97 = or i16 %bf.clear96, %bf.shl
  store i16 %bf.set97, i16* %authorized94, align 4
  %call98 = call i32 @usb_bus_is_wusb(%struct.usb_bus* %bus)
  %tobool99 = icmp ne i32 %call98, 0
  %cond = select i1 %tobool99, i32 1, i32 0
  %wusb = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 22
  %20 = trunc i32 %cond to i16
  %bf.load100 = load i16, i16* %wusb, align 4
  %bf.value101 = and i16 %20, 1
  %bf.shl102 = shl i16 %bf.value101, 5
  %bf.clear103 = and i16 %bf.load100, -33
  %bf.set104 = or i16 %bf.clear103, %bf.shl102
  store i16 %bf.set104, i16* %wusb, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.else91, %if.then87, %if.then13, %if.then4, %entry
  %retval.0 = phi %struct.usb_device* [ null, %if.then13 ], [ null, %if.then4 ], [ null, %entry ], [ %0, %if.else91 ], [ %0, %if.then87 ]
  ret %struct.usb_device* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

declare void @device_initialize(%struct.device*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @dev_to_node(%struct.device* %dev) #1 {
entry:
  %numa_node = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %0 = load i32, i32* %numa_node, align 8, !tbaa !93
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @set_dev_node(%struct.device* %dev, i32 %node) #1 {
entry:
  %numa_node = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  store i32 %node, i32* %numa_node, align 8, !tbaa !93
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set(%union.anon.5* %v, i32 %i) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !94
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !95
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !96
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #4

declare i32 @dev_set_name(%struct.device*, i8*, ...) #2

declare i32 @snprintf(i8*, i64, i8*, ...) #2

declare void @pm_runtime_set_autosuspend_delay(%struct.device*, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @usb_bus_is_wusb(%struct.usb_bus* %bus) #0 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd*
  %wireless = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %1, i32 0, i32 11
  %bf.load = load i8, i8* %wireless, align 8
  %bf.lshr = lshr i8 %bf.load, 4
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  ret i32 %bf.cast
}

declare i8* @__kmalloc(i64, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @usb_init() #5 section ".init.text" {
entry:
  %0 = load i8, i8* @nousb, align 1, !tbaa !43, !range !44
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  %call2 = call i32 @usb_debugfs_init()
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %call6 = call i32 @usb_acpi_register()
  %call7 = call i32 @bus_register(%struct.bus_type* @usb_bus_type)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %bus_register_failed, label %if.end10

if.end10:                                         ; preds = %if.end5
  %call11 = call i32 @bus_register_notifier(%struct.bus_type* @usb_bus_type, %struct.notifier_block* @usb_bus_nb)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %bus_notifier_failed, label %if.end14

if.end14:                                         ; preds = %if.end10
  %call15 = call i32 @usb_major_init()
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %major_init_failed, label %if.end18

if.end18:                                         ; preds = %if.end14
  %call19 = call i32 @usb_register_driver(%struct.usb_driver* @usbfs_driver, %struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0))
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %driver_register_failed, label %if.end22

if.end22:                                         ; preds = %if.end18
  %call23 = call i32 @usb_devio_init()
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %usb_devio_init_failed, label %if.end26

if.end26:                                         ; preds = %if.end22
  %call27 = call i32 @usb_hub_init()
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %hub_init_failed, label %if.end30

if.end30:                                         ; preds = %if.end26
  %call31 = call i32 @usb_register_device_driver(%struct.usb_device_driver* @usb_generic_driver, %struct.module* @__this_module)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %if.end34, label %cleanup

if.end34:                                         ; preds = %if.end30
  call void @usb_hub_cleanup()
  br label %hub_init_failed

hub_init_failed:                                  ; preds = %if.end34, %if.end26
  %retval1.0 = phi i32 [ %call31, %if.end34 ], [ %call27, %if.end26 ]
  call void @usb_devio_cleanup()
  br label %usb_devio_init_failed

usb_devio_init_failed:                            ; preds = %hub_init_failed, %if.end22
  %retval1.1 = phi i32 [ %retval1.0, %hub_init_failed ], [ %call23, %if.end22 ]
  call void @usb_deregister(%struct.usb_driver* @usbfs_driver)
  br label %driver_register_failed

driver_register_failed:                           ; preds = %usb_devio_init_failed, %if.end18
  %retval1.2 = phi i32 [ %retval1.1, %usb_devio_init_failed ], [ %call19, %if.end18 ]
  call void @usb_major_cleanup()
  br label %major_init_failed

major_init_failed:                                ; preds = %driver_register_failed, %if.end14
  %retval1.3 = phi i32 [ %retval1.2, %driver_register_failed ], [ %call15, %if.end14 ]
  %call35 = call i32 @bus_unregister_notifier(%struct.bus_type* @usb_bus_type, %struct.notifier_block* @usb_bus_nb)
  br label %bus_notifier_failed

bus_notifier_failed:                              ; preds = %major_init_failed, %if.end10
  %retval1.4 = phi i32 [ %retval1.3, %major_init_failed ], [ %call11, %if.end10 ]
  call void @bus_unregister(%struct.bus_type* @usb_bus_type)
  br label %bus_register_failed

bus_register_failed:                              ; preds = %bus_notifier_failed, %if.end5
  %retval1.5 = phi i32 [ %retval1.4, %bus_notifier_failed ], [ %call7, %if.end5 ]
  call void @usb_acpi_unregister()
  call void @usb_debugfs_cleanup()
  br label %cleanup

cleanup:                                          ; preds = %bus_register_failed, %if.end30, %if.end, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ %retval1.5, %bus_register_failed ], [ %call2, %if.end ], [ %call31, %if.end30 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_debugfs_init() #0 {
entry:
  %call = call %struct.dentry* @debugfs_create_dir(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.774, i32 0, i32 0), %struct.dentry* null)
  store %struct.dentry* %call, %struct.dentry** @usb_debug_root, align 8, !tbaa !48
  %0 = load %struct.dentry*, %struct.dentry** @usb_debug_root, align 8, !tbaa !48
  %tobool = icmp ne %struct.dentry* %0, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.dentry*, %struct.dentry** @usb_debug_root, align 8, !tbaa !48
  %call1 = call %struct.dentry* @debugfs_create_file(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.14, i32 0, i32 0), i16 zeroext 292, %struct.dentry* %1, i8* null, %struct.file_operations* @usbfs_devices_fops)
  store %struct.dentry* %call1, %struct.dentry** @usb_debug_devices, align 8, !tbaa !48
  %2 = load %struct.dentry*, %struct.dentry** @usb_debug_devices, align 8, !tbaa !48
  %tobool2 = icmp ne %struct.dentry* %2, null
  br i1 %tobool2, label %return, label %if.then3

if.then3:                                         ; preds = %if.end
  %3 = load %struct.dentry*, %struct.dentry** @usb_debug_root, align 8, !tbaa !48
  call void @debugfs_remove(%struct.dentry* %3)
  store %struct.dentry* null, %struct.dentry** @usb_debug_root, align 8, !tbaa !48
  br label %return

return:                                           ; preds = %if.then3, %if.end, %entry
  %retval.0 = phi i32 [ -2, %if.then3 ], [ -2, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare i32 @bus_register(%struct.bus_type*) #2

declare i32 @bus_register_notifier(%struct.bus_type*, %struct.notifier_block*) #2

declare i32 @bus_unregister_notifier(%struct.bus_type*, %struct.notifier_block*) #2

declare void @bus_unregister(%struct.bus_type*) #2

; Function Attrs: nounwind uwtable
define internal void @usb_debugfs_cleanup() #0 {
entry:
  %0 = load %struct.dentry*, %struct.dentry** @usb_debug_devices, align 8, !tbaa !48
  call void @debugfs_remove(%struct.dentry* %0)
  %1 = load %struct.dentry*, %struct.dentry** @usb_debug_root, align 8, !tbaa !48
  call void @debugfs_remove(%struct.dentry* %1)
  ret void
}

declare void @debugfs_remove(%struct.dentry*) #2

; Function Attrs: nounwind uwtable
define internal i32 @usb_bus_notify(%struct.notifier_block* %nb, i64 %action, i8* %data) #0 {
entry:
  %0 = bitcast i8* %data to %struct.device*
  %Pivot = icmp slt i64 %action, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i64 %action, 2
  br i1 %SwitchLeaf2, label %sw.bb8, label %sw.epilog

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i64 %action, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %type = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 4
  %1 = load %struct.device_type*, %struct.device_type** %type, align 8, !tbaa !58
  %cmp = icmp eq %struct.device_type* %1, @usb_device_type
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %2 = bitcast %struct.device* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -136
  %3 = bitcast i8* %add.ptr to %struct.usb_device*
  %call = call i32 @usb_create_sysfs_dev_files(%struct.usb_device* %3)
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb
  %type1 = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 4
  %4 = load %struct.device_type*, %struct.device_type** %type1, align 8, !tbaa !58
  %cmp2 = icmp eq %struct.device_type* %4, @usb_if_device_type
  br i1 %cmp2, label %if.then3, label %sw.epilog

if.then3:                                         ; preds = %if.else
  %5 = bitcast %struct.device* %0 to i8*
  %add.ptr6 = getelementptr inbounds i8, i8* %5, i64 -48
  %6 = bitcast i8* %add.ptr6 to %struct.usb_interface*
  call void @usb_create_sysfs_intf_files(%struct.usb_interface* %6)
  br label %sw.epilog

sw.bb8:                                           ; preds = %LeafBlock1
  %type9 = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 4
  %7 = load %struct.device_type*, %struct.device_type** %type9, align 8, !tbaa !58
  %cmp10 = icmp eq %struct.device_type* %7, @usb_device_type
  br i1 %cmp10, label %if.then11, label %if.else15

if.then11:                                        ; preds = %sw.bb8
  %8 = bitcast %struct.device* %0 to i8*
  %add.ptr14 = getelementptr inbounds i8, i8* %8, i64 -136
  %9 = bitcast i8* %add.ptr14 to %struct.usb_device*
  call void @usb_remove_sysfs_dev_files(%struct.usb_device* %9)
  br label %sw.epilog

if.else15:                                        ; preds = %sw.bb8
  %type16 = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 4
  %10 = load %struct.device_type*, %struct.device_type** %type16, align 8, !tbaa !58
  %cmp17 = icmp eq %struct.device_type* %10, @usb_if_device_type
  br i1 %cmp17, label %if.then18, label %sw.epilog

if.then18:                                        ; preds = %if.else15
  %11 = bitcast %struct.device* %0 to i8*
  %add.ptr21 = getelementptr inbounds i8, i8* %11, i64 -48
  %12 = bitcast i8* %add.ptr21 to %struct.usb_interface*
  call void @usb_remove_sysfs_intf_files(%struct.usb_interface* %12)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then18, %if.else15, %if.then11, %if.then3, %if.else, %if.then, %LeafBlock, %LeafBlock1
  ret i32 0
}

declare %struct.dentry* @debugfs_create_dir(i8*, %struct.dentry*) #2

declare %struct.dentry* @debugfs_create_file(i8*, i16 zeroext, %struct.dentry*, i8*, %struct.file_operations*) #2

; Function Attrs: nounwind uwtable
define internal void @usb_exit() #5 section ".exit.text" {
entry:
  %0 = load i8, i8* @nousb, align 1, !tbaa !43, !range !44
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @usb_deregister_device_driver(%struct.usb_device_driver* @usb_generic_driver)
  call void @usb_major_cleanup()
  call void @usb_deregister(%struct.usb_driver* @usbfs_driver)
  call void @usb_devio_cleanup()
  call void @usb_hub_cleanup()
  %call = call i32 @bus_unregister_notifier(%struct.bus_type* @usb_bus_type, %struct.notifier_block* @usb_bus_nb)
  call void @bus_unregister(%struct.bus_type* @usb_bus_type)
  call void @usb_acpi_unregister()
  call void @usb_debugfs_cleanup()
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.usb_device* @usb_hub_find_child(%struct.usb_device* %hdev, i32 %port1) #0 {
entry:
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  %cmp = icmp slt i32 %port1, 1
  br i1 %cmp, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 28
  %0 = load i32, i32* %maxchild, align 8, !tbaa !97
  %cmp1 = icmp sgt i32 %port1, %0
  br i1 %cmp1, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 22
  %1 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %1, i64 %idxprom
  %2 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %2, i32 0, i32 0
  %3 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !102
  br label %cleanup

cleanup:                                          ; preds = %if.end, %lor.lhs.false, %entry
  %retval.0 = phi %struct.usb_device* [ %3, %if.end ], [ null, %lor.lhs.false ], [ null, %entry ]
  ret %struct.usb_device* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev) #0 {
entry:
  %tobool = icmp ne %struct.usb_device* %hdev, null
  br i1 %tobool, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %entry
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool1 = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool1, label %lor.lhs.false2, label %return

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 28
  %1 = load i32, i32* %maxchild, align 8, !tbaa !97
  %tobool3 = icmp ne i32 %1, 0
  br i1 %tobool3, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false2
  %actconfig4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig4, align 8, !tbaa !64
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 3
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 0
  %3 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !48
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %3)
  %4 = bitcast i8* %call to %struct.usb_hub*
  br label %return

return:                                           ; preds = %if.end, %lor.lhs.false2, %lor.lhs.false, %entry
  %retval.0 = phi %struct.usb_hub* [ %4, %if.end ], [ null, %lor.lhs.false2 ], [ null, %lor.lhs.false ], [ null, %entry ]
  ret %struct.usb_hub* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @usb_get_intfdata(%struct.usb_interface* %intf) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

declare i8* @dev_get_drvdata(%struct.device*) #2

; Function Attrs: nounwind uwtable
define void @usb_queue_reset_device(%struct.usb_interface* %iface) #0 {
entry:
  %reset_ws = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 10
  call void @schedule_work(%struct.work_struct* %reset_ws)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @schedule_work(%struct.work_struct* %work) #1 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8, !tbaa !48
  call void @queue_work(%struct.workqueue_struct* %0, %struct.work_struct* %work)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_work(%struct.workqueue_struct* %wq, %struct.work_struct* %work) #1 {
entry:
  %call = call zeroext i1 @queue_work_on(i32 4096, %struct.workqueue_struct* %wq, %struct.work_struct* %work)
  ret void
}

declare zeroext i1 @queue_work_on(i32, %struct.workqueue_struct*, %struct.work_struct*) #2

; Function Attrs: nounwind uwtable
define i32 @usb_reset_device(%struct.usb_device* %udev) #0 {
entry:
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %do.body3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %state1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %2 = load i32, i32* %state1, align 8, !tbaa !50
  %cmp2 = icmp eq i32 %2, 8
  br i1 %cmp2, label %do.body3, label %if.end10

do.body3:                                         ; preds = %lor.lhs.false, %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_reset_device.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then6, label %cleanup

if.then6:                                         ; preds = %do.body3
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %state7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %3 = load i32, i32* %state7, align 8, !tbaa !50
  %call = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_reset_device.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.38, i32 0, i32 0), i32 %3)
  br label %cleanup

if.end10:                                         ; preds = %lor.lhs.false
  %call11 = call i32 @memalloc_noio_save()
  %call12 = call i32 @usb_autoresume_device(%struct.usb_device* %udev)
  %tobool13 = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool13, label %if.then14, label %if.end37

if.then14:                                        ; preds = %if.end10
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then14
  %i.0 = phi i32 [ 0, %if.then14 ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %4 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv15 = zext i8 %4 to i32
  %cmp16 = icmp slt i32 %i.0, %conv15
  br i1 %cmp16, label %for.body, label %if.end37

for.body:                                         ; preds = %for.cond
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %5 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !48
  %dev18 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %5, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev18, i32 0, i32 7
  %6 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !104
  %tobool19 = icmp ne %struct.device_driver* %6, null
  br i1 %tobool19, label %if.then20, label %for.inc

if.then20:                                        ; preds = %for.body
  %dev21 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %5, i32 0, i32 7
  %driver22 = getelementptr inbounds %struct.device, %struct.device* %dev21, i32 0, i32 7
  %7 = load %struct.device_driver*, %struct.device_driver** %driver22, align 8, !tbaa !104
  %8 = bitcast %struct.device_driver* %7 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 -168
  %9 = bitcast i8* %add.ptr to %struct.usb_driver*
  %pre_reset = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %9, i32 0, i32 7
  %10 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %pre_reset, align 8, !tbaa !105
  %tobool23 = icmp ne i32 (%struct.usb_interface*)* %10, null
  br i1 %tobool23, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then20
  %post_reset = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %9, i32 0, i32 8
  %11 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %post_reset, align 8, !tbaa !110
  %tobool24 = icmp ne i32 (%struct.usb_interface*)* %11, null
  br i1 %tobool24, label %if.then25, label %if.else

if.then25:                                        ; preds = %land.lhs.true
  %pre_reset26 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %9, i32 0, i32 7
  %12 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %pre_reset26, align 8, !tbaa !105
  %call27 = call i32 %12(%struct.usb_interface* %5)
  br label %if.end32

if.else:                                          ; preds = %land.lhs.true, %if.then20
  %condition = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %5, i32 0, i32 5
  %13 = load i32, i32* %condition, align 4, !tbaa !51
  %cmp28 = icmp eq i32 %13, 2
  %. = select i1 %cmp28, i32 1, i32 0
  br label %if.end32

if.end32:                                         ; preds = %if.else, %if.then25
  %unbind.1 = phi i32 [ %call27, %if.then25 ], [ %., %if.else ]
  %tobool33 = icmp ne i32 %unbind.1, 0
  br i1 %tobool33, label %if.then34, label %for.inc

if.then34:                                        ; preds = %if.end32
  call void @usb_forced_unbind_intf(%struct.usb_interface* %5)
  br label %for.inc

for.inc:                                          ; preds = %if.then34, %if.end32, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end37:                                         ; preds = %for.cond, %if.end10
  %call38 = call i32 @usb_reset_and_verify_device(%struct.usb_device* %udev)
  %tobool39 = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool39, label %if.then40, label %if.end88

if.then40:                                        ; preds = %if.end37
  %desc41 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 0
  %bNumInterfaces42 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc41, i32 0, i32 3
  %14 = load i8, i8* %bNumInterfaces42, align 4, !tbaa !65
  %conv43 = zext i8 %14 to i32
  %sub = sub nsw i32 %conv43, 1
  br label %for.cond44

for.cond44:                                       ; preds = %for.inc86, %if.then40
  %i.1 = phi i32 [ %sub, %if.then40 ], [ %dec, %for.inc86 ]
  %cmp45 = icmp sge i32 %i.1, 0
  br i1 %cmp45, label %for.body47, label %if.end88

for.body47:                                       ; preds = %for.cond44
  %interface49 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 3
  %idxprom50 = sext i32 %i.1 to i64
  %arrayidx51 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface49, i64 0, i64 %idxprom50
  %15 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx51, align 8, !tbaa !48
  %needs_binding = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %15, i32 0, i32 6
  %bf.load53 = load i8, i8* %needs_binding, align 8
  %bf.lshr54 = lshr i8 %bf.load53, 5
  %bf.clear55 = and i8 %bf.lshr54, 1
  %bf.cast = zext i8 %bf.clear55 to i32
  %tobool56 = icmp ne i32 %bf.cast, 0
  br i1 %tobool56, label %if.end79, label %land.lhs.true57

land.lhs.true57:                                  ; preds = %for.body47
  %dev58 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %15, i32 0, i32 7
  %driver59 = getelementptr inbounds %struct.device, %struct.device* %dev58, i32 0, i32 7
  %16 = load %struct.device_driver*, %struct.device_driver** %driver59, align 8, !tbaa !104
  %tobool60 = icmp ne %struct.device_driver* %16, null
  br i1 %tobool60, label %if.then61, label %if.end79

if.then61:                                        ; preds = %land.lhs.true57
  %dev63 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %15, i32 0, i32 7
  %driver64 = getelementptr inbounds %struct.device, %struct.device* %dev63, i32 0, i32 7
  %17 = load %struct.device_driver*, %struct.device_driver** %driver64, align 8, !tbaa !104
  %18 = bitcast %struct.device_driver* %17 to i8*
  %add.ptr66 = getelementptr inbounds i8, i8* %18, i64 -168
  %19 = bitcast i8* %add.ptr66 to %struct.usb_driver*
  %post_reset67 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %19, i32 0, i32 8
  %20 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %post_reset67, align 8, !tbaa !110
  %tobool68 = icmp ne i32 (%struct.usb_interface*)* %20, null
  br i1 %tobool68, label %if.then69, label %if.else72

if.then69:                                        ; preds = %if.then61
  %post_reset70 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %19, i32 0, i32 8
  %21 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %post_reset70, align 8, !tbaa !110
  %call71 = call i32 %21(%struct.usb_interface* %15)
  br label %if.end79

if.else72:                                        ; preds = %if.then61
  %condition73 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %15, i32 0, i32 5
  %22 = load i32, i32* %condition73, align 4, !tbaa !51
  %cmp74 = icmp eq i32 %22, 2
  %.bf.cast = select i1 %cmp74, i32 1, i32 %bf.cast
  br label %if.end79

if.end79:                                         ; preds = %if.else72, %if.then69, %land.lhs.true57, %for.body47
  %rebind.2 = phi i32 [ %bf.cast, %for.body47 ], [ %bf.cast, %land.lhs.true57 ], [ %call71, %if.then69 ], [ %.bf.cast, %if.else72 ]
  %cmp80 = icmp eq i32 %call38, 0
  %tobool83 = icmp ne i32 %rebind.2, 0
  %or.cond = and i1 %cmp80, %tobool83
  br i1 %or.cond, label %if.then84, label %for.inc86

if.then84:                                        ; preds = %if.end79
  call void @usb_rebind_intf(%struct.usb_interface* %15)
  br label %for.inc86

for.inc86:                                        ; preds = %if.then84, %if.end79
  %dec = add nsw i32 %i.1, -1
  br label %for.cond44

if.end88:                                         ; preds = %for.cond44, %if.end37
  call void @usb_autosuspend_device(%struct.usb_device* %udev)
  call void @memalloc_noio_restore(i32 %call11)
  br label %cleanup

cleanup:                                          ; preds = %if.end88, %if.then6, %do.body3
  %retval.0 = phi i32 [ %call38, %if.end88 ], [ -22, %if.then6 ], [ -22, %do.body3 ]
  ret i32 %retval.0
}

declare i32 @__dynamic_dev_dbg(%struct._ddebug*, %struct.device*, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @memalloc_noio_save() #1 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !111
  %flags1 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 3
  %1 = load i32, i32* %flags1, align 4, !tbaa !112
  %and = and i32 %1, 524288
  %2 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !111
  %flags3 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %2, i32 0, i32 3
  %3 = load i32, i32* %flags3, align 4, !tbaa !112
  %or = or i32 %3, 524288
  store i32 %or, i32* %flags3, align 4, !tbaa !112
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_reset_and_verify_device(%struct.usb_device* %udev) #0 {
entry:
  %descriptor = alloca %struct.usb_device_descriptor, align 1
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.11(%struct.usb_bus* %1)
  %2 = bitcast %struct.usb_device_descriptor* %descriptor to i8*
  %descriptor1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %3 = bitcast %struct.usb_device_descriptor* %descriptor to i8*
  %4 = bitcast %struct.usb_device_descriptor* %descriptor1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 18, i32 1, i1 false), !tbaa.struct !142
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %5 = load i8, i8* %portnum, align 2, !tbaa !88
  %conv = zext i8 %5 to i32
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %6 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp eq i32 %6, 0
  br i1 %cmp, label %do.body6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %state3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %7 = load i32, i32* %state3, align 8, !tbaa !50
  %cmp4 = icmp eq i32 %7, 8
  br i1 %cmp4, label %do.body6, label %if.end15

do.body6:                                         ; preds = %lor.lhs.false, %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_reset_and_verify_device.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv8 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %cleanup149

if.then10:                                        ; preds = %do.body6
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %state11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %8 = load i32, i32* %state11, align 8, !tbaa !50
  %call12 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_reset_and_verify_device.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.38, i32 0, i32 0), i32 %8)
  br label %cleanup149

if.end15:                                         ; preds = %lor.lhs.false
  %tobool16 = icmp ne %struct.usb_device* %0, null
  br i1 %tobool16, label %if.end40, label %do.body19

do.body19:                                        ; preds = %if.end15
  %bf.load20 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_reset_and_verify_device.descriptor.258 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr21 = lshr i32 %bf.load20, 18
  %bf.clear22 = and i32 %bf.lshr21, 255
  %and23 = and i32 %bf.clear22, 1
  %tobool24 = icmp ne i32 %and23, 0
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot.ext28 = zext i1 %lnot27 to i32
  %conv29 = sext i32 %lnot.ext28 to i64
  %expval30 = call i64 @llvm.expect.i64(i64 %conv29, i64 0)
  %tobool31 = icmp ne i64 %expval30, 0
  br i1 %tobool31, label %if.then32, label %cleanup149

if.then32:                                        ; preds = %do.body19
  %dev33 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call34 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_reset_and_verify_device.descriptor.258 to %struct._ddebug*), %struct.device* %dev33, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.259, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.usb_reset_and_verify_device, i32 0, i32 0))
  br label %cleanup149

if.end40:                                         ; preds = %if.end15
  %call41 = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %0)
  %call42 = call i32 @usb_unlocked_disable_lpm(%struct.usb_device* %udev)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.then44, label %if.end47

if.then44:                                        ; preds = %if.end40
  %9 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %re_enumerate

if.end47:                                         ; preds = %if.end40
  %call48 = call i32 @usb_disable_ltm(%struct.usb_device* %udev)
  %tobool49 = icmp ne i32 %call48, 0
  br i1 %tobool49, label %if.then50, label %if.end53

if.then50:                                        ; preds = %if.end47
  %10 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %re_enumerate

if.end53:                                         ; preds = %if.end47
  %busy_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call41, i32 0, i32 12
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %busy_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i32 %conv, i64* %arraydecay) #8, !srcloc !144
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end53
  %i.0 = phi i32 [ 0, %if.end53 ], [ %inc, %for.inc ]
  %ret.0 = phi i32 [ %call48, %if.end53 ], [ %call58, %for.inc ]
  %11 = load i8, i8* @use_both_schemes, align 1, !tbaa !43, !range !44
  %tobool54 = trunc i8 %11 to i1
  %conv55 = zext i1 %tobool54 to i32
  %add = add nsw i32 %conv55, 1
  %mul = mul nsw i32 2, %add
  %cmp56 = icmp slt i32 %i.0, %mul
  br i1 %cmp56, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @usb_ep0_reinit(%struct.usb_device* %udev)
  %call58 = call i32 @hub_port_init(%struct.usb_hub* %call41, %struct.usb_device* %udev, i32 %conv, i32 %i.0)
  %cmp59 = icmp sge i32 %call58, 0
  br i1 %cmp59, label %for.end, label %switch.early.test

switch.early.test:                                ; preds = %for.body
  switch i32 %call58, label %for.inc [
    i32 -19, label %for.end
    i32 -107, label %for.end
  ]

for.inc:                                          ; preds = %switch.early.test
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %switch.early.test, %switch.early.test, %for.body, %for.cond
  %ret.1 = phi i32 [ %call58, %switch.early.test ], [ %ret.0, %for.cond ], [ %call58, %for.body ], [ %call58, %switch.early.test ]
  %busy_bits69 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call41, i32 0, i32 12
  %arraydecay70 = getelementptr inbounds [1 x i64], [1 x i64]* %busy_bits69, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay70, i32 %conv, i64* %arraydecay70) #8, !srcloc !145
  %cmp71 = icmp slt i32 %ret.1, 0
  br i1 %cmp71, label %re_enumerate, label %if.end74

if.end74:                                         ; preds = %for.end
  %call75 = call i32 @descriptors_changed(%struct.usb_device* %udev, %struct.usb_device_descriptor* %descriptor)
  %tobool76 = icmp ne i32 %call75, 0
  br i1 %tobool76, label %if.then77, label %if.end81

if.then77:                                        ; preds = %if.end74
  %12 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %descriptor80 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %13 = bitcast %struct.usb_device_descriptor* %descriptor80 to i8*
  %14 = bitcast %struct.usb_device_descriptor* %descriptor to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 18, i32 1, i1 false), !tbaa.struct !142
  br label %re_enumerate

if.end81:                                         ; preds = %if.end74
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %15 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool82 = icmp ne %struct.usb_host_config* %15, null
  br i1 %tobool82, label %if.end84, label %done

if.end84:                                         ; preds = %if.end81
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %16 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !146
  call void @mutex_lock_nested(%struct.mutex* %16, i32 0)
  %actconfig85 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %17 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig85, align 8, !tbaa !64
  %call86 = call i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %udev, %struct.usb_host_config* %17, %struct.usb_host_interface* null, %struct.usb_host_interface* null)
  %cmp87 = icmp slt i32 %call86, 0
  br i1 %cmp87, label %if.then89, label %if.end93

if.then89:                                        ; preds = %if.end84
  %18 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %bandwidth_mutex92 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %19 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex92, align 8, !tbaa !146
  call void @mutex_unlock(%struct.mutex* %19)
  br label %re_enumerate

if.end93:                                         ; preds = %if.end84
  %call94 = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or = or i32 -2147483648, %call94
  %actconfig95 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %20 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig95, align 8, !tbaa !64
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %20, i32 0, i32 0
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 4
  %21 = load i8, i8* %bConfigurationValue, align 1, !tbaa !147
  %conv96 = zext i8 %21 to i16
  %call97 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext 9, i8 zeroext 0, i16 zeroext %conv96, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  %cmp98 = icmp slt i32 %call97, 0
  br i1 %cmp98, label %if.then100, label %if.end108

if.then100:                                       ; preds = %if.end93
  %22 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %bandwidth_mutex107 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %23 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex107, align 8, !tbaa !146
  call void @mutex_unlock(%struct.mutex* %23)
  br label %re_enumerate

if.end108:                                        ; preds = %if.end93
  %bandwidth_mutex109 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %24 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex109, align 8, !tbaa !146
  call void @mutex_unlock(%struct.mutex* %24)
  call void @usb_set_device_state(%struct.usb_device* %udev, i32 7)
  br label %for.cond110

for.cond110:                                      ; preds = %for.inc146, %if.end108
  %i.1 = phi i32 [ 0, %if.end108 ], [ %inc147, %for.inc146 ]
  %actconfig111 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %25 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig111, align 8, !tbaa !64
  %desc112 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %25, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc112, i32 0, i32 3
  %26 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv113 = zext i8 %26 to i32
  %cmp114 = icmp slt i32 %i.1, %conv113
  br i1 %cmp114, label %for.body116, label %done

for.body116:                                      ; preds = %for.cond110
  %actconfig117 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %27 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig117, align 8, !tbaa !64
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %27, i32 0, i32 3
  %idxprom = sext i32 %i.1 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %28 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !48
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %28, i32 0, i32 1
  %29 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !148
  %desc119 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %29, i32 0, i32 0
  %bAlternateSetting = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc119, i32 0, i32 3
  %30 = load i8, i8* %bAlternateSetting, align 1, !tbaa !149
  %conv120 = zext i8 %30 to i32
  %cmp121 = icmp eq i32 %conv120, 0
  br i1 %cmp121, label %if.then123, label %if.else

if.then123:                                       ; preds = %for.body116
  call void @usb_disable_interface(%struct.usb_device* %udev, %struct.usb_interface* %28, i1 zeroext true)
  call void @usb_enable_interface(%struct.usb_device* %udev, %struct.usb_interface* %28, i1 zeroext true)
  br label %if.end133

if.else:                                          ; preds = %for.body116
  %resetting_device = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %28, i32 0, i32 6
  %bf.load124 = load i8, i8* %resetting_device, align 8
  %bf.clear125 = and i8 %bf.load124, 127
  %bf.set = or i8 %bf.clear125, -128
  store i8 %bf.set, i8* %resetting_device, align 8
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc119, i32 0, i32 2
  %31 = load i8, i8* %bInterfaceNumber, align 1, !tbaa !150
  %conv126 = zext i8 %31 to i32
  %bAlternateSetting127 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc119, i32 0, i32 3
  %32 = load i8, i8* %bAlternateSetting127, align 1, !tbaa !149
  %conv128 = zext i8 %32 to i32
  %call129 = call i32 @usb_set_interface(%struct.usb_device* %udev, i32 %conv126, i32 %conv128)
  %resetting_device130 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %28, i32 0, i32 6
  %bf.load131 = load i8, i8* %resetting_device130, align 8
  %bf.clear132 = and i8 %bf.load131, 127
  store i8 %bf.clear132, i8* %resetting_device130, align 8
  br label %if.end133

if.end133:                                        ; preds = %if.else, %if.then123
  %ret.2 = phi i32 [ 0, %if.then123 ], [ %call129, %if.else ]
  %cmp134 = icmp slt i32 %ret.2, 0
  br i1 %cmp134, label %if.then136, label %NodeBlock

if.then136:                                       ; preds = %if.end133
  %33 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.then136, %if.end133
  %cleanup.dest.slot.0 = phi i32 [ 10, %if.then136 ], [ 0, %if.end133 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 10
  br i1 %SwitchLeaf2, label %re_enumerate, label %cleanup149

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc146, label %cleanup149

for.inc146:                                       ; preds = %LeafBlock
  %inc147 = add nsw i32 %i.1, 1
  br label %for.cond110

done:                                             ; preds = %for.cond110, %if.end81
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %udev)
  call void @usb_enable_ltm(%struct.usb_device* %udev)
  br label %cleanup149

re_enumerate:                                     ; preds = %LeafBlock1, %if.then100, %if.then89, %if.then77, %for.end, %if.then50, %if.then44
  call void @hub_port_logical_disconnect(%struct.usb_hub* %call41, i32 %conv)
  br label %cleanup149

cleanup149:                                       ; preds = %re_enumerate, %done, %LeafBlock, %LeafBlock1, %if.then32, %do.body19, %if.then10, %do.body6
  %retval.0 = phi i32 [ -19, %re_enumerate ], [ 0, %done ], [ -22, %if.then10 ], [ -22, %do.body6 ], [ -21, %if.then32 ], [ -21, %do.body19 ], [ undef, %LeafBlock ], [ undef, %LeafBlock1 ]
  %34 = bitcast %struct.usb_device_descriptor* %descriptor to i8*
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @memalloc_noio_restore(i32 %flags) #1 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !111
  %flags1 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 3
  %1 = load i32, i32* %flags1, align 4, !tbaa !112
  %and = and i32 %1, -524289
  %or = or i32 %and, %flags
  %2 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !111
  %flags3 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %2, i32 0, i32 3
  store i32 %or, i32* %flags3, align 4, !tbaa !112
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd* @bus_to_hcd.11(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd*
  ret %struct.usb_hcd* %1
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #3

; Function Attrs: nounwind uwtable
define i32 @usb_unlocked_disable_lpm(%struct.usb_device* %udev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.11(%struct.usb_bus* %0)
  %tobool = icmp ne %struct.usb_hcd* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %1 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !146
  call void @mutex_lock_nested(%struct.mutex* %1, i32 0)
  %call1 = call i32 @usb_disable_lpm(%struct.usb_device* %udev)
  %bandwidth_mutex2 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %2 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex2, align 8, !tbaa !146
  call void @mutex_unlock(%struct.mutex* %2)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call1, %if.end ], [ -22, %entry ]
  ret i32 %retval.0
}

declare i32 @dev_err(%struct.device*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define i32 @usb_disable_ltm(%struct.usb_device* %udev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.11(%struct.usb_bus* %0)
  %self = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 10
  %1 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !151
  %call1 = call zeroext i1 @usb_device_supports_ltm(%struct.usb_device* %1)
  br i1 %call1, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %call2 = call zeroext i1 @usb_device_supports_ltm(%struct.usb_device* %udev)
  br i1 %call2, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or = or i32 -2147483648, %call5
  %call6 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext 1, i8 zeroext 0, i16 zeroext 50, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ %call6, %if.end4 ], [ 0, %lor.lhs.false ], [ 0, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_ep0_reinit(%struct.usb_device* %udev) #0 {
entry:
  call void @usb_disable_endpoint(%struct.usb_device* %udev, i32 128, i1 zeroext true)
  call void @usb_disable_endpoint(%struct.usb_device* %udev, i32 0, i1 zeroext true)
  %ep0 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 10
  call void @usb_enable_endpoint(%struct.usb_device* %udev, %struct.usb_host_endpoint* %ep0, i1 zeroext true)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_port_init(%struct.usb_hub* %hub, %struct.usb_device* %udev, i32 %port1, i32 %retry_counter) #0 {
entry:
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !152
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.11(%struct.usb_bus* %1)
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %2 = load i32, i32* %speed, align 4, !tbaa !153
  %devnum4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  %3 = load i32, i32* %devnum4, align 8, !tbaa !38
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  %4 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool = icmp ne %struct.usb_device* %4, null
  br i1 %tobool, label %if.end9, label %if.then

if.then:                                          ; preds = %entry
  %bus5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %5 = load %struct.usb_bus*, %struct.usb_bus** %bus5, align 8, !tbaa !2
  %otg_port = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %5, i32 0, i32 5
  %6 = load i8, i8* %otg_port, align 2, !tbaa !154
  %conv = zext i8 %6 to i32
  %cmp = icmp eq i32 %port1, %conv
  br i1 %cmp, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.then
  %bus8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %7 = load %struct.usb_bus*, %struct.usb_bus** %bus8, align 8, !tbaa !2
  %b_hnp_enable = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %7, i32 0, i32 6
  %bf.load = load i8, i8* %b_hnp_enable, align 1
  %bf.clear = and i8 %bf.load, -3
  store i8 %bf.clear, i8* %b_hnp_enable, align 1
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.then, %entry
  %delay.0 = phi i32 [ 10, %entry ], [ 50, %if.then7 ], [ 50, %if.then ]
  %cmp10 = icmp eq i32 %2, 1
  %.delay.0 = select i1 %cmp10, i32 200, i32 %delay.0
  call void @mutex_lock_nested(%struct.mutex* @hub_port_init.usb_address0_mutex, i32 0)
  %call14 = call i32 @hub_port_reset(%struct.usb_hub* %hub, i32 %port1, %struct.usb_device* %udev, i32 %.delay.0, i1 zeroext false)
  %cmp15 = icmp slt i32 %call14, 0
  br i1 %cmp15, label %fail, label %if.end18

if.end18:                                         ; preds = %if.end9
  %cmp19 = icmp ne i32 %2, 0
  br i1 %cmp19, label %land.lhs.true, label %if.end37

land.lhs.true:                                    ; preds = %if.end18
  %speed21 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %8 = load i32, i32* %speed21, align 4, !tbaa !153
  %cmp22 = icmp ne i32 %2, %8
  br i1 %cmp22, label %do.body25, label %if.end37

do.body25:                                        ; preds = %land.lhs.true
  %bf.load26 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_init.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load26, 18
  %bf.clear27 = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear27, 1
  %tobool28 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool28, true
  %lnot29 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot29 to i32
  %conv30 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv30, i64 0)
  %tobool31 = icmp ne i64 %expval, 0
  br i1 %tobool31, label %if.then32, label %fail

if.then32:                                        ; preds = %do.body25
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call33 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_init.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.235, i32 0, i32 0))
  br label %fail

if.end37:                                         ; preds = %land.lhs.true, %if.end18
  %speed38 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %9 = load i32, i32* %speed38, align 4, !tbaa !153
  %speed39 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %10 = load i32, i32* %speed39, align 4, !tbaa !153
  %Pivot6 = icmp slt i32 %10, 3
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %if.end37
  %Pivot4 = icmp slt i32 %10, 4
  br i1 %Pivot4, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %.off = add i32 %10, -4
  %SwitchLeaf2 = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf2, label %sw.epilog, label %fail

NodeBlock:                                        ; preds = %if.end37
  %Pivot = icmp slt i32 %10, 2
  br i1 %Pivot, label %LeafBlock, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %10, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %fail

sw.epilog:                                        ; preds = %LeafBlock, %NodeBlock, %LeafBlock1, %NodeBlock3
  %.sink = phi i16 [ 64, %NodeBlock3 ], [ 64, %NodeBlock ], [ 8, %LeafBlock ], [ 512, %LeafBlock1 ]
  %ep049 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 10
  %desc50 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep049, i32 0, i32 0
  %wMaxPacketSize51 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc50, i32 0, i32 4
  store i16 %.sink, i16* %wMaxPacketSize51, align 4, !tbaa !155
  %speed52 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %11 = load i32, i32* %speed52, align 4, !tbaa !153
  %cmp53 = icmp eq i32 %11, 4
  br i1 %cmp53, label %if.end58, label %if.else

if.else:                                          ; preds = %sw.epilog
  %speed56 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %12 = load i32, i32* %speed56, align 4, !tbaa !153
  %call57 = call i8* @usb_speed_string(i32 %12)
  br label %if.end58

if.end58:                                         ; preds = %if.else, %sw.epilog
  %speed59 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %13 = load i32, i32* %speed59, align 4, !tbaa !153
  %cmp60 = icmp ne i32 %13, 5
  br i1 %cmp60, label %if.then62, label %if.end67

if.then62:                                        ; preds = %if.end58
  %14 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %if.end67

if.end67:                                         ; preds = %if.then62, %if.end58
  %tt = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 5
  %15 = load %struct.usb_tt*, %struct.usb_tt** %tt, align 8, !tbaa !156
  %tobool68 = icmp ne %struct.usb_tt* %15, null
  br i1 %tobool68, label %if.then69, label %if.else73

if.then69:                                        ; preds = %if.end67
  %tt70 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 5
  %16 = load %struct.usb_tt*, %struct.usb_tt** %tt70, align 8, !tbaa !156
  %tt71 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 5
  store %struct.usb_tt* %16, %struct.usb_tt** %tt71, align 8, !tbaa !156
  %ttport = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 6
  %17 = load i32, i32* %ttport, align 8, !tbaa !157
  %ttport72 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 6
  store i32 %17, i32* %ttport72, align 8, !tbaa !157
  br label %if.end93

if.else73:                                        ; preds = %if.end67
  %speed74 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %18 = load i32, i32* %speed74, align 4, !tbaa !153
  %cmp75 = icmp ne i32 %18, 3
  br i1 %cmp75, label %land.lhs.true77, label %if.end93

land.lhs.true77:                                  ; preds = %if.else73
  %speed78 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 4
  %19 = load i32, i32* %speed78, align 4, !tbaa !153
  %cmp79 = icmp eq i32 %19, 3
  br i1 %cmp79, label %if.then81, label %if.end93

if.then81:                                        ; preds = %land.lhs.true77
  %tt82 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %hub83 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt82, i32 0, i32 0
  %20 = load %struct.usb_device*, %struct.usb_device** %hub83, align 8, !tbaa !158
  %tobool84 = icmp ne %struct.usb_device* %20, null
  br i1 %tobool84, label %if.end88, label %if.then85

if.then85:                                        ; preds = %if.then81
  %21 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %fail

if.end88:                                         ; preds = %if.then81
  %tt89 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %tt90 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 5
  store %struct.usb_tt* %tt89, %struct.usb_tt** %tt90, align 8, !tbaa !156
  %ttport91 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 6
  store i32 %port1, i32* %ttport91, align 8, !tbaa !157
  br label %if.end93

if.end93:                                         ; preds = %if.end88, %land.lhs.true77, %if.else73, %if.then69
  br label %for.cond

for.cond:                                         ; preds = %for.inc249, %if.end93
  %retval2.0 = phi i32 [ -19, %if.end93 ], [ %retval2.6, %for.inc249 ]
  %i.0 = phi i32 [ 0, %if.end93 ], [ %inc250, %for.inc249 ]
  %devnum.0 = phi i32 [ %3, %if.end93 ], [ %devnum.3, %for.inc249 ]
  %cmp94 = icmp slt i32 %i.0, 2
  br i1 %cmp94, label %for.body, label %for.end251

for.body:                                         ; preds = %for.cond
  %div = sdiv i32 %retry_counter, 2
  %22 = load i8, i8* @old_scheme_first, align 1, !tbaa !43, !range !44
  %tobool96 = trunc i8 %22 to i1
  %conv97 = zext i1 %tobool96 to i32
  %cmp98 = icmp eq i32 %div, %conv97
  br i1 %cmp98, label %land.lhs.true100, label %if.end176

land.lhs.true100:                                 ; preds = %for.body
  %driver101 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %23 = load %struct.hc_driver*, %struct.hc_driver** %driver101, align 8, !tbaa !71
  %flags = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %23, i32 0, i32 4
  %24 = load i32, i32* %flags, align 8, !tbaa !159
  %and102 = and i32 %24, 64
  %tobool103 = icmp ne i32 %and102, 0
  br i1 %tobool103, label %if.end176, label %if.then104

if.then104:                                       ; preds = %land.lhs.true100
  %call.i = call i8* @__kmalloc(i64 64, i32 16) #8
  %25 = bitcast i8* %call.i to %struct.usb_device_descriptor*
  %tobool106 = icmp ne %struct.usb_device_descriptor* %25, null
  br i1 %tobool106, label %if.end108, label %NodeBlock35

if.end108:                                        ; preds = %if.then104
  br label %for.cond109

for.cond109:                                      ; preds = %for.inc, %if.end108
  %j.0 = phi i32 [ 0, %if.end108 ], [ %inc, %for.inc ]
  %r.0 = phi i32 [ 0, %if.end108 ], [ %r.2, %for.inc ]
  %cmp110 = icmp slt i32 %j.0, 3
  br i1 %cmp110, label %for.body112, label %for.end

for.body112:                                      ; preds = %for.cond109
  %bMaxPacketSize0 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %25, i32 0, i32 6
  store i8 0, i8* %bMaxPacketSize0, align 1, !tbaa !160
  %26 = bitcast %struct.usb_device_descriptor* %25 to i8*
  %27 = load i32, i32* @initial_descriptor_timeout, align 4, !tbaa !90
  %call113 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 -2147483520, i8 zeroext 6, i8 zeroext -128, i16 zeroext 256, i16 zeroext 0, i8* %26, i16 zeroext 64, i32 %27)
  %bMaxPacketSize0114 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %25, i32 0, i32 6
  %28 = load i8, i8* %bMaxPacketSize0114, align 1, !tbaa !160
  %conv115 = zext i8 %28 to i32
  %Pivot25 = icmp slt i32 %conv115, 32
  br i1 %Pivot25, label %NodeBlock12, label %NodeBlock22

NodeBlock22:                                      ; preds = %for.body112
  %Pivot23 = icmp slt i32 %conv115, 64
  br i1 %Pivot23, label %LeafBlock14, label %NodeBlock20

NodeBlock20:                                      ; preds = %NodeBlock22
  %Pivot21 = icmp slt i32 %conv115, 255
  br i1 %Pivot21, label %LeafBlock16, label %LeafBlock18

LeafBlock18:                                      ; preds = %NodeBlock20
  %SwitchLeaf19 = icmp eq i32 %conv115, 255
  br i1 %SwitchLeaf19, label %sw.bb116, label %sw.default122

LeafBlock16:                                      ; preds = %NodeBlock20
  %SwitchLeaf17 = icmp eq i32 %conv115, 64
  br i1 %SwitchLeaf17, label %sw.bb116, label %sw.default122

LeafBlock14:                                      ; preds = %NodeBlock22
  %SwitchLeaf15 = icmp eq i32 %conv115, 32
  br i1 %SwitchLeaf15, label %sw.bb116, label %sw.default122

NodeBlock12:                                      ; preds = %for.body112
  %Pivot13 = icmp slt i32 %conv115, 16
  br i1 %Pivot13, label %LeafBlock8, label %LeafBlock10

LeafBlock10:                                      ; preds = %NodeBlock12
  %SwitchLeaf11 = icmp eq i32 %conv115, 16
  br i1 %SwitchLeaf11, label %sw.bb116, label %sw.default122

LeafBlock8:                                       ; preds = %NodeBlock12
  %SwitchLeaf9 = icmp eq i32 %conv115, 8
  br i1 %SwitchLeaf9, label %sw.bb116, label %sw.default122

sw.bb116:                                         ; preds = %LeafBlock8, %LeafBlock10, %LeafBlock14, %LeafBlock16, %LeafBlock18
  %bDescriptorType = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %25, i32 0, i32 1
  %29 = load i8, i8* %bDescriptorType, align 1, !tbaa !161
  %conv117 = zext i8 %29 to i32
  %cmp118 = icmp eq i32 %conv117, 1
  br i1 %cmp118, label %sw.epilog127, label %sw.default122

sw.default122:                                    ; preds = %sw.bb116, %LeafBlock8, %LeafBlock10, %LeafBlock14, %LeafBlock16, %LeafBlock18
  %cmp123 = icmp eq i32 %call113, 0
  %.call113 = select i1 %cmp123, i32 -71, i32 %call113
  br label %sw.epilog127

sw.epilog127:                                     ; preds = %sw.default122, %sw.bb116
  %r.2 = phi i32 [ %.call113, %sw.default122 ], [ 0, %sw.bb116 ]
  %cmp128 = icmp eq i32 %r.2, 0
  br i1 %cmp128, label %for.end, label %for.inc

for.inc:                                          ; preds = %sw.epilog127
  %inc = add nsw i32 %j.0, 1
  br label %for.cond109

for.end:                                          ; preds = %sw.epilog127, %for.cond109
  %r.3 = phi i32 [ %r.2, %sw.epilog127 ], [ %r.0, %for.cond109 ]
  %bMaxPacketSize0132 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %25, i32 0, i32 6
  %30 = load i8, i8* %bMaxPacketSize0132, align 1, !tbaa !160
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bMaxPacketSize0133 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 6
  store i8 %30, i8* %bMaxPacketSize0133, align 1, !tbaa !162
  %31 = bitcast %struct.usb_device_descriptor* %25 to i8*
  call void @kfree(i8* %31)
  %call134 = call i32 @hub_port_reset(%struct.usb_hub* %hub, i32 %port1, %struct.usb_device* %udev, i32 %.delay.0, i1 zeroext false)
  %cmp135 = icmp slt i32 %call134, 0
  br i1 %cmp135, label %NodeBlock35, label %if.end138

if.end138:                                        ; preds = %for.end
  %speed139 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %32 = load i32, i32* %speed139, align 4, !tbaa !153
  %cmp140 = icmp ne i32 %9, %32
  br i1 %cmp140, label %do.body144, label %if.end165

do.body144:                                       ; preds = %if.end138
  %bf.load145 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_init.descriptor.241 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr146 = lshr i32 %bf.load145, 18
  %bf.clear147 = and i32 %bf.lshr146, 255
  %and148 = and i32 %bf.clear147, 1
  %tobool149 = icmp ne i32 %and148, 0
  %lnot150 = xor i1 %tobool149, true
  %lnot152 = xor i1 %lnot150, true
  %lnot.ext153 = zext i1 %lnot152 to i32
  %conv154 = sext i32 %lnot.ext153 to i64
  %expval155 = call i64 @llvm.expect.i64(i64 %conv154, i64 0)
  %tobool156 = icmp ne i64 %expval155, 0
  br i1 %tobool156, label %if.then157, label %NodeBlock35

if.then157:                                       ; preds = %do.body144
  %dev158 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call159 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_init.descriptor.241 to %struct._ddebug*), %struct.device* %dev158, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.235, i32 0, i32 0))
  br label %NodeBlock35

if.end165:                                        ; preds = %if.end138
  switch i32 %r.3, label %if.then170 [
    i32 0, label %if.end174
    i32 -19, label %NodeBlock35
  ]

if.then170:                                       ; preds = %if.end165
  %33 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %NodeBlock35

if.end174:                                        ; preds = %if.end165
  br label %NodeBlock35

NodeBlock35:                                      ; preds = %if.end174, %if.then170, %if.end165, %if.then157, %do.body144, %for.end, %if.then104
  %retval2.1 = phi i32 [ %call134, %if.end174 ], [ -12, %if.then104 ], [ %call134, %for.end ], [ -19, %if.then157 ], [ -19, %do.body144 ], [ -90, %if.end165 ], [ -90, %if.then170 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end174 ], [ 10, %if.then104 ], [ 2, %for.end ], [ 2, %if.then157 ], [ 2, %do.body144 ], [ 10, %if.end165 ], [ 10, %if.then170 ]
  %Pivot36 = icmp slt i32 %cleanup.dest.slot.0, 2
  br i1 %Pivot36, label %LeafBlock27, label %NodeBlock33

NodeBlock33:                                      ; preds = %NodeBlock35
  %Pivot34 = icmp slt i32 %cleanup.dest.slot.0, 10
  br i1 %Pivot34, label %LeafBlock29, label %LeafBlock31

LeafBlock31:                                      ; preds = %NodeBlock33
  %SwitchLeaf32 = icmp eq i32 %cleanup.dest.slot.0, 10
  br i1 %SwitchLeaf32, label %for.inc249, label %cleanup399

LeafBlock29:                                      ; preds = %NodeBlock33
  %SwitchLeaf30 = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf30, label %fail, label %cleanup399

LeafBlock27:                                      ; preds = %NodeBlock35
  %SwitchLeaf28 = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf28, label %if.end176, label %cleanup399

if.end176:                                        ; preds = %LeafBlock27, %land.lhs.true100, %for.body
  %retval2.2 = phi i32 [ %retval2.0, %land.lhs.true100 ], [ %retval2.0, %for.body ], [ %retval2.1, %LeafBlock27 ]
  %wusb = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load177 = load i16, i16* %wusb, align 4
  %bf.lshr178 = lshr i16 %bf.load177, 5
  %bf.clear179 = and i16 %bf.lshr178, 1
  %bf.cast = zext i16 %bf.clear179 to i32
  %cmp180 = icmp eq i32 %bf.cast, 0
  br i1 %cmp180, label %if.then182, label %if.end232

if.then182:                                       ; preds = %if.end176
  br label %for.cond183

for.cond183:                                      ; preds = %if.end191, %if.then182
  %retval2.3 = phi i32 [ %retval2.2, %if.then182 ], [ %call187, %if.end191 ]
  %j.1 = phi i32 [ 0, %if.then182 ], [ %inc193, %if.end191 ]
  %cmp184 = icmp slt i32 %j.1, 2
  br i1 %cmp184, label %for.body186, label %for.end194

for.body186:                                      ; preds = %for.cond183
  %call187 = call i32 @hub_set_address(%struct.usb_device* %udev, i32 %devnum.0)
  %cmp188 = icmp sge i32 %call187, 0
  br i1 %cmp188, label %for.end194, label %if.end191

if.end191:                                        ; preds = %for.body186
  call void @msleep(i32 200)
  %inc193 = add nsw i32 %j.1, 1
  br label %for.cond183

for.end194:                                       ; preds = %for.body186, %for.cond183
  %retval2.4 = phi i32 [ %call187, %for.body186 ], [ %retval2.3, %for.cond183 ]
  %cmp195 = icmp slt i32 %retval2.4, 0
  br i1 %cmp195, label %if.then197, label %if.end204

if.then197:                                       ; preds = %for.end194
  %cmp198 = icmp ne i32 %retval2.4, -19
  br i1 %cmp198, label %if.then200, label %fail

if.then200:                                       ; preds = %if.then197
  %34 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %fail

if.end204:                                        ; preds = %for.end194
  %speed205 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %35 = load i32, i32* %speed205, align 4, !tbaa !153
  %cmp206 = icmp eq i32 %35, 5
  br i1 %cmp206, label %if.then208, label %if.end219

if.then208:                                       ; preds = %if.end204
  %devnum209 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  %36 = load i32, i32* %devnum209, align 8, !tbaa !38
  %37 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %if.end219

if.end219:                                        ; preds = %if.then208, %if.end204
  %devnum.1 = phi i32 [ %36, %if.then208 ], [ %devnum.0, %if.end204 ]
  call void @msleep(i32 10)
  %div220 = sdiv i32 %retry_counter, 2
  %38 = load i8, i8* @old_scheme_first, align 1, !tbaa !43, !range !44
  %tobool221 = trunc i8 %38 to i1
  %conv222 = zext i1 %tobool221 to i32
  %cmp223 = icmp eq i32 %div220, %conv222
  br i1 %cmp223, label %land.lhs.true225, label %if.end232

land.lhs.true225:                                 ; preds = %if.end219
  %driver226 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %39 = load %struct.hc_driver*, %struct.hc_driver** %driver226, align 8, !tbaa !71
  %flags227 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %39, i32 0, i32 4
  %40 = load i32, i32* %flags227, align 8, !tbaa !159
  %and228 = and i32 %40, 64
  %tobool229 = icmp ne i32 %and228, 0
  br i1 %tobool229, label %if.end232, label %for.end251

if.end232:                                        ; preds = %land.lhs.true225, %if.end219, %if.end176
  %devnum.2 = phi i32 [ %devnum.0, %if.end176 ], [ %devnum.1, %land.lhs.true225 ], [ %devnum.1, %if.end219 ]
  %call233 = call i32 @usb_get_device_descriptor(%struct.usb_device* %udev, i32 8)
  %cmp234 = icmp slt i32 %call233, 8
  br i1 %cmp234, label %if.then236, label %for.end251

if.then236:                                       ; preds = %if.end232
  %cmp237 = icmp ne i32 %call233, -19
  br i1 %cmp237, label %if.then239, label %if.end242

if.then239:                                       ; preds = %if.then236
  %41 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end242

if.end242:                                        ; preds = %if.then239, %if.then236
  %cmp243 = icmp sge i32 %call233, 0
  %.call233 = select i1 %cmp243, i32 -90, i32 %call233
  br label %for.inc249

for.inc249:                                       ; preds = %if.end242, %LeafBlock31
  %retval2.6 = phi i32 [ %.call233, %if.end242 ], [ %retval2.1, %LeafBlock31 ]
  %devnum.3 = phi i32 [ %devnum.2, %if.end242 ], [ %devnum.0, %LeafBlock31 ]
  %inc250 = add nsw i32 %i.0, 1
  call void @msleep(i32 100)
  br label %for.cond

for.end251:                                       ; preds = %if.end232, %land.lhs.true225, %for.cond
  %retval2.7 = phi i32 [ %retval2.4, %land.lhs.true225 ], [ 0, %if.end232 ], [ %retval2.0, %for.cond ]
  %devnum.4 = phi i32 [ %devnum.1, %land.lhs.true225 ], [ %devnum.2, %if.end232 ], [ %devnum.0, %for.cond ]
  %tobool252 = icmp ne i32 %retval2.7, 0
  br i1 %tobool252, label %fail, label %if.end254

if.end254:                                        ; preds = %for.end251
  %phy = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 9
  %42 = load %struct.usb_phy*, %struct.usb_phy** %phy, align 8, !tbaa !163
  %tobool255 = icmp ne %struct.usb_phy* %42, null
  br i1 %tobool255, label %land.lhs.true256, label %if.end263

land.lhs.true256:                                 ; preds = %if.end254
  %parent257 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  %43 = load %struct.usb_device*, %struct.usb_device** %parent257, align 8, !tbaa !89
  %tobool258 = icmp ne %struct.usb_device* %43, null
  br i1 %tobool258, label %if.end263, label %if.then259

if.then259:                                       ; preds = %land.lhs.true256
  %phy260 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 9
  %44 = load %struct.usb_phy*, %struct.usb_phy** %phy260, align 8, !tbaa !163
  %speed261 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %45 = load i32, i32* %speed261, align 4, !tbaa !153
  call void @usb_phy_notify_connect(%struct.usb_phy* %44, i32 %45)
  br label %if.end263

if.end263:                                        ; preds = %if.then259, %land.lhs.true256, %if.end254
  %speed264 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %46 = load i32, i32* %speed264, align 4, !tbaa !153
  %cmp265 = icmp eq i32 %46, 5
  br i1 %cmp265, label %land.lhs.true267, label %if.end276

land.lhs.true267:                                 ; preds = %if.end263
  %descriptor268 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bcdUSB = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor268, i32 0, i32 2
  %47 = load i16, i16* %bcdUSB, align 2, !tbaa !164
  %conv269 = zext i16 %47 to i32
  %cmp270 = icmp slt i32 %conv269, 768
  br i1 %cmp270, label %if.then272, label %if.end276

if.then272:                                       ; preds = %land.lhs.true267
  %48 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %call275 = call i32 @hub_port_reset(%struct.usb_hub* %hub, i32 %port1, %struct.usb_device* %udev, i32 50, i1 zeroext true)
  br label %fail

if.end276:                                        ; preds = %land.lhs.true267, %if.end263
  %descriptor277 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bMaxPacketSize0278 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor277, i32 0, i32 6
  %49 = load i8, i8* %bMaxPacketSize0278, align 1, !tbaa !162
  %conv279 = zext i8 %49 to i32
  %cmp280 = icmp eq i32 %conv279, 255
  br i1 %cmp280, label %if.end290, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end276
  %speed282 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %50 = load i32, i32* %speed282, align 4, !tbaa !153
  %cmp283 = icmp eq i32 %50, 5
  br i1 %cmp283, label %if.end290, label %if.else286

if.else286:                                       ; preds = %lor.lhs.false
  %descriptor287 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bMaxPacketSize0288 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor287, i32 0, i32 6
  %51 = load i8, i8* %bMaxPacketSize0288, align 1, !tbaa !162
  %conv289 = zext i8 %51 to i32
  br label %if.end290

if.end290:                                        ; preds = %if.else286, %lor.lhs.false, %if.end276
  %i.1 = phi i32 [ %conv289, %if.else286 ], [ 512, %lor.lhs.false ], [ 512, %if.end276 ]
  %ep0291 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 10
  %desc292 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep0291, i32 0, i32 0
  %call293 = call i32 @usb_endpoint_maxp(%struct.usb_endpoint_descriptor* %desc292)
  %cmp294 = icmp ne i32 %call293, %i.1
  br i1 %cmp294, label %if.then296, label %if.end350

if.then296:                                       ; preds = %if.end290
  %speed297 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %52 = load i32, i32* %speed297, align 4, !tbaa !153
  %cmp298 = icmp eq i32 %52, 1
  br i1 %cmp298, label %if.then312, label %lor.lhs.false300

lor.lhs.false300:                                 ; preds = %if.then296
  %53 = sub i32 %i.1, 8
  %54 = lshr i32 %53, 3
  %55 = shl i32 %53, 29
  %56 = or i32 %54, %55
  switch i32 %56, label %if.then312 [
    i32 0, label %if.end315
    i32 1, label %if.end315
    i32 3, label %if.end315
    i32 7, label %if.end315
  ]

if.then312:                                       ; preds = %lor.lhs.false300, %if.then296
  %57 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %fail

if.end315:                                        ; preds = %lor.lhs.false300, %lor.lhs.false300, %lor.lhs.false300, %lor.lhs.false300
  %speed316 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %58 = load i32, i32* %speed316, align 4, !tbaa !153
  %cmp317 = icmp eq i32 %58, 2
  br i1 %cmp317, label %do.body321, label %if.else342

do.body321:                                       ; preds = %if.end315
  %bf.load322 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_init.descriptor.248 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr323 = lshr i32 %bf.load322, 18
  %bf.clear324 = and i32 %bf.lshr323, 255
  %and325 = and i32 %bf.clear324, 1
  %tobool326 = icmp ne i32 %and325, 0
  %lnot327 = xor i1 %tobool326, true
  %lnot329 = xor i1 %lnot327, true
  %lnot.ext330 = zext i1 %lnot329 to i32
  %conv331 = sext i32 %lnot.ext330 to i64
  %expval332 = call i64 @llvm.expect.i64(i64 %conv331, i64 0)
  %tobool333 = icmp ne i64 %expval332, 0
  br i1 %tobool333, label %if.then334, label %if.end345

if.then334:                                       ; preds = %do.body321
  %dev335 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call336 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_init.descriptor.248 to %struct._ddebug*), %struct.device* %dev335, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.249, i32 0, i32 0), i32 %i.1)
  br label %if.end345

if.else342:                                       ; preds = %if.end315
  %59 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end345

if.end345:                                        ; preds = %if.else342, %if.then334, %do.body321
  %conv346 = trunc i32 %i.1 to i16
  %ep0347 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 10
  %desc348 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep0347, i32 0, i32 0
  %wMaxPacketSize349 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc348, i32 0, i32 4
  store i16 %conv346, i16* %wMaxPacketSize349, align 4, !tbaa !155
  call void @usb_ep0_reinit(%struct.usb_device* %udev)
  br label %if.end350

if.end350:                                        ; preds = %if.end345, %if.end290
  %call351 = call i32 @usb_get_device_descriptor(%struct.usb_device* %udev, i32 18)
  %cmp352 = icmp slt i32 %call351, 18
  br i1 %cmp352, label %if.then354, label %if.end365

if.then354:                                       ; preds = %if.end350
  %cmp355 = icmp ne i32 %call351, -19
  br i1 %cmp355, label %if.then357, label %if.end360

if.then357:                                       ; preds = %if.then354
  %60 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end360

if.end360:                                        ; preds = %if.then357, %if.then354
  %cmp361 = icmp sge i32 %call351, 0
  %.call351 = select i1 %cmp361, i32 -42, i32 %call351
  br label %fail

if.end365:                                        ; preds = %if.end350
  %wusb366 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load367 = load i16, i16* %wusb366, align 4
  %bf.lshr368 = lshr i16 %bf.load367, 5
  %bf.clear369 = and i16 %bf.lshr368, 1
  %bf.cast370 = zext i16 %bf.clear369 to i32
  %cmp371 = icmp eq i32 %bf.cast370, 0
  br i1 %cmp371, label %land.lhs.true373, label %if.end387

land.lhs.true373:                                 ; preds = %if.end365
  %descriptor374 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bcdUSB375 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor374, i32 0, i32 2
  %61 = load i16, i16* %bcdUSB375, align 2, !tbaa !164
  %conv376 = zext i16 %61 to i32
  %cmp377 = icmp sge i32 %conv376, 513
  br i1 %cmp377, label %if.then379, label %if.end387

if.then379:                                       ; preds = %land.lhs.true373
  %call380 = call i32 @usb_get_bos_descriptor(%struct.usb_device* %udev)
  %tobool381 = icmp ne i32 %call380, 0
  br i1 %tobool381, label %if.end387, label %if.then382

if.then382:                                       ; preds = %if.then379
  %call383 = call i32 @usb_device_supports_lpm(%struct.usb_device* %udev)
  %lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %62 = trunc i32 %call383 to i16
  %bf.load384 = load i16, i16* %lpm_capable, align 4
  %bf.value = and i16 %62, 1
  %bf.shl = shl i16 %bf.value, 6
  %bf.clear385 = and i16 %bf.load384, -65
  %bf.set = or i16 %bf.clear385, %bf.shl
  store i16 %bf.set, i16* %lpm_capable, align 4
  call void @usb_set_lpm_parameters(%struct.usb_device* %udev)
  br label %if.end387

if.end387:                                        ; preds = %if.then382, %if.then379, %land.lhs.true373, %if.end365
  %driver388 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %63 = load %struct.hc_driver*, %struct.hc_driver** %driver388, align 8, !tbaa !71
  %update_device = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %63, i32 0, i32 37
  %64 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %update_device, align 8, !tbaa !165
  %tobool389 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*)* %64, null
  br i1 %tobool389, label %if.then390, label %fail

if.then390:                                       ; preds = %if.end387
  %driver391 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %65 = load %struct.hc_driver*, %struct.hc_driver** %driver391, align 8, !tbaa !71
  %update_device392 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %65, i32 0, i32 37
  %66 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %update_device392, align 8, !tbaa !165
  %call393 = call i32 %66(%struct.usb_hcd* %call, %struct.usb_device* %udev)
  br label %fail

fail:                                             ; preds = %if.then390, %if.end387, %if.end360, %if.then312, %if.then272, %for.end251, %if.then200, %if.then197, %LeafBlock29, %if.then85, %LeafBlock, %LeafBlock1, %if.then32, %do.body25, %if.end9
  %retval2.9 = phi i32 [ -22, %if.then272 ], [ -90, %if.then312 ], [ %.call351, %if.end360 ], [ %retval2.1, %LeafBlock29 ], [ -22, %if.then85 ], [ %call14, %if.end9 ], [ -19, %if.then32 ], [ -19, %do.body25 ], [ -19, %LeafBlock ], [ -19, %LeafBlock1 ], [ %retval2.4, %if.then200 ], [ %retval2.4, %if.then197 ], [ %retval2.7, %for.end251 ], [ 0, %if.then390 ], [ 0, %if.end387 ]
  %devnum.5 = phi i32 [ %devnum.4, %if.then272 ], [ %devnum.4, %if.then312 ], [ %devnum.4, %if.end360 ], [ %devnum.0, %LeafBlock29 ], [ %3, %if.then85 ], [ %3, %if.end9 ], [ %3, %if.then32 ], [ %3, %do.body25 ], [ %3, %LeafBlock ], [ %3, %LeafBlock1 ], [ %devnum.0, %if.then200 ], [ %devnum.0, %if.then197 ], [ %devnum.4, %for.end251 ], [ %devnum.4, %if.then390 ], [ %devnum.4, %if.end387 ]
  %tobool395 = icmp ne i32 %retval2.9, 0
  br i1 %tobool395, label %if.then396, label %if.end398

if.then396:                                       ; preds = %fail
  call void @hub_port_disable(%struct.usb_hub* %hub, i32 %port1, i32 0)
  call void @update_devnum(%struct.usb_device* %udev, i32 %devnum.5)
  br label %if.end398

if.end398:                                        ; preds = %if.then396, %fail
  call void @mutex_unlock(%struct.mutex* @hub_port_init.usb_address0_mutex)
  br label %cleanup399

cleanup399:                                       ; preds = %if.end398, %LeafBlock27, %LeafBlock29, %LeafBlock31
  %retval.0 = phi i32 [ %retval2.9, %if.end398 ], [ undef, %LeafBlock31 ], [ undef, %LeafBlock27 ], [ undef, %LeafBlock29 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @descriptors_changed(%struct.usb_device* %udev, %struct.usb_device_descriptor* %old_device_descriptor) #0 {
entry:
  %_max1 = alloca i32, align 4
  %_max2 = alloca i32, align 4
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %0 = bitcast %struct.usb_device_descriptor* %descriptor to i8*
  %1 = bitcast %struct.usb_device_descriptor* %old_device_descriptor to i8*
  %call = call i32 @memcmp(i8* %0, i8* %1, i64 18)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %serial = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 26
  %2 = load i8*, i8** %serial, align 8, !tbaa !41
  %tobool = icmp ne i8* %2, null
  br i1 %tobool, label %if.then1, label %if.end4

if.then1:                                         ; preds = %if.end
  %serial2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 26
  %3 = load i8*, i8** %serial2, align 8, !tbaa !41
  %call3 = call i64 @strlen(i8* %3)
  %add = add i64 %call3, 1
  %conv = trunc i64 %add to i32
  br label %if.end4

if.end4:                                          ; preds = %if.then1, %if.end
  %serial_len.0 = phi i32 [ %conv, %if.then1 ], [ 0, %if.end ]
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end4
  %len.0 = phi i32 [ %serial_len.0, %if.end4 ], [ %cond, %for.body ]
  %index.0 = phi i32 [ 0, %if.end4 ], [ %inc, %for.body ]
  %descriptor5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor5, i32 0, i32 13
  %4 = load i8, i8* %bNumConfigurations, align 1, !tbaa !166
  %conv6 = zext i8 %4 to i32
  %cmp7 = icmp ult i32 %index.0, %conv6
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 14
  %5 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !167
  %idxprom = zext i32 %index.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i64 %idxprom
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx, i32 0, i32 0
  %wTotalLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 2
  %6 = load i16, i16* %wTotalLength, align 2, !tbaa !168
  %conv9 = zext i16 %6 to i32
  %7 = bitcast i32* %_max1 to i8*
  store i32 %len.0, i32* %_max1, align 4, !tbaa !90
  %8 = bitcast i32* %_max2 to i8*
  store i32 %conv9, i32* %_max2, align 4, !tbaa !90
  %9 = load i32, i32* %_max1, align 4, !tbaa !90
  %10 = load i32, i32* %_max2, align 4, !tbaa !90
  %cmp12 = icmp ugt i32 %9, %10
  %11 = load i32, i32* %_max1, align 4
  %12 = load i32, i32* %_max2, align 4
  %cond = select i1 %cmp12, i32 %11, i32 %12
  %13 = bitcast i32* %_max2 to i8*
  %14 = bitcast i32* %_max1 to i8*
  %inc = add i32 %index.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %conv14 = zext i32 %len.0 to i64
  %call.i = call i8* @__kmalloc(i64 %conv14, i32 16) #8
  %cmp16 = icmp eq i8* %call.i, null
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %for.end
  %15 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end20:                                         ; preds = %for.end
  br label %for.cond21

for.cond21:                                       ; preds = %for.inc82, %if.end20
  %index.1 = phi i32 [ 0, %if.end20 ], [ %inc83, %for.inc82 ]
  %descriptor22 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bNumConfigurations23 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor22, i32 0, i32 13
  %16 = load i8, i8* %bNumConfigurations23, align 1, !tbaa !166
  %conv24 = zext i8 %16 to i32
  %cmp25 = icmp ult i32 %index.1, %conv24
  br i1 %cmp25, label %for.body27, label %for.end84

for.body27:                                       ; preds = %for.cond21
  %config28 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 14
  %17 = load %struct.usb_host_config*, %struct.usb_host_config** %config28, align 8, !tbaa !167
  %idxprom29 = zext i32 %index.1 to i64
  %arrayidx30 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %17, i64 %idxprom29
  %desc31 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx30, i32 0, i32 0
  %wTotalLength32 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc31, i32 0, i32 2
  %18 = load i16, i16* %wTotalLength32, align 2, !tbaa !168
  %conv33 = zext i16 %18 to i32
  %conv34 = trunc i32 %index.1 to i8
  %call35 = call i32 @usb_get_descriptor(%struct.usb_device* %udev, i8 zeroext 2, i8 zeroext %conv34, i8* %call.i, i32 %conv33)
  %cmp36 = icmp ne i32 %call35, %conv33
  br i1 %cmp36, label %do.body39, label %if.end50

do.body39:                                        ; preds = %for.body27
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @descriptors_changed.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool40 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool40, true
  %lnot41 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot41 to i32
  %conv42 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv42, i64 0)
  %tobool43 = icmp ne i64 %expval, 0
  br i1 %tobool43, label %if.then44, label %for.end84

if.then44:                                        ; preds = %do.body39
  %dev45 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call46 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @descriptors_changed.descriptor to %struct._ddebug*), %struct.device* %dev45, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.267, i32 0, i32 0), i32 %index.1, i32 %call35)
  br label %for.end84

if.end50:                                         ; preds = %for.body27
  %rawdescriptors = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 18
  %19 = load i8**, i8*** %rawdescriptors, align 8, !tbaa !169
  %idxprom51 = zext i32 %index.1 to i64
  %arrayidx52 = getelementptr inbounds i8*, i8** %19, i64 %idxprom51
  %20 = load i8*, i8** %arrayidx52, align 8, !tbaa !48
  %conv53 = zext i32 %conv33 to i64
  %call54 = call i32 @memcmp(i8* %call.i, i8* %20, i64 %conv53)
  %cmp55 = icmp ne i32 %call54, 0
  br i1 %cmp55, label %do.body59, label %for.inc82

do.body59:                                        ; preds = %if.end50
  %bf.load60 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @descriptors_changed.descriptor.268 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr61 = lshr i32 %bf.load60, 18
  %bf.clear62 = and i32 %bf.lshr61, 255
  %and63 = and i32 %bf.clear62, 1
  %tobool64 = icmp ne i32 %and63, 0
  %lnot65 = xor i1 %tobool64, true
  %lnot67 = xor i1 %lnot65, true
  %lnot.ext68 = zext i1 %lnot67 to i32
  %conv69 = sext i32 %lnot.ext68 to i64
  %expval70 = call i64 @llvm.expect.i64(i64 %conv69, i64 0)
  %tobool71 = icmp ne i64 %expval70, 0
  br i1 %tobool71, label %if.then72, label %for.end84

if.then72:                                        ; preds = %do.body59
  %dev73 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %21 = bitcast i8* %call.i to %struct.usb_config_descriptor*
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %21, i32 0, i32 4
  %22 = load i8, i8* %bConfigurationValue, align 1, !tbaa !170
  %conv74 = zext i8 %22 to i32
  %call75 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @descriptors_changed.descriptor.268 to %struct._ddebug*), %struct.device* %dev73, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.269, i32 0, i32 0), i32 %index.1, i32 %conv74)
  br label %for.end84

for.inc82:                                        ; preds = %if.end50
  %inc83 = add i32 %index.1, 1
  br label %for.cond21

for.end84:                                        ; preds = %if.then72, %do.body59, %if.then44, %do.body39, %for.cond21
  %changed.0 = phi i32 [ 1, %if.then44 ], [ 1, %do.body39 ], [ 1, %if.then72 ], [ 1, %do.body59 ], [ 0, %for.cond21 ]
  %tobool85 = icmp eq i32 %changed.0, 0
  %tobool86 = icmp ne i32 %serial_len.0, 0
  %or.cond = and i1 %tobool85, %tobool86
  br i1 %or.cond, label %if.then87, label %if.end148

if.then87:                                        ; preds = %for.end84
  %descriptor88 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %iSerialNumber = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor88, i32 0, i32 12
  %23 = load i8, i8* %iSerialNumber, align 8, !tbaa !171
  %conv89 = zext i8 %23 to i32
  %conv90 = zext i32 %serial_len.0 to i64
  %call91 = call i32 @usb_string(%struct.usb_device* %udev, i32 %conv89, i8* %call.i, i64 %conv90)
  %add92 = add nsw i32 %call91, 1
  %cmp93 = icmp ne i32 %add92, %serial_len.0
  br i1 %cmp93, label %do.body97, label %if.else

do.body97:                                        ; preds = %if.then87
  %bf.load98 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @descriptors_changed.descriptor.270 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr99 = lshr i32 %bf.load98, 18
  %bf.clear100 = and i32 %bf.lshr99, 255
  %and101 = and i32 %bf.clear100, 1
  %tobool102 = icmp ne i32 %and101, 0
  %lnot103 = xor i1 %tobool102, true
  %lnot105 = xor i1 %lnot103, true
  %lnot.ext106 = zext i1 %lnot105 to i32
  %conv107 = sext i32 %lnot.ext106 to i64
  %expval108 = call i64 @llvm.expect.i64(i64 %conv107, i64 0)
  %tobool109 = icmp ne i64 %expval108, 0
  br i1 %tobool109, label %if.then110, label %if.end148

if.then110:                                       ; preds = %do.body97
  %dev111 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call112 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @descriptors_changed.descriptor.270 to %struct._ddebug*), %struct.device* %dev111, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.271, i32 0, i32 0), i32 %call91)
  br label %if.end148

if.else:                                          ; preds = %if.then87
  %serial118 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 26
  %24 = load i8*, i8** %serial118, align 8, !tbaa !41
  %conv119 = sext i32 %call91 to i64
  %call120 = call i32 @memcmp(i8* %call.i, i8* %24, i64 %conv119)
  %cmp121 = icmp ne i32 %call120, 0
  br i1 %cmp121, label %do.body125, label %if.end148

do.body125:                                       ; preds = %if.else
  %bf.load126 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @descriptors_changed.descriptor.272 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr127 = lshr i32 %bf.load126, 18
  %bf.clear128 = and i32 %bf.lshr127, 255
  %and129 = and i32 %bf.clear128, 1
  %tobool130 = icmp ne i32 %and129, 0
  %lnot131 = xor i1 %tobool130, true
  %lnot133 = xor i1 %lnot131, true
  %lnot.ext134 = zext i1 %lnot133 to i32
  %conv135 = sext i32 %lnot.ext134 to i64
  %expval136 = call i64 @llvm.expect.i64(i64 %conv135, i64 0)
  %tobool137 = icmp ne i64 %expval136, 0
  br i1 %tobool137, label %if.then138, label %if.end148

if.then138:                                       ; preds = %do.body125
  %dev139 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call140 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @descriptors_changed.descriptor.272 to %struct._ddebug*), %struct.device* %dev139, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.273, i32 0, i32 0))
  br label %if.end148

if.end148:                                        ; preds = %if.then138, %do.body125, %if.else, %if.then110, %do.body97, %for.end84
  %changed.3 = phi i32 [ %changed.0, %for.end84 ], [ 1, %if.then110 ], [ 1, %do.body97 ], [ %changed.0, %if.else ], [ 1, %if.then138 ], [ 1, %do.body125 ]
  call void @kfree(i8* %call.i)
  br label %cleanup

cleanup:                                          ; preds = %if.end148, %if.then18, %entry
  %retval.0 = phi i32 [ 1, %if.then18 ], [ %changed.3, %if.end148 ], [ 1, %entry ]
  ret i32 %retval.0
}

declare i32 @_dev_info(%struct.device*, i8*, ...) #2

declare void @mutex_lock_nested(%struct.mutex*, i32) #2

declare i32 @dev_warn(%struct.device*, i8*, ...) #2

declare void @mutex_unlock(%struct.mutex*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__create_pipe(%struct.usb_device* %dev, i32 %endpoint) #1 {
entry:
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 0
  %0 = load i32, i32* %devnum, align 8, !tbaa !38
  %shl = shl i32 %0, 8
  %shl1 = shl i32 %endpoint, 15
  %or = or i32 %shl, %shl1
  ret i32 %or
}

; Function Attrs: nounwind uwtable
define void @usb_set_device_state(%struct.usb_device* %udev, i32 %new_state) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* @device_state_lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %4 = load i32, i32* %state, align 8, !tbaa !50
  %cmp5 = icmp eq i32 %4, 0
  br i1 %cmp5, label %if.end45, label %if.else

if.else:                                          ; preds = %entry
  %cmp7 = icmp ne i32 %new_state, 0
  br i1 %cmp7, label %if.then9, label %if.else43

if.then9:                                         ; preds = %if.else
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %5 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool = icmp ne %struct.usb_device* %5, null
  br i1 %tobool, label %if.then10, label %if.end24

if.then10:                                        ; preds = %if.then9
  %state11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %6 = load i32, i32* %state11, align 8, !tbaa !50
  %cmp12 = icmp eq i32 %6, 8
  %cmp14 = icmp eq i32 %new_state, 8
  %or.cond = or i1 %cmp12, %cmp14
  br i1 %or.cond, label %if.end24, label %if.else17

if.else17:                                        ; preds = %if.then10
  %cmp18 = icmp eq i32 %new_state, 7
  br i1 %cmp18, label %if.then20, label %if.end24

if.then20:                                        ; preds = %if.else17
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %7 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %7, i32 0, i32 0
  %bmAttributes = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 6
  %8 = load i8, i8* %bmAttributes, align 1, !tbaa !172
  %conv21 = zext i8 %8 to i32
  %and = and i32 %conv21, 32
  br label %if.end24

if.end24:                                         ; preds = %if.then20, %if.else17, %if.then10, %if.then9
  %wakeup.2 = phi i32 [ -1, %if.then9 ], [ -1, %if.then10 ], [ %and, %if.then20 ], [ 0, %if.else17 ]
  %state25 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %9 = load i32, i32* %state25, align 8, !tbaa !50
  %cmp26 = icmp eq i32 %9, 8
  %cmp28 = icmp ne i32 %new_state, 8
  %or.cond1 = and i1 %cmp26, %cmp28
  br i1 %or.cond1, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.end24
  %10 = load volatile i64, i64* @jiffies, align 8, !tbaa !49
  %active_duration = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 31
  %11 = load i64, i64* %active_duration, align 8, !tbaa !92
  %sub = sub i64 %11, %10
  store i64 %sub, i64* %active_duration, align 8, !tbaa !92
  br label %if.end41

if.else31:                                        ; preds = %if.end24
  %cmp32 = icmp eq i32 %new_state, 8
  br i1 %cmp32, label %land.lhs.true34, label %if.end41

land.lhs.true34:                                  ; preds = %if.else31
  %state35 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %12 = load i32, i32* %state35, align 8, !tbaa !50
  %cmp36 = icmp ne i32 %12, 8
  br i1 %cmp36, label %if.then38, label %if.end41

if.then38:                                        ; preds = %land.lhs.true34
  %13 = load volatile i64, i64* @jiffies, align 8, !tbaa !49
  %active_duration39 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 31
  %14 = load i64, i64* %active_duration39, align 8, !tbaa !92
  %add = add i64 %14, %13
  store i64 %add, i64* %active_duration39, align 8, !tbaa !92
  br label %if.end41

if.end41:                                         ; preds = %if.then38, %land.lhs.true34, %if.else31, %if.then30
  %state42 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  store i32 %new_state, i32* %state42, align 8, !tbaa !50
  br label %if.end45

if.else43:                                        ; preds = %if.else
  call void @recursively_mark_NOTATTACHED(%struct.usb_device* %udev)
  br label %if.end45

if.end45:                                         ; preds = %if.else43, %if.end41, %entry
  %wakeup.4 = phi i32 [ -1, %entry ], [ %wakeup.2, %if.end41 ], [ -1, %if.else43 ]
  call void @spin_unlock_irqrestore(%struct.spinlock* @device_state_lock, i64 %call2)
  %cmp46 = icmp sge i32 %wakeup.4, 0
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.end45
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %tobool49 = icmp ne i32 %wakeup.4, 0
  call void @device_set_wakeup_capable(%struct.device* %dev, i1 zeroext %tobool49)
  br label %if.end50

if.end50:                                         ; preds = %if.then48, %if.end45
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_unlocked_enable_lpm(%struct.usb_device* %udev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.11(%struct.usb_bus* %0)
  %tobool = icmp ne %struct.usb_hcd* %call, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %1 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !146
  call void @mutex_lock_nested(%struct.mutex* %1, i32 0)
  call void @usb_enable_lpm(%struct.usb_device* %udev)
  %bandwidth_mutex1 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %2 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex1, align 8, !tbaa !146
  call void @mutex_unlock(%struct.mutex* %2)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_enable_ltm(%struct.usb_device* %udev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.11(%struct.usb_bus* %0)
  %self = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 10
  %1 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !151
  %call1 = call zeroext i1 @usb_device_supports_ltm(%struct.usb_device* %1)
  br i1 %call1, label %lor.lhs.false, label %cleanup.cont

lor.lhs.false:                                    ; preds = %entry
  %call2 = call zeroext i1 @usb_device_supports_ltm(%struct.usb_device* %udev)
  br i1 %call2, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %lor.lhs.false
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %if.end4, label %cleanup.cont

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or = or i32 -2147483648, %call5
  %call6 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext 3, i8 zeroext 0, i16 zeroext 50, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end4, %if.end, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_port_logical_disconnect(%struct.usb_hub* %hub, i32 %port1) #0 {
entry:
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_logical_disconnect.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end4

if.then:                                          ; preds = %entry
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !173
  %call = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_logical_disconnect.descriptor to %struct._ddebug*), %struct.device* %0, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.44, i32 0, i32 0), i32 %port1)
  br label %do.end4

do.end4:                                          ; preds = %if.then, %entry
  call void @hub_port_disable(%struct.usb_hub* %hub, i32 %port1, i32 1)
  %change_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 11
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i32 %port1, i64* %arraydecay) #8, !srcloc !144
  call void @kick_khubd(%struct.usb_hub* %hub)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_port_disable(%struct.usb_hub* %hub, i32 %port1, i32 %set_state) #0 {
entry:
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !152
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  %1 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %1, i64 %idxprom
  %2 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %2, i32 0, i32 0
  %3 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_device* %3, null
  %tobool2 = icmp ne i32 %set_state, 0
  %or.cond = and i1 %tobool, %tobool2
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %ports3 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  %4 = load %struct.usb_port**, %struct.usb_port*** %ports3, align 8, !tbaa !98
  %sub4 = sub nsw i32 %port1, 1
  %idxprom5 = sext i32 %sub4 to i64
  %arrayidx6 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %4, i64 %idxprom5
  %5 = load %struct.usb_port*, %struct.usb_port** %arrayidx6, align 8, !tbaa !48
  %child7 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %5, i32 0, i32 0
  %6 = load %struct.usb_device*, %struct.usb_device** %child7, align 8, !tbaa !102
  call void @usb_set_device_state(%struct.usb_device* %6, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %error = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 7
  %7 = load i32, i32* %error, align 8, !tbaa !174
  %tobool8 = icmp ne i32 %7, 0
  br i1 %tobool8, label %if.end16, label %if.then9

if.then9:                                         ; preds = %if.end
  %hdev10 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %8 = load %struct.usb_device*, %struct.usb_device** %hdev10, align 8, !tbaa !152
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %8)
  %tobool11 = icmp ne i32 %call, 0
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.then9
  %call13 = call i32 @hub_usb3_port_disable(%struct.usb_hub* %hub, i32 %port1)
  br label %if.end16

if.else:                                          ; preds = %if.then9
  %call14 = call i32 @usb_clear_port_feature(%struct.usb_device* %0, i32 %port1, i32 1)
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then12, %if.end
  %ret.1 = phi i32 [ 0, %if.end ], [ %call13, %if.then12 ], [ %call14, %if.else ]
  switch i32 %ret.1, label %if.then19 [
    i32 0, label %if.end21
    i32 -19, label %if.end21
  ]

if.then19:                                        ; preds = %if.end16
  %9 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %if.end16, %if.end16
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @kick_khubd(%struct.usb_hub* %hub) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* @hub_event_lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %disconnected = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %bf.load = load i8, i8* %disconnected, align 4
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %event_list = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 9
  %call5 = call i32 @list_empty(%struct.list_head* %event_list)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %event_list7 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 9
  call void @list_add_tail(%struct.list_head* %event_list7, %struct.list_head* @hub_event_list)
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %4 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !173
  %5 = bitcast %struct.device* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 -48
  %6 = bitcast i8* %add.ptr to %struct.usb_interface*
  call void @usb_autopm_get_interface_no_resume(%struct.usb_interface* %6)
  call void @__wake_up(%struct.__wait_queue_head* @khubd_wait, i32 3, i32 1, i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  call void @spin_unlock_irqrestore(%struct.spinlock* @hub_event_lock, i64 %call2)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #2 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty(%struct.list_head* %head) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !95
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #1 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !96
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #2 section ".spinlock.text"

declare void @__list_add(%struct.list_head*, %struct.list_head*, %struct.list_head*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hub_is_superspeed(%struct.usb_device* %hdev) #1 {
entry:
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 12
  %bDeviceProtocol = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 5
  %0 = load i8, i8* %bDeviceProtocol, align 2, !tbaa !175
  %conv = zext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 3
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_usb3_port_disable(%struct.usb_hub* %hub, i32 %port1) #0 {
entry:
  %portchange = alloca i16, align 2
  %portstatus = alloca i16, align 2
  %0 = bitcast i16* %portchange to i8*
  %1 = bitcast i16* %portstatus to i8*
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @hub_set_port_link_state(%struct.usb_hub* %hub, i32 %port1, i32 128)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %if.end15, %if.end4
  %total_time.0 = phi i32 [ 0, %if.end4 ], [ %add, %if.end15 ]
  %call5 = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1, i16* %portstatus, i16* %portchange)
  %cmp = icmp slt i32 %call5, 0
  br i1 %cmp, label %cleanup, label %if.end7

if.end7:                                          ; preds = %for.cond
  %3 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv = zext i16 %3 to i32
  %and = and i32 %conv, 480
  %cmp8 = icmp eq i32 %and, 128
  %cmp12 = icmp sge i32 %total_time.0, 2000
  %or.cond = or i1 %cmp8, %cmp12
  br i1 %or.cond, label %for.end, label %if.end15

if.end15:                                         ; preds = %if.end7
  call void @msleep(i32 25)
  %add = add nsw i32 %total_time.0, 25
  br label %for.cond

for.end:                                          ; preds = %if.end7
  %cmp16 = icmp sge i32 %total_time.0, 2000
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %for.end
  %4 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %for.end
  %call21 = call i32 @hub_set_port_link_state(%struct.usb_hub* %hub, i32 %port1, i32 160)
  br label %cleanup

cleanup:                                          ; preds = %if.end20, %for.cond, %if.end, %entry
  %retval.0 = phi i32 [ %call21, %if.end20 ], [ -22, %entry ], [ %call1, %if.end ], [ %call5, %for.cond ]
  %5 = bitcast i16* %portstatus to i8*
  %6 = bitcast i16* %portchange to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_clear_port_feature(%struct.usb_device* %hdev, i32 %port1, i32 %feature) #0 {
entry:
  %call = call i32 @__create_pipe(%struct.usb_device* %hdev, i32 0)
  %or = or i32 -2147483648, %call
  %conv = trunc i32 %feature to i16
  %conv1 = trunc i32 %port1 to i16
  %call2 = call i32 @usb_control_msg(%struct.usb_device* %hdev, i32 %or, i8 zeroext 1, i8 zeroext 35, i16 zeroext %conv, i16 zeroext %conv1, i8* null, i16 zeroext 0, i32 1000)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_set_port_link_state(%struct.usb_hub* %hub, i32 %port1, i32 %link_status) #0 {
entry:
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %shl = shl i32 %link_status, 3
  %or = or i32 %port1, %shl
  %call = call i32 @set_port_feature(%struct.usb_device* %0, i32 %or, i32 5)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1, i16* %status, i16* %change) #0 {
entry:
  %status_mutex = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 6
  call void @mutex_lock_nested(%struct.mutex* %status_mutex, i32 0)
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %status1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  %1 = load %union.anon.48*, %union.anon.48** %status1, align 8, !tbaa !176
  %port = bitcast %union.anon.48* %1 to %struct.usb_hub_status*
  %call = call i32 @get_port_status(%struct.usb_device* %0, i32 %port1, %struct.usb_hub_status* %port)
  %cmp = icmp slt i32 %call, 4
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %cmp2 = icmp ne i32 %call, -19
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %2 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %cmp5 = icmp sge i32 %call, 0
  %.call = select i1 %cmp5, i32 -5, i32 %call
  br label %if.end12

if.else:                                          ; preds = %entry
  %status8 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  %3 = load %union.anon.48*, %union.anon.48** %status8, align 8, !tbaa !176
  %port9 = bitcast %union.anon.48* %3 to %struct.usb_hub_status*
  %wPortStatus = getelementptr inbounds %struct.usb_hub_status, %struct.usb_hub_status* %port9, i32 0, i32 0
  %4 = load i16, i16* %wPortStatus, align 1, !tbaa !84
  store i16 %4, i16* %status, align 2, !tbaa !143
  %status10 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  %5 = load %union.anon.48*, %union.anon.48** %status10, align 8, !tbaa !176
  %port11 = bitcast %union.anon.48* %5 to %struct.usb_hub_status*
  %wPortChange = getelementptr inbounds %struct.usb_hub_status, %struct.usb_hub_status* %port11, i32 0, i32 1
  %6 = load i16, i16* %wPortChange, align 1, !tbaa !84
  store i16 %6, i16* %change, align 2, !tbaa !143
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.end
  %ret.1 = phi i32 [ %.call, %if.end ], [ 0, %if.else ]
  %status_mutex13 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 6
  call void @mutex_unlock(%struct.mutex* %status_mutex13)
  ret i32 %ret.1
}

; Function Attrs: nounwind uwtable
define internal i32 @get_port_status(%struct.usb_device* %hdev, i32 %port1, %struct.usb_hub_status* %data) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %status.0 = phi i32 [ -110, %entry ], [ %call4, %for.body ]
  %cmp = icmp slt i32 %i.0, 5
  br i1 %cmp, label %land.rhs, label %for.end

land.rhs:                                         ; preds = %for.cond
  %cmp1 = icmp eq i32 %status.0, -110
  %cmp2 = icmp eq i32 %status.0, -32
  %.cmp2 = select i1 %cmp1, i1 true, i1 %cmp2
  br i1 %.cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %land.rhs
  %call = call i32 @__create_pipe(%struct.usb_device* %hdev, i32 0)
  %or = or i32 -2147483648, %call
  %or3 = or i32 %or, 128
  %conv = trunc i32 %port1 to i16
  %0 = bitcast %struct.usb_hub_status* %data to i8*
  %call4 = call i32 @usb_control_msg(%struct.usb_device* %hdev, i32 %or3, i8 zeroext 0, i8 zeroext -93, i16 zeroext 0, i16 zeroext %conv, i8* %0, i16 zeroext 4, i32 1000)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %land.rhs, %for.cond
  ret i32 %status.0
}

; Function Attrs: nounwind uwtable
define internal i32 @set_port_feature(%struct.usb_device* %hdev, i32 %port1, i32 %feature) #0 {
entry:
  %call = call i32 @__create_pipe(%struct.usb_device* %hdev, i32 0)
  %or = or i32 -2147483648, %call
  %conv = trunc i32 %feature to i16
  %conv1 = trunc i32 %port1 to i16
  %call2 = call i32 @usb_control_msg(%struct.usb_device* %hdev, i32 %or, i8 zeroext 3, i8 zeroext 35, i16 zeroext %conv, i16 zeroext %conv1, i8* null, i16 zeroext 0, i32 1000)
  ret i32 %call2
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @usb_device_supports_ltm(%struct.usb_device* %udev) #1 {
entry:
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp ne i32 %0, 5
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %bos = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %1 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos, align 8, !tbaa !177
  %tobool = icmp ne %struct.usb_host_bos* %1, null
  br i1 %tobool, label %lor.lhs.false1, label %return

lor.lhs.false1:                                   ; preds = %lor.lhs.false
  %bos2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %2 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos2, align 8, !tbaa !177
  %ss_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %2, i32 0, i32 2
  %3 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap, align 8, !tbaa !178
  %tobool3 = icmp ne %struct.usb_ss_cap_descriptor* %3, null
  br i1 %tobool3, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false1
  %bos4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %4 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos4, align 8, !tbaa !177
  %ss_cap5 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %4, i32 0, i32 2
  %5 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap5, align 8, !tbaa !178
  %bmAttributes = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %5, i32 0, i32 3
  %6 = load i8, i8* %bmAttributes, align 1, !tbaa !180
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 2
  %tobool6 = icmp ne i32 %and, 0
  br label %return

return:                                           ; preds = %if.end, %lor.lhs.false1, %lor.lhs.false, %entry
  %retval.0 = phi i1 [ %tobool6, %if.end ], [ false, %lor.lhs.false1 ], [ false, %lor.lhs.false ], [ false, %entry ]
  ret i1 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_enable_lpm(%struct.usb_device* %udev) #0 {
entry:
  %tobool = icmp ne %struct.usb_device* %udev, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup.cont

lor.lhs.false:                                    ; preds = %entry
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool1 = icmp ne %struct.usb_device* %0, null
  br i1 %tobool1, label %lor.lhs.false2, label %cleanup.cont

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %1 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp ne i32 %1, 5
  br i1 %cmp, label %cleanup.cont, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false2
  %lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %lpm_capable, align 4
  %bf.lshr = lshr i16 %bf.load, 6
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool4 = icmp ne i32 %bf.cast, 0
  br i1 %tobool4, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %lor.lhs.false3
  %lpm_disable_count = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 39
  %2 = load i32, i32* %lpm_disable_count, align 8, !tbaa !81
  %dec = add i32 %2, -1
  store i32 %dec, i32* %lpm_disable_count, align 8, !tbaa !81
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %3 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.11(%struct.usb_bus* %3)
  %tobool5 = icmp ne %struct.usb_hcd* %call, null
  br i1 %tobool5, label %lor.lhs.false6, label %cleanup.cont

lor.lhs.false6:                                   ; preds = %if.end
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %4 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %enable_usb3_lpm_timeout = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %4, i32 0, i32 39
  %5 = load i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)** %enable_usb3_lpm_timeout, align 8, !tbaa !182
  %tobool7 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*, i32)* %5, null
  br i1 %tobool7, label %lor.lhs.false8, label %cleanup.cont

lor.lhs.false8:                                   ; preds = %lor.lhs.false6
  %driver9 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %6 = load %struct.hc_driver*, %struct.hc_driver** %driver9, align 8, !tbaa !71
  %disable_usb3_lpm_timeout = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %6, i32 0, i32 40
  %7 = load i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)** %disable_usb3_lpm_timeout, align 8, !tbaa !183
  %tobool10 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*, i32)* %7, null
  br i1 %tobool10, label %if.end12, label %cleanup.cont

if.end12:                                         ; preds = %lor.lhs.false8
  %lpm_disable_count13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 39
  %8 = load i32, i32* %lpm_disable_count13, align 8, !tbaa !81
  %cmp14 = icmp ugt i32 %8, 0
  br i1 %cmp14, label %cleanup.cont, label %if.end16

if.end16:                                         ; preds = %if.end12
  call void @usb_enable_link_state(%struct.usb_hcd* %call, %struct.usb_device* %udev, i32 1)
  call void @usb_enable_link_state(%struct.usb_hcd* %call, %struct.usb_device* %udev, i32 2)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end16, %if.end12, %lor.lhs.false8, %lor.lhs.false6, %if.end, %lor.lhs.false3, %lor.lhs.false2, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usb_enable_link_state(%struct.usb_hcd* %hcd, %struct.usb_device* %udev, i32 %state) #0 {
entry:
  %bos = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %0 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos, align 8, !tbaa !177
  %ss_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %0, i32 0, i32 2
  %1 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap, align 8, !tbaa !178
  %bU1devExitLat = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %1, i32 0, i32 6
  %2 = load i8, i8* %bU1devExitLat, align 1, !tbaa !184
  %bos1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %3 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos1, align 8, !tbaa !177
  %ss_cap2 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %3, i32 0, i32 2
  %4 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap2, align 8, !tbaa !178
  %bU2DevExitLat = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %4, i32 0, i32 7
  %5 = load i16, i16* %bU2DevExitLat, align 1, !tbaa !185
  %cmp = icmp eq i32 %state, 1
  %conv = zext i8 %2 to i32
  %cmp3 = icmp eq i32 %conv, 0
  %or.cond = and i1 %cmp, %cmp3
  br i1 %or.cond, label %cleanup.cont, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %cmp5 = icmp eq i32 %state, 2
  %conv8 = zext i16 %5 to i32
  %cmp9 = icmp eq i32 %conv8, 0
  %or.cond1 = and i1 %cmp5, %cmp9
  br i1 %or.cond1, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %call = call i32 @usb_req_set_sel(%struct.usb_device* %udev, i32 %state)
  %cmp11 = icmp slt i32 %call, 0
  br i1 %cmp11, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end
  %6 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup.cont

if.end15:                                         ; preds = %if.end
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %hcd, i32 0, i32 8
  %7 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %enable_usb3_lpm_timeout = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %7, i32 0, i32 39
  %8 = load i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)** %enable_usb3_lpm_timeout, align 8, !tbaa !182
  %call16 = call i32 %8(%struct.usb_hcd* %hcd, %struct.usb_device* %udev, i32 %state)
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %cleanup.cont, label %if.end20

if.end20:                                         ; preds = %if.end15
  %cmp21 = icmp slt i32 %call16, 0
  br i1 %cmp21, label %if.then23, label %if.end28

if.then23:                                        ; preds = %if.end20
  %9 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup.cont

if.end28:                                         ; preds = %if.end20
  %call29 = call i32 @usb_set_lpm_timeout(%struct.usb_device* %udev, i32 %state, i32 %call16)
  %tobool = icmp ne i32 %call29, 0
  br i1 %tobool, label %if.then30, label %if.else

if.then30:                                        ; preds = %if.end28
  %driver31 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %hcd, i32 0, i32 8
  %10 = load %struct.hc_driver*, %struct.hc_driver** %driver31, align 8, !tbaa !71
  %disable_usb3_lpm_timeout = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %10, i32 0, i32 40
  %11 = load i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)** %disable_usb3_lpm_timeout, align 8, !tbaa !183
  %call32 = call i32 %11(%struct.usb_hcd* %hcd, %struct.usb_device* %udev, i32 %state)
  br label %cleanup.cont

if.else:                                          ; preds = %if.end28
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %12 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool33 = icmp ne %struct.usb_host_config* %12, null
  br i1 %tobool33, label %if.then34, label %cleanup.cont

if.then34:                                        ; preds = %if.else
  call void @usb_set_device_initiated_lpm(%struct.usb_device* %udev, i32 %state, i1 zeroext true)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then34, %if.else, %if.then30, %if.then23, %if.end15, %if.then13, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_req_set_sel(%struct.usb_device* %udev, i32 %state) #0 {
entry:
  %u1_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 37
  %sel = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %u1_params, i32 0, i32 2
  %0 = load i32, i32* %sel, align 8, !tbaa !186
  %add = add i32 %0, 1000
  %sub = sub i32 %add, 1
  %div = udiv i32 %sub, 1000
  %conv = zext i32 %div to i64
  %u1_params1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 37
  %pel = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %u1_params1, i32 0, i32 1
  %1 = load i32, i32* %pel, align 4, !tbaa !187
  %add2 = add i32 %1, 1000
  %sub3 = sub i32 %add2, 1
  %div4 = udiv i32 %sub3, 1000
  %conv5 = zext i32 %div4 to i64
  %u2_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 38
  %sel6 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %u2_params, i32 0, i32 2
  %2 = load i32, i32* %sel6, align 8, !tbaa !188
  %add7 = add i32 %2, 1000
  %sub8 = sub i32 %add7, 1
  %div9 = udiv i32 %sub8, 1000
  %conv10 = zext i32 %div9 to i64
  %u2_params11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 38
  %pel12 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %u2_params11, i32 0, i32 1
  %3 = load i32, i32* %pel12, align 4, !tbaa !189
  %add13 = add i32 %3, 1000
  %sub14 = sub i32 %add13, 1
  %div15 = udiv i32 %sub14, 1000
  %conv16 = zext i32 %div15 to i64
  switch i32 %state, label %if.end38 [
    i32 1, label %land.lhs.true
    i32 2, label %land.lhs.true25
  ]

land.lhs.true:                                    ; preds = %entry
  %cmp18 = icmp ugt i64 %conv, 255
  %cmp20 = icmp ugt i64 %conv5, 255
  %or.cond = or i1 %cmp18, %cmp20
  br i1 %or.cond, label %do.body31, label %lor.lhs.false22

lor.lhs.false22:                                  ; preds = %land.lhs.true
  %cmp23 = icmp eq i32 %state, 2
  br i1 %cmp23, label %land.lhs.true25, label %if.end38

land.lhs.true25:                                  ; preds = %lor.lhs.false22, %entry
  %cmp26 = icmp ugt i64 %conv10, 65535
  %cmp29 = icmp ugt i64 %conv16, 65535
  %or.cond1 = or i1 %cmp26, %cmp29
  br i1 %or.cond1, label %do.body31, label %if.end38

do.body31:                                        ; preds = %land.lhs.true25, %land.lhs.true
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_req_set_sel.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot32 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot32 to i32
  %conv33 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv33, i64 0)
  %tobool34 = icmp ne i64 %expval, 0
  br i1 %tobool34, label %if.then35, label %cleanup

if.then35:                                        ; preds = %do.body31
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %idxprom = zext i32 %state to i64
  %arrayidx = getelementptr inbounds [4 x i8*], [4 x i8*]* @usb3_lpm_names, i64 0, i64 %idxprom
  %4 = load i8*, i8** %arrayidx, align 8, !tbaa !48
  %call = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_req_set_sel.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.89, i32 0, i32 0), i8* %4, i64 %conv, i64 %conv5)
  br label %cleanup

if.end38:                                         ; preds = %land.lhs.true25, %lor.lhs.false22, %entry
  %cmp39 = icmp ugt i64 %conv, 255
  %.conv = select i1 %cmp39, i64 255, i64 %conv
  %cmp43 = icmp ugt i64 %conv5, 255
  %u1_pel.0 = select i1 %cmp43, i64 255, i64 %conv5
  %cmp47 = icmp ugt i64 %conv10, 65535
  %.conv10 = select i1 %cmp47, i64 65535, i64 %conv10
  %cmp51 = icmp ugt i64 %conv16, 65535
  %u2_pel.0 = select i1 %cmp51, i64 65535, i64 %conv16
  %call.i = call i8* @__kmalloc(i64 6, i32 16) #8
  %5 = bitcast i8* %call.i to %struct.usb_set_sel_req*
  %tobool56 = icmp ne %struct.usb_set_sel_req* %5, null
  br i1 %tobool56, label %if.end58, label %cleanup

if.end58:                                         ; preds = %if.end38
  %conv59 = trunc i64 %.conv to i8
  %u1_sel60 = getelementptr inbounds %struct.usb_set_sel_req, %struct.usb_set_sel_req* %5, i32 0, i32 0
  store i8 %conv59, i8* %u1_sel60, align 1, !tbaa !190
  %conv61 = trunc i64 %u1_pel.0 to i8
  %u1_pel62 = getelementptr inbounds %struct.usb_set_sel_req, %struct.usb_set_sel_req* %5, i32 0, i32 1
  store i8 %conv61, i8* %u1_pel62, align 1, !tbaa !192
  %conv63 = trunc i64 %.conv10 to i16
  %u2_sel64 = getelementptr inbounds %struct.usb_set_sel_req, %struct.usb_set_sel_req* %5, i32 0, i32 2
  store i16 %conv63, i16* %u2_sel64, align 1, !tbaa !193
  %conv65 = trunc i64 %u2_pel.0 to i16
  %u2_pel66 = getelementptr inbounds %struct.usb_set_sel_req, %struct.usb_set_sel_req* %5, i32 0, i32 3
  store i16 %conv65, i16* %u2_pel66, align 1, !tbaa !194
  %call67 = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or = or i32 -2147483648, %call67
  %6 = bitcast %struct.usb_set_sel_req* %5 to i8*
  %call68 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext 48, i8 zeroext 0, i16 zeroext 0, i16 zeroext 0, i8* %6, i16 zeroext 6, i32 5000)
  %7 = bitcast %struct.usb_set_sel_req* %5 to i8*
  call void @kfree(i8* %7)
  br label %cleanup

cleanup:                                          ; preds = %if.end58, %if.end38, %if.then35, %do.body31
  %retval.0 = phi i32 [ %call68, %if.end58 ], [ -22, %if.then35 ], [ -22, %do.body31 ], [ -12, %if.end38 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_set_lpm_timeout(%struct.usb_device* %udev, i32 %state, i32 %timeout) #0 {
entry:
  %Pivot = icmp slt i32 %state, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %state, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %state, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %0 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1
  %feature.0 = phi i32 [ 23, %LeafBlock ], [ 24, %LeafBlock1 ]
  %cmp = icmp eq i32 %state, 1
  %cmp2 = icmp sgt i32 %timeout, 127
  %or.cond = and i1 %cmp, %cmp2
  %cmp4 = icmp ne i32 %timeout, 255
  %or.cond3 = and i1 %or.cond, %cmp4
  br i1 %or.cond3, label %if.then, label %if.end

if.then:                                          ; preds = %sw.epilog
  %1 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

if.end:                                           ; preds = %sw.epilog
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %2 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %and = and i32 %timeout, 255
  %shl = shl i32 %and, 8
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %3 = load i8, i8* %portnum, align 2, !tbaa !88
  %conv = zext i8 %3 to i32
  %or = or i32 %shl, %conv
  %call7 = call i32 @set_port_feature(%struct.usb_device* %2, i32 %or, i32 %feature.0)
  %cmp8 = icmp slt i32 %call7, 0
  br i1 %cmp8, label %if.then10, label %if.end15

if.then10:                                        ; preds = %if.end
  %4 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

if.end15:                                         ; preds = %if.end
  %cmp16 = icmp eq i32 %state, 1
  %u2_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 38
  %u1_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 37
  %u2_params.sink = select i1 %cmp16, %struct.usb3_lpm_parameters* %u1_params, %struct.usb3_lpm_parameters* %u2_params
  %timeout20 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %u2_params.sink, i32 0, i32 3
  store i32 %timeout, i32* %timeout20, align 4, !tbaa !90
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.then10, %if.then, %sw.default
  %retval.0 = phi i32 [ -22, %if.then ], [ -16, %if.then10 ], [ 0, %if.end15 ], [ -22, %sw.default ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @usb_set_device_initiated_lpm(%struct.usb_device* %udev, i32 %state, i1 zeroext %enable) #0 {
entry:
  %frombool = zext i1 %enable to i8
  %Pivot = icmp slt i32 %state, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %state, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %state, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %0 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1
  %feature.0 = phi i32 [ 48, %LeafBlock ], [ 49, %LeafBlock1 ]
  %state2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %1 = load i32, i32* %state2, align 8, !tbaa !50
  %cmp = icmp ne i32 %1, 7
  br i1 %cmp, label %do.body3, label %if.end15

do.body3:                                         ; preds = %sw.epilog
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_set_device_initiated_lpm.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool4 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool4, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then7, label %cleanup

if.then7:                                         ; preds = %do.body3
  %dev8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %tobool9 = trunc i8 %frombool to i1
  %cond11 = select i1 %tobool9, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.77, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.78, i32 0, i32 0)
  %idxprom = zext i32 %state to i64
  %arrayidx = getelementptr inbounds [4 x i8*], [4 x i8*]* @usb3_lpm_names, i64 0, i64 %idxprom
  %2 = load i8*, i8** %arrayidx, align 8, !tbaa !48
  %call12 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_set_device_initiated_lpm.descriptor to %struct._ddebug*), %struct.device* %dev8, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__func__.usb_set_device_initiated_lpm, i32 0, i32 0), i8* %cond11, i8* %2)
  br label %cleanup

if.end15:                                         ; preds = %sw.epilog
  %tobool16 = trunc i8 %frombool to i1
  %call18 = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or = or i32 -2147483648, %call18
  %conv19 = trunc i32 %feature.0 to i16
  %.sink = select i1 %tobool16, i8 3, i8 1
  %call24 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext %.sink, i8 zeroext 0, i16 zeroext %conv19, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  %cmp26 = icmp slt i32 %call24, 0
  br i1 %cmp26, label %if.then28, label %cleanup

if.then28:                                        ; preds = %if.end15
  %3 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then28, %if.end15, %if.then7, %do.body3, %sw.default
  %retval.0 = phi i32 [ -16, %if.then28 ], [ -22, %sw.default ], [ 0, %if.then7 ], [ 0, %do.body3 ], [ 0, %if.end15 ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @recursively_mark_NOTATTACHED(%struct.usb_device* %udev) #0 {
entry:
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %udev)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 28
  %0 = load i32, i32* %maxchild, align 8, !tbaa !97
  %cmp = icmp slt i32 %i.0, %0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 22
  %1 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %1, i64 %idxprom
  %2 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %2, i32 0, i32 0
  %3 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_device* %3, null
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %ports1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 22
  %4 = load %struct.usb_port**, %struct.usb_port*** %ports1, align 8, !tbaa !98
  %idxprom2 = sext i32 %i.0 to i64
  %arrayidx3 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %4, i64 %idxprom2
  %5 = load %struct.usb_port*, %struct.usb_port** %arrayidx3, align 8, !tbaa !48
  %child4 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %5, i32 0, i32 0
  %6 = load %struct.usb_device*, %struct.usb_device** %child4, align 8, !tbaa !102
  call void @recursively_mark_NOTATTACHED(%struct.usb_device* %6)
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %7 = load i32, i32* %state, align 8, !tbaa !50
  %cmp5 = icmp eq i32 %7, 8
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.end
  %8 = load volatile i64, i64* @jiffies, align 8, !tbaa !49
  %active_duration = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 31
  %9 = load i64, i64* %active_duration, align 8, !tbaa !92
  %sub = sub i64 %9, %8
  store i64 %sub, i64* %active_duration, align 8, !tbaa !92
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %for.end
  %state8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  store i32 0, i32* %state8, align 8, !tbaa !50
  ret void
}

declare void @device_set_wakeup_capable(%struct.device*, i1 zeroext) #2

declare i32 @memcmp(i8*, i8*, i64) #2

declare i64 @strlen(i8*) #2

; Function Attrs: nounwind uwtable
define internal i32 @hub_port_reset(%struct.usb_hub* %hub, i32 %port1, %struct.usb_device* %udev, i32 %delay, i1 zeroext %warm) #0 {
entry:
  %status = alloca i32, align 4
  %portchange = alloca i16, align 2
  %portstatus = alloca i16, align 2
  %frombool = zext i1 %warm to i8
  %0 = bitcast i32* %status to i8*
  %1 = bitcast i16* %portchange to i8*
  %2 = bitcast i16* %portstatus to i8*
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %3)
  %tobool = icmp ne i32 %call, 0
  %tobool4 = trunc i8 %frombool to i1
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  br i1 %tobool4, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %4 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end:                                           ; preds = %if.then
  call void @down_read(%struct.rw_semaphore* @ehci_cf_port_reset_rwsem)
  br label %if.end13

if.else:                                          ; preds = %entry
  br i1 %tobool4, label %if.end13, label %if.then5

if.then5:                                         ; preds = %if.else
  %call6 = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1, i16* %portstatus, i16* %portchange)
  store i32 %call6, i32* %status, align 4, !tbaa !90
  %5 = load i32, i32* %status, align 4, !tbaa !90
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %done, label %if.end8

if.end8:                                          ; preds = %if.then5
  %6 = load i16, i16* %portstatus, align 2, !tbaa !143
  %call9 = call zeroext i1 @hub_port_warm_reset_required(%struct.usb_hub* %hub, i16 zeroext %6)
  %.frombool = select i1 %call9, i8 1, i8 %frombool
  br label %if.end13

if.end13:                                         ; preds = %if.end8, %if.else, %if.end
  %warm.addr.2 = phi i8 [ %frombool, %if.end ], [ %frombool, %if.else ], [ %.frombool, %if.end8 ]
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end13
  %delay.addr.0 = phi i32 [ %delay, %if.end13 ], [ 200, %for.inc ]
  %warm.addr.3 = phi i8 [ %warm.addr.2, %if.end13 ], [ %warm.addr.5, %for.inc ]
  %i.0 = phi i32 [ 0, %if.end13 ], [ %inc, %for.inc ]
  %cmp14 = icmp slt i32 %i.0, 5
  br i1 %cmp14, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %hdev15 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %7 = load %struct.usb_device*, %struct.usb_device** %hdev15, align 8, !tbaa !152
  %tobool16 = trunc i8 %warm.addr.3 to i1
  %cond = select i1 %tobool16, i32 28, i32 4
  %call17 = call i32 @set_port_feature(%struct.usb_device* %7, i32 %port1, i32 %cond)
  store i32 %call17, i32* %status, align 4, !tbaa !90
  %8 = load i32, i32* %status, align 4, !tbaa !90
  %cmp18 = icmp eq i32 %8, -19
  br i1 %cmp18, label %if.end47, label %if.else20

if.else20:                                        ; preds = %for.body
  %9 = load i32, i32* %status, align 4, !tbaa !90
  %tobool21 = icmp ne i32 %9, 0
  br i1 %tobool21, label %if.then22, label %if.else27

if.then22:                                        ; preds = %if.else20
  %10 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end47

if.else27:                                        ; preds = %if.else20
  %tobool28 = trunc i8 %warm.addr.3 to i1
  %call29 = call i32 @hub_port_wait_reset(%struct.usb_hub* %hub, i32 %port1, %struct.usb_device* %udev, i32 %delay.addr.0, i1 zeroext %tobool28)
  store i32 %call29, i32* %status, align 4, !tbaa !90
  %11 = load i32, i32* %status, align 4, !tbaa !90
  %tobool30 = icmp ne i32 %11, 0
  %12 = load i32, i32* %status, align 4
  %cmp31 = icmp ne i32 %12, -107
  %or.cond = and i1 %tobool30, %cmp31
  %13 = load i32, i32* %status, align 4
  %cmp33 = icmp ne i32 %13, -19
  %or.cond1 = and i1 %or.cond, %cmp33
  br i1 %or.cond1, label %do.body35, label %if.end47

do.body35:                                        ; preds = %if.else27
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_reset.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool36 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool36, true
  %lnot37 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot37 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool38 = icmp ne i64 %expval, 0
  br i1 %tobool38, label %if.then39, label %if.end47

if.then39:                                        ; preds = %do.body35
  %intfdev40 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %14 = load %struct.device*, %struct.device** %intfdev40, align 8, !tbaa !173
  %15 = load i32, i32* %status, align 4, !tbaa !90
  %call41 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_reset.descriptor to %struct._ddebug*), %struct.device* %14, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.213, i32 0, i32 0), i32 %15)
  br label %if.end47

if.end47:                                         ; preds = %if.then39, %do.body35, %if.else27, %if.then22, %for.body
  %16 = load i32, i32* %status, align 4, !tbaa !90
  %cmp48 = icmp eq i32 %16, 0
  %17 = load i32, i32* %status, align 4
  %cmp50 = icmp eq i32 %17, -107
  %or.cond2 = or i1 %cmp48, %cmp50
  %18 = load i32, i32* %status, align 4
  %cmp53 = icmp eq i32 %18, -19
  %or.cond3 = or i1 %or.cond2, %cmp53
  br i1 %or.cond3, label %if.then55, label %do.body96

if.then55:                                        ; preds = %if.end47
  call void @hub_port_finish_reset(%struct.usb_hub* %hub, i32 %port1, %struct.usb_device* %udev, i32* %status)
  %hdev56 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %19 = load %struct.usb_device*, %struct.usb_device** %hdev56, align 8, !tbaa !152
  %call57 = call i32 @hub_is_superspeed(%struct.usb_device* %19)
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.end60, label %done

if.end60:                                         ; preds = %if.then55
  %call61 = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1, i16* %portstatus, i16* %portchange)
  %cmp62 = icmp slt i32 %call61, 0
  br i1 %cmp62, label %done, label %if.end65

if.end65:                                         ; preds = %if.end60
  %20 = load i16, i16* %portstatus, align 2, !tbaa !143
  %call66 = call zeroext i1 @hub_port_warm_reset_required(%struct.usb_hub* %hub, i16 zeroext %20)
  br i1 %call66, label %if.end68, label %done

if.end68:                                         ; preds = %if.end65
  %tobool69 = trunc i8 %warm.addr.3 to i1
  br i1 %tobool69, label %do.body96, label %do.body72

do.body72:                                        ; preds = %if.end68
  %bf.load73 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_reset.descriptor.214 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr74 = lshr i32 %bf.load73, 18
  %bf.clear75 = and i32 %bf.lshr74, 255
  %and76 = and i32 %bf.clear75, 1
  %tobool77 = icmp ne i32 %and76, 0
  %lnot78 = xor i1 %tobool77, true
  %lnot80 = xor i1 %lnot78, true
  %lnot.ext81 = zext i1 %lnot80 to i32
  %conv82 = sext i32 %lnot.ext81 to i64
  %expval83 = call i64 @llvm.expect.i64(i64 %conv82, i64 0)
  %tobool84 = icmp ne i64 %expval83, 0
  br i1 %tobool84, label %if.then85, label %do.body96

if.then85:                                        ; preds = %do.body72
  %intfdev86 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %21 = load %struct.device*, %struct.device** %intfdev86, align 8, !tbaa !173
  %call87 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_reset.descriptor.214 to %struct._ddebug*), %struct.device* %21, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.215, i32 0, i32 0), i32 %port1)
  br label %do.body96

do.body96:                                        ; preds = %if.then85, %do.body72, %if.end68, %if.end47
  %warm.addr.5 = phi i8 [ %warm.addr.3, %if.end47 ], [ %warm.addr.3, %if.end68 ], [ 1, %if.then85 ], [ 1, %do.body72 ]
  %bf.load97 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_reset.descriptor.216 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr98 = lshr i32 %bf.load97, 18
  %bf.clear99 = and i32 %bf.lshr98, 255
  %and100 = and i32 %bf.clear99, 1
  %tobool101 = icmp ne i32 %and100, 0
  %lnot102 = xor i1 %tobool101, true
  %lnot104 = xor i1 %lnot102, true
  %lnot.ext105 = zext i1 %lnot104 to i32
  %conv106 = sext i32 %lnot.ext105 to i64
  %expval107 = call i64 @llvm.expect.i64(i64 %conv106, i64 0)
  %tobool108 = icmp ne i64 %expval107, 0
  br i1 %tobool108, label %if.then109, label %for.inc

if.then109:                                       ; preds = %do.body96
  %intfdev110 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %22 = load %struct.device*, %struct.device** %intfdev110, align 8, !tbaa !173
  %tobool111 = trunc i8 %warm.addr.5 to i1
  %cond113 = select i1 %tobool111, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.212, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.27.821, i32 0, i32 0)
  %call114 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_reset.descriptor.216 to %struct._ddebug*), %struct.device* %22, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.217, i32 0, i32 0), i32 %port1, i8* %cond113)
  br label %for.inc

for.inc:                                          ; preds = %if.then109, %do.body96
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %23 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %done

done:                                             ; preds = %for.end, %if.end65, %if.end60, %if.then55, %if.then5
  %hdev122 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %24 = load %struct.usb_device*, %struct.usb_device** %hdev122, align 8, !tbaa !152
  %call123 = call i32 @hub_is_superspeed(%struct.usb_device* %24)
  %tobool124 = icmp ne i32 %call123, 0
  br i1 %tobool124, label %if.end126, label %if.then125

if.then125:                                       ; preds = %done
  call void @up_read(%struct.rw_semaphore* @ehci_cf_port_reset_rwsem)
  br label %if.end126

if.end126:                                        ; preds = %if.then125, %done
  %25 = load i32, i32* %status, align 4, !tbaa !90
  br label %cleanup

cleanup:                                          ; preds = %if.end126, %if.then2
  %retval.0 = phi i32 [ %25, %if.end126 ], [ -22, %if.then2 ]
  %26 = bitcast i16* %portstatus to i8*
  %27 = bitcast i16* %portchange to i8*
  %28 = bitcast i32* %status to i8*
  ret i32 %retval.0
}

declare i8* @usb_speed_string(i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @hub_set_address(%struct.usb_device* %udev, i32 %devnum) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.11(%struct.usb_bus* %0)
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %1 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %address_device = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 34
  %2 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %address_device, align 8, !tbaa !195
  %tobool = icmp eq i32 (%struct.usb_hcd*, %struct.usb_device*)* %2, null
  %cmp = icmp sle i32 %devnum, 1
  %or.cond = and i1 %tobool, %cmp
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %3 = load i32, i32* %state, align 8, !tbaa !50
  %cmp2 = icmp eq i32 %3, 6
  br i1 %cmp2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %state5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %4 = load i32, i32* %state5, align 8, !tbaa !50
  %cmp6 = icmp ne i32 %4, 5
  br i1 %cmp6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end4
  %driver9 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %5 = load %struct.hc_driver*, %struct.hc_driver** %driver9, align 8, !tbaa !71
  %address_device10 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %5, i32 0, i32 34
  %6 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %address_device10, align 8, !tbaa !195
  %tobool11 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*)* %6, null
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end8
  %driver13 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %7 = load %struct.hc_driver*, %struct.hc_driver** %driver13, align 8, !tbaa !71
  %address_device14 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %7, i32 0, i32 34
  %8 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %address_device14, align 8, !tbaa !195
  %call15 = call i32 %8(%struct.usb_hcd* %call, %struct.usb_device* %udev)
  br label %if.end17

if.else:                                          ; preds = %if.end8
  %conv = trunc i32 %devnum to i16
  %call16 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 -2147483648, i8 zeroext 5, i8 zeroext 0, i16 zeroext %conv, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.then12
  %retval1.0 = phi i32 [ %call15, %if.then12 ], [ %call16, %if.else ]
  %cmp18 = icmp eq i32 %retval1.0, 0
  br i1 %cmp18, label %if.then20, label %cleanup

if.then20:                                        ; preds = %if.end17
  call void @update_devnum(%struct.usb_device* %udev, i32 %devnum)
  call void @usb_set_device_state(%struct.usb_device* %udev, i32 6)
  call void @usb_ep0_reinit(%struct.usb_device* %udev)
  br label %cleanup

cleanup:                                          ; preds = %if.then20, %if.end17, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ 0, %if.end ], [ -22, %if.end4 ], [ %retval1.0, %if.then20 ], [ %retval1.0, %if.end17 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_phy_notify_connect(%struct.usb_phy* %x, i32 %speed) #1 {
entry:
  %notify_connect = getelementptr inbounds %struct.usb_phy, %struct.usb_phy* %x, i32 0, i32 19
  %0 = load i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32)** %notify_connect, align 8, !tbaa !196
  %tobool = icmp ne i32 (%struct.usb_phy*, i32)* %0, null
  br i1 %tobool, label %if.then, label %return

if.then:                                          ; preds = %entry
  %notify_connect1 = getelementptr inbounds %struct.usb_phy, %struct.usb_phy* %x, i32 0, i32 19
  %1 = load i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32)** %notify_connect1, align 8, !tbaa !196
  %call = call i32 %1(%struct.usb_phy* %x, i32 %speed)
  br label %return

return:                                           ; preds = %if.then, %entry
  %retval.0 = phi i32 [ %call, %if.then ], [ 0, %entry ]
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_maxp(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 4
  %0 = load i16, i16* %wMaxPacketSize, align 1, !tbaa !199
  %conv = zext i16 %0 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_device_supports_lpm(%struct.usb_device* %udev) #0 {
entry:
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp eq i32 %0, 3
  %bos = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %1 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos, align 8, !tbaa !177
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %ext_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %1, i32 0, i32 1
  %2 = load %struct.usb_ext_cap_descriptor*, %struct.usb_ext_cap_descriptor** %ext_cap, align 8, !tbaa !200
  %tobool = icmp ne %struct.usb_ext_cap_descriptor* %2, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %bos1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %3 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos1, align 8, !tbaa !177
  %ext_cap2 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %3, i32 0, i32 1
  %4 = load %struct.usb_ext_cap_descriptor*, %struct.usb_ext_cap_descriptor** %ext_cap2, align 8, !tbaa !200
  %bmAttributes = getelementptr inbounds %struct.usb_ext_cap_descriptor, %struct.usb_ext_cap_descriptor* %4, i32 0, i32 3
  %5 = load i32, i32* %bmAttributes, align 1, !tbaa !201
  %and = and i32 2, %5
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %return, label %if.end

if.end:                                           ; preds = %land.lhs.true, %if.then
  br label %return

if.end5:                                          ; preds = %entry
  %ss_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %1, i32 0, i32 2
  %6 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap, align 8, !tbaa !178
  %tobool7 = icmp ne %struct.usb_ss_cap_descriptor* %6, null
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end5
  %7 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %return

if.end9:                                          ; preds = %if.end5
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %8 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 22
  %bf.load = load i16, i16* %lpm_capable, align 4
  %bf.lshr = lshr i16 %bf.load, 6
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool10 = icmp ne i32 %bf.cast, 0
  br i1 %tobool10, label %return, label %if.end12

if.end12:                                         ; preds = %if.end9
  %9 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %return

return:                                           ; preds = %if.end12, %if.end9, %if.then8, %if.end, %land.lhs.true
  %retval.0 = phi i32 [ 0, %if.end ], [ 0, %if.end12 ], [ 0, %if.then8 ], [ 1, %land.lhs.true ], [ 1, %if.end9 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @usb_set_lpm_parameters(%struct.usb_device* %udev) #0 {
entry:
  %lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %lpm_capable, align 4
  %bf.lshr = lshr i16 %bf.load, 6
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %lor.lhs.false, label %cleanup.cont

lor.lhs.false:                                    ; preds = %entry
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp ne i32 %0, 5
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %1 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %1)
  %tobool1 = icmp ne %struct.usb_hub* %call, null
  br i1 %tobool1, label %if.end3, label %cleanup.cont

if.end3:                                          ; preds = %if.end
  %bos = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %2 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos, align 8, !tbaa !177
  %ss_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %2, i32 0, i32 2
  %3 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap, align 8, !tbaa !178
  %bU1devExitLat = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %3, i32 0, i32 6
  %4 = load i8, i8* %bU1devExitLat, align 1, !tbaa !184
  %conv = zext i8 %4 to i32
  %bos4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %5 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos4, align 8, !tbaa !177
  %ss_cap5 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %5, i32 0, i32 2
  %6 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap5, align 8, !tbaa !178
  %bU2DevExitLat = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %6, i32 0, i32 7
  %7 = load i16, i16* %bU2DevExitLat, align 1, !tbaa !185
  %conv6 = zext i16 %7 to i32
  %parent7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %8 = load %struct.usb_device*, %struct.usb_device** %parent7, align 8, !tbaa !89
  %bos8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 13
  %9 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos8, align 8, !tbaa !177
  %ss_cap9 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %9, i32 0, i32 2
  %10 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap9, align 8, !tbaa !178
  %bU1devExitLat10 = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %10, i32 0, i32 6
  %11 = load i8, i8* %bU1devExitLat10, align 1, !tbaa !184
  %conv11 = zext i8 %11 to i32
  %parent12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %12 = load %struct.usb_device*, %struct.usb_device** %parent12, align 8, !tbaa !89
  %bos13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 13
  %13 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos13, align 8, !tbaa !177
  %ss_cap14 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %13, i32 0, i32 2
  %14 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap14, align 8, !tbaa !178
  %bU2DevExitLat15 = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %14, i32 0, i32 7
  %15 = load i16, i16* %bU2DevExitLat15, align 1, !tbaa !185
  %conv16 = zext i16 %15 to i32
  %u1_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 37
  %parent17 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %16 = load %struct.usb_device*, %struct.usb_device** %parent17, align 8, !tbaa !89
  %u1_params18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %16, i32 0, i32 37
  call void @usb_set_lpm_mel(%struct.usb3_lpm_parameters* %u1_params, i32 %conv, %struct.usb_hub* %call, %struct.usb3_lpm_parameters* %u1_params18, i32 %conv11)
  %u2_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 38
  %parent19 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %17 = load %struct.usb_device*, %struct.usb_device** %parent19, align 8, !tbaa !89
  %u2_params20 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %17, i32 0, i32 38
  call void @usb_set_lpm_mel(%struct.usb3_lpm_parameters* %u2_params, i32 %conv6, %struct.usb_hub* %call, %struct.usb3_lpm_parameters* %u2_params20, i32 %conv16)
  %u1_params21 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 37
  %parent22 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %18 = load %struct.usb_device*, %struct.usb_device** %parent22, align 8, !tbaa !89
  %u1_params23 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 37
  call void @usb_set_lpm_pel(%struct.usb3_lpm_parameters* %u1_params21, i32 %conv, %struct.usb3_lpm_parameters* %u1_params23, i32 %conv11, i32 1)
  %cmp24 = icmp ugt i32 %conv16, %conv11
  %add = add i32 1, %conv16
  %sub = sub i32 %add, %conv11
  %add27 = add i32 1, %conv11
  %port_to_port_delay.0 = select i1 %cmp24, i32 %sub, i32 %add27
  %u2_params29 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 38
  %parent30 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %19 = load %struct.usb_device*, %struct.usb_device** %parent30, align 8, !tbaa !89
  %u2_params31 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %19, i32 0, i32 38
  call void @usb_set_lpm_pel(%struct.usb3_lpm_parameters* %u2_params29, i32 %conv6, %struct.usb3_lpm_parameters* %u2_params31, i32 %conv16, i32 %port_to_port_delay.0)
  %u1_params32 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 37
  call void @usb_set_lpm_sel(%struct.usb_device* %udev, %struct.usb3_lpm_parameters* %u1_params32)
  %u2_params33 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 38
  call void @usb_set_lpm_sel(%struct.usb_device* %udev, %struct.usb3_lpm_parameters* %u2_params33)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end3, %if.end, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @update_devnum(%struct.usb_device* %udev, i32 %devnum) #0 {
entry:
  %wusb = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %wusb, align 4
  %bf.lshr = lshr i16 %bf.load, 5
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %devnum1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  store i32 %devnum, i32* %devnum1, align 8, !tbaa !38
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usb_set_lpm_mel(%struct.usb3_lpm_parameters* %udev_lpm_params, i32 %udev_exit_latency, %struct.usb_hub* %hub, %struct.usb3_lpm_parameters* %hub_lpm_params, i32 %hub_exit_latency) #0 {
entry:
  %mel = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %hub_lpm_params, i32 0, i32 0
  %0 = load i32, i32* %mel, align 4, !tbaa !203
  %descriptor = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %1 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !204
  %u = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %1, i32 0, i32 6
  %ss = bitcast %union.anon.49* %u to %struct.anon.51*
  %bHubHdrDecLat = getelementptr inbounds %struct.anon.51, %struct.anon.51* %ss, i32 0, i32 0
  %2 = load i8, i8* %bHubHdrDecLat, align 1, !tbaa !84
  %conv = zext i8 %2 to i32
  %mul = mul nsw i32 %conv, 100
  %add = add i32 %0, %mul
  %mul1 = mul i32 %udev_exit_latency, 1000
  %mul2 = mul i32 %hub_exit_latency, 1000
  %cmp = icmp ugt i32 %mul1, %mul2
  %mul2.sink = select i1 %cmp, i32 %mul1, i32 %mul2
  %add5 = add i32 %add, %mul2.sink
  %mel6 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %udev_lpm_params, i32 0, i32 0
  store i32 %add5, i32* %mel6, align 4, !tbaa !203
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usb_set_lpm_pel(%struct.usb3_lpm_parameters* %udev_lpm_params, i32 %udev_exit_latency, %struct.usb3_lpm_parameters* %hub_lpm_params, i32 %hub_exit_latency, i32 %port_to_port_exit_latency) #0 {
entry:
  %cmp = icmp ugt i32 %udev_exit_latency, %hub_exit_latency
  %hub_exit_latency.sink = select i1 %cmp, i32 %udev_exit_latency, i32 %hub_exit_latency
  %mul1 = mul i32 %hub_exit_latency.sink, 1000
  %mul2 = mul i32 %port_to_port_exit_latency, 1000
  %pel = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %hub_lpm_params, i32 0, i32 1
  %0 = load i32, i32* %pel, align 4, !tbaa !205
  %add = add i32 %mul2, %0
  %cmp3 = icmp ugt i32 %mul1, %add
  %pel5 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %udev_lpm_params, i32 0, i32 1
  %add.sink = select i1 %cmp3, i32 %mul1, i32 %add
  store i32 %add.sink, i32* %pel5, align 4, !tbaa !205
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usb_set_lpm_sel(%struct.usb_device* %udev, %struct.usb3_lpm_parameters* %udev_lpm_params) #0 {
entry:
  %pel = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %udev_lpm_params, i32 0, i32 1
  %0 = load i32, i32* %pel, align 4, !tbaa !205
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %.sink = phi %struct.usb_device* [ %1, %for.body ], [ %udev, %entry ]
  %num_hubs.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %parent3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %.sink, i32 0, i32 8
  %1 = load %struct.usb_device*, %struct.usb_device** %parent3, align 8, !tbaa !89
  %parent2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 8
  %2 = load %struct.usb_device*, %struct.usb_device** %parent2, align 8, !tbaa !89
  %tobool = icmp ne %struct.usb_device* %2, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %inc = add i32 %num_hubs.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %cmp = icmp ugt i32 %num_hubs.0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %sub = sub i32 %num_hubs.0, 1
  %mul = mul i32 250, %sub
  %add = add i32 2100, %mul
  %add4 = add i32 %0, %add
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  %total_sel.0 = phi i32 [ %add4, %if.then ], [ %0, %for.end ]
  %mul5 = mul i32 250, %num_hubs.0
  %add6 = add i32 %total_sel.0, %mul5
  %sel = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %udev_lpm_params, i32 0, i32 2
  store i32 %add6, i32* %sel, align 4, !tbaa !206
  ret void
}

declare void @down_read(%struct.rw_semaphore*) #2

; Function Attrs: nounwind uwtable
define internal zeroext i1 @hub_port_warm_reset_required(%struct.usb_hub* %hub, i16 zeroext %portstatus) #0 {
entry:
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %conv = zext i16 %portstatus to i32
  %and = and i32 %conv, 480
  %cmp = icmp eq i32 %and, 192
  br i1 %cmp, label %land.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %conv2 = zext i16 %portstatus to i32
  %and3 = and i32 %conv2, 480
  %cmp4 = icmp eq i32 %and3, 320
  br label %land.end

land.end:                                         ; preds = %lor.rhs, %land.rhs, %entry
  %1 = phi i1 [ false, %entry ], [ true, %land.rhs ], [ %cmp4, %lor.rhs ]
  ret i1 %1
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_port_wait_reset(%struct.usb_hub* %hub, i32 %port1, %struct.usb_device* %udev, i32 %delay, i1 zeroext %warm) #0 {
entry:
  %portstatus = alloca i16, align 2
  %portchange = alloca i16, align 2
  %frombool = zext i1 %warm to i8
  %0 = bitcast i16* %portstatus to i8*
  %1 = bitcast i16* %portchange to i8*
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %delay.addr.0 = phi i32 [ %delay, %entry ], [ %.delay.addr.0, %for.inc ]
  %delay_time.0 = phi i32 [ 0, %entry ], [ %add, %for.inc ]
  %cmp = icmp slt i32 %delay_time.0, 800
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @msleep(i32 %delay.addr.0)
  %call = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1, i16* %portstatus, i16* %portchange)
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %cleanup, label %if.end

if.end:                                           ; preds = %for.body
  %2 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv = zext i16 %2 to i32
  %and = and i32 %conv, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end3, label %for.end

if.end3:                                          ; preds = %if.end
  %cmp4 = icmp sge i32 %delay_time.0, 20
  %.delay.addr.0 = select i1 %cmp4, i32 200, i32 %delay.addr.0
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_wait_reset.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and9 = and i32 %bf.clear, 1
  %tobool10 = icmp ne i32 %and9, 0
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv12 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv12, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  br i1 %tobool13, label %if.then14, label %for.inc

if.then14:                                        ; preds = %if.end3
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %3 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !173
  %tobool15 = trunc i8 %frombool to i1
  %cond = select i1 %tobool15, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.212, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.27.821, i32 0, i32 0)
  %call17 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_wait_reset.descriptor to %struct._ddebug*), %struct.device* %3, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.219, i32 0, i32 0), i32 %port1, i8* %cond, i32 %.delay.addr.0)
  br label %for.inc

for.inc:                                          ; preds = %if.then14, %if.end3
  %add = add i32 %delay_time.0, %.delay.addr.0
  br label %for.cond

for.end:                                          ; preds = %if.end, %for.cond
  %4 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv21 = zext i16 %4 to i32
  %and22 = and i32 %conv21, 16
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %cleanup, label %if.end25

if.end25:                                         ; preds = %for.end
  %5 = load i16, i16* %portstatus, align 2, !tbaa !143
  %call26 = call zeroext i1 @hub_port_warm_reset_required(%struct.usb_hub* %hub, i16 zeroext %5)
  br i1 %call26, label %cleanup, label %if.end28

if.end28:                                         ; preds = %if.end25
  %6 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv29 = zext i16 %6 to i32
  %and30 = and i32 %conv29, 1
  %tobool31 = icmp ne i32 %and30, 0
  br i1 %tobool31, label %if.end33, label %cleanup

if.end33:                                         ; preds = %if.end28
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %7 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %call34 = call i32 @hub_is_superspeed(%struct.usb_device* %7)
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %if.end40, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end33
  %8 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv36 = zext i16 %8 to i32
  %and37 = and i32 %conv36, 1
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %cleanup, label %if.end40

if.end40:                                         ; preds = %land.lhs.true, %if.end33
  %9 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv41 = zext i16 %9 to i32
  %and42 = and i32 %conv41, 2
  %tobool43 = icmp ne i32 %and42, 0
  br i1 %tobool43, label %if.end45, label %cleanup

if.end45:                                         ; preds = %if.end40
  %tobool46 = icmp ne %struct.usb_device* %udev, null
  br i1 %tobool46, label %if.end48, label %cleanup

if.end48:                                         ; preds = %if.end45
  %call49 = call i32 @hub_is_wusb(%struct.usb_hub* %hub)
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %if.then51, label %if.else

if.then51:                                        ; preds = %if.end48
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  store i32 4, i32* %speed, align 4, !tbaa !153
  br label %cleanup

if.else:                                          ; preds = %if.end48
  %hdev52 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %hdev52, align 8, !tbaa !152
  %call53 = call i32 @hub_is_superspeed(%struct.usb_device* %10)
  %tobool54 = icmp ne i32 %call53, 0
  br i1 %tobool54, label %if.then55, label %if.else57

if.then55:                                        ; preds = %if.else
  %speed56 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  store i32 5, i32* %speed56, align 4, !tbaa !153
  br label %cleanup

if.else57:                                        ; preds = %if.else
  %11 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv58 = zext i16 %11 to i32
  %and59 = and i32 %conv58, 1024
  %tobool60 = icmp ne i32 %and59, 0
  br i1 %tobool60, label %if.then61, label %if.else63

if.then61:                                        ; preds = %if.else57
  %speed62 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  store i32 3, i32* %speed62, align 4, !tbaa !153
  br label %cleanup

if.else63:                                        ; preds = %if.else57
  %12 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv64 = zext i16 %12 to i32
  %and65 = and i32 %conv64, 512
  %tobool66 = icmp ne i32 %and65, 0
  %speed68 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %.sink = select i1 %tobool66, i32 1, i32 2
  store i32 %.sink, i32* %speed68, align 4, !tbaa !153
  br label %cleanup

cleanup:                                          ; preds = %if.else63, %if.then61, %if.then55, %if.then51, %if.end45, %if.end40, %land.lhs.true, %if.end28, %if.end25, %for.end, %for.body
  %retval.0 = phi i32 [ %call, %for.body ], [ -16, %for.end ], [ -107, %if.end25 ], [ -107, %if.end28 ], [ -107, %land.lhs.true ], [ -16, %if.end40 ], [ 0, %if.end45 ], [ 0, %if.then55 ], [ 0, %if.else63 ], [ 0, %if.then61 ], [ 0, %if.then51 ]
  %13 = bitcast i16* %portchange to i8*
  %14 = bitcast i16* %portstatus to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @hub_port_finish_reset(%struct.usb_hub* %hub, i32 %port1, %struct.usb_device* %udev, i32* %status) #0 {
entry:
  %0 = load i32, i32* %status, align 4, !tbaa !90
  %Pivot6 = icmp slt i32 %0, -19
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %0, 0
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %0, 0
  br i1 %SwitchLeaf4, label %sw.bb, label %sw.epilog

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %0, -19
  br i1 %SwitchLeaf2, label %sw.bb7, label %sw.epilog

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %0, -107
  br i1 %SwitchLeaf, label %sw.bb7, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock3
  call void @msleep(i32 50)
  %tobool = icmp ne %struct.usb_device* %udev, null
  br i1 %tobool, label %if.then, label %sw.bb7

if.then:                                          ; preds = %sw.bb
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.11(%struct.usb_bus* %1)
  call void @update_devnum(%struct.usb_device* %udev, i32 0)
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %2 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %reset_device = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %2, i32 0, i32 36
  %3 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %reset_device, align 8, !tbaa !207
  %tobool1 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*)* %3, null
  br i1 %tobool1, label %if.then2, label %sw.bb7

if.then2:                                         ; preds = %if.then
  %driver3 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %4 = load %struct.hc_driver*, %struct.hc_driver** %driver3, align 8, !tbaa !71
  %reset_device4 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %4, i32 0, i32 36
  %5 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %reset_device4, align 8, !tbaa !207
  %call5 = call i32 %5(%struct.usb_hcd* %call, %struct.usb_device* %udev)
  br label %sw.bb7

sw.bb7:                                           ; preds = %if.then2, %if.then, %sw.bb, %LeafBlock, %LeafBlock1
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %call8 = call i32 @usb_clear_port_feature(%struct.usb_device* %6, i32 %port1, i32 20)
  %hdev9 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %7 = load %struct.usb_device*, %struct.usb_device** %hdev9, align 8, !tbaa !152
  %call10 = call i32 @hub_is_superspeed(%struct.usb_device* %7)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.then12, label %if.end19

if.then12:                                        ; preds = %sw.bb7
  %hdev13 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %8 = load %struct.usb_device*, %struct.usb_device** %hdev13, align 8, !tbaa !152
  %call14 = call i32 @usb_clear_port_feature(%struct.usb_device* %8, i32 %port1, i32 29)
  %hdev15 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %hdev15, align 8, !tbaa !152
  %call16 = call i32 @usb_clear_port_feature(%struct.usb_device* %9, i32 %port1, i32 25)
  %hdev17 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %hdev17, align 8, !tbaa !152
  %call18 = call i32 @usb_clear_port_feature(%struct.usb_device* %10, i32 %port1, i32 16)
  br label %if.end19

if.end19:                                         ; preds = %if.then12, %sw.bb7
  %tobool20 = icmp ne %struct.usb_device* %udev, null
  br i1 %tobool20, label %if.then21, label %sw.epilog

if.then21:                                        ; preds = %if.end19
  %11 = load i32, i32* %status, align 4, !tbaa !90
  %tobool22 = icmp ne i32 %11, 0
  %cond = select i1 %tobool22, i32 0, i32 5
  call void @usb_set_device_state(%struct.usb_device* %udev, i32 %cond)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then21, %if.end19, %LeafBlock, %LeafBlock1, %LeafBlock3
  ret void
}

declare void @up_read(%struct.rw_semaphore*) #2

; Function Attrs: nounwind uwtable
define internal i32 @hub_is_wusb(%struct.usb_hub* %hub) #0 {
entry:
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  %1 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %cmp = icmp ne %struct.usb_device* %1, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !152
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 9
  %3 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %4 = bitcast %struct.usb_bus* %3 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr to %struct.usb_hcd*
  %wireless = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %5, i32 0, i32 11
  %bf.load = load i8, i8* %wireless, align 8
  %bf.lshr = lshr i8 %bf.load, 4
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %bf.cast, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_disable_lpm(%struct.usb_device* %udev) #0 {
entry:
  %tobool = icmp ne %struct.usb_device* %udev, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool1 = icmp ne %struct.usb_device* %0, null
  br i1 %tobool1, label %lor.lhs.false2, label %cleanup

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %1 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp ne i32 %1, 5
  br i1 %cmp, label %cleanup, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false2
  %lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %lpm_capable, align 4
  %bf.lshr = lshr i16 %bf.load, 6
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool4 = icmp ne i32 %bf.cast, 0
  br i1 %tobool4, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false3
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.11(%struct.usb_bus* %2)
  %tobool5 = icmp ne %struct.usb_hcd* %call, null
  br i1 %tobool5, label %lor.lhs.false6, label %cleanup

lor.lhs.false6:                                   ; preds = %if.end
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %3 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %disable_usb3_lpm_timeout = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %3, i32 0, i32 40
  %4 = load i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)** %disable_usb3_lpm_timeout, align 8, !tbaa !183
  %tobool7 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*, i32)* %4, null
  br i1 %tobool7, label %if.end9, label %cleanup

if.end9:                                          ; preds = %lor.lhs.false6
  %lpm_disable_count = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 39
  %5 = load i32, i32* %lpm_disable_count, align 8, !tbaa !81
  %inc = add i32 %5, 1
  store i32 %inc, i32* %lpm_disable_count, align 8, !tbaa !81
  %u1_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 37
  %timeout = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %u1_params, i32 0, i32 3
  %6 = load i32, i32* %timeout, align 4, !tbaa !208
  %cmp10 = icmp eq i32 %6, 0
  br i1 %cmp10, label %land.lhs.true, label %if.end14

land.lhs.true:                                    ; preds = %if.end9
  %u2_params = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 38
  %timeout11 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %u2_params, i32 0, i32 3
  %7 = load i32, i32* %timeout11, align 4, !tbaa !209
  %cmp12 = icmp eq i32 %7, 0
  br i1 %cmp12, label %cleanup, label %if.end14

if.end14:                                         ; preds = %land.lhs.true, %if.end9
  %call15 = call i32 @usb_disable_link_state(%struct.usb_hcd* %call, %struct.usb_device* %udev, i32 1)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %enable_lpm, label %if.end18

if.end18:                                         ; preds = %if.end14
  %call19 = call i32 @usb_disable_link_state(%struct.usb_hcd* %call, %struct.usb_device* %udev, i32 2)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %enable_lpm, label %cleanup

enable_lpm:                                       ; preds = %if.end18, %if.end14
  call void @usb_enable_lpm(%struct.usb_device* %udev)
  br label %cleanup

cleanup:                                          ; preds = %enable_lpm, %if.end18, %land.lhs.true, %lor.lhs.false6, %if.end, %lor.lhs.false3, %lor.lhs.false2, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ -16, %enable_lpm ], [ 0, %lor.lhs.false3 ], [ 0, %lor.lhs.false2 ], [ 0, %lor.lhs.false ], [ 0, %entry ], [ 0, %lor.lhs.false6 ], [ 0, %if.end ], [ 0, %land.lhs.true ], [ 0, %if.end18 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_disable_link_state(%struct.usb_hcd* %hcd, %struct.usb_device* %udev, i32 %state) #0 {
entry:
  %Pivot = icmp slt i32 %state, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %state, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %state, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %0 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1
  %call2 = call i32 @usb_set_lpm_timeout(%struct.usb_device* %udev, i32 %state, i32 0)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %sw.epilog
  call void @usb_set_device_initiated_lpm(%struct.usb_device* %udev, i32 %state, i1 zeroext false)
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %hcd, i32 0, i32 8
  %1 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %disable_usb3_lpm_timeout = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 40
  %2 = load i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)** %disable_usb3_lpm_timeout, align 8, !tbaa !183
  %call4 = call i32 %2(%struct.usb_hcd* %hcd, %struct.usb_device* %udev, i32 %state)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %cleanup

if.then6:                                         ; preds = %if.end
  %3 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then6, %if.end, %sw.epilog, %sw.default
  %retval.0 = phi i32 [ -22, %sw.default ], [ -16, %sw.epilog ], [ 0, %if.then6 ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_root_hub_lost_power(%struct.usb_device* %rhdev) #0 {
entry:
  %0 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %reset_resume = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 33
  %bf.load = load i8, i8* %reset_resume, align 8
  %bf.clear = and i8 %bf.load, -3
  %bf.set = or i8 %bf.clear, 2
  store i8 %bf.set, i8* %reset_resume, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_hub_clear_tt_buffer(%struct.urb* %urb) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !210
  %pipe1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 10
  %1 = load i32, i32* %pipe1, align 8, !tbaa !212
  %tt2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 5
  %2 = load %struct.usb_tt*, %struct.usb_tt** %tt2, align 8, !tbaa !156
  %call.i = call i8* @__kmalloc(i64 40, i32 32) #8
  %3 = bitcast i8* %call.i to %struct.usb_tt_clear*
  %cmp = icmp eq %struct.usb_tt_clear* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  %multi = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %2, i32 0, i32 1
  %5 = load i32, i32* %multi, align 8, !tbaa !213
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end
  %ttport = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 6
  %6 = load i32, i32* %ttport, align 8, !tbaa !157
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.end
  %cond = phi i32 [ %6, %cond.true ], [ 1, %if.end ]
  %tt5 = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %3, i32 0, i32 1
  store i32 %cond, i32* %tt5, align 8, !tbaa !214
  %shr = ashr i32 %1, 15
  %and = and i32 %shr, 15
  %conv = trunc i32 %and to i16
  %devinfo = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %3, i32 0, i32 2
  store i16 %conv, i16* %devinfo, align 4, !tbaa !216
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 0
  %7 = load i32, i32* %devnum, align 8, !tbaa !38
  %shl = shl i32 %7, 4
  %devinfo6 = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %3, i32 0, i32 2
  %8 = load i16, i16* %devinfo6, align 4, !tbaa !216
  %conv7 = zext i16 %8 to i32
  %or = or i32 %conv7, %shl
  %conv8 = trunc i32 %or to i16
  store i16 %conv8, i16* %devinfo6, align 4, !tbaa !216
  %shr9 = ashr i32 %1, 30
  %and10 = and i32 %shr9, 3
  %cmp11 = icmp eq i32 %and10, 2
  %cond13 = select i1 %cmp11, i32 0, i32 4096
  %devinfo14 = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %3, i32 0, i32 2
  %9 = load i16, i16* %devinfo14, align 4, !tbaa !216
  %conv15 = zext i16 %9 to i32
  %or16 = or i32 %conv15, %cond13
  %conv17 = trunc i32 %or16 to i16
  store i16 %conv17, i16* %devinfo14, align 4, !tbaa !216
  %and18 = and i32 %1, 128
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %if.then20, label %if.end25

if.then20:                                        ; preds = %cond.end
  %devinfo21 = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %3, i32 0, i32 2
  %10 = load i16, i16* %devinfo21, align 4, !tbaa !216
  %conv22 = zext i16 %10 to i32
  %or23 = or i32 %conv22, 32768
  %conv24 = trunc i32 %or23 to i16
  store i16 %conv24, i16* %devinfo21, align 4, !tbaa !216
  br label %if.end25

if.end25:                                         ; preds = %if.then20, %cond.end
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %11 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call26 = call %struct.usb_hcd* @bus_to_hcd.11(%struct.usb_bus* %11)
  %hcd = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %3, i32 0, i32 3
  store %struct.usb_hcd* %call26, %struct.usb_hcd** %hcd, align 8, !tbaa !217
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %12 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !218
  %ep27 = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %3, i32 0, i32 4
  store %struct.usb_host_endpoint* %12, %struct.usb_host_endpoint** %ep27, align 8, !tbaa !219
  %13 = bitcast i64* %__dummy to i8*
  %14 = bitcast i64* %__dummy2 to i8*
  %15 = bitcast i64* %__dummy2 to i8*
  %16 = bitcast i64* %__dummy to i8*
  %lock = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %2, i32 0, i32 3
  %call31 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call32 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call31)
  %clear_list = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %3, i32 0, i32 0
  %clear_list35 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %2, i32 0, i32 4
  call void @list_add_tail(%struct.list_head* %clear_list, %struct.list_head* %clear_list35)
  %clear_work = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %2, i32 0, i32 5
  call void @schedule_work(%struct.work_struct* %clear_work)
  %lock37 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %2, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock37, i64 %call32)
  br label %cleanup

cleanup:                                          ; preds = %if.end25, %if.then
  %retval.0 = phi i32 [ -12, %if.then ], [ 0, %if.end25 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_wakeup_notification(%struct.usb_device* %hdev, i32 %portnum) #0 {
entry:
  %tobool = icmp ne %struct.usb_device* %hdev, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  %tobool1 = icmp ne %struct.usb_hub* %call, null
  br i1 %tobool1, label %if.then2, label %cleanup.cont

if.then2:                                         ; preds = %if.end
  %wakeup_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 14
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %wakeup_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i32 %portnum, i64* %arraydecay) #8, !srcloc !144
  call void @kick_khubd(%struct.usb_hub* %call)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then2, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_kick_khubd(%struct.usb_device* %hdev) #0 {
entry:
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  %tobool = icmp ne %struct.usb_hub* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @kick_khubd(%struct.usb_hub* %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_hub_set_port_power(%struct.usb_device* %hdev, i32 %port1, i1 zeroext %set) #0 {
entry:
  %frombool = zext i1 %set to i8
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 22
  %0 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %0, i64 %idxprom
  %1 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %tobool = trunc i8 %frombool to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = call i32 @set_port_feature(%struct.usb_device* %hdev, i32 %port1, i32 8)
  br label %if.end

if.else:                                          ; preds = %entry
  %call2 = call i32 @usb_clear_port_feature(%struct.usb_device* %hdev, i32 %port1, i32 8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %ret.0 = phi i32 [ %call1, %if.then ], [ %call2, %if.else ]
  %tobool3 = icmp ne i32 %ret.0, 0
  br i1 %tobool3, label %if.end6, label %if.then4

if.then4:                                         ; preds = %if.end
  %tobool5 = trunc i8 %frombool to i1
  %conv = zext i1 %tobool5 to i32
  %power_is_on = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 5
  %2 = trunc i32 %conv to i8
  %bf.load = load i8, i8* %power_is_on, align 1
  %bf.value = and i8 %2, 1
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, %bf.value
  store i8 %bf.set, i8* %power_is_on, align 1
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end
  ret i32 %ret.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_remove_device(%struct.usb_device* %udev) #0 {
entry:
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool = icmp ne %struct.usb_device* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %parent1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %1 = load %struct.usb_device*, %struct.usb_device** %parent1, align 8, !tbaa !89
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %1)
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 0
  %2 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !173
  %3 = bitcast %struct.device* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -48
  %4 = bitcast i8* %add.ptr to %struct.usb_interface*
  %call2 = call i32 @usb_autopm_get_interface(%struct.usb_interface* %4)
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %5 = load i8, i8* %portnum, align 2, !tbaa !88
  %conv = zext i8 %5 to i32
  %removed_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 13
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %removed_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i32 %conv, i64* %arraydecay) #8, !srcloc !144
  %portnum3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %6 = load i8, i8* %portnum3, align 2, !tbaa !88
  %conv4 = zext i8 %6 to i32
  call void @hub_port_logical_disconnect(%struct.usb_hub* %call, i32 %conv4)
  call void @usb_autopm_put_interface(%struct.usb_interface* %4)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_hub_claim_port(%struct.usb_device* %hdev, i32 %port1, %struct.dev_state* %owner) #0 {
entry:
  %powner = alloca %struct.dev_state**, align 8
  %0 = bitcast %struct.dev_state*** %powner to i8*
  %call = call i32 @find_port_owner(%struct.usb_device* %hdev, i32 %port1, %struct.dev_state*** %powner)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = load %struct.dev_state**, %struct.dev_state*** %powner, align 8, !tbaa !48
  %2 = load %struct.dev_state*, %struct.dev_state** %1, align 8, !tbaa !48
  %tobool1 = icmp ne %struct.dev_state* %2, null
  br i1 %tobool1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %3 = load %struct.dev_state**, %struct.dev_state*** %powner, align 8, !tbaa !48
  store %struct.dev_state* %owner, %struct.dev_state** %3, align 8, !tbaa !48
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry
  %retval.0 = phi i32 [ %call, %if.end3 ], [ %call, %entry ], [ -16, %if.end ]
  %4 = bitcast %struct.dev_state*** %powner to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @find_port_owner(%struct.usb_device* %hdev, i32 %port1, %struct.dev_state*** %ppowner) #0 {
entry:
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp eq i32 %port1, 0
  br i1 %cmp1, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 28
  %1 = load i32, i32* %maxchild, align 8, !tbaa !97
  %cmp2 = icmp ugt i32 %port1, %1
  br i1 %cmp2, label %return, label %if.end4

if.end4:                                          ; preds = %lor.lhs.false
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 22
  %2 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %sub = sub i32 %port1, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %2, i64 %idxprom
  %3 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %port_owner = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 2
  store %struct.dev_state** %port_owner, %struct.dev_state*** %ppowner, align 8, !tbaa !48
  br label %return

return:                                           ; preds = %if.end4, %lor.lhs.false, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end4 ], [ -19, %entry ], [ -22, %lor.lhs.false ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_hub_release_port(%struct.usb_device* %hdev, i32 %port1, %struct.dev_state* %owner) #0 {
entry:
  %powner = alloca %struct.dev_state**, align 8
  %0 = bitcast %struct.dev_state*** %powner to i8*
  %call = call i32 @find_port_owner(%struct.usb_device* %hdev, i32 %port1, %struct.dev_state*** %powner)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = load %struct.dev_state**, %struct.dev_state*** %powner, align 8, !tbaa !48
  %2 = load %struct.dev_state*, %struct.dev_state** %1, align 8, !tbaa !48
  %cmp = icmp ne %struct.dev_state* %2, %owner
  br i1 %cmp, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %3 = load %struct.dev_state**, %struct.dev_state*** %powner, align 8, !tbaa !48
  store %struct.dev_state* null, %struct.dev_state** %3, align 8, !tbaa !48
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i32 [ %call, %if.end2 ], [ %call, %entry ], [ -2, %if.end ]
  %4 = bitcast %struct.dev_state*** %powner to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_hub_release_all_ports(%struct.usb_device* %hdev, %struct.dev_state* %owner) #0 {
entry:
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %n.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 28
  %0 = load i32, i32* %maxchild, align 8, !tbaa !97
  %cmp = icmp slt i32 %n.0, %0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 22
  %1 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %idxprom = sext i32 %n.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %1, i64 %idxprom
  %2 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %port_owner = getelementptr inbounds %struct.usb_port, %struct.usb_port* %2, i32 0, i32 2
  %3 = load %struct.dev_state*, %struct.dev_state** %port_owner, align 8, !tbaa !220
  %cmp1 = icmp eq %struct.dev_state* %3, %owner
  br i1 %cmp1, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %ports2 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 22
  %4 = load %struct.usb_port**, %struct.usb_port*** %ports2, align 8, !tbaa !98
  %idxprom3 = sext i32 %n.0 to i64
  %arrayidx4 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %4, i64 %idxprom3
  %5 = load %struct.usb_port*, %struct.usb_port** %arrayidx4, align 8, !tbaa !48
  %port_owner5 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %5, i32 0, i32 2
  store %struct.dev_state* null, %struct.dev_state** %port_owner5, align 8, !tbaa !220
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %inc = add nsw i32 %n.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define zeroext i1 @usb_device_is_owned(%struct.usb_device* %udev) #0 {
entry:
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %1 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool = icmp ne %struct.usb_device* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %parent1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %2 = load %struct.usb_device*, %struct.usb_device** %parent1, align 8, !tbaa !89
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %2)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 22
  %3 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %4 = load i8, i8* %portnum, align 2, !tbaa !88
  %conv = zext i8 %4 to i32
  %sub = sub nsw i32 %conv, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %3, i64 %idxprom
  %5 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %port_owner = getelementptr inbounds %struct.usb_port, %struct.usb_port* %5, i32 0, i32 2
  %6 = load %struct.dev_state*, %struct.dev_state** %port_owner, align 8, !tbaa !220
  %tobool2 = icmp ne %struct.dev_state* %6, null
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  br label %cleanup

cleanup:                                          ; preds = %if.end, %lor.lhs.false, %entry
  %retval.0 = phi i1 [ %lnot3, %if.end ], [ false, %lor.lhs.false ], [ false, %entry ]
  ret i1 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_disconnect(%struct.usb_device** %pdev) #0 {
entry:
  %0 = load %struct.usb_device*, %struct.usb_device** %pdev, align 8, !tbaa !48
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %0)
  call void @usb_set_device_state(%struct.usb_device* %0, i32 0)
  %1 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock(%struct.device* %dev2)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %2 = load i32, i32* %maxchild, align 8, !tbaa !97
  %cmp = icmp slt i32 %i.0, %2
  br i1 %cmp, label %for.body, label %do.body7

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 22
  %3 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %3, i64 %idxprom
  %4 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %4, i32 0, i32 0
  %5 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_device* %5, null
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %ports3 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 22
  %6 = load %struct.usb_port**, %struct.usb_port*** %ports3, align 8, !tbaa !98
  %idxprom4 = sext i32 %i.0 to i64
  %arrayidx5 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %6, i64 %idxprom4
  %7 = load %struct.usb_port*, %struct.usb_port** %arrayidx5, align 8, !tbaa !48
  %child6 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %7, i32 0, i32 0
  call void @usb_disconnect(%struct.usb_device** %child6)
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

do.body7:                                         ; preds = %for.cond
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_disconnect.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool8 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool8, true
  %lnot9 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then11, label %do.end16

if.then11:                                        ; preds = %do.body7
  %dev12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %call13 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_disconnect.descriptor to %struct._ddebug*), %struct.device* %dev12, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.6.17, i32 0, i32 0))
  br label %do.end16

do.end16:                                         ; preds = %if.then11, %do.body7
  call void @usb_disable_device(%struct.usb_device* %0, i32 0)
  call void @usb_hcd_synchronize_unlinks(%struct.usb_device* undef)
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  %8 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool17 = icmp ne %struct.usb_device* %8, null
  br i1 %tobool17, label %if.then18, label %if.end40

if.then18:                                        ; preds = %do.end16
  %parent20 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  %9 = load %struct.usb_device*, %struct.usb_device** %parent20, align 8, !tbaa !89
  %call21 = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %9)
  %ports22 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call21, i32 0, i32 22
  %10 = load %struct.usb_port**, %struct.usb_port*** %ports22, align 8, !tbaa !98
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 20
  %11 = load i8, i8* %portnum, align 2, !tbaa !88
  %conv23 = zext i8 %11 to i32
  %sub = sub nsw i32 %conv23, 1
  %idxprom24 = sext i32 %sub to i64
  %arrayidx25 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %10, i64 %idxprom24
  %12 = load %struct.usb_port*, %struct.usb_port** %arrayidx25, align 8, !tbaa !48
  %dev26 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev26, i32 0, i32 2
  call void @sysfs_remove_link(%struct.kobject* %kobj, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7.18, i32 0, i32 0))
  %dev27 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %12, i32 0, i32 1
  %kobj28 = getelementptr inbounds %struct.device, %struct.device* %dev27, i32 0, i32 2
  call void @sysfs_remove_link(%struct.kobject* %kobj28, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8.19, i32 0, i32 0))
  %did_runtime_put = getelementptr inbounds %struct.usb_port, %struct.usb_port* %12, i32 0, i32 5
  %bf.load29 = load i8, i8* %did_runtime_put, align 1
  %bf.lshr30 = lshr i8 %bf.load29, 1
  %bf.clear31 = and i8 %bf.lshr30, 1
  %bf.cast = zext i8 %bf.clear31 to i32
  %tobool32 = icmp ne i32 %bf.cast, 0
  br i1 %tobool32, label %if.else, label %if.then33

if.then33:                                        ; preds = %if.then18
  %dev34 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %12, i32 0, i32 1
  call void @pm_runtime_put(%struct.device* %dev34)
  br label %if.end40

if.else:                                          ; preds = %if.then18
  %did_runtime_put36 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %12, i32 0, i32 5
  %bf.load37 = load i8, i8* %did_runtime_put36, align 1
  %bf.clear38 = and i8 %bf.load37, -3
  store i8 %bf.clear38, i8* %did_runtime_put36, align 1
  br label %if.end40

if.end40:                                         ; preds = %if.else, %if.then33, %do.end16
  %ep0 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 10
  call void @usb_remove_ep_devs(%struct.usb_host_endpoint* %ep0)
  %dev41 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev41)
  %dev42 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_del(%struct.device* %dev42)
  call void @release_devnum(%struct.usb_device* %0)
  call void @spin_lock_irq(%struct.spinlock* @device_state_lock)
  store %struct.usb_device* null, %struct.usb_device** %pdev, align 8, !tbaa !48
  call void @spin_unlock_irq(%struct.spinlock* @device_state_lock)
  call void @hub_free_dev(%struct.usb_device* %0)
  %dev43 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @put_device(%struct.device* %dev43)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  ret void
}

declare void @sysfs_remove_link(%struct.kobject*, i8*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_idle(%struct.device* %dev, i32 5)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

declare void @device_del(%struct.device*) #2

; Function Attrs: nounwind uwtable
define internal void @release_devnum(%struct.usb_device* %udev) #0 {
entry:
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  %0 = load i32, i32* %devnum, align 8, !tbaa !38
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %devnum1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  %1 = load i32, i32* %devnum1, align 8, !tbaa !38
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %devmap = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %2, i32 0, i32 9
  %devicemap = getelementptr inbounds %struct.usb_devmap, %struct.usb_devmap* %devmap, i32 0, i32 0
  %arraydecay = getelementptr inbounds [2 x i64], [2 x i64]* %devicemap, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i32 %1, i64* %arraydecay) #8, !srcloc !145
  %devnum2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  store i32 -1, i32* %devnum2, align 8, !tbaa !38
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_irq(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irq(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_free_dev(%struct.usb_device* %udev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.11(%struct.usb_bus* %0)
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %1 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %free_dev = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 27
  %2 = load void (%struct.usb_hcd*, %struct.usb_device*)*, void (%struct.usb_hcd*, %struct.usb_device*)** %free_dev, align 8, !tbaa !221
  %tobool = icmp ne void (%struct.usb_hcd*, %struct.usb_device*)* %2, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %3 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool1 = icmp ne %struct.usb_device* %3, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %driver2 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %4 = load %struct.hc_driver*, %struct.hc_driver** %driver2, align 8, !tbaa !71
  %free_dev3 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %4, i32 0, i32 27
  %5 = load void (%struct.usb_hcd*, %struct.usb_device*)*, void (%struct.usb_hcd*, %struct.usb_device*)** %free_dev3, align 8, !tbaa !221
  call void %5(%struct.usb_hcd* %call, %struct.usb_device* %udev)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

declare void @_raw_spin_unlock_irq(%struct.raw_spinlock*) #2 section ".spinlock.text"

declare void @_raw_spin_lock_irq(%struct.raw_spinlock*) #2 section ".spinlock.text"

declare i32 @__pm_runtime_idle(%struct.device*, i32) #2

; Function Attrs: nounwind uwtable
define i32 @usb_new_device(%struct.usb_device* %udev) #0 {
entry:
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool = icmp ne %struct.usb_device* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call = call i32 @device_init_wakeup(%struct.device* %dev, i1 zeroext false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_set_active(%struct.device* %dev1)
  %dev3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_get_noresume(%struct.device* %dev3)
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_use_autosuspend(%struct.device* %dev4)
  %dev5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_enable(%struct.device* %dev5)
  call void @usb_disable_autosuspend(%struct.usb_device* %udev)
  %call6 = call i32 @usb_enumerate_device(%struct.usb_device* %udev)
  %cmp = icmp slt i32 %call6, 0
  br i1 %cmp, label %fail, label %do.body9

do.body9:                                         ; preds = %if.end
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_new_device.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool10 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.then13, label %do.end22

if.then13:                                        ; preds = %do.body9
  %dev14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  %1 = load i32, i32* %devnum, align 8, !tbaa !38
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %busnum = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %2, i32 0, i32 1
  %3 = load i32, i32* %busnum, align 8, !tbaa !35
  %bus15 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %4 = load %struct.usb_bus*, %struct.usb_bus** %bus15, align 8, !tbaa !2
  %busnum16 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %4, i32 0, i32 1
  %5 = load i32, i32* %busnum16, align 8, !tbaa !35
  %sub = sub nsw i32 %5, 1
  %mul = mul nsw i32 %sub, 128
  %devnum17 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  %6 = load i32, i32* %devnum17, align 8, !tbaa !38
  %sub18 = sub nsw i32 %6, 1
  %add = add nsw i32 %mul, %sub18
  %call19 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_new_device.descriptor to %struct._ddebug*), %struct.device* %dev14, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.9.20, i32 0, i32 0), i32 %1, i32 %3, i32 %add)
  br label %do.end22

do.end22:                                         ; preds = %if.then13, %do.body9
  %bus23 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %7 = load %struct.usb_bus*, %struct.usb_bus** %bus23, align 8, !tbaa !2
  %busnum24 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %7, i32 0, i32 1
  %8 = load i32, i32* %busnum24, align 8, !tbaa !35
  %sub25 = sub nsw i32 %8, 1
  %mul26 = mul nsw i32 %sub25, 128
  %devnum27 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  %9 = load i32, i32* %devnum27, align 8, !tbaa !38
  %sub28 = sub nsw i32 %9, 1
  %add29 = add nsw i32 %mul26, %sub28
  %or = or i32 198180864, %add29
  %dev30 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %devt = getelementptr inbounds %struct.device, %struct.device* %dev30, i32 0, i32 20
  store i32 %or, i32* %devt, align 8, !tbaa !222
  call void @announce_device(%struct.usb_device* %udev)
  %serial = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 26
  %10 = load i8*, i8** %serial, align 8, !tbaa !41
  %tobool31 = icmp ne i8* %10, null
  br i1 %tobool31, label %if.then32, label %if.end37

if.then32:                                        ; preds = %do.end22
  %serial33 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 26
  %11 = load i8*, i8** %serial33, align 8, !tbaa !41
  %serial34 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 26
  %12 = load i8*, i8** %serial34, align 8, !tbaa !41
  %call35 = call i64 @strlen(i8* %12)
  %conv36 = trunc i64 %call35 to i32
  call void @add_device_randomness(i8* %11, i32 %conv36)
  br label %if.end37

if.end37:                                         ; preds = %if.then32, %do.end22
  %product = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 24
  %13 = load i8*, i8** %product, align 8, !tbaa !39
  %tobool38 = icmp ne i8* %13, null
  br i1 %tobool38, label %if.then39, label %if.end44

if.then39:                                        ; preds = %if.end37
  %product40 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 24
  %14 = load i8*, i8** %product40, align 8, !tbaa !39
  %product41 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 24
  %15 = load i8*, i8** %product41, align 8, !tbaa !39
  %call42 = call i64 @strlen(i8* %15)
  %conv43 = trunc i64 %call42 to i32
  call void @add_device_randomness(i8* %14, i32 %conv43)
  br label %if.end44

if.end44:                                         ; preds = %if.then39, %if.end37
  %manufacturer = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 25
  %16 = load i8*, i8** %manufacturer, align 8, !tbaa !40
  %tobool45 = icmp ne i8* %16, null
  br i1 %tobool45, label %if.then46, label %if.end51

if.then46:                                        ; preds = %if.end44
  %manufacturer47 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 25
  %17 = load i8*, i8** %manufacturer47, align 8, !tbaa !40
  %manufacturer48 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 25
  %18 = load i8*, i8** %manufacturer48, align 8, !tbaa !40
  %call49 = call i64 @strlen(i8* %18)
  %conv50 = trunc i64 %call49 to i32
  call void @add_device_randomness(i8* %17, i32 %conv50)
  br label %if.end51

if.end51:                                         ; preds = %if.then46, %if.end44
  %dev52 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @device_enable_async_suspend(%struct.device* %dev52)
  %parent53 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %19 = load %struct.usb_device*, %struct.usb_device** %parent53, align 8, !tbaa !89
  %tobool54 = icmp ne %struct.usb_device* %19, null
  br i1 %tobool54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end51
  call void @set_usb_port_removable(%struct.usb_device* %udev)
  br label %if.end56

if.end56:                                         ; preds = %if.then55, %if.end51
  %dev57 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call58 = call i32 @device_add(%struct.device* %dev57)
  %tobool59 = icmp ne i32 %call58, 0
  br i1 %tobool59, label %if.then60, label %if.end63

if.then60:                                        ; preds = %if.end56
  %20 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %fail

if.end63:                                         ; preds = %if.end56
  %parent64 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %21 = load %struct.usb_device*, %struct.usb_device** %parent64, align 8, !tbaa !89
  %tobool65 = icmp ne %struct.usb_device* %21, null
  br i1 %tobool65, label %if.then66, label %if.end91

if.then66:                                        ; preds = %if.end63
  %parent67 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %22 = load %struct.usb_device*, %struct.usb_device** %parent67, align 8, !tbaa !89
  %call68 = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %22)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call68, i32 0, i32 22
  %23 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %24 = load i8, i8* %portnum, align 2, !tbaa !88
  %conv69 = zext i8 %24 to i32
  %sub70 = sub nsw i32 %conv69, 1
  %idxprom = sext i32 %sub70 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %23, i64 %idxprom
  %25 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %dev71 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev71, i32 0, i32 2
  %dev72 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %25, i32 0, i32 1
  %kobj73 = getelementptr inbounds %struct.device, %struct.device* %dev72, i32 0, i32 2
  %call74 = call i32 @sysfs_create_link(%struct.kobject* %kobj, %struct.kobject* %kobj73, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7.18, i32 0, i32 0))
  %tobool75 = icmp ne i32 %call74, 0
  br i1 %tobool75, label %NodeBlock, label %if.end77

if.end77:                                         ; preds = %if.then66
  %dev78 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %25, i32 0, i32 1
  %kobj79 = getelementptr inbounds %struct.device, %struct.device* %dev78, i32 0, i32 2
  %dev80 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %kobj81 = getelementptr inbounds %struct.device, %struct.device* %dev80, i32 0, i32 2
  %call82 = call i32 @sysfs_create_link(%struct.kobject* %kobj79, %struct.kobject* %kobj81, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.8.19, i32 0, i32 0))
  %tobool83 = icmp ne i32 %call82, 0
  br i1 %tobool83, label %if.then84, label %if.end87

if.then84:                                        ; preds = %if.end77
  %dev85 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %kobj86 = getelementptr inbounds %struct.device, %struct.device* %dev85, i32 0, i32 2
  call void @sysfs_remove_link(%struct.kobject* %kobj86, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7.18, i32 0, i32 0))
  br label %NodeBlock

if.end87:                                         ; preds = %if.end77
  %dev88 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %25, i32 0, i32 1
  %call89 = call i32 @pm_runtime_get_sync(%struct.device* %dev88)
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end87, %if.then84, %if.then66
  %err.0 = phi i32 [ %call82, %if.then84 ], [ %call82, %if.end87 ], [ %call74, %if.then66 ]
  %cleanup.dest.slot.0 = phi i32 [ 2, %if.then84 ], [ 0, %if.end87 ], [ 2, %if.then66 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf2, label %fail, label %cleanup98

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end91, label %cleanup98

if.end91:                                         ; preds = %LeafBlock, %if.end63
  %err.1 = phi i32 [ %call58, %if.end63 ], [ %err.0, %LeafBlock ]
  %dev92 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %ep0 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 10
  %call93 = call i32 bitcast (i32 (%struct.device.2626*, %struct.usb_host_endpoint*, %struct.usb_device.2852*)* @usb_create_ep_devs to i32 (%struct.device*, %struct.usb_host_endpoint*, %struct.usb_device*)*)(%struct.device* %dev92, %struct.usb_host_endpoint* %ep0, %struct.usb_device* %udev)
  call void @usb_mark_last_busy(%struct.usb_device* %udev)
  %dev94 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_put_sync_autosuspend(%struct.device* %dev94)
  br label %cleanup98

fail:                                             ; preds = %LeafBlock1, %if.then60, %if.end
  %err.2 = phi i32 [ %call58, %if.then60 ], [ %err.0, %LeafBlock1 ], [ %call6, %if.end ]
  call void @usb_set_device_state(%struct.usb_device* %udev, i32 0)
  %dev96 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_disable(%struct.device* %dev96)
  %dev97 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_set_suspended(%struct.device* %dev97)
  br label %cleanup98

cleanup98:                                        ; preds = %fail, %if.end91, %LeafBlock, %LeafBlock1
  %retval.0 = phi i32 [ %err.2, %fail ], [ %err.1, %if.end91 ], [ undef, %LeafBlock1 ], [ undef, %LeafBlock ]
  ret i32 %retval.0
}

declare i32 @device_init_wakeup(%struct.device*, i1 zeroext) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_set_active(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_set_status(%struct.device* %dev, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_get_noresume(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %usage_count = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 11
  call void @atomic_inc(%union.anon.5* %usage_count)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_use_autosuspend(%struct.device* %dev) #1 {
entry:
  call void @__pm_runtime_use_autosuspend(%struct.device* %dev, i1 zeroext true)
  ret void
}

declare void @pm_runtime_enable(%struct.device*) #2

; Function Attrs: nounwind uwtable
define internal i32 @usb_enumerate_device(%struct.usb_device* %udev) #0 {
entry:
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 14
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !167
  %cmp = icmp eq %struct.usb_host_config* %0, null
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %call = call i32 @usb_get_configuration(%struct.usb_device* %udev)
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.then
  %cmp3 = icmp ne i32 %call, -19
  br i1 %cmp3, label %if.then4, label %cleanup

if.then4:                                         ; preds = %if.then2
  %1 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end7:                                          ; preds = %if.then, %entry
  %wusb = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %wusb, align 4
  %bf.lshr = lshr i16 %bf.load, 5
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %cmp8 = icmp eq i32 %bf.cast, 1
  br i1 %cmp8, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end7
  %authorized = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load9 = load i16, i16* %authorized, align 4
  %bf.lshr10 = lshr i16 %bf.load9, 3
  %bf.clear11 = and i16 %bf.lshr10, 1
  %bf.cast12 = zext i16 %bf.clear11 to i32
  %cmp13 = icmp eq i32 %bf.cast12, 0
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %land.lhs.true
  %call15 = call i8* @kstrdup(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.11.22, i32 0, i32 0), i32 208)
  %product = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 24
  store i8* %call15, i8** %product, align 8, !tbaa !39
  %call16 = call i8* @kstrdup(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.11.22, i32 0, i32 0), i32 208)
  %manufacturer = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 25
  store i8* %call16, i8** %manufacturer, align 8, !tbaa !40
  %call17 = call i8* @kstrdup(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.11.22, i32 0, i32 0), i32 208)
  br label %if.end28

if.else:                                          ; preds = %land.lhs.true, %if.end7
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %iProduct = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 11
  %2 = load i8, i8* %iProduct, align 1, !tbaa !223
  %conv = zext i8 %2 to i32
  %call18 = call i8* @usb_cache_string(%struct.usb_device* %udev, i32 %conv)
  %product19 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 24
  store i8* %call18, i8** %product19, align 8, !tbaa !39
  %descriptor20 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %iManufacturer = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor20, i32 0, i32 10
  %3 = load i8, i8* %iManufacturer, align 2, !tbaa !224
  %conv21 = zext i8 %3 to i32
  %call22 = call i8* @usb_cache_string(%struct.usb_device* %udev, i32 %conv21)
  %manufacturer23 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 25
  store i8* %call22, i8** %manufacturer23, align 8, !tbaa !40
  %descriptor24 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %iSerialNumber = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor24, i32 0, i32 12
  %4 = load i8, i8* %iSerialNumber, align 8, !tbaa !171
  %conv25 = zext i8 %4 to i32
  %call26 = call i8* @usb_cache_string(%struct.usb_device* %udev, i32 %conv25)
  br label %if.end28

if.end28:                                         ; preds = %if.else, %if.then14
  %call26.sink = phi i8* [ %call26, %if.else ], [ %call17, %if.then14 ]
  %serial27 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 26
  store i8* %call26.sink, i8** %serial27, align 8, !tbaa !41
  %call29 = call i32 @usb_enumerate_device_otg(%struct.usb_device* %udev)
  %cmp30 = icmp slt i32 %call29, 0
  br i1 %cmp30, label %cleanup, label %if.end33

if.end33:                                         ; preds = %if.end28
  call void @usb_detect_interface_quirks(%struct.usb_device* %udev)
  br label %cleanup

cleanup:                                          ; preds = %if.end33, %if.end28, %if.then4, %if.then2
  %retval.0 = phi i32 [ 0, %if.end33 ], [ %call, %if.then4 ], [ %call, %if.then2 ], [ %call29, %if.end28 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @announce_device(%struct.usb_device* %udev) #0 {
entry:
  %0 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %1 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %product = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 24
  %2 = load i8*, i8** %product, align 8, !tbaa !39
  call void @show_string(i8* %2)
  %manufacturer = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 25
  %3 = load i8*, i8** %manufacturer, align 8, !tbaa !40
  call void @show_string(i8* %3)
  %serial = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 26
  %4 = load i8*, i8** %serial, align 8, !tbaa !41
  call void @show_string(i8* %4)
  ret void
}

declare void @add_device_randomness(i8*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_enable_async_suspend(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %is_prepared = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i8, i8* %is_prepared, align 4
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %power1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %async_suspend = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power1, i32 0, i32 1
  %bf.load2 = load i8, i8* %async_suspend, align 4
  %bf.clear3 = and i8 %bf.load2, -3
  %bf.set = or i8 %bf.clear3, 2
  store i8 %bf.set, i8* %async_suspend, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @set_usb_port_removable(%struct.usb_device* %udev) #0 {
entry:
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %1 = load i8, i8* %portnum, align 2, !tbaa !88
  %tobool = icmp ne %struct.usb_device* %0, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %parent1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %2 = load %struct.usb_device*, %struct.usb_device** %parent1, align 8, !tbaa !89
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %2)
  %descriptor = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 15
  %3 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !204
  %wHubCharacteristics2 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %3, i32 0, i32 3
  %4 = load i16, i16* %wHubCharacteristics2, align 1, !tbaa !225
  %conv = zext i16 %4 to i32
  %and = and i32 %conv, 4
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.end5, label %cleanup.cont

if.end5:                                          ; preds = %if.end
  %call6 = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool7 = icmp ne i32 %call6, 0
  %descriptor9 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 15
  %5 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor9, align 8, !tbaa !204
  %u = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %5, i32 0, i32 6
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end5
  %ss = bitcast %union.anon.49* %u to %struct.anon.51*
  %DeviceRemovable = getelementptr inbounds %struct.anon.51, %struct.anon.51* %ss, i32 0, i32 2
  %6 = load i16, i16* %DeviceRemovable, align 1, !tbaa !84
  %conv10 = zext i16 %6 to i32
  %conv11 = zext i8 %1 to i32
  br label %if.end27

if.else:                                          ; preds = %if.end5
  %hs = bitcast %union.anon.49* %u to %struct.anon.50*
  %DeviceRemovable18 = getelementptr inbounds %struct.anon.50, %struct.anon.50* %hs, i32 0, i32 0
  %conv19 = zext i8 %1 to i32
  %div = sdiv i32 %conv19, 8
  %idxprom = sext i32 %div to i64
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* %DeviceRemovable18, i64 0, i64 %idxprom
  %7 = load i8, i8* %arrayidx, align 1, !tbaa !84
  %conv20 = zext i8 %7 to i32
  %conv21 = zext i8 %1 to i32
  %rem = srem i32 %conv21, 8
  br label %if.end27

if.end27:                                         ; preds = %if.else, %if.then8
  %rem.sink = phi i32 [ %rem, %if.else ], [ %conv11, %if.then8 ]
  %conv20.sink = phi i32 [ %conv20, %if.else ], [ %conv10, %if.then8 ]
  %shl22 = shl i32 1, %rem.sink
  %and23 = and i32 %conv20.sink, %shl22
  %tobool24 = icmp ne i32 %and23, 0
  %.1 = select i1 %tobool24, i8 0, i8 1
  %tobool28 = trunc i8 %.1 to i1
  %removable30 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 36
  %.sink = select i1 %tobool28, i32 1, i32 2
  store i32 %.sink, i32* %removable30, align 4, !tbaa !227
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end27, %if.end, %entry
  ret void
}

declare i32 @device_add(%struct.device*) #2

declare i32 @sysfs_create_link(%struct.kobject*, %struct.kobject*, i8*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pm_runtime_get_sync(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_resume(%struct.device* %dev, i32 4)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_mark_last_busy(%struct.usb_device* %udev) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_mark_last_busy(%struct.device* %dev)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put_sync_autosuspend(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_suspend(%struct.device* %dev, i32 12)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_disable(%struct.device* %dev) #1 {
entry:
  call void @__pm_runtime_disable(%struct.device* %dev, i1 zeroext true)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_set_suspended(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_set_status(%struct.device* %dev, i32 2)
  ret void
}

declare i32 @__pm_runtime_set_status(%struct.device*, i32) #2

declare void @__pm_runtime_disable(%struct.device*, i1 zeroext) #2

declare i32 @__pm_runtime_suspend(%struct.device*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_mark_last_busy(%struct.device* %dev) #1 {
entry:
  %0 = load volatile i64, i64* @jiffies, align 8, !tbaa !49
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %last_busy = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 18
  store volatile i64 %0, i64* %last_busy, align 8, !tbaa !49
  ret void
}

declare i32 @__pm_runtime_resume(%struct.device*, i32) #2

; Function Attrs: nounwind uwtable
define internal void @show_string(i8* %string) #0 {
entry:
  %tobool = icmp ne i8* %string, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %0 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare i8* @kstrdup(i8*, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @usb_enumerate_device_otg(%struct.usb_device* %udev) #0 {
entry:
  %desc = alloca %struct.usb_otg_descriptor*, align 8
  %.compoundliteral = alloca %union.anon.5, align 4
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %is_b_host = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 6
  %bf.load = load i8, i8* %is_b_host, align 1
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end47, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 14
  %1 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !167
  %tobool1 = icmp ne %struct.usb_host_config* %1, null
  br i1 %tobool1, label %land.lhs.true2, label %if.end47

land.lhs.true2:                                   ; preds = %land.lhs.true
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %2 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %bus3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %3 = load %struct.usb_bus*, %struct.usb_bus** %bus3, align 8, !tbaa !2
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %3, i32 0, i32 10
  %4 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !228
  %cmp = icmp eq %struct.usb_device* %2, %4
  br i1 %cmp, label %if.then, label %if.end47

if.then:                                          ; preds = %land.lhs.true2
  %5 = bitcast %struct.usb_otg_descriptor** %desc to i8*
  store %struct.usb_otg_descriptor* null, %struct.usb_otg_descriptor** %desc, align 8, !tbaa !48
  %bus5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %6 = load %struct.usb_bus*, %struct.usb_bus** %bus5, align 8, !tbaa !2
  %rawdescriptors = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 18
  %7 = load i8**, i8*** %rawdescriptors, align 8, !tbaa !169
  %arrayidx = getelementptr inbounds i8*, i8** %7, i64 0
  %8 = load i8*, i8** %arrayidx, align 8, !tbaa !48
  %config6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 14
  %9 = load %struct.usb_host_config*, %struct.usb_host_config** %config6, align 8, !tbaa !167
  %arrayidx7 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %9, i64 0
  %desc8 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx7, i32 0, i32 0
  %wTotalLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc8, i32 0, i32 2
  %10 = load i16, i16* %wTotalLength, align 2, !tbaa !168
  %conv = zext i16 %10 to i32
  %11 = bitcast %struct.usb_otg_descriptor** %desc to i8**
  %call = call i32 @__usb_get_extra_descriptor(i8* %8, i32 %conv, i8 zeroext 9, i8** %11)
  %cmp9 = icmp eq i32 %call, 0
  br i1 %cmp9, label %if.then11, label %if.end46

if.then11:                                        ; preds = %if.then
  %12 = load %struct.usb_otg_descriptor*, %struct.usb_otg_descriptor** %desc, align 8, !tbaa !48
  %bmAttributes = getelementptr inbounds %struct.usb_otg_descriptor, %struct.usb_otg_descriptor* %12, i32 0, i32 2
  %13 = load i8, i8* %bmAttributes, align 1, !tbaa !229
  %conv12 = zext i8 %13 to i32
  %and = and i32 %conv12, 2
  %tobool13 = icmp ne i32 %and, 0
  br i1 %tobool13, label %if.then14, label %if.end46

if.then14:                                        ; preds = %if.then11
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %14 = load i8, i8* %portnum, align 2, !tbaa !88
  %conv15 = zext i8 %14 to i32
  %15 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %otg_port20 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %6, i32 0, i32 5
  %16 = load i8, i8* %otg_port20, align 2, !tbaa !154
  %conv21 = zext i8 %16 to i32
  %cmp22 = icmp eq i32 %conv15, %conv21
  br i1 %cmp22, label %if.then24, label %if.end

if.then24:                                        ; preds = %if.then14
  %b_hnp_enable = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %6, i32 0, i32 6
  %bf.load25 = load i8, i8* %b_hnp_enable, align 1
  %bf.clear26 = and i8 %bf.load25, -3
  %bf.set = or i8 %bf.clear26, 2
  store i8 %bf.set, i8* %b_hnp_enable, align 1
  br label %if.end

if.end:                                           ; preds = %if.then24, %if.then14
  %call27 = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or = or i32 -2147483648, %call27
  %b_hnp_enable28 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %6, i32 0, i32 6
  %bf.load29 = load i8, i8* %b_hnp_enable28, align 1
  %bf.lshr = lshr i8 %bf.load29, 1
  %bf.clear30 = and i8 %bf.lshr, 1
  %bf.cast31 = zext i8 %bf.clear30 to i32
  %tobool32 = icmp ne i32 %bf.cast31, 0
  %cond33 = select i1 %tobool32, i32 3, i32 5
  %conv34 = trunc i32 %cond33 to i16
  %call35 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext 3, i8 zeroext 0, i16 zeroext %conv34, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  %cmp36 = icmp slt i32 %call35, 0
  br i1 %cmp36, label %if.then38, label %if.end46

if.then38:                                        ; preds = %if.end
  %17 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %b_hnp_enable41 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %6, i32 0, i32 6
  %bf.load42 = load i8, i8* %b_hnp_enable41, align 1
  %bf.clear43 = and i8 %bf.load42, -3
  store i8 %bf.clear43, i8* %b_hnp_enable41, align 1
  br label %if.end46

if.end46:                                         ; preds = %if.then38, %if.end, %if.then11, %if.then
  %err.1 = phi i32 [ 0, %if.then ], [ 0, %if.then11 ], [ %call35, %if.then38 ], [ %call35, %if.end ]
  %18 = bitcast %struct.usb_otg_descriptor** %desc to i8*
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %land.lhs.true2, %land.lhs.true, %entry
  %err.2 = phi i32 [ 0, %entry ], [ %err.1, %if.end46 ], [ 0, %land.lhs.true2 ], [ 0, %land.lhs.true ]
  %call48 = call i32 @is_targeted(%struct.usb_device* %udev)
  %tobool49 = icmp ne i32 %call48, 0
  br i1 %tobool49, label %fail, label %if.then50

if.then50:                                        ; preds = %if.end47
  %bus51 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %19 = load %struct.usb_bus*, %struct.usb_bus** %bus51, align 8, !tbaa !2
  %b_hnp_enable52 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %19, i32 0, i32 6
  %bf.load53 = load i8, i8* %b_hnp_enable52, align 1
  %bf.lshr54 = lshr i8 %bf.load53, 1
  %bf.clear55 = and i8 %bf.lshr54, 1
  %bf.cast56 = zext i8 %bf.clear55 to i32
  %tobool57 = icmp ne i32 %bf.cast56, 0
  br i1 %tobool57, label %if.then64, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then50
  %bus58 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %20 = load %struct.usb_bus*, %struct.usb_bus** %bus58, align 8, !tbaa !2
  %is_b_host59 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %20, i32 0, i32 6
  %bf.load60 = load i8, i8* %is_b_host59, align 1
  %bf.clear61 = and i8 %bf.load60, 1
  %bf.cast62 = zext i8 %bf.clear61 to i32
  %tobool63 = icmp ne i32 %bf.cast62, 0
  br i1 %tobool63, label %if.then64, label %fail

if.then64:                                        ; preds = %lor.lhs.false, %if.then50
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  store i32 2, i32* %event, align 4, !tbaa !42
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  %21 = load i32, i32* %coerce.dive, align 4
  %call65 = call i32 @usb_port_suspend(%struct.usb_device* %udev, i32 %21)
  %cmp66 = icmp slt i32 %call65, 0
  br i1 %cmp66, label %do.body69, label %fail

do.body69:                                        ; preds = %if.then64
  %bf.load70 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_enumerate_device_otg.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr71 = lshr i32 %bf.load70, 18
  %bf.clear72 = and i32 %bf.lshr71, 255
  %and73 = and i32 %bf.clear72, 1
  %tobool74 = icmp ne i32 %and73, 0
  %lnot = xor i1 %tobool74, true
  %lnot75 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot75 to i32
  %conv76 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv76, i64 0)
  %tobool77 = icmp ne i64 %expval, 0
  br i1 %tobool77, label %if.then78, label %fail

if.then78:                                        ; preds = %do.body69
  %dev79 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call80 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_enumerate_device_otg.descriptor to %struct._ddebug*), %struct.device* %dev79, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.52, i32 0, i32 0), i32 %call65)
  br label %fail

fail:                                             ; preds = %if.then78, %do.body69, %if.then64, %lor.lhs.false, %if.end47
  %err.3 = phi i32 [ -524, %if.then64 ], [ -524, %if.then78 ], [ -524, %do.body69 ], [ -524, %lor.lhs.false ], [ %err.2, %if.end47 ]
  ret i32 %err.3
}

; Function Attrs: nounwind uwtable
define internal i32 @is_targeted(%struct.usb_device* %dev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %otg_port = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 5
  %1 = load i8, i8* %otg_port, align 2, !tbaa !154
  %tobool = icmp ne i8 %1, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %idVendor = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 7
  %2 = load i16, i16* %idVendor, align 8, !tbaa !231
  %conv = zext i16 %2 to i32
  %cmp = icmp eq i32 %conv, 6666
  br i1 %cmp, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %if.end
  %descriptor2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %idProduct = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor2, i32 0, i32 8
  %3 = load i16, i16* %idProduct, align 2, !tbaa !232
  %conv3 = zext i16 %3 to i32
  %cmp4 = icmp eq i32 %conv3, 47837
  br i1 %cmp4, label %cleanup, label %if.end7

if.end7:                                          ; preds = %land.lhs.true, %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %id.0 = phi %struct.usb_device_id* [ getelementptr inbounds ([4 x %struct.usb_device_id], [4 x %struct.usb_device_id]* @whitelist_table, i32 0, i32 0), %if.end7 ], [ %incdec.ptr, %for.inc ]
  %match_flags = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 0
  %4 = load i16, i16* %match_flags, align 8, !tbaa !233
  %tobool8 = icmp ne i16 %4, 0
  br i1 %tobool8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %match_flags9 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 0
  %5 = load i16, i16* %match_flags9, align 8, !tbaa !233
  %conv10 = zext i16 %5 to i32
  %and = and i32 %conv10, 1
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %land.lhs.true12, label %if.end21

land.lhs.true12:                                  ; preds = %for.body
  %idVendor13 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 1
  %6 = load i16, i16* %idVendor13, align 2, !tbaa !235
  %conv14 = zext i16 %6 to i32
  %descriptor15 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %idVendor16 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor15, i32 0, i32 7
  %7 = load i16, i16* %idVendor16, align 8, !tbaa !231
  %conv17 = zext i16 %7 to i32
  %cmp18 = icmp ne i32 %conv14, %conv17
  br i1 %cmp18, label %for.inc, label %if.end21

if.end21:                                         ; preds = %land.lhs.true12, %for.body
  %match_flags22 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 0
  %8 = load i16, i16* %match_flags22, align 8, !tbaa !233
  %conv23 = zext i16 %8 to i32
  %and24 = and i32 %conv23, 2
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %land.lhs.true26, label %if.end35

land.lhs.true26:                                  ; preds = %if.end21
  %idProduct27 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 2
  %9 = load i16, i16* %idProduct27, align 4, !tbaa !236
  %conv28 = zext i16 %9 to i32
  %descriptor29 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %idProduct30 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor29, i32 0, i32 8
  %10 = load i16, i16* %idProduct30, align 2, !tbaa !232
  %conv31 = zext i16 %10 to i32
  %cmp32 = icmp ne i32 %conv28, %conv31
  br i1 %cmp32, label %for.inc, label %if.end35

if.end35:                                         ; preds = %land.lhs.true26, %if.end21
  %match_flags36 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 0
  %11 = load i16, i16* %match_flags36, align 8, !tbaa !233
  %conv37 = zext i16 %11 to i32
  %and38 = and i32 %conv37, 4
  %tobool39 = icmp ne i32 %and38, 0
  br i1 %tobool39, label %land.lhs.true40, label %if.end47

land.lhs.true40:                                  ; preds = %if.end35
  %bcdDevice_lo = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 3
  %12 = load i16, i16* %bcdDevice_lo, align 2, !tbaa !237
  %conv41 = zext i16 %12 to i32
  %descriptor42 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bcdDevice = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor42, i32 0, i32 9
  %13 = load i16, i16* %bcdDevice, align 4, !tbaa !238
  %conv43 = zext i16 %13 to i32
  %cmp44 = icmp sgt i32 %conv41, %conv43
  br i1 %cmp44, label %for.inc, label %if.end47

if.end47:                                         ; preds = %land.lhs.true40, %if.end35
  %match_flags48 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 0
  %14 = load i16, i16* %match_flags48, align 8, !tbaa !233
  %conv49 = zext i16 %14 to i32
  %and50 = and i32 %conv49, 8
  %tobool51 = icmp ne i32 %and50, 0
  br i1 %tobool51, label %land.lhs.true52, label %if.end60

land.lhs.true52:                                  ; preds = %if.end47
  %bcdDevice_hi = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 4
  %15 = load i16, i16* %bcdDevice_hi, align 8, !tbaa !239
  %conv53 = zext i16 %15 to i32
  %descriptor54 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bcdDevice55 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor54, i32 0, i32 9
  %16 = load i16, i16* %bcdDevice55, align 4, !tbaa !238
  %conv56 = zext i16 %16 to i32
  %cmp57 = icmp slt i32 %conv53, %conv56
  br i1 %cmp57, label %for.inc, label %if.end60

if.end60:                                         ; preds = %land.lhs.true52, %if.end47
  %match_flags61 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 0
  %17 = load i16, i16* %match_flags61, align 8, !tbaa !233
  %conv62 = zext i16 %17 to i32
  %and63 = and i32 %conv62, 16
  %tobool64 = icmp ne i32 %and63, 0
  br i1 %tobool64, label %land.lhs.true65, label %if.end73

land.lhs.true65:                                  ; preds = %if.end60
  %bDeviceClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 5
  %18 = load i8, i8* %bDeviceClass, align 2, !tbaa !240
  %conv66 = zext i8 %18 to i32
  %descriptor67 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bDeviceClass68 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor67, i32 0, i32 3
  %19 = load i8, i8* %bDeviceClass68, align 4, !tbaa !241
  %conv69 = zext i8 %19 to i32
  %cmp70 = icmp ne i32 %conv66, %conv69
  br i1 %cmp70, label %for.inc, label %if.end73

if.end73:                                         ; preds = %land.lhs.true65, %if.end60
  %match_flags74 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 0
  %20 = load i16, i16* %match_flags74, align 8, !tbaa !233
  %conv75 = zext i16 %20 to i32
  %and76 = and i32 %conv75, 32
  %tobool77 = icmp ne i32 %and76, 0
  br i1 %tobool77, label %land.lhs.true78, label %if.end86

land.lhs.true78:                                  ; preds = %if.end73
  %bDeviceSubClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 6
  %21 = load i8, i8* %bDeviceSubClass, align 1, !tbaa !242
  %conv79 = zext i8 %21 to i32
  %descriptor80 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bDeviceSubClass81 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor80, i32 0, i32 4
  %22 = load i8, i8* %bDeviceSubClass81, align 1, !tbaa !243
  %conv82 = zext i8 %22 to i32
  %cmp83 = icmp ne i32 %conv79, %conv82
  br i1 %cmp83, label %for.inc, label %if.end86

if.end86:                                         ; preds = %land.lhs.true78, %if.end73
  %match_flags87 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 0
  %23 = load i16, i16* %match_flags87, align 8, !tbaa !233
  %conv88 = zext i16 %23 to i32
  %and89 = and i32 %conv88, 64
  %tobool90 = icmp ne i32 %and89, 0
  br i1 %tobool90, label %land.lhs.true91, label %cleanup

land.lhs.true91:                                  ; preds = %if.end86
  %bDeviceProtocol = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 0, i32 7
  %24 = load i8, i8* %bDeviceProtocol, align 4, !tbaa !244
  %conv92 = zext i8 %24 to i32
  %descriptor93 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bDeviceProtocol94 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor93, i32 0, i32 5
  %25 = load i8, i8* %bDeviceProtocol94, align 2, !tbaa !175
  %conv95 = zext i8 %25 to i32
  %cmp96 = icmp ne i32 %conv92, %conv95
  br i1 %cmp96, label %for.inc, label %cleanup

for.inc:                                          ; preds = %land.lhs.true91, %land.lhs.true78, %land.lhs.true65, %land.lhs.true52, %land.lhs.true40, %land.lhs.true26, %land.lhs.true12
  %incdec.ptr = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %26 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %land.lhs.true91, %if.end86, %land.lhs.true, %entry
  %retval.0 = phi i32 [ 0, %for.end ], [ 1, %entry ], [ 0, %land.lhs.true ], [ 1, %land.lhs.true91 ], [ 1, %if.end86 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_port_suspend(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %0)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 22
  %1 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %2 = load i8, i8* %portnum, align 2, !tbaa !88
  %conv = zext i8 %2 to i32
  %sub = sub nsw i32 %conv, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %1, i64 %idxprom
  %3 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %portnum1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %4 = load i8, i8* %portnum1, align 2, !tbaa !88
  %conv2 = zext i8 %4 to i32
  %do_remote_wakeup = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load = load i8, i8* %do_remote_wakeup, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.end30

if.then:                                          ; preds = %entry
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %call3 = call i32 @hub_is_superspeed(%struct.usb_device* %5)
  %tobool4 = icmp ne i32 %call3, 0
  %call8 = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or9 = or i32 -2147483648, %call8
  br i1 %tobool4, label %if.else, label %if.then5

if.then5:                                         ; preds = %if.then
  %call7 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or9, i8 zeroext 3, i8 zeroext 0, i16 zeroext 1, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  br label %if.end

if.else:                                          ; preds = %if.then
  %call10 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or9, i8 zeroext 3, i8 zeroext 1, i16 zeroext 0, i16 zeroext 768, i8* null, i16 zeroext 0, i32 5000)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then5
  %status.0 = phi i32 [ %call10, %if.else ], [ %call7, %if.then5 ]
  %tobool11 = icmp ne i32 %status.0, 0
  br i1 %tobool11, label %do.body13, label %if.end30

do.body13:                                        ; preds = %if.end
  %bf.load14 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_suspend.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load14, 18
  %bf.clear15 = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear15, 1
  %tobool16 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool16, true
  %lnot17 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot17 to i32
  %conv18 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv18, i64 0)
  %tobool19 = icmp ne i64 %expval, 0
  br i1 %tobool19, label %if.then20, label %do.end24

if.then20:                                        ; preds = %do.body13
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call21 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_suspend.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.16, i32 0, i32 0), i32 %status.0)
  br label %do.end24

do.end24:                                         ; preds = %if.then20, %do.body13
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %6 = load i32, i32* %event, align 4, !tbaa !42
  %and25 = and i32 %6, 1024
  %cmp = icmp ne i32 %and25, 0
  br i1 %cmp, label %cleanup, label %if.end30

if.end30:                                         ; preds = %do.end24, %if.end, %entry
  %usb2_hw_lpm_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load31 = load i16, i16* %usb2_hw_lpm_enabled, align 4
  %bf.lshr32 = lshr i16 %bf.load31, 8
  %bf.clear33 = and i16 %bf.lshr32, 1
  %bf.cast34 = zext i16 %bf.clear33 to i32
  %cmp35 = icmp eq i32 %bf.cast34, 1
  br i1 %cmp35, label %if.then37, label %if.end39

if.then37:                                        ; preds = %if.end30
  %call38 = call i32 @usb_set_usb2_hardware_lpm(%struct.usb_device* %udev, i32 0)
  br label %if.end39

if.end39:                                         ; preds = %if.then37, %if.end30
  %call40 = call i32 @usb_disable_ltm(%struct.usb_device* %udev)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.then42, label %if.end45

if.then42:                                        ; preds = %if.end39
  %7 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end45:                                         ; preds = %if.end39
  %call46 = call i32 @usb_unlocked_disable_lpm(%struct.usb_device* %udev)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %if.then48, label %if.end51

if.then48:                                        ; preds = %if.end45
  %8 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end51:                                         ; preds = %if.end45
  %hdev52 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %hdev52, align 8, !tbaa !152
  %call53 = call i32 @hub_is_superspeed(%struct.usb_device* %9)
  %tobool54 = icmp ne i32 %call53, 0
  br i1 %tobool54, label %if.then55, label %if.else57

if.then55:                                        ; preds = %if.end51
  %call56 = call i32 @hub_set_port_link_state(%struct.usb_hub* %call, i32 %conv2, i32 96)
  br label %if.end67

if.else57:                                        ; preds = %if.end51
  %event58 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %10 = load i32, i32* %event58, align 4, !tbaa !42
  %and59 = and i32 %10, 1024
  %cmp60 = icmp ne i32 %and59, 0
  br i1 %cmp60, label %if.then62, label %if.end67

if.then62:                                        ; preds = %if.else57
  %hdev63 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %11 = load %struct.usb_device*, %struct.usb_device** %hdev63, align 8, !tbaa !152
  %call64 = call i32 @set_port_feature(%struct.usb_device* %11, i32 %conv2, i32 2)
  br label %if.end67

if.end67:                                         ; preds = %if.then62, %if.else57, %if.then55
  %status.2 = phi i32 [ %call56, %if.then55 ], [ %call64, %if.then62 ], [ 0, %if.else57 ]
  %really_suspend.1 = phi i8 [ 1, %if.then55 ], [ 1, %if.then62 ], [ 0, %if.else57 ]
  %tobool68 = icmp ne i32 %status.2, 0
  br i1 %tobool68, label %do.body71, label %do.body125

do.body71:                                        ; preds = %if.end67
  %bf.load72 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_suspend.descriptor.19 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr73 = lshr i32 %bf.load72, 18
  %bf.clear74 = and i32 %bf.lshr73, 255
  %and75 = and i32 %bf.clear74, 1
  %tobool76 = icmp ne i32 %and75, 0
  %lnot77 = xor i1 %tobool76, true
  %lnot79 = xor i1 %lnot77, true
  %lnot.ext80 = zext i1 %lnot79 to i32
  %conv81 = sext i32 %lnot.ext80 to i64
  %expval82 = call i64 @llvm.expect.i64(i64 %conv81, i64 0)
  %tobool83 = icmp ne i64 %expval82, 0
  br i1 %tobool83, label %if.then84, label %do.end90

if.then84:                                        ; preds = %do.body71
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 0
  %12 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !173
  %call85 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_suspend.descriptor.19 to %struct._ddebug*), %struct.device* %12, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.20, i32 0, i32 0), i32 %conv2, i32 %status.2)
  br label %do.end90

do.end90:                                         ; preds = %if.then84, %do.body71
  %do_remote_wakeup91 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load92 = load i8, i8* %do_remote_wakeup91, align 8
  %bf.clear93 = and i8 %bf.load92, 1
  %bf.cast94 = zext i8 %bf.clear93 to i32
  %tobool95 = icmp ne i32 %bf.cast94, 0
  br i1 %tobool95, label %if.then96, label %if.end107

if.then96:                                        ; preds = %do.end90
  %hdev97 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %13 = load %struct.usb_device*, %struct.usb_device** %hdev97, align 8, !tbaa !152
  %call98 = call i32 @hub_is_superspeed(%struct.usb_device* %13)
  %tobool99 = icmp ne i32 %call98, 0
  br i1 %tobool99, label %if.else104, label %if.then100

if.then100:                                       ; preds = %if.then96
  %call101 = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or102 = or i32 -2147483648, %call101
  %call103 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or102, i8 zeroext 1, i8 zeroext 0, i16 zeroext 1, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  br label %if.end107

if.else104:                                       ; preds = %if.then96
  %call105 = call i32 @usb_disable_function_remotewakeup(%struct.usb_device* %udev)
  br label %if.end107

if.end107:                                        ; preds = %if.else104, %if.then100, %do.end90
  %usb2_hw_lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load108 = load i16, i16* %usb2_hw_lpm_capable, align 4
  %bf.lshr109 = lshr i16 %bf.load108, 7
  %bf.clear110 = and i16 %bf.lshr109, 1
  %bf.cast111 = zext i16 %bf.clear110 to i32
  %cmp112 = icmp eq i32 %bf.cast111, 1
  br i1 %cmp112, label %if.then114, label %if.end116

if.then114:                                       ; preds = %if.end107
  %call115 = call i32 @usb_set_usb2_hardware_lpm(%struct.usb_device* %udev, i32 1)
  br label %if.end116

if.end116:                                        ; preds = %if.then114, %if.end107
  call void @usb_enable_ltm(%struct.usb_device* %udev)
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %udev)
  %event117 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %14 = load i32, i32* %event117, align 4, !tbaa !42
  %and118 = and i32 %14, 1024
  %cmp119 = icmp ne i32 %and118, 0
  %status.2. = select i1 %cmp119, i32 %status.2, i32 0
  br label %if.end159

do.body125:                                       ; preds = %if.end67
  %bf.load126 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_suspend.descriptor.21 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr127 = lshr i32 %bf.load126, 18
  %bf.clear128 = and i32 %bf.lshr127, 255
  %and129 = and i32 %bf.clear128, 1
  %tobool130 = icmp ne i32 %and129, 0
  %lnot131 = xor i1 %tobool130, true
  %lnot133 = xor i1 %lnot131, true
  %lnot.ext134 = zext i1 %lnot133 to i32
  %conv135 = sext i32 %lnot.ext134 to i64
  %expval136 = call i64 @llvm.expect.i64(i64 %conv135, i64 0)
  %tobool137 = icmp ne i64 %expval136, 0
  br i1 %tobool137, label %if.then138, label %do.end153

if.then138:                                       ; preds = %do.body125
  %dev139 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %event140 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %15 = load i32, i32* %event140, align 4, !tbaa !42
  %and141 = and i32 %15, 1024
  %cmp142 = icmp ne i32 %and141, 0
  %cond = select i1 %cmp142, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.15.132, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.27.821, i32 0, i32 0)
  %do_remote_wakeup144 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load145 = load i8, i8* %do_remote_wakeup144, align 8
  %bf.clear146 = and i8 %bf.load145, 1
  %bf.cast147 = zext i8 %bf.clear146 to i32
  %call148 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_suspend.descriptor.21 to %struct._ddebug*), %struct.device* %dev139, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.22, i32 0, i32 0), i8* %cond, i32 %bf.cast147)
  br label %do.end153

do.end153:                                        ; preds = %if.then138, %do.body125
  call void @usb_set_device_state(%struct.usb_device* %udev, i32 8)
  %tobool154 = trunc i8 %really_suspend.1 to i1
  br i1 %tobool154, label %if.then155, label %if.end159

if.then155:                                       ; preds = %do.end153
  %port_is_suspended = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load156 = load i8, i8* %port_is_suspended, align 8
  %bf.clear157 = and i8 %bf.load156, -5
  %bf.set = or i8 %bf.clear157, 4
  store i8 %bf.set, i8* %port_is_suspended, align 8
  call void @msleep(i32 10)
  br label %if.end159

if.end159:                                        ; preds = %if.then155, %do.end153, %if.end116
  %status.4 = phi i32 [ %status.2., %if.end116 ], [ %status.2, %if.then155 ], [ %status.2, %do.end153 ]
  %dev160 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 1
  %call161 = call i32 @dev_pm_qos_flags(%struct.device* %dev160, i32 1)
  %do_remote_wakeup162 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load163 = load i8, i8* %do_remote_wakeup162, align 8
  %bf.clear164 = and i8 %bf.load163, 1
  %bf.cast165 = zext i8 %bf.clear164 to i32
  %tobool166 = icmp eq i32 %bf.cast165, 0
  %cmp167 = icmp ne i32 %call161, 2
  %or.cond = and i1 %tobool166, %cmp167
  br i1 %or.cond, label %land.lhs.true169, label %if.end183

land.lhs.true169:                                 ; preds = %if.end159
  %persist_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load170 = load i16, i16* %persist_enabled, align 4
  %bf.lshr171 = lshr i16 %bf.load170, 1
  %bf.clear172 = and i16 %bf.lshr171, 1
  %bf.cast173 = zext i16 %bf.clear172 to i32
  %tobool174 = icmp eq i32 %bf.cast173, 0
  %tobool176 = icmp ne i32 %status.4, 0
  %or.cond1 = or i1 %tobool174, %tobool176
  br i1 %or.cond1, label %if.end183, label %if.then177

if.then177:                                       ; preds = %land.lhs.true169
  %dev178 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 1
  call void @pm_runtime_put_sync(%struct.device* %dev178)
  %did_runtime_put = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 5
  %bf.load180 = load i8, i8* %did_runtime_put, align 1
  %bf.clear181 = and i8 %bf.load180, -3
  %bf.set182 = or i8 %bf.clear181, 2
  store i8 %bf.set182, i8* %did_runtime_put, align 1
  br label %if.end183

if.end183:                                        ; preds = %if.then177, %land.lhs.true169, %if.end159
  %hdev184 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %16 = load %struct.usb_device*, %struct.usb_device** %hdev184, align 8, !tbaa !152
  call void @usb_mark_last_busy(%struct.usb_device* %16)
  br label %cleanup

cleanup:                                          ; preds = %if.end183, %if.then48, %if.then42, %do.end24
  %retval.0 = phi i32 [ -12, %if.then42 ], [ -12, %if.then48 ], [ %status.4, %if.end183 ], [ %status.0, %do.end24 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_disable_function_remotewakeup(%struct.usb_device* %udev) #0 {
entry:
  %call = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or = or i32 -2147483648, %call
  %call1 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext 1, i8 zeroext 1, i16 zeroext 0, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  ret i32 %call1
}

declare i32 @dev_pm_qos_flags(%struct.device*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put_sync(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_idle(%struct.device* %dev, i32 4)
  ret void
}

declare void @__pm_runtime_use_autosuspend(%struct.device*, i1 zeroext) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc(%union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #8, !srcloc !245
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_deauthorize_device(%struct.usb_device* %usb_dev) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 11
  call void @device_lock(%struct.device* %dev)
  %authorized = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 22
  %bf.load = load i16, i16* %authorized, align 4
  %bf.lshr = lshr i16 %bf.load, 3
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 0
  br i1 %cmp, label %out_unauthorized, label %if.end

if.end:                                           ; preds = %entry
  %authorized1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 22
  %bf.load2 = load i16, i16* %authorized1, align 4
  %bf.clear3 = and i16 %bf.load2, -9
  store i16 %bf.clear3, i16* %authorized1, align 4
  %call = call i32 @usb_set_configuration(%struct.usb_device* %usb_dev, i32 -1)
  %product = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 24
  %0 = load i8*, i8** %product, align 8, !tbaa !39
  call void @kfree(i8* %0)
  %call4 = call i8* @kstrdup(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.11.22, i32 0, i32 0), i32 208)
  %product5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 24
  store i8* %call4, i8** %product5, align 8, !tbaa !39
  %manufacturer = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 25
  %1 = load i8*, i8** %manufacturer, align 8, !tbaa !40
  call void @kfree(i8* %1)
  %call6 = call i8* @kstrdup(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.11.22, i32 0, i32 0), i32 208)
  %manufacturer7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 25
  store i8* %call6, i8** %manufacturer7, align 8, !tbaa !40
  %serial = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 26
  %2 = load i8*, i8** %serial, align 8, !tbaa !41
  call void @kfree(i8* %2)
  %call8 = call i8* @kstrdup(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.11.22, i32 0, i32 0), i32 208)
  %serial9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 26
  store i8* %call8, i8** %serial9, align 8, !tbaa !41
  call void @usb_destroy_configuration(%struct.usb_device* %usb_dev)
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 13
  store i8 0, i8* %bNumConfigurations, align 1, !tbaa !166
  br label %out_unauthorized

out_unauthorized:                                 ; preds = %if.end, %entry
  %dev10 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev10)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @usb_authorize_device(%struct.usb_device* %usb_dev) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 11
  call void @device_lock(%struct.device* %dev)
  %authorized = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 22
  %bf.load = load i16, i16* %authorized, align 4
  %bf.lshr = lshr i16 %bf.load, 3
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 1
  br i1 %cmp, label %out_authorized, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @usb_autoresume_device(%struct.usb_device* %usb_dev)
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %0 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %out_authorized

if.end5:                                          ; preds = %if.end
  %call6 = call i32 @usb_get_device_descriptor(%struct.usb_device* %usb_dev, i32 18)
  %cmp7 = icmp slt i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end11

if.then8:                                         ; preds = %if.end5
  %1 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %error_device_descriptor

if.end11:                                         ; preds = %if.end5
  %product = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 24
  %2 = load i8*, i8** %product, align 8, !tbaa !39
  call void @kfree(i8* %2)
  %product12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 24
  store i8* null, i8** %product12, align 8, !tbaa !39
  %manufacturer = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 25
  %3 = load i8*, i8** %manufacturer, align 8, !tbaa !40
  call void @kfree(i8* %3)
  %manufacturer13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 25
  store i8* null, i8** %manufacturer13, align 8, !tbaa !40
  %serial = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 26
  %4 = load i8*, i8** %serial, align 8, !tbaa !41
  call void @kfree(i8* %4)
  %serial14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 26
  store i8* null, i8** %serial14, align 8, !tbaa !41
  %authorized15 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 22
  %bf.load16 = load i16, i16* %authorized15, align 4
  %bf.clear17 = and i16 %bf.load16, -9
  %bf.set = or i16 %bf.clear17, 8
  store i16 %bf.set, i16* %authorized15, align 4
  %call18 = call i32 @usb_enumerate_device(%struct.usb_device* %usb_dev)
  %cmp19 = icmp slt i32 %call18, 0
  br i1 %cmp19, label %error_device_descriptor, label %if.end21

if.end21:                                         ; preds = %if.end11
  %call22 = call i32 @usb_choose_configuration(%struct.usb_device* %usb_dev)
  %cmp23 = icmp sge i32 %call22, 0
  br i1 %cmp23, label %if.then24, label %if.end30

if.then24:                                        ; preds = %if.end21
  %call25 = call i32 @usb_set_configuration(%struct.usb_device* %usb_dev, i32 %call22)
  %tobool = icmp ne i32 %call25, 0
  br i1 %tobool, label %if.then26, label %if.end30

if.then26:                                        ; preds = %if.then24
  %5 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end30

if.end30:                                         ; preds = %if.then26, %if.then24, %if.end21
  %result.0 = phi i32 [ %call18, %if.end21 ], [ %call25, %if.then26 ], [ %call25, %if.then24 ]
  %6 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %error_device_descriptor

error_device_descriptor:                          ; preds = %if.end30, %if.end11, %if.then8
  %result.2 = phi i32 [ %call6, %if.then8 ], [ %result.0, %if.end30 ], [ %call18, %if.end11 ]
  call void @usb_autosuspend_device(%struct.usb_device* %usb_dev)
  br label %out_authorized

out_authorized:                                   ; preds = %error_device_descriptor, %if.then2, %entry
  %result.4 = phi i32 [ 0, %entry ], [ %call, %if.then2 ], [ %result.2, %error_device_descriptor ]
  %dev33 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev33)
  ret i32 %result.4
}

; Function Attrs: nounwind uwtable
define i32 @usb_port_resume(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %portchange = alloca i16, align 2
  %portstatus = alloca i16, align 2
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %0)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 22
  %1 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %2 = load i8, i8* %portnum, align 2, !tbaa !88
  %conv = zext i8 %2 to i32
  %sub = sub nsw i32 %conv, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %1, i64 %idxprom
  %3 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %portnum1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %4 = load i8, i8* %portnum1, align 2, !tbaa !88
  %conv2 = zext i8 %4 to i32
  %5 = bitcast i16* %portchange to i8*
  %6 = bitcast i16* %portstatus to i8*
  %did_runtime_put = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 5
  %bf.load = load i8, i8* %did_runtime_put, align 1
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.end23

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 1
  %call3 = call i32 @pm_runtime_get_sync(%struct.device* %dev)
  %did_runtime_put4 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 5
  %bf.load5 = load i8, i8* %did_runtime_put4, align 1
  %bf.clear6 = and i8 %bf.load5, -3
  store i8 %bf.clear6, i8* %did_runtime_put4, align 1
  %cmp = icmp slt i32 %call3, 0
  br i1 %cmp, label %do.body9, label %if.end23

do.body9:                                         ; preds = %if.then
  %bf.load10 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_resume.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr11 = lshr i32 %bf.load10, 18
  %bf.clear12 = and i32 %bf.lshr11, 255
  %and = and i32 %bf.clear12, 1
  %tobool13 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool13, true
  %lnot14 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot14 to i32
  %conv15 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool16 = icmp ne i64 %expval, 0
  br i1 %tobool16, label %if.then17, label %cleanup

if.then17:                                        ; preds = %do.body9
  %dev18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call19 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_resume.descriptor to %struct._ddebug*), %struct.device* %dev18, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.25, i32 0, i32 0), i32 %call3)
  br label %cleanup

if.end23:                                         ; preds = %if.then, %entry
  %call24 = call i32 @hub_port_status(%struct.usb_hub* %call, i32 %conv2, i16* %portstatus, i16* %portchange)
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %if.end23
  %7 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv27 = zext i16 %7 to i32
  %call28 = call i32 @port_is_suspended(%struct.usb_hub* %call, i32 %conv27)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.end31, label %SuspendCleared

if.end31:                                         ; preds = %land.lhs.true, %if.end23
  %busy_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 12
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %busy_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i32 %conv2, i64* %arraydecay) #8, !srcloc !144
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %8 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %call32 = call i32 @hub_is_superspeed(%struct.usb_device* %8)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %if.else

if.then34:                                        ; preds = %if.end31
  %call35 = call i32 @hub_set_port_link_state(%struct.usb_hub* %call, i32 %conv2, i32 0)
  br label %if.end38

if.else:                                          ; preds = %if.end31
  %hdev36 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %hdev36, align 8, !tbaa !152
  %call37 = call i32 @usb_clear_port_feature(%struct.usb_device* %9, i32 %conv2, i32 2)
  br label %if.end38

if.end38:                                         ; preds = %if.else, %if.then34
  %status.0 = phi i32 [ %call35, %if.then34 ], [ %call37, %if.else ]
  %tobool39 = icmp ne i32 %status.0, 0
  br i1 %tobool39, label %do.body42, label %do.body64

do.body42:                                        ; preds = %if.end38
  %bf.load43 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_resume.descriptor.26 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr44 = lshr i32 %bf.load43, 18
  %bf.clear45 = and i32 %bf.lshr44, 255
  %and46 = and i32 %bf.clear45, 1
  %tobool47 = icmp ne i32 %and46, 0
  %lnot48 = xor i1 %tobool47, true
  %lnot50 = xor i1 %lnot48, true
  %lnot.ext51 = zext i1 %lnot50 to i32
  %conv52 = sext i32 %lnot.ext51 to i64
  %expval53 = call i64 @llvm.expect.i64(i64 %conv52, i64 0)
  %tobool54 = icmp ne i64 %expval53, 0
  br i1 %tobool54, label %if.then55, label %SuspendCleared

if.then55:                                        ; preds = %do.body42
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 0
  %10 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !173
  %call56 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_resume.descriptor.26 to %struct._ddebug*), %struct.device* %10, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.27, i32 0, i32 0), i32 %conv2, i32 %status.0)
  br label %SuspendCleared

do.body64:                                        ; preds = %if.end38
  %bf.load65 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_resume.descriptor.28 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr66 = lshr i32 %bf.load65, 18
  %bf.clear67 = and i32 %bf.lshr66, 255
  %and68 = and i32 %bf.clear67, 1
  %tobool69 = icmp ne i32 %and68, 0
  %lnot70 = xor i1 %tobool69, true
  %lnot72 = xor i1 %lnot70, true
  %lnot.ext73 = zext i1 %lnot72 to i32
  %conv74 = sext i32 %lnot.ext73 to i64
  %expval75 = call i64 @llvm.expect.i64(i64 %conv74, i64 0)
  %tobool76 = icmp ne i64 %expval75, 0
  br i1 %tobool76, label %if.then77, label %do.end87

if.then77:                                        ; preds = %do.body64
  %dev78 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %11 = load i32, i32* %event, align 4, !tbaa !42
  %and79 = and i32 %11, 1024
  %cmp80 = icmp ne i32 %and79, 0
  %cond = select i1 %cmp80, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.15.132, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.27.821, i32 0, i32 0)
  %call82 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_resume.descriptor.28 to %struct._ddebug*), %struct.device* %dev78, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.23.138, i32 0, i32 0), i8* %cond)
  br label %do.end87

do.end87:                                         ; preds = %if.then77, %do.body64
  call void @msleep(i32 25)
  %call88 = call i32 @hub_port_status(%struct.usb_hub* %call, i32 %conv2, i16* %portstatus, i16* %portchange)
  call void @msleep(i32 10)
  br label %SuspendCleared

SuspendCleared:                                   ; preds = %do.end87, %if.then55, %do.body42, %land.lhs.true
  %status.2 = phi i32 [ %call24, %land.lhs.true ], [ %call88, %do.end87 ], [ %status.0, %if.then55 ], [ %status.0, %do.body42 ]
  %cmp90 = icmp eq i32 %status.2, 0
  br i1 %cmp90, label %if.then92, label %if.end115

if.then92:                                        ; preds = %SuspendCleared
  %port_is_suspended = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load93 = load i8, i8* %port_is_suspended, align 8
  %bf.clear94 = and i8 %bf.load93, -5
  store i8 %bf.clear94, i8* %port_is_suspended, align 8
  %hdev95 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %12 = load %struct.usb_device*, %struct.usb_device** %hdev95, align 8, !tbaa !152
  %call96 = call i32 @hub_is_superspeed(%struct.usb_device* %12)
  %tobool97 = icmp ne i32 %call96, 0
  %13 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv99 = zext i16 %13 to i32
  br i1 %tobool97, label %if.then98, label %if.else106

if.then98:                                        ; preds = %if.then92
  %and100 = and i32 %conv99, 64
  %tobool101 = icmp ne i32 %and100, 0
  br i1 %tobool101, label %if.then102, label %if.end115

if.then102:                                       ; preds = %if.then98
  %hdev103 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %14 = load %struct.usb_device*, %struct.usb_device** %hdev103, align 8, !tbaa !152
  %call104 = call i32 @usb_clear_port_feature(%struct.usb_device* %14, i32 %conv2, i32 25)
  br label %if.end115

if.else106:                                       ; preds = %if.then92
  %and108 = and i32 %conv99, 4
  %tobool109 = icmp ne i32 %and108, 0
  br i1 %tobool109, label %if.then110, label %if.end115

if.then110:                                       ; preds = %if.else106
  %hdev111 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 1
  %15 = load %struct.usb_device*, %struct.usb_device** %hdev111, align 8, !tbaa !152
  %call112 = call i32 @usb_clear_port_feature(%struct.usb_device* %15, i32 %conv2, i32 18)
  br label %if.end115

if.end115:                                        ; preds = %if.then110, %if.else106, %if.then102, %if.then98, %SuspendCleared
  %busy_bits116 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 12
  %arraydecay117 = getelementptr inbounds [1 x i64], [1 x i64]* %busy_bits116, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay117, i32 %conv2, i64* %arraydecay117) #8, !srcloc !145
  %16 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv118 = zext i16 %16 to i32
  %17 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv119 = zext i16 %17 to i32
  %call120 = call i32 @check_port_resume_type(%struct.usb_device* %udev, %struct.usb_hub* %call, i32 %conv2, i32 %status.2, i32 %conv118, i32 %conv119)
  %cmp121 = icmp eq i32 %call120, 0
  br i1 %cmp121, label %if.then123, label %if.end125

if.then123:                                       ; preds = %if.end115
  %call124 = call i32 @finish_port_resume(%struct.usb_device* %udev)
  br label %if.end125

if.end125:                                        ; preds = %if.then123, %if.end115
  %status.3 = phi i32 [ %call124, %if.then123 ], [ %call120, %if.end115 ]
  %cmp126 = icmp slt i32 %status.3, 0
  br i1 %cmp126, label %do.body130, label %if.else151

do.body130:                                       ; preds = %if.end125
  %bf.load131 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_resume.descriptor.30 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr132 = lshr i32 %bf.load131, 18
  %bf.clear133 = and i32 %bf.lshr132, 255
  %and134 = and i32 %bf.clear133, 1
  %tobool135 = icmp ne i32 %and134, 0
  %lnot136 = xor i1 %tobool135, true
  %lnot138 = xor i1 %lnot136, true
  %lnot.ext139 = zext i1 %lnot138 to i32
  %conv140 = sext i32 %lnot.ext139 to i64
  %expval141 = call i64 @llvm.expect.i64(i64 %conv140, i64 0)
  %tobool142 = icmp ne i64 %expval141, 0
  br i1 %tobool142, label %if.then143, label %do.end150

if.then143:                                       ; preds = %do.body130
  %dev144 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call145 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_resume.descriptor.30 to %struct._ddebug*), %struct.device* %dev144, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.31, i32 0, i32 0), i32 %status.3)
  br label %do.end150

do.end150:                                        ; preds = %if.then143, %do.body130
  call void @hub_port_logical_disconnect(%struct.usb_hub* %call, i32 %conv2)
  br label %cleanup

if.else151:                                       ; preds = %if.end125
  %usb2_hw_lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load152 = load i16, i16* %usb2_hw_lpm_capable, align 4
  %bf.lshr153 = lshr i16 %bf.load152, 7
  %bf.clear154 = and i16 %bf.lshr153, 1
  %bf.cast155 = zext i16 %bf.clear154 to i32
  %cmp156 = icmp eq i32 %bf.cast155, 1
  br i1 %cmp156, label %if.then158, label %if.end160

if.then158:                                       ; preds = %if.else151
  %call159 = call i32 @usb_set_usb2_hardware_lpm(%struct.usb_device* %udev, i32 1)
  br label %if.end160

if.end160:                                        ; preds = %if.then158, %if.else151
  call void @usb_enable_ltm(%struct.usb_device* %udev)
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %udev)
  br label %cleanup

cleanup:                                          ; preds = %if.end160, %do.end150, %if.then17, %do.body9
  %retval.0 = phi i32 [ %call3, %if.then17 ], [ %call3, %do.body9 ], [ %status.3, %if.end160 ], [ %status.3, %do.end150 ]
  %18 = bitcast i16* %portstatus to i8*
  %19 = bitcast i16* %portchange to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @port_is_suspended(%struct.usb_hub* %hub, i32 %portstatus) #0 {
entry:
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool = icmp ne i32 %call, 0
  %and2 = and i32 %portstatus, 4
  %tobool3 = icmp ne i32 %and2, 0
  %and = and i32 %portstatus, 480
  %cmp = icmp eq i32 %and, 96
  %tobool3.sink = select i1 %tobool, i1 %cmp, i1 %tobool3
  %.1 = select i1 %tobool3.sink, i32 1, i32 0
  ret i32 %.1
}

; Function Attrs: nounwind uwtable
define internal i32 @check_port_resume_type(%struct.usb_device* %udev, %struct.usb_hub* %hub, i32 %port1, i32 %status, i32 %portchange, i32 %portstatus) #0 {
entry:
  %tobool = icmp ne i32 %status, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %call = call i32 @port_is_suspended(%struct.usb_hub* %hub, i32 %portstatus)
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %call3 = call i32 @port_is_power_on(%struct.usb_hub* %hub, i32 %portstatus)
  %tobool4 = icmp ne i32 %call3, 0
  %and = and i32 %portstatus, 1
  %tobool6 = icmp ne i32 %and, 0
  %or.cond = and i1 %tobool4, %tobool6
  br i1 %or.cond, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  %cmp = icmp sge i32 %status, 0
  %.status = select i1 %cmp, i32 -19, i32 %status
  br label %if.end24

if.else:                                          ; preds = %lor.lhs.false2
  %and8 = and i32 %portstatus, 2
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.end24, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %reset_resume = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load = load i8, i8* %reset_resume, align 8
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool10 = icmp ne i32 %bf.cast, 0
  br i1 %tobool10, label %if.end24, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %persist_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load12 = load i16, i16* %persist_enabled, align 4
  %bf.lshr13 = lshr i16 %bf.load12, 1
  %bf.clear14 = and i16 %bf.lshr13, 1
  %bf.cast15 = zext i16 %bf.clear14 to i32
  %tobool16 = icmp ne i32 %bf.cast15, 0
  br i1 %tobool16, label %if.then17, label %if.end24

if.then17:                                        ; preds = %if.then11
  %reset_resume18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load19 = load i8, i8* %reset_resume18, align 8
  %bf.clear20 = and i8 %bf.load19, -3
  %bf.set = or i8 %bf.clear20, 2
  store i8 %bf.set, i8* %reset_resume18, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then17, %if.then11, %land.lhs.true, %if.else, %if.then
  %status.addr.3 = phi i32 [ %.status, %if.then ], [ %status, %if.else ], [ %status, %land.lhs.true ], [ %status, %if.then17 ], [ -19, %if.then11 ]
  %tobool25 = icmp ne i32 %status.addr.3, 0
  br i1 %tobool25, label %do.body27, label %if.else39

do.body27:                                        ; preds = %if.end24
  %bf.load28 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @check_port_resume_type.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr29 = lshr i32 %bf.load28, 18
  %bf.clear30 = and i32 %bf.lshr29, 255
  %and31 = and i32 %bf.clear30, 1
  %tobool32 = icmp ne i32 %and31, 0
  %lnot = xor i1 %tobool32, true
  %lnot33 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot33 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool34 = icmp ne i64 %expval, 0
  br i1 %tobool34, label %if.then35, label %if.end59

if.then35:                                        ; preds = %do.body27
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !173
  %call36 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @check_port_resume_type.descriptor to %struct._ddebug*), %struct.device* %0, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.61, i32 0, i32 0), i32 %port1, i32 %portchange, i32 %portstatus, i32 %status.addr.3)
  br label %if.end59

if.else39:                                        ; preds = %if.end24
  %reset_resume40 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load41 = load i8, i8* %reset_resume40, align 8
  %bf.lshr42 = lshr i8 %bf.load41, 1
  %bf.clear43 = and i8 %bf.lshr42, 1
  %bf.cast44 = zext i8 %bf.clear43 to i32
  %tobool45 = icmp ne i32 %bf.cast44, 0
  br i1 %tobool45, label %if.then46, label %if.end59

if.then46:                                        ; preds = %if.else39
  %and47 = and i32 %portchange, 1
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %if.then49, label %if.end51

if.then49:                                        ; preds = %if.then46
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %call50 = call i32 @usb_clear_port_feature(%struct.usb_device* %1, i32 %port1, i32 16)
  br label %if.end51

if.end51:                                         ; preds = %if.then49, %if.then46
  %and52 = and i32 %portchange, 2
  %tobool53 = icmp ne i32 %and52, 0
  br i1 %tobool53, label %if.then54, label %if.end59

if.then54:                                        ; preds = %if.end51
  %hdev55 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %hdev55, align 8, !tbaa !152
  %call56 = call i32 @usb_clear_port_feature(%struct.usb_device* %2, i32 %port1, i32 17)
  br label %if.end59

if.end59:                                         ; preds = %if.then54, %if.end51, %if.else39, %if.then35, %do.body27
  ret i32 %status.addr.3
}

; Function Attrs: nounwind uwtable
define internal i32 @finish_port_resume(%struct.usb_device* %udev) #0 {
entry:
  %devstatus = alloca i16, align 2
  %0 = bitcast i16* %devstatus to i8*
  store i16 0, i16* %devstatus, align 2, !tbaa !143
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @finish_port_resume.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end9

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %reset_resume = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load4 = load i8, i8* %reset_resume, align 8
  %bf.lshr5 = lshr i8 %bf.load4, 1
  %bf.clear6 = and i8 %bf.lshr5, 1
  %bf.cast = zext i8 %bf.clear6 to i32
  %tobool7 = icmp ne i32 %bf.cast, 0
  %cond = select i1 %tobool7, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.63, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.64, i32 0, i32 0)
  %call = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @finish_port_resume.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11.859, i32 0, i32 0), i8* %cond)
  br label %do.end9

do.end9:                                          ; preds = %if.then, %entry
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %1 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool10 = icmp ne %struct.usb_host_config* %1, null
  %cond11 = select i1 %tobool10, i32 7, i32 6
  call void @usb_set_device_state(%struct.usb_device* %udev, i32 %cond11)
  %reset_resume12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load13 = load i8, i8* %reset_resume12, align 8
  %bf.lshr14 = lshr i8 %bf.load13, 1
  %bf.clear15 = and i8 %bf.lshr14, 1
  %bf.cast16 = zext i8 %bf.clear15 to i32
  %tobool17 = icmp ne i32 %bf.cast16, 0
  br i1 %tobool17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %do.end9
  br label %retry_reset_resume

retry_reset_resume:                               ; preds = %do.end66, %if.then18
  %call19 = call i32 @usb_reset_and_verify_device(%struct.usb_device* %udev)
  br label %if.end20

if.end20:                                         ; preds = %retry_reset_resume, %do.end9
  %status.0 = phi i32 [ %call19, %retry_reset_resume ], [ 0, %do.end9 ]
  %cmp = icmp eq i32 %status.0, 0
  br i1 %cmp, label %if.then22, label %if.end71

if.then22:                                        ; preds = %if.end20
  store i16 0, i16* %devstatus, align 2, !tbaa !143
  %2 = bitcast i16* %devstatus to i8*
  %call23 = call i32 @usb_get_status(%struct.usb_device* %udev, i32 0, i32 0, i8* %2)
  %cmp24 = icmp sge i32 %call23, 0
  br i1 %cmp24, label %if.then26, label %if.end30

if.then26:                                        ; preds = %if.then22
  %cmp27 = icmp sgt i32 %call23, 0
  %cond29 = select i1 %cmp27, i32 0, i32 -19
  br label %if.end30

if.end30:                                         ; preds = %if.then26, %if.then22
  %status.1 = phi i32 [ %cond29, %if.then26 ], [ %call23, %if.then22 ]
  %tobool31 = icmp ne i32 %status.1, 0
  br i1 %tobool31, label %land.lhs.true, label %if.end71

land.lhs.true:                                    ; preds = %if.end30
  %reset_resume32 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load33 = load i8, i8* %reset_resume32, align 8
  %bf.lshr34 = lshr i8 %bf.load33, 1
  %bf.clear35 = and i8 %bf.lshr34, 1
  %bf.cast36 = zext i8 %bf.clear35 to i32
  %tobool37 = icmp ne i32 %bf.cast36, 0
  br i1 %tobool37, label %if.end71, label %land.lhs.true38

land.lhs.true38:                                  ; preds = %land.lhs.true
  %persist_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load39 = load i16, i16* %persist_enabled, align 4
  %bf.lshr40 = lshr i16 %bf.load39, 1
  %bf.clear41 = and i16 %bf.lshr40, 1
  %bf.cast42 = zext i16 %bf.clear41 to i32
  %tobool43 = icmp ne i32 %bf.cast42, 0
  br i1 %tobool43, label %do.body46, label %if.end71

do.body46:                                        ; preds = %land.lhs.true38
  %bf.load47 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @finish_port_resume.descriptor.65 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr48 = lshr i32 %bf.load47, 18
  %bf.clear49 = and i32 %bf.lshr48, 255
  %and50 = and i32 %bf.clear49, 1
  %tobool51 = icmp ne i32 %and50, 0
  %lnot52 = xor i1 %tobool51, true
  %lnot54 = xor i1 %lnot52, true
  %lnot.ext55 = zext i1 %lnot54 to i32
  %conv56 = sext i32 %lnot.ext55 to i64
  %expval57 = call i64 @llvm.expect.i64(i64 %conv56, i64 0)
  %tobool58 = icmp ne i64 %expval57, 0
  br i1 %tobool58, label %if.then59, label %do.end66

if.then59:                                        ; preds = %do.body46
  %dev60 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call61 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @finish_port_resume.descriptor.65 to %struct._ddebug*), %struct.device* %dev60, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.66, i32 0, i32 0))
  br label %do.end66

do.end66:                                         ; preds = %if.then59, %do.body46
  %reset_resume67 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load68 = load i8, i8* %reset_resume67, align 8
  %bf.clear69 = and i8 %bf.load68, -3
  %bf.set = or i8 %bf.clear69, 2
  store i8 %bf.set, i8* %reset_resume67, align 8
  br label %retry_reset_resume

if.end71:                                         ; preds = %land.lhs.true38, %land.lhs.true, %if.end30, %if.end20
  %status.2 = phi i32 [ %status.0, %if.end20 ], [ %status.1, %land.lhs.true38 ], [ %status.1, %land.lhs.true ], [ %status.1, %if.end30 ]
  %tobool72 = icmp ne i32 %status.2, 0
  br i1 %tobool72, label %do.body75, label %if.else

do.body75:                                        ; preds = %if.end71
  %bf.load76 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @finish_port_resume.descriptor.67 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr77 = lshr i32 %bf.load76, 18
  %bf.clear78 = and i32 %bf.lshr77, 255
  %and79 = and i32 %bf.clear78, 1
  %tobool80 = icmp ne i32 %and79, 0
  %lnot81 = xor i1 %tobool80, true
  %lnot83 = xor i1 %lnot81, true
  %lnot.ext84 = zext i1 %lnot83 to i32
  %conv85 = sext i32 %lnot.ext84 to i64
  %expval86 = call i64 @llvm.expect.i64(i64 %conv85, i64 0)
  %tobool87 = icmp ne i64 %expval86, 0
  br i1 %tobool87, label %if.then88, label %if.end159

if.then88:                                        ; preds = %do.body75
  %dev89 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call90 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @finish_port_resume.descriptor.67 to %struct._ddebug*), %struct.device* %dev89, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.68, i32 0, i32 0), i32 %status.2)
  br label %if.end159

if.else:                                          ; preds = %if.end71
  %actconfig96 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %3 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig96, align 8, !tbaa !64
  %tobool97 = icmp ne %struct.usb_host_config* %3, null
  br i1 %tobool97, label %land.lhs.true98, label %if.end159

land.lhs.true98:                                  ; preds = %if.else
  %reset_resume99 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load100 = load i8, i8* %reset_resume99, align 8
  %bf.lshr101 = lshr i8 %bf.load100, 1
  %bf.clear102 = and i8 %bf.lshr101, 1
  %bf.cast103 = zext i8 %bf.clear102 to i32
  %tobool104 = icmp ne i32 %bf.cast103, 0
  br i1 %tobool104, label %if.end159, label %if.then105

if.then105:                                       ; preds = %land.lhs.true98
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %4 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %call106 = call i32 @hub_is_superspeed(%struct.usb_device* %4)
  %tobool107 = icmp ne i32 %call106, 0
  br i1 %tobool107, label %if.else119, label %do.end111

do.end111:                                        ; preds = %if.then105
  %5 = load i16, i16* %devstatus, align 2, !tbaa !143
  %conv112 = zext i16 %5 to i32
  %and113 = and i32 %conv112, 2
  %tobool114 = icmp ne i32 %and113, 0
  br i1 %tobool114, label %if.then115, label %if.end132

if.then115:                                       ; preds = %do.end111
  %call116 = call i32 @__create_pipe(%struct.usb_device* %udev, i32 0)
  %or = or i32 -2147483648, %call116
  %call117 = call i32 @usb_control_msg(%struct.usb_device* %udev, i32 %or, i8 zeroext 1, i8 zeroext 0, i16 zeroext 1, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  br label %if.end132

if.else119:                                       ; preds = %if.then105
  %6 = bitcast i16* %devstatus to i8*
  %call120 = call i32 @usb_get_status(%struct.usb_device* %udev, i32 1, i32 0, i8* %6)
  %tobool124 = icmp ne i32 %call120, 0
  br i1 %tobool124, label %if.end132, label %land.lhs.true125

land.lhs.true125:                                 ; preds = %if.else119
  %7 = load i16, i16* %devstatus, align 2, !tbaa !143
  %conv126 = zext i16 %7 to i32
  %and127 = and i32 %conv126, 3
  %tobool128 = icmp ne i32 %and127, 0
  br i1 %tobool128, label %if.then129, label %if.end132

if.then129:                                       ; preds = %land.lhs.true125
  %call130 = call i32 @usb_disable_function_remotewakeup(%struct.usb_device* %udev)
  br label %if.end132

if.end132:                                        ; preds = %if.then129, %land.lhs.true125, %if.else119, %if.then115, %do.end111
  %status.5 = phi i32 [ %call117, %if.then115 ], [ %status.2, %do.end111 ], [ %call120, %if.else119 ], [ %call130, %if.then129 ], [ %call120, %land.lhs.true125 ]
  %tobool133 = icmp ne i32 %status.5, 0
  br i1 %tobool133, label %do.body136, label %if.end159

do.body136:                                       ; preds = %if.end132
  %bf.load137 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @finish_port_resume.descriptor.69 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr138 = lshr i32 %bf.load137, 18
  %bf.clear139 = and i32 %bf.lshr138, 255
  %and140 = and i32 %bf.clear139, 1
  %tobool141 = icmp ne i32 %and140, 0
  %lnot142 = xor i1 %tobool141, true
  %lnot144 = xor i1 %lnot142, true
  %lnot.ext145 = zext i1 %lnot144 to i32
  %conv146 = sext i32 %lnot.ext145 to i64
  %expval147 = call i64 @llvm.expect.i64(i64 %conv146, i64 0)
  %tobool148 = icmp ne i64 %expval147, 0
  br i1 %tobool148, label %if.then149, label %if.end159

if.then149:                                       ; preds = %do.body136
  %dev150 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call151 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @finish_port_resume.descriptor.69 to %struct._ddebug*), %struct.device* %dev150, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.70, i32 0, i32 0), i32 %status.5)
  br label %if.end159

if.end159:                                        ; preds = %if.then149, %do.body136, %if.end132, %land.lhs.true98, %if.else, %if.then88, %do.body75
  %status.7 = phi i32 [ %status.2, %if.then88 ], [ %status.2, %do.body75 ], [ %status.2, %land.lhs.true98 ], [ %status.2, %if.else ], [ 0, %do.body136 ], [ 0, %if.then149 ], [ 0, %if.end132 ]
  %8 = bitcast i16* %devstatus to i8*
  ret i32 %status.7
}

; Function Attrs: nounwind uwtable
define internal i32 @port_is_power_on(%struct.usb_hub* %hub, i32 %portstatus) #0 {
entry:
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool = icmp ne i32 %call, 0
  %.sink = select i1 %tobool, i32 512, i32 256
  %and3 = and i32 %portstatus, %.sink
  %tobool4 = icmp ne i32 %and3, 0
  %.1 = select i1 %tobool4, i32 1, i32 0
  ret i32 %.1
}

; Function Attrs: nounwind uwtable
define i32 @usb_remote_wakeup(%struct.usb_device* %udev) #0 {
entry:
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp eq i32 %0, 8
  br i1 %cmp, label %do.body1, label %if.end12

do.body1:                                         ; preds = %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_remote_wakeup.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.end6

if.then4:                                         ; preds = %do.body1
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_remote_wakeup.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.23.138, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.32, i32 0, i32 0))
  br label %do.end6

do.end6:                                          ; preds = %if.then4, %do.body1
  %call7 = call i32 @usb_autoresume_device(%struct.usb_device* %udev)
  %cmp8 = icmp eq i32 %call7, 0
  br i1 %cmp8, label %if.then10, label %if.end12

if.then10:                                        ; preds = %do.end6
  call void @usb_autosuspend_device(%struct.usb_device* %udev)
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %do.end6, %entry
  %status.0 = phi i32 [ 0, %entry ], [ %call7, %if.then10 ], [ %call7, %do.end6 ]
  ret i32 %status.0
}

; Function Attrs: nounwind uwtable
define i32 @hub_port_debounce(%struct.usb_hub* %hub, i32 %port1, i1 zeroext %must_be_connected) #0 {
entry:
  %portchange = alloca i16, align 2
  %portstatus = alloca i16, align 2
  %frombool = zext i1 %must_be_connected to i8
  %0 = bitcast i16* %portchange to i8*
  %1 = bitcast i16* %portstatus to i8*
  br label %for.cond

for.cond:                                         ; preds = %if.end27, %entry
  %total_time.0 = phi i32 [ 0, %entry ], [ %add28, %if.end27 ]
  %stable_time.0 = phi i32 [ 0, %entry ], [ %stable_time.2, %if.end27 ]
  %connection.0 = phi i32 [ 65535, %entry ], [ %connection.1, %if.end27 ]
  %call = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1, i16* %portstatus, i16* %portchange)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %for.cond
  %2 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv = zext i16 %2 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %3 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv1 = zext i16 %3 to i32
  %and2 = and i32 %conv1, 1
  %cmp3 = icmp eq i32 %and2, %connection.0
  br i1 %cmp3, label %if.then5, label %if.else

if.then5:                                         ; preds = %land.lhs.true
  %tobool6 = trunc i8 %frombool to i1
  %tobool6.not = xor i1 %tobool6, true
  %cmp7 = icmp eq i32 %connection.0, 1
  %or.cond = or i1 %tobool6.not, %cmp7
  %add = add nsw i32 %stable_time.0, 25
  %stable_time.1 = select i1 %or.cond, i32 %add, i32 %stable_time.0
  %cmp11 = icmp sge i32 %stable_time.1, 100
  br i1 %cmp11, label %do.body29, label %if.end17

if.else:                                          ; preds = %land.lhs.true, %if.end
  %4 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv15 = zext i16 %4 to i32
  %and16 = and i32 %conv15, 1
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.then5
  %stable_time.2 = phi i32 [ 0, %if.else ], [ %stable_time.1, %if.then5 ]
  %connection.1 = phi i32 [ %and16, %if.else ], [ %connection.0, %if.then5 ]
  %5 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv18 = zext i16 %5 to i32
  %and19 = and i32 %conv18, 1
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.end17
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %call22 = call i32 @usb_clear_port_feature(%struct.usb_device* %6, i32 %port1, i32 16)
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end17
  %cmp24 = icmp sge i32 %total_time.0, 2000
  br i1 %cmp24, label %do.body29, label %if.end27

if.end27:                                         ; preds = %if.end23
  call void @msleep(i32 25)
  %add28 = add nsw i32 %total_time.0, 25
  br label %for.cond

do.body29:                                        ; preds = %if.end23, %if.then5
  %stable_time.3 = phi i32 [ %stable_time.1, %if.then5 ], [ %stable_time.2, %if.end23 ]
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_debounce.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and30 = and i32 %bf.clear, 1
  %tobool31 = icmp ne i32 %and30, 0
  %lnot = xor i1 %tobool31, true
  %lnot32 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot32 to i32
  %conv33 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv33, i64 0)
  %tobool34 = icmp ne i64 %expval, 0
  br i1 %tobool34, label %if.then35, label %do.end40

if.then35:                                        ; preds = %do.body29
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %7 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !173
  %8 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv36 = zext i16 %8 to i32
  %call37 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_debounce.descriptor to %struct._ddebug*), %struct.device* %7, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.34, i32 0, i32 0), i32 %port1, i32 %total_time.0, i32 %stable_time.3, i32 %conv36)
  br label %do.end40

do.end40:                                         ; preds = %if.then35, %do.body29
  %cmp41 = icmp slt i32 %stable_time.3, 100
  br i1 %cmp41, label %cleanup, label %if.end44

if.end44:                                         ; preds = %do.end40
  %9 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv45 = zext i16 %9 to i32
  br label %cleanup

cleanup:                                          ; preds = %if.end44, %do.end40, %for.cond
  %retval.0 = phi i32 [ %conv45, %if.end44 ], [ %call, %for.cond ], [ -110, %do.end40 ]
  %10 = bitcast i16* %portstatus to i8*
  %11 = bitcast i16* %portchange to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_hub_init() #0 {
entry:
  %call = call i32 @usb_register_driver(%struct.usb_driver* @hub_driver, %struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.902, i32 0, i32 0))
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = call i32 (i8*, ...) @printk(i8* null)
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call %struct.task_struct* (i32 (i8*)*, i8*, i32, i8*, ...) @kthread_create_on_node(i32 (i8*)* @hub_thread, i8* null, i32 -1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.36, i32 0, i32 0))
  %1 = bitcast %struct.task_struct* %call2 to i8*
  %call3 = call i64 @IS_ERR(i8* %1)
  %tobool = icmp ne i64 %call3, 0
  br i1 %tobool, label %if.end6, label %if.then4

if.then4:                                         ; preds = %if.end
  %call5 = call i32 @wake_up_process(%struct.task_struct* %call2)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end
  store %struct.task_struct* %call2, %struct.task_struct** @khubd_task, align 8, !tbaa !48
  %2 = load %struct.task_struct*, %struct.task_struct** @khubd_task, align 8, !tbaa !48
  %3 = bitcast %struct.task_struct* %2 to i8*
  %call7 = call i64 @IS_ERR(i8* %3)
  %tobool8 = icmp ne i64 %call7, 0
  br i1 %tobool8, label %if.end10, label %return

if.end10:                                         ; preds = %if.end6
  call void @usb_deregister(%struct.usb_driver* @hub_driver)
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %return

return:                                           ; preds = %if.end10, %if.end6, %if.then
  %retval.0 = phi i32 [ -1, %if.then ], [ -1, %if.end10 ], [ 0, %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_thread(i8* %__unused) #0 {
entry:
  %__wait = alloca %struct.__wait_queue, align 8
  %call = call zeroext i1 @set_freezable()
  br label %do.body

do.body.critedge:                                 ; preds = %do.cond36
  br label %do.body

do.body:                                          ; preds = %lor.rhs, %do.body.critedge, %entry
  call void @hub_events()
  br label %for.cond

for.cond:                                         ; preds = %if.end32, %do.body
  %call1 = call i32 @list_empty(%struct.list_head* @hub_event_list)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %lor.lhs.false, label %if.end24

lor.lhs.false:                                    ; preds = %for.cond
  %call2 = call zeroext i1 @kthread_should_stop()
  br i1 %call2, label %if.end24, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !111
  %call5 = call zeroext i1 @freezing(%struct.task_struct* %0)
  br i1 %call5, label %if.end24, label %do.body6

do.body6:                                         ; preds = %lor.lhs.false3
  %1 = bitcast %struct.__wait_queue* %__wait to i8*
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !246
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 1
  %2 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !111
  %3 = bitcast %struct.task_struct* %2 to i8*
  store i8* %3, i8** %private, align 8, !tbaa !248
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @autoremove_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !249
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  %task_list8 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list8, %struct.list_head** %next, align 8, !tbaa !95
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  %task_list9 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list9, %struct.list_head** %prev, align 8, !tbaa !96
  br label %for.cond10

for.cond10:                                       ; preds = %if.then22, %do.body6
  call void @prepare_to_wait(%struct.__wait_queue_head* @khubd_wait, %struct.__wait_queue* %__wait, i32 1)
  %call11 = call i32 @list_empty(%struct.list_head* @hub_event_list)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %lor.lhs.false13, label %for.end

lor.lhs.false13:                                  ; preds = %for.cond10
  %call14 = call zeroext i1 @kthread_should_stop()
  br i1 %call14, label %for.end, label %lor.lhs.false15

lor.lhs.false15:                                  ; preds = %lor.lhs.false13
  %4 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !111
  %call17 = call zeroext i1 @freezing(%struct.task_struct* %4)
  br i1 %call17, label %for.end, label %if.end

if.end:                                           ; preds = %lor.lhs.false15
  %5 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !111
  %call20 = call i32 @signal_pending(%struct.task_struct* %5)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %for.end, label %if.then22

if.then22:                                        ; preds = %if.end
  call void @schedule()
  br label %for.cond10

for.end:                                          ; preds = %if.end, %lor.lhs.false15, %lor.lhs.false13, %for.cond10
  %__ret.0 = phi i32 [ 0, %lor.lhs.false15 ], [ 0, %lor.lhs.false13 ], [ 0, %for.cond10 ], [ -512, %if.end ]
  call void @finish_wait(%struct.__wait_queue_head* @khubd_wait, %struct.__wait_queue* %__wait)
  %6 = bitcast %struct.__wait_queue* %__wait to i8*
  br label %if.end24

if.end24:                                         ; preds = %for.end, %lor.lhs.false3, %lor.lhs.false, %for.cond
  %__ret.1 = phi i32 [ 0, %lor.lhs.false ], [ 0, %lor.lhs.false3 ], [ %__ret.0, %for.end ], [ 0, %for.cond ]
  %tobool25 = icmp ne i32 %__ret.1, 0
  br i1 %tobool25, label %do.cond36, label %lor.lhs.false26

lor.lhs.false26:                                  ; preds = %if.end24
  %call27 = call i32 @list_empty(%struct.list_head* @hub_event_list)
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %lor.lhs.false29, label %do.cond36

lor.lhs.false29:                                  ; preds = %lor.lhs.false26
  %call30 = call zeroext i1 @kthread_should_stop()
  br i1 %call30, label %do.cond36, label %if.end32

if.end32:                                         ; preds = %lor.lhs.false29
  call void @try_to_freeze()
  br label %for.cond

do.cond36:                                        ; preds = %lor.lhs.false29, %lor.lhs.false26, %if.end24
  %call37 = call zeroext i1 @kthread_should_stop()
  br i1 %call37, label %lor.rhs, label %do.body.critedge

lor.rhs:                                          ; preds = %do.cond36
  %call38 = call i32 @list_empty(%struct.list_head* @hub_event_list)
  %tobool39 = icmp ne i32 %call38, 0
  %lnot = xor i1 %tobool39, true
  br i1 %lnot, label %do.body, label %do.body41

do.body41:                                        ; preds = %lor.rhs
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_thread.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool42 = icmp ne i32 %and, 0
  %lnot43 = xor i1 %tobool42, true
  %lnot44 = xor i1 %lnot43, true
  %lnot.ext = zext i1 %lnot44 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool45 = icmp ne i64 %expval, 0
  br i1 %tobool45, label %if.then46, label %do.end50

if.then46:                                        ; preds = %do.body41
  %7 = load i8*, i8** @usbcore_name, align 8, !tbaa !48
  %call47 = call i32 (%struct._ddebug*, i8*, ...) @__dynamic_pr_debug(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_thread.descriptor to %struct._ddebug*), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.182, i32 0, i32 0), i8* %7)
  br label %do.end50

do.end50:                                         ; preds = %if.then46, %do.body41
  ret i32 0
}

declare %struct.task_struct* @kthread_create_on_node(i32 (i8*)*, i8*, i32, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR(i8* %ptr) #1 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

declare i32 @wake_up_process(%struct.task_struct*) #2

declare zeroext i1 @set_freezable() #2

; Function Attrs: nounwind uwtable
define internal void @hub_events() #0 {
entry:
  %hubstatus = alloca i16, align 2
  %hubchange = alloca i16, align 2
  %portstatus = alloca i16, align 2
  %portchange = alloca i16, align 2
  %status = alloca i16, align 2
  %unused = alloca i16, align 2
  %status418 = alloca i16, align 2
  %unused419 = alloca i16, align 2
  %0 = bitcast i16* %hubstatus to i8*
  %1 = bitcast i16* %hubchange to i8*
  %2 = bitcast i16* %portstatus to i8*
  %3 = bitcast i16* %portchange to i8*
  br label %while.cond

while.cond:                                       ; preds = %loop_disconnected, %entry
  call void @spin_lock_irq(%struct.spinlock* @hub_event_lock)
  %call = call i32 @list_empty(%struct.list_head* @hub_event_list)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.cond
  call void @spin_unlock_irq(%struct.spinlock* @hub_event_lock)
  %4 = bitcast i16* %portchange to i8*
  %5 = bitcast i16* %portstatus to i8*
  %6 = bitcast i16* %hubchange to i8*
  %7 = bitcast i16* %hubstatus to i8*
  ret void

if.end:                                           ; preds = %while.cond
  %8 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.list_head, %struct.list_head* @hub_event_list, i32 0, i32 0), align 8, !tbaa !95
  call void @list_del_init(%struct.list_head* %8)
  %9 = bitcast %struct.list_head* %8 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %9, i64 -224
  %10 = bitcast i8* %add.ptr to %struct.usb_hub*
  %kref = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 2
  call void @kref_get(%struct.arch_spinlock* %kref)
  call void @spin_unlock_irq(%struct.spinlock* @hub_event_lock)
  %hdev2 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 1
  %11 = load %struct.usb_device*, %struct.usb_device** %hdev2, align 8, !tbaa !152
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 0
  %12 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !173
  %13 = bitcast %struct.device* %12 to i8*
  %add.ptr5 = getelementptr inbounds i8, i8* %13, i64 -48
  %14 = bitcast i8* %add.ptr5 to %struct.usb_interface*
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool7 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool7, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %do.end22

if.then10:                                        ; preds = %if.end
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %11, i32 0, i32 3
  %15 = load i32, i32* %state, align 8, !tbaa !50
  %descriptor = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 15
  %16 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !204
  %tobool11 = icmp ne %struct.usb_hub_descriptor* %16, null
  br i1 %tobool11, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.then10
  %descriptor12 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 15
  %17 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor12, align 8, !tbaa !204
  %bNbrPorts = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %17, i32 0, i32 2
  %18 = load i8, i8* %bNbrPorts, align 1, !tbaa !250
  %conv13 = zext i8 %18 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.then10
  %cond = phi i32 [ %conv13, %cond.true ], [ 0, %if.then10 ]
  %change_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 11
  %arrayidx = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits, i64 0, i64 0
  %19 = load i64, i64* %arrayidx, align 8, !tbaa !49
  %conv14 = trunc i64 %19 to i16
  %conv15 = zext i16 %conv14 to i32
  %event_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 10
  %arrayidx16 = getelementptr inbounds [1 x i64], [1 x i64]* %event_bits, i64 0, i64 0
  %20 = load i64, i64* %arrayidx16, align 8, !tbaa !49
  %conv17 = trunc i64 %20 to i16
  %conv18 = zext i16 %conv17 to i32
  %call19 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor to %struct._ddebug*), %struct.device* %12, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.183, i32 0, i32 0), i32 %15, i32 %cond, i32 %conv15, i32 %conv18)
  br label %do.end22

do.end22:                                         ; preds = %cond.end, %if.end
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %11, i32 0, i32 11
  call void @device_lock(%struct.device* %dev)
  %disconnected = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 18
  %bf.load23 = load i8, i8* %disconnected, align 4
  %bf.lshr24 = lshr i8 %bf.load23, 2
  %bf.clear25 = and i8 %bf.lshr24, 1
  %bf.cast = zext i8 %bf.clear25 to i32
  %tobool26 = icmp ne i32 %bf.cast, 0
  %lnot27 = xor i1 %tobool26, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %loop_disconnected, label %if.end35

if.end35:                                         ; preds = %do.end22
  %state36 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %11, i32 0, i32 3
  %21 = load i32, i32* %state36, align 8, !tbaa !50
  %cmp = icmp eq i32 %21, 0
  br i1 %cmp, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.end35
  %error = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 7
  store i32 -19, i32* %error, align 8, !tbaa !174
  call void @hub_quiesce(%struct.usb_hub* %10, i32 0)
  br label %loop

if.end39:                                         ; preds = %if.end35
  %call40 = call i32 @usb_autopm_get_interface(%struct.usb_interface* %14)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %do.body44, label %if.end64

do.body44:                                        ; preds = %if.end39
  %bf.load45 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.184 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr46 = lshr i32 %bf.load45, 18
  %bf.clear47 = and i32 %bf.lshr46, 255
  %and48 = and i32 %bf.clear47, 1
  %tobool49 = icmp ne i32 %and48, 0
  %lnot50 = xor i1 %tobool49, true
  %lnot52 = xor i1 %lnot50, true
  %lnot.ext53 = zext i1 %lnot52 to i32
  %conv54 = sext i32 %lnot.ext53 to i64
  %expval55 = call i64 @llvm.expect.i64(i64 %conv54, i64 0)
  %tobool56 = icmp ne i64 %expval55, 0
  br i1 %tobool56, label %if.then57, label %loop

if.then57:                                        ; preds = %do.body44
  %call58 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.184 to %struct._ddebug*), %struct.device* %12, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.185, i32 0, i32 0), i32 %call40)
  br label %loop

if.end64:                                         ; preds = %if.end39
  %quiescing = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 18
  %bf.load65 = load i8, i8* %quiescing, align 4
  %bf.lshr66 = lshr i8 %bf.load65, 1
  %bf.clear67 = and i8 %bf.lshr66, 1
  %bf.cast68 = zext i8 %bf.clear67 to i32
  %tobool69 = icmp ne i32 %bf.cast68, 0
  br i1 %tobool69, label %loop_autopm, label %if.end71

if.end71:                                         ; preds = %if.end64
  %error72 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 7
  %22 = load i32, i32* %error72, align 8, !tbaa !174
  %tobool73 = icmp ne i32 %22, 0
  br i1 %tobool73, label %do.body76, label %if.end123

do.body76:                                        ; preds = %if.end71
  %bf.load77 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.186 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr78 = lshr i32 %bf.load77, 18
  %bf.clear79 = and i32 %bf.lshr78, 255
  %and80 = and i32 %bf.clear79, 1
  %tobool81 = icmp ne i32 %and80, 0
  %lnot82 = xor i1 %tobool81, true
  %lnot84 = xor i1 %lnot82, true
  %lnot.ext85 = zext i1 %lnot84 to i32
  %conv86 = sext i32 %lnot.ext85 to i64
  %expval87 = call i64 @llvm.expect.i64(i64 %conv86, i64 0)
  %tobool88 = icmp ne i64 %expval87, 0
  br i1 %tobool88, label %if.then89, label %do.end96

if.then89:                                        ; preds = %do.body76
  %error90 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 7
  %23 = load i32, i32* %error90, align 8, !tbaa !174
  %call91 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.186 to %struct._ddebug*), %struct.device* %12, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.187, i32 0, i32 0), i32 %23)
  br label %do.end96

do.end96:                                         ; preds = %if.then89, %do.body76
  %call97 = call i32 @usb_reset_device(%struct.usb_device* %11)
  %tobool98 = icmp ne i32 %call97, 0
  br i1 %tobool98, label %do.body101, label %if.end121

do.body101:                                       ; preds = %do.end96
  %bf.load102 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.188 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr103 = lshr i32 %bf.load102, 18
  %bf.clear104 = and i32 %bf.lshr103, 255
  %and105 = and i32 %bf.clear104, 1
  %tobool106 = icmp ne i32 %and105, 0
  %lnot107 = xor i1 %tobool106, true
  %lnot109 = xor i1 %lnot107, true
  %lnot.ext110 = zext i1 %lnot109 to i32
  %conv111 = sext i32 %lnot.ext110 to i64
  %expval112 = call i64 @llvm.expect.i64(i64 %conv111, i64 0)
  %tobool113 = icmp ne i64 %expval112, 0
  br i1 %tobool113, label %if.then114, label %loop_autopm

if.then114:                                       ; preds = %do.body101
  %call115 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.188 to %struct._ddebug*), %struct.device* %12, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.189, i32 0, i32 0), i32 %call97)
  br label %loop_autopm

if.end121:                                        ; preds = %do.end96
  %nerrors = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 8
  store i32 0, i32* %nerrors, align 4, !tbaa !251
  %error122 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 7
  store i32 0, i32* %error122, align 8, !tbaa !174
  br label %if.end123

if.end123:                                        ; preds = %if.end121, %if.end71
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end123
  %i.0 = phi i32 [ 1, %if.end123 ], [ %inc, %for.inc ]
  %descriptor124 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 15
  %24 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor124, align 8, !tbaa !204
  %bNbrPorts125 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %24, i32 0, i32 2
  %25 = load i8, i8* %bNbrPorts125, align 1, !tbaa !250
  %conv126 = zext i8 %25 to i32
  %cmp127 = icmp sle i32 %i.0, %conv126
  br i1 %cmp127, label %cond.false132, label %for.end

cond.false132:                                    ; preds = %for.cond
  %busy_bits133 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 12
  %arraydecay134 = getelementptr inbounds [1 x i64], [1 x i64]* %busy_bits133, i32 0, i32 0
  %call135 = call i32 @variable_test_bit(i32 %i.0, i64* %arraydecay134)
  %tobool136 = icmp ne i32 %call135, 0
  br i1 %tobool136, label %for.inc, label %if.end138

if.end138:                                        ; preds = %cond.false132
  %change_bits139 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 11
  %arraydecay140 = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits139, i32 0, i32 0
  %call141 = call i32 @variable_test_bit(i32 %i.0, i64* %arraydecay140)
  %wakeup_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 14
  %arraydecay142 = getelementptr inbounds [1 x i64], [1 x i64]* %wakeup_bits, i32 0, i32 0
  %call143 = call i32 @test_and_clear_bit(i32 %i.0, i64* %arraydecay142)
  %event_bits144 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 10
  %arraydecay145 = getelementptr inbounds [1 x i64], [1 x i64]* %event_bits144, i32 0, i32 0
  %call146 = call i32 @test_and_clear_bit(i32 %i.0, i64* %arraydecay145)
  %tobool147 = icmp ne i32 %call146, 0
  %tobool148 = icmp ne i32 %call141, 0
  %or.cond = or i1 %tobool147, %tobool148
  %tobool150 = icmp ne i32 %call143, 0
  %or.cond1 = or i1 %or.cond, %tobool150
  br i1 %or.cond1, label %if.end152, label %for.inc

if.end152:                                        ; preds = %if.end138
  %call153 = call i32 @hub_port_status(%struct.usb_hub* %10, i32 %i.0, i16* %portstatus, i16* %portchange)
  %cmp154 = icmp slt i32 %call153, 0
  br i1 %cmp154, label %for.inc, label %if.end157

if.end157:                                        ; preds = %if.end152
  %26 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv158 = zext i16 %26 to i32
  %and159 = and i32 %conv158, 1
  %tobool160 = icmp ne i32 %and159, 0
  br i1 %tobool160, label %if.then161, label %if.end163

if.then161:                                       ; preds = %if.end157
  %call162 = call i32 @usb_clear_port_feature(%struct.usb_device* %11, i32 %i.0, i32 16)
  br label %if.end163

if.end163:                                        ; preds = %if.then161, %if.end157
  %connect_change.0 = phi i32 [ 1, %if.then161 ], [ %call141, %if.end157 ]
  %27 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv164 = zext i16 %27 to i32
  %and165 = and i32 %conv164, 2
  %tobool166 = icmp ne i32 %and165, 0
  br i1 %tobool166, label %if.then167, label %if.end205

if.then167:                                       ; preds = %if.end163
  %tobool168 = icmp ne i32 %connect_change.0, 0
  br i1 %tobool168, label %if.end192, label %do.body171

do.body171:                                       ; preds = %if.then167
  %bf.load172 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.190 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr173 = lshr i32 %bf.load172, 18
  %bf.clear174 = and i32 %bf.lshr173, 255
  %and175 = and i32 %bf.clear174, 1
  %tobool176 = icmp ne i32 %and175, 0
  %lnot177 = xor i1 %tobool176, true
  %lnot179 = xor i1 %lnot177, true
  %lnot.ext180 = zext i1 %lnot179 to i32
  %conv181 = sext i32 %lnot.ext180 to i64
  %expval182 = call i64 @llvm.expect.i64(i64 %conv181, i64 0)
  %tobool183 = icmp ne i64 %expval182, 0
  br i1 %tobool183, label %if.then184, label %if.end192

if.then184:                                       ; preds = %do.body171
  %28 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv185 = zext i16 %28 to i32
  %call186 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.190 to %struct._ddebug*), %struct.device* %12, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.191, i32 0, i32 0), i32 %i.0, i32 %conv185)
  br label %if.end192

if.end192:                                        ; preds = %if.then184, %do.body171, %if.then167
  %call193 = call i32 @usb_clear_port_feature(%struct.usb_device* %11, i32 %i.0, i32 17)
  %29 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv194 = zext i16 %29 to i32
  %and195 = and i32 %conv194, 2
  %tobool196 = icmp ne i32 %and195, 0
  %tobool198 = icmp ne i32 %connect_change.0, 0
  %or.cond2 = or i1 %tobool196, %tobool198
  br i1 %or.cond2, label %if.end205, label %land.lhs.true199

land.lhs.true199:                                 ; preds = %if.end192
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 22
  %30 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %sub = sub nsw i32 %i.0, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx200 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %30, i64 %idxprom
  %31 = load %struct.usb_port*, %struct.usb_port** %arrayidx200, align 8, !tbaa !48
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %31, i32 0, i32 0
  %32 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !102
  %tobool201 = icmp ne %struct.usb_device* %32, null
  br i1 %tobool201, label %if.then202, label %if.end205

if.then202:                                       ; preds = %land.lhs.true199
  %33 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end205

if.end205:                                        ; preds = %if.then202, %land.lhs.true199, %if.end192, %if.end163
  %connect_change.2 = phi i32 [ %connect_change.0, %if.end163 ], [ %connect_change.0, %if.end192 ], [ 1, %if.then202 ], [ %connect_change.0, %land.lhs.true199 ]
  %34 = load i16, i16* %portstatus, align 2, !tbaa !143
  %35 = load i16, i16* %portchange, align 2, !tbaa !143
  %call206 = call i32 @hub_handle_remote_wakeup(%struct.usb_hub* %10, i32 %i.0, i16 zeroext %34, i16 zeroext %35)
  %tobool207 = icmp ne i32 %call206, 0
  %.connect_change.2 = select i1 %tobool207, i32 1, i32 %connect_change.2
  %36 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv210 = zext i16 %36 to i32
  %and211 = and i32 %conv210, 8
  %tobool212 = icmp ne i32 %and211, 0
  br i1 %tobool212, label %if.then213, label %if.end244

if.then213:                                       ; preds = %if.end205
  %37 = bitcast i16* %status to i8*
  store i16 0, i16* %status, align 2, !tbaa !143
  %38 = bitcast i16* %unused to i8*
  %bf.load216 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.193 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr217 = lshr i32 %bf.load216, 18
  %bf.clear218 = and i32 %bf.lshr217, 255
  %and219 = and i32 %bf.clear218, 1
  %tobool220 = icmp ne i32 %and219, 0
  %lnot221 = xor i1 %tobool220, true
  %lnot223 = xor i1 %lnot221, true
  %lnot.ext224 = zext i1 %lnot223 to i32
  %conv225 = sext i32 %lnot.ext224 to i64
  %expval226 = call i64 @llvm.expect.i64(i64 %conv225, i64 0)
  %tobool227 = icmp ne i64 %expval226, 0
  br i1 %tobool227, label %if.then228, label %do.end234

if.then228:                                       ; preds = %if.then213
  %call229 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.193 to %struct._ddebug*), %struct.device* %12, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.194, i32 0, i32 0), i32 %i.0)
  br label %do.end234

do.end234:                                        ; preds = %if.then228, %if.then213
  %call235 = call i32 @usb_clear_port_feature(%struct.usb_device* %11, i32 %i.0, i32 19)
  call void @msleep(i32 100)
  %call236 = call i32 @hub_power_on(%struct.usb_hub* %10, i1 zeroext true)
  %call237 = call i32 @hub_port_status(%struct.usb_hub* %10, i32 %i.0, i16* %status, i16* %unused)
  %39 = load i16, i16* %status, align 2, !tbaa !143
  %conv238 = zext i16 %39 to i32
  %and239 = and i32 %conv238, 8
  %tobool240 = icmp ne i32 %and239, 0
  br i1 %tobool240, label %if.then241, label %if.end243

if.then241:                                       ; preds = %do.end234
  %40 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end243

if.end243:                                        ; preds = %if.then241, %do.end234
  %41 = bitcast i16* %unused to i8*
  %42 = bitcast i16* %status to i8*
  br label %if.end244

if.end244:                                        ; preds = %if.end243, %if.end205
  %43 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv245 = zext i16 %43 to i32
  %and246 = and i32 %conv245, 16
  %tobool247 = icmp ne i32 %and246, 0
  br i1 %tobool247, label %do.body250, label %if.end271

do.body250:                                       ; preds = %if.end244
  %bf.load251 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.196 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr252 = lshr i32 %bf.load251, 18
  %bf.clear253 = and i32 %bf.lshr252, 255
  %and254 = and i32 %bf.clear253, 1
  %tobool255 = icmp ne i32 %and254, 0
  %lnot256 = xor i1 %tobool255, true
  %lnot258 = xor i1 %lnot256, true
  %lnot.ext259 = zext i1 %lnot258 to i32
  %conv260 = sext i32 %lnot.ext259 to i64
  %expval261 = call i64 @llvm.expect.i64(i64 %conv260, i64 0)
  %tobool262 = icmp ne i64 %expval261, 0
  br i1 %tobool262, label %if.then263, label %do.end269

if.then263:                                       ; preds = %do.body250
  %call264 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.196 to %struct._ddebug*), %struct.device* %12, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.197, i32 0, i32 0), i32 %i.0)
  br label %do.end269

do.end269:                                        ; preds = %if.then263, %do.body250
  %call270 = call i32 @usb_clear_port_feature(%struct.usb_device* %11, i32 %i.0, i32 20)
  br label %if.end271

if.end271:                                        ; preds = %do.end269, %if.end244
  %44 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv272 = zext i16 %44 to i32
  %and273 = and i32 %conv272, 32
  %tobool274 = icmp ne i32 %and273, 0
  br i1 %tobool274, label %land.lhs.true275, label %if.end302

land.lhs.true275:                                 ; preds = %if.end271
  %hdev276 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 1
  %45 = load %struct.usb_device*, %struct.usb_device** %hdev276, align 8, !tbaa !152
  %call277 = call i32 @hub_is_superspeed(%struct.usb_device* %45)
  %tobool278 = icmp ne i32 %call277, 0
  br i1 %tobool278, label %do.body281, label %if.end302

do.body281:                                       ; preds = %land.lhs.true275
  %bf.load282 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.198 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr283 = lshr i32 %bf.load282, 18
  %bf.clear284 = and i32 %bf.lshr283, 255
  %and285 = and i32 %bf.clear284, 1
  %tobool286 = icmp ne i32 %and285, 0
  %lnot287 = xor i1 %tobool286, true
  %lnot289 = xor i1 %lnot287, true
  %lnot.ext290 = zext i1 %lnot289 to i32
  %conv291 = sext i32 %lnot.ext290 to i64
  %expval292 = call i64 @llvm.expect.i64(i64 %conv291, i64 0)
  %tobool293 = icmp ne i64 %expval292, 0
  br i1 %tobool293, label %if.then294, label %do.end300

if.then294:                                       ; preds = %do.body281
  %call295 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.198 to %struct._ddebug*), %struct.device* %12, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.199, i32 0, i32 0), i32 %i.0)
  br label %do.end300

do.end300:                                        ; preds = %if.then294, %do.body281
  %call301 = call i32 @usb_clear_port_feature(%struct.usb_device* %11, i32 %i.0, i32 29)
  br label %if.end302

if.end302:                                        ; preds = %do.end300, %land.lhs.true275, %if.end271
  %46 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv303 = zext i16 %46 to i32
  %and304 = and i32 %conv303, 64
  %tobool305 = icmp ne i32 %and304, 0
  br i1 %tobool305, label %if.then306, label %if.end309

if.then306:                                       ; preds = %if.end302
  %hdev307 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 1
  %47 = load %struct.usb_device*, %struct.usb_device** %hdev307, align 8, !tbaa !152
  %call308 = call i32 @usb_clear_port_feature(%struct.usb_device* %47, i32 %i.0, i32 25)
  br label %if.end309

if.end309:                                        ; preds = %if.then306, %if.end302
  %48 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv310 = zext i16 %48 to i32
  %and311 = and i32 %conv310, 128
  %tobool312 = icmp ne i32 %and311, 0
  br i1 %tobool312, label %if.then313, label %if.end317

if.then313:                                       ; preds = %if.end309
  %49 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %hdev315 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 1
  %50 = load %struct.usb_device*, %struct.usb_device** %hdev315, align 8, !tbaa !152
  %call316 = call i32 @usb_clear_port_feature(%struct.usb_device* %50, i32 %i.0, i32 26)
  br label %if.end317

if.end317:                                        ; preds = %if.then313, %if.end309
  %51 = load i16, i16* %portstatus, align 2, !tbaa !143
  %call318 = call zeroext i1 @hub_port_warm_reset_required(%struct.usb_hub* %10, i16 zeroext %51)
  br i1 %call318, label %if.then319, label %if.end359

if.then319:                                       ; preds = %if.end317
  %ports321 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 22
  %52 = load %struct.usb_port**, %struct.usb_port*** %ports321, align 8, !tbaa !98
  %sub322 = sub nsw i32 %i.0, 1
  %idxprom323 = sext i32 %sub322 to i64
  %arrayidx324 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %52, i64 %idxprom323
  %53 = load %struct.usb_port*, %struct.usb_port** %arrayidx324, align 8, !tbaa !48
  %child325 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %53, i32 0, i32 0
  %54 = load %struct.usb_device*, %struct.usb_device** %child325, align 8, !tbaa !102
  %bf.load328 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.201 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr329 = lshr i32 %bf.load328, 18
  %bf.clear330 = and i32 %bf.lshr329, 255
  %and331 = and i32 %bf.clear330, 1
  %tobool332 = icmp ne i32 %and331, 0
  %lnot333 = xor i1 %tobool332, true
  %lnot335 = xor i1 %lnot333, true
  %lnot.ext336 = zext i1 %lnot335 to i32
  %conv337 = sext i32 %lnot.ext336 to i64
  %expval338 = call i64 @llvm.expect.i64(i64 %conv337, i64 0)
  %tobool339 = icmp ne i64 %expval338, 0
  br i1 %tobool339, label %if.then340, label %do.end346

if.then340:                                       ; preds = %if.then319
  %call341 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.201 to %struct._ddebug*), %struct.device* %12, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.202, i32 0, i32 0), i32 %i.0)
  br label %do.end346

do.end346:                                        ; preds = %if.then340, %if.then319
  %tobool347 = icmp ne %struct.usb_device* %54, null
  br i1 %tobool347, label %if.else, label %if.then348

if.then348:                                       ; preds = %do.end346
  %call349 = call i32 @hub_port_reset(%struct.usb_hub* %10, i32 %i.0, %struct.usb_device* null, i32 50, i1 zeroext true)
  %cmp350 = icmp slt i32 %call349, 0
  br i1 %cmp350, label %if.then352, label %if.end359

if.then352:                                       ; preds = %if.then348
  call void @hub_port_disable(%struct.usb_hub* %10, i32 %i.0, i32 1)
  br label %if.end359

if.else:                                          ; preds = %do.end346
  %dev355 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %54, i32 0, i32 11
  call void @device_lock(%struct.device* %dev355)
  %call356 = call i32 @usb_reset_device(%struct.usb_device* %54)
  %dev357 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %54, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev357)
  br label %if.end359

if.end359:                                        ; preds = %if.else, %if.then352, %if.then348, %if.end317
  %connect_change.4 = phi i32 [ %.connect_change.2, %if.end317 ], [ 0, %if.then348 ], [ 0, %if.then352 ], [ 0, %if.else ]
  %tobool360 = icmp ne i32 %connect_change.4, 0
  br i1 %tobool360, label %if.then361, label %for.inc

if.then361:                                       ; preds = %if.end359
  %55 = load i16, i16* %portstatus, align 2, !tbaa !143
  %56 = load i16, i16* %portchange, align 2, !tbaa !143
  call void @hub_port_connect_change(%struct.usb_hub* %10, i32 %i.0, i16 zeroext %55, i16 zeroext %56)
  br label %for.inc

for.inc:                                          ; preds = %if.then361, %if.end359, %if.end152, %if.end138, %cond.false132
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %event_bits363 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 10
  %arraydecay364 = getelementptr inbounds [1 x i64], [1 x i64]* %event_bits363, i32 0, i32 0
  %call365 = call i32 @test_and_clear_bit(i32 0, i64* %arraydecay364)
  %cmp366 = icmp eq i32 %call365, 0
  br i1 %cmp366, label %loop_autopm, label %if.else369

if.else369:                                       ; preds = %for.end
  %call370 = call i32 @hub_hub_status(%struct.usb_hub* %10, i16* %hubstatus, i16* %hubchange)
  %cmp371 = icmp slt i32 %call370, 0
  br i1 %cmp371, label %if.then373, label %if.else375

if.then373:                                       ; preds = %if.else369
  %57 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %loop_autopm

if.else375:                                       ; preds = %if.else369
  %58 = load i16, i16* %hubchange, align 2, !tbaa !143
  %conv376 = zext i16 %58 to i32
  %and377 = and i32 %conv376, 1
  %tobool378 = icmp ne i32 %and377, 0
  br i1 %tobool378, label %do.body381, label %if.end413

do.body381:                                       ; preds = %if.else375
  %bf.load382 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.204 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr383 = lshr i32 %bf.load382, 18
  %bf.clear384 = and i32 %bf.lshr383, 255
  %and385 = and i32 %bf.clear384, 1
  %tobool386 = icmp ne i32 %and385, 0
  %lnot387 = xor i1 %tobool386, true
  %lnot389 = xor i1 %lnot387, true
  %lnot.ext390 = zext i1 %lnot389 to i32
  %conv391 = sext i32 %lnot.ext390 to i64
  %expval392 = call i64 @llvm.expect.i64(i64 %conv391, i64 0)
  %tobool393 = icmp ne i64 %expval392, 0
  br i1 %tobool393, label %if.then394, label %do.end400

if.then394:                                       ; preds = %do.body381
  %call395 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.204 to %struct._ddebug*), %struct.device* %12, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.205, i32 0, i32 0))
  br label %do.end400

do.end400:                                        ; preds = %if.then394, %do.body381
  call void @clear_hub_feature(%struct.usb_device* %11, i32 0)
  %59 = load i16, i16* %hubstatus, align 2, !tbaa !143
  %conv402 = zext i16 %59 to i32
  %and403 = and i32 %conv402, 1
  %tobool404 = icmp ne i32 %and403, 0
  %limited_power = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 18
  %bf.load406 = load i8, i8* %limited_power, align 4
  %bf.clear407 = and i8 %bf.load406, -2
  %bf.set = or i8 %bf.clear407, 1
  %bf.clear407.sink = select i1 %tobool404, i8 %bf.set, i8 %bf.clear407
  store i8 %bf.clear407.sink, i8* %limited_power, align 4
  br label %if.end413

if.end413:                                        ; preds = %do.end400, %if.else375
  %60 = load i16, i16* %hubchange, align 2, !tbaa !143
  %conv414 = zext i16 %60 to i32
  %and415 = and i32 %conv414, 2
  %tobool416 = icmp ne i32 %and415, 0
  br i1 %tobool416, label %if.then417, label %loop_autopm

if.then417:                                       ; preds = %if.end413
  %61 = bitcast i16* %status418 to i8*
  store i16 0, i16* %status418, align 2, !tbaa !143
  %62 = bitcast i16* %unused419 to i8*
  %bf.load422 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.206 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr423 = lshr i32 %bf.load422, 18
  %bf.clear424 = and i32 %bf.lshr423, 255
  %and425 = and i32 %bf.clear424, 1
  %tobool426 = icmp ne i32 %and425, 0
  %lnot427 = xor i1 %tobool426, true
  %lnot429 = xor i1 %lnot427, true
  %lnot.ext430 = zext i1 %lnot429 to i32
  %conv431 = sext i32 %lnot.ext430 to i64
  %expval432 = call i64 @llvm.expect.i64(i64 %conv431, i64 0)
  %tobool433 = icmp ne i64 %expval432, 0
  br i1 %tobool433, label %if.then434, label %do.end440

if.then434:                                       ; preds = %if.then417
  %call435 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_events.descriptor.206 to %struct._ddebug*), %struct.device* %12, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.207, i32 0, i32 0))
  br label %do.end440

do.end440:                                        ; preds = %if.then434, %if.then417
  call void @clear_hub_feature(%struct.usb_device* %11, i32 1)
  call void @msleep(i32 500)
  %call442 = call i32 @hub_power_on(%struct.usb_hub* %10, i1 zeroext true)
  %call443 = call i32 @hub_hub_status(%struct.usb_hub* %10, i16* %status418, i16* %unused419)
  %63 = load i16, i16* %status418, align 2, !tbaa !143
  %conv444 = zext i16 %63 to i32
  %and445 = and i32 %conv444, 2
  %tobool446 = icmp ne i32 %and445, 0
  br i1 %tobool446, label %if.then447, label %if.end449

if.then447:                                       ; preds = %do.end440
  %64 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end449

if.end449:                                        ; preds = %if.then447, %do.end440
  %65 = bitcast i16* %unused419 to i8*
  %66 = bitcast i16* %status418 to i8*
  br label %loop_autopm

loop_autopm:                                      ; preds = %if.end449, %if.end413, %if.then373, %for.end, %if.then114, %do.body101, %if.end64
  call void @usb_autopm_put_interface_no_suspend(%struct.usb_interface* %14)
  br label %loop

loop:                                             ; preds = %loop_autopm, %if.then57, %do.body44, %if.then38
  call void @usb_autopm_put_interface(%struct.usb_interface* %14)
  br label %loop_disconnected

loop_disconnected:                                ; preds = %loop, %do.end22
  %dev453 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %11, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev453)
  %kref454 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %10, i32 0, i32 2
  call void @kref_put(%struct.arch_spinlock* %kref454, void (%struct.arch_spinlock*)* @hub_release)
  br label %while.cond
}

declare zeroext i1 @kthread_should_stop() #2

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @freezing(%struct.task_struct* %p) #1 {
entry:
  %call = call i32 @atomic_read(%union.anon.5* @system_freezing_cnt)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call4 = call zeroext i1 @freezing_slow_path(%struct.task_struct* %p)
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i1 [ %call4, %if.end ], [ false, %entry ]
  ret i1 %retval.0
}

declare i32 @autoremove_wake_function(%struct.__wait_queue*, i32, i32, i8*) #2

declare void @prepare_to_wait(%struct.__wait_queue_head*, %struct.__wait_queue*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @signal_pending(%struct.task_struct* %p) #1 {
entry:
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* %p, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

declare void @schedule() #2

declare void @finish_wait(%struct.__wait_queue_head*, %struct.__wait_queue*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @try_to_freeze() #1 {
entry:
  call void @__might_sleep(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.257, i32 0, i32 0), i32 51, i32 0)
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !111
  %call3 = call zeroext i1 @freezing(%struct.task_struct* %0)
  %lnot = xor i1 %call3, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call6 = call zeroext i1 @__refrigerator(i1 zeroext false)
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i1 [ %call6, %if.end ], [ false, %entry ]
  ret void
}

declare i32 @__dynamic_pr_debug(%struct._ddebug*, i8*, ...) #2

declare void @__might_sleep(i8*, i32, i32) #2

declare zeroext i1 @__refrigerator(i1 zeroext) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_tsk_thread_flag(%struct.task_struct* %tsk, i32 %flag) #1 {
entry:
  %stack = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i32 0, i32 1
  %0 = load i8*, i8** %stack, align 8, !tbaa !252
  %1 = bitcast i8* %0 to %struct.thread_info*
  %call = call i32 @test_ti_thread_flag(%struct.thread_info* %1, i32 %flag)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_ti_thread_flag(%struct.thread_info* %ti, i32 %flag) #1 {
entry:
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i32 0, i32 2
  %0 = bitcast i32* %flags to i64*
  %call = call i32 @variable_test_bit(i32 %flag, i64* %0)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @variable_test_bit(i32 %nr, i64* %addr) #1 {
entry:
  %0 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr) #8, !srcloc !253
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read(%union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !90
  ret i32 %0
}

declare zeroext i1 @freezing_slow_path(%struct.task_struct*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init(%struct.list_head* %entry1) #1 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD.28(%struct.list_head* %entry1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_get(%struct.arch_spinlock* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_add_return(i32 1, %union.anon.5* %refcount)
  %cmp = icmp slt i32 %call, 2
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  %0 = load i8, i8* @kref_get.__warned, align 1, !tbaa !43, !range !44
  %tobool7 = trunc i8 %0 to i1
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %tobool14 = icmp ne i32 %lnot.ext13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.10.486, i32 0, i32 0), i32 47)
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then
  %tobool23 = icmp ne i32 %lnot.ext13, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end
  store i8 1, i8* @kref_get.__warned, align 1, !tbaa !43
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_quiesce(%struct.usb_hub* %hub, i32 %type) #0 {
entry:
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !152
  %init_work = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 21
  %call = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* %init_work)
  %quiescing = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %bf.load = load i8, i8* %quiescing, align 4
  %bf.clear = and i8 %bf.load, -3
  %bf.set = or i8 %bf.clear, 2
  store i8 %bf.set, i8* %quiescing, align 4
  %cmp = icmp ne i32 %type, 2
  br i1 %cmp, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.inc ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %1 = load i32, i32* %maxchild, align 8, !tbaa !97
  %cmp2 = icmp slt i32 %i.0, %1
  br i1 %cmp2, label %for.body, label %if.end8

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  %2 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %2, i64 %idxprom
  %3 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %3, i32 0, i32 0
  %4 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_device* %4, null
  br i1 %tobool, label %if.then3, label %for.inc

if.then3:                                         ; preds = %for.body
  %ports4 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  %5 = load %struct.usb_port**, %struct.usb_port*** %ports4, align 8, !tbaa !98
  %idxprom5 = sext i32 %i.0 to i64
  %arrayidx6 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %5, i64 %idxprom5
  %6 = load %struct.usb_port*, %struct.usb_port** %arrayidx6, align 8, !tbaa !48
  %child7 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %6, i32 0, i32 0
  call void @usb_disconnect(%struct.usb_device** %child7)
  br label %for.inc

for.inc:                                          ; preds = %if.then3, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end8:                                          ; preds = %for.cond, %entry
  %urb = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 3
  %7 = load %struct.urb*, %struct.urb** %urb, align 8, !tbaa !254
  call void bitcast (void (%struct.urb.824*)* @usb_kill_urb to void (%struct.urb*)*)(%struct.urb* %7)
  %has_indicators = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %bf.load9 = load i8, i8* %has_indicators, align 4
  %bf.lshr = lshr i8 %bf.load9, 4
  %bf.clear10 = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear10 to i32
  %tobool11 = icmp ne i32 %bf.cast, 0
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end8
  %leds = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  %call13 = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* %leds)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end8
  %tt = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %hub15 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt, i32 0, i32 0
  %8 = load %struct.usb_device*, %struct.usb_device** %hub15, align 8, !tbaa !158
  %tobool16 = icmp ne %struct.usb_device* %8, null
  br i1 %tobool16, label %if.then17, label %if.end20

if.then17:                                        ; preds = %if.end14
  %tt18 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %clear_work = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt18, i32 0, i32 5
  %call19 = call zeroext i1 @flush_work(%struct.work_struct* %clear_work)
  br label %if.end20

if.end20:                                         ; preds = %if.then17, %if.end14
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_and_clear_bit(i32 %nr, i64* %addr) #1 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #8, !srcloc !255
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_handle_remote_wakeup(%struct.usb_hub* %hub, i32 %port, i16 zeroext %portstatus, i16 zeroext %portchange) #0 {
entry:
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !152
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  %1 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %sub = sub i32 %port, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %1, i64 %idxprom
  %2 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %2, i32 0, i32 0
  %3 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !102
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %conv = zext i16 %portchange to i32
  %and = and i32 %conv, 4
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.end, label %cleanup

if.end:                                           ; preds = %if.then
  %call4 = call i32 @usb_clear_port_feature(%struct.usb_device* %0, i32 %port, i32 18)
  br label %if.end14

if.else:                                          ; preds = %entry
  %tobool5 = icmp ne %struct.usb_device* %3, null
  br i1 %tobool5, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.else
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 3
  %4 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp ne i32 %4, 8
  br i1 %cmp, label %cleanup, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %lor.lhs.false
  %conv8 = zext i16 %portstatus to i32
  %and9 = and i32 %conv8, 480
  %cmp10 = icmp ne i32 %and9, 0
  br i1 %cmp10, label %cleanup, label %if.end14

if.end14:                                         ; preds = %lor.lhs.false7, %if.end
  %tobool15 = icmp ne %struct.usb_device* %3, null
  br i1 %tobool15, label %if.then16, label %if.else23

if.then16:                                        ; preds = %if.end14
  call void @msleep(i32 10)
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 11
  call void @device_lock(%struct.device* %dev)
  %call17 = call i32 @usb_remote_wakeup(%struct.usb_device* %3)
  %dev18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev18)
  %cmp19 = icmp slt i32 %call17, 0
  %. = select i1 %cmp19, i32 1, i32 0
  br label %do.body26

if.else23:                                        ; preds = %if.end14
  call void @hub_port_disable(%struct.usb_hub* %hub, i32 %port, i32 1)
  br label %do.body26

do.body26:                                        ; preds = %if.else23, %if.then16
  %connect_change.1 = phi i32 [ %., %if.then16 ], [ 0, %if.else23 ]
  %ret.0 = phi i32 [ %call17, %if.then16 ], [ -19, %if.else23 ]
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_handle_remote_wakeup.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and27 = and i32 %bf.clear, 1
  %tobool28 = icmp ne i32 %and27, 0
  %lnot = xor i1 %tobool28, true
  %lnot29 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot29 to i32
  %conv30 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv30, i64 0)
  %tobool31 = icmp ne i64 %expval, 0
  br i1 %tobool31, label %if.then32, label %cleanup

if.then32:                                        ; preds = %do.body26
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %5 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !173
  %call33 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_handle_remote_wakeup.descriptor to %struct._ddebug*), %struct.device* %5, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.209, i32 0, i32 0), i32 %port, i32 %ret.0)
  br label %cleanup

cleanup:                                          ; preds = %if.then32, %do.body26, %lor.lhs.false7, %lor.lhs.false, %if.else, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ 0, %lor.lhs.false7 ], [ 0, %lor.lhs.false ], [ 0, %if.else ], [ %connect_change.1, %if.then32 ], [ %connect_change.1, %do.body26 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_power_on(%struct.usb_hub* %hub, i1 zeroext %do_delay) #0 {
entry:
  %_max1 = alloca i32, align 4
  %_max2 = alloca i32, align 4
  %frombool = zext i1 %do_delay to i8
  %descriptor = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %0 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !204
  %bPwrOn2PwrGood = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %0, i32 0, i32 4
  %1 = load i8, i8* %bPwrOn2PwrGood, align 1, !tbaa !256
  %conv = zext i8 %1 to i32
  %mul = mul nsw i32 %conv, 2
  %descriptor1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %2 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor1, align 8, !tbaa !204
  %wHubCharacteristics2 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %2, i32 0, i32 3
  %3 = load i16, i16* %wHubCharacteristics2, align 1, !tbaa !225
  %conv3 = zext i16 %3 to i32
  %and = and i32 %conv3, 3
  %cmp = icmp slt i32 %and, 2
  br i1 %cmp, label %do.body5, label %do.body14

do.body5:                                         ; preds = %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_power_on.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and6 = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and6, 0
  %lnot = xor i1 %tobool, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv8 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %if.end35

if.then10:                                        ; preds = %do.body5
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %4 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !173
  %call = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_power_on.descriptor to %struct._ddebug*), %struct.device* %4, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.177, i32 0, i32 0))
  br label %if.end35

do.body14:                                        ; preds = %entry
  %bf.load15 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_power_on.descriptor.178 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr16 = lshr i32 %bf.load15, 18
  %bf.clear17 = and i32 %bf.lshr16, 255
  %and18 = and i32 %bf.clear17, 1
  %tobool19 = icmp ne i32 %and18, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %expval25 = call i64 @llvm.expect.i64(i64 %conv24, i64 0)
  %tobool26 = icmp ne i64 %expval25, 0
  br i1 %tobool26, label %if.then27, label %if.end35

if.then27:                                        ; preds = %do.body14
  %intfdev28 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %5 = load %struct.device*, %struct.device** %intfdev28, align 8, !tbaa !173
  %call29 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_power_on.descriptor.178 to %struct._ddebug*), %struct.device* %5, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.179, i32 0, i32 0))
  br label %if.end35

if.end35:                                         ; preds = %if.then27, %do.body14, %if.then10, %do.body5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end35
  %port1.0 = phi i32 [ 1, %if.end35 ], [ %inc, %for.inc ]
  %descriptor36 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %6 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor36, align 8, !tbaa !204
  %bNbrPorts = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %6, i32 0, i32 2
  %7 = load i8, i8* %bNbrPorts, align 1, !tbaa !250
  %conv37 = zext i8 %7 to i32
  %cmp38 = icmp sle i32 %port1.0, %conv37
  br i1 %cmp38, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  %8 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %sub = sub nsw i32 %port1.0, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %8, i64 %idxprom
  %9 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %power_is_on = getelementptr inbounds %struct.usb_port, %struct.usb_port* %9, i32 0, i32 5
  %bf.load40 = load i8, i8* %power_is_on, align 1
  %bf.clear41 = and i8 %bf.load40, 1
  %bf.cast = zext i8 %bf.clear41 to i32
  %tobool42 = icmp ne i32 %bf.cast, 0
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  br i1 %tobool42, label %if.then43, label %if.else45

if.then43:                                        ; preds = %for.body
  %call44 = call i32 @set_port_feature(%struct.usb_device* %10, i32 %port1.0, i32 8)
  br label %for.inc

if.else45:                                        ; preds = %for.body
  %call47 = call i32 @usb_clear_port_feature(%struct.usb_device* %10, i32 %port1.0, i32 8)
  br label %for.inc

for.inc:                                          ; preds = %if.else45, %if.then43
  %inc = add nsw i32 %port1.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = bitcast i32* %_max1 to i8*
  store i32 %mul, i32* %_max1, align 4, !tbaa !90
  %12 = bitcast i32* %_max2 to i8*
  store i32 100, i32* %_max2, align 4, !tbaa !90
  %13 = load i32, i32* %_max1, align 4, !tbaa !90
  %14 = load i32, i32* %_max2, align 4, !tbaa !90
  %cmp51 = icmp ugt i32 %13, %14
  %15 = load i32, i32* %_max1, align 4
  %16 = load i32, i32* %_max2, align 4
  %cond = select i1 %cmp51, i32 %15, i32 %16
  %17 = bitcast i32* %_max2 to i8*
  %18 = bitcast i32* %_max1 to i8*
  %tobool53 = trunc i8 %frombool to i1
  br i1 %tobool53, label %if.then54, label %if.end55

if.then54:                                        ; preds = %for.end
  call void @msleep(i32 %cond)
  br label %if.end55

if.end55:                                         ; preds = %if.then54, %for.end
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define internal void @hub_port_connect_change(%struct.usb_hub* %hub, i32 %port1, i16 zeroext %portstatus, i16 zeroext %portchange) #0 {
entry:
  %devstat = alloca i16, align 2
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !152
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %1 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !173
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.11(%struct.usb_bus* %2)
  %descriptor = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %3 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !204
  %wHubCharacteristics2 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %3, i32 0, i32 3
  %4 = load i16, i16* %wHubCharacteristics2, align 1, !tbaa !225
  %conv = zext i16 %4 to i32
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_connect_change.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv5, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %do.end13

if.then:                                          ; preds = %entry
  %conv7 = zext i16 %portstatus to i32
  %conv8 = zext i16 %portchange to i32
  %conv9 = zext i16 %portstatus to i32
  %call10 = call i8* @portspeed(%struct.usb_hub* %hub, i32 %conv9)
  %call11 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_connect_change.descriptor to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.220, i32 0, i32 0), i32 %port1, i32 %conv7, i32 %conv8, i8* %call10)
  br label %do.end13

do.end13:                                         ; preds = %if.then, %entry
  %has_indicators = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %bf.load14 = load i8, i8* %has_indicators, align 4
  %bf.lshr15 = lshr i8 %bf.load14, 4
  %bf.clear16 = and i8 %bf.lshr15, 1
  %bf.cast = zext i8 %bf.clear16 to i32
  %tobool17 = icmp ne i32 %bf.cast, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %do.end13
  call void @set_port_led(%struct.usb_hub* %hub, i32 %port1, i32 0)
  %indicator = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 19
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [31 x i8], [31 x i8]* %indicator, i64 0, i64 %idxprom
  store i8 0, i8* %arrayidx, align 1, !tbaa !84
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %do.end13
  %bus20 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %5 = load %struct.usb_bus*, %struct.usb_bus** %bus20, align 8, !tbaa !2
  %is_b_host = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %5, i32 0, i32 6
  %bf.load21 = load i8, i8* %is_b_host, align 1
  %bf.clear22 = and i8 %bf.load21, 1
  %bf.cast23 = zext i8 %bf.clear22 to i32
  %tobool24 = icmp ne i32 %bf.cast23, 0
  %conv26 = zext i16 %portchange to i32
  %and27 = and i32 %conv26, -4
  %conv28 = trunc i32 %and27 to i16
  %portchange.addr.0 = select i1 %tobool24, i16 %conv28, i16 %portchange
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  %6 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %sub30 = sub nsw i32 %port1, 1
  %idxprom31 = sext i32 %sub30 to i64
  %arrayidx32 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %6, i64 %idxprom31
  %7 = load %struct.usb_port*, %struct.usb_port** %arrayidx32, align 8, !tbaa !48
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %7, i32 0, i32 0
  %8 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !102
  %conv33 = zext i16 %portstatus to i32
  %and34 = and i32 %conv33, 1
  %tobool35 = icmp ne i32 %and34, 0
  %tobool36 = icmp ne %struct.usb_device* %8, null
  %or.cond = and i1 %tobool35, %tobool36
  br i1 %or.cond, label %land.lhs.true37, label %if.end63

land.lhs.true37:                                  ; preds = %if.end19
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 3
  %9 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp ne i32 %9, 0
  br i1 %cmp, label %if.then39, label %if.end63

if.then39:                                        ; preds = %land.lhs.true37
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 11
  call void @device_lock(%struct.device* %dev)
  %conv40 = zext i16 %portstatus to i32
  %and41 = and i32 %conv40, 2
  %tobool42 = icmp ne i32 %and41, 0
  br i1 %tobool42, label %if.end57, label %if.else

if.else:                                          ; preds = %if.then39
  %state44 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 3
  %10 = load i32, i32* %state44, align 8, !tbaa !50
  %cmp45 = icmp eq i32 %10, 8
  br i1 %cmp45, label %land.lhs.true47, label %if.end57

land.lhs.true47:                                  ; preds = %if.else
  %persist_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 22
  %bf.load48 = load i16, i16* %persist_enabled, align 4
  %bf.lshr49 = lshr i16 %bf.load48, 1
  %bf.clear50 = and i16 %bf.lshr49, 1
  %bf.cast51 = zext i16 %bf.clear50 to i32
  %tobool52 = icmp ne i32 %bf.cast51, 0
  br i1 %tobool52, label %if.then53, label %if.end57

if.then53:                                        ; preds = %land.lhs.true47
  %call54 = call i32 @usb_remote_wakeup(%struct.usb_device* %8)
  br label %if.end57

if.end57:                                         ; preds = %if.then53, %land.lhs.true47, %if.else, %if.then39
  %status.1 = phi i32 [ 0, %if.then39 ], [ %call54, %if.then53 ], [ -19, %land.lhs.true47 ], [ -19, %if.else ]
  %dev58 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev58)
  %cmp59 = icmp eq i32 %status.1, 0
  br i1 %cmp59, label %if.then61, label %if.end63

if.then61:                                        ; preds = %if.end57
  %change_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 11
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i32 %port1, i64* %arraydecay) #8, !srcloc !145
  br label %cleanup.cont365

if.end63:                                         ; preds = %if.end57, %land.lhs.true37, %if.end19
  %tobool64 = icmp ne %struct.usb_device* %8, null
  br i1 %tobool64, label %if.then65, label %if.end82

if.then65:                                        ; preds = %if.end63
  %phy = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 9
  %11 = load %struct.usb_phy*, %struct.usb_phy** %phy, align 8, !tbaa !163
  %tobool66 = icmp ne %struct.usb_phy* %11, null
  br i1 %tobool66, label %land.lhs.true67, label %if.end76

land.lhs.true67:                                  ; preds = %if.then65
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  %12 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool68 = icmp ne %struct.usb_device* %12, null
  br i1 %tobool68, label %if.end76, label %land.lhs.true69

land.lhs.true69:                                  ; preds = %land.lhs.true67
  %conv70 = zext i16 %portstatus to i32
  %and71 = and i32 %conv70, 1
  %tobool72 = icmp ne i32 %and71, 0
  br i1 %tobool72, label %if.end76, label %if.then73

if.then73:                                        ; preds = %land.lhs.true69
  %phy74 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 9
  %13 = load %struct.usb_phy*, %struct.usb_phy** %phy74, align 8, !tbaa !163
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 4
  %14 = load i32, i32* %speed, align 4, !tbaa !153
  call void @usb_phy_notify_disconnect(%struct.usb_phy* %13, i32 %14)
  br label %if.end76

if.end76:                                         ; preds = %if.then73, %land.lhs.true69, %land.lhs.true67, %if.then65
  %ports77 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  %15 = load %struct.usb_port**, %struct.usb_port*** %ports77, align 8, !tbaa !98
  %sub78 = sub nsw i32 %port1, 1
  %idxprom79 = sext i32 %sub78 to i64
  %arrayidx80 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %15, i64 %idxprom79
  %16 = load %struct.usb_port*, %struct.usb_port** %arrayidx80, align 8, !tbaa !48
  %child81 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %16, i32 0, i32 0
  call void @usb_disconnect(%struct.usb_device** %child81)
  br label %if.end82

if.end82:                                         ; preds = %if.end76, %if.end63
  %change_bits83 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 11
  %arraydecay84 = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits83, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay84, i32 %port1, i64* %arraydecay84) #8, !srcloc !145
  %conv85 = zext i16 %portstatus to i32
  %and86 = and i32 %conv85, 1
  %tobool87 = icmp ne i32 %and86, 0
  br i1 %tobool87, label %lor.lhs.false, label %if.then91

lor.lhs.false:                                    ; preds = %if.end82
  %conv88 = zext i16 %portchange.addr.0 to i32
  %and89 = and i32 %conv88, 1
  %tobool90 = icmp ne i32 %and89, 0
  br i1 %tobool90, label %if.then91, label %if.end93

if.then91:                                        ; preds = %lor.lhs.false, %if.end82
  %removed_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 13
  %arraydecay92 = getelementptr inbounds [1 x i64], [1 x i64]* %removed_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay92, i32 %port1, i64* %arraydecay92) #8, !srcloc !145
  br label %if.end93

if.end93:                                         ; preds = %if.then91, %lor.lhs.false
  %conv94 = zext i16 %portchange.addr.0 to i32
  %and95 = and i32 %conv94, 3
  %tobool96 = icmp ne i32 %and95, 0
  br i1 %tobool96, label %if.then97, label %if.end116

if.then97:                                        ; preds = %if.end93
  %call98 = call i32 @hub_port_debounce_be_stable(%struct.usb_hub* %hub, i32 %port1)
  %cmp99 = icmp slt i32 %call98, 0
  br i1 %cmp99, label %if.then101, label %if.end115

if.then101:                                       ; preds = %if.then97
  %cmp102 = icmp ne i32 %call98, -19
  br i1 %cmp102, label %land.lhs.true104, label %if.end109

land.lhs.true104:                                 ; preds = %if.then101
  %call105 = call i32 @__printk_ratelimit(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.hub_port_connect_change, i32 0, i32 0))
  %tobool106 = icmp ne i32 %call105, 0
  br i1 %tobool106, label %if.then107, label %if.end109

if.then107:                                       ; preds = %land.lhs.true104
  %17 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end109

if.end109:                                        ; preds = %if.then107, %land.lhs.true104, %if.then101
  %conv110 = zext i16 %portstatus to i32
  %and111 = and i32 %conv110, -2
  br label %if.end115

if.end115:                                        ; preds = %if.end109, %if.then97
  %call98.sink = phi i32 [ %and111, %if.end109 ], [ %call98, %if.then97 ]
  %conv114 = trunc i32 %call98.sink to i16
  br label %if.end116

if.end116:                                        ; preds = %if.end115, %if.end93
  %portstatus.addr.1 = phi i16 [ %conv114, %if.end115 ], [ %portstatus, %if.end93 ]
  %conv117 = zext i16 %portstatus.addr.1 to i32
  %and118 = and i32 %conv117, 1
  %tobool119 = icmp ne i32 %and118, 0
  br i1 %tobool119, label %cond.false, label %if.then129

cond.false:                                       ; preds = %if.end116
  %removed_bits125 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 13
  %arraydecay126 = getelementptr inbounds [1 x i64], [1 x i64]* %removed_bits125, i32 0, i32 0
  %call127 = call i32 @variable_test_bit(i32 %port1, i64* %arraydecay126)
  %tobool128 = icmp ne i32 %call127, 0
  br i1 %tobool128, label %if.then129, label %if.end145

if.then129:                                       ; preds = %cond.false, %if.end116
  %and130 = and i32 %conv, 3
  %cmp131 = icmp ult i32 %and130, 2
  br i1 %cmp131, label %land.lhs.true133, label %if.end139

land.lhs.true133:                                 ; preds = %if.then129
  %conv134 = zext i16 %portstatus.addr.1 to i32
  %call135 = call i32 @port_is_power_on(%struct.usb_hub* %hub, i32 %conv134)
  %tobool136 = icmp ne i32 %call135, 0
  br i1 %tobool136, label %if.end139, label %if.then137

if.then137:                                       ; preds = %land.lhs.true133
  %call138 = call i32 @set_port_feature(%struct.usb_device* %0, i32 %port1, i32 8)
  br label %if.end139

if.end139:                                        ; preds = %if.then137, %land.lhs.true133, %if.then129
  %conv140 = zext i16 %portstatus.addr.1 to i32
  %and141 = and i32 %conv140, 2
  %tobool142 = icmp ne i32 %and141, 0
  br i1 %tobool142, label %done, label %cleanup.cont365

if.end145:                                        ; preds = %cond.false
  %hdev146 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %18 = load %struct.usb_device*, %struct.usb_device** %hdev146, align 8, !tbaa !152
  %call147 = call i32 @hub_is_superspeed(%struct.usb_device* %18)
  %tobool148 = icmp ne i32 %call147, 0
  %. = select i1 %tobool148, i32 150, i32 100
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end145
  %status.2 = phi i32 [ 0, %if.end145 ], [ %status.7, %for.inc ]
  %i.0 = phi i32 [ 0, %if.end145 ], [ %inc, %for.inc ]
  %19 = load i8, i8* @use_both_schemes, align 1, !tbaa !43, !range !44
  %tobool152 = trunc i8 %19 to i1
  %conv153 = zext i1 %tobool152 to i32
  %add = add nsw i32 %conv153, 1
  %mul = mul nsw i32 2, %add
  %cmp154 = icmp slt i32 %i.0, %mul
  br i1 %cmp154, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %bus156 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %20 = load %struct.usb_bus*, %struct.usb_bus** %bus156, align 8, !tbaa !2
  %call157 = call %struct.usb_device* @usb_alloc_dev(%struct.usb_device* %0, %struct.usb_bus* %20, i32 %port1)
  %tobool158 = icmp ne %struct.usb_device* %call157, null
  br i1 %tobool158, label %if.end161, label %if.then159

if.then159:                                       ; preds = %for.body
  %21 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %done

if.end161:                                        ; preds = %for.body
  call void @usb_set_device_state(%struct.usb_device* %call157, i32 2)
  %mA_per_port = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %22 = load i32, i32* %mA_per_port, align 8, !tbaa !257
  %conv162 = trunc i32 %22 to i16
  %bus_mA = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call157, i32 0, i32 19
  store i16 %conv162, i16* %bus_mA, align 8, !tbaa !258
  %level = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 21
  %23 = load i8, i8* %level, align 1, !tbaa !87
  %conv163 = zext i8 %23 to i32
  %add164 = add nsw i32 %conv163, 1
  %conv165 = trunc i32 %add164 to i8
  %level166 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call157, i32 0, i32 21
  store i8 %conv165, i8* %level166, align 1, !tbaa !87
  %call167 = call i32 @hub_is_wusb(%struct.usb_hub* %hub)
  %wusb = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call157, i32 0, i32 22
  %24 = trunc i32 %call167 to i16
  %bf.load168 = load i16, i16* %wusb, align 4
  %bf.value = and i16 %24, 1
  %bf.shl = shl i16 %bf.value, 5
  %bf.clear169 = and i16 %bf.load168, -33
  %bf.set = or i16 %bf.clear169, %bf.shl
  store i16 %bf.set, i16* %wusb, align 4
  %hdev170 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %25 = load %struct.usb_device*, %struct.usb_device** %hdev170, align 8, !tbaa !152
  %call171 = call i32 @hub_is_superspeed(%struct.usb_device* %25)
  %tobool172 = icmp ne i32 %call171, 0
  %speed174 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call157, i32 0, i32 4
  %.sink = select i1 %tobool172, i32 5, i32 0
  store i32 %.sink, i32* %speed174, align 4, !tbaa !153
  call void @choose_devnum(%struct.usb_device* %call157)
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call157, i32 0, i32 0
  %26 = load i32, i32* %devnum, align 8, !tbaa !38
  %cmp178 = icmp sle i32 %26, 0
  br i1 %cmp178, label %loop, label %if.end181

if.end181:                                        ; preds = %if.end161
  %call182 = call i32 @hub_port_init(%struct.usb_hub* %hub, %struct.usb_device* %call157, i32 %port1, i32 %i.0)
  %cmp183 = icmp slt i32 %call182, 0
  br i1 %cmp183, label %loop, label %if.end186

if.end186:                                        ; preds = %if.end181
  call void @usb_detect_quirks(%struct.usb_device* %call157)
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call157, i32 0, i32 29
  %27 = load i32, i32* %quirks, align 4, !tbaa !259
  %and187 = and i32 %27, 64
  %tobool188 = icmp ne i32 %and187, 0
  br i1 %tobool188, label %if.then189, label %if.end190

if.then189:                                       ; preds = %if.end186
  call void @msleep(i32 1000)
  br label %if.end190

if.end190:                                        ; preds = %if.then189, %if.end186
  %descriptor191 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call157, i32 0, i32 12
  %bDeviceClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor191, i32 0, i32 3
  %28 = load i8, i8* %bDeviceClass, align 4, !tbaa !241
  %conv192 = zext i8 %28 to i32
  %cmp193 = icmp eq i32 %conv192, 9
  br i1 %cmp193, label %land.lhs.true195, label %if.end252

land.lhs.true195:                                 ; preds = %if.end190
  %bus_mA196 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call157, i32 0, i32 19
  %29 = load i16, i16* %bus_mA196, align 8, !tbaa !258
  %conv197 = zext i16 %29 to i32
  %cmp198 = icmp ule i32 %conv197, %.
  br i1 %cmp198, label %if.then200, label %if.end252

if.then200:                                       ; preds = %land.lhs.true195
  %30 = bitcast i16* %devstat to i8*
  %31 = bitcast i16* %devstat to i8*
  %call201 = call i32 @usb_get_status(%struct.usb_device* %call157, i32 0, i32 0, i8* %31)
  %cmp202 = icmp slt i32 %call201, 2
  br i1 %cmp202, label %do.body206, label %do.end230

do.body206:                                       ; preds = %if.then200
  %bf.load207 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_connect_change.descriptor.223 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr208 = lshr i32 %bf.load207, 18
  %bf.clear209 = and i32 %bf.lshr208, 255
  %and210 = and i32 %bf.clear209, 1
  %tobool211 = icmp ne i32 %and210, 0
  %lnot212 = xor i1 %tobool211, true
  %lnot214 = xor i1 %lnot212, true
  %lnot.ext215 = zext i1 %lnot214 to i32
  %conv216 = sext i32 %lnot.ext215 to i64
  %expval217 = call i64 @llvm.expect.i64(i64 %conv216, i64 0)
  %tobool218 = icmp ne i64 %expval217, 0
  br i1 %tobool218, label %if.then219, label %cleanup

if.then219:                                       ; preds = %do.body206
  %dev220 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call157, i32 0, i32 11
  %call221 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_connect_change.descriptor.223 to %struct._ddebug*), %struct.device* %dev220, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.224, i32 0, i32 0), i32 %call201)
  br label %cleanup

do.end230:                                        ; preds = %if.then200
  %32 = load i16, i16* %devstat, align 2, !tbaa !143
  %conv231 = zext i16 %32 to i32
  %and232 = and i32 %conv231, 1
  %cmp233 = icmp eq i32 %and232, 0
  br i1 %cmp233, label %if.then235, label %cleanup

if.then235:                                       ; preds = %do.end230
  %33 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %has_indicators238 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %bf.load239 = load i8, i8* %has_indicators238, align 4
  %bf.lshr240 = lshr i8 %bf.load239, 4
  %bf.clear241 = and i8 %bf.lshr240, 1
  %bf.cast242 = zext i8 %bf.clear241 to i32
  %tobool243 = icmp ne i32 %bf.cast242, 0
  br i1 %tobool243, label %if.then244, label %cleanup

if.then244:                                       ; preds = %if.then235
  %indicator245 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 19
  %sub246 = sub nsw i32 %port1, 1
  %idxprom247 = sext i32 %sub246 to i64
  %arrayidx248 = getelementptr inbounds [31 x i8], [31 x i8]* %indicator245, i64 0, i64 %idxprom247
  store i8 4, i8* %arrayidx248, align 1, !tbaa !84
  %leds = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  call void @schedule_delayed_work(%struct.delayed_work* %leds, i64 0)
  br label %cleanup

cleanup:                                          ; preds = %if.then244, %if.then235, %do.end230, %if.then219, %do.body206
  %status.3 = phi i32 [ %call201, %if.then219 ], [ %call201, %do.body206 ], [ -107, %if.then244 ], [ -107, %if.then235 ], [ %call201, %do.end230 ]
  %cleanup.dest.slot.0 = phi i32 [ 15, %if.then219 ], [ 15, %do.body206 ], [ 15, %if.then244 ], [ 15, %if.then235 ], [ 0, %do.end230 ]
  %34 = bitcast i16* %devstat to i8*
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 15
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %cleanup
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 15
  br i1 %SwitchLeaf2, label %loop_disable, label %cleanup.cont365

LeafBlock:                                        ; preds = %cleanup
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end252, label %cleanup.cont365

if.end252:                                        ; preds = %LeafBlock, %land.lhs.true195, %if.end190
  %descriptor253 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call157, i32 0, i32 12
  %bcdUSB = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor253, i32 0, i32 2
  %35 = load i16, i16* %bcdUSB, align 2, !tbaa !164
  %conv254 = zext i16 %35 to i32
  %cmp255 = icmp sge i32 %conv254, 512
  br i1 %cmp255, label %land.lhs.true257, label %if.end265

land.lhs.true257:                                 ; preds = %if.end252
  %speed258 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call157, i32 0, i32 4
  %36 = load i32, i32* %speed258, align 4, !tbaa !153
  %cmp259 = icmp eq i32 %36, 2
  %37 = load i32, i32* @highspeed_hubs, align 4
  %cmp262 = icmp ne i32 %37, 0
  %or.cond3 = and i1 %cmp259, %cmp262
  br i1 %or.cond3, label %if.then264, label %if.end265

if.then264:                                       ; preds = %land.lhs.true257
  call void @check_highspeed(%struct.usb_hub* %hub, %struct.usb_device* %call157, i32 %port1)
  br label %if.end265

if.end265:                                        ; preds = %if.then264, %land.lhs.true257, %if.end252
  call void @spin_lock_irq(%struct.spinlock* @device_state_lock)
  %state266 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 3
  %38 = load i32, i32* %state266, align 8, !tbaa !50
  %cmp267 = icmp eq i32 %38, 0
  br i1 %cmp267, label %if.end276, label %if.else270

if.else270:                                       ; preds = %if.end265
  %ports271 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  %39 = load %struct.usb_port**, %struct.usb_port*** %ports271, align 8, !tbaa !98
  %sub272 = sub nsw i32 %port1, 1
  %idxprom273 = sext i32 %sub272 to i64
  %arrayidx274 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %39, i64 %idxprom273
  %40 = load %struct.usb_port*, %struct.usb_port** %arrayidx274, align 8, !tbaa !48
  %child275 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %40, i32 0, i32 0
  store %struct.usb_device* %call157, %struct.usb_device** %child275, align 8, !tbaa !102
  br label %if.end276

if.end276:                                        ; preds = %if.else270, %if.end265
  %status.4 = phi i32 [ 0, %if.else270 ], [ -107, %if.end265 ]
  call void @spin_unlock_irq(%struct.spinlock* @device_state_lock)
  %tobool277 = icmp ne i32 %status.4, 0
  br i1 %tobool277, label %if.end288, label %if.then278

if.then278:                                       ; preds = %if.end276
  %call279 = call i32 @usb_new_device(%struct.usb_device* %call157)
  %tobool280 = icmp ne i32 %call279, 0
  br i1 %tobool280, label %if.then281, label %if.end288

if.then281:                                       ; preds = %if.then278
  call void @spin_lock_irq(%struct.spinlock* @device_state_lock)
  %ports282 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  %41 = load %struct.usb_port**, %struct.usb_port*** %ports282, align 8, !tbaa !98
  %sub283 = sub nsw i32 %port1, 1
  %idxprom284 = sext i32 %sub283 to i64
  %arrayidx285 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %41, i64 %idxprom284
  %42 = load %struct.usb_port*, %struct.usb_port** %arrayidx285, align 8, !tbaa !48
  %child286 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %42, i32 0, i32 0
  store %struct.usb_device* null, %struct.usb_device** %child286, align 8, !tbaa !102
  call void @spin_unlock_irq(%struct.spinlock* @device_state_lock)
  br label %if.end288

if.end288:                                        ; preds = %if.then281, %if.then278, %if.end276
  %status.5 = phi i32 [ %status.4, %if.end276 ], [ %call279, %if.then281 ], [ %call279, %if.then278 ]
  %tobool289 = icmp ne i32 %status.5, 0
  br i1 %tobool289, label %loop_disable, label %if.end291

if.end291:                                        ; preds = %if.end288
  %call292 = call i32 @hub_power_remaining(%struct.usb_hub* %hub)
  %tobool293 = icmp ne i32 %call292, 0
  br i1 %tobool293, label %do.body296, label %cleanup.cont365

do.body296:                                       ; preds = %if.end291
  %bf.load297 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_connect_change.descriptor.226 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr298 = lshr i32 %bf.load297, 18
  %bf.clear299 = and i32 %bf.lshr298, 255
  %and300 = and i32 %bf.clear299, 1
  %tobool301 = icmp ne i32 %and300, 0
  %lnot302 = xor i1 %tobool301, true
  %lnot304 = xor i1 %lnot302, true
  %lnot.ext305 = zext i1 %lnot304 to i32
  %conv306 = sext i32 %lnot.ext305 to i64
  %expval307 = call i64 @llvm.expect.i64(i64 %conv306, i64 0)
  %tobool308 = icmp ne i64 %expval307, 0
  br i1 %tobool308, label %if.then309, label %cleanup.cont365

if.then309:                                       ; preds = %do.body296
  %call310 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_port_connect_change.descriptor.226 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.227, i32 0, i32 0), i32 %call292)
  br label %cleanup.cont365

loop_disable:                                     ; preds = %if.end288, %LeafBlock1
  %status.6 = phi i32 [ %status.3, %LeafBlock1 ], [ %status.5, %if.end288 ]
  call void @hub_port_disable(%struct.usb_hub* %hub, i32 %port1, i32 1)
  br label %loop

loop:                                             ; preds = %loop_disable, %if.end181, %if.end161
  %status.7 = phi i32 [ %status.6, %loop_disable ], [ -107, %if.end161 ], [ %call182, %if.end181 ]
  call void @usb_ep0_reinit(%struct.usb_device* %call157)
  call void @release_devnum(%struct.usb_device* %call157)
  call void @hub_free_dev(%struct.usb_device* %call157)
  call void @usb_put_dev(%struct.usb_device* %call157)
  switch i32 %status.7, label %for.inc [
    i32 -107, label %for.end
    i32 -524, label %for.end
  ]

for.inc:                                          ; preds = %loop
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %loop, %loop, %for.cond
  %status.8 = phi i32 [ %status.7, %loop ], [ %status.7, %loop ], [ %status.2, %for.cond ]
  %hdev325 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %43 = load %struct.usb_device*, %struct.usb_device** %hdev325, align 8, !tbaa !152
  %parent326 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %43, i32 0, i32 8
  %44 = load %struct.usb_device*, %struct.usb_device** %parent326, align 8, !tbaa !89
  %tobool327 = icmp ne %struct.usb_device* %44, null
  br i1 %tobool327, label %if.then335, label %lor.lhs.false328

lor.lhs.false328:                                 ; preds = %for.end
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %45 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %port_handed_over = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %45, i32 0, i32 24
  %46 = load i32 (%struct.usb_hcd*, i32)*, i32 (%struct.usb_hcd*, i32)** %port_handed_over, align 8, !tbaa !260
  %tobool329 = icmp ne i32 (%struct.usb_hcd*, i32)* %46, null
  br i1 %tobool329, label %lor.lhs.false330, label %if.then335

lor.lhs.false330:                                 ; preds = %lor.lhs.false328
  %driver331 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %47 = load %struct.hc_driver*, %struct.hc_driver** %driver331, align 8, !tbaa !71
  %port_handed_over332 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %47, i32 0, i32 24
  %48 = load i32 (%struct.usb_hcd*, i32)*, i32 (%struct.usb_hcd*, i32)** %port_handed_over332, align 8, !tbaa !260
  %call333 = call i32 %48(%struct.usb_hcd* %call, i32 %port1)
  %tobool334 = icmp ne i32 %call333, 0
  br i1 %tobool334, label %done, label %if.then335

if.then335:                                       ; preds = %lor.lhs.false330, %lor.lhs.false328, %for.end
  switch i32 %status.8, label %if.then341 [
    i32 -107, label %done
    i32 -19, label %done
  ]

if.then341:                                       ; preds = %if.then335
  %49 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %done

done:                                             ; preds = %if.then341, %if.then335, %if.then335, %lor.lhs.false330, %if.then159, %if.end139
  call void @hub_port_disable(%struct.usb_hub* %hub, i32 %port1, i32 1)
  %driver346 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %50 = load %struct.hc_driver*, %struct.hc_driver** %driver346, align 8, !tbaa !71
  %relinquish_port = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %50, i32 0, i32 23
  %51 = load void (%struct.usb_hcd*, i32)*, void (%struct.usb_hcd*, i32)** %relinquish_port, align 8, !tbaa !261
  %tobool347 = icmp ne void (%struct.usb_hcd*, i32)* %51, null
  br i1 %tobool347, label %land.lhs.true348, label %cleanup.cont365

land.lhs.true348:                                 ; preds = %done
  %hdev349 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %52 = load %struct.usb_device*, %struct.usb_device** %hdev349, align 8, !tbaa !152
  %parent350 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %52, i32 0, i32 8
  %53 = load %struct.usb_device*, %struct.usb_device** %parent350, align 8, !tbaa !89
  %tobool351 = icmp ne %struct.usb_device* %53, null
  br i1 %tobool351, label %cleanup.cont365, label %if.then352

if.then352:                                       ; preds = %land.lhs.true348
  %driver353 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %54 = load %struct.hc_driver*, %struct.hc_driver** %driver353, align 8, !tbaa !71
  %relinquish_port354 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %54, i32 0, i32 23
  %55 = load void (%struct.usb_hcd*, i32)*, void (%struct.usb_hcd*, i32)** %relinquish_port354, align 8, !tbaa !261
  call void %55(%struct.usb_hcd* %call, i32 %port1)
  br label %cleanup.cont365

cleanup.cont365:                                  ; preds = %if.then352, %land.lhs.true348, %done, %if.then309, %do.body296, %if.end291, %LeafBlock, %LeafBlock1, %if.end139, %if.then61
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_hub_status(%struct.usb_hub* %hub, i16* %status, i16* %change) #0 {
entry:
  %status_mutex = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 6
  call void @mutex_lock_nested(%struct.mutex* %status_mutex, i32 0)
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %status1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  %1 = load %union.anon.48*, %union.anon.48** %status1, align 8, !tbaa !176
  %hub2 = bitcast %union.anon.48* %1 to %struct.usb_hub_status*
  %call = call i32 @get_hub_status(%struct.usb_device* %0, %struct.usb_hub_status* %hub2)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %cmp3 = icmp ne i32 %call, -19
  br i1 %cmp3, label %if.then4, label %if.end10

if.then4:                                         ; preds = %if.then
  %2 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end10

if.else:                                          ; preds = %entry
  %status6 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  %3 = load %union.anon.48*, %union.anon.48** %status6, align 8, !tbaa !176
  %hub7 = bitcast %union.anon.48* %3 to %struct.usb_hub_status*
  %wHubStatus = getelementptr inbounds %struct.usb_hub_status, %struct.usb_hub_status* %hub7, i32 0, i32 0
  %4 = load i16, i16* %wHubStatus, align 1, !tbaa !84
  store i16 %4, i16* %status, align 2, !tbaa !143
  %status8 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  %5 = load %union.anon.48*, %union.anon.48** %status8, align 8, !tbaa !176
  %hub9 = bitcast %union.anon.48* %5 to %struct.usb_hub_status*
  %wHubChange = getelementptr inbounds %struct.usb_hub_status, %struct.usb_hub_status* %hub9, i32 0, i32 1
  %6 = load i16, i16* %wHubChange, align 1, !tbaa !84
  store i16 %6, i16* %change, align 2, !tbaa !143
  br label %if.end10

if.end10:                                         ; preds = %if.else, %if.then4, %if.then
  %ret.0 = phi i32 [ 0, %if.else ], [ %call, %if.then4 ], [ %call, %if.then ]
  %status_mutex11 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 6
  call void @mutex_unlock(%struct.mutex* %status_mutex11)
  ret i32 %ret.0
}

; Function Attrs: nounwind uwtable
define internal void @clear_hub_feature(%struct.usb_device* %hdev, i32 %feature) #0 {
entry:
  %call = call i32 @__create_pipe(%struct.usb_device* %hdev, i32 0)
  %or = or i32 -2147483648, %call
  %conv = trunc i32 %feature to i16
  %call1 = call i32 @usb_control_msg(%struct.usb_device* %hdev, i32 %or, i8 zeroext 1, i8 zeroext 32, i16 zeroext %conv, i16 zeroext 0, i8* null, i16 zeroext 0, i32 1000)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_release(%struct.arch_spinlock* %kref) #0 {
entry:
  %0 = bitcast %struct.arch_spinlock* %kref to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.usb_hub*
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 0
  %2 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !173
  %3 = bitcast %struct.device* %2 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -48
  %4 = bitcast i8* %add.ptr3 to %struct.usb_interface*
  call void @usb_put_intf(%struct.usb_interface* %4)
  %5 = bitcast %struct.usb_hub* %1 to i8*
  call void @kfree(i8* %5)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* %release) #1 {
entry:
  call void @kref_sub(%struct.arch_spinlock* %kref, i32 1, void (%struct.arch_spinlock*)* %release)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_sub(%struct.arch_spinlock* %kref, i32 %count, void (%struct.arch_spinlock*)* %release) #1 {
entry:
  %cmp = icmp eq void (%struct.arch_spinlock*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.10.486, i32 0, i32 0), i32 71)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_sub_and_test(i32 %count, %union.anon.5* %refcount)
  %tobool14 = icmp ne i32 %call, 0
  br i1 %tobool14, label %if.then15, label %return

if.then15:                                        ; preds = %if.end
  call void %release(%struct.arch_spinlock* %kref)
  br label %return

return:                                           ; preds = %if.then15, %if.end
  %retval.0 = phi i32 [ 1, %if.then15 ], [ 0, %if.end ]
  ret void
}

declare void @warn_slowpath_null(i8*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_sub_and_test(i32 %i, %union.anon.5* %v) #1 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subl $2,$0; sete $1", "=*m,=*qm,ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32 %i, i32* %counter) #8, !srcloc !262
  %0 = load i8, i8* %c, align 1, !tbaa !84
  %conv = zext i8 %0 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @get_hub_status(%struct.usb_device* %hdev, %struct.usb_hub_status* %data) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %status.0 = phi i32 [ -110, %entry ], [ %call4, %for.body ]
  %cmp = icmp slt i32 %i.0, 5
  br i1 %cmp, label %land.rhs, label %for.end

land.rhs:                                         ; preds = %for.cond
  %cmp1 = icmp eq i32 %status.0, -110
  %cmp2 = icmp eq i32 %status.0, -32
  %.cmp2 = select i1 %cmp1, i1 true, i1 %cmp2
  br i1 %.cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %land.rhs
  %call = call i32 @__create_pipe(%struct.usb_device* %hdev, i32 0)
  %or = or i32 -2147483648, %call
  %or3 = or i32 %or, 128
  %0 = bitcast %struct.usb_hub_status* %data to i8*
  %call4 = call i32 @usb_control_msg(%struct.usb_device* %hdev, i32 %or3, i8 zeroext 0, i8 zeroext -96, i16 zeroext 0, i16 zeroext 0, i8* %0, i16 zeroext 4, i32 1000)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %land.rhs, %for.cond
  ret i32 %status.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @portspeed(%struct.usb_hub* %hub, i32 %portstatus) #1 {
entry:
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %and = and i32 %portstatus, 1024
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %return, label %if.else

if.else:                                          ; preds = %if.end
  %and3 = and i32 %portstatus, 512
  %tobool4 = icmp ne i32 %and3, 0
  %. = select i1 %tobool4, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.231, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.232, i32 0, i32 0)
  br label %return

return:                                           ; preds = %if.else, %if.end, %entry
  %retval.0 = phi i8* [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.229, i32 0, i32 0), %entry ], [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.230, i32 0, i32 0), %if.end ], [ %., %if.else ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @set_port_led(%struct.usb_hub* %hub, i32 %port1, i32 %selector) #0 {
entry:
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %shl = shl i32 %selector, 8
  %or = or i32 %shl, %port1
  %call = call i32 @set_port_feature(%struct.usb_device* %0, i32 %or, i32 22)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %do.body1, label %if.end11

do.body1:                                         ; preds = %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @set_port_led.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %if.end11

if.then4:                                         ; preds = %do.body1
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %1 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !173
  %Pivot6 = icmp slt i32 %selector, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %if.then4
  %Pivot4 = icmp slt i32 %selector, 3
  br i1 %Pivot4, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %selector, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

NodeBlock:                                        ; preds = %if.then4
  %Pivot = icmp slt i32 %selector, 1
  br i1 %Pivot, label %LeafBlock, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %selector, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock, %NodeBlock, %LeafBlock1, %NodeBlock3
  %s.0 = phi i8* [ getelementptr inbounds ([3 x i8], [3 x i8]* @.str.6.805, i32 0, i32 0), %sw.default ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.105, i32 0, i32 0), %NodeBlock ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i32 0, i32 0), %NodeBlock3 ], [ getelementptr inbounds ([4 x i8], [4 x i8]* @.str.107, i32 0, i32 0), %LeafBlock1 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.108, i32 0, i32 0), %LeafBlock ]
  %call8 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @set_port_led.descriptor to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.104, i32 0, i32 0), i32 %port1, i8* %s.0, i32 %call)
  br label %if.end11

if.end11:                                         ; preds = %sw.epilog, %do.body1, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_phy_notify_disconnect(%struct.usb_phy* %x, i32 %speed) #1 {
entry:
  %notify_disconnect = getelementptr inbounds %struct.usb_phy, %struct.usb_phy* %x, i32 0, i32 20
  %0 = load i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32)** %notify_disconnect, align 8, !tbaa !263
  %tobool = icmp ne i32 (%struct.usb_phy*, i32)* %0, null
  br i1 %tobool, label %if.then, label %return

if.then:                                          ; preds = %entry
  %notify_disconnect1 = getelementptr inbounds %struct.usb_phy, %struct.usb_phy* %x, i32 0, i32 20
  %1 = load i32 (%struct.usb_phy*, i32)*, i32 (%struct.usb_phy*, i32)** %notify_disconnect1, align 8, !tbaa !263
  %call = call i32 %1(%struct.usb_phy* %x, i32 %speed)
  br label %return

return:                                           ; preds = %if.then, %entry
  %retval.0 = phi i32 [ %call, %if.then ], [ 0, %entry ]
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hub_port_debounce_be_stable(%struct.usb_hub* %hub, i32 %port1) #1 {
entry:
  %call = call i32 @hub_port_debounce(%struct.usb_hub* %hub, i32 %port1, i1 zeroext false)
  ret i32 %call
}

declare i32 @__printk_ratelimit(i8*) #2

; Function Attrs: nounwind uwtable
define internal void @choose_devnum(%struct.usb_device* %udev) #0 {
entry:
  %bus1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus1, align 8, !tbaa !2
  %wusb = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %wusb, align 4
  %bf.lshr = lshr i16 %bf.load, 5
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 20
  %1 = load i8, i8* %portnum, align 2, !tbaa !88
  %conv = zext i8 %1 to i32
  %add = add nsw i32 %conv, 1
  %devmap = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 9
  %devicemap = getelementptr inbounds %struct.usb_devmap, %struct.usb_devmap* %devmap, i32 0, i32 0
  %arraydecay = getelementptr inbounds [2 x i64], [2 x i64]* %devicemap, i32 0, i32 0
  %call = call i32 @variable_test_bit(i32 %add, i64* %arraydecay)
  %tobool2 = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %do.body7, label %if.end31

do.body7:                                         ; preds = %if.then
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.5.13, i32 0, i32 0), i32 1949, i64 12) #8, !srcloc !264
  br label %do.body8

do.body8:                                         ; preds = %do.body8, %do.body7
  br label %do.body8

if.else:                                          ; preds = %entry
  %devmap13 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 9
  %devicemap14 = getelementptr inbounds %struct.usb_devmap, %struct.usb_devmap* %devmap13, i32 0, i32 0
  %arraydecay15 = getelementptr inbounds [2 x i64], [2 x i64]* %devicemap14, i32 0, i32 0
  %devnum_next = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 8
  %2 = load i32, i32* %devnum_next, align 8, !tbaa !265
  %conv16 = sext i32 %2 to i64
  %call17 = call i64 @find_next_zero_bit(i64* %arraydecay15, i64 128, i64 %conv16)
  %conv18 = trunc i64 %call17 to i32
  %cmp = icmp sge i32 %conv18, 128
  br i1 %cmp, label %if.then20, label %if.end26

if.then20:                                        ; preds = %if.else
  %devmap21 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 9
  %devicemap22 = getelementptr inbounds %struct.usb_devmap, %struct.usb_devmap* %devmap21, i32 0, i32 0
  %arraydecay23 = getelementptr inbounds [2 x i64], [2 x i64]* %devicemap22, i32 0, i32 0
  %call24 = call i64 @find_next_zero_bit(i64* %arraydecay23, i64 128, i64 1)
  %conv25 = trunc i64 %call24 to i32
  br label %if.end26

if.end26:                                         ; preds = %if.then20, %if.else
  %devnum.0 = phi i32 [ %conv25, %if.then20 ], [ %conv18, %if.else ]
  %cmp27 = icmp sge i32 %devnum.0, 127
  %add29 = add nsw i32 %devnum.0, 1
  %cond = select i1 %cmp27, i32 1, i32 %add29
  %devnum_next30 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 8
  store i32 %cond, i32* %devnum_next30, align 8, !tbaa !265
  br label %if.end31

if.end31:                                         ; preds = %if.end26, %if.then
  %devnum.1 = phi i32 [ %devnum.0, %if.end26 ], [ %add, %if.then ]
  %cmp32 = icmp slt i32 %devnum.1, 128
  br i1 %cmp32, label %if.then34, label %if.end39

if.then34:                                        ; preds = %if.end31
  %devmap35 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %0, i32 0, i32 9
  %devicemap36 = getelementptr inbounds %struct.usb_devmap, %struct.usb_devmap* %devmap35, i32 0, i32 0
  %arraydecay37 = getelementptr inbounds [2 x i64], [2 x i64]* %devicemap36, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay37, i32 %devnum.1, i64* %arraydecay37) #8, !srcloc !144
  %devnum38 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 0
  store i32 %devnum.1, i32* %devnum38, align 8, !tbaa !38
  br label %if.end39

if.end39:                                         ; preds = %if.then34, %if.end31
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @schedule_delayed_work(%struct.delayed_work* %dwork, i64 %delay) #1 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8, !tbaa !48
  call void @queue_delayed_work(%struct.workqueue_struct* %0, %struct.delayed_work* %dwork, i64 %delay)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @check_highspeed(%struct.usb_hub* %hub, %struct.usb_device* %udev, i32 %port1) #0 {
entry:
  %call.i = call i8* @__kmalloc(i64 10, i32 208) #8
  %0 = bitcast i8* %call.i to %struct.usb_qualifier_descriptor*
  %cmp = icmp eq %struct.usb_qualifier_descriptor* %0, null
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %1 = bitcast %struct.usb_qualifier_descriptor* %0 to i8*
  %call1 = call i32 @usb_get_descriptor(%struct.usb_device* %udev, i8 zeroext 6, i8 zeroext 0, i8* %1, i32 10)
  %conv = sext i32 %call1 to i64
  %cmp2 = icmp eq i64 %conv, 10
  br i1 %cmp2, label %if.then4, label %if.end9

if.then4:                                         ; preds = %if.end
  %2 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %has_indicators = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %bf.load = load i8, i8* %has_indicators, align 4
  %bf.lshr = lshr i8 %bf.load, 4
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.then4
  %indicator = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 19
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [31 x i8], [31 x i8]* %indicator, i64 0, i64 %idxprom
  store i8 2, i8* %arrayidx, align 1, !tbaa !84
  %leds = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  call void @schedule_delayed_work(%struct.delayed_work* %leds, i64 0)
  br label %if.end9

if.end9:                                          ; preds = %if.then6, %if.then4, %if.end
  %3 = bitcast %struct.usb_qualifier_descriptor* %0 to i8*
  call void @kfree(i8* %3)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end9, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_power_remaining(%struct.usb_hub* %hub) #0 {
entry:
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !152
  %limited_power = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %bf.load = load i8, i8* %limited_power, align 4
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end, label %cleanup39

if.end:                                           ; preds = %entry
  %bus_mA = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 19
  %1 = load i16, i16* %bus_mA, align 8, !tbaa !258
  %conv = zext i16 %1 to i32
  %descriptor = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %2 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !204
  %bHubContrCurrent = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %2, i32 0, i32 5
  %3 = load i8, i8* %bHubContrCurrent, align 1, !tbaa !266
  %conv2 = zext i8 %3 to i32
  %sub = sub nsw i32 %conv, %conv2
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock, %if.end
  %port1.0 = phi i32 [ 1, %if.end ], [ %inc, %LeafBlock ]
  %remaining.0 = phi i32 [ %sub, %if.end ], [ %remaining.1, %LeafBlock ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %4 = load i32, i32* %maxchild, align 8, !tbaa !97
  %cmp = icmp sle i32 %port1.0, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  %5 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %sub4 = sub nsw i32 %port1.0, 1
  %idxprom = sext i32 %sub4 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %5, i64 %idxprom
  %6 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %6, i32 0, i32 0
  %7 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !102
  %tobool5 = icmp ne %struct.usb_device* %7, null
  br i1 %tobool5, label %if.end7, label %LeafBlock

if.end7:                                          ; preds = %for.body
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %7)
  %tobool8 = icmp ne i32 %call, 0
  %. = select i1 %tobool8, i32 150, i32 100
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 15
  %8 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool11 = icmp ne %struct.usb_host_config* %8, null
  br i1 %tobool11, label %if.then12, label %if.else15

if.then12:                                        ; preds = %if.end7
  %actconfig13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 15
  %9 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig13, align 8, !tbaa !64
  %call14 = call i32 @usb_get_max_power(%struct.usb_device* %7, %struct.usb_host_config* %9)
  br label %if.end23

if.else15:                                        ; preds = %if.end7
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 9
  %10 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %otg_port = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %10, i32 0, i32 5
  %11 = load i8, i8* %otg_port, align 2, !tbaa !154
  %conv16 = zext i8 %11 to i32
  %cmp17 = icmp ne i32 %port1.0, %conv16
  br i1 %cmp17, label %if.end23, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else15
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  %12 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool19 = icmp ne %struct.usb_device* %12, null
  %.. = select i1 %tobool19, i32 %., i32 8
  br label %if.end23

if.end23:                                         ; preds = %lor.lhs.false, %if.else15, %if.then12
  %delta.1 = phi i32 [ %call14, %if.then12 ], [ %., %if.else15 ], [ %.., %lor.lhs.false ]
  %mA_per_port = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %13 = load i32, i32* %mA_per_port, align 8, !tbaa !257
  %cmp24 = icmp ugt i32 %delta.1, %13
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %if.end23
  %14 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %if.end23
  %sub30 = sub nsw i32 %remaining.0, %delta.1
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end29, %for.body
  %remaining.1 = phi i32 [ %sub30, %if.end29 ], [ %remaining.0, %for.body ]
  %inc = add nsw i32 %port1.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %cmp33 = icmp slt i32 %remaining.0, 0
  br i1 %cmp33, label %if.then35, label %cleanup39

if.then35:                                        ; preds = %for.end
  %15 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup39

cleanup39:                                        ; preds = %if.then35, %for.end, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ 0, %if.then35 ], [ %remaining.0, %for.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_get_max_power(%struct.usb_device* %udev, %struct.usb_host_config* %c) #1 {
entry:
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp eq i32 %0, 5
  %cond = select i1 %cmp, i32 8, i32 2
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %c, i32 0, i32 0
  %bMaxPower = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 7
  %1 = load i8, i8* %bMaxPower, align 8, !tbaa !267
  %conv = zext i8 %1 to i32
  %mul1 = mul i32 %conv, %cond
  ret i32 %mul1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_delayed_work(%struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay) #1 {
entry:
  %call = call zeroext i1 @queue_delayed_work_on(i32 4096, %struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay)
  ret void
}

declare zeroext i1 @queue_delayed_work_on(i32, %struct.workqueue_struct*, %struct.delayed_work*, i64) #2

declare i64 @find_next_zero_bit(i64*, i64, i64) #2

declare zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work*) #2

declare zeroext i1 @flush_work(%struct.work_struct*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_return(i32 %i, %union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #8, !srcloc !268
  %add = add nsw i32 %i, %0
  ret i32 %add
}

declare void @__list_del_entry(%struct.list_head*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.28(%struct.list_head* %list) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !95
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !96
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_probe(%struct.usb_interface* %intf, %struct.usb_device_id* %id) #0 {
entry:
  %.compoundliteral = alloca %struct.pgprot, align 8
  %.compoundliteral93 = alloca %struct.pgprot, align 8
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %0 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !148
  %call = call %struct.usb_device* @interface_to_usbdev(%struct.usb_interface* %intf)
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 11
  call void @pm_runtime_set_autosuspend_delay(%struct.device* %dev, i32 0)
  call void @usb_enable_autosuspend(%struct.usb_device* %call)
  %level = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 21
  %1 = load i8, i8* %level, align 1, !tbaa !87
  %conv = zext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 8
  %3 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool = icmp ne %struct.usb_device* %3, null
  br i1 %tobool, label %if.then4, label %if.end7

if.then4:                                         ; preds = %if.end
  %4 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

if.end7:                                          ; preds = %if.end
  %desc8 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 0
  %bInterfaceSubClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc8, i32 0, i32 6
  %5 = load i8, i8* %bInterfaceSubClass, align 2, !tbaa !269
  %conv9 = zext i8 %5 to i32
  %cmp10 = icmp ne i32 %conv9, 0
  br i1 %cmp10, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.end7
  %desc12 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 0
  %bInterfaceSubClass13 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc12, i32 0, i32 6
  %6 = load i8, i8* %bInterfaceSubClass13, align 2, !tbaa !269
  %conv14 = zext i8 %6 to i32
  %cmp15 = icmp ne i32 %conv14, 1
  br i1 %cmp15, label %descriptor_error, label %if.end20

descriptor_error:                                 ; preds = %if.end26, %if.end20, %land.lhs.true
  %7 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end20:                                         ; preds = %land.lhs.true, %if.end7
  %desc21 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc21, i32 0, i32 4
  %8 = load i8, i8* %bNumEndpoints, align 4, !tbaa !270
  %conv22 = zext i8 %8 to i32
  %cmp23 = icmp ne i32 %conv22, 1
  br i1 %cmp23, label %descriptor_error, label %if.end26

if.end26:                                         ; preds = %if.end20
  %endpoint27 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 3
  %9 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint27, align 8, !tbaa !271
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %9, i64 0
  %desc28 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 0
  %call29 = call i32 @usb_endpoint_is_int_in(%struct.usb_endpoint_descriptor* %desc28)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %if.end32, label %descriptor_error

if.end32:                                         ; preds = %if.end26
  %10 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %call35 = call i8* @kzalloc.29(i64 968, i32 208)
  %11 = bitcast i8* %call35 to %struct.usb_hub*
  %tobool36 = icmp ne %struct.usb_hub* %11, null
  br i1 %tobool36, label %if.end49, label %do.body38

do.body38:                                        ; preds = %if.end32
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_probe.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool39 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool39, true
  %lnot40 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot40 to i32
  %conv41 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv41, i64 0)
  %tobool42 = icmp ne i64 %expval, 0
  br i1 %tobool42, label %if.then43, label %cleanup

if.then43:                                        ; preds = %do.body38
  %dev44 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call45 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_probe.descriptor to %struct._ddebug*), %struct.device* %dev44, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.96, i32 0, i32 0))
  br label %cleanup

if.end49:                                         ; preds = %if.end32
  %kref = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 2
  call void @kref_init(%struct.arch_spinlock* %kref)
  %event_list = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 9
  call void @INIT_LIST_HEAD.28(%struct.list_head* %event_list)
  %dev50 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 0
  store %struct.device* %dev50, %struct.device** %intfdev, align 8, !tbaa !173
  %hdev51 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 1
  store %struct.usb_device* %call, %struct.usb_device** %hdev51, align 8, !tbaa !152
  %leds = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 20
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %leds, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work, i32 0)
  %leds55 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 20
  %work56 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %leds55, i32 0, i32 0
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work56, i32 0, i32 0
  %counter = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !272
  %12 = bitcast %struct.pgprot* %data to i8*
  %13 = bitcast %struct.pgprot* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 8, i32 8, i1 false), !tbaa.struct !273
  %leds57 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 20
  %work58 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %leds57, i32 0, i32 0
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work58, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.97, i32 0, i32 0), %struct.lock_class_key* @hub_probe.__key, i32 0)
  %leds59 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 20
  %work60 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %leds59, i32 0, i32 0
  %entry61 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work60, i32 0, i32 1
  call void @INIT_LIST_HEAD.28(%struct.list_head* %entry61)
  %leds63 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 20
  %work64 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %leds63, i32 0, i32 0
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work64, i32 0, i32 2
  store void (%struct.work_struct*)* @led_work, void (%struct.work_struct*)** %func, align 8, !tbaa !274
  %leds73 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 20
  %timer = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %leds73, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer, i32 2, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.99, i32 0, i32 0), %struct.lock_class_key* @hub_probe.__key.98)
  %leds76 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 20
  %timer77 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %leds76, i32 0, i32 1
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer77, i32 0, i32 3
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function, align 8, !tbaa !275
  %leds78 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 20
  %14 = ptrtoint %struct.delayed_work* %leds78 to i64
  %leds79 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 20
  %timer80 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %leds79, i32 0, i32 1
  %data81 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer80, i32 0, i32 4
  store i64 %14, i64* %data81, align 8, !tbaa !276
  %init_work = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 21
  %work89 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work89, i32 0)
  %init_work90 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 21
  %work91 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work90, i32 0, i32 0
  %data92 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work91, i32 0, i32 0
  %counter94 = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral93, i32 0, i32 0
  store i64 137438953408, i64* %counter94, align 8, !tbaa !272
  %15 = bitcast %struct.pgprot* %data92 to i8*
  %16 = bitcast %struct.pgprot* %.compoundliteral93 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 8, i32 8, i1 false), !tbaa.struct !273
  %init_work95 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 21
  %work96 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work95, i32 0, i32 0
  %lockdep_map97 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work96, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map97, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.101, i32 0, i32 0), %struct.lock_class_key* @hub_probe.__key.100, i32 0)
  %init_work98 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 21
  %work99 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work98, i32 0, i32 0
  %entry100 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work99, i32 0, i32 1
  call void @INIT_LIST_HEAD.28(%struct.list_head* %entry100)
  %init_work102 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 21
  %work103 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work102, i32 0, i32 0
  %func104 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work103, i32 0, i32 2
  store void (%struct.work_struct*)* null, void (%struct.work_struct*)** %func104, align 8, !tbaa !274
  %init_work113 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 21
  %timer114 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work113, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer114, i32 2, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.103, i32 0, i32 0), %struct.lock_class_key* @hub_probe.__key.102)
  %init_work117 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 21
  %timer118 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work117, i32 0, i32 1
  %function119 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer118, i32 0, i32 3
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function119, align 8, !tbaa !275
  %init_work120 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 21
  %17 = ptrtoint %struct.delayed_work* %init_work120 to i64
  %init_work121 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 21
  %timer122 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work121, i32 0, i32 1
  %data123 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer122, i32 0, i32 4
  store i64 %17, i64* %data123, align 8, !tbaa !276
  %call128 = call %struct.usb_interface* @usb_get_intf(%struct.usb_interface* %intf)
  %18 = bitcast %struct.usb_hub* %11 to i8*
  call void @usb_set_intfdata(%struct.usb_interface* %intf, i8* %18)
  %needs_remote_wakeup = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load129 = load i8, i8* %needs_remote_wakeup, align 8
  %bf.clear130 = and i8 %bf.load129, -9
  %bf.set = or i8 %bf.clear130, 8
  store i8 %bf.set, i8* %needs_remote_wakeup, align 8
  %dev131 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @pm_suspend_ignore_children(%struct.device* %dev131, i1 zeroext true)
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 4
  %19 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp132 = icmp eq i32 %19, 3
  br i1 %cmp132, label %if.then134, label %if.end135

if.then134:                                       ; preds = %if.end49
  %20 = load i32, i32* @highspeed_hubs, align 4, !tbaa !90
  %inc = add i32 %20, 1
  store i32 %inc, i32* @highspeed_hubs, align 4, !tbaa !90
  br label %if.end135

if.end135:                                        ; preds = %if.then134, %if.end49
  %driver_info = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 12
  %21 = load i64, i64* %driver_info, align 8, !tbaa !277
  %and136 = and i64 %21, 1
  %tobool137 = icmp ne i64 %and136, 0
  br i1 %tobool137, label %if.then138, label %if.end142

if.then138:                                       ; preds = %if.end135
  %quirk_check_port_auto_suspend = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %11, i32 0, i32 18
  %bf.load139 = load i8, i8* %quirk_check_port_auto_suspend, align 4
  %bf.clear140 = and i8 %bf.load139, -9
  %bf.set141 = or i8 %bf.clear140, 8
  store i8 %bf.set141, i8* %quirk_check_port_auto_suspend, align 4
  br label %if.end142

if.end142:                                        ; preds = %if.then138, %if.end135
  %call143 = call i32 @hub_configure(%struct.usb_hub* %11, %struct.usb_endpoint_descriptor* %desc28)
  %cmp144 = icmp sge i32 %call143, 0
  br i1 %cmp144, label %cleanup, label %if.end147

if.end147:                                        ; preds = %if.end142
  call void @hub_disconnect(%struct.usb_interface* %intf)
  br label %cleanup

cleanup:                                          ; preds = %if.end147, %if.end142, %if.then43, %do.body38, %descriptor_error, %if.then4, %if.then
  %retval.0 = phi i32 [ -7, %if.then ], [ -19, %if.then4 ], [ -5, %descriptor_error ], [ -19, %if.end147 ], [ -12, %if.then43 ], [ -12, %do.body38 ], [ 0, %if.end142 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @hub_disconnect(%struct.usb_interface* %intf) #0 {
entry:
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.usb_hub*
  %call1 = call %struct.usb_device* @interface_to_usbdev(%struct.usb_interface* %intf)
  call void @spin_lock_irq(%struct.spinlock* @hub_event_lock)
  %event_list = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 9
  %call2 = call i32 @list_empty(%struct.list_head* %event_list)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %event_list3 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 9
  call void @list_del_init(%struct.list_head* %event_list3)
  call void @usb_autopm_put_interface_no_suspend(%struct.usb_interface* %intf)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %disconnected = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 18
  %bf.load = load i8, i8* %disconnected, align 4
  %bf.clear = and i8 %bf.load, -5
  %bf.set = or i8 %bf.clear, 4
  store i8 %bf.set, i8* %disconnected, align 4
  call void @spin_unlock_irq(%struct.spinlock* @hub_event_lock)
  %error = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 7
  store i32 0, i32* %error, align 8, !tbaa !174
  call void @hub_quiesce(%struct.usb_hub* %0, i32 0)
  call void @usb_set_intfdata(%struct.usb_interface* %intf, i8* null)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call1, i32 0, i32 28
  %1 = load i32, i32* %maxchild, align 8, !tbaa !97
  %cmp = icmp slt i32 %i.0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add = add nsw i32 %i.0, 1
  call void bitcast (void (%struct.usb_hub.4588*, i32)* @usb_hub_remove_port_device to void (%struct.usb_hub*, i32)*)(%struct.usb_hub* %0, i32 %add)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %hdev4 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %hdev4, align 8, !tbaa !152
  %maxchild5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 28
  store i32 0, i32* %maxchild5, align 8, !tbaa !97
  %hdev6 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %hdev6, align 8, !tbaa !152
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 4
  %4 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp7 = icmp eq i32 %4, 3
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.end
  %5 = load i32, i32* @highspeed_hubs, align 4, !tbaa !90
  %dec = add i32 %5, -1
  store i32 %dec, i32* @highspeed_hubs, align 4, !tbaa !90
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %for.end
  %urb = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 3
  %6 = load %struct.urb*, %struct.urb** %urb, align 8, !tbaa !254
  call void bitcast (void (%struct.urb.824*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %6)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 22
  %7 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %8 = bitcast %struct.usb_port** %7 to i8*
  call void @kfree(i8* %8)
  %descriptor = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 15
  %9 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !204
  %10 = bitcast %struct.usb_hub_descriptor* %9 to i8*
  call void @kfree(i8* %10)
  %status = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 5
  %11 = load %union.anon.48*, %union.anon.48** %status, align 8, !tbaa !176
  %12 = bitcast %union.anon.48* %11 to i8*
  call void @kfree(i8* %12)
  %buffer = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 4
  %13 = load [8 x i8]*, [8 x i8]** %buffer, align 8, !tbaa !278
  %14 = bitcast [8 x i8]* %13 to i8*
  call void @kfree(i8* %14)
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @pm_suspend_ignore_children(%struct.device* %dev, i1 zeroext false)
  %kref = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 2
  call void @kref_put(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* @hub_release)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_ioctl(%struct.usb_interface* %intf, i32 %code, i8* %user_data) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev(%struct.usb_interface* %intf)
  %call1 = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %call)
  %SwitchLeaf = icmp eq i32 %code, -2139073261
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %entry
  %0 = bitcast i8* %user_data to %struct.usbdevfs_hub_portinfo*
  call void @spin_lock_irq(%struct.spinlock* @device_state_lock)
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 0
  %1 = load i32, i32* %devnum, align 8, !tbaa !38
  %cmp = icmp sle i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %nports = getelementptr inbounds %struct.usbdevfs_hub_portinfo, %struct.usbdevfs_hub_portinfo* %0, i32 0, i32 0
  store i8 0, i8* %nports, align 1, !tbaa !279
  br label %if.end22

if.else:                                          ; preds = %sw.bb
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 28
  %2 = load i32, i32* %maxchild, align 8, !tbaa !97
  %conv = trunc i32 %2 to i8
  %nports2 = getelementptr inbounds %struct.usbdevfs_hub_portinfo, %struct.usbdevfs_hub_portinfo* %0, i32 0, i32 0
  store i8 %conv, i8* %nports2, align 1, !tbaa !279
  br label %for.cond

for.cond:                                         ; preds = %if.end, %if.else
  %i.0 = phi i32 [ 0, %if.else ], [ %inc, %if.end ]
  %nports3 = getelementptr inbounds %struct.usbdevfs_hub_portinfo, %struct.usbdevfs_hub_portinfo* %0, i32 0, i32 0
  %3 = load i8, i8* %nports3, align 1, !tbaa !279
  %conv4 = sext i8 %3 to i32
  %cmp5 = icmp slt i32 %i.0, %conv4
  br i1 %cmp5, label %for.body, label %if.end22

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call1, i32 0, i32 22
  %4 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %4, i64 %idxprom
  %5 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %5, i32 0, i32 0
  %6 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !102
  %cmp7 = icmp eq %struct.usb_device* %6, null
  br i1 %cmp7, label %if.end, label %if.else12

if.else12:                                        ; preds = %for.body
  %ports13 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call1, i32 0, i32 22
  %7 = load %struct.usb_port**, %struct.usb_port*** %ports13, align 8, !tbaa !98
  %idxprom14 = sext i32 %i.0 to i64
  %arrayidx15 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %7, i64 %idxprom14
  %8 = load %struct.usb_port*, %struct.usb_port** %arrayidx15, align 8, !tbaa !48
  %child16 = getelementptr inbounds %struct.usb_port, %struct.usb_port* %8, i32 0, i32 0
  %9 = load %struct.usb_device*, %struct.usb_device** %child16, align 8, !tbaa !102
  %devnum17 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %9, i32 0, i32 0
  %10 = load i32, i32* %devnum17, align 8, !tbaa !38
  %conv18 = trunc i32 %10 to i8
  br label %if.end

if.end:                                           ; preds = %if.else12, %for.body
  %conv18.sink = phi i8 [ %conv18, %if.else12 ], [ 0, %for.body ]
  %port19 = getelementptr inbounds %struct.usbdevfs_hub_portinfo, %struct.usbdevfs_hub_portinfo* %0, i32 0, i32 1
  %idxprom20 = sext i32 %i.0 to i64
  %arrayidx21 = getelementptr inbounds [127 x i8], [127 x i8]* %port19, i64 0, i64 %idxprom20
  store i8 %conv18.sink, i8* %arrayidx21, align 1, !tbaa !84
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end22:                                         ; preds = %for.cond, %if.then
  call void @spin_unlock_irq(%struct.spinlock* @device_state_lock)
  %nports23 = getelementptr inbounds %struct.usbdevfs_hub_portinfo, %struct.usbdevfs_hub_portinfo* %0, i32 0, i32 0
  %11 = load i8, i8* %nports23, align 1, !tbaa !279
  %conv24 = sext i8 %11 to i32
  %add = add nsw i32 %conv24, 1
  br label %cleanup

cleanup:                                          ; preds = %if.end22, %entry
  %retval.0 = phi i32 [ %add, %if.end22 ], [ -38, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_suspend(%struct.usb_interface* %intf, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.usb_hub*
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !152
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %port1.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %retval.0 = phi i32 [ undef, %entry ], [ %retval.1, %for.inc ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 28
  %2 = load i32, i32* %maxchild, align 8, !tbaa !97
  %cmp = icmp ule i32 %port1.0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 22
  %3 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %sub = sub i32 %port1.0, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %3, i64 %idxprom
  %4 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %4, i32 0, i32 0
  %5 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !102
  %tobool = icmp ne %struct.usb_device* %5, null
  br i1 %tobool, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %for.body
  %can_submit = getelementptr inbounds %struct.usb_device, %struct.usb_device* %5, i32 0, i32 22
  %bf.load = load i16, i16* %can_submit, align 4
  %bf.clear = and i16 %bf.load, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool2 = icmp ne i32 %bf.cast, 0
  br i1 %tobool2, label %if.then, label %if.end6

if.then:                                          ; preds = %land.lhs.true
  %6 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %7 = load i32, i32* %event, align 4, !tbaa !42
  %and = and i32 %7, 1024
  %cmp4 = icmp ne i32 %and, 0
  br i1 %cmp4, label %LeafBlock, label %if.end6

if.end6:                                          ; preds = %if.then, %land.lhs.true, %for.body
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end6, %if.then
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end6 ], [ 1, %if.then ]
  %retval.1 = phi i32 [ %retval.0, %if.end6 ], [ -16, %if.then ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup62

for.inc:                                          ; preds = %LeafBlock
  %inc = add i32 %port1.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %do_remote_wakeup = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 33
  %bf.load7 = load i8, i8* %do_remote_wakeup, align 8
  %bf.clear8 = and i8 %bf.load7, 1
  %bf.cast9 = zext i8 %bf.clear8 to i32
  %tobool10 = icmp ne i32 %bf.cast9, 0
  br i1 %tobool10, label %land.lhs.true11, label %if.end27

land.lhs.true11:                                  ; preds = %for.end
  %quirk_check_port_auto_suspend = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %0, i32 0, i32 18
  %bf.load12 = load i8, i8* %quirk_check_port_auto_suspend, align 4
  %bf.lshr = lshr i8 %bf.load12, 3
  %bf.clear13 = and i8 %bf.lshr, 1
  %bf.cast14 = zext i8 %bf.clear13 to i32
  %tobool15 = icmp ne i32 %bf.cast14, 0
  br i1 %tobool15, label %if.then16, label %if.end27

if.then16:                                        ; preds = %land.lhs.true11
  %call17 = call i32 @check_ports_changed(%struct.usb_hub* %0)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.then19, label %if.end27

if.then19:                                        ; preds = %if.then16
  %event20 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %8 = load i32, i32* %event20, align 4, !tbaa !42
  %and21 = and i32 %8, 1024
  %cmp22 = icmp ne i32 %and21, 0
  br i1 %cmp22, label %cleanup62, label %if.end24

if.end24:                                         ; preds = %if.then19
  %dev25 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @pm_wakeup_event(%struct.device* %dev25, i32 2000)
  br label %if.end27

if.end27:                                         ; preds = %if.end24, %if.then16, %land.lhs.true11, %for.end
  %call28 = call i32 @hub_is_superspeed(%struct.usb_device* %1)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %land.lhs.true30, label %do.body48

land.lhs.true30:                                  ; preds = %if.end27
  %do_remote_wakeup31 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 33
  %bf.load32 = load i8, i8* %do_remote_wakeup31, align 8
  %bf.clear33 = and i8 %bf.load32, 1
  %bf.cast34 = zext i8 %bf.clear33 to i32
  %tobool35 = icmp ne i32 %bf.cast34, 0
  br i1 %tobool35, label %if.then36, label %do.body48

if.then36:                                        ; preds = %land.lhs.true30
  br label %for.cond37

for.cond37:                                       ; preds = %for.body40, %if.then36
  %port1.1 = phi i32 [ 1, %if.then36 ], [ %inc45, %for.body40 ]
  %maxchild38 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 28
  %9 = load i32, i32* %maxchild38, align 8, !tbaa !97
  %cmp39 = icmp ule i32 %port1.1, %9
  br i1 %cmp39, label %for.body40, label %do.body48

for.body40:                                       ; preds = %for.cond37
  %or = or i32 %port1.1, 256
  %or41 = or i32 %or, 512
  %or42 = or i32 %or41, 1024
  %call43 = call i32 @set_port_feature(%struct.usb_device* %1, i32 %or42, i32 27)
  %inc45 = add i32 %port1.1, 1
  br label %for.cond37

do.body48:                                        ; preds = %for.cond37, %land.lhs.true30, %if.end27
  %bf.load49 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_suspend.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr50 = lshr i32 %bf.load49, 18
  %bf.clear51 = and i32 %bf.lshr50, 255
  %and52 = and i32 %bf.clear51, 1
  %tobool53 = icmp ne i32 %and52, 0
  %lnot = xor i1 %tobool53, true
  %lnot54 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot54 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool55 = icmp ne i64 %expval, 0
  br i1 %tobool55, label %if.then56, label %do.end61

if.then56:                                        ; preds = %do.body48
  %dev57 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call58 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_suspend.descriptor to %struct._ddebug*), %struct.device* %dev57, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11.859, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.hub_suspend, i32 0, i32 0))
  br label %do.end61

do.end61:                                         ; preds = %if.then56, %do.body48
  call void @hub_quiesce(%struct.usb_hub* %0, i32 2)
  br label %cleanup62

cleanup62:                                        ; preds = %do.end61, %if.then19, %LeafBlock
  %retval.2 = phi i32 [ 0, %do.end61 ], [ -16, %if.then19 ], [ %retval.1, %LeafBlock ]
  ret i32 %retval.2
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_resume(%struct.usb_interface* %intf) #0 {
entry:
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.usb_hub*
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_resume.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end6

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call4 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_resume.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11.859, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__func__.hub_resume, i32 0, i32 0))
  br label %do.end6

do.end6:                                          ; preds = %if.then, %entry
  call void @hub_activate(%struct.usb_hub* %0, i32 4)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_reset_resume(%struct.usb_interface* %intf) #0 {
entry:
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.usb_hub*
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_reset_resume.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end6

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call4 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_reset_resume.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11.859, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.hub_reset_resume, i32 0, i32 0))
  br label %do.end6

do.end6:                                          ; preds = %if.then, %entry
  call void @hub_activate(%struct.usb_hub* %0, i32 5)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_pre_reset(%struct.usb_interface* %intf) #0 {
entry:
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.usb_hub*
  call void @hub_quiesce(%struct.usb_hub* %0, i32 1)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @hub_post_reset(%struct.usb_interface* %intf) #0 {
entry:
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.usb_hub*
  call void @hub_activate(%struct.usb_hub* %0, i32 3)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @hub_activate(%struct.usb_hub* %hub, i32 %type) #0 {
entry:
  %portstatus = alloca i16, align 2
  %portchange = alloca i16, align 2
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !152
  switch i32 %type, label %if.then6 [
    i32 1, label %init2
    i32 2, label %init3
    i32 4, label %init2
  ]

if.then6:                                         ; preds = %entry
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 8
  %1 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool = icmp ne %struct.usb_device* %1, null
  br i1 %tobool, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.then6
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool7 = icmp ne i32 %call, 0
  br i1 %tobool7, label %if.then8, label %if.end17

if.then8:                                         ; preds = %land.lhs.true
  %call9 = call i32 @__create_pipe(%struct.usb_device* %0, i32 0)
  %or = or i32 -2147483648, %call9
  %level = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 21
  %2 = load i8, i8* %level, align 1, !tbaa !87
  %conv = zext i8 %2 to i32
  %sub = sub nsw i32 %conv, 1
  %conv10 = trunc i32 %sub to i16
  %call11 = call i32 @usb_control_msg(%struct.usb_device* %0, i32 %or, i8 zeroext 12, i8 zeroext 32, i16 zeroext %conv10, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  %cmp12 = icmp slt i32 %call11, 0
  br i1 %cmp12, label %if.then14, label %if.end17

if.then14:                                        ; preds = %if.then8
  %3 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %if.then8, %land.lhs.true, %if.then6
  switch i32 %type, label %if.else45 [
    i32 0, label %if.then20
    i32 5, label %if.then28
  ]

if.then20:                                        ; preds = %if.end17
  %call21 = call i32 @hub_power_on(%struct.usb_hub* %hub, i1 zeroext false)
  %init_work = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 21
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work, i32 0, i32 0
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work, i32 0, i32 2
  store void (%struct.work_struct*)* @hub_init_func2, void (%struct.work_struct*)** %func, align 8, !tbaa !274
  %init_work22 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 21
  %call23 = call i64 @msecs_to_jiffies(i32 %call21)
  call void @schedule_delayed_work(%struct.delayed_work* %init_work22, i64 %call23)
  %intfdev25 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %4 = load %struct.device*, %struct.device** %intfdev25, align 8, !tbaa !173
  %5 = bitcast %struct.device* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 -48
  %6 = bitcast i8* %add.ptr to %struct.usb_interface*
  call void @usb_autopm_get_interface_no_resume(%struct.usb_interface* %6)
  br label %cleanup.cont

if.then28:                                        ; preds = %if.end17
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %7 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call29 = call %struct.usb_hcd* @bus_to_hcd.11(%struct.usb_bus* %7)
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call29, i32 0, i32 8
  %8 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %update_hub_device = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %8, i32 0, i32 35
  %9 = load i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)** %update_hub_device, align 8, !tbaa !281
  %tobool30 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)* %9, null
  br i1 %tobool30, label %if.then31, label %if.end43

if.then31:                                        ; preds = %if.then28
  %driver32 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call29, i32 0, i32 8
  %10 = load %struct.hc_driver*, %struct.hc_driver** %driver32, align 8, !tbaa !71
  %update_hub_device33 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %10, i32 0, i32 35
  %11 = load i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)** %update_hub_device33, align 8, !tbaa !281
  %tt = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %call34 = call i32 %11(%struct.usb_hcd* %call29, %struct.usb_device* %0, %struct.usb_tt* %tt, i32 16)
  %cmp35 = icmp slt i32 %call34, 0
  br i1 %cmp35, label %if.then37, label %if.end43

if.then37:                                        ; preds = %if.then31
  %12 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %13 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end43

if.end43:                                         ; preds = %if.then37, %if.then31, %if.then28
  %call44 = call i32 @hub_power_on(%struct.usb_hub* %hub, i1 zeroext true)
  br label %init2

if.else45:                                        ; preds = %if.end17
  %call46 = call i32 @hub_power_on(%struct.usb_hub* %hub, i1 zeroext true)
  br label %init2

init2:                                            ; preds = %if.else45, %if.end43, %entry, %entry
  br label %for.cond

for.cond:                                         ; preds = %if.end200, %init2
  %port1.0 = phi i32 [ 1, %init2 ], [ %inc, %if.end200 ]
  %need_debounce_delay.0 = phi i8 [ 0, %init2 ], [ %need_debounce_delay.3, %if.end200 ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %14 = load i32, i32* %maxchild, align 8, !tbaa !97
  %cmp50 = icmp sle i32 %port1.0, %14
  br i1 %cmp50, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  %15 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %sub52 = sub nsw i32 %port1.0, 1
  %idxprom = sext i32 %sub52 to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %15, i64 %idxprom
  %16 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %child = getelementptr inbounds %struct.usb_port, %struct.usb_port* %16, i32 0, i32 0
  %17 = load %struct.usb_device*, %struct.usb_device** %child, align 8, !tbaa !102
  %18 = bitcast i16* %portstatus to i8*
  %19 = bitcast i16* %portchange to i8*
  store i16 0, i16* %portchange, align 2, !tbaa !143
  store i16 0, i16* %portstatus, align 2, !tbaa !143
  %call53 = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1.0, i16* %portstatus, i16* %portchange)
  %tobool54 = icmp ne %struct.usb_device* %17, null
  br i1 %tobool54, label %do.body59, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %20 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv55 = zext i16 %20 to i32
  %and = and i32 %conv55, 1
  %tobool56 = icmp ne i32 %and, 0
  br i1 %tobool56, label %do.body59, label %if.end75

do.body59:                                        ; preds = %lor.lhs.false, %for.body
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_activate.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and60 = and i32 %bf.clear, 1
  %tobool61 = icmp ne i32 %and60, 0
  %lnot = xor i1 %tobool61, true
  %lnot62 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot62 to i32
  %conv63 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv63, i64 0)
  %tobool64 = icmp ne i64 %expval, 0
  br i1 %tobool64, label %if.then65, label %if.end75

if.then65:                                        ; preds = %do.body59
  %intfdev66 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %21 = load %struct.device*, %struct.device** %intfdev66, align 8, !tbaa !173
  %22 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv67 = zext i16 %22 to i32
  %23 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv68 = zext i16 %23 to i32
  %call69 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_activate.descriptor to %struct._ddebug*), %struct.device* %21, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.175, i32 0, i32 0), i32 %port1.0, i32 %conv67, i32 %conv68)
  br label %if.end75

if.end75:                                         ; preds = %if.then65, %do.body59, %lor.lhs.false
  %24 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv76 = zext i16 %24 to i32
  %and77 = and i32 %conv76, 2
  %tobool78 = icmp ne i32 %and77, 0
  br i1 %tobool78, label %land.lhs.true79, label %if.end104

land.lhs.true79:                                  ; preds = %if.end75
  %cmp80 = icmp ne i32 %type, 4
  br i1 %cmp80, label %if.then91, label %lor.lhs.false82

lor.lhs.false82:                                  ; preds = %land.lhs.true79
  %25 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv83 = zext i16 %25 to i32
  %and84 = and i32 %conv83, 1
  %tobool85 = icmp ne i32 %and84, 0
  %tobool87 = icmp ne %struct.usb_device* %17, null
  %or.cond = and i1 %tobool85, %tobool87
  br i1 %or.cond, label %lor.lhs.false88, label %if.then91

lor.lhs.false88:                                  ; preds = %lor.lhs.false82
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %17, i32 0, i32 3
  %26 = load i32, i32* %state, align 8, !tbaa !50
  %cmp89 = icmp eq i32 %26, 0
  br i1 %cmp89, label %if.then91, label %if.end104

if.then91:                                        ; preds = %lor.lhs.false88, %lor.lhs.false82, %land.lhs.true79
  %call92 = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool93 = icmp ne i32 %call92, 0
  br i1 %tobool93, label %if.else99, label %if.then94

if.then94:                                        ; preds = %if.then91
  %call95 = call i32 @usb_clear_port_feature(%struct.usb_device* %0, i32 %port1.0, i32 1)
  %27 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv96 = zext i16 %27 to i32
  %and97 = and i32 %conv96, -3
  %conv98 = trunc i32 %and97 to i16
  store i16 %conv98, i16* %portstatus, align 2, !tbaa !143
  br label %if.end104

if.else99:                                        ; preds = %if.then91
  %28 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv100 = zext i16 %28 to i32
  %and101 = and i32 %conv100, -3
  %conv102 = trunc i32 %and101 to i16
  store i16 %conv102, i16* %portstatus, align 2, !tbaa !143
  br label %if.end104

if.end104:                                        ; preds = %if.else99, %if.then94, %lor.lhs.false88, %if.end75
  %29 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv105 = zext i16 %29 to i32
  %and106 = and i32 %conv105, 1
  %tobool107 = icmp ne i32 %and106, 0
  br i1 %tobool107, label %if.then108, label %if.end111

if.then108:                                       ; preds = %if.end104
  %hdev109 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %30 = load %struct.usb_device*, %struct.usb_device** %hdev109, align 8, !tbaa !152
  %call110 = call i32 @usb_clear_port_feature(%struct.usb_device* %30, i32 %port1.0, i32 16)
  br label %if.end111

if.end111:                                        ; preds = %if.then108, %if.end104
  %need_debounce_delay.1 = phi i8 [ 1, %if.then108 ], [ %need_debounce_delay.0, %if.end104 ]
  %31 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv112 = zext i16 %31 to i32
  %and113 = and i32 %conv112, 2
  %tobool114 = icmp ne i32 %and113, 0
  br i1 %tobool114, label %if.then115, label %if.end118

if.then115:                                       ; preds = %if.end111
  %hdev116 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %32 = load %struct.usb_device*, %struct.usb_device** %hdev116, align 8, !tbaa !152
  %call117 = call i32 @usb_clear_port_feature(%struct.usb_device* %32, i32 %port1.0, i32 17)
  br label %if.end118

if.end118:                                        ; preds = %if.then115, %if.end111
  %need_debounce_delay.2 = phi i8 [ 1, %if.then115 ], [ %need_debounce_delay.1, %if.end111 ]
  %33 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv119 = zext i16 %33 to i32
  %and120 = and i32 %conv119, 32
  %tobool121 = icmp ne i32 %and120, 0
  br i1 %tobool121, label %land.lhs.true122, label %if.end129

land.lhs.true122:                                 ; preds = %if.end118
  %hdev123 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %34 = load %struct.usb_device*, %struct.usb_device** %hdev123, align 8, !tbaa !152
  %call124 = call i32 @hub_is_superspeed(%struct.usb_device* %34)
  %tobool125 = icmp ne i32 %call124, 0
  br i1 %tobool125, label %if.then126, label %if.end129

if.then126:                                       ; preds = %land.lhs.true122
  %hdev127 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %35 = load %struct.usb_device*, %struct.usb_device** %hdev127, align 8, !tbaa !152
  %call128 = call i32 @usb_clear_port_feature(%struct.usb_device* %35, i32 %port1.0, i32 29)
  br label %if.end129

if.end129:                                        ; preds = %if.then126, %land.lhs.true122, %if.end118
  %need_debounce_delay.3 = phi i8 [ 1, %if.then126 ], [ %need_debounce_delay.2, %land.lhs.true122 ], [ %need_debounce_delay.2, %if.end118 ]
  %36 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv130 = zext i16 %36 to i32
  %and131 = and i32 %conv130, 1
  %tobool132 = icmp ne i32 %and131, 0
  br i1 %tobool132, label %lor.lhs.false133, label %if.then137

lor.lhs.false133:                                 ; preds = %if.end129
  %37 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv134 = zext i16 %37 to i32
  %and135 = and i32 %conv134, 1
  %tobool136 = icmp ne i32 %and135, 0
  br i1 %tobool136, label %if.then137, label %if.end138

if.then137:                                       ; preds = %lor.lhs.false133, %if.end129
  %removed_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 13
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %removed_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i32 %port1.0, i64* %arraydecay) #8, !srcloc !145
  br label %if.end138

if.end138:                                        ; preds = %if.then137, %lor.lhs.false133
  %magicptr = ptrtoint %struct.usb_device* %17 to i64
  %cond = icmp eq i64 %magicptr, 0
  br i1 %cond, label %lor.lhs.false146, label %lor.lhs.false140

lor.lhs.false140:                                 ; preds = %if.end138
  %state141 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %17, i32 0, i32 3
  %38 = load i32, i32* %state141, align 8, !tbaa !50
  %cmp142 = icmp eq i32 %38, 0
  br i1 %cmp142, label %if.then144, label %if.else153

if.then144:                                       ; preds = %lor.lhs.false140
  %tobool145 = icmp ne %struct.usb_device* %17, null
  br i1 %tobool145, label %if.then150, label %lor.lhs.false146

lor.lhs.false146:                                 ; preds = %if.then144, %if.end138
  %39 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv147 = zext i16 %39 to i32
  %and148 = and i32 %conv147, 1
  %tobool149 = icmp ne i32 %and148, 0
  br i1 %tobool149, label %if.then150, label %if.end200

if.then150:                                       ; preds = %lor.lhs.false146, %if.then144
  %change_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 11
  %arraydecay151 = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay151, i32 %port1.0, i64* %arraydecay151) #8, !srcloc !144
  br label %if.end200

if.else153:                                       ; preds = %lor.lhs.false140
  %40 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv154 = zext i16 %40 to i32
  %and155 = and i32 %conv154, 2
  %tobool156 = icmp ne i32 %and155, 0
  br i1 %tobool156, label %if.then157, label %if.else175

if.then157:                                       ; preds = %if.else153
  %41 = load i16, i16* %portstatus, align 2, !tbaa !143
  %conv158 = zext i16 %41 to i32
  %and159 = and i32 %conv158, 480
  %cmp160 = icmp eq i32 %and159, 0
  %frombool = zext i1 %cmp160 to i8
  %42 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv162 = zext i16 %42 to i32
  %tobool163 = icmp ne i32 %conv162, 0
  br i1 %tobool163, label %if.then171, label %lor.lhs.false164

lor.lhs.false164:                                 ; preds = %if.then157
  %hdev165 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %43 = load %struct.usb_device*, %struct.usb_device** %hdev165, align 8, !tbaa !152
  %call166 = call i32 @hub_is_superspeed(%struct.usb_device* %43)
  %tobool167 = icmp ne i32 %call166, 0
  br i1 %tobool167, label %land.lhs.true168, label %if.end200

land.lhs.true168:                                 ; preds = %lor.lhs.false164
  %tobool169 = trunc i8 %frombool to i1
  br i1 %tobool169, label %if.then171, label %if.end200

if.then171:                                       ; preds = %land.lhs.true168, %if.then157
  %change_bits172 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 11
  %arraydecay173 = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits172, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay173, i32 %port1.0, i64* %arraydecay173) #8, !srcloc !144
  br label %if.end200

if.else175:                                       ; preds = %if.else153
  %persist_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %17, i32 0, i32 22
  %bf.load176 = load i16, i16* %persist_enabled, align 4
  %bf.lshr177 = lshr i16 %bf.load176, 1
  %bf.clear178 = and i16 %bf.lshr177, 1
  %bf.cast = zext i16 %bf.clear178 to i32
  %tobool179 = icmp ne i32 %bf.cast, 0
  br i1 %tobool179, label %if.then180, label %if.else195

if.then180:                                       ; preds = %if.else175
  %ports181 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  %44 = load %struct.usb_port**, %struct.usb_port*** %ports181, align 8, !tbaa !98
  %sub182 = sub nsw i32 %port1.0, 1
  %idxprom183 = sext i32 %sub182 to i64
  %arrayidx184 = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %44, i64 %idxprom183
  %45 = load %struct.usb_port*, %struct.usb_port** %arrayidx184, align 8, !tbaa !48
  %reset_resume = getelementptr inbounds %struct.usb_device, %struct.usb_device* %17, i32 0, i32 33
  %bf.load185 = load i8, i8* %reset_resume, align 8
  %bf.clear186 = and i8 %bf.load185, -3
  %bf.set = or i8 %bf.clear186, 2
  store i8 %bf.set, i8* %reset_resume, align 8
  %power_is_on = getelementptr inbounds %struct.usb_port, %struct.usb_port* %45, i32 0, i32 5
  %bf.load187 = load i8, i8* %power_is_on, align 1
  %bf.clear188 = and i8 %bf.load187, 1
  %bf.cast189 = zext i8 %bf.clear188 to i32
  %tobool190 = icmp ne i32 %bf.cast189, 0
  br i1 %tobool190, label %if.then191, label %if.end200

if.then191:                                       ; preds = %if.then180
  %change_bits192 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 11
  %arraydecay193 = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits192, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay193, i32 %port1.0, i64* %arraydecay193) #8, !srcloc !144
  br label %if.end200

if.else195:                                       ; preds = %if.else175
  call void @usb_set_device_state(%struct.usb_device* %17, i32 0)
  %change_bits196 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 11
  %arraydecay197 = getelementptr inbounds [1 x i64], [1 x i64]* %change_bits196, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay197, i32 %port1.0, i64* %arraydecay197) #8, !srcloc !144
  br label %if.end200

if.end200:                                        ; preds = %if.else195, %if.then191, %if.then180, %if.then171, %land.lhs.true168, %lor.lhs.false164, %if.then150, %lor.lhs.false146
  %46 = bitcast i16* %portchange to i8*
  %47 = bitcast i16* %portstatus to i8*
  %inc = add nsw i32 %port1.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool201 = trunc i8 %need_debounce_delay.0 to i1
  br i1 %tobool201, label %if.then202, label %init3

if.then202:                                       ; preds = %for.end
  %cmp203 = icmp eq i32 %type, 1
  br i1 %cmp203, label %do.body206, label %if.else215

do.body206:                                       ; preds = %if.then202
  %init_work207 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 21
  %work208 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %init_work207, i32 0, i32 0
  %func209 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work208, i32 0, i32 2
  store void (%struct.work_struct*)* @hub_init_func3, void (%struct.work_struct*)** %func209, align 8, !tbaa !274
  %init_work212 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 21
  %call213 = call i64 @msecs_to_jiffies(i32 100)
  call void @schedule_delayed_work(%struct.delayed_work* %init_work212, i64 %call213)
  br label %cleanup.cont

if.else215:                                       ; preds = %if.then202
  call void @msleep(i32 100)
  br label %init3

init3:                                            ; preds = %if.else215, %for.end, %entry
  %quiescing = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %bf.load218 = load i8, i8* %quiescing, align 4
  %bf.clear219 = and i8 %bf.load218, -3
  store i8 %bf.clear219, i8* %quiescing, align 4
  %urb = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 3
  %48 = load %struct.urb*, %struct.urb** %urb, align 8, !tbaa !254
  %call220 = call i32 bitcast (i32 (%struct.urb.824*, i32)* @usb_submit_urb to i32 (%struct.urb*, i32)*)(%struct.urb* %48, i32 16)
  %cmp221 = icmp slt i32 %call220, 0
  br i1 %cmp221, label %if.then223, label %if.end226

if.then223:                                       ; preds = %init3
  %49 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end226

if.end226:                                        ; preds = %if.then223, %init3
  %has_indicators = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %bf.load227 = load i8, i8* %has_indicators, align 4
  %bf.lshr228 = lshr i8 %bf.load227, 4
  %bf.clear229 = and i8 %bf.lshr228, 1
  %bf.cast230 = zext i8 %bf.clear229 to i32
  %tobool231 = icmp ne i32 %bf.cast230, 0
  br i1 %tobool231, label %land.lhs.true232, label %if.end237

land.lhs.true232:                                 ; preds = %if.end226
  %50 = load i8, i8* @blinkenlights, align 1, !tbaa !43, !range !44
  %tobool233 = trunc i8 %50 to i1
  br i1 %tobool233, label %if.then235, label %if.end237

if.then235:                                       ; preds = %land.lhs.true232
  %leds = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 20
  call void @schedule_delayed_work(%struct.delayed_work* %leds, i64 166)
  br label %if.end237

if.end237:                                        ; preds = %if.then235, %land.lhs.true232, %if.end226
  call void @kick_khubd(%struct.usb_hub* %hub)
  %cmp238 = icmp ule i32 %type, 2
  br i1 %cmp238, label %if.then240, label %cleanup.cont

if.then240:                                       ; preds = %if.end237
  %intfdev242 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %51 = load %struct.device*, %struct.device** %intfdev242, align 8, !tbaa !173
  %52 = bitcast %struct.device* %51 to i8*
  %add.ptr244 = getelementptr inbounds i8, i8* %52, i64 -48
  %53 = bitcast i8* %add.ptr244 to %struct.usb_interface*
  call void @usb_autopm_put_interface_async(%struct.usb_interface* %53)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then240, %if.end237, %do.body206, %if.then20
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hub_init_func2(%struct.work_struct* %ws) #0 {
entry:
  %0 = bitcast %struct.work_struct* %ws to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -736
  %1 = bitcast i8* %add.ptr to %struct.usb_hub*
  call void @hub_activate(%struct.usb_hub* %1, i32 1)
  ret void
}

declare i64 @msecs_to_jiffies(i32) #2

; Function Attrs: nounwind uwtable
define internal void @hub_init_func3(%struct.work_struct* %ws) #0 {
entry:
  %0 = bitcast %struct.work_struct* %ws to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -736
  %1 = bitcast i8* %add.ptr to %struct.usb_hub*
  call void @hub_activate(%struct.usb_hub* %1, i32 2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @check_ports_changed(%struct.usb_hub* %hub) #0 {
entry:
  %portstatus = alloca i16, align 2
  %portchange = alloca i16, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %port1.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %retval.0 = phi i32 [ undef, %entry ], [ %retval.1, %for.inc ]
  %hdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev, align 8, !tbaa !152
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %1 = load i32, i32* %maxchild, align 8, !tbaa !97
  %cmp = icmp sle i32 %port1.0, %1
  br i1 %cmp, label %for.body, label %cleanup4

for.body:                                         ; preds = %for.cond
  %2 = bitcast i16* %portstatus to i8*
  %3 = bitcast i16* %portchange to i8*
  %call = call i32 @hub_port_status(%struct.usb_hub* %hub, i32 %port1.0, i16* %portstatus, i16* %portchange)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %4 = load i16, i16* %portchange, align 2, !tbaa !143
  %conv = zext i16 %4 to i32
  %tobool1 = icmp ne i32 %conv, 0
  br i1 %tobool1, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %for.body
  br label %cleanup

cleanup:                                          ; preds = %if.end, %land.lhs.true
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end ], [ 1, %land.lhs.true ]
  %retval.1 = phi i32 [ %retval.0, %if.end ], [ 1, %land.lhs.true ]
  %5 = bitcast i16* %portchange to i8*
  %6 = bitcast i16* %portstatus to i8*
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup4

for.inc:                                          ; preds = %cleanup
  %inc = add nsw i32 %port1.0, 1
  br label %for.cond

cleanup4:                                         ; preds = %cleanup, %for.cond
  %retval.2 = phi i32 [ 0, %for.cond ], [ %retval.1, %cleanup ]
  ret i32 %retval.2
}

declare void @pm_wakeup_event(%struct.device*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_device* @interface_to_usbdev(%struct.usb_interface* %intf) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %parent, align 8, !tbaa !282
  %1 = bitcast %struct.device* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -136
  %2 = bitcast i8* %add.ptr to %struct.usb_device*
  ret %struct.usb_device* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_set_intfdata(%struct.usb_interface* %intf, i8* %data) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i32 @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_suspend_ignore_children(%struct.device* %dev, i1 zeroext %enable) #1 {
entry:
  %frombool = zext i1 %enable to i8
  %tobool = trunc i8 %frombool to i1
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %ignore_children = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %0 = zext i1 %tobool to i8
  %bf.load = load i8, i8* %ignore_children, align 4
  %bf.shl = shl i8 %0, 4
  %bf.clear = and i8 %bf.load, -17
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, i8* %ignore_children, align 4
  ret void
}

declare i32 @dev_set_drvdata(%struct.device*, i8*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_is_int_in(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %call = call i32 @usb_endpoint_xfer_int(%struct.usb_endpoint_descriptor* %epd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %call1 = call i32 @usb_endpoint_dir_in(%struct.usb_endpoint_descriptor* %epd)
  %tobool2 = icmp ne i32 %call1, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %0 = phi i1 [ false, %entry ], [ %tobool2, %land.rhs ]
  %land.ext = zext i1 %0 to i32
  ret i32 %land.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.29(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_init(%struct.arch_spinlock* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  call void @atomic_set.30(%union.anon.5* %refcount, i32 1)
  ret void
}

declare void @__init_work(%struct.work_struct*, i32) #2

declare void @lockdep_init_map(%struct.lockdep_map*, i8*, %struct.lock_class_key*, i32) #2

; Function Attrs: nounwind uwtable
define internal void @led_work(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -512
  %1 = bitcast i8* %add.ptr to %struct.usb_hub*
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !152
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 3
  %3 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp ne i32 %3, 7
  br i1 %cmp, label %cleanup.cont43, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %quiescing = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 18
  %bf.load = load i8, i8* %quiescing, align 4
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %cleanup.cont43, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock14, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %LeafBlock14 ]
  %changed.0 = phi i32 [ 0, %if.end ], [ %changed.2, %LeafBlock14 ]
  %cursor.0 = phi i32 [ -1, %if.end ], [ %cursor.2, %LeafBlock14 ]
  %descriptor = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 15
  %4 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !204
  %bNbrPorts = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %4, i32 0, i32 2
  %5 = load i8, i8* %bNbrPorts, align 1, !tbaa !250
  %conv = zext i8 %5 to i32
  %cmp2 = icmp ult i32 %i.0, %conv
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %indicator = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 19
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [31 x i8], [31 x i8]* %indicator, i64 0, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1, !tbaa !84
  %conv4 = zext i8 %6 to i32
  %Pivot12 = icmp slt i32 %conv4, 4
  br i1 %Pivot12, label %NodeBlock1, label %NodeBlock9

NodeBlock9:                                       ; preds = %for.body
  %Pivot10 = icmp slt i32 %conv4, 6
  br i1 %Pivot10, label %NodeBlock3, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %conv4, 7
  br i1 %Pivot8, label %sw.epilog, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %conv4, 7
  br i1 %SwitchLeaf6, label %sw.epilog, label %LeafBlock14

NodeBlock3:                                       ; preds = %NodeBlock9
  %Pivot4 = icmp slt i32 %conv4, 5
  %. = select i1 %Pivot4, i32 1, i32 3
  %.16 = select i1 %Pivot4, i32 5, i32 4
  br label %sw.epilog

NodeBlock1:                                       ; preds = %for.body
  %Pivot2 = icmp slt i32 %conv4, 2
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %conv4, 3
  %.17 = select i1 %Pivot, i32 2, i32 3
  %.18 = select i1 %Pivot, i32 3, i32 2
  br label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %conv4, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %LeafBlock14

sw.epilog:                                        ; preds = %LeafBlock, %NodeBlock, %NodeBlock3, %LeafBlock5, %NodeBlock7
  %cursor.1 = phi i32 [ %cursor.0, %NodeBlock3 ], [ %cursor.0, %NodeBlock ], [ %i.0, %LeafBlock ], [ %cursor.0, %NodeBlock7 ], [ %cursor.0, %LeafBlock5 ]
  %selector.0 = phi i32 [ %., %NodeBlock3 ], [ %.17, %NodeBlock ], [ 0, %LeafBlock ], [ 2, %NodeBlock7 ], [ 1, %LeafBlock5 ]
  %mode.0 = phi i32 [ %.16, %NodeBlock3 ], [ %.18, %NodeBlock ], [ 0, %LeafBlock ], [ 7, %NodeBlock7 ], [ 6, %LeafBlock5 ]
  %cmp11 = icmp ne i32 %selector.0, 0
  %.changed.0 = select i1 %cmp11, i32 1, i32 %changed.0
  %add = add i32 %i.0, 1
  call void @set_port_led(%struct.usb_hub* %1, i32 %add, i32 %selector.0)
  %conv15 = trunc i32 %mode.0 to i8
  %indicator16 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 19
  %idxprom17 = zext i32 %i.0 to i64
  %arrayidx18 = getelementptr inbounds [31 x i8], [31 x i8]* %indicator16, i64 0, i64 %idxprom17
  store i8 %conv15, i8* %arrayidx18, align 1, !tbaa !84
  br label %LeafBlock14

LeafBlock14:                                      ; preds = %sw.epilog, %LeafBlock, %LeafBlock5
  %changed.2 = phi i32 [ %.changed.0, %sw.epilog ], [ %changed.0, %LeafBlock ], [ %changed.0, %LeafBlock5 ]
  %cursor.2 = phi i32 [ %cursor.1, %sw.epilog ], [ %cursor.0, %LeafBlock ], [ %cursor.0, %LeafBlock5 ]
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool20 = icmp ne i32 %changed.0, 0
  br i1 %tobool20, label %if.end33, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.end
  %7 = load i8, i8* @blinkenlights, align 1, !tbaa !43, !range !44
  %tobool21 = trunc i8 %7 to i1
  br i1 %tobool21, label %if.then23, label %if.end33

if.then23:                                        ; preds = %land.lhs.true
  %inc24 = add nsw i32 %cursor.0, 1
  %descriptor25 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 15
  %8 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor25, align 8, !tbaa !204
  %bNbrPorts26 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %8, i32 0, i32 2
  %9 = load i8, i8* %bNbrPorts26, align 1, !tbaa !250
  %conv27 = zext i8 %9 to i32
  %rem = srem i32 %inc24, %conv27
  %add28 = add nsw i32 %rem, 1
  call void @set_port_led(%struct.usb_hub* %1, i32 %add28, i32 2)
  %indicator29 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 19
  %idxprom30 = sext i32 %rem to i64
  %arrayidx31 = getelementptr inbounds [31 x i8], [31 x i8]* %indicator29, i64 0, i64 %idxprom30
  store i8 1, i8* %arrayidx31, align 1, !tbaa !84
  %inc32 = add i32 %changed.0, 1
  br label %if.end33

if.end33:                                         ; preds = %if.then23, %land.lhs.true, %for.end
  %changed.3 = phi i32 [ %changed.0, %for.end ], [ %inc32, %if.then23 ], [ %changed.0, %land.lhs.true ]
  %tobool34 = icmp ne i32 %changed.3, 0
  br i1 %tobool34, label %if.then35, label %cleanup.cont43

if.then35:                                        ; preds = %if.end33
  %leds = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 20
  call void @schedule_delayed_work(%struct.delayed_work* %leds, i64 166)
  br label %cleanup.cont43

cleanup.cont43:                                   ; preds = %if.then35, %if.end33, %lor.lhs.false, %entry
  ret void
}

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) #2

declare void @delayed_work_timer_fn(i64) #2

; Function Attrs: nounwind uwtable
define internal i32 @hub_configure(%struct.usb_hub* %hub, %struct.usb_endpoint_descriptor* %endpoint) #0 {
entry:
  %hubstatus = alloca i16, align 2
  %hubchange = alloca i16, align 2
  %portstr = alloca [32 x i8], align 16
  %.compoundliteral = alloca %struct.pgprot, align 8
  %hdev1 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %hdev1, align 8, !tbaa !152
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 0
  %1 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !173
  %2 = bitcast i16* %hubstatus to i8*
  %3 = bitcast i16* %hubchange to i8*
  %call.i2 = call i8* @__kmalloc(i64 8, i32 208) #8
  %4 = bitcast i8* %call.i2 to [8 x i8]*
  %buffer = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 4
  store [8 x i8]* %4, [8 x i8]** %buffer, align 8, !tbaa !278
  %buffer2 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 4
  %5 = load [8 x i8]*, [8 x i8]** %buffer2, align 8, !tbaa !278
  %tobool = icmp ne [8 x i8]* %5, null
  br i1 %tobool, label %if.end, label %fail

if.end:                                           ; preds = %entry
  %call.i1 = call i8* @__kmalloc(i64 4, i32 208) #8
  %6 = bitcast i8* %call.i1 to %union.anon.48*
  %status = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  store %union.anon.48* %6, %union.anon.48** %status, align 8, !tbaa !176
  %status4 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 5
  %7 = load %union.anon.48*, %union.anon.48** %status4, align 8, !tbaa !176
  %tobool5 = icmp ne %union.anon.48* %7, null
  br i1 %tobool5, label %do.body, label %fail

do.body:                                          ; preds = %if.end
  %status_mutex = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 6
  call void @__mutex_init(%struct.mutex* %status_mutex, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.111, i32 0, i32 0), %struct.lock_class_key* @hub_configure.__key)
  %call.i = call i8* @__kmalloc(i64 15, i32 208) #8
  %8 = bitcast i8* %call.i to %struct.usb_hub_descriptor*
  %descriptor = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  store %struct.usb_hub_descriptor* %8, %struct.usb_hub_descriptor** %descriptor, align 8, !tbaa !204
  %descriptor9 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %9 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor9, align 8, !tbaa !204
  %tobool10 = icmp ne %struct.usb_hub_descriptor* %9, null
  br i1 %tobool10, label %if.end12, label %fail

if.end12:                                         ; preds = %do.body
  %descriptor13 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %10 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor13, align 8, !tbaa !204
  %11 = bitcast %struct.usb_hub_descriptor* %10 to i8*
  %call14 = call i32 @get_hub_descriptor(%struct.usb_device* %0, i8* %11)
  %cmp = icmp slt i32 %call14, 0
  br i1 %cmp, label %fail, label %if.else

if.else:                                          ; preds = %if.end12
  %descriptor16 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %12 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor16, align 8, !tbaa !204
  %bNbrPorts = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %12, i32 0, i32 2
  %13 = load i8, i8* %bNbrPorts, align 1, !tbaa !250
  %conv = zext i8 %13 to i32
  %cmp17 = icmp sgt i32 %conv, 31
  br i1 %cmp17, label %fail, label %if.else20

if.else20:                                        ; preds = %if.else
  %descriptor21 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %14 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor21, align 8, !tbaa !204
  %bNbrPorts22 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %14, i32 0, i32 2
  %15 = load i8, i8* %bNbrPorts22, align 1, !tbaa !250
  %conv23 = zext i8 %15 to i32
  %cmp24 = icmp eq i32 %conv23, 0
  br i1 %cmp24, label %fail, label %if.end29

if.end29:                                         ; preds = %if.else20
  %descriptor30 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %16 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor30, align 8, !tbaa !204
  %bNbrPorts31 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %16, i32 0, i32 2
  %17 = load i8, i8* %bNbrPorts31, align 1, !tbaa !250
  %conv32 = zext i8 %17 to i32
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  store i32 %conv32, i32* %maxchild, align 8, !tbaa !97
  %18 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %maxchild38 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %19 = load i32, i32* %maxchild38, align 8, !tbaa !97
  %conv39 = sext i32 %19 to i64
  %mul = mul i64 %conv39, 8
  %call40 = call i8* @kzalloc.29(i64 %mul, i32 208)
  %20 = bitcast i8* %call40 to %struct.usb_port**
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  store %struct.usb_port** %20, %struct.usb_port*** %ports, align 8, !tbaa !98
  %ports41 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 22
  %21 = load %struct.usb_port**, %struct.usb_port*** %ports41, align 8, !tbaa !98
  %tobool42 = icmp ne %struct.usb_port** %21, null
  br i1 %tobool42, label %if.end44, label %fail

if.end44:                                         ; preds = %if.end29
  %descriptor45 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %22 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor45, align 8, !tbaa !204
  %wHubCharacteristics46 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %22, i32 0, i32 3
  %23 = load i16, i16* %wHubCharacteristics46, align 1, !tbaa !225
  %call47 = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool48 = icmp ne i32 %call47, 0
  %. = select i1 %tobool48, i32 150, i32 100
  %.46 = select i1 %tobool48, i32 900, i32 500
  %conv52 = zext i16 %23 to i32
  %and = and i32 %conv52, 4
  %tobool53 = icmp ne i32 %and, 0
  br i1 %tobool53, label %land.lhs.true, label %do.body89

land.lhs.true:                                    ; preds = %if.end44
  %call54 = call i32 @hub_is_superspeed(%struct.usb_device* %0)
  %tobool55 = icmp ne i32 %call54, 0
  br i1 %tobool55, label %do.body89, label %if.then56

if.then56:                                        ; preds = %land.lhs.true
  %24 = bitcast [32 x i8]* %portstr to i8*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then56
  %i57.0 = phi i32 [ 0, %if.then56 ], [ %inc, %for.body ]
  %maxchild58 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %25 = load i32, i32* %maxchild58, align 8, !tbaa !97
  %cmp59 = icmp slt i32 %i57.0, %25
  br i1 %cmp59, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %descriptor61 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %26 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor61, align 8, !tbaa !204
  %u = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %26, i32 0, i32 6
  %hs = bitcast %union.anon.49* %u to %struct.anon.50*
  %DeviceRemovable = getelementptr inbounds %struct.anon.50, %struct.anon.50* %hs, i32 0, i32 0
  %add = add nsw i32 %i57.0, 1
  %div = sdiv i32 %add, 8
  %idxprom = sext i32 %div to i64
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* %DeviceRemovable, i64 0, i64 %idxprom
  %27 = load i8, i8* %arrayidx, align 1, !tbaa !84
  %conv62 = zext i8 %27 to i32
  %add63 = add nsw i32 %i57.0, 1
  %rem = srem i32 %add63, 8
  %shl = shl i32 1, %rem
  %and64 = and i32 %conv62, %shl
  %tobool65 = icmp ne i32 %and64, 0
  %cond66 = select i1 %tobool65, i32 70, i32 82
  %conv67 = trunc i32 %cond66 to i8
  %idxprom68 = sext i32 %i57.0 to i64
  %arrayidx69 = getelementptr inbounds [32 x i8], [32 x i8]* %portstr, i64 0, i64 %idxprom68
  store i8 %conv67, i8* %arrayidx69, align 1, !tbaa !84
  %inc = add nsw i32 %i57.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %maxchild70 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %28 = load i32, i32* %maxchild70, align 8, !tbaa !97
  %idxprom71 = sext i32 %28 to i64
  %arrayidx72 = getelementptr inbounds [32 x i8], [32 x i8]* %portstr, i64 0, i64 %idxprom71
  store i8 0, i8* %arrayidx72, align 1, !tbaa !84
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and75 = and i32 %bf.clear, 1
  %tobool76 = icmp ne i32 %and75, 0
  %lnot = xor i1 %tobool76, true
  %lnot77 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot77 to i32
  %conv78 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv78, i64 0)
  %tobool79 = icmp ne i64 %expval, 0
  br i1 %tobool79, label %if.then80, label %do.end86

if.then80:                                        ; preds = %for.end
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %portstr, i32 0, i32 0
  %call81 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.117, i32 0, i32 0), i8* %arraydecay)
  br label %do.end86

do.end86:                                         ; preds = %if.then80, %for.end
  %29 = bitcast [32 x i8]* %portstr to i8*
  br label %if.end109

do.body89:                                        ; preds = %land.lhs.true, %if.end44
  %bf.load90 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.118 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr91 = lshr i32 %bf.load90, 18
  %bf.clear92 = and i32 %bf.lshr91, 255
  %and93 = and i32 %bf.clear92, 1
  %tobool94 = icmp ne i32 %and93, 0
  %lnot95 = xor i1 %tobool94, true
  %lnot97 = xor i1 %lnot95, true
  %lnot.ext98 = zext i1 %lnot97 to i32
  %conv99 = sext i32 %lnot.ext98 to i64
  %expval100 = call i64 @llvm.expect.i64(i64 %conv99, i64 0)
  %tobool101 = icmp ne i64 %expval100, 0
  br i1 %tobool101, label %if.then102, label %if.end109

if.then102:                                       ; preds = %do.body89
  %call103 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.118 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.119, i32 0, i32 0))
  br label %if.end109

if.end109:                                        ; preds = %if.then102, %do.body89, %do.end86
  %conv110 = zext i16 %23 to i32
  %and111 = and i32 %conv110, 3
  %Pivot4 = icmp slt i32 %and111, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end109
  %Pivot = icmp slt i32 %and111, 2
  br i1 %Pivot, label %do.body135, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %and111.off = add i32 %and111, -2
  %SwitchLeaf2 = icmp ule i32 %and111.off, 1
  br i1 %SwitchLeaf2, label %do.body157, label %sw.epilog

LeafBlock:                                        ; preds = %if.end109
  %SwitchLeaf = icmp eq i32 %and111, 0
  br i1 %SwitchLeaf, label %do.body113, label %sw.epilog

do.body113:                                       ; preds = %LeafBlock
  %bf.load114 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.120 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr115 = lshr i32 %bf.load114, 18
  %bf.clear116 = and i32 %bf.lshr115, 255
  %and117 = and i32 %bf.clear116, 1
  %tobool118 = icmp ne i32 %and117, 0
  %lnot119 = xor i1 %tobool118, true
  %lnot121 = xor i1 %lnot119, true
  %lnot.ext122 = zext i1 %lnot121 to i32
  %conv123 = sext i32 %lnot.ext122 to i64
  %expval124 = call i64 @llvm.expect.i64(i64 %conv123, i64 0)
  %tobool125 = icmp ne i64 %expval124, 0
  br i1 %tobool125, label %if.then126, label %sw.epilog

if.then126:                                       ; preds = %do.body113
  %call127 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.120 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.121, i32 0, i32 0))
  br label %sw.epilog

do.body135:                                       ; preds = %NodeBlock
  %bf.load136 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.122 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr137 = lshr i32 %bf.load136, 18
  %bf.clear138 = and i32 %bf.lshr137, 255
  %and139 = and i32 %bf.clear138, 1
  %tobool140 = icmp ne i32 %and139, 0
  %lnot141 = xor i1 %tobool140, true
  %lnot143 = xor i1 %lnot141, true
  %lnot.ext144 = zext i1 %lnot143 to i32
  %conv145 = sext i32 %lnot.ext144 to i64
  %expval146 = call i64 @llvm.expect.i64(i64 %conv145, i64 0)
  %tobool147 = icmp ne i64 %expval146, 0
  br i1 %tobool147, label %if.then148, label %sw.epilog

if.then148:                                       ; preds = %do.body135
  %call149 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.122 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.123, i32 0, i32 0))
  br label %sw.epilog

do.body157:                                       ; preds = %LeafBlock1
  %bf.load158 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.124 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr159 = lshr i32 %bf.load158, 18
  %bf.clear160 = and i32 %bf.lshr159, 255
  %and161 = and i32 %bf.clear160, 1
  %tobool162 = icmp ne i32 %and161, 0
  %lnot163 = xor i1 %tobool162, true
  %lnot165 = xor i1 %lnot163, true
  %lnot.ext166 = zext i1 %lnot165 to i32
  %conv167 = sext i32 %lnot.ext166 to i64
  %expval168 = call i64 @llvm.expect.i64(i64 %conv167, i64 0)
  %tobool169 = icmp ne i64 %expval168, 0
  br i1 %tobool169, label %if.then170, label %sw.epilog

if.then170:                                       ; preds = %do.body157
  %call171 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.124 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.125, i32 0, i32 0))
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then170, %do.body157, %if.then148, %do.body135, %if.then126, %do.body113, %LeafBlock, %LeafBlock1
  %conv177 = zext i16 %23 to i32
  %and178 = and i32 %conv177, 24
  %Pivot19 = icmp slt i32 %and178, 16
  br i1 %Pivot19, label %NodeBlock10, label %NodeBlock16

NodeBlock16:                                      ; preds = %sw.epilog
  %Pivot17 = icmp slt i32 %and178, 24
  br i1 %Pivot17, label %LeafBlock12, label %LeafBlock14

LeafBlock14:                                      ; preds = %NodeBlock16
  %SwitchLeaf15 = icmp eq i32 %and178, 24
  br i1 %SwitchLeaf15, label %do.body225, label %do.body246

LeafBlock12:                                      ; preds = %NodeBlock16
  %SwitchLeaf13 = icmp eq i32 %and178, 16
  br i1 %SwitchLeaf13, label %do.body225, label %do.body246

NodeBlock10:                                      ; preds = %sw.epilog
  %Pivot11 = icmp slt i32 %and178, 8
  br i1 %Pivot11, label %LeafBlock6, label %LeafBlock8

LeafBlock8:                                       ; preds = %NodeBlock10
  %SwitchLeaf9 = icmp eq i32 %and178, 8
  br i1 %SwitchLeaf9, label %do.body203, label %do.body246

LeafBlock6:                                       ; preds = %NodeBlock10
  %SwitchLeaf7 = icmp eq i32 %and178, 0
  br i1 %SwitchLeaf7, label %do.body181, label %do.body246

do.body181:                                       ; preds = %LeafBlock6
  %bf.load182 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.126 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr183 = lshr i32 %bf.load182, 18
  %bf.clear184 = and i32 %bf.lshr183, 255
  %and185 = and i32 %bf.clear184, 1
  %tobool186 = icmp ne i32 %and185, 0
  %lnot187 = xor i1 %tobool186, true
  %lnot189 = xor i1 %lnot187, true
  %lnot.ext190 = zext i1 %lnot189 to i32
  %conv191 = sext i32 %lnot.ext190 to i64
  %expval192 = call i64 @llvm.expect.i64(i64 %conv191, i64 0)
  %tobool193 = icmp ne i64 %expval192, 0
  br i1 %tobool193, label %if.then194, label %do.body246

if.then194:                                       ; preds = %do.body181
  %call195 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.126 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.127, i32 0, i32 0))
  br label %do.body246

do.body203:                                       ; preds = %LeafBlock8
  %bf.load204 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.128 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr205 = lshr i32 %bf.load204, 18
  %bf.clear206 = and i32 %bf.lshr205, 255
  %and207 = and i32 %bf.clear206, 1
  %tobool208 = icmp ne i32 %and207, 0
  %lnot209 = xor i1 %tobool208, true
  %lnot211 = xor i1 %lnot209, true
  %lnot.ext212 = zext i1 %lnot211 to i32
  %conv213 = sext i32 %lnot.ext212 to i64
  %expval214 = call i64 @llvm.expect.i64(i64 %conv213, i64 0)
  %tobool215 = icmp ne i64 %expval214, 0
  br i1 %tobool215, label %if.then216, label %do.body246

if.then216:                                       ; preds = %do.body203
  %call217 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.128 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.129, i32 0, i32 0))
  br label %do.body246

do.body225:                                       ; preds = %LeafBlock12, %LeafBlock14
  %bf.load226 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.130 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr227 = lshr i32 %bf.load226, 18
  %bf.clear228 = and i32 %bf.lshr227, 255
  %and229 = and i32 %bf.clear228, 1
  %tobool230 = icmp ne i32 %and229, 0
  %lnot231 = xor i1 %tobool230, true
  %lnot233 = xor i1 %lnot231, true
  %lnot.ext234 = zext i1 %lnot233 to i32
  %conv235 = sext i32 %lnot.ext234 to i64
  %expval236 = call i64 @llvm.expect.i64(i64 %conv235, i64 0)
  %tobool237 = icmp ne i64 %expval236, 0
  br i1 %tobool237, label %if.then238, label %do.body246

if.then238:                                       ; preds = %do.body225
  %call239 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.130 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.131, i32 0, i32 0))
  br label %do.body246

do.body246:                                       ; preds = %if.then238, %do.body225, %if.then216, %do.body203, %if.then194, %do.body181, %LeafBlock6, %LeafBlock8, %LeafBlock12, %LeafBlock14
  %tt = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %lock = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt, i32 0, i32 3
  %call247 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %tt249 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %lock250 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt249, i32 0, i32 3
  %30 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock250, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %30 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.133, i32 0, i32 0), %struct.lock_class_key* @hub_configure.__key.132)
  %tt255 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %clear_list = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt255, i32 0, i32 4
  call void @INIT_LIST_HEAD.28(%struct.list_head* %clear_list)
  %tt258 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %clear_work = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt258, i32 0, i32 5
  call void @__init_work(%struct.work_struct* %clear_work, i32 0)
  %tt259 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %clear_work260 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt259, i32 0, i32 5
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %clear_work260, i32 0, i32 0
  %counter = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !272
  %31 = bitcast %struct.pgprot* %data to i8*
  %32 = bitcast %struct.pgprot* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %31, i8* %32, i64 8, i32 8, i1 false), !tbaa.struct !273
  %tt261 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %clear_work262 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt261, i32 0, i32 5
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %clear_work262, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.135, i32 0, i32 0), %struct.lock_class_key* @hub_configure.__key.134, i32 0)
  %tt263 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %clear_work264 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt263, i32 0, i32 5
  %entry265 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %clear_work264, i32 0, i32 1
  call void @INIT_LIST_HEAD.28(%struct.list_head* %entry265)
  %tt267 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %clear_work268 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt267, i32 0, i32 5
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %clear_work268, i32 0, i32 2
  store void (%struct.work_struct*)* @hub_tt_work, void (%struct.work_struct*)** %func, align 8, !tbaa !274
  %descriptor275 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 12
  %bDeviceProtocol = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor275, i32 0, i32 5
  %33 = load i8, i8* %bDeviceProtocol, align 2, !tbaa !175
  %conv276 = zext i8 %33 to i32
  %Pivot30 = icmp slt i32 %conv276, 2
  br i1 %Pivot30, label %NodeBlock23, label %NodeBlock27

NodeBlock27:                                      ; preds = %do.body246
  %Pivot28 = icmp slt i32 %conv276, 3
  br i1 %Pivot28, label %sw.bb301, label %LeafBlock25

LeafBlock25:                                      ; preds = %NodeBlock27
  %SwitchLeaf26 = icmp eq i32 %conv276, 3
  br i1 %SwitchLeaf26, label %sw.epilog357, label %do.body334

NodeBlock23:                                      ; preds = %do.body246
  %Pivot24 = icmp slt i32 %conv276, 1
  br i1 %Pivot24, label %LeafBlock21, label %do.body279

LeafBlock21:                                      ; preds = %NodeBlock23
  %SwitchLeaf22 = icmp eq i32 %conv276, 0
  br i1 %SwitchLeaf22, label %sw.epilog357, label %do.body334

do.body279:                                       ; preds = %NodeBlock23
  %bf.load280 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.136 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr281 = lshr i32 %bf.load280, 18
  %bf.clear282 = and i32 %bf.lshr281, 255
  %and283 = and i32 %bf.clear282, 1
  %tobool284 = icmp ne i32 %and283, 0
  %lnot285 = xor i1 %tobool284, true
  %lnot287 = xor i1 %lnot285, true
  %lnot.ext288 = zext i1 %lnot287 to i32
  %conv289 = sext i32 %lnot.ext288 to i64
  %expval290 = call i64 @llvm.expect.i64(i64 %conv289, i64 0)
  %tobool291 = icmp ne i64 %expval290, 0
  br i1 %tobool291, label %if.then292, label %do.end298

if.then292:                                       ; preds = %do.body279
  %call293 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.136 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.137, i32 0, i32 0))
  br label %do.end298

do.end298:                                        ; preds = %if.then292, %do.body279
  %tt299 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %hub300 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt299, i32 0, i32 0
  store %struct.usb_device* %0, %struct.usb_device** %hub300, align 8, !tbaa !158
  br label %sw.epilog357

sw.bb301:                                         ; preds = %NodeBlock27
  %call302 = call i32 @usb_set_interface(%struct.usb_device* %0, i32 0, i32 1)
  %cmp303 = icmp eq i32 %call302, 0
  br i1 %cmp303, label %do.body307, label %if.else328

do.body307:                                       ; preds = %sw.bb301
  %bf.load308 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.138 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr309 = lshr i32 %bf.load308, 18
  %bf.clear310 = and i32 %bf.lshr309, 255
  %and311 = and i32 %bf.clear310, 1
  %tobool312 = icmp ne i32 %and311, 0
  %lnot313 = xor i1 %tobool312, true
  %lnot315 = xor i1 %lnot313, true
  %lnot.ext316 = zext i1 %lnot315 to i32
  %conv317 = sext i32 %lnot.ext316 to i64
  %expval318 = call i64 @llvm.expect.i64(i64 %conv317, i64 0)
  %tobool319 = icmp ne i64 %expval318, 0
  br i1 %tobool319, label %if.then320, label %do.end326

if.then320:                                       ; preds = %do.body307
  %call321 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.138 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.139, i32 0, i32 0))
  br label %do.end326

do.end326:                                        ; preds = %if.then320, %do.body307
  %tt327 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %multi = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt327, i32 0, i32 1
  store i32 1, i32* %multi, align 8, !tbaa !283
  br label %if.end330

if.else328:                                       ; preds = %sw.bb301
  %34 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end330

if.end330:                                        ; preds = %if.else328, %do.end326
  %tt331 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %hub332 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt331, i32 0, i32 0
  store %struct.usb_device* %0, %struct.usb_device** %hub332, align 8, !tbaa !158
  br label %sw.epilog357

do.body334:                                       ; preds = %LeafBlock21, %LeafBlock25
  %bf.load335 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.141 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr336 = lshr i32 %bf.load335, 18
  %bf.clear337 = and i32 %bf.lshr336, 255
  %and338 = and i32 %bf.clear337, 1
  %tobool339 = icmp ne i32 %and338, 0
  %lnot340 = xor i1 %tobool339, true
  %lnot342 = xor i1 %lnot340, true
  %lnot.ext343 = zext i1 %lnot342 to i32
  %conv344 = sext i32 %lnot.ext343 to i64
  %expval345 = call i64 @llvm.expect.i64(i64 %conv344, i64 0)
  %tobool346 = icmp ne i64 %expval345, 0
  br i1 %tobool346, label %if.then347, label %sw.epilog357

if.then347:                                       ; preds = %do.body334
  %descriptor348 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 12
  %bDeviceProtocol349 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor348, i32 0, i32 5
  %35 = load i8, i8* %bDeviceProtocol349, align 2, !tbaa !175
  %conv350 = zext i8 %35 to i32
  %call351 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.141 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.142, i32 0, i32 0), i32 %conv350)
  br label %sw.epilog357

sw.epilog357:                                     ; preds = %if.then347, %do.body334, %if.end330, %do.end298, %LeafBlock21, %LeafBlock25
  %conv358 = zext i16 %23 to i32
  %and359 = and i32 %conv358, 96
  %Pivot45 = icmp slt i32 %and359, 64
  br i1 %Pivot45, label %NodeBlock36, label %NodeBlock42

NodeBlock42:                                      ; preds = %sw.epilog357
  %Pivot43 = icmp slt i32 %and359, 96
  br i1 %Pivot43, label %LeafBlock38, label %LeafBlock40

LeafBlock40:                                      ; preds = %NodeBlock42
  %SwitchLeaf41 = icmp eq i32 %and359, 96
  br i1 %SwitchLeaf41, label %sw.bb444, label %sw.epilog470

LeafBlock38:                                      ; preds = %NodeBlock42
  %SwitchLeaf39 = icmp eq i32 %and359, 64
  br i1 %SwitchLeaf39, label %sw.bb418, label %sw.epilog470

NodeBlock36:                                      ; preds = %sw.epilog357
  %Pivot37 = icmp slt i32 %and359, 32
  br i1 %Pivot37, label %LeafBlock32, label %LeafBlock34

LeafBlock34:                                      ; preds = %NodeBlock36
  %SwitchLeaf35 = icmp eq i32 %and359, 32
  br i1 %SwitchLeaf35, label %sw.bb392, label %sw.epilog470

LeafBlock32:                                      ; preds = %NodeBlock36
  %SwitchLeaf33 = icmp eq i32 %and359, 0
  br i1 %SwitchLeaf33, label %sw.bb360, label %sw.epilog470

sw.bb360:                                         ; preds = %LeafBlock32
  %descriptor361 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 12
  %bDeviceProtocol362 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor361, i32 0, i32 5
  %36 = load i8, i8* %bDeviceProtocol362, align 2, !tbaa !175
  %conv363 = zext i8 %36 to i32
  %cmp364 = icmp ne i32 %conv363, 0
  br i1 %cmp364, label %if.then366, label %sw.epilog470

if.then366:                                       ; preds = %sw.bb360
  %tt367 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %think_time = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt367, i32 0, i32 2
  store i32 666, i32* %think_time, align 4, !tbaa !284
  %bf.load370 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.143 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr371 = lshr i32 %bf.load370, 18
  %bf.clear372 = and i32 %bf.lshr371, 255
  %and373 = and i32 %bf.clear372, 1
  %tobool374 = icmp ne i32 %and373, 0
  %lnot375 = xor i1 %tobool374, true
  %lnot377 = xor i1 %lnot375, true
  %lnot.ext378 = zext i1 %lnot377 to i32
  %conv379 = sext i32 %lnot.ext378 to i64
  %expval380 = call i64 @llvm.expect.i64(i64 %conv379, i64 0)
  %tobool381 = icmp ne i64 %expval380, 0
  br i1 %tobool381, label %if.then382, label %sw.epilog470

if.then382:                                       ; preds = %if.then366
  %tt383 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %think_time384 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt383, i32 0, i32 2
  %37 = load i32, i32* %think_time384, align 4, !tbaa !284
  %call385 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.143 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.144, i32 0, i32 0), i32 8, i32 %37)
  br label %sw.epilog470

sw.bb392:                                         ; preds = %LeafBlock34
  %tt393 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %think_time394 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt393, i32 0, i32 2
  store i32 1332, i32* %think_time394, align 4, !tbaa !284
  %bf.load397 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.145 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr398 = lshr i32 %bf.load397, 18
  %bf.clear399 = and i32 %bf.lshr398, 255
  %and400 = and i32 %bf.clear399, 1
  %tobool401 = icmp ne i32 %and400, 0
  %lnot402 = xor i1 %tobool401, true
  %lnot404 = xor i1 %lnot402, true
  %lnot.ext405 = zext i1 %lnot404 to i32
  %conv406 = sext i32 %lnot.ext405 to i64
  %expval407 = call i64 @llvm.expect.i64(i64 %conv406, i64 0)
  %tobool408 = icmp ne i64 %expval407, 0
  br i1 %tobool408, label %if.then409, label %sw.epilog470

if.then409:                                       ; preds = %sw.bb392
  %tt410 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %think_time411 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt410, i32 0, i32 2
  %38 = load i32, i32* %think_time411, align 4, !tbaa !284
  %call412 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.145 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.144, i32 0, i32 0), i32 16, i32 %38)
  br label %sw.epilog470

sw.bb418:                                         ; preds = %LeafBlock38
  %tt419 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %think_time420 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt419, i32 0, i32 2
  store i32 1998, i32* %think_time420, align 4, !tbaa !284
  %bf.load423 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.146 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr424 = lshr i32 %bf.load423, 18
  %bf.clear425 = and i32 %bf.lshr424, 255
  %and426 = and i32 %bf.clear425, 1
  %tobool427 = icmp ne i32 %and426, 0
  %lnot428 = xor i1 %tobool427, true
  %lnot430 = xor i1 %lnot428, true
  %lnot.ext431 = zext i1 %lnot430 to i32
  %conv432 = sext i32 %lnot.ext431 to i64
  %expval433 = call i64 @llvm.expect.i64(i64 %conv432, i64 0)
  %tobool434 = icmp ne i64 %expval433, 0
  br i1 %tobool434, label %if.then435, label %sw.epilog470

if.then435:                                       ; preds = %sw.bb418
  %tt436 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %think_time437 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt436, i32 0, i32 2
  %39 = load i32, i32* %think_time437, align 4, !tbaa !284
  %call438 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.146 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.144, i32 0, i32 0), i32 24, i32 %39)
  br label %sw.epilog470

sw.bb444:                                         ; preds = %LeafBlock40
  %tt445 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %think_time446 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt445, i32 0, i32 2
  store i32 2664, i32* %think_time446, align 4, !tbaa !284
  %bf.load449 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.147 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr450 = lshr i32 %bf.load449, 18
  %bf.clear451 = and i32 %bf.lshr450, 255
  %and452 = and i32 %bf.clear451, 1
  %tobool453 = icmp ne i32 %and452, 0
  %lnot454 = xor i1 %tobool453, true
  %lnot456 = xor i1 %lnot454, true
  %lnot.ext457 = zext i1 %lnot456 to i32
  %conv458 = sext i32 %lnot.ext457 to i64
  %expval459 = call i64 @llvm.expect.i64(i64 %conv458, i64 0)
  %tobool460 = icmp ne i64 %expval459, 0
  br i1 %tobool460, label %if.then461, label %sw.epilog470

if.then461:                                       ; preds = %sw.bb444
  %tt462 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %think_time463 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt462, i32 0, i32 2
  %40 = load i32, i32* %think_time463, align 4, !tbaa !284
  %call464 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.147 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.144, i32 0, i32 0), i32 32, i32 %40)
  br label %sw.epilog470

sw.epilog470:                                     ; preds = %if.then461, %sw.bb444, %if.then435, %sw.bb418, %if.then409, %sw.bb392, %if.then382, %if.then366, %sw.bb360, %LeafBlock32, %LeafBlock34, %LeafBlock38, %LeafBlock40
  %conv471 = zext i16 %23 to i32
  %and472 = and i32 %conv471, 128
  %tobool473 = icmp ne i32 %and472, 0
  br i1 %tobool473, label %if.then474, label %do.body500

if.then474:                                       ; preds = %sw.epilog470
  %has_indicators = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %bf.load475 = load i8, i8* %has_indicators, align 4
  %bf.clear476 = and i8 %bf.load475, -17
  %bf.set = or i8 %bf.clear476, 16
  store i8 %bf.set, i8* %has_indicators, align 4
  %bf.load479 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.148 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr480 = lshr i32 %bf.load479, 18
  %bf.clear481 = and i32 %bf.lshr480, 255
  %and482 = and i32 %bf.clear481, 1
  %tobool483 = icmp ne i32 %and482, 0
  %lnot484 = xor i1 %tobool483, true
  %lnot486 = xor i1 %lnot484, true
  %lnot.ext487 = zext i1 %lnot486 to i32
  %conv488 = sext i32 %lnot.ext487 to i64
  %expval489 = call i64 @llvm.expect.i64(i64 %conv488, i64 0)
  %tobool490 = icmp ne i64 %expval489, 0
  br i1 %tobool490, label %if.then491, label %do.body500

if.then491:                                       ; preds = %if.then474
  %call492 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.148 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.149, i32 0, i32 0))
  br label %do.body500

do.body500:                                       ; preds = %if.then491, %if.then474, %sw.epilog470
  %bf.load501 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.150 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr502 = lshr i32 %bf.load501, 18
  %bf.clear503 = and i32 %bf.lshr502, 255
  %and504 = and i32 %bf.clear503, 1
  %tobool505 = icmp ne i32 %and504, 0
  %lnot506 = xor i1 %tobool505, true
  %lnot508 = xor i1 %lnot506, true
  %lnot.ext509 = zext i1 %lnot508 to i32
  %conv510 = sext i32 %lnot.ext509 to i64
  %expval511 = call i64 @llvm.expect.i64(i64 %conv510, i64 0)
  %tobool512 = icmp ne i64 %expval511, 0
  br i1 %tobool512, label %if.then513, label %do.end522

if.then513:                                       ; preds = %do.body500
  %descriptor514 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %41 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor514, align 8, !tbaa !204
  %bPwrOn2PwrGood = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %41, i32 0, i32 4
  %42 = load i8, i8* %bPwrOn2PwrGood, align 1, !tbaa !256
  %conv515 = zext i8 %42 to i32
  %mul516 = mul nsw i32 %conv515, 2
  %call517 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.150 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.151, i32 0, i32 0), i32 %mul516)
  br label %do.end522

do.end522:                                        ; preds = %if.then513, %do.body500
  %43 = bitcast i16* %hubstatus to i8*
  %call523 = call i32 @usb_get_status(%struct.usb_device* %0, i32 0, i32 0, i8* %43)
  %cmp524 = icmp slt i32 %call523, 2
  br i1 %cmp524, label %fail, label %do.end530

do.end530:                                        ; preds = %do.end522
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %44 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call531 = call %struct.usb_hcd* @bus_to_hcd.11(%struct.usb_bus* %44)
  %bus532 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %45 = load %struct.usb_bus*, %struct.usb_bus** %bus532, align 8, !tbaa !2
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %45, i32 0, i32 10
  %46 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !228
  %cmp533 = icmp eq %struct.usb_device* %0, %46
  br i1 %cmp533, label %if.then535, label %if.else560

if.then535:                                       ; preds = %do.end530
  %power_budget = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call531, i32 0, i32 16
  %47 = load i32, i32* %power_budget, align 8, !tbaa !285
  %cmp536 = icmp ugt i32 %47, 0
  br i1 %cmp536, label %if.then538, label %if.else541

if.then538:                                       ; preds = %if.then535
  %power_budget539 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call531, i32 0, i32 16
  %48 = load i32, i32* %power_budget539, align 8, !tbaa !285
  br label %if.end546

if.else541:                                       ; preds = %if.then535
  %maxchild542 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %49 = load i32, i32* %maxchild542, align 8, !tbaa !97
  %mul543 = mul i32 %.46, %49
  br label %if.end546

if.end546:                                        ; preds = %if.else541, %if.then538
  %mul543.sink = phi i32 [ %mul543, %if.else541 ], [ %48, %if.then538 ]
  %conv544 = trunc i32 %mul543.sink to i16
  %bus_mA545 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 19
  store i16 %conv544, i16* %bus_mA545, align 8, !tbaa !258
  %bus_mA547 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 19
  %50 = load i16, i16* %bus_mA547, align 8, !tbaa !258
  %conv548 = zext i16 %50 to i32
  %cmp549 = icmp uge i32 %conv548, %.46
  br i1 %cmp549, label %if.then551, label %if.else552

if.then551:                                       ; preds = %if.end546
  %mA_per_port = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  store i32 %.46, i32* %mA_per_port, align 8, !tbaa !257
  br label %if.end609

if.else552:                                       ; preds = %if.end546
  %bus_mA553 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 19
  %51 = load i16, i16* %bus_mA553, align 8, !tbaa !258
  %conv554 = zext i16 %51 to i32
  %mA_per_port555 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  store i32 %conv554, i32* %mA_per_port555, align 8, !tbaa !257
  %limited_power = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %bf.load556 = load i8, i8* %limited_power, align 4
  %bf.clear557 = and i8 %bf.load556, -2
  %bf.set558 = or i8 %bf.clear557, 1
  store i8 %bf.set558, i8* %limited_power, align 4
  br label %if.end609

if.else560:                                       ; preds = %do.end530
  %52 = load i16, i16* %hubstatus, align 2, !tbaa !143
  %conv561 = zext i16 %52 to i32
  %and562 = and i32 %conv561, 1
  %cmp563 = icmp eq i32 %and562, 0
  br i1 %cmp563, label %if.then565, label %if.end608

if.then565:                                       ; preds = %if.else560
  %bus_mA566 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 19
  %53 = load i16, i16* %bus_mA566, align 8, !tbaa !258
  %conv567 = zext i16 %53 to i32
  %descriptor568 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %54 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor568, align 8, !tbaa !204
  %bHubContrCurrent = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %54, i32 0, i32 5
  %55 = load i8, i8* %bHubContrCurrent, align 1, !tbaa !266
  %conv569 = zext i8 %55 to i32
  %sub = sub nsw i32 %conv567, %conv569
  %bf.load572 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.153 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr573 = lshr i32 %bf.load572, 18
  %bf.clear574 = and i32 %bf.lshr573, 255
  %and575 = and i32 %bf.clear574, 1
  %tobool576 = icmp ne i32 %and575, 0
  %lnot577 = xor i1 %tobool576, true
  %lnot579 = xor i1 %lnot577, true
  %lnot.ext580 = zext i1 %lnot579 to i32
  %conv581 = sext i32 %lnot.ext580 to i64
  %expval582 = call i64 @llvm.expect.i64(i64 %conv581, i64 0)
  %tobool583 = icmp ne i64 %expval582, 0
  br i1 %tobool583, label %if.then584, label %do.end593

if.then584:                                       ; preds = %if.then565
  %descriptor585 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %56 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor585, align 8, !tbaa !204
  %bHubContrCurrent586 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %56, i32 0, i32 5
  %57 = load i8, i8* %bHubContrCurrent586, align 1, !tbaa !266
  %conv587 = zext i8 %57 to i32
  %call588 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.153 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.154, i32 0, i32 0), i32 %conv587)
  br label %do.end593

do.end593:                                        ; preds = %if.then584, %if.then565
  %limited_power594 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %bf.load595 = load i8, i8* %limited_power594, align 4
  %bf.clear596 = and i8 %bf.load595, -2
  %bf.set597 = or i8 %bf.clear596, 1
  store i8 %bf.set597, i8* %limited_power594, align 4
  %maxchild598 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %58 = load i32, i32* %maxchild598, align 8, !tbaa !97
  %mul599 = mul i32 %58, %.
  %cmp600 = icmp ult i32 %sub, %mul599
  br i1 %cmp600, label %if.then602, label %if.end608

if.then602:                                       ; preds = %do.end593
  %59 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end608

if.end608:                                        ; preds = %if.then602, %do.end593, %if.else560
  %.46.sink = phi i32 [ %.46, %if.else560 ], [ %., %if.then602 ], [ %., %do.end593 ]
  %mA_per_port607 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  store i32 %.46.sink, i32* %mA_per_port607, align 8, !tbaa !257
  br label %if.end609

if.end609:                                        ; preds = %if.end608, %if.else552, %if.then551
  %mA_per_port610 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %60 = load i32, i32* %mA_per_port610, align 8, !tbaa !257
  %cmp611 = icmp ult i32 %60, %.46
  br i1 %cmp611, label %do.body615, label %if.end636

do.body615:                                       ; preds = %if.end609
  %bf.load616 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.156 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr617 = lshr i32 %bf.load616, 18
  %bf.clear618 = and i32 %bf.lshr617, 255
  %and619 = and i32 %bf.clear618, 1
  %tobool620 = icmp ne i32 %and619, 0
  %lnot621 = xor i1 %tobool620, true
  %lnot623 = xor i1 %lnot621, true
  %lnot.ext624 = zext i1 %lnot623 to i32
  %conv625 = sext i32 %lnot.ext624 to i64
  %expval626 = call i64 @llvm.expect.i64(i64 %conv625, i64 0)
  %tobool627 = icmp ne i64 %expval626, 0
  br i1 %tobool627, label %if.then628, label %if.end636

if.then628:                                       ; preds = %do.body615
  %mA_per_port629 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 17
  %61 = load i32, i32* %mA_per_port629, align 8, !tbaa !257
  %call630 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.156 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.157, i32 0, i32 0), i32 %61)
  br label %if.end636

if.end636:                                        ; preds = %if.then628, %do.body615, %if.end609
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call531, i32 0, i32 8
  %62 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %update_hub_device = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %62, i32 0, i32 35
  %63 = load i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)** %update_hub_device, align 8, !tbaa !281
  %tobool637 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)* %63, null
  br i1 %tobool637, label %if.then638, label %if.end647

if.then638:                                       ; preds = %if.end636
  %driver639 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call531, i32 0, i32 8
  %64 = load %struct.hc_driver*, %struct.hc_driver** %driver639, align 8, !tbaa !71
  %update_hub_device640 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %64, i32 0, i32 35
  %65 = load i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, %struct.usb_tt*, i32)** %update_hub_device640, align 8, !tbaa !281
  %tt641 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 16
  %call642 = call i32 %65(%struct.usb_hcd* %call531, %struct.usb_device* %0, %struct.usb_tt* %tt641, i32 208)
  %cmp643 = icmp slt i32 %call642, 0
  br i1 %cmp643, label %fail, label %if.end647

if.end647:                                        ; preds = %if.then638, %if.end636
  %call648 = call i32 @hub_hub_status(%struct.usb_hub* %hub, i16* %hubstatus, i16* %hubchange)
  %cmp649 = icmp slt i32 %call648, 0
  br i1 %cmp649, label %fail, label %if.end652

if.end652:                                        ; preds = %if.end647
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 15
  %66 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %66, i32 0, i32 0
  %bmAttributes = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 6
  %67 = load i8, i8* %bmAttributes, align 1, !tbaa !172
  %conv653 = zext i8 %67 to i32
  %and654 = and i32 %conv653, 64
  %tobool655 = icmp ne i32 %and654, 0
  br i1 %tobool655, label %do.body658, label %if.end682

do.body658:                                       ; preds = %if.end652
  %bf.load659 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.159 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr660 = lshr i32 %bf.load659, 18
  %bf.clear661 = and i32 %bf.lshr660, 255
  %and662 = and i32 %bf.clear661, 1
  %tobool663 = icmp ne i32 %and662, 0
  %lnot664 = xor i1 %tobool663, true
  %lnot666 = xor i1 %lnot664, true
  %lnot.ext667 = zext i1 %lnot666 to i32
  %conv668 = sext i32 %lnot.ext667 to i64
  %expval669 = call i64 @llvm.expect.i64(i64 %conv668, i64 0)
  %tobool670 = icmp ne i64 %expval669, 0
  br i1 %tobool670, label %if.then671, label %if.end682

if.then671:                                       ; preds = %do.body658
  %68 = load i16, i16* %hubstatus, align 2, !tbaa !143
  %conv672 = zext i16 %68 to i32
  %and673 = and i32 %conv672, 1
  %tobool674 = icmp ne i32 %and673, 0
  %cond675 = select i1 %tobool674, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.161, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.162, i32 0, i32 0)
  %call676 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.159 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.160, i32 0, i32 0), i8* %cond675)
  br label %if.end682

if.end682:                                        ; preds = %if.then671, %do.body658, %if.end652
  %conv683 = zext i16 %23 to i32
  %and684 = and i32 %conv683, 24
  %cmp685 = icmp eq i32 %and684, 0
  br i1 %cmp685, label %do.body689, label %if.end713

do.body689:                                       ; preds = %if.end682
  %bf.load690 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.163 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr691 = lshr i32 %bf.load690, 18
  %bf.clear692 = and i32 %bf.lshr691, 255
  %and693 = and i32 %bf.clear692, 1
  %tobool694 = icmp ne i32 %and693, 0
  %lnot695 = xor i1 %tobool694, true
  %lnot697 = xor i1 %lnot695, true
  %lnot.ext698 = zext i1 %lnot697 to i32
  %conv699 = sext i32 %lnot.ext698 to i64
  %expval700 = call i64 @llvm.expect.i64(i64 %conv699, i64 0)
  %tobool701 = icmp ne i64 %expval700, 0
  br i1 %tobool701, label %if.then702, label %if.end713

if.then702:                                       ; preds = %do.body689
  %69 = load i16, i16* %hubstatus, align 2, !tbaa !143
  %conv703 = zext i16 %69 to i32
  %and704 = and i32 %conv703, 2
  %tobool705 = icmp ne i32 %and704, 0
  %cond706 = select i1 %tobool705, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.27.821, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.165, i32 0, i32 0)
  %call707 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_configure.descriptor.163 to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.164, i32 0, i32 0), i8* %cond706)
  br label %if.end713

if.end713:                                        ; preds = %if.then702, %do.body689, %if.end682
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %endpoint, i32 0, i32 2
  %70 = load i8, i8* %bEndpointAddress, align 1, !tbaa !286
  %conv714 = zext i8 %70 to i32
  %call715 = call i32 @__create_pipe(%struct.usb_device* %0, i32 %conv714)
  %or = or i32 1073741824, %call715
  %or716 = or i32 %or, 128
  %and717 = and i32 %or716, 128
  %tobool718 = icmp ne i32 %and717, 0
  %lnot719 = xor i1 %tobool718, true
  %lnot.ext720 = zext i1 %lnot719 to i32
  %call721 = call zeroext i16 @usb_maxpacket(%struct.usb_device* %0, i32 %or716, i32 %lnot.ext720)
  %conv722 = zext i16 %call721 to i32
  %conv723 = sext i32 %conv722 to i64
  %cmp724 = icmp ugt i64 %conv723, 8
  %.conv722 = select i1 %cmp724, i32 8, i32 %conv722
  %call728 = call %struct.urb* bitcast (%struct.urb.824* (i32, i32)* @usb_alloc_urb to %struct.urb* (i32, i32)*)(i32 0, i32 208)
  %urb = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 3
  store %struct.urb* %call728, %struct.urb** %urb, align 8, !tbaa !254
  %urb729 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 3
  %71 = load %struct.urb*, %struct.urb** %urb729, align 8, !tbaa !254
  %tobool730 = icmp ne %struct.urb* %71, null
  br i1 %tobool730, label %if.end732, label %fail

if.end732:                                        ; preds = %if.end713
  %urb733 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 3
  %72 = load %struct.urb*, %struct.urb** %urb733, align 8, !tbaa !254
  %buffer734 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 4
  %73 = load [8 x i8]*, [8 x i8]** %buffer734, align 8, !tbaa !278
  %arraydecay735 = getelementptr inbounds [8 x i8], [8 x i8]* %73, i32 0, i32 0
  %74 = bitcast %struct.usb_hub* %hub to i8*
  %bInterval = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %endpoint, i32 0, i32 5
  %75 = load i8, i8* %bInterval, align 1, !tbaa !287
  %conv736 = zext i8 %75 to i32
  call void @usb_fill_int_urb(%struct.urb* %72, %struct.usb_device* %0, i32 %or716, i8* %arraydecay735, i32 %.conv722, void (%struct.urb*)* @hub_irq, i8* %74, i32 %conv736)
  %has_indicators737 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 18
  %bf.load738 = load i8, i8* %has_indicators737, align 4
  %bf.lshr739 = lshr i8 %bf.load738, 4
  %bf.clear740 = and i8 %bf.lshr739, 1
  %bf.cast = zext i8 %bf.clear740 to i32
  %tobool741 = icmp ne i32 %bf.cast, 0
  br i1 %tobool741, label %land.lhs.true742, label %if.end747

land.lhs.true742:                                 ; preds = %if.end732
  %76 = load i8, i8* @blinkenlights, align 1, !tbaa !43, !range !44
  %tobool743 = trunc i8 %76 to i1
  br i1 %tobool743, label %if.then745, label %if.end747

if.then745:                                       ; preds = %land.lhs.true742
  %indicator = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 19
  %arrayidx746 = getelementptr inbounds [31 x i8], [31 x i8]* %indicator, i64 0, i64 0
  store i8 1, i8* %arrayidx746, align 1, !tbaa !84
  br label %if.end747

if.end747:                                        ; preds = %if.then745, %land.lhs.true742, %if.end732
  br label %for.cond748

for.cond748:                                      ; preds = %for.inc762, %if.end747
  %i.0 = phi i32 [ 0, %if.end747 ], [ %inc763, %for.inc762 ]
  %maxchild749 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %77 = load i32, i32* %maxchild749, align 8, !tbaa !97
  %cmp750 = icmp slt i32 %i.0, %77
  br i1 %cmp750, label %for.body752, label %for.end764

for.body752:                                      ; preds = %for.cond748
  %add753 = add nsw i32 %i.0, 1
  %call754 = call i32 bitcast (i32 (%struct.usb_hub.4588*, i32)* @usb_hub_create_port_device to i32 (%struct.usb_hub*, i32)*)(%struct.usb_hub* %hub, i32 %add753)
  %cmp755 = icmp slt i32 %call754, 0
  br i1 %cmp755, label %if.then757, label %for.inc762

if.then757:                                       ; preds = %for.body752
  %78 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %for.inc762

for.inc762:                                       ; preds = %if.then757, %for.body752
  %inc763 = add nsw i32 %i.0, 1
  br label %for.cond748

for.end764:                                       ; preds = %for.cond748
  %descriptor765 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %hub, i32 0, i32 15
  %79 = load %struct.usb_hub_descriptor*, %struct.usb_hub_descriptor** %descriptor765, align 8, !tbaa !204
  call void @usb_hub_adjust_deviceremovable(%struct.usb_device* %0, %struct.usb_hub_descriptor* %79)
  call void @hub_activate(%struct.usb_hub* %hub, i32 0)
  br label %cleanup

fail:                                             ; preds = %if.end713, %if.end647, %if.then638, %do.end522, %if.end29, %if.else20, %if.else, %if.end12, %do.body, %if.end, %entry
  %ret.0 = phi i32 [ -12, %entry ], [ -12, %if.end ], [ -12, %do.body ], [ %call14, %if.end12 ], [ -19, %if.else ], [ -19, %if.else20 ], [ -12, %if.end29 ], [ %call523, %do.end522 ], [ %call642, %if.then638 ], [ %call648, %if.end647 ], [ -12, %if.end713 ]
  %80 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %fail, %for.end764
  %retval.0 = phi i32 [ %ret.0, %fail ], [ 0, %for.end764 ]
  %81 = bitcast i16* %hubchange to i8*
  %82 = bitcast i16* %hubstatus to i8*
  ret i32 %retval.0
}

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #2

; Function Attrs: nounwind uwtable
define internal i32 @get_hub_descriptor(%struct.usb_device* %hdev, i8* %data) #0 {
entry:
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %hdev)
  %tobool = icmp ne i32 %call, 0
  %. = select i1 %tobool, i32 12, i32 15
  %.1 = select i1 %tobool, i32 42, i32 41
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 3
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %call1 = call i32 @__create_pipe(%struct.usb_device* %hdev, i32 0)
  %or = or i32 -2147483648, %call1
  %or2 = or i32 %or, 128
  %shl = shl i32 %.1, 8
  %conv = trunc i32 %shl to i16
  %conv3 = trunc i32 %. to i16
  %call4 = call i32 @usb_control_msg(%struct.usb_device* %hdev, i32 %or2, i8 zeroext 6, i8 zeroext -96, i16 zeroext %conv, i16 zeroext 0, i8* %data, i16 zeroext %conv3, i32 5000)
  %cmp5 = icmp sge i32 %call4, 9
  br i1 %cmp5, label %cleanup, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.body, %for.cond
  %retval.0 = phi i32 [ %call4, %for.body ], [ -22, %for.cond ]
  ret i32 %retval.0
}

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #2

; Function Attrs: nounwind uwtable
define internal void @hub_tt_work(%struct.work_struct* %work) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy35 = alloca i64, align 8
  %__dummy236 = alloca i64, align 8
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -392
  %1 = bitcast i8* %add.ptr to %struct.usb_hub*
  %2 = bitcast i64* %__dummy to i8*
  %3 = bitcast i64* %__dummy2 to i8*
  %4 = bitcast i64* %__dummy2 to i8*
  %5 = bitcast i64* %__dummy to i8*
  br label %while.cond

while.cond:                                       ; preds = %if.end32, %entry
  %tt40 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 16
  %lock41 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt40, i32 0, i32 3
  %call42 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock41)
  %call43 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call42)
  %tt6 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 16
  %clear_list = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt6, i32 0, i32 4
  %call7 = call i32 @list_empty(%struct.list_head* %clear_list)
  %tobool = icmp ne i32 %call7, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %hdev8 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %hdev8, align 8, !tbaa !152
  %tt9 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 16
  %clear_list10 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt9, i32 0, i32 4
  %next11 = getelementptr inbounds %struct.list_head, %struct.list_head* %clear_list10, i32 0, i32 0
  %7 = load %struct.list_head*, %struct.list_head** %next11, align 8, !tbaa !288
  %8 = bitcast %struct.list_head* %7 to i8*
  %add.ptr14 = getelementptr inbounds i8, i8* %8, i64 0
  %9 = bitcast i8* %add.ptr14 to %struct.usb_tt_clear*
  %clear_list15 = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %9, i32 0, i32 0
  call void @list_del(%struct.list_head* %clear_list15)
  %tt16 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 16
  %lock17 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt16, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock17, i64 %call43)
  %devinfo = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %9, i32 0, i32 2
  %10 = load i16, i16* %devinfo, align 4, !tbaa !216
  %tt18 = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %9, i32 0, i32 1
  %11 = load i32, i32* %tt18, align 8, !tbaa !214
  %conv19 = trunc i32 %11 to i16
  %call20 = call i32 @hub_clear_tt_buffer(%struct.usb_device* %6, i16 zeroext %10, i16 zeroext %conv19)
  switch i32 %call20, label %if.then [
    i32 0, label %if.end
    i32 -19, label %if.end
  ]

if.then:                                          ; preds = %while.body
  %12 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body, %while.body
  %hcd = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %9, i32 0, i32 3
  %13 = load %struct.usb_hcd*, %struct.usb_hcd** %hcd, align 8, !tbaa !217
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %13, i32 0, i32 8
  %14 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %clear_tt_buffer_complete = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %14, i32 0, i32 25
  %15 = load void (%struct.usb_hcd*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd*, %struct.usb_host_endpoint*)** %clear_tt_buffer_complete, align 8, !tbaa !289
  %tobool28 = icmp ne void (%struct.usb_hcd*, %struct.usb_host_endpoint*)* %15, null
  br i1 %tobool28, label %if.then29, label %if.end32

if.then29:                                        ; preds = %if.end
  %clear_tt_buffer_complete30 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %14, i32 0, i32 25
  %16 = load void (%struct.usb_hcd*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd*, %struct.usb_host_endpoint*)** %clear_tt_buffer_complete30, align 8, !tbaa !289
  %hcd31 = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %9, i32 0, i32 3
  %17 = load %struct.usb_hcd*, %struct.usb_hcd** %hcd31, align 8, !tbaa !217
  %ep = getelementptr inbounds %struct.usb_tt_clear, %struct.usb_tt_clear* %9, i32 0, i32 4
  %18 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !219
  call void %16(%struct.usb_hcd* %17, %struct.usb_host_endpoint* %18)
  br label %if.end32

if.end32:                                         ; preds = %if.then29, %if.end
  %19 = bitcast %struct.usb_tt_clear* %9 to i8*
  call void @kfree(i8* %19)
  %20 = bitcast i64* %__dummy35 to i8*
  %21 = bitcast i64* %__dummy236 to i8*
  %22 = bitcast i64* %__dummy236 to i8*
  %23 = bitcast i64* %__dummy35 to i8*
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %tt48 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 16
  %lock49 = getelementptr inbounds %struct.usb_tt, %struct.usb_tt* %tt48, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock49, i64 %call43)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @usb_maxpacket(%struct.usb_device* %udev, i32 %pipe, i32 %is_out) #1 {
entry:
  %shr = ashr i32 %pipe, 15
  %and = and i32 %shr, 15
  %tobool = icmp ne i32 %is_out, 0
  %and1 = and i32 %pipe, 128
  %tobool2 = icmp ne i32 %and1, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.51.750, i32 0, i32 0), i32 1773)
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.then
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 17
  br label %if.end47

if.else:                                          ; preds = %entry
  %lnot25 = xor i1 %lnot3, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %tobool27 = icmp ne i32 %lnot.ext26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.else
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.51.750, i32 0, i32 0), i32 1776)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.else
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 16
  br label %if.end47

if.end47:                                         ; preds = %if.end36, %if.end
  %ep_in.sink = phi [16 x %struct.usb_host_endpoint*]* [ %ep_in, %if.end36 ], [ %ep_out, %if.end ]
  %idxprom45 = zext i32 %and to i64
  %arrayidx46 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in.sink, i64 0, i64 %idxprom45
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx46, align 8, !tbaa !48
  %tobool48 = icmp ne %struct.usb_host_endpoint* %0, null
  br i1 %tobool48, label %if.end50, label %cleanup

if.end50:                                         ; preds = %if.end47
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %0, i32 0, i32 0
  %call = call i32 @usb_endpoint_maxp(%struct.usb_endpoint_descriptor* %desc)
  %conv51 = trunc i32 %call to i16
  br label %cleanup

cleanup:                                          ; preds = %if.end50, %if.end47
  %retval.0 = phi i16 [ %conv51, %if.end50 ], [ 0, %if.end47 ]
  ret i16 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @hub_irq(%struct.urb* %urb) #0 {
entry:
  %context = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  %0 = load i8*, i8** %context, align 8, !tbaa !290
  %1 = bitcast i8* %0 to %struct.usb_hub*
  %status1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 12
  %2 = load i32, i32* %status1, align 8, !tbaa !291
  %Pivot10 = icmp slt i32 %2, -2
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %2, 0
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %2, 0
  br i1 %SwitchLeaf6, label %sw.bb12, label %do.body2

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %2, -2
  br i1 %SwitchLeaf4, label %cleanup.cont, label %do.body2

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %2, -104
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %2, -104
  br i1 %SwitchLeaf2, label %cleanup.cont, label %do.body2

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %2, -108
  br i1 %SwitchLeaf, label %cleanup.cont, label %do.body2

do.body2:                                         ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_irq.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %do.end6

if.then:                                          ; preds = %do.body2
  %intfdev = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 0
  %3 = load %struct.device*, %struct.device** %intfdev, align 8, !tbaa !173
  %call = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hub_irq.descriptor to %struct._ddebug*), %struct.device* %3, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.170, i32 0, i32 0), i32 %2)
  br label %do.end6

do.end6:                                          ; preds = %if.then, %do.body2
  %nerrors = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 8
  %4 = load i32, i32* %nerrors, align 4, !tbaa !251
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %nerrors, align 4, !tbaa !251
  %cmp = icmp slt i32 %inc, 10
  br i1 %cmp, label %resubmit, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end6
  %error = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 7
  %5 = load i32, i32* %error, align 8, !tbaa !174
  %tobool8 = icmp ne i32 %5, 0
  br i1 %tobool8, label %resubmit, label %if.end10

if.end10:                                         ; preds = %lor.lhs.false
  %error11 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 7
  store i32 %2, i32* %error11, align 8, !tbaa !174
  br label %sw.bb12

sw.bb12:                                          ; preds = %if.end10, %LeafBlock5
  br label %for.cond

for.cond:                                         ; preds = %for.body, %sw.bb12
  %i.0 = phi i32 [ 0, %sw.bb12 ], [ %inc16, %for.body ]
  %bits.0 = phi i64 [ 0, %sw.bb12 ], [ %or, %for.body ]
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %6 = load i32, i32* %actual_length, align 4, !tbaa !292
  %cmp13 = icmp ult i32 %i.0, %6
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %buffer = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 4
  %7 = load [8 x i8]*, [8 x i8]** %buffer, align 8, !tbaa !278
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [8 x i8], [8 x i8]* %7, i64 0, i64 %idxprom
  %8 = load i8, i8* %arrayidx, align 1, !tbaa !84
  %conv15 = zext i8 %8 to i64
  %mul = mul i32 %i.0, 8
  %sh_prom = zext i32 %mul to i64
  %shl = shl i64 %conv15, %sh_prom
  %or = or i64 %bits.0, %shl
  %inc16 = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %event_bits = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 10
  %arrayidx17 = getelementptr inbounds [1 x i64], [1 x i64]* %event_bits, i64 0, i64 0
  store i64 %bits.0, i64* %arrayidx17, align 8, !tbaa !49
  %nerrors18 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 8
  store i32 0, i32* %nerrors18, align 4, !tbaa !251
  call void @kick_khubd(%struct.usb_hub* %1)
  br label %resubmit

resubmit:                                         ; preds = %for.end, %lor.lhs.false, %do.end6
  %quiescing = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 18
  %bf.load19 = load i8, i8* %quiescing, align 4
  %bf.lshr20 = lshr i8 %bf.load19, 1
  %bf.clear21 = and i8 %bf.lshr20, 1
  %bf.cast = zext i8 %bf.clear21 to i32
  %tobool22 = icmp ne i32 %bf.cast, 0
  br i1 %tobool22, label %cleanup.cont, label %if.end24

if.end24:                                         ; preds = %resubmit
  %urb25 = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %1, i32 0, i32 3
  %9 = load %struct.urb*, %struct.urb** %urb25, align 8, !tbaa !254
  %call26 = call i32 bitcast (i32 (%struct.urb.824*, i32)* @usb_submit_urb to i32 (%struct.urb*, i32)*)(%struct.urb* %9, i32 32)
  switch i32 %call26, label %if.then34 [
    i32 0, label %cleanup.cont
    i32 -19, label %cleanup.cont
    i32 -1, label %cleanup.cont
  ]

if.then34:                                        ; preds = %if.end24
  %10 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then34, %if.end24, %if.end24, %if.end24, %resubmit, %LeafBlock, %LeafBlock1, %LeafBlock3
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_fill_int_urb(%struct.urb* %urb, %struct.usb_device* %dev, i32 %pipe, i8* %transfer_buffer, i32 %buffer_length, void (%struct.urb*)* %complete_fn, i8* %context, i32 %interval) #1 {
entry:
  %dev1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  store %struct.usb_device* %dev, %struct.usb_device** %dev1, align 8, !tbaa !210
  %pipe2 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 10
  store i32 %pipe, i32* %pipe2, align 8, !tbaa !212
  %transfer_buffer3 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  store i8* %transfer_buffer, i8** %transfer_buffer3, align 8, !tbaa !293
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  store i32 %buffer_length, i32* %transfer_buffer_length, align 8, !tbaa !294
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 28
  store void (%struct.urb*)* %complete_fn, void (%struct.urb*)** %complete, align 8, !tbaa !295
  %context4 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  store i8* %context, i8** %context4, align 8, !tbaa !290
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp eq i32 %0, 3
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %speed5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 4
  %1 = load i32, i32* %speed5, align 4, !tbaa !153
  %cmp6 = icmp eq i32 %1, 5
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %sub = sub nsw i32 %interval, 1
  %shl = shl i32 1, %sub
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %interval.sink = phi i32 [ %shl, %if.then ], [ %interval, %lor.lhs.false ]
  %interval8 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 25
  store i32 %interval.sink, i32* %interval8, align 8, !tbaa !296
  %start_frame = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 23
  store i32 -1, i32* %start_frame, align 8, !tbaa !297
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_hub_adjust_deviceremovable(%struct.usb_device* %hdev, %struct.usb_hub_descriptor* %desc) #0 {
entry:
  %call = call i32 @hub_is_superspeed(%struct.usb_device* %hdev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %i.0 = phi i32 [ 1, %if.then ], [ %inc, %for.inc ]
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 28
  %0 = load i32, i32* %maxchild, align 8, !tbaa !97
  %cmp = icmp sle i32 %i.0, %0
  br i1 %cmp, label %for.body, label %if.end82

for.body:                                         ; preds = %for.cond
  %call1 = call i32 @usb_get_hub_port_connect_type(%struct.usb_device* %hdev, i32 %i.0)
  %cmp2 = icmp eq i32 %call1, 2
  br i1 %cmp2, label %if.then3, label %for.inc

if.then3:                                         ; preds = %for.body
  %rem = srem i32 %i.0, 8
  %shl = shl i32 1, %rem
  %conv = trunc i32 %shl to i8
  %u = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %desc, i32 0, i32 6
  %hs = bitcast %union.anon.49* %u to %struct.anon.50*
  %DeviceRemovable = getelementptr inbounds %struct.anon.50, %struct.anon.50* %hs, i32 0, i32 0
  %div = sdiv i32 %i.0, 8
  %idxprom = sext i32 %div to i64
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* %DeviceRemovable, i64 0, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !84
  %conv4 = zext i8 %1 to i32
  %conv5 = zext i8 %conv to i32
  %and = and i32 %conv4, %conv5
  %tobool6 = icmp ne i32 %and, 0
  br i1 %tobool6, label %for.inc, label %do.body8

do.body8:                                         ; preds = %if.then3
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hub_adjust_deviceremovable.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and9 = and i32 %bf.clear, 1
  %tobool10 = icmp ne i32 %and9, 0
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv12 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv12, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  br i1 %tobool13, label %if.then14, label %do.end17

if.then14:                                        ; preds = %do.body8
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 11
  %call15 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hub_adjust_deviceremovable.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.str.39, i32 0, i32 0), i32 %i.0)
  br label %do.end17

do.end17:                                         ; preds = %if.then14, %do.body8
  %conv18 = zext i8 %conv to i32
  %u19 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %desc, i32 0, i32 6
  %hs20 = bitcast %union.anon.49* %u19 to %struct.anon.50*
  %DeviceRemovable21 = getelementptr inbounds %struct.anon.50, %struct.anon.50* %hs20, i32 0, i32 0
  %div22 = sdiv i32 %i.0, 8
  %idxprom23 = sext i32 %div22 to i64
  %arrayidx24 = getelementptr inbounds [4 x i8], [4 x i8]* %DeviceRemovable21, i64 0, i64 %idxprom23
  %2 = load i8, i8* %arrayidx24, align 1, !tbaa !84
  %conv25 = zext i8 %2 to i32
  %or = or i32 %conv25, %conv18
  %conv26 = trunc i32 %or to i8
  store i8 %conv26, i8* %arrayidx24, align 1, !tbaa !84
  br label %for.inc

for.inc:                                          ; preds = %do.end17, %if.then3, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.else:                                          ; preds = %entry
  %u29 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %desc, i32 0, i32 6
  %ss = bitcast %union.anon.49* %u29 to %struct.anon.51*
  %DeviceRemovable30 = getelementptr inbounds %struct.anon.51, %struct.anon.51* %ss, i32 0, i32 2
  %3 = load i16, i16* %DeviceRemovable30, align 1, !tbaa !84
  br label %for.cond31

for.cond31:                                       ; preds = %for.inc76, %if.else
  %i.1 = phi i32 [ 1, %if.else ], [ %inc77, %for.inc76 ]
  %port_removable.0 = phi i16 [ %3, %if.else ], [ %port_removable.2, %for.inc76 ]
  %maxchild32 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 28
  %4 = load i32, i32* %maxchild32, align 8, !tbaa !97
  %cmp33 = icmp sle i32 %i.1, %4
  br i1 %cmp33, label %for.body35, label %for.end78

for.body35:                                       ; preds = %for.cond31
  %call36 = call i32 @usb_get_hub_port_connect_type(%struct.usb_device* %hdev, i32 %i.1)
  %cmp37 = icmp eq i32 %call36, 2
  br i1 %cmp37, label %if.then39, label %for.inc76

if.then39:                                        ; preds = %for.body35
  %shl41 = shl i32 1, %i.1
  %conv42 = trunc i32 %shl41 to i16
  %conv43 = zext i16 %port_removable.0 to i32
  %conv44 = zext i16 %conv42 to i32
  %and45 = and i32 %conv43, %conv44
  %tobool46 = icmp ne i32 %and45, 0
  br i1 %tobool46, label %for.inc76, label %do.body49

do.body49:                                        ; preds = %if.then39
  %bf.load50 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hub_adjust_deviceremovable.descriptor.40 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr51 = lshr i32 %bf.load50, 18
  %bf.clear52 = and i32 %bf.lshr51, 255
  %and53 = and i32 %bf.clear52, 1
  %tobool54 = icmp ne i32 %and53, 0
  %lnot55 = xor i1 %tobool54, true
  %lnot57 = xor i1 %lnot55, true
  %lnot.ext58 = zext i1 %lnot57 to i32
  %conv59 = sext i32 %lnot.ext58 to i64
  %expval60 = call i64 @llvm.expect.i64(i64 %conv59, i64 0)
  %tobool61 = icmp ne i64 %expval60, 0
  br i1 %tobool61, label %if.then62, label %do.end69

if.then62:                                        ; preds = %do.body49
  %dev63 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 11
  %call64 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hub_adjust_deviceremovable.descriptor.40 to %struct._ddebug*), %struct.device* %dev63, i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.str.39, i32 0, i32 0), i32 %i.1)
  br label %do.end69

do.end69:                                         ; preds = %if.then62, %do.body49
  %conv70 = zext i16 %conv42 to i32
  %conv71 = zext i16 %port_removable.0 to i32
  %or72 = or i32 %conv71, %conv70
  %conv73 = trunc i32 %or72 to i16
  br label %for.inc76

for.inc76:                                        ; preds = %do.end69, %if.then39, %for.body35
  %port_removable.2 = phi i16 [ %port_removable.0, %for.body35 ], [ %port_removable.0, %if.then39 ], [ %conv73, %do.end69 ]
  %inc77 = add nsw i32 %i.1, 1
  br label %for.cond31

for.end78:                                        ; preds = %for.cond31
  %u79 = getelementptr inbounds %struct.usb_hub_descriptor, %struct.usb_hub_descriptor* %desc, i32 0, i32 6
  %ss80 = bitcast %union.anon.49* %u79 to %struct.anon.51*
  %DeviceRemovable81 = getelementptr inbounds %struct.anon.51, %struct.anon.51* %ss80, i32 0, i32 2
  store i16 %port_removable.0, i16* %DeviceRemovable81, align 1, !tbaa !84
  br label %if.end82

if.end82:                                         ; preds = %for.end78, %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_get_hub_port_connect_type(%struct.usb_device* %hdev, i32 %port1) #0 {
entry:
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 22
  %0 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %0, i64 %idxprom
  %1 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %connect_type = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 3
  %2 = load i32, i32* %connect_type, align 8, !tbaa !298
  ret i32 %2
}

declare void @list_del(%struct.list_head*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hub_clear_tt_buffer(%struct.usb_device* %hdev, i16 zeroext %devinfo, i16 zeroext %tt) #1 {
entry:
  %call = call i32 @__create_pipe(%struct.usb_device* %hdev, i32 0)
  %or = or i32 -2147483648, %call
  %call1 = call i32 @usb_control_msg(%struct.usb_device* %hdev, i32 %or, i8 zeroext 8, i8 zeroext 35, i16 zeroext %devinfo, i16 zeroext %tt, i8* null, i16 zeroext 0, i32 1000)
  ret i32 %call1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set.30(%union.anon.5* %v, i32 %i) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !94
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_int(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 3
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_dir_in(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !286
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 128
  %cmp = icmp eq i32 %and, 128
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define void @usb_hub_cleanup() #0 {
entry:
  %0 = load %struct.task_struct*, %struct.task_struct** @khubd_task, align 8, !tbaa !48
  %call = call i32 @kthread_stop(%struct.task_struct* %0)
  call void @usb_deregister(%struct.usb_driver* @hub_driver)
  ret void
}

declare i32 @kthread_stop(%struct.task_struct*) #2

; Function Attrs: nounwind uwtable
define void @usb_set_hub_port_connect_type(%struct.usb_device* %hdev, i32 %port1, i32 %type) #0 {
entry:
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 22
  %0 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %0, i64 %idxprom
  %1 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %connect_type = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 3
  store i32 %type, i32* %connect_type, align 8, !tbaa !298
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @usb_get_hub_port_acpi_handle(%struct.usb_device* %hdev, i32 %port1) #0 {
entry:
  %call = call %struct.usb_hub* @usb_hub_to_struct_hub(%struct.usb_device* %hdev)
  %ports = getelementptr inbounds %struct.usb_hub, %struct.usb_hub* %call, i32 0, i32 22
  %0 = load %struct.usb_port**, %struct.usb_port*** %ports, align 8, !tbaa !98
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port*, %struct.usb_port** %0, i64 %idxprom
  %1 = load %struct.usb_port*, %struct.usb_port** %arrayidx, align 8, !tbaa !48
  %dev = getelementptr inbounds %struct.usb_port, %struct.usb_port* %1, i32 0, i32 1
  %acpi_node = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 19
  %handle = getelementptr inbounds %union.anon.3, %union.anon.3* %acpi_node, i32 0, i32 0
  %2 = load i8*, i8** %handle, align 8, !tbaa !300
  ret i8* %2
}

; Function Attrs: nounwind uwtable
define void @usb_mon_deregister() #0 {
entry:
  %0 = load %struct.usb_mon_operations*, %struct.usb_mon_operations** @mon_ops, align 8, !tbaa !48
  %cmp = icmp eq %struct.usb_mon_operations* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %return

if.end:                                           ; preds = %entry
  store %struct.usb_mon_operations* null, %struct.usb_mon_operations** @mon_ops, align 8, !tbaa !48
  call void asm sideeffect "mfence", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !301
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_mon_register(%struct.usb_mon_operations* %ops) #0 {
entry:
  %0 = load %struct.usb_mon_operations*, %struct.usb_mon_operations** @mon_ops, align 8, !tbaa !48
  %tobool = icmp ne %struct.usb_mon_operations* %0, null
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  store %struct.usb_mon_operations* %ops, %struct.usb_mon_operations** @mon_ops, align 8, !tbaa !48
  call void asm sideeffect "mfence", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !302
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -16, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_platform_shutdown(%struct.platform_device* %dev) #0 {
entry:
  %call = call i8* @platform_get_drvdata(%struct.platform_device* %dev)
  %0 = bitcast i8* %call to %struct.usb_hcd.588*
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %0, i32 0, i32 8
  %1 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %shutdown = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %1, i32 0, i32 10
  %shutdown1 = bitcast {}** %shutdown to void (%struct.usb_hcd.588*)**
  %2 = load void (%struct.usb_hcd.588*)*, void (%struct.usb_hcd.588*)** %shutdown1, align 8, !tbaa !303
  %tobool = icmp ne void (%struct.usb_hcd.588*)* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %driver2 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %0, i32 0, i32 8
  %3 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver2, align 8, !tbaa !71
  %shutdown3 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %3, i32 0, i32 10
  %shutdown4 = bitcast {}** %shutdown3 to void (%struct.usb_hcd.588*)**
  %4 = load void (%struct.usb_hcd.588*)*, void (%struct.usb_hcd.588*)** %shutdown4, align 8, !tbaa !303
  call void %4(%struct.usb_hcd.588* %0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @platform_get_drvdata(%struct.platform_device* %pdev) #1 {
entry:
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define void @usb_remove_hcd(%struct.usb_hcd.588* %hcd) #0 {
entry:
  %rhdev = alloca %struct.usb_device*, align 8
  %0 = bitcast %struct.usb_device** %rhdev to i8*
  %self = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 10
  %1 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !151
  store %struct.usb_device* %1, %struct.usb_device** %rhdev, align 8, !tbaa !48
  %2 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %3 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !48
  %call2 = call %struct.usb_device* @usb_get_dev(%struct.usb_device* %3)
  %4 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !48
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 11
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj, %struct.attribute_group* @usb_bus_attr_group)
  %flags = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags, i32 5, i64* %flags) #8, !srcloc !304
  %state3 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 21
  %5 = load i32, i32* %state3, align 8, !tbaa !305
  %and = and i32 %5, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %do.body5

if.then:                                          ; preds = %entry
  %state4 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 21
  store i32 133, i32* %state4, align 8, !tbaa !305
  br label %do.body5

do.body5:                                         ; preds = %if.then, %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_remove_hcd.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and6 = and i32 %bf.clear, 1
  %tobool7 = icmp ne i32 %and6, 0
  %lnot = xor i1 %tobool7, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %do.end16

if.then10:                                        ; preds = %do.body5
  %self11 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller12 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self11, i32 0, i32 0
  %6 = load %struct.device*, %struct.device** %controller12, align 8, !tbaa !306
  %call13 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_remove_hcd.descriptor to %struct._ddebug*), %struct.device* %6, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.46.47, i32 0, i32 0))
  br label %do.end16

do.end16:                                         ; preds = %if.then10, %do.body5
  call void @spin_lock_irq.48(%struct.spinlock* @hcd_root_hub_lock)
  %rh_registered = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %bf.load17 = load i8, i8* %rh_registered, align 8
  %bf.clear18 = and i8 %bf.load17, -2
  store i8 %bf.clear18, i8* %rh_registered, align 8
  call void @spin_unlock_irq.49(%struct.spinlock* @hcd_root_hub_lock)
  %wakeup_work = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 7
  %call19 = call zeroext i1 @cancel_work_sync(%struct.work_struct* %wakeup_work)
  call void @mutex_lock_nested(%struct.mutex* @usb_bus_list_lock, i32 0)
  call void @usb_disconnect(%struct.usb_device** %rhdev)
  call void @mutex_unlock(%struct.mutex* @usb_bus_list_lock)
  %rh_pollable = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %bf.load20 = load i8, i8* %rh_pollable, align 8
  %bf.clear21 = and i8 %bf.load20, -3
  store i8 %bf.clear21, i8* %rh_pollable, align 8
  %flags22 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags22, i32 2, i64* %flags22) #8, !srcloc !304
  %rh_timer = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 5
  %call23 = call i32 @del_timer_sync(%struct.timer_list* %rh_timer)
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %7 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %stop = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %7, i32 0, i32 9
  %stop24 = bitcast {}** %stop to void (%struct.usb_hcd.588*)**
  %8 = load void (%struct.usb_hcd.588*)*, void (%struct.usb_hcd.588*)** %stop24, align 8, !tbaa !307
  call void %8(%struct.usb_hcd.588* %hcd)
  %state25 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 21
  store i32 0, i32* %state25, align 8, !tbaa !305
  %flags26 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags26, i32 2, i64* %flags26) #8, !srcloc !304
  %rh_timer27 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 5
  %call28 = call i32 @del_timer_sync(%struct.timer_list* %rh_timer27)
  %call29 = call i32 @usb_hcd_is_primary_hcd(%struct.usb_hcd.588* %hcd)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %if.then31, label %if.end36

if.then31:                                        ; preds = %do.end16
  %irq = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 12
  %9 = load i32, i32* %irq, align 4, !tbaa !308
  %cmp = icmp ugt i32 %9, 0
  br i1 %cmp, label %if.then33, label %if.end36

if.then33:                                        ; preds = %if.then31
  %irq34 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 12
  %10 = load i32, i32* %irq34, align 4, !tbaa !308
  %11 = bitcast %struct.usb_hcd.588* %hcd to i8*
  call void @free_irq(i32 %10, i8* %11)
  br label %if.end36

if.end36:                                         ; preds = %if.then33, %if.then31, %do.end16
  %self37 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %root_hub38 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self37, i32 0, i32 10
  %12 = load %struct.usb_device*, %struct.usb_device** %root_hub38, align 8, !tbaa !151
  call void @usb_put_dev(%struct.usb_device* %12)
  %self39 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  call void @usb_deregister_bus(%struct.usb_bus* %self39)
  call void bitcast (void (%struct.usb_hcd.2297*)* @hcd_buffer_destroy to void (%struct.usb_hcd.588*)*)(%struct.usb_hcd.588* %hcd)
  %13 = bitcast %struct.usb_device** %rhdev to i8*
  ret void
}

declare void @sysfs_remove_group(%struct.kobject*, %struct.attribute_group*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_irq.48(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irq.49(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

declare zeroext i1 @cancel_work_sync(%struct.work_struct*) #2

declare i32 @del_timer_sync(%struct.timer_list*) #2

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_is_primary_hcd(%struct.usb_hcd.588* %hcd) #0 {
entry:
  %primary_hcd = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 19
  %0 = load %struct.usb_hcd.588*, %struct.usb_hcd.588** %primary_hcd, align 8, !tbaa !309
  %tobool = icmp ne %struct.usb_hcd.588* %0, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %primary_hcd1 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 19
  %1 = load %struct.usb_hcd.588*, %struct.usb_hcd.588** %primary_hcd1, align 8, !tbaa !309
  %cmp = icmp eq %struct.usb_hcd.588* %hcd, %1
  %conv = zext i1 %cmp to i32
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %conv, %if.end ], [ 1, %entry ]
  ret i32 %retval.0
}

declare void @free_irq(i32, i8*) #2

; Function Attrs: nounwind uwtable
define internal void @usb_deregister_bus(%struct.usb_bus* %bus) #0 {
entry:
  %0 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  call void @mutex_lock_nested(%struct.mutex* @usb_bus_list_lock, i32 0)
  %bus_list = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 12
  call void @list_del(%struct.list_head* %bus_list)
  call void @mutex_unlock(%struct.mutex* @usb_bus_list_lock)
  call void @usb_notify_remove_bus(%struct.usb_bus* %bus)
  %busnum1 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 1
  %1 = load i32, i32* %busnum1, align 8, !tbaa !35
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* getelementptr inbounds (%struct.sigset_t, %struct.sigset_t* @busmap, i32 0, i32 0, i32 0), i32 %1, i64* getelementptr inbounds (%struct.sigset_t, %struct.sigset_t* @busmap, i32 0, i32 0, i32 0)) #8, !srcloc !304
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @usb_host_authorized_default_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %cmp = icmp eq %struct.usb_bus* %2, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call %struct.usb_hcd.588* @bus_to_hcd.55(%struct.usb_bus* %2)
  %authorized_default = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 11
  %bf.load = load i8, i8* %authorized_default, align 8
  %bf.lshr = lshr i8 %bf.load, 5
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6.543, i32 0, i32 0), i32 %bf.cast)
  %conv = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -19, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @usb_host_authorized_default_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %size) #0 {
entry:
  %val = alloca i32, align 4
  %0 = bitcast i32* %val to i8*
  %1 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -136
  %2 = bitcast i8* %add.ptr to %struct.usb_device*
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 9
  %3 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %cmp = icmp eq %struct.usb_bus* %3, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call %struct.usb_hcd.588* @bus_to_hcd.55(%struct.usb_bus* %3)
  %call1 = call i32 (i8*, i8*, ...) @sscanf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6.543, i32 0, i32 0), i32* %val)
  %conv = sext i32 %call1 to i64
  %cmp2 = icmp eq i64 %conv, 1
  br i1 %cmp2, label %if.then4, label %cleanup

if.then4:                                         ; preds = %if.end
  %4 = load i32, i32* %val, align 4, !tbaa !90
  %tobool = icmp ne i32 %4, 0
  %cond = select i1 %tobool, i32 1, i32 0
  %authorized_default = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 11
  %5 = trunc i32 %cond to i8
  %bf.load = load i8, i8* %authorized_default, align 8
  %bf.value = and i8 %5, 1
  %bf.shl = shl i8 %bf.value, 5
  %bf.clear = and i8 %bf.load, -33
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, i8* %authorized_default, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.then4, %if.end, %entry
  %retval.0 = phi i64 [ -19, %entry ], [ %size, %if.then4 ], [ -22, %if.end ]
  %6 = bitcast i32* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd.588* @bus_to_hcd.55(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd.588*
  ret %struct.usb_hcd.588* %1
}

declare i32 @sscanf(i8*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define i32 @usb_add_hcd(%struct.usb_hcd.588* %hcd, i32 %irqnum, i64 %irqflags) #0 {
entry:
  %rhdev = alloca %struct.usb_device*, align 8
  %0 = bitcast %struct.usb_device** %rhdev to i8*
  %1 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %2 = load i32, i32* @authorized_default, align 4, !tbaa !90
  %cmp = icmp slt i32 %2, 0
  %3 = load i32, i32* @authorized_default, align 4
  %cmp2 = icmp sgt i32 %3, 1
  %or.cond = or i1 %cmp, %cmp2
  br i1 %or.cond, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %wireless = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %bf.load = load i8, i8* %wireless, align 8
  %bf.lshr = lshr i8 %bf.load, 4
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  %cond = select i1 %tobool, i32 0, i32 1
  %authorized_default = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %4 = trunc i32 %cond to i8
  %bf.load3 = load i8, i8* %authorized_default, align 8
  %bf.value = and i8 %4, 1
  %bf.shl = shl i8 %bf.value, 5
  %bf.clear4 = and i8 %bf.load3, -33
  %bf.set = or i8 %bf.clear4, %bf.shl
  store i8 %bf.set, i8* %authorized_default, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load i32, i32* @authorized_default, align 4, !tbaa !90
  %authorized_default5 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %6 = trunc i32 %5 to i8
  %bf.load6 = load i8, i8* %authorized_default5, align 8
  %bf.value7 = and i8 %6, 1
  %bf.shl8 = shl i8 %bf.value7, 5
  %bf.clear9 = and i8 %bf.load6, -33
  %bf.set10 = or i8 %bf.clear9, %bf.shl8
  store i8 %bf.set10, i8* %authorized_default5, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %flags = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags, i32 0, i64* %flags) #8, !srcloc !310
  %call12 = call i32 bitcast (i32 (%struct.usb_hcd.2297*)* @hcd_buffer_create to i32 (%struct.usb_hcd.588*)*)(%struct.usb_hcd.588* %hcd)
  %cmp13 = icmp ne i32 %call12, 0
  br i1 %cmp13, label %do.body15, label %if.end29

do.body15:                                        ; preds = %if.end
  %bf.load16 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_add_hcd.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr17 = lshr i32 %bf.load16, 18
  %bf.clear18 = and i32 %bf.lshr17, 255
  %and = and i32 %bf.clear18, 1
  %tobool19 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool19, true
  %lnot20 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot20 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool21 = icmp ne i64 %expval, 0
  br i1 %tobool21, label %if.then22, label %cleanup

if.then22:                                        ; preds = %do.body15
  %self23 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller24 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self23, i32 0, i32 0
  %7 = load %struct.device*, %struct.device** %controller24, align 8, !tbaa !306
  %call25 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_add_hcd.descriptor to %struct._ddebug*), %struct.device* %7, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.38.59, i32 0, i32 0))
  br label %cleanup

if.end29:                                         ; preds = %if.end
  %self30 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %call31 = call i32 @usb_register_bus(%struct.usb_bus* %self30)
  %cmp32 = icmp slt i32 %call31, 0
  br i1 %cmp32, label %err_register_bus, label %if.end35

if.end35:                                         ; preds = %if.end29
  %self36 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %call37 = call %struct.usb_device* @usb_alloc_dev(%struct.usb_device* null, %struct.usb_bus* %self36, i32 0)
  store %struct.usb_device* %call37, %struct.usb_device** %rhdev, align 8, !tbaa !48
  %cmp38 = icmp eq %struct.usb_device* %call37, null
  br i1 %cmp38, label %if.then40, label %if.end44

if.then40:                                        ; preds = %if.end35
  %8 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %err_allocate_root_hub

if.end44:                                         ; preds = %if.end35
  %9 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !48
  %self45 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self45, i32 0, i32 10
  store %struct.usb_device* %9, %struct.usb_device** %root_hub, align 8, !tbaa !151
  %speed = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 3
  %10 = load i32, i32* %speed, align 8, !tbaa !311
  %Pivot6 = icmp slt i32 %10, 32
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end44
  %Pivot = icmp slt i32 %10, 64
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %10, 64
  br i1 %SwitchLeaf4, label %sw.bb49, label %err_set_rh_speed

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %10, 32
  br i1 %SwitchLeaf2, label %sw.bb47, label %err_set_rh_speed

LeafBlock:                                        ; preds = %if.end44
  %SwitchLeaf = icmp eq i32 %10, 16
  br i1 %SwitchLeaf, label %sw.bb, label %err_set_rh_speed

sw.bb:                                            ; preds = %LeafBlock
  %11 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !48
  br label %sw.epilog

sw.bb47:                                          ; preds = %LeafBlock1
  %12 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !48
  br label %sw.epilog

sw.bb49:                                          ; preds = %LeafBlock3
  %13 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !48
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb49, %sw.bb47, %sw.bb
  %.sink7 = phi %struct.usb_device* [ %13, %sw.bb49 ], [ %12, %sw.bb47 ], [ %11, %sw.bb ]
  %.sink = phi i32 [ 5, %sw.bb49 ], [ 3, %sw.bb47 ], [ 2, %sw.bb ]
  %speed50 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %.sink7, i32 0, i32 4
  store i32 %.sink, i32* %speed50, align 4, !tbaa !153
  %14 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !48
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %14, i32 0, i32 11
  call void @device_set_wakeup_capable(%struct.device* %dev, i1 zeroext true)
  %flags51 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags51, i32 5, i64* %flags51) #8, !srcloc !310
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %15 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %reset = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %15, i32 0, i32 5
  %16 = load i32 (%struct.usb_hcd.588*)*, i32 (%struct.usb_hcd.588*)** %reset, align 8, !tbaa !312
  %tobool52 = icmp ne i32 (%struct.usb_hcd.588*)* %16, null
  br i1 %tobool52, label %land.lhs.true, label %if.end62

land.lhs.true:                                    ; preds = %sw.epilog
  %driver53 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %17 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver53, align 8, !tbaa !71
  %reset54 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %17, i32 0, i32 5
  %18 = load i32 (%struct.usb_hcd.588*)*, i32 (%struct.usb_hcd.588*)** %reset54, align 8, !tbaa !312
  %call55 = call i32 %18(%struct.usb_hcd.588* %hcd)
  %cmp56 = icmp slt i32 %call55, 0
  br i1 %cmp56, label %if.then58, label %if.end62

if.then58:                                        ; preds = %land.lhs.true
  %19 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %err_set_rh_speed

if.end62:                                         ; preds = %land.lhs.true, %sw.epilog
  %rh_pollable = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %bf.load63 = load i8, i8* %rh_pollable, align 8
  %bf.clear64 = and i8 %bf.load63, -3
  %bf.set65 = or i8 %bf.clear64, 2
  store i8 %bf.set65, i8* %rh_pollable, align 8
  %self66 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller67 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self66, i32 0, i32 0
  %20 = load %struct.device*, %struct.device** %controller67, align 8, !tbaa !306
  %call68 = call zeroext i1 @device_can_wakeup(%struct.device* %20)
  br i1 %call68, label %land.lhs.true70, label %if.end100

land.lhs.true70:                                  ; preds = %if.end62
  %self71 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %root_hub72 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self71, i32 0, i32 10
  %21 = load %struct.usb_device*, %struct.usb_device** %root_hub72, align 8, !tbaa !151
  %dev73 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %21, i32 0, i32 11
  %call74 = call zeroext i1 @device_can_wakeup(%struct.device* %dev73)
  br i1 %call74, label %do.body78, label %if.end100

do.body78:                                        ; preds = %land.lhs.true70
  %bf.load79 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_add_hcd.descriptor.41 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr80 = lshr i32 %bf.load79, 18
  %bf.clear81 = and i32 %bf.lshr80, 255
  %and82 = and i32 %bf.clear81, 1
  %tobool83 = icmp ne i32 %and82, 0
  %lnot84 = xor i1 %tobool83, true
  %lnot86 = xor i1 %lnot84, true
  %lnot.ext87 = zext i1 %lnot86 to i32
  %conv88 = sext i32 %lnot.ext87 to i64
  %expval89 = call i64 @llvm.expect.i64(i64 %conv88, i64 0)
  %tobool90 = icmp ne i64 %expval89, 0
  br i1 %tobool90, label %if.then91, label %if.end100

if.then91:                                        ; preds = %do.body78
  %self92 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller93 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self92, i32 0, i32 0
  %22 = load %struct.device*, %struct.device** %controller93, align 8, !tbaa !306
  %call94 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_add_hcd.descriptor.41 to %struct._ddebug*), %struct.device* %22, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.42.62, i32 0, i32 0))
  br label %if.end100

if.end100:                                        ; preds = %if.then91, %do.body78, %land.lhs.true70, %if.end62
  %call101 = call i32 @usb_hcd_is_primary_hcd(%struct.usb_hcd.588* %hcd)
  %tobool102 = icmp ne i32 %call101, 0
  %tobool104 = icmp ne i32 %irqnum, 0
  %or.cond8 = and i1 %tobool102, %tobool104
  br i1 %or.cond8, label %if.then105, label %if.end110

if.then105:                                       ; preds = %if.end100
  %call106 = call i32 @usb_hcd_request_irqs(%struct.usb_hcd.588* %hcd, i32 %irqnum, i64 %irqflags)
  %tobool107 = icmp ne i32 %call106, 0
  br i1 %tobool107, label %err_set_rh_speed, label %if.end110

if.end110:                                        ; preds = %if.then105, %if.end100
  %state = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 21
  store i32 1, i32* %state, align 8, !tbaa !305
  %driver111 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %23 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver111, align 8, !tbaa !71
  %start = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %23, i32 0, i32 6
  %24 = load i32 (%struct.usb_hcd.588*)*, i32 (%struct.usb_hcd.588*)** %start, align 8, !tbaa !313
  %call112 = call i32 %24(%struct.usb_hcd.588* %hcd)
  %cmp113 = icmp slt i32 %call112, 0
  br i1 %cmp113, label %if.then115, label %if.end119

if.then115:                                       ; preds = %if.end110
  %25 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %err_hcd_driver_start

if.end119:                                        ; preds = %if.end110
  %call120 = call i32 @register_root_hub(%struct.usb_hcd.588* %hcd)
  %cmp121 = icmp ne i32 %call120, 0
  br i1 %cmp121, label %err_register_root_hub, label %if.end124

if.end124:                                        ; preds = %if.end119
  %26 = load %struct.usb_device*, %struct.usb_device** %rhdev, align 8, !tbaa !48
  %dev125 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %26, i32 0, i32 11
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev125, i32 0, i32 2
  %call126 = call i32 @sysfs_create_group(%struct.kobject* %kobj, %struct.attribute_group* @usb_bus_attr_group)
  %cmp127 = icmp slt i32 %call126, 0
  br i1 %cmp127, label %if.then129, label %if.end131

if.then129:                                       ; preds = %if.end124
  %27 = call i32 (i8*, ...) @printk(i8* null)
  %flags146 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags146, i32 5, i64* %flags146) #8, !srcloc !304
  %state147 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 21
  %28 = load i32, i32* %state147, align 8, !tbaa !305
  %and148 = and i32 %28, 1
  %tobool149 = icmp ne i32 %and148, 0
  br i1 %tobool149, label %if.then150, label %if.end152

if.end131:                                        ; preds = %if.end124
  %uses_new_polling = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %bf.load132 = load i8, i8* %uses_new_polling, align 8
  %bf.lshr133 = lshr i8 %bf.load132, 3
  %bf.clear134 = and i8 %bf.lshr133, 1
  %bf.cast135 = zext i8 %bf.clear134 to i32
  %tobool136 = icmp ne i32 %bf.cast135, 0
  br i1 %tobool136, label %land.lhs.true137, label %if.end142

land.lhs.true137:                                 ; preds = %if.end131
  %flags138 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  %29 = load i64, i64* %flags138, align 8, !tbaa !314
  %and139 = and i64 %29, 4
  %tobool140 = icmp ne i64 %and139, 0
  br i1 %tobool140, label %if.then141, label %if.end142

if.then141:                                       ; preds = %land.lhs.true137
  call void @usb_hcd_poll_rh_status(%struct.usb_hcd.588* %hcd)
  br label %if.end142

if.end142:                                        ; preds = %if.then141, %land.lhs.true137, %if.end131
  %self143 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller144 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self143, i32 0, i32 0
  %30 = load %struct.device*, %struct.device** %controller144, align 8, !tbaa !306
  %call145 = call i32 @device_wakeup_enable(%struct.device* %30)
  br label %cleanup

if.then150:                                       ; preds = %if.then129
  %state151 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 21
  store i32 133, i32* %state151, align 8, !tbaa !305
  br label %if.end152

if.end152:                                        ; preds = %if.then150, %if.then129
  call void @spin_lock_irq.48(%struct.spinlock* @hcd_root_hub_lock)
  %rh_registered = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %bf.load153 = load i8, i8* %rh_registered, align 8
  %bf.clear154 = and i8 %bf.load153, -2
  store i8 %bf.clear154, i8* %rh_registered, align 8
  call void @spin_unlock_irq.49(%struct.spinlock* @hcd_root_hub_lock)
  %wakeup_work = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 7
  %call155 = call zeroext i1 @cancel_work_sync(%struct.work_struct* %wakeup_work)
  call void @mutex_lock_nested(%struct.mutex* @usb_bus_list_lock, i32 0)
  call void @usb_disconnect(%struct.usb_device** %rhdev)
  call void @mutex_unlock(%struct.mutex* @usb_bus_list_lock)
  br label %err_register_root_hub

err_register_root_hub:                            ; preds = %if.end152, %if.end119
  %retval1.0 = phi i32 [ %call126, %if.end152 ], [ %call120, %if.end119 ]
  %rh_pollable156 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %bf.load157 = load i8, i8* %rh_pollable156, align 8
  %bf.clear158 = and i8 %bf.load157, -3
  store i8 %bf.clear158, i8* %rh_pollable156, align 8
  %flags159 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags159, i32 2, i64* %flags159) #8, !srcloc !304
  %rh_timer = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 5
  %call160 = call i32 @del_timer_sync(%struct.timer_list* %rh_timer)
  %driver161 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %31 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver161, align 8, !tbaa !71
  %stop = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %31, i32 0, i32 9
  %stop162 = bitcast {}** %stop to void (%struct.usb_hcd.588*)**
  %32 = load void (%struct.usb_hcd.588*)*, void (%struct.usb_hcd.588*)** %stop162, align 8, !tbaa !307
  call void %32(%struct.usb_hcd.588* %hcd)
  %state163 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 21
  store i32 0, i32* %state163, align 8, !tbaa !305
  %flags164 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags164, i32 2, i64* %flags164) #8, !srcloc !304
  %rh_timer165 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 5
  %call166 = call i32 @del_timer_sync(%struct.timer_list* %rh_timer165)
  br label %err_hcd_driver_start

err_hcd_driver_start:                             ; preds = %err_register_root_hub, %if.then115
  %retval1.1 = phi i32 [ %call112, %if.then115 ], [ %retval1.0, %err_register_root_hub ]
  %call167 = call i32 @usb_hcd_is_primary_hcd(%struct.usb_hcd.588* %hcd)
  %tobool168 = icmp ne i32 %call167, 0
  br i1 %tobool168, label %land.lhs.true169, label %err_set_rh_speed

land.lhs.true169:                                 ; preds = %err_hcd_driver_start
  %irq = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 12
  %33 = load i32, i32* %irq, align 4, !tbaa !308
  %cmp170 = icmp ugt i32 %33, 0
  br i1 %cmp170, label %if.then172, label %err_set_rh_speed

if.then172:                                       ; preds = %land.lhs.true169
  %34 = bitcast %struct.usb_hcd.588* %hcd to i8*
  call void @free_irq(i32 %irqnum, i8* %34)
  br label %err_set_rh_speed

err_set_rh_speed:                                 ; preds = %if.then172, %land.lhs.true169, %err_hcd_driver_start, %if.then105, %if.then58, %LeafBlock, %LeafBlock1, %LeafBlock3
  %retval1.4 = phi i32 [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -22, %LeafBlock3 ], [ %call55, %if.then58 ], [ %call106, %if.then105 ], [ %retval1.1, %if.then172 ], [ %retval1.1, %land.lhs.true169 ], [ %retval1.1, %err_hcd_driver_start ]
  %self174 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %root_hub175 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self174, i32 0, i32 10
  %35 = load %struct.usb_device*, %struct.usb_device** %root_hub175, align 8, !tbaa !151
  call void @usb_put_dev(%struct.usb_device* %35)
  br label %err_allocate_root_hub

err_allocate_root_hub:                            ; preds = %err_set_rh_speed, %if.then40
  %retval1.5 = phi i32 [ -12, %if.then40 ], [ %retval1.4, %err_set_rh_speed ]
  %self176 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  call void @usb_deregister_bus(%struct.usb_bus* %self176)
  br label %err_register_bus

err_register_bus:                                 ; preds = %err_allocate_root_hub, %if.end29
  %retval1.6 = phi i32 [ %retval1.5, %err_allocate_root_hub ], [ %call31, %if.end29 ]
  call void bitcast (void (%struct.usb_hcd.2297*)* @hcd_buffer_destroy to void (%struct.usb_hcd.588*)*)(%struct.usb_hcd.588* %hcd)
  br label %cleanup

cleanup:                                          ; preds = %err_register_bus, %if.end142, %if.then22, %do.body15
  %retval.0 = phi i32 [ %retval1.6, %err_register_bus ], [ %call126, %if.end142 ], [ %call12, %if.then22 ], [ %call12, %do.body15 ]
  %36 = bitcast %struct.usb_device** %rhdev to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_register_bus(%struct.usb_bus* %bus) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @usb_bus_list_lock, i32 0)
  %call = call i64 @find_next_zero_bit(i64* getelementptr inbounds (%struct.sigset_t, %struct.sigset_t* @busmap, i32 0, i32 0, i32 0), i64 64, i64 1)
  %conv = trunc i64 %call to i32
  %cmp = icmp sge i32 %conv, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = call i32 (i8*, ...) @printk(i8* null)
  call void @mutex_unlock(%struct.mutex* @usb_bus_list_lock)
  br label %cleanup

if.end:                                           ; preds = %entry
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* getelementptr inbounds (%struct.sigset_t, %struct.sigset_t* @busmap, i32 0, i32 0, i32 0), i32 %conv, i64* getelementptr inbounds (%struct.sigset_t, %struct.sigset_t* @busmap, i32 0, i32 0, i32 0)) #8, !srcloc !310
  %busnum3 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 1
  store i32 %conv, i32* %busnum3, align 8, !tbaa !35
  %bus_list = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 12
  call void @list_add(%struct.list_head* %bus_list, %struct.list_head* @usb_bus_list)
  call void @mutex_unlock(%struct.mutex* @usb_bus_list_lock)
  call void @usb_notify_add_bus(%struct.usb_bus* %bus)
  %1 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ -7, %if.then ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @device_can_wakeup(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %can_wakeup = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i8, i8* %can_wakeup, align 4
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_hcd_request_irqs(%struct.usb_hcd.588* %hcd, i32 %irqnum, i64 %irqflags) #0 {
entry:
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %0 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %irq = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %0, i32 0, i32 3
  %1 = load i32 (%struct.usb_hcd.588*)*, i32 (%struct.usb_hcd.588*)** %irq, align 8, !tbaa !315
  %tobool = icmp ne i32 (%struct.usb_hcd.588*)* %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %and = and i64 %irqflags, 128
  %tobool2 = icmp ne i64 %and, 0
  %and4 = and i64 %irqflags, -33
  %and4.irqflags = select i1 %tobool2, i64 %and4, i64 %irqflags
  %irq_descr = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 4
  %arraydecay = getelementptr inbounds [24 x i8], [24 x i8]* %irq_descr, i32 0, i32 0
  %driver5 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %2 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver5, align 8, !tbaa !71
  %description = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %2, i32 0, i32 0
  %3 = load i8*, i8** %description, align 8, !tbaa !316
  %self = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %busnum = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 1
  %4 = load i32, i32* %busnum, align 8, !tbaa !317
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 24, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.64.76, i32 0, i32 0), i8* %3, i32 %4)
  %irq_descr6 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 4
  %arraydecay7 = getelementptr inbounds [24 x i8], [24 x i8]* %irq_descr6, i32 0, i32 0
  %5 = bitcast %struct.usb_hcd.588* %hcd to i8*
  %call8 = call i32 @request_irq(i32 %irqnum, i32 (i32, i8*)* @usb_hcd_irq, i64 %and4.irqflags, i8* %arraydecay7, i8* %5)
  %cmp = icmp ne i32 %call8, 0
  br i1 %cmp, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.then
  %6 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end12:                                         ; preds = %if.then
  %irq13 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 12
  store i32 %irqnum, i32* %irq13, align 4, !tbaa !308
  %7 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

if.else:                                          ; preds = %entry
  %irq20 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 12
  store i32 0, i32* %irq20, align 4, !tbaa !308
  %rsrc_start21 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 14
  %8 = load i64, i64* %rsrc_start21, align 8, !tbaa !318
  %tobool22 = icmp ne i64 %8, 0
  br i1 %tobool22, label %if.then23, label %cleanup

if.then23:                                        ; preds = %if.else
  %9 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %if.else, %if.end12, %if.then9
  %retval.0 = phi i32 [ %call8, %if.then9 ], [ 0, %if.else ], [ 0, %if.then23 ], [ 0, %if.end12 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @register_root_hub(%struct.usb_hcd.588* %hcd) #0 {
entry:
  %self = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !306
  %self1 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self1, i32 0, i32 10
  %1 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !151
  %devnum3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 0
  store i32 1, i32* %devnum3, align 8, !tbaa !38
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %devnum_next = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %2, i32 0, i32 8
  store i32 2, i32* %devnum_next, align 8, !tbaa !265
  %bus4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %3 = load %struct.usb_bus*, %struct.usb_bus** %bus4, align 8, !tbaa !2
  %devmap = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %3, i32 0, i32 9
  %devicemap = getelementptr inbounds %struct.usb_devmap, %struct.usb_devmap* %devmap, i32 0, i32 0
  %4 = bitcast [2 x i64]* %devicemap to i8*
  call void @llvm.memset.p0i8.i64(i8* %4, i8 0, i64 16, i32 8, i1 false)
  %bus5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %5 = load %struct.usb_bus*, %struct.usb_bus** %bus5, align 8, !tbaa !2
  %devmap6 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %5, i32 0, i32 9
  %devicemap7 = getelementptr inbounds %struct.usb_devmap, %struct.usb_devmap* %devmap6, i32 0, i32 0
  %arraydecay = getelementptr inbounds [2 x i64], [2 x i64]* %devicemap7, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i32 1, i64* %arraydecay) #8, !srcloc !310
  call void @usb_set_device_state(%struct.usb_device* %1, i32 6)
  call void @mutex_lock_nested(%struct.mutex* @usb_bus_list_lock, i32 0)
  %ep0 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 10
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep0, i32 0, i32 0
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc, i32 0, i32 4
  store i16 64, i16* %wMaxPacketSize, align 4, !tbaa !155
  %call = call i32 @usb_get_device_descriptor(%struct.usb_device* %1, i32 18)
  %conv = sext i32 %call to i64
  %cmp = icmp ne i64 %conv, 18
  br i1 %cmp, label %if.then, label %if.end20

if.then:                                          ; preds = %entry
  call void @mutex_unlock(%struct.mutex* @usb_bus_list_lock)
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @register_root_hub.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv11 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.then13, label %do.end17

if.then13:                                        ; preds = %if.then
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call14 = call i8* @dev_name(%struct.device* %dev)
  %call15 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @register_root_hub.descriptor to %struct._ddebug*), %struct.device* %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.70.72, i32 0, i32 0), i8* %call14, i32 %call)
  br label %do.end17

do.end17:                                         ; preds = %if.then13, %if.then
  %cmp18 = icmp slt i32 %call, 0
  %call. = select i1 %cmp18, i32 %call, i32 -90
  br label %cleanup

if.end20:                                         ; preds = %entry
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 4
  %6 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp21 = icmp eq i32 %6, 5
  br i1 %cmp21, label %if.then23, label %if.end52

if.then23:                                        ; preds = %if.end20
  %call24 = call i32 @usb_get_bos_descriptor(%struct.usb_device* %1)
  %cmp25 = icmp slt i32 %call24, 0
  br i1 %cmp25, label %if.then27, label %if.end52

if.then27:                                        ; preds = %if.then23
  call void @mutex_unlock(%struct.mutex* @usb_bus_list_lock)
  %bf.load30 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @register_root_hub.descriptor.71 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr31 = lshr i32 %bf.load30, 18
  %bf.clear32 = and i32 %bf.lshr31, 255
  %and33 = and i32 %bf.clear32, 1
  %tobool34 = icmp ne i32 %and33, 0
  %lnot35 = xor i1 %tobool34, true
  %lnot37 = xor i1 %lnot35, true
  %lnot.ext38 = zext i1 %lnot37 to i32
  %conv39 = sext i32 %lnot.ext38 to i64
  %expval40 = call i64 @llvm.expect.i64(i64 %conv39, i64 0)
  %tobool41 = icmp ne i64 %expval40, 0
  br i1 %tobool41, label %if.then42, label %cleanup

if.then42:                                        ; preds = %if.then27
  %dev43 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call44 = call i8* @dev_name(%struct.device* %dev43)
  %call45 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @register_root_hub.descriptor.71 to %struct._ddebug*), %struct.device* %0, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.72.73, i32 0, i32 0), i8* %call44, i32 %call24)
  br label %cleanup

if.end52:                                         ; preds = %if.then23, %if.end20
  %call53 = call i32 @usb_new_device(%struct.usb_device* %1)
  %tobool54 = icmp ne i32 %call53, 0
  br i1 %tobool54, label %if.then55, label %if.else

if.then55:                                        ; preds = %if.end52
  %dev56 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %call57 = call i8* @dev_name(%struct.device* %dev56)
  %7 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end65

if.else:                                          ; preds = %if.end52
  call void @spin_lock_irq.48(%struct.spinlock* @hcd_root_hub_lock)
  %rh_registered = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %bf.load59 = load i8, i8* %rh_registered, align 8
  %bf.clear60 = and i8 %bf.load59, -2
  %bf.set = or i8 %bf.clear60, 1
  store i8 %bf.set, i8* %rh_registered, align 8
  call void @spin_unlock_irq.49(%struct.spinlock* @hcd_root_hub_lock)
  %flags = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  %8 = load i64, i64* %flags, align 8, !tbaa !314
  %and61 = and i64 %8, 64
  %tobool62 = icmp ne i64 %and61, 0
  br i1 %tobool62, label %if.then63, label %if.end65

if.then63:                                        ; preds = %if.else
  call void @usb_hc_died(%struct.usb_hcd.588* %hcd)
  br label %if.end65

if.end65:                                         ; preds = %if.then63, %if.else, %if.then55
  call void @mutex_unlock(%struct.mutex* @usb_bus_list_lock)
  br label %cleanup

cleanup:                                          ; preds = %if.end65, %if.then42, %if.then27, %do.end17
  %retval.0 = phi i32 [ %call., %do.end17 ], [ %call53, %if.end65 ], [ %call24, %if.then42 ], [ %call24, %if.then27 ]
  ret i32 %retval.0
}

declare i32 @sysfs_create_group(%struct.kobject*, %struct.attribute_group*) #2

; Function Attrs: nounwind uwtable
define void @usb_hcd_poll_rh_status(%struct.usb_hcd.588* %hcd) #0 {
entry:
  %buffer = alloca [6 x i8], align 1
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast [6 x i8]* %buffer to i8*
  %rh_pollable = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %bf.load = load i8, i8* %rh_pollable, align 8
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %uses_new_polling = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %bf.load4 = load i8, i8* %uses_new_polling, align 8
  %bf.lshr5 = lshr i8 %bf.load4, 3
  %bf.clear6 = and i8 %bf.lshr5, 1
  %bf.cast7 = zext i8 %bf.clear6 to i32
  %tobool8 = icmp ne i32 %bf.cast7, 0
  br i1 %tobool8, label %if.end11, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %status_urb = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 6
  %1 = load %struct.urb*, %struct.urb** %status_urb, align 8, !tbaa !319
  %tobool9 = icmp ne %struct.urb* %1, null
  br i1 %tobool9, label %if.end11, label %cleanup

if.end11:                                         ; preds = %land.lhs.true, %if.end
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %2 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %hub_status_data = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %2, i32 0, i32 18
  %3 = load i32 (%struct.usb_hcd.588*, i8*)*, i32 (%struct.usb_hcd.588*, i8*)** %hub_status_data, align 8, !tbaa !320
  %arraydecay = getelementptr inbounds [6 x i8], [6 x i8]* %buffer, i32 0, i32 0
  %call = call i32 %3(%struct.usb_hcd.588* %hcd, i8* %arraydecay)
  %cmp = icmp sgt i32 %call, 0
  br i1 %cmp, label %do.body14, label %if.end31

do.body14:                                        ; preds = %if.end11
  %4 = bitcast i64* %__dummy to i8*
  %5 = bitcast i64* %__dummy2 to i8*
  %6 = bitcast i64* %__dummy2 to i8*
  %7 = bitcast i64* %__dummy to i8*
  %call17 = call %struct.raw_spinlock* @spinlock_check.65(%struct.spinlock* @hcd_root_hub_lock)
  %call18 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call17)
  %status_urb21 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 6
  %8 = load %struct.urb*, %struct.urb** %status_urb21, align 8, !tbaa !319
  %tobool22 = icmp ne %struct.urb* %8, null
  %flags24 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  br i1 %tobool22, label %if.then23, label %if.else

if.then23:                                        ; preds = %do.body14
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags24, i32 3, i64* %flags24) #8, !srcloc !304
  %status_urb25 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 6
  store %struct.urb* null, %struct.urb** %status_urb25, align 8, !tbaa !319
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %8, i32 0, i32 20
  store i32 %call, i32* %actual_length, align 4, !tbaa !292
  %conv26 = sext i32 %call to i64
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %8, i32 0, i32 14
  %9 = load i8*, i8** %transfer_buffer, align 8, !tbaa !293
  %arraydecay27 = getelementptr inbounds [6 x i8], [6 x i8]* %buffer, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %arraydecay27, i64 %conv26, i32 1, i1 false)
  call void @usb_hcd_unlink_urb_from_ep(%struct.usb_hcd.588* undef, %struct.urb* %8)
  call void @spin_unlock(%struct.spinlock* @hcd_root_hub_lock)
  call void @usb_hcd_giveback_urb(%struct.usb_hcd.588* %hcd, %struct.urb* %8, i32 0)
  call void @spin_lock(%struct.spinlock* @hcd_root_hub_lock)
  br label %if.end30

if.else:                                          ; preds = %do.body14
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags24, i32 3, i64* %flags24) #8, !srcloc !310
  br label %if.end30

if.end30:                                         ; preds = %if.else, %if.then23
  %length.0 = phi i32 [ %call, %if.then23 ], [ 0, %if.else ]
  call void @spin_unlock_irqrestore.66(%struct.spinlock* @hcd_root_hub_lock, i64 %call18)
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.end11
  %length.1 = phi i32 [ %length.0, %if.end30 ], [ %call, %if.end11 ]
  %uses_new_polling32 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %bf.load33 = load i8, i8* %uses_new_polling32, align 8
  %bf.lshr34 = lshr i8 %bf.load33, 3
  %bf.clear35 = and i8 %bf.lshr34, 1
  %bf.cast36 = zext i8 %bf.clear35 to i32
  %tobool37 = icmp ne i32 %bf.cast36, 0
  br i1 %tobool37, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end31
  %flags38 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  %10 = load i64, i64* %flags38, align 8, !tbaa !314
  %and = and i64 %10, 4
  %tobool39 = icmp ne i64 %and, 0
  br i1 %tobool39, label %if.then47, label %cleanup

cond.false:                                       ; preds = %if.end31
  %cmp40 = icmp eq i32 %length.1, 0
  br i1 %cmp40, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.false
  %status_urb42 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 6
  %11 = load %struct.urb*, %struct.urb** %status_urb42, align 8, !tbaa !319
  %cmp43 = icmp ne %struct.urb* %11, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.false
  %12 = phi i1 [ false, %cond.false ], [ %cmp43, %land.rhs ]
  %land.ext = zext i1 %12 to i32
  %conv45 = sext i32 %land.ext to i64
  %tobool46 = icmp ne i64 %conv45, 0
  br i1 %tobool46, label %if.then47, label %cleanup

if.then47:                                        ; preds = %land.end, %cond.true
  %rh_timer = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 5
  %13 = load volatile i64, i64* @jiffies, align 8, !tbaa !49
  %div = udiv i64 %13, 62
  %add = add i64 %div, 1
  %mul = mul i64 %add, 62
  %call48 = call i32 @mod_timer(%struct.timer_list* %rh_timer, i64 %mul)
  br label %cleanup

cleanup:                                          ; preds = %if.then47, %land.end, %cond.true, %land.lhs.true, %entry
  %14 = bitcast [6 x i8]* %buffer to i8*
  ret void
}

declare i32 @device_wakeup_enable(%struct.device*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check.65(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_unlink_urb_from_ep(%struct.usb_hcd.588* %hcd, %struct.urb* %urb) #0 {
entry:
  call void @spin_lock(%struct.spinlock* @hcd_urb_list_lock)
  %urb_list = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 5
  call void @list_del_init.69(%struct.list_head* %urb_list)
  call void @spin_unlock(%struct.spinlock* @hcd_urb_list_lock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_giveback_urb(%struct.usb_hcd.588* %hcd, %struct.urb* %urb, i32 %status) #0 {
entry:
  %hcpriv = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 1
  store i8* null, i8** %hcpriv, align 8, !tbaa !321
  %unlinked = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 4
  %0 = load i32, i32* %unlinked, align 8, !tbaa !322
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %unlinked3 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 4
  %1 = load i32, i32* %unlinked3, align 8, !tbaa !322
  br label %if.end17

if.else:                                          ; preds = %entry
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %2 = load i32, i32* %transfer_flags, align 4, !tbaa !323
  %and = and i32 %2, 1
  %tobool4 = icmp ne i32 %and, 0
  br i1 %tobool4, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %if.else
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %3 = load i32, i32* %actual_length, align 4, !tbaa !292
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %4 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !294
  %cmp = icmp ult i32 %3, %4
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %tobool6 = icmp ne i32 %status, 0
  %lnot7 = xor i1 %tobool6, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %if.else
  %5 = phi i1 [ false, %land.lhs.true ], [ false, %if.else ], [ %lnot7, %land.rhs ]
  %lnot9 = xor i1 %5, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  %.status = select i1 %tobool15, i32 -121, i32 %status
  br label %if.end17

if.end17:                                         ; preds = %land.end, %if.then
  %status.addr.1 = phi i32 [ %1, %if.then ], [ %.status, %land.end ]
  call void @unmap_urb_for_dma(%struct.usb_hcd.588* %hcd, %struct.urb* %urb)
  %self = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  call void @usbmon_urb_complete(%struct.usb_bus* %self, %struct.urb* %urb, i32 %status.addr.1)
  call void bitcast (void (%struct.urb.824*)* @usb_unanchor_urb to void (%struct.urb*)*)(%struct.urb* %urb)
  %status18 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 12
  store i32 %status.addr.1, i32* %status18, align 8, !tbaa !291
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 28
  %6 = load void (%struct.urb*)*, void (%struct.urb*)** %complete, align 8, !tbaa !295
  call void %6(%struct.urb* %urb)
  %use_count = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 2
  call void @atomic_dec(%union.anon.5* %use_count)
  %reject = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 3
  %call = call i32 @atomic_read.67(%union.anon.5* %reject)
  %tobool19 = icmp ne i32 %call, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %expval25 = call i64 @llvm.expect.i64(i64 %conv24, i64 0)
  %tobool26 = icmp ne i64 %expval25, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end17
  call void @__wake_up(%struct.__wait_queue_head* @usb_kill_urb_queue, i32 3, i32 1, i8* null)
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %if.end17
  call void bitcast (void (%struct.urb.824*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %urb)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore.66(%struct.spinlock* %lock, i64 %flags) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

declare i32 @mod_timer(%struct.timer_list*, i64) #2

declare void @_raw_spin_lock(%struct.raw_spinlock*) #2 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal void @unmap_urb_for_dma(%struct.usb_hcd.588* %hcd, %struct.urb* %urb) #0 {
entry:
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %0 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %unmap_urb_for_dma = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %0, i32 0, i32 15
  %1 = load void (%struct.usb_hcd.588*, %struct.urb*)*, void (%struct.usb_hcd.588*, %struct.urb*)** %unmap_urb_for_dma, align 8, !tbaa !324
  %tobool = icmp ne void (%struct.usb_hcd.588*, %struct.urb*)* %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %driver1 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %2 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver1, align 8, !tbaa !71
  %unmap_urb_for_dma2 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %2, i32 0, i32 15
  %3 = load void (%struct.usb_hcd.588*, %struct.urb*)*, void (%struct.usb_hcd.588*, %struct.urb*)** %unmap_urb_for_dma2, align 8, !tbaa !324
  call void %3(%struct.usb_hcd.588* %hcd, %struct.urb* %urb)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @usb_hcd_unmap_urb_for_dma(%struct.usb_hcd.588* %hcd, %struct.urb* %urb)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usbmon_urb_complete(%struct.usb_bus* %bus, %struct.urb* %urb, i32 %status) #1 {
entry:
  %monitored = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 18
  %0 = load i32, i32* %monitored, align 8, !tbaa !325
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.usb_mon_operations*, %struct.usb_mon_operations** @mon_ops, align 8, !tbaa !48
  %urb_complete = getelementptr inbounds %struct.usb_mon_operations, %struct.usb_mon_operations* %1, i32 0, i32 2
  %2 = load void (%struct.usb_bus*, %struct.urb*, i32)*, void (%struct.usb_bus*, %struct.urb*, i32)** %urb_complete, align 8, !tbaa !326
  call void %2(%struct.usb_bus* %bus, %struct.urb* %urb, i32 %status)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_dec(%union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #8, !srcloc !328
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read.67(%union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !90
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_unmap_urb_for_dma(%struct.usb_hcd.588* %hcd, %struct.urb* %urb) #0 {
entry:
  call void @usb_hcd_unmap_urb_setup_for_dma(%struct.usb_hcd.588* %hcd, %struct.urb* %urb)
  %call = call i32 @usb_urb_dir_in(%struct.urb* %urb)
  %tobool = icmp ne i32 %call, 0
  %cond = select i1 %tobool, i32 2, i32 1
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %0 = load i32, i32* %transfer_flags, align 4, !tbaa !323
  %and = and i32 %0, 262144
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %self = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %1 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !306
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 16
  %2 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8, !tbaa !329
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %3 = load i32, i32* %num_sgs, align 4, !tbaa !330
  call void @dma_unmap_sg_attrs(%struct.device* %1, %struct.scatterlist* %2, i32 %3, i32 %cond, %struct.sigset_t* null)
  br label %if.end28

if.else:                                          ; preds = %entry
  %transfer_flags2 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %4 = load i32, i32* %transfer_flags2, align 4, !tbaa !323
  %and3 = and i32 %4, 131072
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then5, label %if.else8

if.then5:                                         ; preds = %if.else
  %self6 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller7 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self6, i32 0, i32 0
  %5 = load %struct.device*, %struct.device** %controller7, align 8, !tbaa !306
  %transfer_dma = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 15
  %6 = load i64, i64* %transfer_dma, align 8, !tbaa !331
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %7 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !294
  %conv = zext i32 %7 to i64
  call void @dma_unmap_page(%struct.device* %5, i64 %6, i64 %conv, i32 %cond)
  br label %if.end28

if.else8:                                         ; preds = %if.else
  %transfer_flags9 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %8 = load i32, i32* %transfer_flags9, align 4, !tbaa !323
  %and10 = and i32 %8, 65536
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.else18

if.then12:                                        ; preds = %if.else8
  %self13 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller14 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self13, i32 0, i32 0
  %9 = load %struct.device*, %struct.device** %controller14, align 8, !tbaa !306
  %transfer_dma15 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 15
  %10 = load i64, i64* %transfer_dma15, align 8, !tbaa !331
  %transfer_buffer_length16 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %11 = load i32, i32* %transfer_buffer_length16, align 8, !tbaa !294
  %conv17 = zext i32 %11 to i64
  call void @dma_unmap_single_attrs(%struct.device* %9, i64 %10, i64 %conv17, i32 %cond, %struct.sigset_t* null)
  br label %if.end28

if.else18:                                        ; preds = %if.else8
  %transfer_flags19 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %12 = load i32, i32* %transfer_flags19, align 4, !tbaa !323
  %and20 = and i32 %12, 524288
  %tobool21 = icmp ne i32 %and20, 0
  br i1 %tobool21, label %if.then22, label %if.end28

if.then22:                                        ; preds = %if.else18
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %13 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !210
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 9
  %14 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %transfer_dma23 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 15
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %transfer_buffer_length24 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %15 = load i32, i32* %transfer_buffer_length24, align 8, !tbaa !294
  %conv25 = zext i32 %15 to i64
  call void @hcd_free_coherent(%struct.usb_bus* %14, i64* %transfer_dma23, i8** %transfer_buffer, i64 %conv25, i32 %cond)
  br label %if.end28

if.end28:                                         ; preds = %if.then22, %if.else18, %if.then12, %if.then5, %if.then
  %transfer_flags29 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %16 = load i32, i32* %transfer_flags29, align 4, !tbaa !323
  %and30 = and i32 %16, -983041
  store i32 %and30, i32* %transfer_flags29, align 4, !tbaa !323
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_unmap_urb_setup_for_dma(%struct.usb_hcd.588* %hcd, %struct.urb* %urb) #0 {
entry:
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %0 = load i32, i32* %transfer_flags, align 4, !tbaa !323
  %and = and i32 %0, 1048576
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %self = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %1 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !306
  %setup_dma = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 22
  %2 = load i64, i64* %setup_dma, align 8, !tbaa !332
  call void @dma_unmap_single_attrs(%struct.device* %1, i64 %2, i64 8, i32 1, %struct.sigset_t* null)
  br label %if.end6

if.else:                                          ; preds = %entry
  %transfer_flags1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %3 = load i32, i32* %transfer_flags1, align 4, !tbaa !323
  %and2 = and i32 %3, 2097152
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.else
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !210
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 9
  %5 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %setup_dma5 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 22
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 21
  call void @hcd_free_coherent(%struct.usb_bus* %5, i64* %setup_dma5, i8** %setup_packet, i64 8, i32 1)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.else, %if.then
  %transfer_flags7 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %6 = load i32, i32* %transfer_flags7, align 4, !tbaa !323
  %and8 = and i32 %6, -3145729
  store i32 %and8, i32* %transfer_flags7, align 4, !tbaa !323
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_urb_dir_in(%struct.urb* %urb) #1 {
entry:
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %0 = load i32, i32* %transfer_flags, align 4, !tbaa !323
  %and = and i32 %0, 512
  %cmp = icmp eq i32 %and, 512
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @dma_unmap_sg_attrs(%struct.device* %dev, %struct.scatterlist* %sg, i32 %nents, i32 %dir, %struct.sigset_t* %attrs) #1 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  %call1 = call i32 @valid_dma_direction(i32 %dir)
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.end10

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.51.68, i32 0, i32 0), i32 65, i64 12) #8, !srcloc !333
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.end10:                                         ; preds = %entry
  call void @debug_dma_unmap_sg(%struct.device* %dev, %struct.scatterlist* %sg, i32 %nents, i32 %dir)
  %unmap_sg = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 7
  %0 = load void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)*, void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)** %unmap_sg, align 8, !tbaa !334
  %tobool11 = icmp ne void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)* %0, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %do.end10
  %unmap_sg13 = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 7
  %1 = load void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)*, void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)** %unmap_sg13, align 8, !tbaa !334
  call void %1(%struct.device* %dev, %struct.scatterlist* %sg, i32 %nents, i32 %dir, %struct.sigset_t* %attrs)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %do.end10
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @dma_unmap_page(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir) #1 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  %call1 = call i32 @valid_dma_direction(i32 %dir)
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.end10

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.51.68, i32 0, i32 0), i32 91, i64 12) #8, !srcloc !336
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.end10:                                         ; preds = %entry
  %unmap_page = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 5
  %0 = load void (%struct.device*, i64, i64, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i64, i32, %struct.sigset_t*)** %unmap_page, align 8, !tbaa !337
  %tobool11 = icmp ne void (%struct.device*, i64, i64, i32, %struct.sigset_t*)* %0, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %do.end10
  %unmap_page13 = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 5
  %1 = load void (%struct.device*, i64, i64, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i64, i32, %struct.sigset_t*)** %unmap_page13, align 8, !tbaa !337
  call void %1(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, %struct.sigset_t* null)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %do.end10
  call void @debug_dma_unmap_page(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, i1 zeroext false)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @dma_unmap_single_attrs(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, %struct.sigset_t* %attrs) #1 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  %call1 = call i32 @valid_dma_direction(i32 %dir)
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.end10

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.51.68, i32 0, i32 0), i32 36, i64 12) #8, !srcloc !338
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.end10:                                         ; preds = %entry
  %unmap_page = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 5
  %0 = load void (%struct.device*, i64, i64, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i64, i32, %struct.sigset_t*)** %unmap_page, align 8, !tbaa !337
  %tobool11 = icmp ne void (%struct.device*, i64, i64, i32, %struct.sigset_t*)* %0, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %do.end10
  %unmap_page13 = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 5
  %1 = load void (%struct.device*, i64, i64, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i64, i32, %struct.sigset_t*)** %unmap_page13, align 8, !tbaa !337
  call void %1(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, %struct.sigset_t* %attrs)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %do.end10
  call void @debug_dma_unmap_page(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, i1 zeroext true)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hcd_free_coherent(%struct.usb_bus* %bus, i64* %dma_handle, i8** %vaddr_handle, i64 %size, i32 %dir) #0 {
entry:
  %0 = load i8*, i8** %vaddr_handle, align 8, !tbaa !48
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 %size
  %1 = bitcast i8* %add.ptr to i64*
  %2 = bitcast i64* %1 to i8*
  %call = call i64 @get_unaligned_le64(i8* %2)
  %3 = inttoptr i64 %call to i8*
  %cmp = icmp eq i32 %dir, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i8*, i8** %vaddr_handle, align 8, !tbaa !48
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 %size, i32 1, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %add = add i64 %size, 8
  %5 = load i8*, i8** %vaddr_handle, align 8, !tbaa !48
  %6 = load i64, i64* %dma_handle, align 8, !tbaa !339
  call void @hcd_buffer_free(%struct.usb_bus* %bus, i64 %add, i8* %5, i64 %6)
  store i8* %3, i8** %vaddr_handle, align 8, !tbaa !48
  store i64 0, i64* %dma_handle, align 8, !tbaa !339
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @get_unaligned_le64(i8* %p) #1 {
entry:
  %0 = bitcast i8* %p to i64*
  %call = call i64 @__le64_to_cpup(i64* %0)
  ret i64 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @__le64_to_cpup(i64* %p) #1 {
entry:
  %0 = load i64, i64* %p, align 8, !tbaa !339
  ret i64 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev) #1 {
entry:
  %tobool = icmp ne %struct.device* %dev, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %archdata = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 17
  %dma_ops = getelementptr inbounds %struct.dev_archdata, %struct.dev_archdata* %archdata, i32 0, i32 0
  %0 = load %struct.dma_map_ops*, %struct.dma_map_ops** %dma_ops, align 8, !tbaa !340
  %tobool4 = icmp ne %struct.dma_map_ops* %0, null
  br i1 %tobool4, label %if.else, label %return

if.else:                                          ; preds = %lor.lhs.false
  %archdata5 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 17
  %dma_ops6 = getelementptr inbounds %struct.dev_archdata, %struct.dev_archdata* %archdata5, i32 0, i32 0
  br label %return

return:                                           ; preds = %if.else, %lor.lhs.false, %entry
  %dma_ops6.sink = phi %struct.dma_map_ops** [ %dma_ops6, %if.else ], [ @dma_ops, %lor.lhs.false ], [ @dma_ops, %entry ]
  %1 = load %struct.dma_map_ops*, %struct.dma_map_ops** %dma_ops6.sink, align 8, !tbaa !48
  ret %struct.dma_map_ops* %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @valid_dma_direction(i32 %dma_direction) #1 {
entry:
  %switch = icmp ult i32 %dma_direction, 3
  %. = select i1 %switch, i1 true, i1 false
  %lor.ext = zext i1 %. to i32
  ret i32 %lor.ext
}

declare void @debug_dma_unmap_page(%struct.device*, i64, i64, i32, i1 zeroext) #2

declare void @debug_dma_unmap_sg(%struct.device*, %struct.scatterlist*, i32, i32) #2

declare void @_raw_spin_unlock(%struct.raw_spinlock*) #2 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init.69(%struct.list_head* %entry1) #1 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD.70(%struct.list_head* %entry1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.70(%struct.list_head* %list) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !95
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !96
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name(%struct.device* %dev) #1 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !341
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !341
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_hc_died(%struct.usb_hcd.588* %hcd) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %1 = bitcast i64* %__dummy to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy2 to i8*
  %4 = bitcast i64* %__dummy to i8*
  %call2 = call %struct.raw_spinlock* @spinlock_check.65(%struct.spinlock* @hcd_root_hub_lock)
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call2)
  %flags6 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags6, i32 5, i64* %flags6) #8, !srcloc !304
  %flags7 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags7, i32 6, i64* %flags7) #8, !srcloc !310
  %rh_registered = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %bf.load = load i8, i8* %rh_registered, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %flags8 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags8, i32 2, i64* %flags8) #8, !srcloc !304
  %self9 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self9, i32 0, i32 10
  %5 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !151
  call void @usb_set_device_state(%struct.usb_device* %5, i32 0)
  %self10 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %root_hub11 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self10, i32 0, i32 10
  %6 = load %struct.usb_device*, %struct.usb_device** %root_hub11, align 8, !tbaa !151
  call void @usb_kick_khubd(%struct.usb_device* %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call12 = call i32 @usb_hcd_is_primary_hcd(%struct.usb_hcd.588* %hcd)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %land.lhs.true, label %if.end29

land.lhs.true:                                    ; preds = %if.end
  %shared_hcd = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 18
  %7 = load %struct.usb_hcd.588*, %struct.usb_hcd.588** %shared_hcd, align 8, !tbaa !342
  %tobool14 = icmp ne %struct.usb_hcd.588* %7, null
  br i1 %tobool14, label %if.then15, label %if.end29

if.then15:                                        ; preds = %land.lhs.true
  %shared_hcd16 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 18
  %8 = load %struct.usb_hcd.588*, %struct.usb_hcd.588** %shared_hcd16, align 8, !tbaa !342
  %rh_registered17 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %8, i32 0, i32 11
  %bf.load18 = load i8, i8* %rh_registered17, align 8
  %bf.clear19 = and i8 %bf.load18, 1
  %bf.cast20 = zext i8 %bf.clear19 to i32
  %tobool21 = icmp ne i32 %bf.cast20, 0
  br i1 %tobool21, label %if.then22, label %if.end29

if.then22:                                        ; preds = %if.then15
  %flags23 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %8, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags23, i32 2, i64* %flags23) #8, !srcloc !304
  %self24 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %8, i32 0, i32 0
  %root_hub25 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self24, i32 0, i32 10
  %9 = load %struct.usb_device*, %struct.usb_device** %root_hub25, align 8, !tbaa !151
  call void @usb_set_device_state(%struct.usb_device* %9, i32 0)
  %self26 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %8, i32 0, i32 0
  %root_hub27 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self26, i32 0, i32 10
  %10 = load %struct.usb_device*, %struct.usb_device** %root_hub27, align 8, !tbaa !151
  call void @usb_kick_khubd(%struct.usb_device* %10)
  br label %if.end29

if.end29:                                         ; preds = %if.then22, %if.then15, %land.lhs.true, %if.end
  call void @spin_unlock_irqrestore.66(%struct.spinlock* @hcd_root_hub_lock, i64 %call3)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name(%struct.kobject* %kobj) #1 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !343
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_irq(i32 %irq, i8* %__hcd) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy20 = alloca i64, align 8
  %__dummy221 = alloca i64, align 8
  %__dummy30 = alloca i64, align 8
  %__dummy231 = alloca i64, align 8
  %__dummy39 = alloca i64, align 8
  %__dummy240 = alloca i64, align 8
  %0 = bitcast i8* %__hcd to %struct.usb_hcd.588*
  %1 = bitcast i64* %__dummy to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy2 to i8*
  %4 = bitcast i64* %__dummy to i8*
  %call = call i64 @arch_local_irq_save()
  call void @trace_hardirqs_off()
  %flags4 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %0, i32 0, i32 10
  %5 = load i64, i64* %flags4, align 8, !tbaa !314
  %and = and i64 %5, 64
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %flags5 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %0, i32 0, i32 10
  %6 = load i64, i64* %flags5, align 8, !tbaa !314
  %and6 = and i64 %6, 1
  %tobool7 = icmp ne i64 %and6, 0
  %lnot = xor i1 %tobool7, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %7 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot8 = xor i1 %7, true
  %lnot9 = xor i1 %lnot8, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv10 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv10, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %do.body19, label %if.else

if.else:                                          ; preds = %lor.end
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %0, i32 0, i32 8
  %8 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %irq12 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %8, i32 0, i32 3
  %9 = load i32 (%struct.usb_hcd.588*)*, i32 (%struct.usb_hcd.588*)** %irq12, align 8, !tbaa !315
  %call13 = call i32 %9(%struct.usb_hcd.588* %0)
  %cmp14 = icmp eq i32 %call13, 0
  %. = select i1 %cmp14, i32 0, i32 1
  br label %do.body19

do.body19:                                        ; preds = %if.else, %lor.end
  %rc.1 = phi i32 [ %., %if.else ], [ 0, %lor.end ]
  %10 = bitcast i64* %__dummy20 to i8*
  %11 = bitcast i64* %__dummy221 to i8*
  %12 = bitcast i64* %__dummy221 to i8*
  %13 = bitcast i64* %__dummy20 to i8*
  %call26 = call i32 @arch_irqs_disabled_flags(i64 %call)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %do.body29, label %if.else37

do.body29:                                        ; preds = %do.body19
  %14 = bitcast i64* %__dummy30 to i8*
  %15 = bitcast i64* %__dummy231 to i8*
  %16 = bitcast i64* %__dummy231 to i8*
  %17 = bitcast i64* %__dummy30 to i8*
  call void @arch_local_irq_restore(i64 %call)
  call void @trace_hardirqs_off()
  br label %do.end48

if.else37:                                        ; preds = %do.body19
  call void @trace_hardirqs_on()
  %18 = bitcast i64* %__dummy39 to i8*
  %19 = bitcast i64* %__dummy240 to i8*
  %20 = bitcast i64* %__dummy240 to i8*
  %21 = bitcast i64* %__dummy39 to i8*
  call void @arch_local_irq_restore(i64 %call)
  br label %do.end48

do.end48:                                         ; preds = %if.else37, %do.body29
  ret i32 %rc.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @request_irq(i32 %irq, i32 (i32, i8*)* %handler, i64 %flags, i8* %name, i8* %dev) #1 {
entry:
  %call = call i32 @request_threaded_irq(i32 %irq, i32 (i32, i8*)* %handler, i32 (i32, i8*)* null, i64 %flags, i8* %name, i8* %dev)
  ret i32 %call
}

declare i32 @request_threaded_irq(i32, i32 (i32, i8*)*, i32 (i32, i8*)*, i64, i8*, i8*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @arch_local_irq_save() #1 {
entry:
  %call = call i64 @arch_local_save_flags()
  call void @arch_local_irq_disable()
  ret i64 %call
}

declare void @trace_hardirqs_off() #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @arch_irqs_disabled_flags(i64 %flags) #1 {
entry:
  %and = and i64 %flags, 512
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @arch_local_irq_restore(i64 %f) #1 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops.581, %struct.pv_irq_ops.581* @pv_irq_ops, i32 0, i32 1, i32 0), align 8, !tbaa !344
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.9.881, i32 0, i32 0), i32 829, i64 12) #8, !srcloc !347
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call i64 asm sideeffect "771:\0A\09call *${2:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${1:c}\0A  .byte 772b-771b\0A  .short ${3:c}\0A.popsection\0A", "={ax},i,i,i,{di},~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 45, i8** getelementptr inbounds (%struct.pv_irq_ops.581, %struct.pv_irq_ops.581* @pv_irq_ops, i32 0, i32 1, i32 0), i32 1, i64 %f) #8, !srcloc !348
  ret void
}

declare void @trace_hardirqs_on() #2

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @arch_local_save_flags() #1 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops.581, %struct.pv_irq_ops.581* @pv_irq_ops, i32 0, i32 0, i32 0), align 8, !tbaa !349
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.9.881, i32 0, i32 0), i32 824, i64 12) #8, !srcloc !350
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call i64 asm sideeffect "771:\0A\09call *${2:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${1:c}\0A  .byte 772b-771b\0A  .short ${3:c}\0A.popsection\0A", "={ax},i,i,i,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 44, i8** getelementptr inbounds (%struct.pv_irq_ops.581, %struct.pv_irq_ops.581* @pv_irq_ops, i32 0, i32 0, i32 0), i32 1) #8, !srcloc !351
  ret i64 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @arch_local_irq_disable() #1 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops.581, %struct.pv_irq_ops.581* @pv_irq_ops, i32 0, i32 2, i32 0), align 8, !tbaa !352
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.9.881, i32 0, i32 0), i32 834, i64 12) #8, !srcloc !353
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call i64 asm sideeffect "771:\0A\09call *${2:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${1:c}\0A  .byte 772b-771b\0A  .short ${3:c}\0A.popsection\0A", "={ax},i,i,i,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 46, i8** getelementptr inbounds (%struct.pv_irq_ops.581, %struct.pv_irq_ops.581* @pv_irq_ops, i32 0, i32 2, i32 0), i32 1) #8, !srcloc !354
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add(%struct.list_head* %new, %struct.list_head* %head) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !95
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_put_hcd(%struct.usb_hcd.588* %hcd) #0 {
entry:
  %tobool = icmp ne %struct.usb_hcd.588* %hcd, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %kref = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 1
  call void @kref_put.84(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* @hcd_release)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hcd_release(%struct.arch_spinlock* %kref) #0 {
entry:
  %0 = bitcast %struct.arch_spinlock* %kref to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -120
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd.588*
  %call = call i32 @usb_hcd_is_primary_hcd(%struct.usb_hcd.588* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 17
  %2 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !146
  %3 = bitcast %struct.mutex* %2 to i8*
  call void @kfree(i8* %3)
  br label %if.end

if.else:                                          ; preds = %entry
  %shared_hcd = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 18
  %4 = load %struct.usb_hcd.588*, %struct.usb_hcd.588** %shared_hcd, align 8, !tbaa !342
  %shared_hcd1 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %4, i32 0, i32 18
  store %struct.usb_hcd.588* null, %struct.usb_hcd.588** %shared_hcd1, align 8, !tbaa !342
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %5 = bitcast %struct.usb_hcd.588* %1 to i8*
  call void @kfree(i8* %5)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put.84(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* %release) #1 {
entry:
  call void @kref_sub.85(%struct.arch_spinlock* %kref, i32 1, void (%struct.arch_spinlock*)* %release)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_sub.85(%struct.arch_spinlock* %kref, i32 %count, void (%struct.arch_spinlock*)* %release) #1 {
entry:
  %cmp = icmp eq void (%struct.arch_spinlock*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.10.486, i32 0, i32 0), i32 71)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_sub_and_test.87(i32 %count, %union.anon.5* %refcount)
  %tobool14 = icmp ne i32 %call, 0
  br i1 %tobool14, label %if.then15, label %return

if.then15:                                        ; preds = %if.end
  call void %release(%struct.arch_spinlock* %kref)
  br label %return

return:                                           ; preds = %if.then15, %if.end
  %retval.0 = phi i32 [ 1, %if.then15 ], [ 0, %if.end ]
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_sub_and_test.87(i32 %i, %union.anon.5* %v) #1 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subl $2,$0; sete $1", "=*m,=*qm,ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32 %i, i32* %counter) #8, !srcloc !355
  %0 = load i8, i8* %c, align 1, !tbaa !84
  %conv = zext i8 %0 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define %struct.usb_hcd.588* @usb_get_hcd(%struct.usb_hcd.588* %hcd) #0 {
entry:
  %tobool = icmp ne %struct.usb_hcd.588* %hcd, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %kref = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 1
  call void @kref_get.90(%struct.arch_spinlock* %kref)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.usb_hcd.588* %hcd
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_get.90(%struct.arch_spinlock* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_add_return.91(i32 1, %union.anon.5* %refcount)
  %cmp = icmp slt i32 %call, 2
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  %0 = load i8, i8* @kref_get.__warned.92, align 1, !tbaa !43, !range !44
  %tobool7 = trunc i8 %0 to i1
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %tobool14 = icmp ne i32 %lnot.ext13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.10.486, i32 0, i32 0), i32 47)
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then
  %tobool23 = icmp ne i32 %lnot.ext13, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end
  store i8 1, i8* @kref_get.__warned.92, align 1, !tbaa !43
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_return.91(i32 %i, %union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #8, !srcloc !356
  %add = add nsw i32 %i, %0
  ret i32 %add
}

; Function Attrs: nounwind uwtable
define %struct.usb_hcd.588* @usb_create_hcd(%struct.hc_driver.589* %driver, %struct.device* %dev, i8* %bus_name) #0 {
entry:
  %call = call %struct.usb_hcd.588* @usb_create_shared_hcd(%struct.hc_driver.589* %driver, %struct.device* %dev, i8* %bus_name, %struct.usb_hcd.588* null)
  ret %struct.usb_hcd.588* %call
}

; Function Attrs: nounwind uwtable
define %struct.usb_hcd.588* @usb_create_shared_hcd(%struct.hc_driver.589* %driver, %struct.device* %dev, i8* %bus_name, %struct.usb_hcd.588* %primary_hcd) #0 {
entry:
  %.compoundliteral = alloca %struct.pgprot, align 8
  %hcd_priv_size = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %driver, i32 0, i32 2
  %0 = load i64, i64* %hcd_priv_size, align 8, !tbaa !357
  %add = add i64 512, %0
  %call = call i8* @kzalloc.93(i64 %add, i32 208)
  %1 = bitcast i8* %call to %struct.usb_hcd.588*
  %tobool = icmp ne %struct.usb_hcd.588* %1, null
  br i1 %tobool, label %if.end9, label %do.body1

do.body1:                                         ; preds = %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_create_shared_hcd.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool2 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then5, label %cleanup

if.then5:                                         ; preds = %do.body1
  %call6 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_create_shared_hcd.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.28, i32 0, i32 0))
  br label %cleanup

if.end9:                                          ; preds = %entry
  %cmp = icmp eq %struct.usb_hcd.588* %primary_hcd, null
  br i1 %cmp, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.end9
  %call.i = call i8* @__kmalloc(i64 168, i32 208) #8
  %2 = bitcast i8* %call.i to %struct.mutex*
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 17
  store %struct.mutex* %2, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !146
  %bandwidth_mutex13 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 17
  %3 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex13, align 8, !tbaa !146
  %tobool14 = icmp ne %struct.mutex* %3, null
  br i1 %tobool14, label %do.body38, label %if.then15

if.then15:                                        ; preds = %if.then11
  %4 = bitcast %struct.usb_hcd.588* %1 to i8*
  call void @kfree(i8* %4)
  %bf.load18 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_create_shared_hcd.descriptor.29 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr19 = lshr i32 %bf.load18, 18
  %bf.clear20 = and i32 %bf.lshr19, 255
  %and21 = and i32 %bf.clear20, 1
  %tobool22 = icmp ne i32 %and21, 0
  %lnot23 = xor i1 %tobool22, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %conv27 = sext i32 %lnot.ext26 to i64
  %expval28 = call i64 @llvm.expect.i64(i64 %conv27, i64 0)
  %tobool29 = icmp ne i64 %expval28, 0
  br i1 %tobool29, label %if.then30, label %cleanup

if.then30:                                        ; preds = %if.then15
  %call31 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_create_shared_hcd.descriptor.29 to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.30, i32 0, i32 0))
  br label %cleanup

do.body38:                                        ; preds = %if.then11
  %bandwidth_mutex39 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 17
  %5 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex39, align 8, !tbaa !146
  call void @__mutex_init(%struct.mutex* %5, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.31.95, i32 0, i32 0), %struct.lock_class_key* @usb_create_shared_hcd.__key)
  %6 = bitcast %struct.usb_hcd.588* %1 to i8*
  %call42 = call i32 @dev_set_drvdata(%struct.device* %dev, i8* %6)
  br label %if.end48

if.else:                                          ; preds = %if.end9
  %bandwidth_mutex43 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %primary_hcd, i32 0, i32 17
  %7 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex43, align 8, !tbaa !146
  %bandwidth_mutex44 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 17
  store %struct.mutex* %7, %struct.mutex** %bandwidth_mutex44, align 8, !tbaa !146
  %primary_hcd45 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 19
  store %struct.usb_hcd.588* %primary_hcd, %struct.usb_hcd.588** %primary_hcd45, align 8, !tbaa !309
  %primary_hcd46 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %primary_hcd, i32 0, i32 19
  store %struct.usb_hcd.588* %primary_hcd, %struct.usb_hcd.588** %primary_hcd46, align 8, !tbaa !309
  %shared_hcd = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 18
  store %struct.usb_hcd.588* %primary_hcd, %struct.usb_hcd.588** %shared_hcd, align 8, !tbaa !342
  %shared_hcd47 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %primary_hcd, i32 0, i32 18
  store %struct.usb_hcd.588* %1, %struct.usb_hcd.588** %shared_hcd47, align 8, !tbaa !342
  br label %if.end48

if.end48:                                         ; preds = %if.else, %do.body38
  %kref = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 1
  call void @kref_init.96(%struct.arch_spinlock* %kref)
  %self = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 0
  call void @usb_bus_init(%struct.usb_bus* %self)
  %self49 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self49, i32 0, i32 0
  store %struct.device* %dev, %struct.device** %controller, align 8, !tbaa !306
  %self50 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 0
  %bus_name51 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self50, i32 0, i32 2
  store i8* %bus_name, i8** %bus_name51, align 8, !tbaa !358
  %dma_mask = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 12
  %8 = load i64*, i64** %dma_mask, align 8, !tbaa !79
  %cmp52 = icmp ne i64* %8, null
  %conv53 = zext i1 %cmp52 to i32
  %conv54 = trunc i32 %conv53 to i8
  %self55 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 0
  %uses_dma = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self55, i32 0, i32 3
  store i8 %conv54, i8* %uses_dma, align 8, !tbaa !359
  %rh_timer = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 5
  call void @init_timer_key(%struct.timer_list* %rh_timer, i32 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33.97, i32 0, i32 0), %struct.lock_class_key* @usb_create_shared_hcd.__key.32)
  %rh_timer59 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 5
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %rh_timer59, i32 0, i32 3
  store void (i64)* @rh_timer_func, void (i64)** %function, align 8, !tbaa !360
  %9 = ptrtoint %struct.usb_hcd.588* %1 to i64
  %rh_timer60 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 5
  %data = getelementptr inbounds %struct.timer_list, %struct.timer_list* %rh_timer60, i32 0, i32 4
  store i64 %9, i64* %data, align 8, !tbaa !361
  %wakeup_work = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 7
  call void @__init_work(%struct.work_struct* %wakeup_work, i32 0)
  %wakeup_work63 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 7
  %data64 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %wakeup_work63, i32 0, i32 0
  %counter = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !272
  %10 = bitcast %struct.pgprot* %data64 to i8*
  %11 = bitcast %struct.pgprot* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 8, i32 8, i1 false), !tbaa.struct !273
  %wakeup_work65 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 7
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %wakeup_work65, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.35.98, i32 0, i32 0), %struct.lock_class_key* @usb_create_shared_hcd.__key.34, i32 0)
  %wakeup_work66 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 7
  %entry67 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %wakeup_work66, i32 0, i32 1
  call void @INIT_LIST_HEAD.70(%struct.list_head* %entry67)
  %wakeup_work69 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 7
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %wakeup_work69, i32 0, i32 2
  store void (%struct.work_struct*)* @hcd_resume_work, void (%struct.work_struct*)** %func, align 8, !tbaa !274
  %driver76 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 8
  store %struct.hc_driver.589* %driver, %struct.hc_driver.589** %driver76, align 8, !tbaa !71
  %flags = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %driver, i32 0, i32 4
  %12 = load i32, i32* %flags, align 8, !tbaa !159
  %and77 = and i32 %12, 112
  %speed = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 3
  store i32 %and77, i32* %speed, align 8, !tbaa !311
  %product_desc = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %driver, i32 0, i32 1
  %13 = load i8*, i8** %product_desc, align 8, !tbaa !362
  %tobool78 = icmp ne i8* %13, null
  br i1 %tobool78, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end48
  %product_desc79 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %driver, i32 0, i32 1
  %14 = load i8*, i8** %product_desc79, align 8, !tbaa !362
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.end48
  %cond = phi i8* [ %14, %cond.true ], [ getelementptr inbounds ([20 x i8], [20 x i8]* @.str.36.99, i32 0, i32 0), %if.end48 ]
  %product_desc80 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 2
  store i8* %cond, i8** %product_desc80, align 8, !tbaa !363
  br label %cleanup

cleanup:                                          ; preds = %cond.end, %if.then30, %if.then15, %if.then5, %do.body1
  %retval.0 = phi %struct.usb_hcd.588* [ %1, %cond.end ], [ null, %if.then5 ], [ null, %do.body1 ], [ null, %if.then30 ], [ null, %if.then15 ]
  ret %struct.usb_hcd.588* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.93(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_init.96(%struct.arch_spinlock* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  call void @atomic_set.102(%union.anon.5* %refcount, i32 1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usb_bus_init(%struct.usb_bus* %bus) #0 {
entry:
  %devmap = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 9
  %0 = bitcast %struct.usb_devmap* %devmap to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 16, i32 8, i1 false)
  %devnum_next = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 8
  store i32 1, i32* %devnum_next, align 8, !tbaa !265
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 10
  store %struct.usb_device* null, %struct.usb_device** %root_hub, align 8, !tbaa !228
  %busnum = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 1
  store i32 -1, i32* %busnum, align 8, !tbaa !35
  %bandwidth_allocated = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 13
  store i32 0, i32* %bandwidth_allocated, align 8, !tbaa !364
  %bandwidth_int_reqs = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 14
  store i32 0, i32* %bandwidth_int_reqs, align 4, !tbaa !365
  %bandwidth_isoc_reqs = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 15
  store i32 0, i32* %bandwidth_isoc_reqs, align 8, !tbaa !366
  %bus_list = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 12
  call void @INIT_LIST_HEAD.70(%struct.list_head* %bus_list)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rh_timer_func(i64 %_hcd) #0 {
entry:
  %0 = inttoptr i64 %_hcd to %struct.usb_hcd.588*
  call void @usb_hcd_poll_rh_status(%struct.usb_hcd.588* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @hcd_resume_work(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -304
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd.588*
  %self = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 10
  %2 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !151
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock.100(%struct.device* %dev)
  %call = call i32 @usb_remote_wakeup(%struct.usb_device* %2)
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock.101(%struct.device* %dev1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock.100(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock.101(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set.102(%union.anon.5* %v, i32 %i) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !94
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_bus_start_enum(%struct.usb_bus* %bus, i32 %port_num) #0 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd.588*
  %tobool = icmp ne i32 %port_num, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 8
  %2 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %start_port_reset = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %2, i32 0, i32 22
  %3 = load i32 (%struct.usb_hcd.588*, i32)*, i32 (%struct.usb_hcd.588*, i32)** %start_port_reset, align 8, !tbaa !367
  %tobool1 = icmp ne i32 (%struct.usb_hcd.588*, i32)* %3, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %driver2 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 8
  %4 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver2, align 8, !tbaa !71
  %start_port_reset3 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %4, i32 0, i32 22
  %5 = load i32 (%struct.usb_hcd.588*, i32)*, i32 (%struct.usb_hcd.588*, i32)** %start_port_reset3, align 8, !tbaa !367
  %call = call i32 %5(%struct.usb_hcd.588* %1, i32 %port_num)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %status.0 = phi i32 [ %call, %if.then ], [ -95, %land.lhs.true ], [ -95, %entry ]
  %cmp = icmp eq i32 %status.0, 0
  br i1 %cmp, label %if.then4, label %if.end7

if.then4:                                         ; preds = %if.end
  %rh_timer = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %1, i32 0, i32 5
  %6 = load volatile i64, i64* @jiffies, align 8, !tbaa !49
  %call5 = call i64 @msecs_to_jiffies(i32 10)
  %add = add i64 %6, %call5
  %call6 = call i32 @mod_timer(%struct.timer_list* %rh_timer, i64 %add)
  br label %if.end7

if.end7:                                          ; preds = %if.then4, %if.end
  ret i32 %status.0
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_resume_root_hub(%struct.usb_hcd.588* %hcd) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %call = call %struct.raw_spinlock* @spinlock_check.65(%struct.spinlock* @hcd_root_hub_lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %rh_registered = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %bf.load = load i8, i8* %rh_registered, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %flags5 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags5, i32 4, i64* %flags5) #8, !srcloc !310
  %4 = load %struct.workqueue_struct*, %struct.workqueue_struct** @pm_wq, align 8, !tbaa !48
  %wakeup_work = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 7
  call void @queue_work.103(%struct.workqueue_struct* %4, %struct.work_struct* %wakeup_work)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @spin_unlock_irqrestore.66(%struct.spinlock* @hcd_root_hub_lock, i64 %call2)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_work.103(%struct.workqueue_struct* %wq, %struct.work_struct* %work) #1 {
entry:
  %call = call zeroext i1 @queue_work_on(i32 4096, %struct.workqueue_struct* %wq, %struct.work_struct* %work)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_free_streams(%struct.usb_interface* %interface, %struct.usb_host_endpoint** %eps, i32 %num_eps, i32 %mem_flags) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev.104(%struct.usb_interface* %interface)
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call1 = call %struct.usb_hcd.588* @bus_to_hcd.55(%struct.usb_bus* %0)
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 4
  %1 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp ne i32 %1, 5
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %cmp2 = icmp ult i32 %i.0, %num_eps
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %eps, i64 %idxprom
  %2 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8, !tbaa !48
  %tobool = icmp ne %struct.usb_host_endpoint* %2, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup.cont

lor.lhs.false:                                    ; preds = %for.body
  %idxprom3 = sext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %eps, i64 %idxprom3
  %3 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx4, align 8, !tbaa !48
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %3, i32 0, i32 0
  %call5 = call i32 @usb_endpoint_xfer_bulk(%struct.usb_endpoint_descriptor* %desc)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %for.inc, label %cleanup.cont

for.inc:                                          ; preds = %lor.lhs.false
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call1, i32 0, i32 8
  %4 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %free_streams = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %4, i32 0, i32 29
  %5 = load i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32)** %free_streams, align 8, !tbaa !368
  %call9 = call i32 %5(%struct.usb_hcd.588* %call1, %struct.usb_device* %call, %struct.usb_host_endpoint** %eps, i32 %num_eps, i32 %mem_flags)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %lor.lhs.false, %for.body, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_device* @interface_to_usbdev.104(%struct.usb_interface* %intf) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %parent, align 8, !tbaa !282
  %1 = bitcast %struct.device* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -136
  %2 = bitcast i8* %add.ptr to %struct.usb_device*
  ret %struct.usb_device* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_bulk(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 2
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define i32 @usb_alloc_streams(%struct.usb_interface* %interface, %struct.usb_host_endpoint** %eps, i32 %num_eps, i32 %num_streams, i32 %mem_flags) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev.104(%struct.usb_interface* %interface)
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call1 = call %struct.usb_hcd.588* @bus_to_hcd.55(%struct.usb_bus* %0)
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call1, i32 0, i32 8
  %1 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %alloc_streams = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %1, i32 0, i32 28
  %2 = load i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32, i32)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32, i32)** %alloc_streams, align 8, !tbaa !369
  %tobool = icmp ne i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32, i32)* %2, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %driver2 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call1, i32 0, i32 8
  %3 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver2, align 8, !tbaa !71
  %free_streams = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %3, i32 0, i32 29
  %4 = load i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32)** %free_streams, align 8, !tbaa !368
  %tobool3 = icmp ne i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32)* %4, null
  br i1 %tobool3, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 4
  %5 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp ne i32 %5, 5
  br i1 %cmp, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %i.0 = phi i32 [ 0, %if.end5 ], [ %inc, %for.inc ]
  %cmp6 = icmp ult i32 %i.0, %num_eps
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %eps, i64 %idxprom
  %6 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8, !tbaa !48
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %6, i32 0, i32 0
  %call7 = call i32 @usb_endpoint_xfer_bulk(%struct.usb_endpoint_descriptor* %desc)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %for.inc, label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %driver11 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call1, i32 0, i32 8
  %7 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver11, align 8, !tbaa !71
  %alloc_streams12 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %7, i32 0, i32 28
  %8 = load i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32, i32)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint**, i32, i32, i32)** %alloc_streams12, align 8, !tbaa !369
  %call13 = call i32 %8(%struct.usb_hcd.588* %call1, %struct.usb_device* %call, %struct.usb_host_endpoint** %eps, i32 %num_eps, i32 %num_streams, i32 %mem_flags)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %for.body, %if.end, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ %call13, %for.end ], [ -22, %lor.lhs.false ], [ -22, %entry ], [ -22, %if.end ], [ -22, %for.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_map_urb_for_dma(%struct.usb_hcd.588* %hcd, %struct.urb* %urb, i32 %mem_flags) #0 {
entry:
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !218
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %0, i32 0, i32 0
  %call = call i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %desc)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end27

if.then:                                          ; preds = %entry
  %self = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %uses_pio_for_control = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 4
  %1 = load i8, i8* %uses_pio_for_control, align 1, !tbaa !370
  %tobool1 = icmp ne i8 %1, 0
  br i1 %tobool1, label %cleanup147, label %if.end

if.end:                                           ; preds = %if.then
  %self3 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %uses_dma = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self3, i32 0, i32 3
  %2 = load i8, i8* %uses_dma, align 8, !tbaa !359
  %tobool4 = icmp ne i8 %2, 0
  br i1 %tobool4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end
  %self6 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self6, i32 0, i32 0
  %3 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !306
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 21
  %4 = load i8*, i8** %setup_packet, align 8, !tbaa !371
  %call7 = call i64 @dma_map_single_attrs(%struct.device* %3, i8* %4, i64 8, i32 1, %struct.sigset_t* null)
  %setup_dma = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 22
  store i64 %call7, i64* %setup_dma, align 8, !tbaa !332
  %self8 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller9 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self8, i32 0, i32 0
  %5 = load %struct.device*, %struct.device** %controller9, align 8, !tbaa !306
  %setup_dma10 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 22
  %6 = load i64, i64* %setup_dma10, align 8, !tbaa !332
  %call11 = call i32 @dma_mapping_error(%struct.device* %5, i64 %6)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %cleanup147, label %if.end14

if.end14:                                         ; preds = %if.then5
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %7 = load i32, i32* %transfer_flags, align 4, !tbaa !323
  %or = or i32 %7, 1048576
  store i32 %or, i32* %transfer_flags, align 4, !tbaa !323
  br label %if.end27

if.else:                                          ; preds = %if.end
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %8 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %flags = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %8, i32 0, i32 4
  %9 = load i32, i32* %flags, align 8, !tbaa !159
  %and = and i32 %9, 2
  %tobool15 = icmp ne i32 %and, 0
  br i1 %tobool15, label %if.then16, label %if.end27

if.then16:                                        ; preds = %if.else
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %10 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !210
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %10, i32 0, i32 9
  %11 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %setup_dma17 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 22
  %setup_packet18 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 21
  %call19 = call i32 @hcd_alloc_coherent(%struct.usb_bus* %11, i32 %mem_flags, i64* %setup_dma17, i8** %setup_packet18, i64 8, i32 1)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %cleanup147, label %if.end22

if.end22:                                         ; preds = %if.then16
  %transfer_flags23 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %12 = load i32, i32* %transfer_flags23, align 4, !tbaa !323
  %or24 = or i32 %12, 2097152
  store i32 %or24, i32* %transfer_flags23, align 4, !tbaa !323
  br label %if.end27

if.end27:                                         ; preds = %if.end22, %if.else, %if.end14, %entry
  %ret.2 = phi i32 [ 0, %entry ], [ 0, %if.end14 ], [ %call19, %if.end22 ], [ 0, %if.else ]
  %call28 = call i32 @usb_urb_dir_in(%struct.urb* %urb)
  %tobool29 = icmp ne i32 %call28, 0
  %cond = select i1 %tobool29, i32 2, i32 1
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %13 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !294
  %cmp = icmp ne i32 %13, 0
  br i1 %cmp, label %land.lhs.true, label %cleanup147

land.lhs.true:                                    ; preds = %if.end27
  %transfer_flags30 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %14 = load i32, i32* %transfer_flags30, align 4, !tbaa !323
  %and31 = and i32 %14, 4
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %cleanup147, label %if.then33

if.then33:                                        ; preds = %land.lhs.true
  %self34 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %uses_dma35 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self34, i32 0, i32 3
  %15 = load i8, i8* %uses_dma35, align 8, !tbaa !359
  %tobool36 = icmp ne i8 %15, 0
  br i1 %tobool36, label %if.then37, label %if.else118

if.then37:                                        ; preds = %if.then33
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %16 = load i32, i32* %num_sgs, align 4, !tbaa !330
  %tobool38 = icmp ne i32 %16, 0
  br i1 %tobool38, label %if.then39, label %if.else76

if.then39:                                        ; preds = %if.then37
  %ep40 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %17 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep40, align 8, !tbaa !218
  %desc41 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %17, i32 0, i32 0
  %call42 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %desc41)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.then44, label %if.end57

if.then44:                                        ; preds = %if.then39
  %tobool45 = icmp ne i32 1, 0
  %lnot = xor i1 %tobool45, true
  %lnot46 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot46 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool47 = icmp ne i64 %expval, 0
  br i1 %tobool47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %if.then44
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i32 1451)
  br label %if.end49

if.end49:                                         ; preds = %if.then48, %if.then44
  br label %LeafBlock

if.end57:                                         ; preds = %if.then39
  %self58 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller59 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self58, i32 0, i32 0
  %18 = load %struct.device*, %struct.device** %controller59, align 8, !tbaa !306
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 16
  %19 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8, !tbaa !329
  %num_sgs60 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %20 = load i32, i32* %num_sgs60, align 4, !tbaa !330
  %call61 = call i32 @dma_map_sg_attrs(%struct.device* %18, %struct.scatterlist* %19, i32 %20, i32 %cond, %struct.sigset_t* null)
  %cmp62 = icmp sle i32 %call61, 0
  br i1 %cmp62, label %if.end68, label %if.else65

if.else65:                                        ; preds = %if.end57
  %transfer_flags66 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %21 = load i32, i32* %transfer_flags66, align 4, !tbaa !323
  %or67 = or i32 %21, 262144
  store i32 %or67, i32* %transfer_flags66, align 4, !tbaa !323
  br label %if.end68

if.end68:                                         ; preds = %if.else65, %if.end57
  %ret.3 = phi i32 [ %ret.2, %if.else65 ], [ -11, %if.end57 ]
  %num_mapped_sgs = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 17
  store i32 %call61, i32* %num_mapped_sgs, align 8, !tbaa !372
  %num_sgs69 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %22 = load i32, i32* %num_sgs69, align 4, !tbaa !330
  %cmp70 = icmp ne i32 %call61, %22
  br i1 %cmp70, label %if.then72, label %LeafBlock

if.then72:                                        ; preds = %if.end68
  %transfer_flags73 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %23 = load i32, i32* %transfer_flags73, align 4, !tbaa !323
  %or74 = or i32 %23, 4194304
  store i32 %or74, i32* %transfer_flags73, align 4, !tbaa !323
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.then72, %if.end68, %if.end49
  %ret.4 = phi i32 [ %ret.2, %if.end49 ], [ %ret.3, %if.then72 ], [ %ret.3, %if.end68 ]
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.end49 ], [ 0, %if.then72 ], [ 0, %if.end68 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end138, label %cleanup147

if.else76:                                        ; preds = %if.then37
  %sg77 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 16
  %24 = load %struct.scatterlist*, %struct.scatterlist** %sg77, align 8, !tbaa !329
  %tobool78 = icmp ne %struct.scatterlist* %24, null
  br i1 %tobool78, label %if.then79, label %if.else99

if.then79:                                        ; preds = %if.else76
  %sg81 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 16
  %25 = load %struct.scatterlist*, %struct.scatterlist** %sg81, align 8, !tbaa !329
  %self82 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller83 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self82, i32 0, i32 0
  %26 = load %struct.device*, %struct.device** %controller83, align 8, !tbaa !306
  %call84 = call %struct.page* @sg_page(%struct.scatterlist* %25)
  %offset = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %25, i32 0, i32 2
  %27 = load i32, i32* %offset, align 8, !tbaa !373
  %conv85 = zext i32 %27 to i64
  %transfer_buffer_length86 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %28 = load i32, i32* %transfer_buffer_length86, align 8, !tbaa !294
  %conv87 = zext i32 %28 to i64
  %call88 = call i64 @dma_map_page(%struct.device* %26, %struct.page* %call84, i64 %conv85, i64 %conv87, i32 %cond)
  %transfer_dma = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 15
  store i64 %call88, i64* %transfer_dma, align 8, !tbaa !331
  %self89 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller90 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self89, i32 0, i32 0
  %29 = load %struct.device*, %struct.device** %controller90, align 8, !tbaa !306
  %transfer_dma91 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 15
  %30 = load i64, i64* %transfer_dma91, align 8, !tbaa !331
  %call92 = call i32 @dma_mapping_error(%struct.device* %29, i64 %30)
  %tobool93 = icmp ne i32 %call92, 0
  br i1 %tobool93, label %if.end138, label %if.else95

if.else95:                                        ; preds = %if.then79
  %transfer_flags96 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %31 = load i32, i32* %transfer_flags96, align 4, !tbaa !323
  %or97 = or i32 %31, 131072
  store i32 %or97, i32* %transfer_flags96, align 4, !tbaa !323
  br label %if.end138

if.else99:                                        ; preds = %if.else76
  %self100 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller101 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self100, i32 0, i32 0
  %32 = load %struct.device*, %struct.device** %controller101, align 8, !tbaa !306
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %33 = load i8*, i8** %transfer_buffer, align 8, !tbaa !293
  %transfer_buffer_length102 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %34 = load i32, i32* %transfer_buffer_length102, align 8, !tbaa !294
  %conv103 = zext i32 %34 to i64
  %call104 = call i64 @dma_map_single_attrs(%struct.device* %32, i8* %33, i64 %conv103, i32 %cond, %struct.sigset_t* null)
  %transfer_dma105 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 15
  store i64 %call104, i64* %transfer_dma105, align 8, !tbaa !331
  %self106 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller107 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self106, i32 0, i32 0
  %35 = load %struct.device*, %struct.device** %controller107, align 8, !tbaa !306
  %transfer_dma108 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 15
  %36 = load i64, i64* %transfer_dma108, align 8, !tbaa !331
  %call109 = call i32 @dma_mapping_error(%struct.device* %35, i64 %36)
  %tobool110 = icmp ne i32 %call109, 0
  br i1 %tobool110, label %if.end138, label %if.else112

if.else112:                                       ; preds = %if.else99
  %transfer_flags113 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %37 = load i32, i32* %transfer_flags113, align 4, !tbaa !323
  %or114 = or i32 %37, 65536
  store i32 %or114, i32* %transfer_flags113, align 4, !tbaa !323
  br label %if.end138

if.else118:                                       ; preds = %if.then33
  %driver119 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %38 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver119, align 8, !tbaa !71
  %flags120 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %38, i32 0, i32 4
  %39 = load i32, i32* %flags120, align 8, !tbaa !159
  %and121 = and i32 %39, 2
  %tobool122 = icmp ne i32 %and121, 0
  br i1 %tobool122, label %if.then123, label %if.end138

if.then123:                                       ; preds = %if.else118
  %dev124 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %40 = load %struct.usb_device*, %struct.usb_device** %dev124, align 8, !tbaa !210
  %bus125 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %40, i32 0, i32 9
  %41 = load %struct.usb_bus*, %struct.usb_bus** %bus125, align 8, !tbaa !2
  %transfer_dma126 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 15
  %transfer_buffer127 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %transfer_buffer_length128 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %42 = load i32, i32* %transfer_buffer_length128, align 8, !tbaa !294
  %conv129 = zext i32 %42 to i64
  %call130 = call i32 @hcd_alloc_coherent(%struct.usb_bus* %41, i32 %mem_flags, i64* %transfer_dma126, i8** %transfer_buffer127, i64 %conv129, i32 %cond)
  %cmp131 = icmp eq i32 %call130, 0
  br i1 %cmp131, label %if.then133, label %if.end138

if.then133:                                       ; preds = %if.then123
  %transfer_flags134 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %43 = load i32, i32* %transfer_flags134, align 4, !tbaa !323
  %or135 = or i32 %43, 524288
  store i32 %or135, i32* %transfer_flags134, align 4, !tbaa !323
  br label %if.end138

if.end138:                                        ; preds = %if.then133, %if.then123, %if.else118, %if.else112, %if.else99, %if.else95, %if.then79, %LeafBlock
  %ret.10 = phi i32 [ %ret.4, %LeafBlock ], [ %ret.2, %if.else95 ], [ -11, %if.then79 ], [ %ret.2, %if.else112 ], [ -11, %if.else99 ], [ %ret.2, %if.else118 ], [ %call130, %if.then133 ], [ %call130, %if.then123 ]
  %tobool139 = icmp ne i32 %ret.10, 0
  br i1 %tobool139, label %land.lhs.true140, label %cleanup147

land.lhs.true140:                                 ; preds = %if.end138
  %transfer_flags141 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %44 = load i32, i32* %transfer_flags141, align 4, !tbaa !323
  %and142 = and i32 %44, 3145728
  %tobool143 = icmp ne i32 %and142, 0
  br i1 %tobool143, label %if.then144, label %cleanup147

if.then144:                                       ; preds = %land.lhs.true140
  call void @usb_hcd_unmap_urb_for_dma(%struct.usb_hcd.588* %hcd, %struct.urb* %urb)
  br label %cleanup147

cleanup147:                                       ; preds = %if.then144, %land.lhs.true140, %if.end138, %LeafBlock, %land.lhs.true, %if.end27, %if.then16, %if.then5, %if.then
  %retval.1 = phi i32 [ 0, %if.then ], [ -11, %if.then5 ], [ %call19, %if.then16 ], [ %ret.2, %land.lhs.true ], [ %ret.2, %if.end27 ], [ %ret.10, %if.then144 ], [ %ret.10, %land.lhs.true140 ], [ %ret.10, %if.end138 ], [ -22, %LeafBlock ]
  ret i32 %retval.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @dma_map_single_attrs(%struct.device* %dev, i8* %ptr, i64 %size, i32 %dir, %struct.sigset_t* %attrs) #1 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  %conv = trunc i64 %size to i32
  call void @kmemcheck_mark_initialized()
  %call1 = call i32 @valid_dma_direction(i32 %dir)
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %do.body6, label %do.end11

do.body6:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.51.68, i32 0, i32 0), i32 19, i64 12) #8, !srcloc !375
  br label %do.body7

do.body7:                                         ; preds = %do.body7, %do.body6
  br label %do.body7

do.end11:                                         ; preds = %entry
  %map_page = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 4
  %0 = load i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.sigset_t*)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.sigset_t*)** %map_page, align 8, !tbaa !376
  %1 = ptrtoint i8* %ptr to i64
  %call12 = call i64 @__phys_addr(i64 %1)
  %shr = lshr i64 %call12, 12
  %add.ptr = getelementptr inbounds %struct.page, %struct.page* inttoptr (i64 -24189255811072 to %struct.page*), i64 %shr
  %2 = ptrtoint i8* %ptr to i64
  %and = and i64 %2, 4095
  %call13 = call i64 %0(%struct.device* %dev, %struct.page* %add.ptr, i64 %and, i64 %size, i32 %dir, %struct.sigset_t* %attrs)
  %3 = ptrtoint i8* %ptr to i64
  %call14 = call i64 @__phys_addr(i64 %3)
  %shr15 = lshr i64 %call14, 12
  %add.ptr16 = getelementptr inbounds %struct.page, %struct.page* inttoptr (i64 -24189255811072 to %struct.page*), i64 %shr15
  %4 = ptrtoint i8* %ptr to i64
  %and17 = and i64 %4, 4095
  call void @debug_dma_map_page(%struct.device* %dev, %struct.page* %add.ptr16, i64 %and17, i64 %size, i32 %dir, i64 %call13, i1 zeroext true)
  ret i64 %call13
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @dma_mapping_error(%struct.device* %dev, i64 %dma_addr) #1 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  call void @debug_dma_mapping_error(%struct.device* %dev, i64 %dma_addr)
  %mapping_error = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 12
  %0 = load i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)** %mapping_error, align 8, !tbaa !377
  %tobool = icmp ne i32 (%struct.device*, i64)* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mapping_error1 = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 12
  %1 = load i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)** %mapping_error1, align 8, !tbaa !377
  %call2 = call i32 %1(%struct.device* %dev, i64 %dma_addr)
  br label %cleanup

if.end:                                           ; preds = %entry
  %cmp = icmp eq i64 %dma_addr, 0
  %conv = zext i1 %cmp to i32
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call2, %if.then ], [ %conv, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @hcd_alloc_coherent(%struct.usb_bus* %bus, i32 %mem_flags, i64* %dma_handle, i8** %vaddr_handle, i64 %size, i32 %dir) #0 {
entry:
  %0 = load i8*, i8** %vaddr_handle, align 8, !tbaa !48
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.then, label %if.end39

if.then:                                          ; preds = %entry
  %tobool = icmp ne i32 1, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then3, label %if.end30

if.then3:                                         ; preds = %if.then
  %1 = load i8, i8* @hcd_alloc_coherent.__warned, align 1, !tbaa !43, !range !44
  %tobool4 = trunc i8 %1 to i1
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %tobool11 = icmp ne i32 %lnot.ext10, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %if.then19, label %if.end

if.then19:                                        ; preds = %if.then3
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i32 1289)
  br label %if.end

if.end:                                           ; preds = %if.then19, %if.then3
  %tobool20 = icmp ne i32 %lnot.ext10, 0
  %lnot21 = xor i1 %tobool20, true
  %lnot23 = xor i1 %lnot21, true
  %lnot.ext24 = zext i1 %lnot23 to i32
  %conv25 = sext i32 %lnot.ext24 to i64
  %expval26 = call i64 @llvm.expect.i64(i64 %conv25, i64 0)
  %tobool27 = icmp ne i64 %expval26, 0
  br i1 %tobool27, label %if.then28, label %if.end30

if.then28:                                        ; preds = %if.end
  store i8 1, i8* @hcd_alloc_coherent.__warned, align 1, !tbaa !43
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %if.end, %if.then
  br label %cleanup

if.end39:                                         ; preds = %entry
  %add = add i64 %size, 8
  %call = call i8* @hcd_buffer_alloc(%struct.usb_bus* %bus, i64 %add, i32 %mem_flags, i64* %dma_handle)
  %tobool40 = icmp ne i8* %call, null
  br i1 %tobool40, label %if.end42, label %cleanup

if.end42:                                         ; preds = %if.end39
  %add.ptr = getelementptr inbounds i8, i8* %call, i64 %size
  %2 = bitcast i8* %add.ptr to i64*
  %3 = bitcast i64* %2 to i8*
  %4 = load i8*, i8** %vaddr_handle, align 8, !tbaa !48
  %5 = ptrtoint i8* %4 to i64
  call void @put_unaligned_le64(i64 %5, i8* %3)
  %cmp43 = icmp eq i32 %dir, 1
  br i1 %cmp43, label %if.then45, label %if.end47

if.then45:                                        ; preds = %if.end42
  %6 = load i8*, i8** %vaddr_handle, align 8, !tbaa !48
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %call, i8* %6, i64 %size, i32 1, i1 false)
  br label %if.end47

if.end47:                                         ; preds = %if.then45, %if.end42
  store i8* %call, i8** %vaddr_handle, align 8, !tbaa !48
  br label %cleanup

cleanup:                                          ; preds = %if.end47, %if.end39, %if.end30
  %retval.0 = phi i32 [ -14, %if.end30 ], [ 0, %if.end47 ], [ -12, %if.end39 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 1
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @dma_map_sg_attrs(%struct.device* %dev, %struct.scatterlist* %sg, i32 %nents, i32 %dir, %struct.sigset_t* %attrs) #1 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %s.0 = phi %struct.scatterlist* [ %sg, %entry ], [ %call2, %for.body ]
  %cmp = icmp slt i32 %i.0, %nents
  br i1 %cmp, label %for.body, label %do.body

for.body:                                         ; preds = %for.cond
  call void @sg_virt(%struct.scatterlist* %s.0)
  %length = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %s.0, i32 0, i32 3
  %0 = load i32, i32* %length, align 4, !tbaa !378
  call void @kmemcheck_mark_initialized()
  %inc = add nsw i32 %i.0, 1
  %call2 = call %struct.scatterlist* @sg_next(%struct.scatterlist* %s.0)
  br label %for.cond

do.body:                                          ; preds = %for.cond
  %call3 = call i32 @valid_dma_direction(i32 %dir)
  %tobool = icmp ne i32 %call3, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %do.body7, label %do.end12

do.body7:                                         ; preds = %do.body
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.51.68, i32 0, i32 0), i32 52, i64 12) #8, !srcloc !379
  br label %do.body8

do.body8:                                         ; preds = %do.body8, %do.body7
  br label %do.body8

do.end12:                                         ; preds = %do.body
  %map_sg = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 6
  %1 = load i32 (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)** %map_sg, align 8, !tbaa !380
  %call13 = call i32 %1(%struct.device* %dev, %struct.scatterlist* %sg, i32 %nents, i32 %dir, %struct.sigset_t* %attrs)
  call void @debug_dma_map_sg(%struct.device* %dev, %struct.scatterlist* %sg, i32 %nents, i32 %call13, i32 %dir)
  ret i32 %call13
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.page* @sg_page(%struct.scatterlist* %sg) #1 {
entry:
  %sg_magic = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 0
  %0 = load i64, i64* %sg_magic, align 8, !tbaa !381
  %cmp = icmp ne i64 %0, 2271560481
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.body8

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.56.674, i32 0, i32 0), i32 98, i64 12) #8, !srcloc !382
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.body8:                                         ; preds = %entry
  %page_link = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %1 = load i64, i64* %page_link, align 8, !tbaa !383
  %and = and i64 %1, 1
  %tobool9 = icmp ne i64 %and, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %do.body18, label %do.end26

do.body18:                                        ; preds = %do.body8
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.56.674, i32 0, i32 0), i32 99, i64 12) #8, !srcloc !384
  br label %do.body19

do.body19:                                        ; preds = %do.body19, %do.body18
  br label %do.body19

do.end26:                                         ; preds = %do.body8
  %page_link27 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %2 = load i64, i64* %page_link27, align 8, !tbaa !383
  %and28 = and i64 %2, -4
  %3 = inttoptr i64 %and28 to %struct.page*
  ret %struct.page* %3
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @dma_map_page(%struct.device* %dev, %struct.page* %page, i64 %offset, i64 %size, i32 %dir) #1 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev)
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %page to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %0 = inttoptr i64 %add.i to i8*
  %add.ptr = getelementptr i8, i8* %0, i64 %offset
  %conv = trunc i64 %size to i32
  call void @kmemcheck_mark_initialized()
  %call2 = call i32 @valid_dma_direction(i32 %dir)
  %tobool = icmp ne i32 %call2, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv5, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %do.body7, label %do.end12

do.body7:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.51.68, i32 0, i32 0), i32 79, i64 12) #8, !srcloc !385
  br label %do.body8

do.body8:                                         ; preds = %do.body8, %do.body7
  br label %do.body8

do.end12:                                         ; preds = %entry
  %map_page = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 4
  %1 = load i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.sigset_t*)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.sigset_t*)** %map_page, align 8, !tbaa !376
  %call13 = call i64 %1(%struct.device* %dev, %struct.page* %page, i64 %offset, i64 %size, i32 %dir, %struct.sigset_t* null)
  call void @debug_dma_map_page(%struct.device* %dev, %struct.page* %page, i64 %offset, i64 %size, i32 %dir, i64 %call13, i1 zeroext false)
  ret i64 %call13
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kmemcheck_mark_initialized() #1 {
entry:
  ret void
}

declare void @debug_dma_map_page(%struct.device*, %struct.page*, i64, i64, i32, i64, i1 zeroext) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_virt(%struct.scatterlist* %sg) #1 {
entry:
  %call = call %struct.page* @sg_page(%struct.scatterlist* %sg)
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %call to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %0 = inttoptr i64 %add.i to i8*
  %offset = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 2
  %1 = load i32, i32* %offset, align 8, !tbaa !373
  %idx.ext = zext i32 %1 to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  ret void
}

declare %struct.scatterlist* @sg_next(%struct.scatterlist*) #2

declare void @debug_dma_map_sg(%struct.device*, %struct.scatterlist*, i32, i32, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @put_unaligned_le64(i64 %val, i8* %p) #1 {
entry:
  %0 = bitcast i8* %p to i64*
  store i64 %val, i64* %0, align 8, !tbaa !339
  ret void
}

declare void @debug_dma_mapping_error(%struct.device*, i64) #2

declare i64 @__phys_addr(i64) #2

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_check_unlink_urb(%struct.usb_hcd.588* %hcd, %struct.urb* %urb, i32 %status) #0 {
entry:
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !218
  %urb_list = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %0, i32 0, i32 3
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %.sink = phi %struct.list_head* [ %1, %for.inc ], [ %urb_list, %entry ]
  %next5 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next5, align 8, !tbaa !95
  %ep1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %2 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep1, align 8, !tbaa !218
  %urb_list2 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %2, i32 0, i32 3
  %cmp = icmp eq %struct.list_head* %1, %urb_list2
  %urb_list3 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 5
  %cmp4 = icmp eq %struct.list_head* %1, %urb_list3
  %or.cond = or i1 %cmp, %cmp4
  br i1 %or.cond, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.cond
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %urb_list6 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 5
  %cmp7 = icmp ne %struct.list_head* %1, %urb_list6
  br i1 %cmp7, label %cleanup, label %if.end9

if.end9:                                          ; preds = %for.end
  %unlinked = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 4
  %3 = load i32, i32* %unlinked, align 8, !tbaa !322
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %if.end11

if.end11:                                         ; preds = %if.end9
  %unlinked12 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 4
  store i32 %status, i32* %unlinked12, align 8, !tbaa !322
  br label %cleanup

cleanup:                                          ; preds = %if.end11, %if.end9, %for.end
  %retval.0 = phi i32 [ 0, %if.end11 ], [ -43, %for.end ], [ -16, %if.end9 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_link_urb_to_ep(%struct.usb_hcd.588* %hcd, %struct.urb* %urb) #0 {
entry:
  call void @spin_lock(%struct.spinlock* @hcd_urb_list_lock)
  %reject = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 3
  %call = call i32 @atomic_read.67(%union.anon.5* %reject)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %done, label %if.end

if.end:                                           ; preds = %entry
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !218
  %enabled = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %0, i32 0, i32 8
  %1 = load i32, i32* %enabled, align 4, !tbaa !386
  %tobool3 = icmp ne i32 %1, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv10 = sext i32 %lnot.ext9 to i64
  %expval11 = call i64 @llvm.expect.i64(i64 %conv10, i64 0)
  %tobool12 = icmp ne i64 %expval11, 0
  br i1 %tobool12, label %done, label %if.end14

if.end14:                                         ; preds = %if.end
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %2 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !210
  %can_submit = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 22
  %bf.load = load i16, i16* %can_submit, align 4
  %bf.clear = and i16 %bf.load, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool15 = icmp ne i32 %bf.cast, 0
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  %expval23 = call i64 @llvm.expect.i64(i64 %conv22, i64 0)
  %tobool24 = icmp ne i64 %expval23, 0
  br i1 %tobool24, label %done, label %if.end26

if.end26:                                         ; preds = %if.end14
  %flags = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  %3 = load i64, i64* %flags, align 8, !tbaa !314
  %and = and i64 %3, 32
  %tobool27 = icmp ne i64 %and, 0
  br i1 %tobool27, label %if.then28, label %done

if.then28:                                        ; preds = %if.end26
  %unlinked = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 4
  store i32 0, i32* %unlinked, align 8, !tbaa !322
  %urb_list = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 5
  %ep29 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %4 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep29, align 8, !tbaa !218
  %urb_list30 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %4, i32 0, i32 3
  call void @list_add_tail.106(%struct.list_head* %urb_list, %struct.list_head* %urb_list30)
  br label %done

done:                                             ; preds = %if.then28, %if.end26, %if.end14, %if.end, %entry
  %rc.0 = phi i32 [ 0, %if.then28 ], [ -1, %entry ], [ -2, %if.end ], [ -113, %if.end14 ], [ -108, %if.end26 ]
  call void @spin_unlock(%struct.spinlock* @hcd_urb_list_lock)
  ret i32 %rc.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.106(%struct.list_head* %new, %struct.list_head* %head) #1 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !96
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @usb_calc_bus_time(i32 %speed, i32 %is_input, i32 %isoc, i32 %bytecount) #0 {
entry:
  %Pivot4 = icmp slt i32 %speed, 2
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %speed, 3
  br i1 %Pivot, label %sw.bb13, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %speed, 3
  br i1 %SwitchLeaf2, label %sw.bb35, label %do.body

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %speed, 1
  br i1 %SwitchLeaf, label %sw.bb, label %do.body

sw.bb:                                            ; preds = %LeafBlock
  %tobool = icmp ne i32 %is_input, 0
  %mul = mul nsw i32 56, %bytecount
  %div = sdiv i32 %mul, 6
  %conv = sext i32 %div to i64
  %mul1 = mul nsw i64 10, %conv
  %add = add nsw i64 31, %mul1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %mul2 = mul nsw i64 67667, %add
  %div3 = sdiv i64 %mul2, 1000
  %add4 = add i64 65726, %div3
  br label %cleanup

if.else:                                          ; preds = %sw.bb
  %mul10 = mul nsw i64 66700, %add
  %div11 = sdiv i64 %mul10, 1000
  %add12 = add i64 65773, %div11
  br label %cleanup

sw.bb13:                                          ; preds = %NodeBlock
  %tobool14 = icmp ne i32 %isoc, 0
  %mul16 = mul nsw i32 56, %bytecount
  %div17 = sdiv i32 %mul16, 6
  %conv18 = sext i32 %div17 to i64
  %mul19 = mul nsw i64 10, %conv18
  %add20 = add nsw i64 31, %mul19
  %mul21 = mul nsw i64 8354, %add20
  %div22 = sdiv i64 %mul21, 1000
  br i1 %tobool14, label %if.then15, label %if.else26

if.then15:                                        ; preds = %sw.bb13
  %tobool23 = icmp ne i32 %is_input, 0
  %cond = select i1 %tobool23, i64 7268, i64 6265
  %add24 = add nsw i64 %cond, 1000
  %add25 = add i64 %add24, %div22
  br label %cleanup

if.else26:                                        ; preds = %sw.bb13
  %add34 = add i64 10107, %div22
  br label %cleanup

sw.bb35:                                          ; preds = %LeafBlock1
  %tobool36 = icmp ne i32 %isoc, 0
  %mul38 = mul nsw i32 56, %bytecount
  %div39 = sdiv i32 %mul38, 6
  %add40 = add nsw i32 3, %div39
  %conv41 = sext i32 %add40 to i64
  %mul42 = mul i64 2083, %conv41
  %.sink = select i1 %tobool36, i64 633232, i64 916520
  %add52 = add i64 %.sink, %mul42
  %div53 = udiv i64 %add52, 1000
  %add54 = add i64 %div53, 5
  br label %cleanup

do.body:                                          ; preds = %LeafBlock, %LeafBlock1
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_calc_bus_time.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool55 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool55, true
  %lnot56 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot56 to i32
  %conv57 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv57, i64 0)
  %tobool58 = icmp ne i64 %expval, 0
  br i1 %tobool58, label %if.then59, label %cleanup

if.then59:                                        ; preds = %do.body
  %0 = load i8*, i8** @usbcore_name, align 8, !tbaa !48
  %call = call i32 (%struct._ddebug*, i8*, ...) @__dynamic_pr_debug(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_calc_bus_time.descriptor to %struct._ddebug*), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.5.107, i32 0, i32 0), i8* %0)
  br label %cleanup

cleanup:                                          ; preds = %if.then59, %do.body, %sw.bb35, %if.else26, %if.then15, %if.else, %if.then
  %retval.0 = phi i64 [ %add4, %if.then ], [ %add12, %if.else ], [ %add25, %if.then15 ], [ %add34, %if.else26 ], [ %add54, %sw.bb35 ], [ -1, %if.then59 ], [ -1, %do.body ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_end_port_resume(%struct.usb_bus* %bus, i32 %portnum) #0 {
entry:
  %shl = shl i32 1, %portnum
  %resuming_ports = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 16
  %0 = load i32, i32* %resuming_ports, align 4, !tbaa !387
  %and = and i32 %0, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %neg = xor i32 %shl, -1
  %resuming_ports1 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 16
  %1 = load i32, i32* %resuming_ports1, align 4, !tbaa !387
  %and2 = and i32 %1, %neg
  store i32 %and2, i32* %resuming_ports1, align 4, !tbaa !387
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 10
  %2 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !228
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @pm_runtime_put_noidle(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put_noidle(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %usage_count = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 11
  call void @atomic_add_unless(%union.anon.5* %usage_count, i32 -1, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_add_unless(%union.anon.5* %v, i32 %a, i32 %u) #1 {
entry:
  %call = call i32 @__atomic_add_unless(%union.anon.5* %v, i32 %a, i32 %u)
  %cmp = icmp ne i32 %call, %u
  %conv = zext i1 %cmp to i32
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__atomic_add_unless(%union.anon.5* %v, i32 %a, i32 %u) #1 {
entry:
  %call = call i32 @atomic_read.67(%union.anon.5* %v)
  br label %for.cond

for.cond:                                         ; preds = %if.end13, %entry
  %c.0 = phi i32 [ %call, %entry ], [ %call2, %if.end13 ]
  %cmp = icmp eq i32 %c.0, %u
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %for.end, label %if.end

if.end:                                           ; preds = %for.cond
  %add = add nsw i32 %c.0, %a
  %call2 = call i32 @atomic_cmpxchg(%union.anon.5* %v, i32 %c.0, i32 %add)
  %cmp3 = icmp eq i32 %call2, %c.0
  %lnot5 = xor i1 %cmp3, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %expval10 = call i64 @llvm.expect.i64(i64 %conv9, i64 1)
  %tobool11 = icmp ne i64 %expval10, 0
  br i1 %tobool11, label %for.end, label %if.end13

if.end13:                                         ; preds = %if.end
  br label %for.cond

for.end:                                          ; preds = %if.end, %for.cond
  ret i32 %c.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_cmpxchg(%union.anon.5* %v, i32 %old, i32 %new) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; cmpxchgl $2,$1", "={ax},=*m,r,0,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %new, i32 %old, i32* %counter) #8, !srcloc !388
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_start_port_resume(%struct.usb_bus* %bus, i32 %portnum) #0 {
entry:
  %shl = shl i32 1, %portnum
  %resuming_ports = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 16
  %0 = load i32, i32* %resuming_ports, align 4, !tbaa !387
  %and = and i32 %0, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %resuming_ports1 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 16
  %1 = load i32, i32* %resuming_ports1, align 4, !tbaa !387
  %or = or i32 %1, %shl
  store i32 %or, i32* %resuming_ports1, align 4, !tbaa !387
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 10
  %2 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !228
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @pm_runtime_get_noresume.108(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_get_noresume.108(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %usage_count = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 11
  call void @atomic_inc.109(%union.anon.5* %usage_count)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.109(%union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #8, !srcloc !389
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_submit_urb(%struct.urb* %urb, i32 %mem_flags) #0 {
entry:
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !210
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.588* @bus_to_hcd.55(%struct.usb_bus* %1)
  %call1 = call %struct.urb* bitcast (%struct.urb.824* (%struct.urb.824*)* @usb_get_urb to %struct.urb* (%struct.urb*)*)(%struct.urb* %urb)
  %use_count = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 2
  call void @atomic_inc.109(%union.anon.5* %use_count)
  %dev2 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %2 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8, !tbaa !210
  %urbnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 30
  call void @atomic_inc.109(%union.anon.5* %urbnum)
  %self = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 0
  call void @usbmon_urb_submit(%struct.usb_bus* %self, %struct.urb* %urb)
  %dev3 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %3 = load %struct.usb_device*, %struct.usb_device** %dev3, align 8, !tbaa !210
  %call4 = call i32 @is_root_hub(%struct.usb_device* %3)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call5 = call i32 @rh_urb_enqueue(%struct.usb_hcd.588* %call, %struct.urb* %urb)
  br label %if.end21

if.else:                                          ; preds = %entry
  %call6 = call i32 @map_urb_for_dma(%struct.usb_hcd.588* %call, %struct.urb* %urb, i32 %mem_flags)
  %cmp = icmp eq i32 %call6, 0
  %lnot = xor i1 %cmp, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then9, label %if.end21

if.then9:                                         ; preds = %if.else
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %4 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %urb_enqueue = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %4, i32 0, i32 12
  %5 = load i32 (%struct.usb_hcd.588*, %struct.urb*, i32)*, i32 (%struct.usb_hcd.588*, %struct.urb*, i32)** %urb_enqueue, align 8, !tbaa !390
  %call10 = call i32 %5(%struct.usb_hcd.588* %call, %struct.urb* %urb, i32 %mem_flags)
  %tobool11 = icmp ne i32 %call10, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.then9
  call void @unmap_urb_for_dma(%struct.usb_hcd.588* %call, %struct.urb* %urb)
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %if.then9, %if.else, %if.then
  %status.1 = phi i32 [ %call5, %if.then ], [ %call6, %if.else ], [ %call10, %if.then19 ], [ %call10, %if.then9 ]
  %tobool22 = icmp ne i32 %status.1, 0
  %lnot23 = xor i1 %tobool22, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %conv27 = sext i32 %lnot.ext26 to i64
  %expval28 = call i64 @llvm.expect.i64(i64 %conv27, i64 0)
  %tobool29 = icmp ne i64 %expval28, 0
  br i1 %tobool29, label %if.then30, label %if.end39

if.then30:                                        ; preds = %if.end21
  %self31 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 0
  call void @usbmon_urb_submit_error(%struct.usb_bus* %self31, %struct.urb* %urb, i32 %status.1)
  %hcpriv = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 1
  store i8* null, i8** %hcpriv, align 8, !tbaa !321
  %urb_list = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 5
  call void @INIT_LIST_HEAD.70(%struct.list_head* %urb_list)
  %use_count32 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 2
  call void @atomic_dec(%union.anon.5* %use_count32)
  %dev33 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %6 = load %struct.usb_device*, %struct.usb_device** %dev33, align 8, !tbaa !210
  %urbnum34 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 30
  call void @atomic_dec(%union.anon.5* %urbnum34)
  %reject = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 3
  %call35 = call i32 @atomic_read.67(%union.anon.5* %reject)
  %tobool36 = icmp ne i32 %call35, 0
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.then30
  call void @__wake_up(%struct.__wait_queue_head* @usb_kill_urb_queue, i32 3, i32 1, i8* null)
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %if.then30
  call void bitcast (void (%struct.urb.824*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %urb)
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end21
  ret i32 %status.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usbmon_urb_submit(%struct.usb_bus* %bus, %struct.urb* %urb) #1 {
entry:
  %monitored = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 18
  %0 = load i32, i32* %monitored, align 8, !tbaa !325
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.usb_mon_operations*, %struct.usb_mon_operations** @mon_ops, align 8, !tbaa !48
  %urb_submit = getelementptr inbounds %struct.usb_mon_operations, %struct.usb_mon_operations* %1, i32 0, i32 0
  %2 = load void (%struct.usb_bus*, %struct.urb*)*, void (%struct.usb_bus*, %struct.urb*)** %urb_submit, align 8, !tbaa !391
  call void %2(%struct.usb_bus* %bus, %struct.urb* %urb)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_root_hub(%struct.usb_device* %udev) #1 {
entry:
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %cmp = icmp eq %struct.usb_device* %0, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @rh_urb_enqueue(%struct.usb_hcd.588* %hcd, %struct.urb* %urb) #0 {
entry:
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !218
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %0, i32 0, i32 0
  %call = call i32 @usb_endpoint_xfer_int.110(%struct.usb_endpoint_descriptor* %desc)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 @rh_queue_status(%struct.usb_hcd.588* %hcd, %struct.urb* %urb)
  br label %return

if.end:                                           ; preds = %entry
  %ep2 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %1 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep2, align 8, !tbaa !218
  %desc3 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %1, i32 0, i32 0
  %call4 = call i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %desc3)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %return

if.then6:                                         ; preds = %if.end
  %call7 = call i32 @rh_call_control(%struct.usb_hcd.588* %hcd, %struct.urb* %urb)
  br label %return

return:                                           ; preds = %if.then6, %if.end, %if.then
  %retval.0 = phi i32 [ %call1, %if.then ], [ %call7, %if.then6 ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @map_urb_for_dma(%struct.usb_hcd.588* %hcd, %struct.urb* %urb, i32 %mem_flags) #0 {
entry:
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %0 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %map_urb_for_dma = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %0, i32 0, i32 14
  %1 = load i32 (%struct.usb_hcd.588*, %struct.urb*, i32)*, i32 (%struct.usb_hcd.588*, %struct.urb*, i32)** %map_urb_for_dma, align 8, !tbaa !392
  %tobool = icmp ne i32 (%struct.usb_hcd.588*, %struct.urb*, i32)* %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %driver1 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %2 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver1, align 8, !tbaa !71
  %map_urb_for_dma2 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %2, i32 0, i32 14
  %3 = load i32 (%struct.usb_hcd.588*, %struct.urb*, i32)*, i32 (%struct.usb_hcd.588*, %struct.urb*, i32)** %map_urb_for_dma2, align 8, !tbaa !392
  %call = call i32 %3(%struct.usb_hcd.588* %hcd, %struct.urb* %urb, i32 %mem_flags)
  br label %return

if.else:                                          ; preds = %entry
  %call3 = call i32 @usb_hcd_map_urb_for_dma(%struct.usb_hcd.588* %hcd, %struct.urb* %urb, i32 %mem_flags)
  br label %return

return:                                           ; preds = %if.else, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %call3, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usbmon_urb_submit_error(%struct.usb_bus* %bus, %struct.urb* %urb, i32 %error) #1 {
entry:
  %monitored = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 18
  %0 = load i32, i32* %monitored, align 8, !tbaa !325
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.usb_mon_operations*, %struct.usb_mon_operations** @mon_ops, align 8, !tbaa !48
  %urb_submit_error = getelementptr inbounds %struct.usb_mon_operations, %struct.usb_mon_operations* %1, i32 0, i32 1
  %2 = load void (%struct.usb_bus*, %struct.urb*, i32)*, void (%struct.usb_bus*, %struct.urb*, i32)** %urb_submit_error, align 8, !tbaa !393
  call void %2(%struct.usb_bus* %bus, %struct.urb* %urb, i32 %error)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_int.110(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 3
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define internal i32 @rh_queue_status(%struct.usb_hcd.588* %hcd, %struct.urb* %urb) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !210
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 28
  %1 = load i32, i32* %maxchild, align 8, !tbaa !97
  %div = sdiv i32 %1, 8
  %add = add nsw i32 1, %div
  %2 = bitcast i64* %__dummy to i8*
  %3 = bitcast i64* %__dummy2 to i8*
  %4 = bitcast i64* %__dummy2 to i8*
  %5 = bitcast i64* %__dummy to i8*
  %call = call %struct.raw_spinlock* @spinlock_check.65(%struct.spinlock* @hcd_root_hub_lock)
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %status_urb = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 6
  %6 = load %struct.urb*, %struct.urb** %status_urb, align 8, !tbaa !319
  %tobool = icmp ne %struct.urb* %6, null
  br i1 %tobool, label %do.body9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %7 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !294
  %cmp6 = icmp ult i32 %7, %add
  br i1 %cmp6, label %do.body9, label %if.end20

do.body9:                                         ; preds = %lor.lhs.false, %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @rh_queue_status.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool10 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv12 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv12, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  br i1 %tobool13, label %if.then14, label %done

if.then14:                                        ; preds = %do.body9
  %self = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %8 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !306
  %call15 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @rh_queue_status.descriptor to %struct._ddebug*), %struct.device* %8, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.53.115, i32 0, i32 0))
  br label %done

if.end20:                                         ; preds = %lor.lhs.false
  %call21 = call i32 @usb_hcd_link_urb_to_ep(%struct.usb_hcd.588* %hcd, %struct.urb* %urb)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %done, label %if.end24

if.end24:                                         ; preds = %if.end20
  %status_urb25 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 6
  store %struct.urb* %urb, %struct.urb** %status_urb25, align 8, !tbaa !319
  %9 = bitcast %struct.usb_hcd.588* %hcd to i8*
  %hcpriv = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 1
  store i8* %9, i8** %hcpriv, align 8, !tbaa !321
  %uses_new_polling = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %bf.load26 = load i8, i8* %uses_new_polling, align 8
  %bf.lshr27 = lshr i8 %bf.load26, 3
  %bf.clear28 = and i8 %bf.lshr27, 1
  %bf.cast = zext i8 %bf.clear28 to i32
  %tobool29 = icmp ne i32 %bf.cast, 0
  br i1 %tobool29, label %if.else, label %if.then30

if.then30:                                        ; preds = %if.end24
  %rh_timer = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 5
  %10 = load volatile i64, i64* @jiffies, align 8, !tbaa !49
  %div31 = udiv i64 %10, 62
  %add32 = add i64 %div31, 1
  %mul = mul i64 %add32, 62
  %call33 = call i32 @mod_timer(%struct.timer_list* %rh_timer, i64 %mul)
  br label %done

if.else:                                          ; preds = %if.end24
  %flags34 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 10
  %11 = load i64, i64* %flags34, align 8, !tbaa !314
  %and35 = and i64 %11, 8
  %tobool36 = icmp ne i64 %and35, 0
  br i1 %tobool36, label %if.then37, label %done

if.then37:                                        ; preds = %if.else
  %rh_timer38 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 5
  %12 = load volatile i64, i64* @jiffies, align 8, !tbaa !49
  %call39 = call i32 @mod_timer(%struct.timer_list* %rh_timer38, i64 %12)
  br label %done

done:                                             ; preds = %if.then37, %if.else, %if.then30, %if.end20, %if.then14, %do.body9
  %retval1.0 = phi i32 [ -22, %if.then14 ], [ -22, %do.body9 ], [ %call21, %if.end20 ], [ 0, %if.else ], [ 0, %if.then37 ], [ 0, %if.then30 ]
  call void @spin_unlock_irqrestore.66(%struct.spinlock* @hcd_root_hub_lock, i64 %call3)
  ret i32 %retval1.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rh_call_control(%struct.usb_hcd.588* %hcd, %struct.urb* %urb) #0 {
entry:
  %tbuf = alloca [15 x i8], align 4
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %0 = load i8*, i8** %transfer_buffer, align 8, !tbaa !293
  %1 = bitcast [15 x i8]* %tbuf to i8*
  %arraydecay = getelementptr inbounds [15 x i8], [15 x i8]* %tbuf, i32 0, i32 0
  call void @__might_sleep(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i32 458, i32 0)
  call void @spin_lock_irq.48(%struct.spinlock* @hcd_root_hub_lock)
  %call = call i32 @usb_hcd_link_urb_to_ep(%struct.usb_hcd.588* %hcd, %struct.urb* %urb)
  call void @spin_unlock_irq.49(%struct.spinlock* @hcd_root_hub_lock)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = bitcast %struct.usb_hcd.588* %hcd to i8*
  %hcpriv = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 1
  store i8* %2, i8** %hcpriv, align 8, !tbaa !321
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 21
  %3 = load i8*, i8** %setup_packet, align 8, !tbaa !371
  %4 = bitcast i8* %3 to %struct.usb_ctrlrequest*
  %bRequestType = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %4, i32 0, i32 0
  %5 = load i8, i8* %bRequestType, align 1, !tbaa !394
  %conv = zext i8 %5 to i32
  %shl = shl i32 %conv, 8
  %bRequest = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %4, i32 0, i32 1
  %6 = load i8, i8* %bRequest, align 1, !tbaa !396
  %conv4 = zext i8 %6 to i32
  %or = or i32 %shl, %conv4
  %conv5 = trunc i32 %or to i16
  %wValue6 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %4, i32 0, i32 2
  %7 = load i16, i16* %wValue6, align 1, !tbaa !397
  %wIndex7 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %4, i32 0, i32 3
  %8 = load i16, i16* %wIndex7, align 1, !tbaa !398
  %wLength8 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %4, i32 0, i32 4
  %9 = load i16, i16* %wLength8, align 1, !tbaa !399
  %conv9 = zext i16 %9 to i32
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %10 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !294
  %cmp = icmp ugt i32 %conv9, %10
  br i1 %cmp, label %sw.epilog150, label %if.end12

if.end12:                                         ; preds = %if.end
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  store i32 0, i32* %actual_length, align 4, !tbaa !292
  %conv13 = zext i16 %conv5 to i32
  %Pivot42 = icmp slt i32 %conv13, 259
  br i1 %Pivot42, label %NodeBlock17, label %NodeBlock39

NodeBlock39:                                      ; preds = %if.end12
  %Pivot40 = icmp slt i32 %conv13, 32776
  br i1 %Pivot40, label %NodeBlock27, label %NodeBlock37

NodeBlock37:                                      ; preds = %NodeBlock39
  %Pivot38 = icmp slt i32 %conv13, 32778
  br i1 %Pivot38, label %LeafBlock29, label %NodeBlock35

NodeBlock35:                                      ; preds = %NodeBlock37
  %Pivot36 = icmp slt i32 %conv13, 33024
  br i1 %Pivot36, label %LeafBlock31, label %LeafBlock33

LeafBlock33:                                      ; preds = %NodeBlock35
  %SwitchLeaf34 = icmp eq i32 %conv13, 33024
  br i1 %SwitchLeaf34, label %sw.bb108, label %nongeneric

LeafBlock31:                                      ; preds = %NodeBlock35
  %SwitchLeaf32 = icmp eq i32 %conv13, 32778
  br i1 %SwitchLeaf32, label %sw.bb86, label %nongeneric

LeafBlock29:                                      ; preds = %NodeBlock37
  %SwitchLeaf30 = icmp eq i32 %conv13, 32776
  br i1 %SwitchLeaf30, label %sw.bb46, label %nongeneric

NodeBlock27:                                      ; preds = %NodeBlock39
  %Pivot28 = icmp slt i32 %conv13, 32768
  br i1 %Pivot28, label %LeafBlock19, label %NodeBlock25

NodeBlock25:                                      ; preds = %NodeBlock27
  %Pivot26 = icmp slt i32 %conv13, 32774
  br i1 %Pivot26, label %LeafBlock21, label %LeafBlock23

LeafBlock23:                                      ; preds = %NodeBlock25
  %SwitchLeaf24 = icmp eq i32 %conv13, 32774
  br i1 %SwitchLeaf24, label %sw.bb48, label %nongeneric

LeafBlock21:                                      ; preds = %NodeBlock25
  %SwitchLeaf22 = icmp eq i32 %conv13, 32768
  br i1 %SwitchLeaf22, label %sw.bb, label %nongeneric

LeafBlock19:                                      ; preds = %NodeBlock27
  %SwitchLeaf20 = icmp eq i32 %conv13, 259
  br i1 %SwitchLeaf20, label %do.body113, label %nongeneric

NodeBlock17:                                      ; preds = %if.end12
  %Pivot18 = icmp slt i32 %conv13, 9
  br i1 %Pivot18, label %NodeBlock5, label %NodeBlock15

NodeBlock15:                                      ; preds = %NodeBlock17
  %Pivot16 = icmp slt i32 %conv13, 11
  br i1 %Pivot16, label %LeafBlock7, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %conv13, 257
  br i1 %Pivot14, label %LeafBlock9, label %LeafBlock11

LeafBlock11:                                      ; preds = %NodeBlock13
  %SwitchLeaf12 = icmp eq i32 %conv13, 257
  br i1 %SwitchLeaf12, label %do.body113, label %nongeneric

LeafBlock9:                                       ; preds = %NodeBlock13
  %SwitchLeaf10 = icmp eq i32 %conv13, 11
  br i1 %SwitchLeaf10, label %sw.epilog150, label %nongeneric

LeafBlock7:                                       ; preds = %NodeBlock15
  %SwitchLeaf8 = icmp eq i32 %conv13, 9
  br i1 %SwitchLeaf8, label %sw.epilog150, label %nongeneric

NodeBlock5:                                       ; preds = %NodeBlock17
  %Pivot6 = icmp slt i32 %conv13, 3
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %conv13, 5
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %conv13, 5
  br i1 %SwitchLeaf4, label %do.body90, label %nongeneric

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv13, 3
  br i1 %SwitchLeaf2, label %sw.bb30, label %nongeneric

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %conv13, 1
  br i1 %SwitchLeaf, label %sw.bb20, label %nongeneric

sw.bb:                                            ; preds = %LeafBlock21
  %self = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 10
  %11 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !151
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %11, i32 0, i32 11
  %call14 = call zeroext i1 @device_may_wakeup(%struct.device* %dev)
  %conv15 = zext i1 %call14 to i32
  %shl16 = shl i32 %conv15, 1
  %or17 = or i32 %shl16, 1
  %conv18 = trunc i32 %or17 to i8
  %arrayidx = getelementptr inbounds [15 x i8], [15 x i8]* %tbuf, i64 0, i64 0
  store i8 %conv18, i8* %arrayidx, align 4, !tbaa !84
  %arrayidx19 = getelementptr inbounds [15 x i8], [15 x i8]* %tbuf, i64 0, i64 1
  store i8 0, i8* %arrayidx19, align 1, !tbaa !84
  br label %sw.epilog150

sw.bb20:                                          ; preds = %LeafBlock
  %conv21 = zext i16 %7 to i32
  %cmp22 = icmp eq i32 %conv21, 1
  br i1 %cmp22, label %if.then24, label %sw.epilog150

if.then24:                                        ; preds = %sw.bb20
  %self25 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %root_hub26 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self25, i32 0, i32 10
  %12 = load %struct.usb_device*, %struct.usb_device** %root_hub26, align 8, !tbaa !151
  %dev27 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 11
  %call28 = call i32 @device_set_wakeup_enable(%struct.device* %dev27, i1 zeroext false)
  br label %sw.epilog150

sw.bb30:                                          ; preds = %LeafBlock1
  %self31 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %root_hub32 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self31, i32 0, i32 10
  %13 = load %struct.usb_device*, %struct.usb_device** %root_hub32, align 8, !tbaa !151
  %dev33 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 11
  %call34 = call zeroext i1 @device_can_wakeup(%struct.device* %dev33)
  %conv36 = zext i16 %7 to i32
  %cmp37 = icmp eq i32 %conv36, 1
  %or.cond = and i1 %call34, %cmp37
  br i1 %or.cond, label %if.then39, label %sw.epilog150

if.then39:                                        ; preds = %sw.bb30
  %self40 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %root_hub41 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self40, i32 0, i32 10
  %14 = load %struct.usb_device*, %struct.usb_device** %root_hub41, align 8, !tbaa !151
  %dev42 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %14, i32 0, i32 11
  %call43 = call i32 @device_set_wakeup_enable(%struct.device* %dev42, i1 zeroext true)
  br label %sw.epilog150

sw.bb46:                                          ; preds = %LeafBlock29
  %arrayidx47 = getelementptr inbounds [15 x i8], [15 x i8]* %tbuf, i64 0, i64 0
  store i8 1, i8* %arrayidx47, align 4, !tbaa !84
  br label %sw.epilog150

sw.bb48:                                          ; preds = %LeafBlock23
  %conv49 = zext i16 %7 to i32
  %and = and i32 %conv49, 65280
  %Pivot57 = icmp slt i32 %and, 768
  br i1 %Pivot57, label %NodeBlock48, label %NodeBlock54

NodeBlock54:                                      ; preds = %sw.bb48
  %Pivot55 = icmp slt i32 %and, 3840
  br i1 %Pivot55, label %LeafBlock50, label %LeafBlock52

LeafBlock52:                                      ; preds = %NodeBlock54
  %SwitchLeaf53 = icmp eq i32 %and, 3840
  br i1 %SwitchLeaf53, label %nongeneric, label %sw.epilog150

LeafBlock50:                                      ; preds = %NodeBlock54
  %SwitchLeaf51 = icmp eq i32 %and, 768
  br i1 %SwitchLeaf51, label %sw.bb70, label %sw.epilog150

NodeBlock48:                                      ; preds = %sw.bb48
  %Pivot49 = icmp slt i32 %and, 512
  br i1 %Pivot49, label %LeafBlock44, label %LeafBlock46

LeafBlock46:                                      ; preds = %NodeBlock48
  %SwitchLeaf47 = icmp eq i32 %and, 512
  br i1 %SwitchLeaf47, label %sw.bb57, label %sw.epilog150

LeafBlock44:                                      ; preds = %NodeBlock48
  %SwitchLeaf45 = icmp eq i32 %and, 256
  br i1 %SwitchLeaf45, label %sw.bb50, label %sw.epilog150

sw.bb50:                                          ; preds = %LeafBlock44
  %speed = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 3
  %15 = load i32, i32* %speed, align 8, !tbaa !311
  %Pivot68 = icmp slt i32 %15, 32
  br i1 %Pivot68, label %LeafBlock59, label %NodeBlock65

NodeBlock65:                                      ; preds = %sw.bb50
  %Pivot66 = icmp slt i32 %15, 64
  br i1 %Pivot66, label %LeafBlock61, label %LeafBlock63

LeafBlock63:                                      ; preds = %NodeBlock65
  %SwitchLeaf64 = icmp eq i32 %15, 64
  br i1 %SwitchLeaf64, label %sw.epilog, label %sw.epilog150

LeafBlock61:                                      ; preds = %NodeBlock65
  %SwitchLeaf62 = icmp eq i32 %15, 32
  br i1 %SwitchLeaf62, label %sw.epilog, label %sw.epilog150

LeafBlock59:                                      ; preds = %sw.bb50
  %SwitchLeaf60 = icmp eq i32 %15, 16
  br i1 %SwitchLeaf60, label %sw.epilog, label %sw.epilog150

sw.epilog:                                        ; preds = %LeafBlock59, %LeafBlock61, %LeafBlock63
  %bufp.0 = phi i8* [ getelementptr inbounds ([18 x i8], [18 x i8]* @usb3_rh_dev_descriptor, i32 0, i32 0), %LeafBlock63 ], [ getelementptr inbounds ([18 x i8], [18 x i8]* @usb2_rh_dev_descriptor, i32 0, i32 0), %LeafBlock61 ], [ getelementptr inbounds ([18 x i8], [18 x i8]* @usb11_rh_dev_descriptor, i32 0, i32 0), %LeafBlock59 ]
  %has_tt = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %bf.load = load i8, i8* %has_tt, align 8
  %bf.lshr = lshr i8 %bf.load, 6
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool54 = icmp ne i32 %bf.cast, 0
  %. = select i1 %tobool54, i8 1, i8 0
  br label %sw.epilog150

sw.bb57:                                          ; preds = %LeafBlock46
  %speed58 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 3
  %16 = load i32, i32* %speed58, align 8, !tbaa !311
  %Pivot79 = icmp slt i32 %16, 32
  br i1 %Pivot79, label %LeafBlock70, label %NodeBlock76

NodeBlock76:                                      ; preds = %sw.bb57
  %Pivot77 = icmp slt i32 %16, 64
  br i1 %Pivot77, label %LeafBlock72, label %LeafBlock74

LeafBlock74:                                      ; preds = %NodeBlock76
  %SwitchLeaf75 = icmp eq i32 %16, 64
  br i1 %SwitchLeaf75, label %sw.epilog63, label %sw.epilog150

LeafBlock72:                                      ; preds = %NodeBlock76
  %SwitchLeaf73 = icmp eq i32 %16, 32
  br i1 %SwitchLeaf73, label %sw.epilog63, label %sw.epilog150

LeafBlock70:                                      ; preds = %sw.bb57
  %SwitchLeaf71 = icmp eq i32 %16, 16
  br i1 %SwitchLeaf71, label %sw.epilog63, label %sw.epilog150

sw.epilog63:                                      ; preds = %LeafBlock70, %LeafBlock72, %LeafBlock74
  %bufp.1 = phi i8* [ getelementptr inbounds ([31 x i8], [31 x i8]* @ss_rh_config_descriptor, i32 0, i32 0), %LeafBlock74 ], [ getelementptr inbounds ([25 x i8], [25 x i8]* @hs_rh_config_descriptor, i32 0, i32 0), %LeafBlock72 ], [ getelementptr inbounds ([25 x i8], [25 x i8]* @fs_rh_config_descriptor, i32 0, i32 0), %LeafBlock70 ]
  %len.0 = phi i32 [ 31, %LeafBlock74 ], [ 25, %LeafBlock72 ], [ 25, %LeafBlock70 ]
  %self64 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %root_hub65 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self64, i32 0, i32 10
  %17 = load %struct.usb_device*, %struct.usb_device** %root_hub65, align 8, !tbaa !151
  %dev66 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %17, i32 0, i32 11
  %call67 = call zeroext i1 @device_can_wakeup(%struct.device* %dev66)
  %.95 = select i1 %call67, i8 1, i8 0
  br label %sw.epilog150

sw.bb70:                                          ; preds = %LeafBlock50
  %conv71 = zext i16 %7 to i32
  %and72 = and i32 %conv71, 255
  %cmp73 = icmp slt i32 %and72, 4
  br i1 %cmp73, label %if.then75, label %sw.epilog150

if.then75:                                        ; preds = %sw.bb70
  %conv76 = zext i16 %7 to i32
  %and77 = and i32 %conv76, 255
  %conv78 = zext i16 %9 to i32
  %call79 = call i32 @rh_string(i32 %and77, %struct.usb_hcd.588* %hcd, i8* %0, i32 %conv78)
  %actual_length80 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  store i32 %call79, i32* %actual_length80, align 4, !tbaa !292
  br label %sw.epilog150

sw.bb86:                                          ; preds = %LeafBlock31
  %arrayidx87 = getelementptr inbounds [15 x i8], [15 x i8]* %tbuf, i64 0, i64 0
  store i8 0, i8* %arrayidx87, align 4, !tbaa !84
  br label %sw.epilog150

do.body90:                                        ; preds = %LeafBlock3
  %bf.load91 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @rh_call_control.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr92 = lshr i32 %bf.load91, 18
  %bf.clear93 = and i32 %bf.lshr92, 255
  %and94 = and i32 %bf.clear93, 1
  %tobool95 = icmp ne i32 %and94, 0
  %lnot = xor i1 %tobool95, true
  %lnot96 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot96 to i32
  %conv97 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv97, i64 0)
  %tobool98 = icmp ne i64 %expval, 0
  br i1 %tobool98, label %if.then99, label %sw.epilog150

if.then99:                                        ; preds = %do.body90
  %self100 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self100, i32 0, i32 0
  %18 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !306
  %conv101 = zext i16 %7 to i32
  %call102 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @rh_call_control.descriptor to %struct._ddebug*), %struct.device* %18, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.54.111, i32 0, i32 0), i32 %conv101)
  br label %sw.epilog150

sw.bb108:                                         ; preds = %LeafBlock33
  %arrayidx109 = getelementptr inbounds [15 x i8], [15 x i8]* %tbuf, i64 0, i64 0
  store i8 0, i8* %arrayidx109, align 4, !tbaa !84
  %arrayidx110 = getelementptr inbounds [15 x i8], [15 x i8]* %tbuf, i64 0, i64 1
  store i8 0, i8* %arrayidx110, align 1, !tbaa !84
  br label %do.body113

do.body113:                                       ; preds = %sw.bb108, %LeafBlock11, %LeafBlock19
  %len.2 = phi i32 [ 0, %LeafBlock11 ], [ 0, %LeafBlock19 ], [ 2, %sw.bb108 ]
  %bf.load114 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @rh_call_control.descriptor.55 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr115 = lshr i32 %bf.load114, 18
  %bf.clear116 = and i32 %bf.lshr115, 255
  %and117 = and i32 %bf.clear116, 1
  %tobool118 = icmp ne i32 %and117, 0
  %lnot119 = xor i1 %tobool118, true
  %lnot121 = xor i1 %lnot119, true
  %lnot.ext122 = zext i1 %lnot121 to i32
  %conv123 = sext i32 %lnot.ext122 to i64
  %expval124 = call i64 @llvm.expect.i64(i64 %conv123, i64 0)
  %tobool125 = icmp ne i64 %expval124, 0
  br i1 %tobool125, label %if.then126, label %sw.epilog150

if.then126:                                       ; preds = %do.body113
  %self127 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller128 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self127, i32 0, i32 0
  %19 = load %struct.device*, %struct.device** %controller128, align 8, !tbaa !306
  %call129 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @rh_call_control.descriptor.55 to %struct._ddebug*), %struct.device* %19, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.56.112, i32 0, i32 0))
  br label %sw.epilog150

nongeneric:                                       ; preds = %LeafBlock52, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock7, %LeafBlock9, %LeafBlock11, %LeafBlock19, %LeafBlock21, %LeafBlock23, %LeafBlock29, %LeafBlock31, %LeafBlock33
  %conv136 = zext i16 %conv5 to i32
  %Pivot94 = icmp slt i32 %conv136, 40966
  br i1 %Pivot94, label %NodeBlock85, label %NodeBlock91

NodeBlock91:                                      ; preds = %nongeneric
  %Pivot92 = icmp slt i32 %conv136, 41728
  br i1 %Pivot92, label %LeafBlock87, label %LeafBlock89

LeafBlock89:                                      ; preds = %NodeBlock91
  %SwitchLeaf90 = icmp eq i32 %conv136, 41728
  br i1 %SwitchLeaf90, label %sw.epilog139, label %NewDefault80

LeafBlock87:                                      ; preds = %NodeBlock91
  %SwitchLeaf88 = icmp eq i32 %conv136, 40966
  br i1 %SwitchLeaf88, label %sw.epilog139, label %NewDefault80

NodeBlock85:                                      ; preds = %nongeneric
  %Pivot86 = icmp slt i32 %conv136, 40960
  br i1 %Pivot86, label %LeafBlock81, label %LeafBlock83

LeafBlock83:                                      ; preds = %NodeBlock85
  %SwitchLeaf84 = icmp eq i32 %conv136, 40960
  br i1 %SwitchLeaf84, label %sw.epilog139, label %NewDefault80

LeafBlock81:                                      ; preds = %NodeBlock85
  %SwitchLeaf82 = icmp eq i32 %conv136, 32774
  br i1 %SwitchLeaf82, label %sw.epilog139, label %NewDefault80

NewDefault80:                                     ; preds = %LeafBlock81, %LeafBlock83, %LeafBlock87, %LeafBlock89
  br label %sw.epilog139

sw.epilog139:                                     ; preds = %NewDefault80, %LeafBlock81, %LeafBlock83, %LeafBlock87, %LeafBlock89
  %len.3 = phi i32 [ 0, %LeafBlock81 ], [ 0, %NewDefault80 ], [ 4, %LeafBlock89 ], [ 4, %LeafBlock83 ], [ 15, %LeafBlock87 ]
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %20 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %hub_control = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %20, i32 0, i32 19
  %21 = load i32 (%struct.usb_hcd.588*, i16, i16, i16, i8*, i16)*, i32 (%struct.usb_hcd.588*, i16, i16, i16, i8*, i16)** %hub_control, align 8, !tbaa !400
  %arraydecay140 = getelementptr inbounds [15 x i8], [15 x i8]* %tbuf, i32 0, i32 0
  %call141 = call i32 %21(%struct.usb_hcd.588* %hcd, i16 zeroext %conv5, i16 zeroext %7, i16 zeroext %8, i8* %arraydecay140, i16 zeroext %9)
  %conv142 = zext i16 %conv5 to i32
  %cmp143 = icmp eq i32 %conv142, 40966
  br i1 %cmp143, label %if.then145, label %sw.epilog150

if.then145:                                       ; preds = %sw.epilog139
  %self146 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %root_hub147 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self146, i32 0, i32 10
  %22 = load %struct.usb_device*, %struct.usb_device** %root_hub147, align 8, !tbaa !151
  %arraydecay148 = getelementptr inbounds [15 x i8], [15 x i8]* %tbuf, i32 0, i32 0
  %23 = bitcast i8* %arraydecay148 to %struct.usb_hub_descriptor*
  call void @usb_hub_adjust_deviceremovable(%struct.usb_device* %22, %struct.usb_hub_descriptor* %23)
  br label %sw.epilog150

sw.epilog150:                                     ; preds = %if.then145, %sw.epilog139, %if.then126, %do.body113, %if.then99, %do.body90, %sw.bb86, %if.then75, %sw.bb70, %sw.epilog63, %LeafBlock70, %LeafBlock72, %LeafBlock74, %sw.epilog, %LeafBlock59, %LeafBlock61, %LeafBlock63, %LeafBlock44, %LeafBlock46, %LeafBlock50, %LeafBlock52, %sw.bb46, %if.then39, %sw.bb30, %if.then24, %sw.bb20, %sw.bb, %LeafBlock7, %LeafBlock9, %if.end
  %bufp.3 = phi i8* [ %arraydecay, %if.then24 ], [ %arraydecay, %if.then39 ], [ %arraydecay, %LeafBlock7 ], [ %arraydecay, %LeafBlock9 ], [ %arraydecay, %sw.bb ], [ %arraydecay, %sw.bb46 ], [ %arraydecay, %sw.bb86 ], [ %bufp.0, %sw.epilog ], [ %bufp.1, %sw.epilog63 ], [ %arraydecay, %if.then75 ], [ %arraydecay, %if.then99 ], [ %arraydecay, %do.body90 ], [ %arraydecay, %if.then126 ], [ %arraydecay, %do.body113 ], [ %arraydecay, %if.then145 ], [ %arraydecay, %sw.epilog139 ], [ %arraydecay, %LeafBlock52 ], [ %arraydecay, %LeafBlock50 ], [ %arraydecay, %LeafBlock46 ], [ %arraydecay, %LeafBlock44 ], [ %arraydecay, %sw.bb70 ], [ %arraydecay, %LeafBlock74 ], [ %arraydecay, %LeafBlock72 ], [ %arraydecay, %LeafBlock70 ], [ %arraydecay, %LeafBlock63 ], [ %arraydecay, %LeafBlock61 ], [ %arraydecay, %LeafBlock59 ], [ %arraydecay, %sw.bb30 ], [ %arraydecay, %sw.bb20 ], [ %arraydecay, %if.end ]
  %len.4 = phi i32 [ 0, %if.then24 ], [ 0, %if.then39 ], [ 0, %LeafBlock7 ], [ 0, %LeafBlock9 ], [ 2, %sw.bb ], [ 1, %sw.bb46 ], [ 1, %sw.bb86 ], [ 18, %sw.epilog ], [ %len.0, %sw.epilog63 ], [ 0, %if.then75 ], [ 0, %if.then99 ], [ 0, %do.body90 ], [ %len.2, %if.then126 ], [ %len.2, %do.body113 ], [ %len.3, %if.then145 ], [ %len.3, %sw.epilog139 ], [ 0, %LeafBlock52 ], [ 0, %LeafBlock50 ], [ 0, %LeafBlock46 ], [ 0, %LeafBlock44 ], [ 0, %sw.bb70 ], [ 0, %LeafBlock74 ], [ 0, %LeafBlock72 ], [ 0, %LeafBlock70 ], [ 0, %LeafBlock63 ], [ 0, %LeafBlock61 ], [ 0, %LeafBlock59 ], [ 0, %sw.bb30 ], [ 0, %sw.bb20 ], [ 0, %if.end ]
  %status.0 = phi i32 [ %call, %if.then24 ], [ %call, %if.then39 ], [ %call, %LeafBlock7 ], [ %call, %LeafBlock9 ], [ %call, %sw.bb ], [ %call, %sw.bb46 ], [ %call, %sw.bb86 ], [ %call, %if.then75 ], [ %call, %sw.epilog63 ], [ %call, %sw.epilog ], [ %call, %if.then99 ], [ %call, %do.body90 ], [ %call, %if.then126 ], [ %call, %do.body113 ], [ %call141, %if.then145 ], [ %call141, %sw.epilog139 ], [ -32, %LeafBlock52 ], [ -32, %LeafBlock50 ], [ -32, %LeafBlock46 ], [ -32, %LeafBlock44 ], [ -32, %sw.bb70 ], [ -32, %LeafBlock74 ], [ -32, %LeafBlock72 ], [ -32, %LeafBlock70 ], [ -32, %LeafBlock63 ], [ -32, %LeafBlock61 ], [ -32, %LeafBlock59 ], [ -32, %sw.bb30 ], [ -32, %sw.bb20 ], [ -32, %if.end ]
  %patch_wakeup.2 = phi i8 [ 0, %if.then24 ], [ 0, %if.then39 ], [ 0, %LeafBlock7 ], [ 0, %LeafBlock9 ], [ 0, %sw.bb ], [ 0, %sw.bb46 ], [ 0, %sw.bb86 ], [ 0, %sw.epilog ], [ %.95, %sw.epilog63 ], [ 0, %if.then75 ], [ 0, %if.then99 ], [ 0, %do.body90 ], [ 0, %if.then126 ], [ 0, %do.body113 ], [ 0, %if.then145 ], [ 0, %sw.epilog139 ], [ 0, %LeafBlock52 ], [ 0, %LeafBlock50 ], [ 0, %LeafBlock46 ], [ 0, %LeafBlock44 ], [ 0, %sw.bb70 ], [ 0, %LeafBlock74 ], [ 0, %LeafBlock72 ], [ 0, %LeafBlock70 ], [ 0, %LeafBlock63 ], [ 0, %LeafBlock61 ], [ 0, %LeafBlock59 ], [ 0, %sw.bb30 ], [ 0, %sw.bb20 ], [ 0, %if.end ]
  %patch_protocol.2 = phi i8 [ 0, %if.then24 ], [ 0, %if.then39 ], [ 0, %LeafBlock7 ], [ 0, %LeafBlock9 ], [ 0, %sw.bb ], [ 0, %sw.bb46 ], [ 0, %sw.bb86 ], [ %., %sw.epilog ], [ 0, %sw.epilog63 ], [ 0, %if.then75 ], [ 0, %if.then99 ], [ 0, %do.body90 ], [ 0, %if.then126 ], [ 0, %do.body113 ], [ 0, %if.then145 ], [ 0, %sw.epilog139 ], [ 0, %LeafBlock52 ], [ 0, %LeafBlock50 ], [ 0, %LeafBlock46 ], [ 0, %LeafBlock44 ], [ 0, %sw.bb70 ], [ 0, %LeafBlock74 ], [ 0, %LeafBlock72 ], [ 0, %LeafBlock70 ], [ 0, %LeafBlock63 ], [ 0, %LeafBlock61 ], [ 0, %LeafBlock59 ], [ 0, %sw.bb30 ], [ 0, %sw.bb20 ], [ 0, %if.end ]
  %cmp151 = icmp slt i32 %status.0, 0
  br i1 %cmp151, label %if.then153, label %if.else185

if.then153:                                       ; preds = %sw.epilog150
  %cmp154 = icmp ne i32 %status.0, -32
  br i1 %cmp154, label %do.body158, label %if.end190

do.body158:                                       ; preds = %if.then153
  %bf.load159 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @rh_call_control.descriptor.57 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr160 = lshr i32 %bf.load159, 18
  %bf.clear161 = and i32 %bf.lshr160, 255
  %and162 = and i32 %bf.clear161, 1
  %tobool163 = icmp ne i32 %and162, 0
  %lnot164 = xor i1 %tobool163, true
  %lnot166 = xor i1 %lnot164, true
  %lnot.ext167 = zext i1 %lnot166 to i32
  %conv168 = sext i32 %lnot.ext167 to i64
  %expval169 = call i64 @llvm.expect.i64(i64 %conv168, i64 0)
  %tobool170 = icmp ne i64 %expval169, 0
  br i1 %tobool170, label %if.then171, label %if.end190

if.then171:                                       ; preds = %do.body158
  %self172 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %controller173 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self172, i32 0, i32 0
  %24 = load %struct.device*, %struct.device** %controller173, align 8, !tbaa !306
  %conv174 = zext i16 %conv5 to i32
  %conv175 = zext i16 %7 to i32
  %conv176 = zext i16 %8 to i32
  %conv177 = zext i16 %9 to i32
  %call178 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @rh_call_control.descriptor.57 to %struct._ddebug*), %struct.device* %24, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.58.113, i32 0, i32 0), i32 %conv174, i32 %conv175, i32 %conv176, i32 %conv177, i32 %status.0)
  br label %if.end190

if.else185:                                       ; preds = %sw.epilog150
  %cmp186 = icmp sgt i32 %status.0, 0
  %status.0.len.4 = select i1 %cmp186, i32 %status.0, i32 %len.4
  %.status.0 = select i1 %cmp186, i32 0, i32 %status.0
  br label %if.end190

if.end190:                                        ; preds = %if.else185, %if.then171, %do.body158, %if.then153
  %len.6 = phi i32 [ %status.0.len.4, %if.else185 ], [ 0, %do.body158 ], [ 0, %if.then171 ], [ 0, %if.then153 ]
  %status.2 = phi i32 [ %.status.0, %if.else185 ], [ %status.0, %do.body158 ], [ %status.0, %if.then171 ], [ %status.0, %if.then153 ]
  %tobool191 = icmp ne i32 %len.6, 0
  br i1 %tobool191, label %if.then192, label %if.end220

if.then192:                                       ; preds = %if.end190
  %transfer_buffer_length193 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %25 = load i32, i32* %transfer_buffer_length193, align 8, !tbaa !294
  %cmp194 = icmp ult i32 %25, %len.6
  br i1 %cmp194, label %if.then196, label %if.end198

if.then196:                                       ; preds = %if.then192
  %transfer_buffer_length197 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %26 = load i32, i32* %transfer_buffer_length197, align 8, !tbaa !294
  br label %if.end198

if.end198:                                        ; preds = %if.then196, %if.then192
  %len.7 = phi i32 [ %26, %if.then196 ], [ %len.6, %if.then192 ]
  %actual_length199 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  store i32 %len.7, i32* %actual_length199, align 4, !tbaa !292
  %conv200 = zext i32 %len.7 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %bufp.3, i64 %conv200, i32 1, i1 false)
  %conv201 = zext i8 %patch_wakeup.2 to i32
  %tobool202 = icmp ne i32 %conv201, 0
  %conv204 = zext i32 %len.7 to i64
  %cmp205 = icmp ugt i64 %conv204, 7
  %or.cond96 = and i1 %tobool202, %cmp205
  br i1 %or.cond96, label %if.then207, label %if.end211

if.then207:                                       ; preds = %if.end198
  %27 = bitcast i8* %0 to %struct.usb_config_descriptor*
  %bmAttributes = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %27, i32 0, i32 6
  %28 = load i8, i8* %bmAttributes, align 1, !tbaa !401
  %conv208 = zext i8 %28 to i32
  %or209 = or i32 %conv208, 32
  %conv210 = trunc i32 %or209 to i8
  store i8 %conv210, i8* %bmAttributes, align 1, !tbaa !401
  br label %if.end211

if.end211:                                        ; preds = %if.then207, %if.end198
  %conv212 = zext i8 %patch_protocol.2 to i32
  %tobool213 = icmp ne i32 %conv212, 0
  %conv215 = zext i32 %len.7 to i64
  %cmp216 = icmp ugt i64 %conv215, 6
  %or.cond97 = and i1 %tobool213, %cmp216
  br i1 %or.cond97, label %if.then218, label %if.end220

if.then218:                                       ; preds = %if.end211
  %29 = bitcast i8* %0 to %struct.usb_device_descriptor*
  %bDeviceProtocol = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %29, i32 0, i32 5
  store i8 1, i8* %bDeviceProtocol, align 1, !tbaa !402
  br label %if.end220

if.end220:                                        ; preds = %if.then218, %if.end211, %if.end190
  call void @spin_lock_irq.48(%struct.spinlock* @hcd_root_hub_lock)
  call void @usb_hcd_unlink_urb_from_ep(%struct.usb_hcd.588* undef, %struct.urb* %urb)
  call void @spin_unlock(%struct.spinlock* @hcd_root_hub_lock)
  call void @usb_hcd_giveback_urb(%struct.usb_hcd.588* %hcd, %struct.urb* %urb, i32 %status.2)
  call void @spin_lock(%struct.spinlock* @hcd_root_hub_lock)
  call void @spin_unlock_irq.49(%struct.spinlock* @hcd_root_hub_lock)
  br label %cleanup

cleanup:                                          ; preds = %if.end220, %entry
  %retval.0 = phi i32 [ 0, %if.end220 ], [ %call, %entry ]
  %30 = bitcast [15 x i8]* %tbuf to i8*
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @device_may_wakeup(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %can_wakeup = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i8, i8* %can_wakeup, align 4
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %power1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %wakeup = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power1, i32 0, i32 5
  %0 = load %struct.wakeup_source*, %struct.wakeup_source** %wakeup, align 8, !tbaa !403
  %tobool2 = icmp ne %struct.wakeup_source* %0, null
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %1 = phi i1 [ false, %entry ], [ %lnot3, %land.rhs ]
  ret i1 %1
}

declare i32 @device_set_wakeup_enable(%struct.device*, i1 zeroext) #2

; Function Attrs: nounwind uwtable
define internal i32 @rh_string(i32 %id, %struct.usb_hcd.588* %hcd, i8* %data, i32 %len) #0 {
entry:
  %buf = alloca [100 x i8], align 16
  %0 = bitcast [100 x i8]* %buf to i8*
  %Pivot6 = icmp slt i32 %id, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %id, 3
  br i1 %Pivot4, label %sw.bb2, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %id, 3
  br i1 %SwitchLeaf2, label %sw.bb3, label %cleanup

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %id, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb1

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %id, 0
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %LeafBlock
  %cmp = icmp ugt i32 %len, 4
  %.len = select i1 %cmp, i32 4, i32 %len
  %conv = zext i32 %.len to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %data, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @rh_string.langids, i32 0, i32 0), i64 %conv, i32 1, i1 false)
  br label %cleanup

sw.bb1:                                           ; preds = %NodeBlock
  %self = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 0
  %bus_name = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 2
  %1 = load i8*, i8** %bus_name, align 8, !tbaa !358
  br label %sw.epilog

sw.bb2:                                           ; preds = %NodeBlock3
  %product_desc = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 2
  %2 = load i8*, i8** %product_desc, align 8, !tbaa !363
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock1
  %arraydecay = getelementptr inbounds [100 x i8], [100 x i8]* %buf, i32 0, i32 0
  %call = call %struct.new_utsname* @init_utsname()
  %sysname = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [65 x i8], [65 x i8]* %sysname, i32 0, i32 0
  %call5 = call %struct.new_utsname* @init_utsname()
  %release = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call5, i32 0, i32 2
  %arraydecay6 = getelementptr inbounds [65 x i8], [65 x i8]* %release, i32 0, i32 0
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %3 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %description = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %3, i32 0, i32 0
  %4 = load i8*, i8** %description, align 8, !tbaa !316
  %call7 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 100, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.59.114, i32 0, i32 0), i8* %arraydecay4, i8* %arraydecay6, i8* %4)
  %arraydecay8 = getelementptr inbounds [100 x i8], [100 x i8]* %buf, i32 0, i32 0
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb3, %sw.bb2, %sw.bb1
  %s.0 = phi i8* [ %1, %sw.bb1 ], [ %2, %sw.bb2 ], [ %arraydecay8, %sw.bb3 ]
  %call9 = call i32 @ascii2desc(i8* %s.0, i8* %data, i32 %len)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %sw.bb, %LeafBlock, %LeafBlock1
  %retval.0 = phi i32 [ %.len, %sw.bb ], [ %call9, %sw.epilog ], [ 0, %LeafBlock ], [ 0, %LeafBlock1 ]
  %5 = bitcast [100 x i8]* %buf to i8*
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.new_utsname* @init_utsname() #1 {
entry:
  ret %struct.new_utsname* getelementptr inbounds (%struct.uts_namespace, %struct.uts_namespace* @init_uts_ns, i32 0, i32 1)
}

; Function Attrs: nounwind uwtable
define internal i32 @ascii2desc(i8* %s, i8* %buf, i32 %len) #0 {
entry:
  %call = call i64 @strlen(i8* %s)
  %mul = mul i64 2, %call
  %add = add i64 2, %mul
  %conv = trunc i64 %add to i32
  %cmp = icmp ugt i32 %conv, 254
  %.conv = select i1 %cmp, i32 254, i32 %conv
  %cmp2 = icmp ugt i32 %len, %.conv
  %len.addr.0 = select i1 %cmp2, i32 %.conv, i32 %len
  %add6 = add i32 %.conv, 768
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %entry
  %t.1 = phi i32 [ %add6, %entry ], [ %conv15, %if.end11 ]
  %n.0 = phi i32 [ %len.addr.0, %entry ], [ %dec8, %if.end11 ]
  %buf.addr.0 = phi i8* [ %buf, %entry ], [ %incdec.ptr13, %if.end11 ]
  %s.addr.0 = phi i8* [ %s, %entry ], [ %incdec.ptr14, %if.end11 ]
  %dec = add i32 %n.0, -1
  %tobool = icmp ne i32 %n.0, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %conv7 = trunc i32 %t.1 to i8
  %incdec.ptr = getelementptr inbounds i8, i8* %buf.addr.0, i32 1
  store i8 %conv7, i8* %buf.addr.0, align 1, !tbaa !84
  %dec8 = add i32 %dec, -1
  %tobool9 = icmp ne i32 %dec, 0
  br i1 %tobool9, label %if.end11, label %while.end

if.end11:                                         ; preds = %while.body
  %shr = lshr i32 %t.1, 8
  %conv12 = trunc i32 %shr to i8
  %incdec.ptr13 = getelementptr inbounds i8, i8* %incdec.ptr, i32 1
  store i8 %conv12, i8* %incdec.ptr, align 1, !tbaa !84
  %incdec.ptr14 = getelementptr inbounds i8, i8* %s.addr.0, i32 1
  %0 = load i8, i8* %s.addr.0, align 1, !tbaa !84
  %conv15 = zext i8 %0 to i32
  br label %while.cond

while.end:                                        ; preds = %while.body, %while.cond
  ret i32 %len.addr.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_unlink_urb(%struct.urb* %urb, i32 %status) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %call = call %struct.raw_spinlock* @spinlock_check.65(%struct.spinlock* @hcd_urb_unlink_lock)
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %use_count = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 2
  %call6 = call i32 @atomic_read.67(%union.anon.5* %use_count)
  %cmp7 = icmp sgt i32 %call6, 0
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !210
  %call9 = call %struct.usb_device* @usb_get_dev(%struct.usb_device* %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %retval1.0 = phi i32 [ 0, %if.then ], [ -43, %entry ]
  call void @spin_unlock_irqrestore.66(%struct.spinlock* @hcd_urb_unlink_lock, i64 %call3)
  %cmp10 = icmp eq i32 %retval1.0, 0
  br i1 %cmp10, label %if.then12, label %if.end17

if.then12:                                        ; preds = %if.end
  %dev13 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %5 = load %struct.usb_device*, %struct.usb_device** %dev13, align 8, !tbaa !210
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %5, i32 0, i32 9
  %6 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call14 = call %struct.usb_hcd.588* @bus_to_hcd.55(%struct.usb_bus* %6)
  %call15 = call i32 @unlink1(%struct.usb_hcd.588* %call14, %struct.urb* %urb, i32 %status)
  %dev16 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %7 = load %struct.usb_device*, %struct.usb_device** %dev16, align 8, !tbaa !210
  call void @usb_put_dev(%struct.usb_device* %7)
  br label %if.end17

if.end17:                                         ; preds = %if.then12, %if.end
  %retval1.1 = phi i32 [ %call15, %if.then12 ], [ %retval1.0, %if.end ]
  switch i32 %retval1.1, label %do.body27 [
    i32 0, label %if.end41
    i32 -43, label %if.end40
    i32 -16, label %if.end40
  ]

do.body27:                                        ; preds = %if.end17
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_unlink_urb.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot28 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot28 to i32
  %conv29 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv29, i64 0)
  %tobool30 = icmp ne i64 %expval, 0
  br i1 %tobool30, label %if.then31, label %if.end40

if.then31:                                        ; preds = %do.body27
  %dev32 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %8 = load %struct.usb_device*, %struct.usb_device** %dev32, align 8, !tbaa !210
  %dev33 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 11
  %call34 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_unlink_urb.descriptor to %struct._ddebug*), %struct.device* %dev33, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.6.116, i32 0, i32 0), %struct.urb* %urb, i32 %retval1.1)
  br label %if.end40

if.end40:                                         ; preds = %if.then31, %do.body27, %if.end17, %if.end17
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.end17
  %retval1.2 = phi i32 [ %retval1.1, %if.end40 ], [ -115, %if.end17 ]
  ret i32 %retval1.2
}

; Function Attrs: nounwind uwtable
define internal i32 @unlink1(%struct.usb_hcd.588* %hcd, %struct.urb* %urb, i32 %status) #0 {
entry:
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !210
  %call = call i32 @is_root_hub(%struct.usb_device* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = call i32 @usb_rh_urb_dequeue(%struct.usb_hcd.588* %hcd, %struct.urb* %urb, i32 %status)
  br label %if.end

if.else:                                          ; preds = %entry
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %1 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %urb_dequeue = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %1, i32 0, i32 13
  %2 = load i32 (%struct.usb_hcd.588*, %struct.urb*, i32)*, i32 (%struct.usb_hcd.588*, %struct.urb*, i32)** %urb_dequeue, align 8, !tbaa !404
  %call2 = call i32 %2(%struct.usb_hcd.588* %hcd, %struct.urb* %urb, i32 %status)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %value.0 = phi i32 [ %call1, %if.then ], [ %call2, %if.else ]
  ret i32 %value.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_rh_urb_dequeue(%struct.usb_hcd.588* %hcd, %struct.urb* %urb, i32 %status) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %call = call %struct.raw_spinlock* @spinlock_check.65(%struct.spinlock* @hcd_root_hub_lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %call5 = call i32 @usb_hcd_check_unlink_urb(%struct.usb_hcd.588* undef, %struct.urb* %urb, i32 %status)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %done, label %if.end

if.end:                                           ; preds = %entry
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %4 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !218
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %4, i32 0, i32 0
  %call6 = call i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %desc)
  %cmp7 = icmp eq i32 %call6, 0
  br i1 %cmp7, label %done, label %if.else

if.else:                                          ; preds = %if.end
  %uses_new_polling = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 11
  %bf.load = load i8, i8* %uses_new_polling, align 8
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool10 = icmp ne i32 %bf.cast, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %if.else
  %rh_timer = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 5
  %call12 = call i32 @del_timer(%struct.timer_list* %rh_timer)
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.else
  %status_urb = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 6
  %5 = load %struct.urb*, %struct.urb** %status_urb, align 8, !tbaa !319
  %cmp14 = icmp eq %struct.urb* %urb, %5
  br i1 %cmp14, label %if.then16, label %done

if.then16:                                        ; preds = %if.end13
  %status_urb17 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 6
  store %struct.urb* null, %struct.urb** %status_urb17, align 8, !tbaa !319
  call void @usb_hcd_unlink_urb_from_ep(%struct.usb_hcd.588* undef, %struct.urb* %urb)
  call void @spin_unlock(%struct.spinlock* @hcd_root_hub_lock)
  call void @usb_hcd_giveback_urb(%struct.usb_hcd.588* %hcd, %struct.urb* %urb, i32 %status)
  call void @spin_lock(%struct.spinlock* @hcd_root_hub_lock)
  br label %done

done:                                             ; preds = %if.then16, %if.end13, %if.end, %entry
  call void @spin_unlock_irqrestore.66(%struct.spinlock* @hcd_root_hub_lock, i64 %call2)
  ret i32 %call5
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !286
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  ret i32 %and
}

declare i32 @del_timer(%struct.timer_list*) #2

; Function Attrs: nounwind uwtable
define void @usb_hcd_flush_endpoint(%struct.usb_device* %udev, %struct.usb_host_endpoint* %ep) #0 {
entry:
  %tobool = icmp ne %struct.usb_host_endpoint* %ep, null
  br i1 %tobool, label %do.body, label %cleanup.cont

do.body:                                          ; preds = %entry
  call void @__might_sleep(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i32 1681, i32 0)
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.588* @bus_to_hcd.55(%struct.usb_bus* %0)
  call void @spin_lock_irq.48(%struct.spinlock* @hcd_urb_list_lock)
  br label %rescan

NewDefault5:                                      ; preds = %LeafBlock6
  br label %rescan

rescan:                                           ; preds = %NewDefault5, %do.body
  %urb_list = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 3
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %rescan
  %urb_list32.sink = phi %struct.list_head* [ %urb_list32, %for.inc ], [ %urb_list, %rescan ]
  %next33 = getelementptr inbounds %struct.list_head, %struct.list_head* %urb_list32.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next33, align 8, !tbaa !48
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr35 = getelementptr inbounds i8, i8* %2, i64 -32
  %3 = bitcast i8* %add.ptr35 to %struct.urb*
  %urb_list4 = getelementptr inbounds %struct.urb, %struct.urb* %3, i32 0, i32 5
  %urb_list5 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 3
  %cmp = icmp ne %struct.list_head* %urb_list4, %urb_list5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %unlinked = getelementptr inbounds %struct.urb, %struct.urb* %3, i32 0, i32 4
  %4 = load i32, i32* %unlinked, align 8, !tbaa !322
  %tobool6 = icmp ne i32 %4, 0
  br i1 %tobool6, label %LeafBlock6, label %if.end8

if.end8:                                          ; preds = %for.body
  %call9 = call %struct.urb* bitcast (%struct.urb.824* (%struct.urb.824*)* @usb_get_urb to %struct.urb* (%struct.urb*)*)(%struct.urb* %3)
  %call10 = call i32 @usb_urb_dir_in(%struct.urb* %3)
  call void @spin_unlock(%struct.spinlock* @hcd_urb_list_lock)
  %call11 = call i32 @unlink1(%struct.usb_hcd.588* %call, %struct.urb* %3, i32 -108)
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_flush_endpoint.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool14 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool14, true
  %lnot15 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot15 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool16 = icmp ne i64 %expval, 0
  br i1 %tobool16, label %if.then17, label %do.end30

if.then17:                                        ; preds = %if.end8
  %self = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %5 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !306
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call18 = call i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %desc)
  %tobool19 = icmp ne i32 %call10, 0
  %cond = select i1 %tobool19, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.45.737, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.44.736, i32 0, i32 0)
  %desc20 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call21 = call i32 @usb_endpoint_type(%struct.usb_endpoint_descriptor* %desc20)
  %Pivot4 = icmp slt i32 %call21, 2
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.then17
  %Pivot = icmp slt i32 %call21, 3
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %call21, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %if.then17
  %SwitchLeaf = icmp eq i32 %call21, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock, %LeafBlock1, %NodeBlock
  %s.0 = phi i8* [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.13.120, i32 0, i32 0), %sw.default ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.27.821, i32 0, i32 0), %LeafBlock ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11.122, i32 0, i32 0), %NodeBlock ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.12.123, i32 0, i32 0), %LeafBlock1 ]
  %call25 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_flush_endpoint.descriptor to %struct._ddebug*), %struct.device* %5, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7.124, i32 0, i32 0), %struct.urb* %3, i32 %call18, i8* %cond, i8* %s.0)
  br label %do.end30

do.end30:                                         ; preds = %sw.epilog, %if.end8
  call void bitcast (void (%struct.urb.824*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %3)
  call void @spin_lock(%struct.spinlock* @hcd_urb_list_lock)
  br label %LeafBlock6

LeafBlock6:                                       ; preds = %do.end30, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 6, %do.end30 ], [ 9, %for.body ]
  %SwitchLeaf7 = icmp eq i32 %cleanup.dest.slot.0, 9
  br i1 %SwitchLeaf7, label %for.inc, label %NewDefault5

for.inc:                                          ; preds = %LeafBlock6
  %urb_list32 = getelementptr inbounds %struct.urb, %struct.urb* %3, i32 0, i32 5
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @spin_unlock_irq.49(%struct.spinlock* @hcd_urb_list_lock)
  br label %while.cond

while.cond:                                       ; preds = %if.end53, %for.end
  %urb_list36 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 3
  %call37 = call i32 @list_empty.125(%struct.list_head* %urb_list36)
  %tobool38 = icmp ne i32 %call37, 0
  %lnot39 = xor i1 %tobool38, true
  br i1 %lnot39, label %while.body, label %cleanup.cont

while.body:                                       ; preds = %while.cond
  call void @spin_lock_irq.48(%struct.spinlock* @hcd_urb_list_lock)
  %urb_list41 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 3
  %call42 = call i32 @list_empty.125(%struct.list_head* %urb_list41)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.end50, label %if.then44

if.then44:                                        ; preds = %while.body
  %urb_list46 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 3
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %urb_list46, i32 0, i32 1
  %6 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !405
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr48 = getelementptr inbounds i8, i8* %7, i64 -32
  %8 = bitcast i8* %add.ptr48 to %struct.urb*
  %call49 = call %struct.urb* bitcast (%struct.urb.824* (%struct.urb.824*)* @usb_get_urb to %struct.urb* (%struct.urb*)*)(%struct.urb* %8)
  br label %if.end50

if.end50:                                         ; preds = %if.then44, %while.body
  %urb.1 = phi %struct.urb* [ null, %while.body ], [ %8, %if.then44 ]
  call void @spin_unlock_irq.49(%struct.spinlock* @hcd_urb_list_lock)
  %tobool51 = icmp ne %struct.urb* %urb.1, null
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end50
  call void bitcast (void (%struct.urb.824*)* @usb_kill_urb to void (%struct.urb*)*)(%struct.urb* %urb.1)
  call void bitcast (void (%struct.urb.824*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %urb.1)
  br label %if.end53

if.end53:                                         ; preds = %if.then52, %if.end50
  br label %while.cond

cleanup.cont:                                     ; preds = %while.cond, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_type(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty.125(%struct.list_head* %head) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !95
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %udev, %struct.usb_host_config* %new_config, %struct.usb_host_interface* %cur_alt, %struct.usb_host_interface* %new_alt) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.588* @bus_to_hcd.55(%struct.usb_bus* %0)
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %1 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %check_bandwidth = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %1, i32 0, i32 32
  %2 = load i32 (%struct.usb_hcd.588*, %struct.usb_device*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*)** %check_bandwidth, align 8, !tbaa !406
  %tobool = icmp ne i32 (%struct.usb_hcd.588*, %struct.usb_device*)* %2, null
  br i1 %tobool, label %if.end, label %cleanup163

if.end:                                           ; preds = %entry
  %tobool1 = icmp ne %struct.usb_host_config* %new_config, null
  %tobool2 = icmp ne %struct.usb_host_interface* %cur_alt, null
  %or.cond = or i1 %tobool1, %tobool2
  br i1 %or.cond, label %if.end20, label %if.then3

if.then3:                                         ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then3
  %i.0 = phi i32 [ 1, %if.then3 ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 17
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out, i64 0, i64 %idxprom
  %3 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8, !tbaa !48
  %tobool4 = icmp ne %struct.usb_host_endpoint* %3, null
  br i1 %tobool4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %for.body
  %driver6 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %4 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver6, align 8, !tbaa !71
  %drop_endpoint = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %4, i32 0, i32 31
  %5 = load i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint*)** %drop_endpoint, align 8, !tbaa !407
  %call7 = call i32 %5(%struct.usb_hcd.588* %call, %struct.usb_device* %udev, %struct.usb_host_endpoint* %3)
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %for.body
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 16
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in, i64 0, i64 %idxprom9
  %6 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx10, align 8, !tbaa !48
  %tobool11 = icmp ne %struct.usb_host_endpoint* %6, null
  br i1 %tobool11, label %if.then12, label %for.inc

if.then12:                                        ; preds = %if.end8
  %driver13 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %7 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver13, align 8, !tbaa !71
  %drop_endpoint14 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %7, i32 0, i32 31
  %8 = load i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint*)** %drop_endpoint14, align 8, !tbaa !407
  %call15 = call i32 %8(%struct.usb_hcd.588* %call, %struct.usb_device* %udev, %struct.usb_host_endpoint* %6)
  br label %for.inc

for.inc:                                          ; preds = %if.then12, %if.end8
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %driver17 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %9 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver17, align 8, !tbaa !71
  %check_bandwidth18 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %9, i32 0, i32 32
  %10 = load i32 (%struct.usb_hcd.588*, %struct.usb_device*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*)** %check_bandwidth18, align 8, !tbaa !406
  %call19 = call i32 %10(%struct.usb_hcd.588* %call, %struct.usb_device* %udev)
  br label %cleanup163

if.end20:                                         ; preds = %if.end
  %tobool21 = icmp ne %struct.usb_host_config* %new_config, null
  br i1 %tobool21, label %if.then22, label %if.end90

if.then22:                                        ; preds = %if.end20
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %new_config, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %11 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv = zext i8 %11 to i32
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc53, %if.then22
  %i.1 = phi i32 [ 1, %if.then22 ], [ %inc54, %for.inc53 ]
  %ret.0 = phi i32 [ 0, %if.then22 ], [ %ret.2, %for.inc53 ]
  %cmp24 = icmp slt i32 %i.1, 16
  br i1 %cmp24, label %for.body26, label %for.end55

for.body26:                                       ; preds = %for.cond23
  %ep_out27 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 17
  %idxprom28 = sext i32 %i.1 to i64
  %arrayidx29 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out27, i64 0, i64 %idxprom28
  %12 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx29, align 8, !tbaa !48
  %tobool30 = icmp ne %struct.usb_host_endpoint* %12, null
  br i1 %tobool30, label %if.then31, label %if.end39

if.then31:                                        ; preds = %for.body26
  %driver32 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %13 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver32, align 8, !tbaa !71
  %drop_endpoint33 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %13, i32 0, i32 31
  %14 = load i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint*)** %drop_endpoint33, align 8, !tbaa !407
  %call34 = call i32 %14(%struct.usb_hcd.588* %call, %struct.usb_device* %udev, %struct.usb_host_endpoint* %12)
  %cmp35 = icmp slt i32 %call34, 0
  br i1 %cmp35, label %reset, label %if.end39

if.end39:                                         ; preds = %if.then31, %for.body26
  %ret.1 = phi i32 [ %ret.0, %for.body26 ], [ %call34, %if.then31 ]
  %ep_in40 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 16
  %idxprom41 = sext i32 %i.1 to i64
  %arrayidx42 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in40, i64 0, i64 %idxprom41
  %15 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx42, align 8, !tbaa !48
  %tobool43 = icmp ne %struct.usb_host_endpoint* %15, null
  br i1 %tobool43, label %if.then44, label %for.inc53

if.then44:                                        ; preds = %if.end39
  %driver45 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %16 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver45, align 8, !tbaa !71
  %drop_endpoint46 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %16, i32 0, i32 31
  %17 = load i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint*)** %drop_endpoint46, align 8, !tbaa !407
  %call47 = call i32 %17(%struct.usb_hcd.588* %call, %struct.usb_device* %udev, %struct.usb_host_endpoint* %15)
  %cmp48 = icmp slt i32 %call47, 0
  br i1 %cmp48, label %reset, label %for.inc53

for.inc53:                                        ; preds = %if.then44, %if.end39
  %ret.2 = phi i32 [ %ret.1, %if.end39 ], [ %call47, %if.then44 ]
  %inc54 = add nsw i32 %i.1, 1
  br label %for.cond23

for.end55:                                        ; preds = %for.cond23
  br label %for.cond56

for.cond56:                                       ; preds = %for.inc87, %for.end55
  %i.2 = phi i32 [ 0, %for.end55 ], [ %inc88, %for.inc87 ]
  %ret.3 = phi i32 [ %ret.0, %for.end55 ], [ %ret.5, %for.inc87 ]
  %cmp57 = icmp slt i32 %i.2, %conv
  br i1 %cmp57, label %for.body59, label %if.end90

for.body59:                                       ; preds = %for.cond56
  %intf_cache = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %new_config, i32 0, i32 4
  %idxprom60 = sext i32 %i.2 to i64
  %arrayidx61 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache, i64 0, i64 %idxprom60
  %18 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx61, align 8, !tbaa !48
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %18, i32 0, i32 2
  %arrayidx62 = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i64 0, i64 0
  %desc63 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx62, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc63, i32 0, i32 2
  %19 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !68
  %conv64 = zext i8 %19 to i32
  %call65 = call %struct.usb_host_interface* @usb_find_alt_setting(%struct.usb_host_config* %new_config, i32 %conv64, i32 0)
  %tobool66 = icmp ne %struct.usb_host_interface* %call65, null
  %call65.arrayidx62 = select i1 %tobool66, %struct.usb_host_interface* %call65, %struct.usb_host_interface* %arrayidx62
  br label %for.cond69

for.cond69:                                       ; preds = %for.inc83, %for.body59
  %j.0 = phi i32 [ 0, %for.body59 ], [ %inc84, %for.inc83 ]
  %ret.4 = phi i32 [ %ret.3, %for.body59 ], [ %call78, %for.inc83 ]
  %desc70 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %call65.arrayidx62, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc70, i32 0, i32 4
  %20 = load i8, i8* %bNumEndpoints, align 4, !tbaa !270
  %conv71 = zext i8 %20 to i32
  %cmp72 = icmp slt i32 %j.0, %conv71
  br i1 %cmp72, label %for.body74, label %NodeBlock

for.body74:                                       ; preds = %for.cond69
  %driver75 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %21 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver75, align 8, !tbaa !71
  %add_endpoint = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %21, i32 0, i32 30
  %22 = load i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint*)** %add_endpoint, align 8, !tbaa !408
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %call65.arrayidx62, i32 0, i32 3
  %23 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !271
  %idxprom76 = sext i32 %j.0 to i64
  %arrayidx77 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %23, i64 %idxprom76
  %call78 = call i32 %22(%struct.usb_hcd.588* %call, %struct.usb_device* %udev, %struct.usb_host_endpoint* %arrayidx77)
  %cmp79 = icmp slt i32 %call78, 0
  br i1 %cmp79, label %NodeBlock, label %for.inc83

for.inc83:                                        ; preds = %for.body74
  %inc84 = add nsw i32 %j.0, 1
  br label %for.cond69

NodeBlock:                                        ; preds = %for.body74, %for.cond69
  %ret.5 = phi i32 [ %call78, %for.body74 ], [ %ret.4, %for.cond69 ]
  %cleanup.dest.slot.0 = phi i32 [ 8, %for.body74 ], [ 0, %for.cond69 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 8
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 8
  br i1 %SwitchLeaf2, label %reset, label %cleanup163

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc87, label %cleanup163

for.inc87:                                        ; preds = %LeafBlock
  %inc88 = add nsw i32 %i.2, 1
  br label %for.cond56

if.end90:                                         ; preds = %for.cond56, %if.end20
  %ret.6 = phi i32 [ 0, %if.end20 ], [ %ret.3, %for.cond56 ]
  %tobool91 = icmp ne %struct.usb_host_interface* %cur_alt, null
  %tobool93 = icmp ne %struct.usb_host_interface* %new_alt, null
  %or.cond10 = and i1 %tobool91, %tobool93
  br i1 %or.cond10, label %if.then94, label %if.end154

if.then94:                                        ; preds = %if.end90
  %desc95 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %cur_alt, i32 0, i32 0
  %bInterfaceNumber96 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc95, i32 0, i32 2
  %24 = load i8, i8* %bInterfaceNumber96, align 2, !tbaa !68
  %conv97 = zext i8 %24 to i32
  %call98 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %udev, i32 %conv97)
  %tobool99 = icmp ne %struct.usb_interface* %call98, null
  br i1 %tobool99, label %if.end101, label %NodeBlock8

if.end101:                                        ; preds = %if.then94
  %resetting_device = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call98, i32 0, i32 6
  %bf.load = load i8, i8* %resetting_device, align 8
  %bf.lshr = lshr i8 %bf.load, 7
  %bf.cast = zext i8 %bf.lshr to i32
  %tobool102 = icmp ne i32 %bf.cast, 0
  br i1 %tobool102, label %if.then103, label %if.end110

if.then103:                                       ; preds = %if.end101
  %call104 = call %struct.usb_host_interface* @usb_altnum_to_altsetting(%struct.usb_interface* %call98, i32 0)
  %tobool105 = icmp ne %struct.usb_host_interface* %call104, null
  br i1 %tobool105, label %if.end110, label %if.then106

if.then106:                                       ; preds = %if.then103
  %altsetting107 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call98, i32 0, i32 0
  %25 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting107, align 8, !tbaa !60
  %arrayidx108 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %25, i64 0
  br label %if.end110

if.end110:                                        ; preds = %if.then106, %if.then103, %if.end101
  %cur_alt.addr.1 = phi %struct.usb_host_interface* [ %cur_alt, %if.end101 ], [ %call104, %if.then103 ], [ %arrayidx108, %if.then106 ]
  br label %for.cond111

for.cond111:                                      ; preds = %for.inc128, %if.end110
  %i.3 = phi i32 [ 0, %if.end110 ], [ %inc129, %for.inc128 ]
  %ret.7 = phi i32 [ %ret.6, %if.end110 ], [ %call123, %for.inc128 ]
  %desc112 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %cur_alt.addr.1, i32 0, i32 0
  %bNumEndpoints113 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc112, i32 0, i32 4
  %26 = load i8, i8* %bNumEndpoints113, align 4, !tbaa !270
  %conv114 = zext i8 %26 to i32
  %cmp115 = icmp slt i32 %i.3, %conv114
  br i1 %cmp115, label %for.body117, label %for.end130

for.body117:                                      ; preds = %for.cond111
  %driver118 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %27 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver118, align 8, !tbaa !71
  %drop_endpoint119 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %27, i32 0, i32 31
  %28 = load i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint*)** %drop_endpoint119, align 8, !tbaa !407
  %endpoint120 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %cur_alt.addr.1, i32 0, i32 3
  %29 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint120, align 8, !tbaa !271
  %idxprom121 = sext i32 %i.3 to i64
  %arrayidx122 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %29, i64 %idxprom121
  %call123 = call i32 %28(%struct.usb_hcd.588* %call, %struct.usb_device* %udev, %struct.usb_host_endpoint* %arrayidx122)
  %cmp124 = icmp slt i32 %call123, 0
  br i1 %cmp124, label %NodeBlock8, label %for.inc128

for.inc128:                                       ; preds = %for.body117
  %inc129 = add nsw i32 %i.3, 1
  br label %for.cond111

for.end130:                                       ; preds = %for.cond111
  br label %for.cond131

for.cond131:                                      ; preds = %for.inc148, %for.end130
  %i.4 = phi i32 [ 0, %for.end130 ], [ %inc149, %for.inc148 ]
  %ret.8 = phi i32 [ %ret.7, %for.end130 ], [ %call143, %for.inc148 ]
  %desc132 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %new_alt, i32 0, i32 0
  %bNumEndpoints133 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc132, i32 0, i32 4
  %30 = load i8, i8* %bNumEndpoints133, align 4, !tbaa !270
  %conv134 = zext i8 %30 to i32
  %cmp135 = icmp slt i32 %i.4, %conv134
  br i1 %cmp135, label %for.body137, label %NodeBlock8

for.body137:                                      ; preds = %for.cond131
  %driver138 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %31 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver138, align 8, !tbaa !71
  %add_endpoint139 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %31, i32 0, i32 30
  %32 = load i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*, %struct.usb_host_endpoint*)** %add_endpoint139, align 8, !tbaa !408
  %endpoint140 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %new_alt, i32 0, i32 3
  %33 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint140, align 8, !tbaa !271
  %idxprom141 = sext i32 %i.4 to i64
  %arrayidx142 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %33, i64 %idxprom141
  %call143 = call i32 %32(%struct.usb_hcd.588* %call, %struct.usb_device* %udev, %struct.usb_host_endpoint* %arrayidx142)
  %cmp144 = icmp slt i32 %call143, 0
  br i1 %cmp144, label %NodeBlock8, label %for.inc148

for.inc148:                                       ; preds = %for.body137
  %inc149 = add nsw i32 %i.4, 1
  br label %for.cond131

NodeBlock8:                                       ; preds = %for.body137, %for.cond131, %for.body117, %if.then94
  %ret.9 = phi i32 [ %ret.6, %if.then94 ], [ %call123, %for.body117 ], [ %call143, %for.body137 ], [ %ret.8, %for.cond131 ]
  %cleanup.dest.slot.1 = phi i32 [ 1, %if.then94 ], [ 8, %for.body117 ], [ 8, %for.body137 ], [ 0, %for.cond131 ]
  %Pivot9 = icmp slt i32 %cleanup.dest.slot.1, 8
  br i1 %Pivot9, label %LeafBlock4, label %LeafBlock6

LeafBlock6:                                       ; preds = %NodeBlock8
  %SwitchLeaf7 = icmp eq i32 %cleanup.dest.slot.1, 8
  br i1 %SwitchLeaf7, label %reset, label %cleanup163

LeafBlock4:                                       ; preds = %NodeBlock8
  %SwitchLeaf5 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf5, label %if.end154, label %cleanup163

if.end154:                                        ; preds = %LeafBlock4, %if.end90
  %driver155 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %34 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver155, align 8, !tbaa !71
  %check_bandwidth156 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %34, i32 0, i32 32
  %35 = load i32 (%struct.usb_hcd.588*, %struct.usb_device*)*, i32 (%struct.usb_hcd.588*, %struct.usb_device*)** %check_bandwidth156, align 8, !tbaa !406
  %call157 = call i32 %35(%struct.usb_hcd.588* %call, %struct.usb_device* %udev)
  br label %reset

reset:                                            ; preds = %if.end154, %LeafBlock6, %LeafBlock1, %if.then44, %if.then31
  %ret.10 = phi i32 [ %ret.5, %LeafBlock1 ], [ %call157, %if.end154 ], [ %ret.9, %LeafBlock6 ], [ %call34, %if.then31 ], [ %call47, %if.then44 ]
  %cmp158 = icmp slt i32 %ret.10, 0
  br i1 %cmp158, label %if.then160, label %cleanup163

if.then160:                                       ; preds = %reset
  %driver161 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %36 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver161, align 8, !tbaa !71
  %reset_bandwidth = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %36, i32 0, i32 33
  %37 = load void (%struct.usb_hcd.588*, %struct.usb_device*)*, void (%struct.usb_hcd.588*, %struct.usb_device*)** %reset_bandwidth, align 8, !tbaa !409
  call void %37(%struct.usb_hcd.588* %call, %struct.usb_device* %udev)
  br label %cleanup163

cleanup163:                                       ; preds = %if.then160, %reset, %LeafBlock4, %LeafBlock6, %LeafBlock, %LeafBlock1, %for.end, %entry
  %retval.1 = phi i32 [ 0, %for.end ], [ 0, %entry ], [ %ret.10, %if.then160 ], [ %ret.10, %reset ], [ undef, %LeafBlock ], [ undef, %LeafBlock1 ], [ -22, %LeafBlock6 ], [ -22, %LeafBlock4 ]
  ret i32 %retval.1
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_disable_endpoint(%struct.usb_device* %udev, %struct.usb_host_endpoint* %ep) #0 {
entry:
  call void @__might_sleep(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.53, i32 0, i32 0), i32 1892, i32 0)
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.588* @bus_to_hcd.55(%struct.usb_bus* %0)
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %1 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %endpoint_disable = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %1, i32 0, i32 16
  %2 = load void (%struct.usb_hcd.588*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd.588*, %struct.usb_host_endpoint*)** %endpoint_disable, align 8, !tbaa !410
  %tobool = icmp ne void (%struct.usb_hcd.588*, %struct.usb_host_endpoint*)* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %driver4 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %3 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver4, align 8, !tbaa !71
  %endpoint_disable5 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %3, i32 0, i32 16
  %4 = load void (%struct.usb_hcd.588*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd.588*, %struct.usb_host_endpoint*)** %endpoint_disable5, align 8, !tbaa !410
  call void %4(%struct.usb_hcd.588* %call, %struct.usb_host_endpoint* %ep)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_reset_endpoint(%struct.usb_device* %udev, %struct.usb_host_endpoint* %ep) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.588* @bus_to_hcd.55(%struct.usb_bus* %0)
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %1 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %endpoint_reset = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %1, i32 0, i32 17
  %2 = load void (%struct.usb_hcd.588*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd.588*, %struct.usb_host_endpoint*)** %endpoint_reset, align 8, !tbaa !411
  %tobool = icmp ne void (%struct.usb_hcd.588*, %struct.usb_host_endpoint*)* %2, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %driver1 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %3 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver1, align 8, !tbaa !71
  %endpoint_reset2 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %3, i32 0, i32 17
  %4 = load void (%struct.usb_hcd.588*, %struct.usb_host_endpoint*)*, void (%struct.usb_hcd.588*, %struct.usb_host_endpoint*)** %endpoint_reset2, align 8, !tbaa !411
  call void %4(%struct.usb_hcd.588* %call, %struct.usb_host_endpoint* %ep)
  br label %if.end29

if.else:                                          ; preds = %entry
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call3 = call i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %desc)
  %desc4 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call5 = call i32 @usb_endpoint_dir_out(%struct.usb_endpoint_descriptor* %desc4)
  %desc6 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call7 = call i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %desc6)
  %toggle = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 7
  %idxprom = sext i32 %call5 to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %toggle, i64 0, i64 %idxprom
  %5 = load i32, i32* %arrayidx, align 4, !tbaa !90
  %shl = shl i32 1, %call3
  %neg = xor i32 %shl, -1
  %and = and i32 %5, %neg
  %shl8 = shl i32 0, %call3
  %or = or i32 %and, %shl8
  %toggle9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 7
  %idxprom10 = sext i32 %call5 to i64
  %arrayidx11 = getelementptr inbounds [2 x i32], [2 x i32]* %toggle9, i64 0, i64 %idxprom10
  store i32 %or, i32* %arrayidx11, align 4, !tbaa !90
  %tobool12 = icmp ne i32 %call7, 0
  br i1 %tobool12, label %if.then13, label %if.end29

if.then13:                                        ; preds = %if.else
  %toggle14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 7
  %tobool15 = icmp ne i32 %call5, 0
  %lnot = xor i1 %tobool15, true
  %lnot.ext = zext i1 %lnot to i32
  %idxprom16 = sext i32 %lnot.ext to i64
  %arrayidx17 = getelementptr inbounds [2 x i32], [2 x i32]* %toggle14, i64 0, i64 %idxprom16
  %6 = load i32, i32* %arrayidx17, align 4, !tbaa !90
  %shl18 = shl i32 1, %call3
  %neg19 = xor i32 %shl18, -1
  %and20 = and i32 %6, %neg19
  %shl21 = shl i32 0, %call3
  %or22 = or i32 %and20, %shl21
  %toggle23 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 7
  %tobool24 = icmp ne i32 %call5, 0
  %lnot25 = xor i1 %tobool24, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %idxprom27 = sext i32 %lnot.ext26 to i64
  %arrayidx28 = getelementptr inbounds [2 x i32], [2 x i32]* %toggle23, i64 0, i64 %idxprom27
  store i32 %or22, i32* %arrayidx28, align 4, !tbaa !90
  br label %if.end29

if.end29:                                         ; preds = %if.then13, %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_dir_out(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !286
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 128
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_synchronize_unlinks(%struct.usb_device* %udev) #0 {
entry:
  call void @spin_lock_irq.48(%struct.spinlock* @hcd_urb_unlink_lock)
  call void @spin_unlock_irq.49(%struct.spinlock* @hcd_urb_unlink_lock)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_get_frame_number(%struct.usb_device* %udev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd.588* @bus_to_hcd.55(%struct.usb_bus* %0)
  %flags = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 10
  %1 = load i64, i64* %flags, align 8, !tbaa !314
  %and = and i64 %1, 32
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %call, i32 0, i32 8
  %2 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %get_frame_number = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %2, i32 0, i32 11
  %3 = load i32 (%struct.usb_hcd.588*)*, i32 (%struct.usb_hcd.588*)** %get_frame_number, align 8, !tbaa !412
  %call1 = call i32 %3(%struct.usb_hcd.588* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call1, %if.end ], [ -108, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @hcd_bus_suspend(%struct.usb_device* %rhdev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %buffer = alloca [6 x i8], align 1
  %.compoundliteral = alloca %union.anon.5, align 4
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %1 = bitcast %struct.usb_bus* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.usb_hcd.588*
  %state = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 21
  %3 = load i32, i32* %state, align 8, !tbaa !305
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_suspend.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end9

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 11
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %4 = load i32, i32* %event, align 4, !tbaa !42
  %and4 = and i32 %4, 1024
  %cmp = icmp ne i32 %and4, 0
  %cond = select i1 %cmp, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.15.132, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.27.821, i32 0, i32 0)
  %do_remote_wakeup = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 33
  %bf.load6 = load i8, i8* %do_remote_wakeup, align 8
  %bf.clear7 = and i8 %bf.load6, 1
  %bf.cast = zext i8 %bf.clear7 to i32
  %call = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_suspend.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.14.133, i32 0, i32 0), i8* %cond, i32 %bf.cast)
  br label %do.end9

do.end9:                                          ; preds = %if.then, %entry
  %flags = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 10
  %5 = load i64, i64* %flags, align 8, !tbaa !314
  %and10 = and i64 %5, 64
  %tobool11 = icmp ne i64 %and10, 0
  br i1 %tobool11, label %do.body14, label %if.end35

do.body14:                                        ; preds = %do.end9
  %bf.load15 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_suspend.descriptor.16 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr16 = lshr i32 %bf.load15, 18
  %bf.clear17 = and i32 %bf.lshr16, 255
  %and18 = and i32 %bf.clear17, 1
  %tobool19 = icmp ne i32 %and18, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %expval25 = call i64 @llvm.expect.i64(i64 %conv24, i64 0)
  %tobool26 = icmp ne i64 %expval25, 0
  br i1 %tobool26, label %if.then27, label %cleanup

if.then27:                                        ; preds = %do.body14
  %dev28 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 11
  %call29 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_suspend.descriptor.16 to %struct._ddebug*), %struct.device* %dev28, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.17.134, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.18.135, i32 0, i32 0))
  br label %cleanup

if.end35:                                         ; preds = %do.end9
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 8
  %6 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %bus_suspend = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %6, i32 0, i32 20
  %7 = load i32 (%struct.usb_hcd.588*)*, i32 (%struct.usb_hcd.588*)** %bus_suspend, align 8, !tbaa !413
  %tobool36 = icmp ne i32 (%struct.usb_hcd.588*)* %7, null
  br i1 %tobool36, label %if.else, label %if.end43

if.else:                                          ; preds = %if.end35
  %flags38 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags38, i32 5, i64* %flags38) #8, !srcloc !304
  %state39 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 21
  store i32 133, i32* %state39, align 8, !tbaa !305
  %driver40 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 8
  %8 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver40, align 8, !tbaa !71
  %bus_suspend41 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %8, i32 0, i32 20
  %9 = load i32 (%struct.usb_hcd.588*)*, i32 (%struct.usb_hcd.588*)** %bus_suspend41, align 8, !tbaa !413
  %call42 = call i32 %9(%struct.usb_hcd.588* %2)
  br label %if.end43

if.end43:                                         ; preds = %if.else, %if.end35
  %status.0 = phi i32 [ %call42, %if.else ], [ -2, %if.end35 ]
  %cmp44 = icmp eq i32 %status.0, 0
  br i1 %cmp44, label %if.then46, label %if.else86

if.then46:                                        ; preds = %if.end43
  call void @usb_set_device_state(%struct.usb_device* %rhdev, i32 8)
  %state47 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 21
  store i32 4, i32* %state47, align 8, !tbaa !305
  %do_remote_wakeup48 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 33
  %bf.load49 = load i8, i8* %do_remote_wakeup48, align 8
  %bf.clear50 = and i8 %bf.load49, 1
  %bf.cast51 = zext i8 %bf.clear50 to i32
  %tobool52 = icmp ne i32 %bf.cast51, 0
  br i1 %tobool52, label %if.then53, label %cleanup

if.then53:                                        ; preds = %if.then46
  %10 = bitcast [6 x i8]* %buffer to i8*
  %driver54 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 8
  %11 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver54, align 8, !tbaa !71
  %hub_status_data = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %11, i32 0, i32 18
  %12 = load i32 (%struct.usb_hcd.588*, i8*)*, i32 (%struct.usb_hcd.588*, i8*)** %hub_status_data, align 8, !tbaa !320
  %arraydecay = getelementptr inbounds [6 x i8], [6 x i8]* %buffer, i32 0, i32 0
  %call55 = call i32 %12(%struct.usb_hcd.588* %2, i8* %arraydecay)
  %cmp56 = icmp ne i32 %call55, 0
  br i1 %cmp56, label %do.body60, label %if.end84

do.body60:                                        ; preds = %if.then53
  %bf.load61 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_suspend.descriptor.19 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr62 = lshr i32 %bf.load61, 18
  %bf.clear63 = and i32 %bf.lshr62, 255
  %and64 = and i32 %bf.clear63, 1
  %tobool65 = icmp ne i32 %and64, 0
  %lnot66 = xor i1 %tobool65, true
  %lnot68 = xor i1 %lnot66, true
  %lnot.ext69 = zext i1 %lnot68 to i32
  %conv70 = sext i32 %lnot.ext69 to i64
  %expval71 = call i64 @llvm.expect.i64(i64 %conv70, i64 0)
  %tobool72 = icmp ne i64 %expval71, 0
  br i1 %tobool72, label %if.then73, label %do.end80

if.then73:                                        ; preds = %do.body60
  %dev74 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 11
  %call75 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_suspend.descriptor.19 to %struct._ddebug*), %struct.device* %dev74, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.20.136, i32 0, i32 0))
  br label %do.end80

do.end80:                                         ; preds = %if.then73, %do.body60
  %event81 = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  store i32 1040, i32* %event81, align 4, !tbaa !42
  %coerce.dive82 = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  %13 = load i32, i32* %coerce.dive82, align 4
  %call83 = call i32 @hcd_bus_resume(%struct.usb_device* %rhdev, i32 %13)
  br label %if.end84

if.end84:                                         ; preds = %do.end80, %if.then53
  %status.1 = phi i32 [ -16, %do.end80 ], [ %call55, %if.then53 ]
  %14 = bitcast [6 x i8]* %buffer to i8*
  br label %cleanup

if.else86:                                        ; preds = %if.end43
  call void @spin_lock_irq.48(%struct.spinlock* @hcd_root_hub_lock)
  %flags87 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 10
  %15 = load i64, i64* %flags87, align 8, !tbaa !314
  %and88 = and i64 %15, 64
  %tobool89 = icmp ne i64 %and88, 0
  br i1 %tobool89, label %if.end93, label %if.then90

if.then90:                                        ; preds = %if.else86
  %flags91 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags91, i32 5, i64* %flags91) #8, !srcloc !310
  %state92 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 21
  store i32 %3, i32* %state92, align 8, !tbaa !305
  br label %if.end93

if.end93:                                         ; preds = %if.then90, %if.else86
  call void @spin_unlock_irq.49(%struct.spinlock* @hcd_root_hub_lock)
  %bf.load96 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_suspend.descriptor.21 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr97 = lshr i32 %bf.load96, 18
  %bf.clear98 = and i32 %bf.lshr97, 255
  %and99 = and i32 %bf.clear98, 1
  %tobool100 = icmp ne i32 %and99, 0
  %lnot101 = xor i1 %tobool100, true
  %lnot103 = xor i1 %lnot101, true
  %lnot.ext104 = zext i1 %lnot103 to i32
  %conv105 = sext i32 %lnot.ext104 to i64
  %expval106 = call i64 @llvm.expect.i64(i64 %conv105, i64 0)
  %tobool107 = icmp ne i64 %expval106, 0
  br i1 %tobool107, label %if.then108, label %cleanup

if.then108:                                       ; preds = %if.end93
  %dev109 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 11
  %call110 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_suspend.descriptor.21 to %struct._ddebug*), %struct.device* %dev109, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.22.137, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.18.135, i32 0, i32 0), i32 %status.0)
  br label %cleanup

cleanup:                                          ; preds = %if.then108, %if.end93, %if.end84, %if.then46, %if.then27, %do.body14
  %retval.0 = phi i32 [ 0, %if.then27 ], [ 0, %do.body14 ], [ %status.1, %if.end84 ], [ %status.0, %if.then46 ], [ %status.0, %if.then108 ], [ %status.0, %if.end93 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @hcd_bus_resume(%struct.usb_device* %rhdev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %1 = bitcast %struct.usb_bus* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.usb_hcd.588*
  %state = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 21
  %3 = load i32, i32* %state, align 8, !tbaa !305
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_resume.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end7

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 11
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %4 = load i32, i32* %event, align 4, !tbaa !42
  %and4 = and i32 %4, 1024
  %cmp = icmp ne i32 %and4, 0
  %cond = select i1 %cmp, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.15.132, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.27.821, i32 0, i32 0)
  %call = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_resume.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.23.138, i32 0, i32 0), i8* %cond)
  br label %do.end7

do.end7:                                          ; preds = %if.then, %entry
  %flags = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 10
  %5 = load i64, i64* %flags, align 8, !tbaa !314
  %and8 = and i64 %5, 64
  %tobool9 = icmp ne i64 %and8, 0
  br i1 %tobool9, label %do.body12, label %if.end33

do.body12:                                        ; preds = %do.end7
  %bf.load13 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_resume.descriptor.24 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr14 = lshr i32 %bf.load13, 18
  %bf.clear15 = and i32 %bf.lshr14, 255
  %and16 = and i32 %bf.clear15, 1
  %tobool17 = icmp ne i32 %and16, 0
  %lnot18 = xor i1 %tobool17, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  %expval23 = call i64 @llvm.expect.i64(i64 %conv22, i64 0)
  %tobool24 = icmp ne i64 %expval23, 0
  br i1 %tobool24, label %if.then25, label %cleanup

if.then25:                                        ; preds = %do.body12
  %dev26 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 11
  %call27 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_resume.descriptor.24 to %struct._ddebug*), %struct.device* %dev26, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.17.134, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.25.139, i32 0, i32 0))
  br label %cleanup

if.end33:                                         ; preds = %do.end7
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 8
  %6 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %bus_resume = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %6, i32 0, i32 21
  %7 = load i32 (%struct.usb_hcd.588*)*, i32 (%struct.usb_hcd.588*)** %bus_resume, align 8, !tbaa !414
  %tobool34 = icmp ne i32 (%struct.usb_hcd.588*)* %7, null
  br i1 %tobool34, label %if.end36, label %cleanup

if.end36:                                         ; preds = %if.end33
  %flags37 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 10
  %8 = load i64, i64* %flags37, align 8, !tbaa !314
  %and38 = and i64 %8, 32
  %tobool39 = icmp ne i64 %and38, 0
  br i1 %tobool39, label %cleanup, label %if.end41

if.end41:                                         ; preds = %if.end36
  %state42 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 21
  store i32 132, i32* %state42, align 8, !tbaa !305
  %driver43 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 8
  %9 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver43, align 8, !tbaa !71
  %bus_resume44 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %9, i32 0, i32 21
  %10 = load i32 (%struct.usb_hcd.588*)*, i32 (%struct.usb_hcd.588*)** %bus_resume44, align 8, !tbaa !414
  %call45 = call i32 %10(%struct.usb_hcd.588* %2)
  %flags46 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags46, i32 4, i64* %flags46) #8, !srcloc !304
  %cmp47 = icmp eq i32 %call45, 0
  br i1 %cmp47, label %if.then49, label %if.else75

if.then49:                                        ; preds = %if.end41
  call void @spin_lock_irq.48(%struct.spinlock* @hcd_root_hub_lock)
  %flags50 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 10
  %11 = load i64, i64* %flags50, align 8, !tbaa !314
  %and51 = and i64 %11, 64
  %tobool52 = icmp ne i64 %and51, 0
  br i1 %tobool52, label %if.end58, label %if.then53

if.then53:                                        ; preds = %if.then49
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 15
  %12 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool54 = icmp ne %struct.usb_host_config* %12, null
  %cond55 = select i1 %tobool54, i32 7, i32 6
  call void @usb_set_device_state(%struct.usb_device* %rhdev, i32 %cond55)
  %flags56 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags56, i32 5, i64* %flags56) #8, !srcloc !310
  %state57 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 21
  store i32 1, i32* %state57, align 8, !tbaa !305
  br label %if.end58

if.end58:                                         ; preds = %if.then53, %if.then49
  call void @spin_unlock_irq.49(%struct.spinlock* @hcd_root_hub_lock)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end58
  %inc.sink = phi i32 [ %inc, %for.inc ], [ 1, %if.end58 ]
  %port1.0 = phi i32 [ 1, %if.end58 ], [ %inc, %for.inc ]
  %call74 = call %struct.usb_device* @usb_hub_find_child(%struct.usb_device* %rhdev, i32 %inc.sink)
  %maxchild = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 28
  %13 = load i32, i32* %maxchild, align 8, !tbaa !97
  %cmp60 = icmp sle i32 %port1.0, %13
  br i1 %cmp60, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %tobool62 = icmp ne %struct.usb_device* %call74, null
  br i1 %tobool62, label %if.else, label %for.inc

if.else:                                          ; preds = %for.body
  %state64 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call74, i32 0, i32 3
  %14 = load i32, i32* %state64, align 8, !tbaa !50
  %cmp65 = icmp ne i32 %14, 0
  br i1 %cmp65, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %if.else
  %port_is_suspended = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call74, i32 0, i32 33
  %bf.load67 = load i8, i8* %port_is_suspended, align 8
  %bf.lshr68 = lshr i8 %bf.load67, 2
  %bf.clear69 = and i8 %bf.lshr68, 1
  %bf.cast = zext i8 %bf.clear69 to i32
  %tobool70 = icmp ne i32 %bf.cast, 0
  br i1 %tobool70, label %for.inc, label %if.then71

if.then71:                                        ; preds = %land.lhs.true
  call void @usleep_range(i64 10000, i64 11000)
  br label %cleanup

for.inc:                                          ; preds = %land.lhs.true, %if.else, %for.body
  %inc = add nsw i32 %port1.0, 1
  br label %for.cond

if.else75:                                        ; preds = %if.end41
  %state76 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %2, i32 0, i32 21
  store i32 %3, i32* %state76, align 8, !tbaa !305
  %bf.load79 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_resume.descriptor.26 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr80 = lshr i32 %bf.load79, 18
  %bf.clear81 = and i32 %bf.lshr80, 255
  %and82 = and i32 %bf.clear81, 1
  %tobool83 = icmp ne i32 %and82, 0
  %lnot84 = xor i1 %tobool83, true
  %lnot86 = xor i1 %lnot84, true
  %lnot.ext87 = zext i1 %lnot86 to i32
  %conv88 = sext i32 %lnot.ext87 to i64
  %expval89 = call i64 @llvm.expect.i64(i64 %conv88, i64 0)
  %tobool90 = icmp ne i64 %expval89, 0
  br i1 %tobool90, label %if.then91, label %do.end98

if.then91:                                        ; preds = %if.else75
  %dev92 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %rhdev, i32 0, i32 11
  %call93 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_bus_resume.descriptor.26 to %struct._ddebug*), %struct.device* %dev92, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.22.137, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.25.139, i32 0, i32 0), i32 %call45)
  br label %do.end98

do.end98:                                         ; preds = %if.then91, %if.else75
  %cmp99 = icmp ne i32 %call45, -108
  br i1 %cmp99, label %if.then101, label %cleanup

if.then101:                                       ; preds = %do.end98
  call void @usb_hc_died(%struct.usb_hcd.588* %2)
  br label %cleanup

cleanup:                                          ; preds = %if.then101, %do.end98, %if.then71, %for.cond, %if.end36, %if.end33, %if.then25, %do.body12
  %retval.0 = phi i32 [ 0, %if.then25 ], [ 0, %do.body12 ], [ -2, %if.end33 ], [ 0, %if.end36 ], [ %call45, %do.end98 ], [ %call45, %if.then101 ], [ %call45, %if.then71 ], [ %call45, %for.cond ]
  ret i32 %retval.0
}

declare void @usleep_range(i64, i64) #2

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_find_raw_port_number(%struct.usb_hcd.588* %hcd, i32 %port1) #0 {
entry:
  %driver = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %0 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver, align 8, !tbaa !71
  %find_raw_port_number = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %0, i32 0, i32 41
  %1 = load i32 (%struct.usb_hcd.588*, i32)*, i32 (%struct.usb_hcd.588*, i32)** %find_raw_port_number, align 8, !tbaa !415
  %tobool = icmp ne i32 (%struct.usb_hcd.588*, i32)* %1, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %driver1 = getelementptr inbounds %struct.usb_hcd.588, %struct.usb_hcd.588* %hcd, i32 0, i32 8
  %2 = load %struct.hc_driver.589*, %struct.hc_driver.589** %driver1, align 8, !tbaa !71
  %find_raw_port_number2 = getelementptr inbounds %struct.hc_driver.589, %struct.hc_driver.589* %2, i32 0, i32 41
  %3 = load i32 (%struct.usb_hcd.588*, i32)*, i32 (%struct.usb_hcd.588*, i32)** %find_raw_port_number2, align 8, !tbaa !415
  %call = call i32 %3(%struct.usb_hcd.588* %hcd, i32 %port1)
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call, %if.end ], [ %port1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_anchor_empty(%struct.usb_anchor* %anchor) #0 {
entry:
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %call = call i32 @list_empty.141(%struct.list_head* %urb_list)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty.141(%struct.list_head* %head) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !95
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define void @usb_scuttle_anchored_urbs(%struct.usb_anchor* %anchor) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %lock = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %call = call %struct.raw_spinlock* @spinlock_check.142(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %call5 = call i32 @list_empty.141(%struct.list_head* %urb_list)
  %tobool = icmp ne i32 %call5, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %urb_list6 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %urb_list6, i32 0, i32 1
  %4 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !416
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 -48
  %6 = bitcast i8* %add.ptr to %struct.urb.824*
  call void @__usb_unanchor_urb(%struct.urb.824* %6, %struct.usb_anchor* %anchor)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %lock8 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  call void @spin_unlock_irqrestore.143(%struct.spinlock* %lock8, i64 %call2)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check.142(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

; Function Attrs: nounwind uwtable
define internal void @__usb_unanchor_urb(%struct.urb.824* %urb, %struct.usb_anchor* %anchor) #0 {
entry:
  %anchor1 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 7
  store %struct.usb_anchor* null, %struct.usb_anchor** %anchor1, align 8, !tbaa !418
  %anchor_list = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 6
  call void @list_del(%struct.list_head* %anchor_list)
  call void @usb_free_urb(%struct.urb.824* %urb)
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %call = call i32 @list_empty.141(%struct.list_head* %urb_list)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %wait = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 1
  call void @__wake_up(%struct.__wait_queue_head* %wait, i32 3, i32 1, i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore.143(%struct.spinlock* %lock, i64 %flags) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_free_urb(%struct.urb.824* %urb) #0 {
entry:
  %tobool = icmp ne %struct.urb.824* %urb, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %kref = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 0
  call void @kref_put.146(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* @urb_destroy)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @urb_destroy(%struct.arch_spinlock* %kref) #0 {
entry:
  %0 = bitcast %struct.arch_spinlock* %kref to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.urb.824*
  %transfer_flags = getelementptr inbounds %struct.urb.824, %struct.urb.824* %1, i32 0, i32 13
  %2 = load i32, i32* %transfer_flags, align 4, !tbaa !323
  %and = and i32 %2, 256
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %transfer_buffer = getelementptr inbounds %struct.urb.824, %struct.urb.824* %1, i32 0, i32 14
  %3 = load i8*, i8** %transfer_buffer, align 8, !tbaa !293
  call void @kfree(i8* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = bitcast %struct.urb.824* %1 to i8*
  call void @kfree(i8* %4)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put.146(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* %release) #1 {
entry:
  call void @kref_sub.147(%struct.arch_spinlock* %kref, i32 1, void (%struct.arch_spinlock*)* %release)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_sub.147(%struct.arch_spinlock* %kref, i32 %count, void (%struct.arch_spinlock*)* %release) #1 {
entry:
  %cmp = icmp eq void (%struct.arch_spinlock*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.10.486, i32 0, i32 0), i32 71)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_sub_and_test.149(i32 %count, %union.anon.5* %refcount)
  %tobool14 = icmp ne i32 %call, 0
  br i1 %tobool14, label %if.then15, label %return

if.then15:                                        ; preds = %if.end
  call void %release(%struct.arch_spinlock* %kref)
  br label %return

return:                                           ; preds = %if.then15, %if.end
  %retval.0 = phi i32 [ 1, %if.then15 ], [ 0, %if.end ]
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_sub_and_test.149(i32 %i, %union.anon.5* %v) #1 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subl $2,$0; sete $1", "=*m,=*qm,ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32 %i, i32* %counter) #8, !srcloc !419
  %0 = load i8, i8* %c, align 1, !tbaa !84
  %conv = zext i8 %0 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define %struct.urb.824* @usb_get_from_anchor(%struct.usb_anchor* %anchor) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %lock = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %call = call %struct.raw_spinlock* @spinlock_check.142(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %call5 = call i32 @list_empty.141(%struct.list_head* %urb_list)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %urb_list6 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %urb_list6, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !420
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 -48
  %6 = bitcast i8* %add.ptr to %struct.urb.824*
  %call8 = call %struct.urb.824* @usb_get_urb(%struct.urb.824* %6)
  call void @__usb_unanchor_urb(%struct.urb.824* %6, %struct.usb_anchor* %anchor)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %victim.0 = phi %struct.urb.824* [ %6, %if.then ], [ null, %entry ]
  %lock9 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  call void @spin_unlock_irqrestore.143(%struct.spinlock* %lock9, i64 %call2)
  ret %struct.urb.824* %victim.0
}

; Function Attrs: nounwind uwtable
define %struct.urb.824* @usb_get_urb(%struct.urb.824* %urb) #0 {
entry:
  %tobool = icmp ne %struct.urb.824* %urb, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %kref = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 0
  call void @kref_get.152(%struct.arch_spinlock* %kref)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.urb.824* %urb
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_get.152(%struct.arch_spinlock* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_add_return.153(i32 1, %union.anon.5* %refcount)
  %cmp = icmp slt i32 %call, 2
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  %0 = load i8, i8* @kref_get.__warned.154, align 1, !tbaa !43, !range !44
  %tobool7 = trunc i8 %0 to i1
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %tobool14 = icmp ne i32 %lnot.ext13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.10.486, i32 0, i32 0), i32 47)
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then
  %tobool23 = icmp ne i32 %lnot.ext13, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end
  store i8 1, i8* @kref_get.__warned.154, align 1, !tbaa !43
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_return.153(i32 %i, %union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #8, !srcloc !421
  %add = add nsw i32 %i, %0
  ret i32 %add
}

; Function Attrs: nounwind uwtable
define i32 @usb_wait_anchor_empty_timeout(%struct.usb_anchor* %anchor, i32 %timeout) #0 {
entry:
  %__wait = alloca %struct.__wait_queue, align 8
  %call = call i64 @msecs_to_jiffies(i32 %timeout)
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %call1 = call i32 @list_empty.141(%struct.list_head* %urb_list)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end20, label %do.body

do.body:                                          ; preds = %entry
  %0 = bitcast %struct.__wait_queue* %__wait to i8*
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !246
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 1
  %1 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !422
  %2 = bitcast %struct.task_struct* %1 to i8*
  store i8* %2, i8** %private, align 8, !tbaa !248
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @autoremove_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !249
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  %task_list3 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list3, %struct.list_head** %next, align 8, !tbaa !95
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  %task_list4 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list4, %struct.list_head** %prev, align 8, !tbaa !96
  br label %for.cond

for.cond:                                         ; preds = %if.end12, %do.body
  %__ret.0 = phi i64 [ %call, %do.body ], [ %call9, %if.end12 ]
  %wait = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 1
  call void @prepare_to_wait(%struct.__wait_queue_head* %wait, %struct.__wait_queue* %__wait, i32 2)
  %urb_list5 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %call6 = call i32 @list_empty.141(%struct.list_head* %urb_list5)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %for.end, label %if.end

if.end:                                           ; preds = %for.cond
  %call9 = call i64 @schedule_timeout(i64 %__ret.0)
  %tobool10 = icmp ne i64 %call9, 0
  br i1 %tobool10, label %if.end12, label %for.end

if.end12:                                         ; preds = %if.end
  br label %for.cond

for.end:                                          ; preds = %if.end, %for.cond
  %__ret.1 = phi i64 [ %__ret.0, %for.cond ], [ %call9, %if.end ]
  %tobool13 = icmp ne i64 %__ret.1, 0
  br i1 %tobool13, label %if.end18, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.end
  %urb_list14 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %call15 = call i32 @list_empty.141(%struct.list_head* %urb_list14)
  %tobool16 = icmp ne i32 %call15, 0
  %.__ret.1 = select i1 %tobool16, i64 1, i64 %__ret.1
  br label %if.end18

if.end18:                                         ; preds = %land.lhs.true, %for.end
  %__ret.2 = phi i64 [ %__ret.1, %for.end ], [ %.__ret.1, %land.lhs.true ]
  %wait19 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 1
  call void @finish_wait(%struct.__wait_queue_head* %wait19, %struct.__wait_queue* %__wait)
  %3 = bitcast %struct.__wait_queue* %__wait to i8*
  br label %if.end20

if.end20:                                         ; preds = %if.end18, %entry
  %__ret.3 = phi i64 [ %call, %entry ], [ %__ret.2, %if.end18 ]
  %conv = trunc i64 %__ret.3 to i32
  ret i32 %conv
}

declare i64 @schedule_timeout(i64) #2

; Function Attrs: nounwind uwtable
define void @usb_unlink_anchored_urbs(%struct.usb_anchor* %anchor) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call %struct.urb.824* @usb_get_from_anchor(%struct.usb_anchor* %anchor)
  %cmp = icmp ne %struct.urb.824* %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call1 = call i32 @usb_unlink_urb(%struct.urb.824* %call)
  call void @usb_free_urb(%struct.urb.824* %call)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_unlink_urb(%struct.urb.824* %urb) #0 {
entry:
  %tobool = icmp ne %struct.urb.824* %urb, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !210
  %tobool1 = icmp ne %struct.usb_device* %0, null
  br i1 %tobool1, label %if.end3, label %return

if.end3:                                          ; preds = %if.end
  %ep = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 9
  %1 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !218
  %tobool4 = icmp ne %struct.usb_host_endpoint* %1, null
  br i1 %tobool4, label %if.end6, label %return

if.end6:                                          ; preds = %if.end3
  %call = call i32 bitcast (i32 (%struct.urb*, i32)* @usb_hcd_unlink_urb to i32 (%struct.urb.824*, i32)*)(%struct.urb.824* %urb, i32 -104)
  br label %return

return:                                           ; preds = %if.end6, %if.end3, %if.end, %entry
  %retval.0 = phi i32 [ %call, %if.end6 ], [ -22, %entry ], [ -19, %if.end ], [ -43, %if.end3 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_unpoison_anchored_urbs(%struct.usb_anchor* %anchor) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %lock = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %call = call %struct.raw_spinlock* @spinlock_check.142(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %anchor_list10.sink = phi %struct.list_head* [ %anchor_list10, %for.body ], [ %urb_list, %entry ]
  %next11 = getelementptr inbounds %struct.list_head, %struct.list_head* %anchor_list10.sink, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next11, align 8, !tbaa !48
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr13 = getelementptr inbounds i8, i8* %5, i64 -48
  %6 = bitcast i8* %add.ptr13 to %struct.urb.824*
  %anchor_list = getelementptr inbounds %struct.urb.824, %struct.urb.824* %6, i32 0, i32 6
  %urb_list6 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %cmp7 = icmp ne %struct.list_head* %anchor_list, %urb_list6
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @usb_unpoison_urb(%struct.urb.824* %6)
  %anchor_list10 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %6, i32 0, i32 6
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %poisoned = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 3
  %bf.load = load i8, i8* %poisoned, align 8
  %bf.clear = and i8 %bf.load, -2
  store i8 %bf.clear, i8* %poisoned, align 8
  %lock14 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  call void @spin_unlock_irqrestore.143(%struct.spinlock* %lock14, i64 %call2)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_unpoison_urb(%struct.urb.824* %urb) #0 {
entry:
  %tobool = icmp ne %struct.urb.824* %urb, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %reject = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 3
  call void @atomic_dec.156(%union.anon.5* %reject)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_dec.156(%union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #8, !srcloc !423
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_poison_anchored_urbs(%struct.usb_anchor* %anchor) #0 {
entry:
  %lock = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  call void @spin_lock_irq.157(%struct.spinlock* %lock)
  %poisoned = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 3
  %bf.load = load i8, i8* %poisoned, align 8
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %poisoned, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %call = call i32 @list_empty.141(%struct.list_head* %urb_list)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %urb_list1 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %urb_list1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !416
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -48
  %2 = bitcast i8* %add.ptr to %struct.urb.824*
  %call2 = call %struct.urb.824* @usb_get_urb(%struct.urb.824* %2)
  %lock3 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  call void @spin_unlock_irq.158(%struct.spinlock* %lock3)
  call void @usb_poison_urb(%struct.urb.824* %2)
  call void @usb_free_urb(%struct.urb.824* %2)
  %lock4 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  call void @spin_lock_irq.157(%struct.spinlock* %lock4)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %lock5 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  call void @spin_unlock_irq.158(%struct.spinlock* %lock5)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_irq.157(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irq.158(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_poison_urb(%struct.urb.824* %urb) #0 {
entry:
  %__wait = alloca %struct.__wait_queue, align 8
  call void @__might_sleep(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1.159, i32 0, i32 0), i32 685, i32 0)
  %tobool = icmp ne %struct.urb.824* %urb, null
  br i1 %tobool, label %if.end, label %do.end21

if.end:                                           ; preds = %entry
  %reject = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 3
  call void @atomic_inc.160(%union.anon.5* %reject)
  %dev = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !210
  %tobool3 = icmp ne %struct.usb_device* %0, null
  br i1 %tobool3, label %lor.lhs.false, label %do.end21

lor.lhs.false:                                    ; preds = %if.end
  %ep = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 9
  %1 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !218
  %tobool4 = icmp ne %struct.usb_host_endpoint* %1, null
  br i1 %tobool4, label %if.end6, label %do.end21

if.end6:                                          ; preds = %lor.lhs.false
  %call = call i32 bitcast (i32 (%struct.urb*, i32)* @usb_hcd_unlink_urb to i32 (%struct.urb.824*, i32)*)(%struct.urb.824* %urb, i32 -2)
  %use_count = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 2
  %call8 = call i32 @atomic_read.161(%union.anon.5* %use_count)
  %cmp = icmp eq i32 %call8, 0
  br i1 %cmp, label %do.end21, label %do.body11

do.body11:                                        ; preds = %if.end6
  %2 = bitcast %struct.__wait_queue* %__wait to i8*
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !246
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 1
  %3 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !422
  %4 = bitcast %struct.task_struct* %3 to i8*
  store i8* %4, i8** %private, align 8, !tbaa !248
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @autoremove_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !249
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  %task_list13 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list13, %struct.list_head** %next, align 8, !tbaa !95
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  %task_list14 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list14, %struct.list_head** %prev, align 8, !tbaa !96
  br label %for.cond

for.cond:                                         ; preds = %if.end19, %do.body11
  call void @prepare_to_wait(%struct.__wait_queue_head* @usb_kill_urb_queue, %struct.__wait_queue* %__wait, i32 2)
  %use_count15 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 2
  %call16 = call i32 @atomic_read.161(%union.anon.5* %use_count15)
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %for.end, label %if.end19

if.end19:                                         ; preds = %for.cond
  call void @schedule()
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @finish_wait(%struct.__wait_queue_head* @usb_kill_urb_queue, %struct.__wait_queue* %__wait)
  %5 = bitcast %struct.__wait_queue* %__wait to i8*
  br label %do.end21

do.end21:                                         ; preds = %for.end, %if.end6, %lor.lhs.false, %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.160(%union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #8, !srcloc !424
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read.161(%union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !90
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define void @usb_kill_anchored_urbs(%struct.usb_anchor* %anchor) #0 {
entry:
  %lock = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  call void @spin_lock_irq.157(%struct.spinlock* %lock)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %call = call i32 @list_empty.141(%struct.list_head* %urb_list)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %urb_list1 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %urb_list1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !416
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -48
  %2 = bitcast i8* %add.ptr to %struct.urb.824*
  %call2 = call %struct.urb.824* @usb_get_urb(%struct.urb.824* %2)
  %lock3 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  call void @spin_unlock_irq.158(%struct.spinlock* %lock3)
  call void @usb_kill_urb(%struct.urb.824* %2)
  call void @usb_free_urb(%struct.urb.824* %2)
  %lock4 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  call void @spin_lock_irq.157(%struct.spinlock* %lock4)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %lock5 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  call void @spin_unlock_irq.158(%struct.spinlock* %lock5)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_kill_urb(%struct.urb.824* %urb) #0 {
entry:
  %__wait = alloca %struct.__wait_queue, align 8
  call void @__might_sleep(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1.159, i32 0, i32 0), i32 644, i32 0)
  %tobool = icmp ne %struct.urb.824* %urb, null
  br i1 %tobool, label %land.lhs.true, label %return

land.lhs.true:                                    ; preds = %entry
  %dev = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !210
  %tobool3 = icmp ne %struct.usb_device* %0, null
  br i1 %tobool3, label %land.lhs.true4, label %return

land.lhs.true4:                                   ; preds = %land.lhs.true
  %ep = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 9
  %1 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !218
  %tobool5 = icmp ne %struct.usb_host_endpoint* %1, null
  br i1 %tobool5, label %if.end, label %return

if.end:                                           ; preds = %land.lhs.true4
  %reject = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 3
  call void @atomic_inc.160(%union.anon.5* %reject)
  %call = call i32 bitcast (i32 (%struct.urb*, i32)* @usb_hcd_unlink_urb to i32 (%struct.urb.824*, i32)*)(%struct.urb.824* %urb, i32 -2)
  %use_count = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 2
  %call7 = call i32 @atomic_read.161(%union.anon.5* %use_count)
  %cmp = icmp eq i32 %call7, 0
  br i1 %cmp, label %do.end20, label %do.body10

do.body10:                                        ; preds = %if.end
  %2 = bitcast %struct.__wait_queue* %__wait to i8*
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !246
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 1
  %3 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !422
  %4 = bitcast %struct.task_struct* %3 to i8*
  store i8* %4, i8** %private, align 8, !tbaa !248
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @autoremove_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !249
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  %task_list12 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list12, %struct.list_head** %next, align 8, !tbaa !95
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  %task_list13 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list13, %struct.list_head** %prev, align 8, !tbaa !96
  br label %for.cond

for.cond:                                         ; preds = %if.end18, %do.body10
  call void @prepare_to_wait(%struct.__wait_queue_head* @usb_kill_urb_queue, %struct.__wait_queue* %__wait, i32 2)
  %use_count14 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 2
  %call15 = call i32 @atomic_read.161(%union.anon.5* %use_count14)
  %cmp16 = icmp eq i32 %call15, 0
  br i1 %cmp16, label %for.end, label %if.end18

if.end18:                                         ; preds = %for.cond
  call void @schedule()
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @finish_wait(%struct.__wait_queue_head* @usb_kill_urb_queue, %struct.__wait_queue* %__wait)
  %5 = bitcast %struct.__wait_queue* %__wait to i8*
  br label %do.end20

do.end20:                                         ; preds = %for.end, %if.end
  %reject21 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 3
  call void @atomic_dec.156(%union.anon.5* %reject21)
  br label %return

return:                                           ; preds = %do.end20, %land.lhs.true4, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_block_urb(%struct.urb.824* %urb) #0 {
entry:
  %tobool = icmp ne %struct.urb.824* %urb, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %reject = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 3
  call void @atomic_inc.160(%union.anon.5* %reject)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_submit_urb(%struct.urb.824* %urb, i32 %mem_flags) #0 {
entry:
  %_min1 = alloca i32, align 4
  %_min2 = alloca i32, align 4
  %tobool = icmp ne %struct.urb.824* %urb, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup306

lor.lhs.false:                                    ; preds = %entry
  %complete = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 28
  %complete1 = bitcast {}** %complete to void (%struct.urb.824*)**
  %0 = load void (%struct.urb.824*)*, void (%struct.urb.824*)** %complete1, align 8, !tbaa !295
  %tobool2 = icmp ne void (%struct.urb.824*)* %0, null
  br i1 %tobool2, label %if.end, label %cleanup306

if.end:                                           ; preds = %lor.lhs.false
  %hcpriv = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 1
  %1 = load i8*, i8** %hcpriv, align 8, !tbaa !321
  %tobool3 = icmp ne i8* %1, null
  br i1 %tobool3, label %if.then4, label %if.end45

if.then4:                                         ; preds = %if.end
  %tobool5 = icmp ne i32 1, 0
  %lnot = xor i1 %tobool5, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then8, label %if.end36

if.then8:                                         ; preds = %if.then4
  %2 = load i8, i8* @usb_submit_urb.__warned, align 1, !tbaa !43, !range !44
  %tobool9 = trunc i8 %2 to i1
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %tobool16 = icmp ne i32 %lnot.ext15, 0
  %lnot17 = xor i1 %tobool16, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool23 = icmp ne i64 %expval22, 0
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.then8
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1.159, i32 0, i32 0), i32 327, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.2.166, i32 0, i32 0), %struct.urb.824* %urb)
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %if.then8
  %tobool26 = icmp ne i32 %lnot.ext15, 0
  %lnot27 = xor i1 %tobool26, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end25
  store i8 1, i8* @usb_submit_urb.__warned, align 1, !tbaa !43
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.end25, %if.then4
  br label %cleanup306

if.end45:                                         ; preds = %if.end
  %dev46 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 8
  %3 = load %struct.usb_device*, %struct.usb_device** %dev46, align 8, !tbaa !210
  %tobool47 = icmp ne %struct.usb_device* %3, null
  br i1 %tobool47, label %lor.lhs.false48, label %cleanup306

lor.lhs.false48:                                  ; preds = %if.end45
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 3
  %4 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp ult i32 %4, 4
  br i1 %cmp, label %cleanup306, label %if.end51

if.end51:                                         ; preds = %lor.lhs.false48
  %pipe = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 10
  %5 = load i32, i32* %pipe, align 8, !tbaa !212
  %call = call %struct.usb_host_endpoint* @usb_pipe_endpoint(%struct.usb_device* %3, i32 %5)
  %tobool52 = icmp ne %struct.usb_host_endpoint* %call, null
  br i1 %tobool52, label %if.end54, label %cleanup306

if.end54:                                         ; preds = %if.end51
  %ep55 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 9
  store %struct.usb_host_endpoint* %call, %struct.usb_host_endpoint** %ep55, align 8, !tbaa !218
  %status = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 12
  store i32 -115, i32* %status, align 8, !tbaa !291
  %actual_length = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 20
  store i32 0, i32* %actual_length, align 4, !tbaa !292
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 0
  %call56 = call i32 @usb_endpoint_type.167(%struct.usb_endpoint_descriptor* %desc)
  %cmp57 = icmp eq i32 %call56, 0
  br i1 %cmp57, label %if.then59, label %if.else

if.then59:                                        ; preds = %if.end54
  %setup_packet = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 21
  %6 = load i8*, i8** %setup_packet, align 8, !tbaa !371
  %7 = bitcast i8* %6 to %struct.usb_ctrlrequest*
  %tobool60 = icmp ne %struct.usb_ctrlrequest* %7, null
  br i1 %tobool60, label %if.end62, label %LeafBlock

if.end62:                                         ; preds = %if.then59
  %bRequestType = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %7, i32 0, i32 0
  %8 = load i8, i8* %bRequestType, align 1, !tbaa !394
  %conv63 = zext i8 %8 to i32
  %and = and i32 %conv63, 128
  %tobool64 = icmp ne i32 %and, 0
  br i1 %tobool64, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.end62
  %wLength = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %7, i32 0, i32 4
  %9 = load i16, i16* %wLength, align 1, !tbaa !399
  %tobool65 = icmp ne i16 %9, 0
  %lnot66 = xor i1 %tobool65, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end62
  %10 = phi i1 [ true, %if.end62 ], [ %lnot66, %lor.rhs ]
  %lor.ext = zext i1 %10 to i32
  br label %LeafBlock

LeafBlock:                                        ; preds = %lor.end, %if.then59
  %is_out.0 = phi i32 [ %lor.ext, %lor.end ], [ undef, %if.then59 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %lor.end ], [ 1, %if.then59 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end70, label %cleanup306

if.else:                                          ; preds = %if.end54
  %desc68 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 0
  %call69 = call i32 @usb_endpoint_dir_out.168(%struct.usb_endpoint_descriptor* %desc68)
  br label %if.end70

if.end70:                                         ; preds = %if.else, %LeafBlock
  %is_out.1 = phi i32 [ %call69, %if.else ], [ %is_out.0, %LeafBlock ]
  %transfer_flags = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 13
  %11 = load i32, i32* %transfer_flags, align 4, !tbaa !323
  %and71 = and i32 %11, -8323585
  store i32 %and71, i32* %transfer_flags, align 4, !tbaa !323
  %tobool72 = icmp ne i32 %is_out.1, 0
  %cond = select i1 %tobool72, i32 0, i32 512
  %transfer_flags73 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 13
  %12 = load i32, i32* %transfer_flags73, align 4, !tbaa !323
  %or = or i32 %12, %cond
  store i32 %or, i32* %transfer_flags73, align 4, !tbaa !323
  %cmp74 = icmp ne i32 %call56, 0
  br i1 %cmp74, label %land.lhs.true, label %if.end80

land.lhs.true:                                    ; preds = %if.end70
  %state76 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 3
  %13 = load i32, i32* %state76, align 8, !tbaa !50
  %cmp77 = icmp ult i32 %13, 7
  br i1 %cmp77, label %cleanup306, label %if.end80

if.end80:                                         ; preds = %land.lhs.true, %if.end70
  %desc81 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 0
  %call82 = call i32 @usb_endpoint_maxp.169(%struct.usb_endpoint_descriptor* %desc81)
  %cmp83 = icmp sle i32 %call82, 0
  br i1 %cmp83, label %do.body86, label %if.end106

do.body86:                                        ; preds = %if.end80
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_submit_urb.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and87 = and i32 %bf.clear, 1
  %tobool88 = icmp ne i32 %and87, 0
  %lnot89 = xor i1 %tobool88, true
  %lnot91 = xor i1 %lnot89, true
  %lnot.ext92 = zext i1 %lnot91 to i32
  %conv93 = sext i32 %lnot.ext92 to i64
  %expval94 = call i64 @llvm.expect.i64(i64 %conv93, i64 0)
  %tobool95 = icmp ne i64 %expval94, 0
  br i1 %tobool95, label %if.then96, label %cleanup306

if.then96:                                        ; preds = %do.body86
  %dev97 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 11
  %desc98 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 0
  %call99 = call i32 @usb_endpoint_num.170(%struct.usb_endpoint_descriptor* %desc98)
  %tobool100 = icmp ne i32 %is_out.1, 0
  %cond101 = select i1 %tobool100, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.44.736, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.45.737, i32 0, i32 0)
  %call102 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_submit_urb.descriptor to %struct._ddebug*), %struct.device* %dev97, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.4.173, i32 0, i32 0), i32 %call99, i8* %cond101, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.usb_submit_urb, i32 0, i32 0), i32 %call82)
  br label %cleanup306

if.end106:                                        ; preds = %if.end80
  %cmp107 = icmp eq i32 %call56, 1
  br i1 %cmp107, label %if.then109, label %if.end156

if.then109:                                       ; preds = %if.end106
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 4
  %14 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp110 = icmp eq i32 %14, 5
  br i1 %cmp110, label %if.then112, label %if.end119

if.then112:                                       ; preds = %if.then109
  %ss_ep_comp = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 1
  %bMaxBurst = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp, i32 0, i32 2
  %15 = load i8, i8* %bMaxBurst, align 1, !tbaa !425
  %conv113 = zext i8 %15 to i32
  %add = add nsw i32 1, %conv113
  %ss_ep_comp114 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 1
  %bmAttributes = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp114, i32 0, i32 3
  %16 = load i8, i8* %bmAttributes, align 1, !tbaa !426
  %conv115 = zext i8 %16 to i32
  %and116 = and i32 %conv115, 3
  %add117 = add nsw i32 1, %and116
  %mul = mul nsw i32 %call82, %add
  %mul118 = mul nsw i32 %mul, %add117
  br label %if.end119

if.end119:                                        ; preds = %if.then112, %if.then109
  %max.0 = phi i32 [ %mul118, %if.then112 ], [ %call82, %if.then109 ]
  %speed120 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 4
  %17 = load i32, i32* %speed120, align 4, !tbaa !153
  %cmp121 = icmp eq i32 %17, 3
  br i1 %cmp121, label %if.then123, label %if.end129

if.then123:                                       ; preds = %if.end119
  %shr = ashr i32 %max.0, 11
  %and125 = and i32 %shr, 3
  %add126 = add nsw i32 1, %and125
  %and127 = and i32 %max.0, 2047
  %mul128 = mul nsw i32 %and127, %add126
  br label %if.end129

if.end129:                                        ; preds = %if.then123, %if.end119
  %max.1 = phi i32 [ %mul128, %if.then123 ], [ %max.0, %if.end119 ]
  %number_of_packets = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 24
  %18 = load i32, i32* %number_of_packets, align 4, !tbaa !427
  %cmp130 = icmp sle i32 %18, 0
  br i1 %cmp130, label %LeafBlock2, label %if.end133

if.end133:                                        ; preds = %if.end129
  br label %for.cond

for.cond:                                         ; preds = %if.end143, %if.end133
  %n.0 = phi i32 [ 0, %if.end133 ], [ %inc, %if.end143 ]
  %number_of_packets134 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 24
  %19 = load i32, i32* %number_of_packets134, align 4, !tbaa !427
  %cmp135 = icmp slt i32 %n.0, %19
  br i1 %cmp135, label %for.body, label %LeafBlock2

for.body:                                         ; preds = %for.cond
  %iso_frame_desc = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 29
  %idxprom = sext i32 %n.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb3_lpm_parameters], [0 x %struct.usb3_lpm_parameters]* %iso_frame_desc, i64 0, i64 %idxprom
  %length = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %arrayidx, i32 0, i32 1
  %20 = load i32, i32* %length, align 4, !tbaa !428
  %cmp137 = icmp slt i32 %20, 0
  %cmp140 = icmp sgt i32 %20, %max.1
  %or.cond = or i1 %cmp137, %cmp140
  br i1 %or.cond, label %LeafBlock2, label %if.end143

if.end143:                                        ; preds = %for.body
  %iso_frame_desc144 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 29
  %idxprom145 = sext i32 %n.0 to i64
  %arrayidx146 = getelementptr inbounds [0 x %struct.usb3_lpm_parameters], [0 x %struct.usb3_lpm_parameters]* %iso_frame_desc144, i64 0, i64 %idxprom145
  %status147 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %arrayidx146, i32 0, i32 3
  store i32 -18, i32* %status147, align 4, !tbaa !430
  %iso_frame_desc148 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 29
  %idxprom149 = sext i32 %n.0 to i64
  %arrayidx150 = getelementptr inbounds [0 x %struct.usb3_lpm_parameters], [0 x %struct.usb3_lpm_parameters]* %iso_frame_desc148, i64 0, i64 %idxprom149
  %actual_length151 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %arrayidx150, i32 0, i32 2
  store i32 0, i32* %actual_length151, align 8, !tbaa !431
  %inc = add nsw i32 %n.0, 1
  br label %for.cond

LeafBlock2:                                       ; preds = %for.body, %for.cond, %if.end129
  %cleanup.dest.slot.1 = phi i32 [ 1, %if.end129 ], [ 1, %for.body ], [ 0, %for.cond ]
  %retval.2 = phi i32 [ -22, %if.end129 ], [ -90, %for.body ], [ -8, %for.cond ]
  %SwitchLeaf3 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf3, label %if.end156, label %cleanup306

if.end156:                                        ; preds = %LeafBlock2, %if.end106
  %max.2 = phi i32 [ %call82, %if.end106 ], [ %max.1, %LeafBlock2 ]
  %transfer_buffer_length = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 19
  %21 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !294
  %cmp157 = icmp ugt i32 %21, 2147483647
  br i1 %cmp157, label %cleanup306, label %if.end160

if.end160:                                        ; preds = %if.end156
  %pipe161 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 10
  %22 = load i32, i32* %pipe161, align 8, !tbaa !212
  %shr162 = lshr i32 %22, 30
  %and163 = and i32 %shr162, 3
  %idxprom164 = sext i32 %call56 to i64
  %arrayidx165 = getelementptr inbounds [4 x i32], [4 x i32]* @usb_submit_urb.pipetypes, i64 0, i64 %idxprom164
  %23 = load i32, i32* %arrayidx165, align 4, !tbaa !90
  %cmp166 = icmp ne i32 %and163, %23
  br i1 %cmp166, label %if.then168, label %NodeBlock9

if.then168:                                       ; preds = %if.end160
  %tobool170 = icmp ne i32 1, 0
  %lnot171 = xor i1 %tobool170, true
  %lnot173 = xor i1 %lnot171, true
  %lnot.ext174 = zext i1 %lnot173 to i32
  %conv175 = sext i32 %lnot.ext174 to i64
  %expval176 = call i64 @llvm.expect.i64(i64 %conv175, i64 0)
  %tobool177 = icmp ne i64 %expval176, 0
  br i1 %tobool177, label %if.then178, label %if.end186

if.then178:                                       ; preds = %if.then168
  %dev179 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 11
  %call180 = call i8* @dev_driver_string(%struct.device* %dev179)
  %pipe181 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 10
  %24 = load i32, i32* %pipe181, align 8, !tbaa !212
  %shr182 = lshr i32 %24, 30
  %and183 = and i32 %shr182, 3
  %idxprom184 = sext i32 %call56 to i64
  %arrayidx185 = getelementptr inbounds [4 x i32], [4 x i32]* @usb_submit_urb.pipetypes, i64 0, i64 %idxprom184
  %25 = load i32, i32* %arrayidx185, align 4, !tbaa !90
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1.159, i32 0, i32 0), i32 435, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.7.174, i32 0, i32 0), i8* %call180, i32 %and183, i32 %25)
  br label %if.end186

if.end186:                                        ; preds = %if.then178, %if.then168
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %if.end186, %if.end160
  %Pivot10 = icmp slt i32 %call56, 1
  br i1 %Pivot10, label %LeafBlock5, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %call56, 2
  br i1 %Pivot, label %sw.bb206, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock
  %SwitchLeaf8 = icmp eq i32 %call56, 2
  br i1 %SwitchLeaf8, label %sw.bb, label %sw.default

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %call56, 0
  br i1 %SwitchLeaf6, label %sw.bb200, label %sw.default

sw.bb:                                            ; preds = %LeafBlock7
  %tobool196 = icmp ne i32 %is_out.1, 0
  %or198 = or i32 900, 64
  %or198. = select i1 %tobool196, i32 %or198, i32 900
  br label %sw.bb200

sw.bb200:                                         ; preds = %sw.bb, %LeafBlock5
  %allowed.1 = phi i32 [ 900, %LeafBlock5 ], [ %or198., %sw.bb ]
  %or201 = or i32 %allowed.1, 32
  br label %sw.default

sw.default:                                       ; preds = %sw.bb200, %LeafBlock5, %LeafBlock7
  %allowed.2 = phi i32 [ %or201, %sw.bb200 ], [ 900, %LeafBlock7 ], [ 900, %LeafBlock5 ]
  %tobool202 = icmp ne i32 %is_out.1, 0
  %or204 = or i32 %allowed.2, 1
  %allowed.2.or204 = select i1 %tobool202, i32 %allowed.2, i32 %or204
  br label %sw.epilog

sw.bb206:                                         ; preds = %NodeBlock
  %or207 = or i32 900, 2
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb206, %sw.default
  %allowed.4 = phi i32 [ %allowed.2.or204, %sw.default ], [ %or207, %sw.bb206 ]
  %transfer_flags208 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 13
  %26 = load i32, i32* %transfer_flags208, align 4, !tbaa !323
  %and209 = and i32 %allowed.4, %26
  %transfer_flags210 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 13
  %27 = load i32, i32* %transfer_flags210, align 4, !tbaa !323
  %cmp211 = icmp ne i32 %and209, %27
  br i1 %cmp211, label %if.then213, label %NodeBlock16

if.then213:                                       ; preds = %sw.epilog
  %tobool215 = icmp ne i32 1, 0
  %lnot216 = xor i1 %tobool215, true
  %lnot218 = xor i1 %lnot216, true
  %lnot.ext219 = zext i1 %lnot218 to i32
  %conv220 = sext i32 %lnot.ext219 to i64
  %expval221 = call i64 @llvm.expect.i64(i64 %conv220, i64 0)
  %tobool222 = icmp ne i64 %expval221, 0
  br i1 %tobool222, label %if.then223, label %if.end227

if.then223:                                       ; preds = %if.then213
  %dev224 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 11
  %call225 = call i8* @dev_driver_string(%struct.device* %dev224)
  %transfer_flags226 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 13
  %28 = load i32, i32* %transfer_flags226, align 4, !tbaa !323
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1.159, i32 0, i32 0), i32 461, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.8.175, i32 0, i32 0), i8* %call225, i32 %28, i32 %and209)
  br label %if.end227

if.end227:                                        ; preds = %if.then223, %if.then213
  br label %NodeBlock16

NodeBlock16:                                      ; preds = %if.end227, %sw.epilog
  %Pivot17 = icmp slt i32 %call56, 3
  br i1 %Pivot17, label %LeafBlock12, label %LeafBlock14

LeafBlock14:                                      ; preds = %NodeBlock16
  %SwitchLeaf15 = icmp eq i32 %call56, 3
  br i1 %SwitchLeaf15, label %sw.bb237, label %sw.epilog304

LeafBlock12:                                      ; preds = %NodeBlock16
  %SwitchLeaf13 = icmp eq i32 %call56, 1
  br i1 %SwitchLeaf13, label %sw.bb237, label %sw.epilog304

sw.bb237:                                         ; preds = %LeafBlock12, %LeafBlock14
  %speed238 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 4
  %29 = load i32, i32* %speed238, align 4, !tbaa !153
  %SwitchLeaf20 = icmp eq i32 %29, 4
  %interval = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 25
  %30 = load i32, i32* %interval, align 8, !tbaa !296
  br i1 %SwitchLeaf20, label %sw.bb239, label %sw.default244

sw.bb239:                                         ; preds = %sw.bb237
  %cmp240 = icmp slt i32 %30, 6
  br i1 %cmp240, label %cleanup306, label %sw.epilog250

sw.default244:                                    ; preds = %sw.bb237
  %cmp246 = icmp sle i32 %30, 0
  br i1 %cmp246, label %cleanup306, label %sw.epilog250

sw.epilog250:                                     ; preds = %sw.default244, %sw.bb239
  %speed251 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 4
  %31 = load i32, i32* %speed251, align 4, !tbaa !153
  %Pivot31 = icmp slt i32 %31, 4
  br i1 %Pivot31, label %NodeBlock24, label %NodeBlock28

NodeBlock28:                                      ; preds = %sw.epilog250
  %Pivot29 = icmp slt i32 %31, 5
  br i1 %Pivot29, label %sw.bb258, label %LeafBlock26

LeafBlock26:                                      ; preds = %NodeBlock28
  %SwitchLeaf27 = icmp eq i32 %31, 5
  br i1 %SwitchLeaf27, label %sw.bb252, label %cleanup306

NodeBlock24:                                      ; preds = %sw.epilog250
  %Pivot25 = icmp slt i32 %31, 3
  br i1 %Pivot25, label %LeafBlock22, label %sw.bb264

LeafBlock22:                                      ; preds = %NodeBlock24
  %.off = add i32 %31, -1
  %SwitchLeaf23 = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf23, label %sw.bb271, label %cleanup306

sw.bb252:                                         ; preds = %LeafBlock26
  %interval253 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 25
  %32 = load i32, i32* %interval253, align 8, !tbaa !296
  %cmp254 = icmp sgt i32 %32, 32768
  br i1 %cmp254, label %cleanup306, label %sw.epilog289

sw.bb258:                                         ; preds = %NodeBlock28
  %interval259 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 25
  %33 = load i32, i32* %interval259, align 8, !tbaa !296
  %cmp260 = icmp sgt i32 %33, 16
  br i1 %cmp260, label %cleanup306, label %sw.epilog289

sw.bb264:                                         ; preds = %NodeBlock24
  %interval265 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 25
  %34 = load i32, i32* %interval265, align 8, !tbaa !296
  %cmp266 = icmp sgt i32 %34, 8192
  br i1 %cmp266, label %if.then268, label %sw.epilog289

if.then268:                                       ; preds = %sw.bb264
  %interval269 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 25
  store i32 8192, i32* %interval269, align 8, !tbaa !296
  br label %sw.epilog289

sw.bb271:                                         ; preds = %LeafBlock22
  %cmp272 = icmp eq i32 %call56, 3
  %interval275 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 25
  %35 = load i32, i32* %interval275, align 8, !tbaa !296
  br i1 %cmp272, label %if.then274, label %if.else280

if.then274:                                       ; preds = %sw.bb271
  %cmp276 = icmp sgt i32 %35, 255
  br i1 %cmp276, label %cleanup306, label %sw.epilog289

if.else280:                                       ; preds = %sw.bb271
  %cmp282 = icmp sgt i32 %35, 1024
  br i1 %cmp282, label %if.then284, label %sw.epilog289

if.then284:                                       ; preds = %if.else280
  %interval285 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 25
  store i32 1024, i32* %interval285, align 8, !tbaa !296
  br label %sw.epilog289

sw.epilog289:                                     ; preds = %if.then284, %if.else280, %if.then274, %if.then268, %sw.bb264, %sw.bb258, %sw.bb252
  %max.4 = phi i32 [ 32768, %sw.bb252 ], [ %max.2, %sw.bb258 ], [ 8192, %if.then268 ], [ 8192, %sw.bb264 ], [ 128, %if.then274 ], [ 1024, %if.then284 ], [ 1024, %if.else280 ]
  %speed290 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 4
  %36 = load i32, i32* %speed290, align 4, !tbaa !153
  %cmp291 = icmp ne i32 %36, 4
  br i1 %cmp291, label %if.then293, label %sw.epilog304

if.then293:                                       ; preds = %sw.epilog289
  %37 = bitcast i32* %_min1 to i8*
  store i32 %max.4, i32* %_min1, align 4, !tbaa !90
  %38 = bitcast i32* %_min2 to i8*
  %interval294 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 25
  %39 = load i32, i32* %interval294, align 8, !tbaa !296
  %call295 = call i32 @__ilog2_u32(i32 %39) #4
  %shl = shl i32 1, %call295
  store i32 %shl, i32* %_min2, align 4, !tbaa !90
  %40 = load i32, i32* %_min1, align 4, !tbaa !90
  %41 = load i32, i32* %_min2, align 4, !tbaa !90
  %cmp299 = icmp slt i32 %40, %41
  %42 = load i32, i32* %_min1, align 4
  %43 = load i32, i32* %_min2, align 4
  %cond301 = select i1 %cmp299, i32 %42, i32 %43
  %44 = bitcast i32* %_min2 to i8*
  %45 = bitcast i32* %_min1 to i8*
  %interval302 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 25
  store i32 %cond301, i32* %interval302, align 8, !tbaa !296
  br label %sw.epilog304

sw.epilog304:                                     ; preds = %if.then293, %sw.epilog289, %LeafBlock12, %LeafBlock14
  %call305 = call i32 bitcast (i32 (%struct.urb*, i32)* @usb_hcd_submit_urb to i32 (%struct.urb.824*, i32)*)(%struct.urb.824* %urb, i32 %mem_flags)
  br label %cleanup306

cleanup306:                                       ; preds = %sw.epilog304, %if.then274, %sw.bb258, %sw.bb252, %LeafBlock22, %LeafBlock26, %sw.default244, %sw.bb239, %if.end156, %LeafBlock2, %if.then96, %do.body86, %land.lhs.true, %LeafBlock, %if.end51, %lor.lhs.false48, %if.end45, %if.end36, %lor.lhs.false, %entry
  %retval.3 = phi i32 [ -16, %if.end36 ], [ %call305, %sw.epilog304 ], [ -22, %lor.lhs.false ], [ -22, %entry ], [ -19, %lor.lhs.false48 ], [ -19, %if.end45 ], [ -2, %if.end51 ], [ -19, %land.lhs.true ], [ -90, %if.then96 ], [ -90, %do.body86 ], [ -90, %if.end156 ], [ -22, %sw.bb239 ], [ -22, %sw.default244 ], [ -22, %sw.bb252 ], [ -22, %sw.bb258 ], [ -22, %if.then274 ], [ -22, %LeafBlock22 ], [ -22, %LeafBlock26 ], [ -8, %LeafBlock ], [ %retval.2, %LeafBlock2 ]
  ret i32 %retval.3
}

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_host_endpoint* @usb_pipe_endpoint(%struct.usb_device* %dev, i32 %pipe) #1 {
entry:
  %and = and i32 %pipe, 128
  %tobool = icmp ne i32 %and, 0
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 17
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 16
  %ep_out.sink = select i1 %tobool, [16 x %struct.usb_host_endpoint*]* %ep_in, [16 x %struct.usb_host_endpoint*]* %ep_out
  %arraydecay1 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out.sink, i32 0, i32 0
  %shr = lshr i32 %pipe, 15
  %and2 = and i32 %shr, 15
  %idxprom = zext i32 %and2 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arraydecay1, i64 %idxprom
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8, !tbaa !48
  ret %struct.usb_host_endpoint* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_type.167(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_dir_out.168(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !286
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 128
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_maxp.169(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 4
  %0 = load i16, i16* %wMaxPacketSize, align 1, !tbaa !199
  %conv = zext i16 %0 to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_num.170(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !286
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  ret i32 %and
}

declare i8* @dev_driver_string(%struct.device*) #2

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__ilog2_u32(i32 %n) #6 {
entry:
  %call = call i32 @fls(i32 %n)
  %sub = sub nsw i32 %call, 1
  ret i32 %sub
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @fls(i32 %x) #1 {
entry:
  %0 = call i32 asm "bsrl $1,$0", "=r,rm,0,~{dirflag},~{fpsr},~{flags}"(i32 %x, i32 -1) #9, !srcloc !432
  %add = add nsw i32 %0, 1
  ret i32 %add
}

; Function Attrs: nounwind uwtable
define void @usb_unanchor_urb(%struct.urb.824* %urb) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tobool = icmp ne %struct.urb.824* %urb, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %anchor1 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 7
  %0 = load %struct.usb_anchor*, %struct.usb_anchor** %anchor1, align 8, !tbaa !418
  %tobool2 = icmp ne %struct.usb_anchor* %0, null
  br i1 %tobool2, label %do.body5, label %cleanup.cont

do.body5:                                         ; preds = %if.end
  %1 = bitcast i64* %__dummy to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy2 to i8*
  %4 = bitcast i64* %__dummy to i8*
  %lock = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %0, i32 0, i32 2
  %call = call %struct.raw_spinlock* @spinlock_check.142(%struct.spinlock* %lock)
  %call6 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %anchor9 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 7
  %5 = load %struct.usb_anchor*, %struct.usb_anchor** %anchor9, align 8, !tbaa !418
  %cmp10 = icmp eq %struct.usb_anchor* %0, %5
  %lnot = xor i1 %cmp10, true
  %lnot12 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot12 to i32
  %conv13 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv13, i64 1)
  %tobool14 = icmp ne i64 %expval, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %do.body5
  call void @__usb_unanchor_urb(%struct.urb.824* %urb, %struct.usb_anchor* %0)
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %do.body5
  %lock17 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %0, i32 0, i32 2
  call void @spin_unlock_irqrestore.143(%struct.spinlock* %lock17, i64 %call6)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end16, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_anchor_urb(%struct.urb.824* %urb, %struct.usb_anchor* %anchor) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %lock = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  %call = call %struct.raw_spinlock* @spinlock_check.142(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %call5 = call %struct.urb.824* @usb_get_urb(%struct.urb.824* %urb)
  %anchor_list = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 6
  %urb_list = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 0
  call void @list_add_tail.179(%struct.list_head* %anchor_list, %struct.list_head* %urb_list)
  %anchor6 = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 7
  store %struct.usb_anchor* %anchor, %struct.usb_anchor** %anchor6, align 8, !tbaa !418
  %poisoned = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 3
  %bf.load = load i8, i8* %poisoned, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  %lnot = xor i1 %tobool, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv8 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %reject = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 3
  call void @atomic_inc.160(%union.anon.5* %reject)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %lock10 = getelementptr inbounds %struct.usb_anchor, %struct.usb_anchor* %anchor, i32 0, i32 2
  call void @spin_unlock_irqrestore.143(%struct.spinlock* %lock10, i64 %call2)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.179(%struct.list_head* %new, %struct.list_head* %head) #1 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !96
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.urb.824* @usb_alloc_urb(i32 %iso_packets, i32 %mem_flags) #0 {
entry:
  %conv = sext i32 %iso_packets to i64
  %mul = mul i64 %conv, 16
  %add = add i64 192, %mul
  %call.i = call i8* @__kmalloc(i64 %add, i32 %mem_flags) #8
  %0 = bitcast i8* %call.i to %struct.urb.824*
  %tobool = icmp ne %struct.urb.824* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @usb_init_urb(%struct.urb.824* %0)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi %struct.urb.824* [ %0, %if.end ], [ null, %if.then ]
  ret %struct.urb.824* %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_init_urb(%struct.urb.824* %urb) #0 {
entry:
  %tobool = icmp ne %struct.urb.824* %urb, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.urb.824* %urb to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 192, i32 8, i1 false)
  %kref = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 0
  call void @kref_init.185(%struct.arch_spinlock* %kref)
  %anchor_list = getelementptr inbounds %struct.urb.824, %struct.urb.824* %urb, i32 0, i32 6
  call void @INIT_LIST_HEAD.186(%struct.list_head* %anchor_list)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_init.185(%struct.arch_spinlock* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  call void @atomic_set.187(%union.anon.5* %refcount, i32 1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.186(%struct.list_head* %list) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !95
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !96
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set.187(%union.anon.5* %v, i32 %i) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !94
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_if_uevent(%struct.device* %dev, %struct.kobj_uevent_env* %env) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -48
  %1 = bitcast i8* %add.ptr to %struct.usb_interface*
  %call = call %struct.usb_device* @interface_to_usbdev.195(%struct.usb_interface* %1)
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %1, i32 0, i32 1
  %2 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !148
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 5
  %3 = load i8, i8* %bInterfaceClass, align 1, !tbaa !433
  %conv = zext i8 %3 to i32
  %desc1 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceSubClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc1, i32 0, i32 6
  %4 = load i8, i8* %bInterfaceSubClass, align 2, !tbaa !269
  %conv2 = zext i8 %4 to i32
  %desc3 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceProtocol = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc3, i32 0, i32 7
  %5 = load i8, i8* %bInterfaceProtocol, align 1, !tbaa !434
  %conv4 = zext i8 %5 to i32
  %call5 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.36.196, i32 0, i32 0), i32 %conv, i32 %conv2, i32 %conv4)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 12
  %idVendor = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 7
  %6 = load i16, i16* %idVendor, align 8, !tbaa !231
  %conv6 = zext i16 %6 to i32
  %descriptor7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 12
  %idProduct = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor7, i32 0, i32 8
  %7 = load i16, i16* %idProduct, align 2, !tbaa !232
  %conv8 = zext i16 %7 to i32
  %descriptor9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 12
  %bcdDevice = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor9, i32 0, i32 9
  %8 = load i16, i16* %bcdDevice, align 4, !tbaa !238
  %conv10 = zext i16 %8 to i32
  %descriptor11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 12
  %bDeviceClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor11, i32 0, i32 3
  %9 = load i8, i8* %bDeviceClass, align 4, !tbaa !241
  %conv12 = zext i8 %9 to i32
  %descriptor13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 12
  %bDeviceSubClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor13, i32 0, i32 4
  %10 = load i8, i8* %bDeviceSubClass, align 1, !tbaa !243
  %conv14 = zext i8 %10 to i32
  %descriptor15 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 12
  %bDeviceProtocol = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor15, i32 0, i32 5
  %11 = load i8, i8* %bDeviceProtocol, align 2, !tbaa !175
  %conv16 = zext i8 %11 to i32
  %desc17 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceClass18 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc17, i32 0, i32 5
  %12 = load i8, i8* %bInterfaceClass18, align 1, !tbaa !433
  %conv19 = zext i8 %12 to i32
  %desc20 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceSubClass21 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc20, i32 0, i32 6
  %13 = load i8, i8* %bInterfaceSubClass21, align 2, !tbaa !269
  %conv22 = zext i8 %13 to i32
  %desc23 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceProtocol24 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc23, i32 0, i32 7
  %14 = load i8, i8* %bInterfaceProtocol24, align 1, !tbaa !434
  %conv25 = zext i8 %14 to i32
  %desc26 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc26, i32 0, i32 2
  %15 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !68
  %conv27 = zext i8 %15 to i32
  %call28 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.37.197, i32 0, i32 0), i32 %conv6, i32 %conv8, i32 %conv10, i32 %conv12, i32 %conv14, i32 %conv16, i32 %conv19, i32 %conv22, i32 %conv25, i32 %conv27)
  %tobool29 = icmp ne i32 %call28, 0
  %. = select i1 %tobool29, i32 -12, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ -12, %entry ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @usb_release_interface(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -48
  %1 = bitcast i8* %add.ptr to %struct.usb_interface*
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %1, i32 0, i32 0
  %2 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !60
  %3 = bitcast %struct.usb_host_interface* %2 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -8
  %4 = bitcast i8* %add.ptr3 to %struct.usb_interface_cache*
  %ref = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %4, i32 0, i32 1
  call void @kref_put.191(%struct.arch_spinlock* %ref, void (%struct.arch_spinlock*)* @usb_release_interface_cache)
  %5 = bitcast %struct.usb_interface* %1 to i8*
  call void @kfree(i8* %5)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put.191(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* %release) #1 {
entry:
  call void @kref_sub.192(%struct.arch_spinlock* %kref, i32 1, void (%struct.arch_spinlock*)* %release)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_sub.192(%struct.arch_spinlock* %kref, i32 %count, void (%struct.arch_spinlock*)* %release) #1 {
entry:
  %cmp = icmp eq void (%struct.arch_spinlock*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.10.486, i32 0, i32 0), i32 71)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_sub_and_test.194(i32 %count, %union.anon.5* %refcount)
  %tobool14 = icmp ne i32 %call, 0
  br i1 %tobool14, label %if.then15, label %return

if.then15:                                        ; preds = %if.end
  call void %release(%struct.arch_spinlock* %kref)
  br label %return

return:                                           ; preds = %if.then15, %if.end
  %retval.0 = phi i32 [ 1, %if.then15 ], [ 0, %if.end ]
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_sub_and_test.194(i32 %i, %union.anon.5* %v) #1 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subl $2,$0; sete $1", "=*m,=*qm,ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32 %i, i32* %counter) #8, !srcloc !435
  %0 = load i8, i8* %c, align 1, !tbaa !84
  %conv = zext i8 %0 to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_device* @interface_to_usbdev.195(%struct.usb_interface* %intf) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %parent, align 8, !tbaa !282
  %1 = bitcast %struct.device* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -136
  %2 = bitcast i8* %add.ptr to %struct.usb_device*
  ret %struct.usb_device* %2
}

; Function Attrs: nounwind uwtable
define i32 @usb_driver_set_configuration(%struct.usb_device* %udev, i32 %config) #0 {
entry:
  %.compoundliteral = alloca %struct.pgprot, align 8
  %call.i = call i8* @__kmalloc(i64 112, i32 208) #8
  %0 = bitcast i8* %call.i to %struct.set_config_request*
  %tobool = icmp ne %struct.set_config_request* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %udev1 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 0
  store %struct.usb_device* %udev, %struct.usb_device** %udev1, align 8, !tbaa !436
  %config2 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 1
  store i32 %config, i32* %config2, align 8, !tbaa !438
  %work = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 2
  call void @__init_work(%struct.work_struct* %work, i32 0)
  %work4 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 2
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work4, i32 0, i32 0
  %counter = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !272
  %1 = bitcast %struct.pgprot* %data to i8*
  %2 = bitcast %struct.pgprot* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 8, i32 8, i1 false), !tbaa.struct !273
  %work5 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 2
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work5, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.25.200, i32 0, i32 0), %struct.lock_class_key* @usb_driver_set_configuration.__key, i32 0)
  %work6 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 2
  %entry7 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work6, i32 0, i32 1
  call void @INIT_LIST_HEAD.201(%struct.list_head* %entry7)
  %work9 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 2
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work9, i32 0, i32 2
  store void (%struct.work_struct*)* @driver_set_config_work, void (%struct.work_struct*)** %func, align 8, !tbaa !274
  call void @spin_lock.202(%struct.spinlock* @set_config_lock)
  %node = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 3
  call void @list_add.203(%struct.list_head* %node, %struct.list_head* @set_config_list)
  call void @spin_unlock.204(%struct.spinlock* @set_config_lock)
  %call14 = call %struct.usb_device* @usb_get_dev(%struct.usb_device* %udev)
  %work15 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %0, i32 0, i32 2
  call void @schedule_work.205(%struct.work_struct* %work15)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.201(%struct.list_head* %list) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !95
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !96
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @driver_set_config_work(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.set_config_request*
  %udev1 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %1, i32 0, i32 0
  %2 = load %struct.usb_device*, %struct.usb_device** %udev1, align 8, !tbaa !436
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock.208(%struct.device* %dev)
  call void @spin_lock.202(%struct.spinlock* @set_config_lock)
  %node = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %1, i32 0, i32 3
  call void @list_del(%struct.list_head* %node)
  call void @spin_unlock.204(%struct.spinlock* @set_config_lock)
  %config = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %1, i32 0, i32 1
  %3 = load i32, i32* %config, align 8, !tbaa !438
  %cmp = icmp sge i32 %3, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %config2 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %1, i32 0, i32 1
  %4 = load i32, i32* %config2, align 8, !tbaa !438
  %call = call i32 @usb_set_configuration(%struct.usb_device* %2, i32 %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %dev3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock.211(%struct.device* %dev3)
  call void @usb_put_dev(%struct.usb_device* %2)
  %5 = bitcast %struct.set_config_request* %1 to i8*
  call void @kfree(i8* %5)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock.202(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add.203(%struct.list_head* %new, %struct.list_head* %head) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !95
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock.204(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @schedule_work.205(%struct.work_struct* %work) #1 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8, !tbaa !48
  call void @queue_work.206(%struct.workqueue_struct* %0, %struct.work_struct* %work)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_work.206(%struct.workqueue_struct* %wq, %struct.work_struct* %work) #1 {
entry:
  %call = call zeroext i1 @queue_work_on(i32 4096, %struct.workqueue_struct* %wq, %struct.work_struct* %work)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock.208(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_set_configuration(%struct.usb_device* %dev, i32 %configuration) #0 {
entry:
  %.compoundliteral = alloca %struct.pgprot, align 8
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.212(%struct.usb_bus* %0)
  %authorized = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 22
  %bf.load = load i16, i16* %authorized, align 4
  %bf.lshr = lshr i16 %bf.load, 3
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 0
  %cmp1 = icmp eq i32 %configuration, -1
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.end11, label %if.else

if.else:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %i.0 = phi i32 [ 0, %if.else ], [ %inc, %for.inc ]
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 13
  %1 = load i8, i8* %bNumConfigurations, align 1, !tbaa !166
  %conv = zext i8 %1 to i32
  %cmp2 = icmp slt i32 %i.0, %conv
  br i1 %cmp2, label %for.body, label %if.end11

for.body:                                         ; preds = %for.cond
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !167
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i64 %idxprom
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx, i32 0, i32 0
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 4
  %3 = load i8, i8* %bConfigurationValue, align 1, !tbaa !147
  %conv4 = zext i8 %3 to i32
  %cmp5 = icmp eq i32 %conv4, %configuration
  br i1 %cmp5, label %if.then7, label %for.inc

if.then7:                                         ; preds = %for.body
  %config8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  %4 = load %struct.usb_host_config*, %struct.usb_host_config** %config8, align 8, !tbaa !167
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %4, i64 %idxprom9
  br label %if.end11

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end11:                                         ; preds = %if.then7, %for.cond, %entry
  %cp.1 = phi %struct.usb_host_config* [ null, %entry ], [ %arrayidx10, %if.then7 ], [ null, %for.cond ]
  %configuration.addr.0 = phi i32 [ 0, %entry ], [ %configuration, %for.cond ], [ %configuration, %if.then7 ]
  %tobool = icmp eq %struct.usb_host_config* %cp.1, null
  %cmp12 = icmp ne i32 %configuration.addr.0, 0
  %or.cond1 = and i1 %tobool, %cmp12
  br i1 %or.cond1, label %cleanup235, label %if.end15

if.end15:                                         ; preds = %if.end11
  %tobool16 = icmp ne %struct.usb_host_config* %cp.1, null
  %cmp18 = icmp eq i32 %configuration.addr.0, 0
  %or.cond2 = and i1 %tobool16, %cmp18
  br i1 %or.cond2, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end15
  %5 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end23

if.end23:                                         ; preds = %if.then20, %if.end15
  %tobool24 = icmp ne %struct.usb_host_config* %cp.1, null
  br i1 %tobool24, label %if.then25, label %if.end65

if.then25:                                        ; preds = %if.end23
  %desc26 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.1, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc26, i32 0, i32 3
  %6 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv27 = zext i8 %6 to i32
  %conv28 = sext i32 %conv27 to i64
  %mul = mul i64 %conv28, 8
  %call.i = call i8* @__kmalloc(i64 %mul, i32 16) #8
  %7 = bitcast i8* %call.i to %struct.usb_interface**
  %tobool30 = icmp ne %struct.usb_interface** %7, null
  br i1 %tobool30, label %if.end34, label %if.then31

if.then31:                                        ; preds = %if.then25
  %8 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup235

if.end34:                                         ; preds = %if.then25
  br label %for.cond35

for.cond35:                                       ; preds = %for.inc53, %if.end34
  %n.0 = phi i32 [ 0, %if.end34 ], [ %inc54, %for.inc53 ]
  %cmp36 = icmp slt i32 %n.0, %conv27
  br i1 %cmp36, label %for.body38, label %for.end55

for.body38:                                       ; preds = %for.cond35
  %call39 = call i8* @kzalloc.214(i64 1280, i32 16)
  %9 = bitcast i8* %call39 to %struct.usb_interface*
  %idxprom40 = sext i32 %n.0 to i64
  %arrayidx41 = getelementptr inbounds %struct.usb_interface*, %struct.usb_interface** %7, i64 %idxprom40
  store %struct.usb_interface* %9, %struct.usb_interface** %arrayidx41, align 8, !tbaa !48
  %idxprom42 = sext i32 %n.0 to i64
  %arrayidx43 = getelementptr inbounds %struct.usb_interface*, %struct.usb_interface** %7, i64 %idxprom42
  %10 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx43, align 8, !tbaa !48
  %tobool44 = icmp ne %struct.usb_interface* %10, null
  br i1 %tobool44, label %for.inc53, label %if.then45

if.then45:                                        ; preds = %for.body38
  %11 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %free_interfaces

free_interfaces:                                  ; preds = %if.end90, %if.then78, %if.end65, %if.then45
  %n.1 = phi i32 [ %n.0, %if.then45 ], [ %n.3, %if.then78 ], [ %n.3, %if.end90 ], [ %n.3, %if.end65 ]
  %new_interfaces.0 = phi %struct.usb_interface** [ %7, %if.then45 ], [ %new_interfaces.1, %if.then78 ], [ %new_interfaces.1, %if.end90 ], [ %new_interfaces.1, %if.end65 ]
  %ret.0 = phi i32 [ -12, %if.then45 ], [ -12, %if.then78 ], [ %call83, %if.end90 ], [ %call66, %if.end65 ]
  br label %while.cond

while.cond:                                       ; preds = %while.body, %free_interfaces
  %n.2 = phi i32 [ %n.1, %free_interfaces ], [ %dec, %while.body ]
  %dec = add nsw i32 %n.2, -1
  %cmp48 = icmp sge i32 %dec, 0
  br i1 %cmp48, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %idxprom50 = sext i32 %dec to i64
  %arrayidx51 = getelementptr inbounds %struct.usb_interface*, %struct.usb_interface** %new_interfaces.0, i64 %idxprom50
  %12 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx51, align 8, !tbaa !48
  %13 = bitcast %struct.usb_interface* %12 to i8*
  call void @kfree(i8* %13)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %14 = bitcast %struct.usb_interface** %new_interfaces.0 to i8*
  call void @kfree(i8* %14)
  br label %cleanup235

for.inc53:                                        ; preds = %for.body38
  %inc54 = add nsw i32 %n.0, 1
  br label %for.cond35

for.end55:                                        ; preds = %for.cond35
  %bus_mA = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 19
  %15 = load i16, i16* %bus_mA, align 8, !tbaa !258
  %conv56 = zext i16 %15 to i32
  %call57 = call i32 @usb_get_max_power.215(%struct.usb_device* %dev, %struct.usb_host_config* %cp.1)
  %sub = sub i32 %conv56, %call57
  %cmp58 = icmp slt i32 %sub, 0
  br i1 %cmp58, label %if.then60, label %if.end65

if.then60:                                        ; preds = %for.end55
  %16 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end65

if.end65:                                         ; preds = %if.then60, %for.end55, %if.end23
  %nintf.0 = phi i32 [ 0, %if.end23 ], [ %conv27, %if.then60 ], [ %conv27, %for.end55 ]
  %n.3 = phi i32 [ 0, %if.end23 ], [ %n.0, %if.then60 ], [ %n.0, %for.end55 ]
  %new_interfaces.1 = phi %struct.usb_interface** [ null, %if.end23 ], [ %7, %if.then60 ], [ %7, %for.end55 ]
  %call66 = call i32 @usb_autoresume_device(%struct.usb_device* %dev)
  %tobool67 = icmp ne i32 %call66, 0
  br i1 %tobool67, label %free_interfaces, label %if.end69

if.end69:                                         ; preds = %if.end65
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 3
  %17 = load i32, i32* %state, align 8, !tbaa !50
  %cmp70 = icmp ne i32 %17, 6
  br i1 %cmp70, label %if.then72, label %if.end73

if.then72:                                        ; preds = %if.end69
  call void @usb_disable_device(%struct.usb_device* %dev, i32 1)
  br label %if.end73

if.end73:                                         ; preds = %if.then72, %if.end69
  call void @cancel_async_set_config(%struct.usb_device* %dev)
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %18 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !146
  call void @mutex_lock_nested(%struct.mutex* %18, i32 0)
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %19 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool74 = icmp ne %struct.usb_host_config* %19, null
  br i1 %tobool74, label %land.lhs.true75, label %if.end82

land.lhs.true75:                                  ; preds = %if.end73
  %call76 = call i32 @usb_disable_lpm(%struct.usb_device* %dev)
  %tobool77 = icmp ne i32 %call76, 0
  br i1 %tobool77, label %if.then78, label %if.end82

if.then78:                                        ; preds = %land.lhs.true75
  %20 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %bandwidth_mutex81 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %21 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex81, align 8, !tbaa !146
  call void @mutex_unlock(%struct.mutex* %21)
  br label %free_interfaces

if.end82:                                         ; preds = %land.lhs.true75, %if.end73
  %call83 = call i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %dev, %struct.usb_host_config* %cp.1, %struct.usb_host_interface* null, %struct.usb_host_interface* null)
  %cmp84 = icmp slt i32 %call83, 0
  br i1 %cmp84, label %if.then86, label %if.end92

if.then86:                                        ; preds = %if.end82
  %actconfig87 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %22 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig87, align 8, !tbaa !64
  %tobool88 = icmp ne %struct.usb_host_config* %22, null
  br i1 %tobool88, label %if.then89, label %if.end90

if.then89:                                        ; preds = %if.then86
  call void @usb_enable_lpm(%struct.usb_device* %dev)
  br label %if.end90

if.end90:                                         ; preds = %if.then89, %if.then86
  %bandwidth_mutex91 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %23 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex91, align 8, !tbaa !146
  call void @mutex_unlock(%struct.mutex* %23)
  call void @usb_autosuspend_device(%struct.usb_device* %dev)
  br label %free_interfaces

if.end92:                                         ; preds = %if.end82
  br label %for.cond93

for.cond93:                                       ; preds = %if.end110, %if.end92
  %i.1 = phi i32 [ 0, %if.end92 ], [ %inc144, %if.end110 ]
  %cmp94 = icmp slt i32 %i.1, %nintf.0
  br i1 %cmp94, label %for.body96, label %for.end145

for.body96:                                       ; preds = %for.cond93
  %idxprom97 = sext i32 %i.1 to i64
  %arrayidx98 = getelementptr inbounds %struct.usb_interface*, %struct.usb_interface** %new_interfaces.1, i64 %idxprom97
  %24 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx98, align 8, !tbaa !48
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.1, i32 0, i32 3
  %idxprom99 = sext i32 %i.1 to i64
  %arrayidx100 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom99
  store %struct.usb_interface* %24, %struct.usb_interface** %arrayidx100, align 8, !tbaa !48
  %intf_cache = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.1, i32 0, i32 4
  %idxprom101 = sext i32 %i.1 to i64
  %arrayidx102 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache, i64 0, i64 %idxprom101
  %25 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx102, align 8, !tbaa !48
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %25, i32 0, i32 2
  %arraydecay = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i32 0, i32 0
  %altsetting103 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 0
  store %struct.usb_host_interface* %arraydecay, %struct.usb_host_interface** %altsetting103, align 8, !tbaa !60
  %num_altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %25, i32 0, i32 0
  %26 = load i32, i32* %num_altsetting, align 8, !tbaa !69
  %num_altsetting104 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 2
  store i32 %26, i32* %num_altsetting104, align 8, !tbaa !59
  %ref = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %25, i32 0, i32 1
  call void @kref_get.220(%struct.arch_spinlock* %ref)
  %call105 = call %struct.usb_host_interface* @usb_altnum_to_altsetting(%struct.usb_interface* %24, i32 0)
  %tobool106 = icmp ne %struct.usb_host_interface* %call105, null
  br i1 %tobool106, label %if.end110, label %if.then107

if.then107:                                       ; preds = %for.body96
  %altsetting108 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 0
  %27 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting108, align 8, !tbaa !60
  %arrayidx109 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %27, i64 0
  br label %if.end110

if.end110:                                        ; preds = %if.then107, %for.body96
  %alt.0 = phi %struct.usb_host_interface* [ %call105, %for.body96 ], [ %arrayidx109, %if.then107 ]
  %desc111 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc111, i32 0, i32 2
  %28 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !68
  %call112 = call %struct.usb_interface_assoc_descriptor* @find_iad(%struct.usb_host_config* %cp.1, i8 zeroext %28)
  %intf_assoc = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 3
  store %struct.usb_interface_assoc_descriptor* %call112, %struct.usb_interface_assoc_descriptor** %intf_assoc, align 8, !tbaa !439
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 1
  store %struct.usb_host_interface* %alt.0, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !148
  call void @usb_enable_interface(%struct.usb_device* %dev, %struct.usb_interface* %24, i1 zeroext true)
  %dev113 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %dev114 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 7
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev114, i32 0, i32 0
  store %struct.device* %dev113, %struct.device** %parent, align 8, !tbaa !282
  %dev115 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev115, i32 0, i32 7
  store %struct.device_driver* null, %struct.device_driver** %driver, align 8, !tbaa !104
  %dev116 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 7
  %bus117 = getelementptr inbounds %struct.device, %struct.device* %dev116, i32 0, i32 6
  store %struct.bus_type* @usb_bus_type, %struct.bus_type** %bus117, align 8, !tbaa !440
  %dev118 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 7
  %type = getelementptr inbounds %struct.device, %struct.device* %dev118, i32 0, i32 4
  store %struct.device_type* @usb_if_device_type, %struct.device_type** %type, align 8, !tbaa !441
  %dev119 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 7
  %groups = getelementptr inbounds %struct.device, %struct.device* %dev119, i32 0, i32 26
  store %struct.attribute_group** getelementptr inbounds ([3 x %struct.attribute_group*], [3 x %struct.attribute_group*]* @usb_interface_groups, i32 0, i32 0), %struct.attribute_group*** %groups, align 8, !tbaa !442
  %dev120 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %dma_mask = getelementptr inbounds %struct.device, %struct.device* %dev120, i32 0, i32 12
  %29 = load i64*, i64** %dma_mask, align 8, !tbaa !80
  %dev121 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 7
  %dma_mask122 = getelementptr inbounds %struct.device, %struct.device* %dev121, i32 0, i32 12
  store i64* %29, i64** %dma_mask122, align 8, !tbaa !443
  %reset_ws = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 10
  call void @__init_work(%struct.work_struct* %reset_ws, i32 0)
  %reset_ws124 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 10
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %reset_ws124, i32 0, i32 0
  %counter = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !272
  %30 = bitcast %struct.pgprot* %data to i8*
  %31 = bitcast %struct.pgprot* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %30, i8* %31, i64 8, i32 8, i1 false), !tbaa.struct !273
  %reset_ws125 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 10
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %reset_ws125, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21, i32 0, i32 0), %struct.lock_class_key* @usb_set_configuration.__key, i32 0)
  %reset_ws126 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 10
  %entry127 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %reset_ws126, i32 0, i32 1
  call void @INIT_LIST_HEAD.201(%struct.list_head* %entry127)
  %reset_ws129 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 10
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %reset_ws129, i32 0, i32 2
  store void (%struct.work_struct*)* @__usb_queue_reset_device, void (%struct.work_struct*)** %func, align 8, !tbaa !274
  %minor = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 4
  store i32 -1, i32* %minor, align 8, !tbaa !57
  %dev134 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 7
  call void @device_initialize(%struct.device* %dev134)
  %dev135 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 7
  call void @pm_runtime_no_callbacks(%struct.device* %dev135)
  %dev136 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 7
  %bus137 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %32 = load %struct.usb_bus*, %struct.usb_bus** %bus137, align 8, !tbaa !2
  %busnum = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %32, i32 0, i32 1
  %33 = load i32, i32* %busnum, align 8, !tbaa !35
  %devpath = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 1
  %arraydecay138 = getelementptr inbounds [16 x i8], [16 x i8]* %devpath, i32 0, i32 0
  %desc139 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 0
  %bInterfaceNumber140 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc139, i32 0, i32 2
  %34 = load i8, i8* %bInterfaceNumber140, align 2, !tbaa !68
  %conv141 = zext i8 %34 to i32
  %call142 = call i32 (%struct.device*, i8*, ...) @dev_set_name(%struct.device* %dev136, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.22.223, i32 0, i32 0), i32 %33, i8* %arraydecay138, i32 %configuration.addr.0, i32 %conv141)
  %inc144 = add nsw i32 %i.1, 1
  br label %for.cond93

for.end145:                                       ; preds = %for.cond93
  %35 = bitcast %struct.usb_interface** %new_interfaces.1 to i8*
  call void @kfree(i8* %35)
  %call146 = call i32 @__create_pipe.224(%struct.usb_device* %dev, i32 0)
  %or = or i32 -2147483648, %call146
  %conv147 = trunc i32 %configuration.addr.0 to i16
  %call148 = call i32 @usb_control_msg(%struct.usb_device* %dev, i32 %or, i8 zeroext 9, i8 zeroext 0, i16 zeroext %conv147, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  %cmp149 = icmp slt i32 %call148, 0
  %tobool152 = icmp ne %struct.usb_host_config* %cp.1, null
  %or.cond3 = and i1 %cmp149, %tobool152
  br i1 %or.cond3, label %if.then153, label %if.end172

if.then153:                                       ; preds = %for.end145
  %call154 = call i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %dev, %struct.usb_host_config* null, %struct.usb_host_interface* null, %struct.usb_host_interface* null)
  br label %for.cond155

for.cond155:                                      ; preds = %for.body158, %if.then153
  %i.2 = phi i32 [ 0, %if.then153 ], [ %inc170, %for.body158 ]
  %cmp156 = icmp slt i32 %i.2, %nintf.0
  br i1 %cmp156, label %for.body158, label %if.end172

for.body158:                                      ; preds = %for.cond155
  %interface159 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.1, i32 0, i32 3
  %idxprom160 = sext i32 %i.2 to i64
  %arrayidx161 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface159, i64 0, i64 %idxprom160
  %36 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx161, align 8, !tbaa !48
  call void @usb_disable_interface(%struct.usb_device* %dev, %struct.usb_interface* %36, i1 zeroext true)
  %interface162 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.1, i32 0, i32 3
  %idxprom163 = sext i32 %i.2 to i64
  %arrayidx164 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface162, i64 0, i64 %idxprom163
  %37 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx164, align 8, !tbaa !48
  %dev165 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %37, i32 0, i32 7
  call void @put_device(%struct.device* %dev165)
  %interface166 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.1, i32 0, i32 3
  %idxprom167 = sext i32 %i.2 to i64
  %arrayidx168 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface166, i64 0, i64 %idxprom167
  store %struct.usb_interface* null, %struct.usb_interface** %arrayidx168, align 8, !tbaa !48
  %inc170 = add nsw i32 %i.2, 1
  br label %for.cond155

if.end172:                                        ; preds = %for.cond155, %for.end145
  %cp.2 = phi %struct.usb_host_config* [ %cp.1, %for.end145 ], [ null, %for.cond155 ]
  %actconfig173 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  store %struct.usb_host_config* %cp.2, %struct.usb_host_config** %actconfig173, align 8, !tbaa !64
  %bandwidth_mutex174 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %38 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex174, align 8, !tbaa !146
  call void @mutex_unlock(%struct.mutex* %38)
  %tobool175 = icmp ne %struct.usb_host_config* %cp.2, null
  br i1 %tobool175, label %if.end177, label %if.then176

if.then176:                                       ; preds = %if.end172
  call void @usb_set_device_state(%struct.usb_device* %dev, i32 6)
  call void @usb_autosuspend_device(%struct.usb_device* %dev)
  br label %cleanup235

if.end177:                                        ; preds = %if.end172
  call void @usb_set_device_state(%struct.usb_device* %dev, i32 7)
  %string = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.2, i32 0, i32 1
  %39 = load i8*, i8** %string, align 8, !tbaa !444
  %cmp178 = icmp eq i8* %39, null
  br i1 %cmp178, label %land.lhs.true180, label %if.end187

land.lhs.true180:                                 ; preds = %if.end177
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 29
  %40 = load i32, i32* %quirks, align 4, !tbaa !259
  %and = and i32 %40, 8
  %tobool181 = icmp ne i32 %and, 0
  br i1 %tobool181, label %if.end187, label %if.then182

if.then182:                                       ; preds = %land.lhs.true180
  %desc183 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.2, i32 0, i32 0
  %iConfiguration = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc183, i32 0, i32 5
  %41 = load i8, i8* %iConfiguration, align 2, !tbaa !445
  %conv184 = zext i8 %41 to i32
  %call185 = call i8* @usb_cache_string(%struct.usb_device* %dev, i32 %conv184)
  %string186 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.2, i32 0, i32 1
  store i8* %call185, i8** %string186, align 8, !tbaa !444
  br label %if.end187

if.end187:                                        ; preds = %if.then182, %land.lhs.true180, %if.end177
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %dev)
  call void @usb_enable_ltm(%struct.usb_device* %dev)
  br label %for.cond188

for.cond188:                                      ; preds = %LeafBlock, %if.end187
  %i.3 = phi i32 [ 0, %if.end187 ], [ %inc233, %LeafBlock ]
  %cmp189 = icmp slt i32 %i.3, %nintf.0
  br i1 %cmp189, label %for.body191, label %for.end234

for.body191:                                      ; preds = %for.cond188
  %interface193 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %cp.2, i32 0, i32 3
  %idxprom194 = sext i32 %i.3 to i64
  %arrayidx195 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface193, i64 0, i64 %idxprom194
  %42 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx195, align 8, !tbaa !48
  %bf.load198 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_set_configuration.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr199 = lshr i32 %bf.load198, 18
  %bf.clear200 = and i32 %bf.lshr199, 255
  %and201 = and i32 %bf.clear200, 1
  %tobool202 = icmp ne i32 %and201, 0
  %lnot = xor i1 %tobool202, true
  %lnot203 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot203 to i32
  %conv204 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv204, i64 0)
  %tobool205 = icmp ne i64 %expval, 0
  br i1 %tobool205, label %if.then206, label %do.end219

if.then206:                                       ; preds = %for.body191
  %dev207 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %dev208 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %42, i32 0, i32 7
  %call209 = call i8* @dev_name.231(%struct.device* %dev208)
  %cur_altsetting210 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %42, i32 0, i32 1
  %43 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting210, align 8, !tbaa !148
  %desc211 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %43, i32 0, i32 0
  %bInterfaceNumber212 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc211, i32 0, i32 2
  %44 = load i8, i8* %bInterfaceNumber212, align 2, !tbaa !68
  %conv213 = zext i8 %44 to i32
  %call214 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_set_configuration.descriptor to %struct._ddebug*), %struct.device* %dev207, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.23.232, i32 0, i32 0), i8* %call209, i32 %configuration.addr.0, i32 %conv213)
  br label %do.end219

do.end219:                                        ; preds = %if.then206, %for.body191
  %dev220 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %42, i32 0, i32 7
  call void @device_enable_async_suspend.233(%struct.device* %dev220)
  %dev221 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %42, i32 0, i32 7
  %call222 = call i32 @device_add(%struct.device* %dev221)
  %cmp223 = icmp ne i32 %call222, 0
  br i1 %cmp223, label %if.then225, label %if.end230

if.then225:                                       ; preds = %do.end219
  %dev227 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %42, i32 0, i32 7
  %call228 = call i8* @dev_name.231(%struct.device* %dev227)
  %45 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %LeafBlock

if.end230:                                        ; preds = %do.end219
  call void @create_intf_ep_devs(%struct.usb_interface* %42)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end230, %if.then225
  %inc233 = add nsw i32 %i.3, 1
  br label %for.cond188

for.end234:                                       ; preds = %for.cond188
  call void @usb_autosuspend_device(%struct.usb_device* %dev)
  br label %cleanup235

cleanup235:                                       ; preds = %for.end234, %if.then176, %while.end, %if.then31, %if.end11
  %retval.0 = phi i32 [ %ret.0, %while.end ], [ 0, %for.end234 ], [ %call148, %if.then176 ], [ -12, %if.then31 ], [ -22, %if.end11 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock.211(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd* @bus_to_hcd.212(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd*
  ret %struct.usb_hcd* %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.214(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_get_max_power.215(%struct.usb_device* %udev, %struct.usb_host_config* %c) #1 {
entry:
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp eq i32 %0, 5
  %cond = select i1 %cmp, i32 8, i32 2
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %c, i32 0, i32 0
  %bMaxPower = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 7
  %1 = load i8, i8* %bMaxPower, align 8, !tbaa !267
  %conv = zext i8 %1 to i32
  %mul1 = mul i32 %conv, %cond
  ret i32 %mul1
}

; Function Attrs: nounwind uwtable
define void @usb_disable_device(%struct.usb_device* %dev, i32 %skip_ep0) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.212(%struct.usb_bus* %0)
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %1 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool = icmp ne %struct.usb_host_config* %1, null
  br i1 %tobool, label %if.then, label %do.body69

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %actconfig1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig1, align 8, !tbaa !64
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %3 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv = zext i8 %3 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %actconfig3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %4 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig3, align 8, !tbaa !64
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %4, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %5 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !48
  %unregistering = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %5, i32 0, i32 6
  %bf.load = load i8, i8* %unregistering, align 8
  %bf.clear = and i8 %bf.load, -5
  %bf.set = or i8 %bf.clear, 4
  store i8 %bf.set, i8* %unregistering, align 8
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond4

for.cond4:                                        ; preds = %LeafBlock, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc38, %LeafBlock ]
  %actconfig5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %6 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig5, align 8, !tbaa !64
  %desc6 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %6, i32 0, i32 0
  %bNumInterfaces7 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc6, i32 0, i32 3
  %7 = load i8, i8* %bNumInterfaces7, align 4, !tbaa !65
  %conv8 = zext i8 %7 to i32
  %cmp9 = icmp slt i32 %i.1, %conv8
  br i1 %cmp9, label %for.body11, label %for.end39

for.body11:                                       ; preds = %for.cond4
  %actconfig13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %8 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig13, align 8, !tbaa !64
  %interface14 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %8, i32 0, i32 3
  %idxprom15 = sext i32 %i.1 to i64
  %arrayidx16 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface14, i64 0, i64 %idxprom15
  %9 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx16, align 8, !tbaa !48
  %dev17 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %9, i32 0, i32 7
  %call18 = call i32 @device_is_registered(%struct.device* %dev17)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %do.body21, label %LeafBlock

do.body21:                                        ; preds = %for.body11
  %bf.load22 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_disable_device.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load22, 18
  %bf.clear23 = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear23, 1
  %tobool24 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool24, true
  %lnot25 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot25 to i32
  %conv26 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv26, i64 0)
  %tobool27 = icmp ne i64 %expval, 0
  br i1 %tobool27, label %if.then28, label %do.end35

if.then28:                                        ; preds = %do.body21
  %dev29 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %dev30 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %9, i32 0, i32 7
  %call31 = call i8* @dev_name.231(%struct.device* %dev30)
  %call32 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_disable_device.descriptor to %struct._ddebug*), %struct.device* %dev29, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.6.260, i32 0, i32 0), i8* %call31)
  br label %do.end35

do.end35:                                         ; preds = %if.then28, %do.body21
  call void @remove_intf_ep_devs(%struct.usb_interface* %9)
  %dev36 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %9, i32 0, i32 7
  call void @device_del(%struct.device* %dev36)
  br label %LeafBlock

LeafBlock:                                        ; preds = %do.end35, %for.body11
  %inc38 = add nsw i32 %i.1, 1
  br label %for.cond4

for.end39:                                        ; preds = %for.cond4
  br label %for.cond40

for.cond40:                                       ; preds = %for.body47, %for.end39
  %i.2 = phi i32 [ 0, %for.end39 ], [ %inc58, %for.body47 ]
  %actconfig41 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %10 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig41, align 8, !tbaa !64
  %desc42 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %10, i32 0, i32 0
  %bNumInterfaces43 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc42, i32 0, i32 3
  %11 = load i8, i8* %bNumInterfaces43, align 4, !tbaa !65
  %conv44 = zext i8 %11 to i32
  %cmp45 = icmp slt i32 %i.2, %conv44
  br i1 %cmp45, label %for.body47, label %for.end59

for.body47:                                       ; preds = %for.cond40
  %actconfig48 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %12 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig48, align 8, !tbaa !64
  %interface49 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %12, i32 0, i32 3
  %idxprom50 = sext i32 %i.2 to i64
  %arrayidx51 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface49, i64 0, i64 %idxprom50
  %13 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx51, align 8, !tbaa !48
  %dev52 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %13, i32 0, i32 7
  call void @put_device(%struct.device* %dev52)
  %actconfig53 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %14 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig53, align 8, !tbaa !64
  %interface54 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %14, i32 0, i32 3
  %idxprom55 = sext i32 %i.2 to i64
  %arrayidx56 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface54, i64 0, i64 %idxprom55
  store %struct.usb_interface* null, %struct.usb_interface** %arrayidx56, align 8, !tbaa !48
  %inc58 = add nsw i32 %i.2, 1
  br label %for.cond40

for.end59:                                        ; preds = %for.cond40
  %call60 = call i32 @usb_unlocked_disable_lpm(%struct.usb_device* %dev)
  %call61 = call i32 @usb_disable_ltm(%struct.usb_device* %dev)
  %actconfig62 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  store %struct.usb_host_config* null, %struct.usb_host_config** %actconfig62, align 8, !tbaa !64
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 3
  %15 = load i32, i32* %state, align 8, !tbaa !50
  %cmp63 = icmp eq i32 %15, 7
  br i1 %cmp63, label %if.then65, label %do.body69

if.then65:                                        ; preds = %for.end59
  call void @usb_set_device_state(%struct.usb_device* %dev, i32 6)
  br label %do.body69

do.body69:                                        ; preds = %if.then65, %for.end59, %entry
  %bf.load70 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_disable_device.descriptor.7 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr71 = lshr i32 %bf.load70, 18
  %bf.clear72 = and i32 %bf.lshr71, 255
  %and73 = and i32 %bf.clear72, 1
  %tobool74 = icmp ne i32 %and73, 0
  %lnot75 = xor i1 %tobool74, true
  %lnot77 = xor i1 %lnot75, true
  %lnot.ext78 = zext i1 %lnot77 to i32
  %conv79 = sext i32 %lnot.ext78 to i64
  %expval80 = call i64 @llvm.expect.i64(i64 %conv79, i64 0)
  %tobool81 = icmp ne i64 %expval80, 0
  br i1 %tobool81, label %if.then82, label %do.end90

if.then82:                                        ; preds = %do.body69
  %dev83 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %tobool84 = icmp ne i32 %skip_ep0, 0
  %cond = select i1 %tobool84, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.9.261, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7.424, i32 0, i32 0)
  %call85 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_disable_device.descriptor.7 to %struct._ddebug*), %struct.device* %dev83, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.8.263, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.usb_disable_device, i32 0, i32 0), i8* %cond)
  br label %do.end90

do.end90:                                         ; preds = %if.then82, %do.body69
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %16 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %check_bandwidth = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %16, i32 0, i32 32
  %17 = load i32 (%struct.usb_hcd*, %struct.usb_device*)*, i32 (%struct.usb_hcd*, %struct.usb_device*)** %check_bandwidth, align 8, !tbaa !406
  %tobool91 = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*)* %17, null
  br i1 %tobool91, label %if.then92, label %if.end102

if.then92:                                        ; preds = %do.end90
  br label %for.cond93

for.cond93:                                       ; preds = %for.body96, %if.then92
  %i.3 = phi i32 [ %skip_ep0, %if.then92 ], [ %inc98, %for.body96 ]
  %cmp94 = icmp slt i32 %i.3, 16
  br i1 %cmp94, label %for.body96, label %for.end99

for.body96:                                       ; preds = %for.cond93
  call void @usb_disable_endpoint(%struct.usb_device* %dev, i32 %i.3, i1 zeroext false)
  %add = add nsw i32 %i.3, 128
  call void @usb_disable_endpoint(%struct.usb_device* %dev, i32 %add, i1 zeroext false)
  %inc98 = add nsw i32 %i.3, 1
  br label %for.cond93

for.end99:                                        ; preds = %for.cond93
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %18 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !146
  call void @mutex_lock_nested(%struct.mutex* %18, i32 0)
  %call100 = call i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %dev, %struct.usb_host_config* null, %struct.usb_host_interface* null, %struct.usb_host_interface* null)
  %bandwidth_mutex101 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %19 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex101, align 8, !tbaa !146
  call void @mutex_unlock(%struct.mutex* %19)
  br label %if.end102

if.end102:                                        ; preds = %for.end99, %do.end90
  br label %for.cond103

for.cond103:                                      ; preds = %for.body106, %if.end102
  %i.4 = phi i32 [ %skip_ep0, %if.end102 ], [ %inc109, %for.body106 ]
  %cmp104 = icmp slt i32 %i.4, 16
  br i1 %cmp104, label %for.body106, label %for.end110

for.body106:                                      ; preds = %for.cond103
  call void @usb_disable_endpoint(%struct.usb_device* %dev, i32 %i.4, i1 zeroext true)
  %add107 = add nsw i32 %i.4, 128
  call void @usb_disable_endpoint(%struct.usb_device* %dev, i32 %add107, i1 zeroext true)
  %inc109 = add nsw i32 %i.4, 1
  br label %for.cond103

for.end110:                                       ; preds = %for.cond103
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @cancel_async_set_config(%struct.usb_device* %udev) #0 {
entry:
  call void @spin_lock.202(%struct.spinlock* @set_config_lock)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @set_config_list, i32 0, i32 0), %entry ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !48
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr6 = getelementptr inbounds i8, i8* %1, i64 -96
  %2 = bitcast i8* %add.ptr6 to %struct.set_config_request*
  %node = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %2, i32 0, i32 3
  %cmp = icmp ne %struct.list_head* %node, @set_config_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %udev1 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %2, i32 0, i32 0
  %3 = load %struct.usb_device*, %struct.usb_device** %udev1, align 8, !tbaa !436
  %cmp2 = icmp eq %struct.usb_device* %3, %udev
  br i1 %cmp2, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %config = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %2, i32 0, i32 1
  store i32 -999, i32* %config, align 8, !tbaa !438
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %node4 = getelementptr inbounds %struct.set_config_request, %struct.set_config_request* %2, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %node4, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @spin_unlock.204(%struct.spinlock* @set_config_lock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_get.220(%struct.arch_spinlock* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_add_return.258(i32 1, %union.anon.5* %refcount)
  %cmp = icmp slt i32 %call, 2
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  %0 = load i8, i8* @kref_get.__warned.259, align 1, !tbaa !43, !range !44
  %tobool7 = trunc i8 %0 to i1
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %tobool14 = icmp ne i32 %lnot.ext13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.10.486, i32 0, i32 0), i32 47)
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then
  %tobool23 = icmp ne i32 %lnot.ext13, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end
  store i8 1, i8* @kref_get.__warned.259, align 1, !tbaa !43
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.usb_interface_assoc_descriptor* @find_iad(%struct.usb_host_config* %config, i8 zeroext %inum) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %retval1.0 = phi %struct.usb_interface_assoc_descriptor* [ null, %entry ], [ %retval1.3, %for.inc ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 16
  br i1 %cmp, label %land.rhs, label %for.end

land.rhs:                                         ; preds = %for.cond
  %intf_assoc2 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 2
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x %struct.usb_interface_assoc_descriptor*], [16 x %struct.usb_interface_assoc_descriptor*]* %intf_assoc2, i64 0, i64 %idxprom
  %0 = load %struct.usb_interface_assoc_descriptor*, %struct.usb_interface_assoc_descriptor** %arrayidx, align 8, !tbaa !48
  %tobool = icmp ne %struct.usb_interface_assoc_descriptor* %0, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %land.rhs
  %intf_assoc3 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 2
  %idxprom4 = sext i32 %i.0 to i64
  %arrayidx5 = getelementptr inbounds [16 x %struct.usb_interface_assoc_descriptor*], [16 x %struct.usb_interface_assoc_descriptor*]* %intf_assoc3, i64 0, i64 %idxprom4
  %1 = load %struct.usb_interface_assoc_descriptor*, %struct.usb_interface_assoc_descriptor** %arrayidx5, align 8, !tbaa !48
  %bInterfaceCount = getelementptr inbounds %struct.usb_interface_assoc_descriptor, %struct.usb_interface_assoc_descriptor* %1, i32 0, i32 3
  %2 = load i8, i8* %bInterfaceCount, align 1, !tbaa !446
  %conv = zext i8 %2 to i32
  %cmp6 = icmp eq i32 %conv, 0
  br i1 %cmp6, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %bFirstInterface = getelementptr inbounds %struct.usb_interface_assoc_descriptor, %struct.usb_interface_assoc_descriptor* %1, i32 0, i32 2
  %3 = load i8, i8* %bFirstInterface, align 1, !tbaa !448
  %conv8 = zext i8 %3 to i32
  %bInterfaceCount9 = getelementptr inbounds %struct.usb_interface_assoc_descriptor, %struct.usb_interface_assoc_descriptor* %1, i32 0, i32 3
  %4 = load i8, i8* %bInterfaceCount9, align 1, !tbaa !446
  %conv10 = zext i8 %4 to i32
  %sub = sub nsw i32 %conv10, 1
  %add = add nsw i32 %conv8, %sub
  %conv11 = zext i8 %inum to i32
  %cmp12 = icmp sge i32 %conv11, %conv8
  %conv14 = zext i8 %inum to i32
  %cmp15 = icmp sle i32 %conv14, %add
  %or.cond = and i1 %cmp12, %cmp15
  br i1 %or.cond, label %if.then17, label %for.inc

if.then17:                                        ; preds = %if.end
  %tobool18 = icmp ne %struct.usb_interface_assoc_descriptor* %retval1.0, null
  br i1 %tobool18, label %if.else, label %for.inc

if.else:                                          ; preds = %if.then17
  %5 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %for.inc

for.inc:                                          ; preds = %if.else, %if.then17, %if.end, %for.body
  %retval1.3 = phi %struct.usb_interface_assoc_descriptor* [ %retval1.0, %for.body ], [ %retval1.0, %if.end ], [ %retval1.0, %if.else ], [ %1, %if.then17 ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %land.rhs, %for.cond
  ret %struct.usb_interface_assoc_descriptor* %retval1.0
}

; Function Attrs: nounwind uwtable
define void @usb_enable_interface(%struct.usb_device* %dev, %struct.usb_interface* %intf, i1 zeroext %reset_eps) #0 {
entry:
  %frombool = zext i1 %reset_eps to i8
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %0 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !148
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 4
  %1 = load i8, i8* %bNumEndpoints, align 4, !tbaa !270
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 3
  %2 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !271
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %2, i64 %idxprom
  %tobool = trunc i8 %frombool to i1
  call void @usb_enable_endpoint(%struct.usb_device* %dev, %struct.usb_host_endpoint* %arrayidx, i1 zeroext %tobool)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__usb_queue_reset_device(%struct.work_struct* %ws) #0 {
entry:
  %0 = bitcast %struct.work_struct* %ws to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -1200
  %1 = bitcast i8* %add.ptr to %struct.usb_interface*
  %call = call %struct.usb_device* @interface_to_usbdev.195(%struct.usb_interface* %1)
  %call1 = call i32 @usb_lock_device_for_reset(%struct.usb_device* %call, %struct.usb_interface* %1)
  %cmp = icmp sge i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %reset_running = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %1, i32 0, i32 6
  %bf.load = load i8, i8* %reset_running, align 8
  %bf.clear = and i8 %bf.load, -65
  %bf.set = or i8 %bf.clear, 64
  store i8 %bf.set, i8* %reset_running, align 8
  %call2 = call i32 @usb_reset_device(%struct.usb_device* %call)
  %reset_running3 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %1, i32 0, i32 6
  %bf.load4 = load i8, i8* %reset_running3, align 8
  %bf.clear5 = and i8 %bf.load4, -65
  store i8 %bf.clear5, i8* %reset_running3, align 8
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 11
  call void @device_unlock.211(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @pm_runtime_no_callbacks(%struct.device*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__create_pipe.224(%struct.usb_device* %dev, i32 %endpoint) #1 {
entry:
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 0
  %0 = load i32, i32* %devnum, align 8, !tbaa !38
  %shl = shl i32 %0, 8
  %shl1 = shl i32 %endpoint, 15
  %or = or i32 %shl, %shl1
  ret i32 %or
}

; Function Attrs: nounwind uwtable
define i32 @usb_control_msg(%struct.usb_device* %dev, i32 %pipe, i8 zeroext %request, i8 zeroext %requesttype, i16 zeroext %value, i16 zeroext %index, i8* %data, i16 zeroext %size, i32 %timeout) #0 {
entry:
  %call.i = call i8* @__kmalloc(i64 8, i32 16) #8
  %0 = bitcast i8* %call.i to %struct.usb_ctrlrequest*
  %tobool = icmp ne %struct.usb_ctrlrequest* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %bRequestType = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %0, i32 0, i32 0
  store i8 %requesttype, i8* %bRequestType, align 1, !tbaa !394
  %bRequest = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %0, i32 0, i32 1
  store i8 %request, i8* %bRequest, align 1, !tbaa !396
  %wValue = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %0, i32 0, i32 2
  store i16 %value, i16* %wValue, align 1, !tbaa !397
  %wIndex = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %0, i32 0, i32 3
  store i16 %index, i16* %wIndex, align 1, !tbaa !398
  %wLength = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %0, i32 0, i32 4
  store i16 %size, i16* %wLength, align 1, !tbaa !399
  %conv = zext i16 %size to i32
  %call1 = call i32 @usb_internal_control_msg(%struct.usb_device* %dev, i32 %pipe, %struct.usb_ctrlrequest* %0, i8* %data, i32 %conv, i32 %timeout)
  %1 = bitcast %struct.usb_ctrlrequest* %0 to i8*
  call void @kfree(i8* %1)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call1, %if.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_disable_interface(%struct.usb_device* %dev, %struct.usb_interface* %intf, i1 zeroext %reset_hardware) #0 {
entry:
  %frombool = zext i1 %reset_hardware to i8
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %0 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !148
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 4
  %1 = load i8, i8* %bNumEndpoints, align 4, !tbaa !270
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 3
  %2 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !271
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %2, i64 %idxprom
  %desc2 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 0
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc2, i32 0, i32 2
  %3 = load i8, i8* %bEndpointAddress, align 2, !tbaa !449
  %conv3 = zext i8 %3 to i32
  %tobool = trunc i8 %frombool to i1
  call void @usb_disable_endpoint(%struct.usb_device* %dev, i32 %conv3, i1 zeroext %tobool)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @usb_cache_string(%struct.usb_device* %udev, i32 %index) #0 {
entry:
  %cmp = icmp sle i32 %index, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call.i1 = call i8* @__kmalloc(i64 382, i32 16) #8
  %tobool = icmp ne i8* %call.i1, null
  br i1 %tobool, label %if.then1, label %cleanup

if.then1:                                         ; preds = %if.end
  %call2 = call i32 @usb_string(%struct.usb_device* %udev, i32 %index, i8* %call.i1, i64 382)
  %cmp3 = icmp sgt i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end10

if.then4:                                         ; preds = %if.then1
  %inc = add nsw i32 %call2, 1
  %conv = sext i32 %inc to i64
  %call.i = call i8* @__kmalloc(i64 %conv, i32 16) #8
  %tobool6 = icmp ne i8* %call.i, null
  br i1 %tobool6, label %if.end8, label %cleanup

if.end8:                                          ; preds = %if.then4
  %conv9 = sext i32 %inc to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %call.i, i8* %call.i1, i64 %conv9, i32 1, i1 false)
  br label %if.end10

if.end10:                                         ; preds = %if.end8, %if.then1
  %smallbuf.0 = phi i8* [ %call.i, %if.end8 ], [ null, %if.then1 ]
  call void @kfree(i8* %call.i1)
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.then4, %if.end, %entry
  %retval.0 = phi i8* [ null, %entry ], [ %call.i1, %if.then4 ], [ %smallbuf.0, %if.end10 ], [ null, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name.231(%struct.device* %dev) #1 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !341
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !341
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name.235(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_enable_async_suspend.233(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %is_prepared = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i8, i8* %is_prepared, align 4
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %power1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %async_suspend = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power1, i32 0, i32 1
  %bf.load2 = load i8, i8* %async_suspend, align 4
  %bf.clear3 = and i8 %bf.load2, -3
  %bf.set = or i8 %bf.clear3, 2
  store i8 %bf.set, i8* %async_suspend, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @create_intf_ep_devs(%struct.usb_interface* %intf) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev.195(%struct.usb_interface* %intf)
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %0 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !148
  %ep_devs_created = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load = load i8, i8* %ep_devs_created, align 8
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %unregistering = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load1 = load i8, i8* %unregistering, align 8
  %bf.lshr2 = lshr i8 %bf.load1, 2
  %bf.clear3 = and i8 %bf.lshr2, 1
  %bf.cast4 = zext i8 %bf.clear3 to i32
  %tobool5 = icmp ne i32 %bf.cast4, 0
  br i1 %tobool5, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 4
  %1 = load i8, i8* %bNumEndpoints, align 4, !tbaa !270
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 3
  %2 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !271
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %2, i64 %idxprom
  %call7 = call i32 bitcast (i32 (%struct.device.2626*, %struct.usb_host_endpoint*, %struct.usb_device.2852*)* @usb_create_ep_devs to i32 (%struct.device*, %struct.usb_host_endpoint*, %struct.usb_device*)*)(%struct.device* %dev, %struct.usb_host_endpoint* %arrayidx, %struct.usb_device* %call)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %ep_devs_created8 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load9 = load i8, i8* %ep_devs_created8, align 8
  %bf.clear10 = and i8 %bf.load9, -3
  %bf.set = or i8 %bf.clear10, 2
  store i8 %bf.set, i8* %ep_devs_created8, align 8
  br label %cleanup

cleanup:                                          ; preds = %for.end, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name.235(%struct.kobject* %kobj) #1 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !343
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define i32 @usb_string(%struct.usb_device* %dev, i32 %index, i8* %buf, i64 %size) #0 {
entry:
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp eq i32 %0, 8
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp ugt i64 %size, 0
  %tobool = icmp ne i8* %buf, null
  %or.cond = and i1 %cmp1, %tobool
  %tobool3 = icmp ne i32 %index, 0
  %or.cond1 = and i1 %or.cond, %tobool3
  br i1 %or.cond1, label %if.end5, label %cleanup

if.end5:                                          ; preds = %if.end
  %arrayidx = getelementptr inbounds i8, i8* %buf, i64 0
  store i8 0, i8* %arrayidx, align 1, !tbaa !84
  %call.i = call i8* @__kmalloc(i64 256, i32 16) #8
  %tobool6 = icmp ne i8* %call.i, null
  br i1 %tobool6, label %if.end8, label %cleanup

if.end8:                                          ; preds = %if.end5
  %call9 = call i32 @usb_get_langid(%struct.usb_device* %dev, i8* %call.i)
  %cmp10 = icmp slt i32 %call9, 0
  br i1 %cmp10, label %errout, label %if.end12

if.end12:                                         ; preds = %if.end8
  %string_langid = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 23
  %1 = load i32, i32* %string_langid, align 8, !tbaa !450
  %call13 = call i32 @usb_string_sub(%struct.usb_device* %dev, i32 %1, i32 %index, i8* %call.i)
  %cmp14 = icmp slt i32 %call13, 0
  br i1 %cmp14, label %errout, label %if.end16

if.end16:                                         ; preds = %if.end12
  %dec = add i64 %size, -1
  %arrayidx17 = getelementptr inbounds i8, i8* %call.i, i64 2
  %2 = bitcast i8* %arrayidx17 to i16*
  %sub = sub nsw i32 %call13, 2
  %div = sdiv i32 %sub, 2
  %conv = trunc i64 %dec to i32
  %call18 = call i32 @utf16s_to_utf8s(i16* %2, i32 %div, i32 1, i8* %buf, i32 %conv)
  %idxprom = sext i32 %call18 to i64
  %arrayidx19 = getelementptr inbounds i8, i8* %buf, i64 %idxprom
  store i8 0, i8* %arrayidx19, align 1, !tbaa !84
  %arrayidx20 = getelementptr inbounds i8, i8* %call.i, i64 1
  %3 = load i8, i8* %arrayidx20, align 1, !tbaa !84
  %conv21 = zext i8 %3 to i32
  %cmp22 = icmp ne i32 %conv21, 3
  br i1 %cmp22, label %do.body25, label %errout

do.body25:                                        ; preds = %if.end16
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_string.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool26 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool26, true
  %lnot27 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot27 to i32
  %conv28 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool29 = icmp ne i64 %expval, 0
  br i1 %tobool29, label %if.then30, label %errout

if.then30:                                        ; preds = %do.body25
  %dev31 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %arrayidx32 = getelementptr inbounds i8, i8* %call.i, i64 1
  %4 = load i8, i8* %arrayidx32, align 1, !tbaa !84
  %conv33 = zext i8 %4 to i32
  %call34 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_string.descriptor to %struct._ddebug*), %struct.device* %dev31, i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.5.240, i32 0, i32 0), i32 %conv33, i32 %index, i8* %buf)
  br label %errout

errout:                                           ; preds = %if.then30, %do.body25, %if.end16, %if.end12, %if.end8
  %err.0 = phi i32 [ %call9, %if.end8 ], [ %call13, %if.end12 ], [ %call18, %do.body25 ], [ %call18, %if.then30 ], [ %call18, %if.end16 ]
  call void @kfree(i8* %call.i)
  br label %cleanup

cleanup:                                          ; preds = %errout, %if.end5, %if.end, %entry
  %retval.0 = phi i32 [ %err.0, %errout ], [ -113, %entry ], [ -22, %if.end ], [ -12, %if.end5 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_get_langid(%struct.usb_device* %dev, i8* %tbuf) #0 {
entry:
  %have_langid = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 22
  %bf.load = load i16, i16* %have_langid, align 4
  %bf.lshr = lshr i16 %bf.load, 2
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %string_langid = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 23
  %0 = load i32, i32* %string_langid, align 8, !tbaa !450
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %call = call i32 @usb_string_sub(%struct.usb_device* %dev, i32 0, i32 0, i8* %tbuf)
  %cmp3 = icmp eq i32 %call, -61
  br i1 %cmp3, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end2
  %cmp4 = icmp sgt i32 %call, 0
  %cmp5 = icmp slt i32 %call, 4
  %or.cond = and i1 %cmp4, %cmp5
  br i1 %or.cond, label %if.then6, label %if.end14

if.then6:                                         ; preds = %lor.lhs.false, %if.end2
  %string_langid7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 23
  store i32 1033, i32* %string_langid7, align 8, !tbaa !450
  %have_langid8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 22
  %bf.load9 = load i16, i16* %have_langid8, align 4
  %bf.clear10 = and i16 %bf.load9, -5
  %bf.set = or i16 %bf.clear10, 4
  store i16 %bf.set, i16* %have_langid8, align 4
  %1 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end14:                                         ; preds = %lor.lhs.false
  %cmp15 = icmp slt i32 %call, 0
  br i1 %cmp15, label %if.then16, label %if.end20

if.then16:                                        ; preds = %if.end14
  %2 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %string_langid19 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 23
  store i32 -1, i32* %string_langid19, align 8, !tbaa !450
  br label %cleanup

if.end20:                                         ; preds = %if.end14
  %arrayidx = getelementptr inbounds i8, i8* %tbuf, i64 2
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !84
  %conv = zext i8 %3 to i32
  %arrayidx21 = getelementptr inbounds i8, i8* %tbuf, i64 3
  %4 = load i8, i8* %arrayidx21, align 1, !tbaa !84
  %conv22 = zext i8 %4 to i32
  %shl = shl i32 %conv22, 8
  %or = or i32 %conv, %shl
  %string_langid23 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 23
  store i32 %or, i32* %string_langid23, align 8, !tbaa !450
  %have_langid24 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 22
  %bf.load25 = load i16, i16* %have_langid24, align 4
  %bf.clear26 = and i16 %bf.load25, -5
  %bf.set27 = or i16 %bf.clear26, 4
  store i16 %bf.set27, i16* %have_langid24, align 4
  %bf.load29 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_get_langid.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr30 = lshr i32 %bf.load29, 18
  %bf.clear31 = and i32 %bf.lshr30, 255
  %and = and i32 %bf.clear31, 1
  %tobool32 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool32, true
  %lnot33 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot33 to i32
  %conv34 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv34, i64 0)
  %tobool35 = icmp ne i64 %expval, 0
  br i1 %tobool35, label %if.then36, label %cleanup

if.then36:                                        ; preds = %if.end20
  %dev37 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %string_langid38 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 23
  %5 = load i32, i32* %string_langid38, align 8, !tbaa !450
  %call39 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_get_langid.descriptor to %struct._ddebug*), %struct.device* %dev37, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.35.243, i32 0, i32 0), i32 %5)
  br label %cleanup

cleanup:                                          ; preds = %if.then36, %if.end20, %if.then16, %if.then6, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.then6 ], [ -32, %if.then16 ], [ 0, %entry ], [ -32, %if.end ], [ 0, %if.then36 ], [ 0, %if.end20 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_string_sub(%struct.usb_device* %dev, i32 %langid, i32 %index, i8* %buf) #0 {
entry:
  %rc = alloca i32, align 4
  %0 = bitcast i32* %rc to i8*
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 29
  %1 = load i32, i32* %quirks, align 4, !tbaa !259
  %and = and i32 %1, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -5, i32* %rc, align 4, !tbaa !90
  br label %if.end

if.else:                                          ; preds = %entry
  %conv = trunc i32 %langid to i16
  %conv1 = trunc i32 %index to i8
  %call = call i32 @usb_get_string(%struct.usb_device* %dev, i16 zeroext %conv, i8 zeroext %conv1, i8* %buf, i32 255)
  store i32 %call, i32* %rc, align 4, !tbaa !90
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %2 = load i32, i32* %rc, align 4, !tbaa !90
  %cmp = icmp slt i32 %2, 2
  br i1 %cmp, label %if.then3, label %if.end15

if.then3:                                         ; preds = %if.end
  %conv4 = trunc i32 %langid to i16
  %conv5 = trunc i32 %index to i8
  %call6 = call i32 @usb_get_string(%struct.usb_device* %dev, i16 zeroext %conv4, i8 zeroext %conv5, i8* %buf, i32 2)
  store i32 %call6, i32* %rc, align 4, !tbaa !90
  %3 = load i32, i32* %rc, align 4, !tbaa !90
  %cmp7 = icmp eq i32 %3, 2
  br i1 %cmp7, label %if.then9, label %if.end15

if.then9:                                         ; preds = %if.then3
  %conv10 = trunc i32 %langid to i16
  %conv11 = trunc i32 %index to i8
  %arrayidx = getelementptr inbounds i8, i8* %buf, i64 0
  %4 = load i8, i8* %arrayidx, align 1, !tbaa !84
  %conv12 = zext i8 %4 to i32
  %call13 = call i32 @usb_get_string(%struct.usb_device* %dev, i16 zeroext %conv10, i8 zeroext %conv11, i8* %buf, i32 %conv12)
  store i32 %call13, i32* %rc, align 4, !tbaa !90
  br label %if.end15

if.end15:                                         ; preds = %if.then9, %if.then3, %if.end
  %5 = load i32, i32* %rc, align 4, !tbaa !90
  %cmp16 = icmp sge i32 %5, 2
  br i1 %cmp16, label %if.then18, label %if.end34

if.then18:                                        ; preds = %if.end15
  %arrayidx19 = getelementptr inbounds i8, i8* %buf, i64 0
  %6 = load i8, i8* %arrayidx19, align 1, !tbaa !84
  %tobool20 = icmp ne i8 %6, 0
  br i1 %tobool20, label %if.end24, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then18
  %arrayidx21 = getelementptr inbounds i8, i8* %buf, i64 1
  %7 = load i8, i8* %arrayidx21, align 1, !tbaa !84
  %tobool22 = icmp ne i8 %7, 0
  br i1 %tobool22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %land.lhs.true
  call void @usb_try_string_workarounds(i8* %buf, i32* %rc)
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %land.lhs.true, %if.then18
  %arrayidx25 = getelementptr inbounds i8, i8* %buf, i64 0
  %8 = load i8, i8* %arrayidx25, align 1, !tbaa !84
  %conv26 = zext i8 %8 to i32
  %9 = load i32, i32* %rc, align 4, !tbaa !90
  %cmp27 = icmp slt i32 %conv26, %9
  br i1 %cmp27, label %if.then29, label %if.end32

if.then29:                                        ; preds = %if.end24
  %arrayidx30 = getelementptr inbounds i8, i8* %buf, i64 0
  %10 = load i8, i8* %arrayidx30, align 1, !tbaa !84
  %conv31 = zext i8 %10 to i32
  store i32 %conv31, i32* %rc, align 4, !tbaa !90
  br label %if.end32

if.end32:                                         ; preds = %if.then29, %if.end24
  %11 = load i32, i32* %rc, align 4, !tbaa !90
  %12 = load i32, i32* %rc, align 4, !tbaa !90
  %and33 = and i32 %12, 1
  %sub = sub nsw i32 %11, %and33
  store i32 %sub, i32* %rc, align 4, !tbaa !90
  br label %if.end34

if.end34:                                         ; preds = %if.end32, %if.end15
  %13 = load i32, i32* %rc, align 4, !tbaa !90
  %cmp35 = icmp slt i32 %13, 2
  br i1 %cmp35, label %if.then37, label %if.end40

if.then37:                                        ; preds = %if.end34
  %14 = load i32, i32* %rc, align 4, !tbaa !90
  %cmp38 = icmp slt i32 %14, 0
  %15 = load i32, i32* %rc, align 4
  %cond = select i1 %cmp38, i32 %15, i32 -22
  store i32 %cond, i32* %rc, align 4, !tbaa !90
  br label %if.end40

if.end40:                                         ; preds = %if.then37, %if.end34
  %16 = load i32, i32* %rc, align 4, !tbaa !90
  %17 = bitcast i32* %rc to i8*
  ret i32 %16
}

declare i32 @utf16s_to_utf8s(i16*, i32, i32, i8*, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @usb_get_string(%struct.usb_device* %dev, i16 zeroext %langid, i8 zeroext %index, i8* %buf, i32 %size) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %result.0 = phi i32 [ undef, %entry ], [ %result.1, %for.inc ]
  %cmp = icmp slt i32 %i.0, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @__create_pipe.224(%struct.usb_device* %dev, i32 0)
  %or = or i32 -2147483648, %call
  %or1 = or i32 %or, 128
  %conv = zext i8 %index to i32
  %add = add nsw i32 768, %conv
  %conv2 = trunc i32 %add to i16
  %conv3 = trunc i32 %size to i16
  %call4 = call i32 @usb_control_msg(%struct.usb_device* %dev, i32 %or1, i8 zeroext 6, i8 zeroext -128, i16 zeroext %conv2, i16 zeroext %langid, i8* %buf, i16 zeroext %conv3, i32 5000)
  switch i32 %call4, label %if.end [
    i32 0, label %for.inc
    i32 -32, label %for.inc
  ]

if.end:                                           ; preds = %for.body
  %cmp9 = icmp sgt i32 %call4, 1
  br i1 %cmp9, label %land.lhs.true, label %for.end

land.lhs.true:                                    ; preds = %if.end
  %arrayidx = getelementptr inbounds i8, i8* %buf, i64 1
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !84
  %conv11 = zext i8 %0 to i32
  %cmp12 = icmp ne i32 %conv11, 3
  br i1 %cmp12, label %for.inc, label %for.end

for.inc:                                          ; preds = %land.lhs.true, %for.body, %for.body
  %result.1 = phi i32 [ %call4, %for.body ], [ %call4, %for.body ], [ -61, %land.lhs.true ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %land.lhs.true, %if.end, %for.cond
  %result.2 = phi i32 [ %call4, %land.lhs.true ], [ %call4, %if.end ], [ %result.0, %for.cond ]
  ret i32 %result.2
}

; Function Attrs: nounwind uwtable
define internal void @usb_try_string_workarounds(i8* %buf, i32* %length) #0 {
entry:
  %0 = load i32, i32* %length, align 4, !tbaa !90
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %newlength.0 = phi i32 [ 2, %entry ], [ %add10, %for.inc ]
  %add = add nsw i32 %newlength.0, 1
  %cmp = icmp slt i32 %add, %0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %newlength.0 to i64
  %arrayidx = getelementptr inbounds i8, i8* %buf, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !84
  %conv = zext i8 %1 to i32
  %idxprom1 = sext i32 %conv to i64
  %arrayidx2 = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom1
  %2 = load i8, i8* %arrayidx2, align 1, !tbaa !84
  %conv3 = zext i8 %2 to i32
  %and = and i32 %conv3, 151
  %cmp4 = icmp ne i32 %and, 0
  br i1 %cmp4, label %lor.lhs.false, label %for.end

lor.lhs.false:                                    ; preds = %for.body
  %add6 = add nsw i32 %newlength.0, 1
  %idxprom7 = sext i32 %add6 to i64
  %arrayidx8 = getelementptr inbounds i8, i8* %buf, i64 %idxprom7
  %3 = load i8, i8* %arrayidx8, align 1, !tbaa !84
  %conv9 = zext i8 %3 to i32
  %tobool = icmp ne i32 %conv9, 0
  br i1 %tobool, label %for.end, label %for.inc

for.inc:                                          ; preds = %lor.lhs.false
  %add10 = add nsw i32 %newlength.0, 2
  br label %for.cond

for.end:                                          ; preds = %lor.lhs.false, %for.body, %for.cond
  %cmp11 = icmp sgt i32 %newlength.0, 2
  br i1 %cmp11, label %if.then13, label %if.end16

if.then13:                                        ; preds = %for.end
  %conv14 = trunc i32 %newlength.0 to i8
  %arrayidx15 = getelementptr inbounds i8, i8* %buf, i64 0
  store i8 %conv14, i8* %arrayidx15, align 1, !tbaa !84
  store i32 %newlength.0, i32* %length, align 4, !tbaa !90
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_disable_endpoint(%struct.usb_device* %dev, i32 %epaddr, i1 zeroext %reset_hardware) #0 {
entry:
  %frombool = zext i1 %reset_hardware to i8
  %and = and i32 %epaddr, 15
  %tobool = icmp ne %struct.usb_device* %dev, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %and1 = and i32 %epaddr, 128
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.else, label %if.then3

if.then3:                                         ; preds = %if.end
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 17
  %idxprom = zext i32 %and to i64
  %arrayidx = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out, i64 0, i64 %idxprom
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8, !tbaa !48
  %tobool4 = trunc i8 %frombool to i1
  br i1 %tobool4, label %if.then5, label %if.end18

if.then5:                                         ; preds = %if.then3
  %ep_out6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 17
  %idxprom7 = zext i32 %and to i64
  %arrayidx8 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out6, i64 0, i64 %idxprom7
  store %struct.usb_host_endpoint* null, %struct.usb_host_endpoint** %arrayidx8, align 8, !tbaa !48
  br label %if.end18

if.else:                                          ; preds = %if.end
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 16
  %idxprom10 = zext i32 %and to i64
  %arrayidx11 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in, i64 0, i64 %idxprom10
  %1 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx11, align 8, !tbaa !48
  %tobool12 = trunc i8 %frombool to i1
  br i1 %tobool12, label %if.then13, label %if.end18

if.then13:                                        ; preds = %if.else
  %ep_in14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 16
  %idxprom15 = zext i32 %and to i64
  %arrayidx16 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in14, i64 0, i64 %idxprom15
  store %struct.usb_host_endpoint* null, %struct.usb_host_endpoint** %arrayidx16, align 8, !tbaa !48
  br label %if.end18

if.end18:                                         ; preds = %if.then13, %if.else, %if.then5, %if.then3
  %ep.0 = phi %struct.usb_host_endpoint* [ %0, %if.then5 ], [ %0, %if.then3 ], [ %1, %if.then13 ], [ %1, %if.else ]
  %tobool19 = icmp ne %struct.usb_host_endpoint* %ep.0, null
  br i1 %tobool19, label %if.then20, label %cleanup.cont

if.then20:                                        ; preds = %if.end18
  %enabled = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep.0, i32 0, i32 8
  store i32 0, i32* %enabled, align 4, !tbaa !386
  call void @usb_hcd_flush_endpoint(%struct.usb_device* %dev, %struct.usb_host_endpoint* %ep.0)
  %tobool21 = trunc i8 %frombool to i1
  br i1 %tobool21, label %if.then22, label %cleanup.cont

if.then22:                                        ; preds = %if.then20
  call void @usb_hcd_disable_endpoint(%struct.usb_device* %dev, %struct.usb_host_endpoint* %ep.0)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then22, %if.then20, %if.end18, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_internal_control_msg(%struct.usb_device* %usb_dev, i32 %pipe, %struct.usb_ctrlrequest* %cmd, i8* %data, i32 %len, i32 %timeout) #0 {
entry:
  %length = alloca i32, align 4
  %0 = bitcast i32* %length to i8*
  %call = call %struct.urb* bitcast (%struct.urb.824* (i32, i32)* @usb_alloc_urb to %struct.urb* (i32, i32)*)(i32 0, i32 16)
  %tobool = icmp ne %struct.urb* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %1 = bitcast %struct.usb_ctrlrequest* %cmd to i8*
  call void @usb_fill_control_urb(%struct.urb* %call, %struct.usb_device* %usb_dev, i32 %pipe, i8* %1, i8* %data, i32 %len, void (%struct.urb*)* @usb_api_blocking_completion, i8* null)
  %call1 = call i32 @usb_start_wait_urb(%struct.urb* %call, i32 %timeout, i32* %length)
  %cmp = icmp slt i32 %call1, 0
  %2 = load i32, i32* %length, align 4
  %call1. = select i1 %cmp, i32 %call1, i32 %2
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ -12, %entry ], [ %call1., %if.end ]
  %3 = bitcast i32* %length to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @usb_api_blocking_completion(%struct.urb* %urb) #0 {
entry:
  %context = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  %0 = load i8*, i8** %context, align 8, !tbaa !290
  %1 = bitcast i8* %0 to %struct.api_context*
  %status = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 12
  %2 = load i32, i32* %status, align 8, !tbaa !291
  %status1 = getelementptr inbounds %struct.api_context, %struct.api_context* %1, i32 0, i32 1
  store i32 %2, i32* %status1, align 8, !tbaa !451
  %done = getelementptr inbounds %struct.api_context, %struct.api_context* %1, i32 0, i32 0
  call void @complete(%struct.completion* %done)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_fill_control_urb(%struct.urb* %urb, %struct.usb_device* %dev, i32 %pipe, i8* %setup_packet, i8* %transfer_buffer, i32 %buffer_length, void (%struct.urb*)* %complete_fn, i8* %context) #1 {
entry:
  %dev1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  store %struct.usb_device* %dev, %struct.usb_device** %dev1, align 8, !tbaa !210
  %pipe2 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 10
  store i32 %pipe, i32* %pipe2, align 8, !tbaa !212
  %setup_packet3 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 21
  store i8* %setup_packet, i8** %setup_packet3, align 8, !tbaa !371
  %transfer_buffer4 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  store i8* %transfer_buffer, i8** %transfer_buffer4, align 8, !tbaa !293
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  store i32 %buffer_length, i32* %transfer_buffer_length, align 8, !tbaa !294
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 28
  store void (%struct.urb*)* %complete_fn, void (%struct.urb*)** %complete, align 8, !tbaa !295
  %context5 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  store i8* %context, i8** %context5, align 8, !tbaa !290
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_start_wait_urb(%struct.urb* %urb, i32 %timeout, i32* %actual_length) #0 {
entry:
  %ctx = alloca %struct.api_context, align 8
  %0 = bitcast %struct.api_context* %ctx to i8*
  %done = getelementptr inbounds %struct.api_context, %struct.api_context* %ctx, i32 0, i32 0
  call void @init_completion(%struct.completion* %done)
  %1 = bitcast %struct.api_context* %ctx to i8*
  %context = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  store i8* %1, i8** %context, align 8, !tbaa !290
  %actual_length2 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  store i32 0, i32* %actual_length2, align 4, !tbaa !292
  %call = call i32 bitcast (i32 (%struct.urb.824*, i32)* @usb_submit_urb to i32 (%struct.urb*, i32)*)(%struct.urb* %urb, i32 16)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %out, label %if.end

if.end:                                           ; preds = %entry
  %tobool5 = icmp ne i32 %timeout, 0
  br i1 %tobool5, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end
  %call6 = call i64 @msecs_to_jiffies(i32 %timeout)
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.end
  %cond = phi i64 [ %call6, %cond.true ], [ 9223372036854775807, %if.end ]
  %done7 = getelementptr inbounds %struct.api_context, %struct.api_context* %ctx, i32 0, i32 0
  %call8 = call i64 @wait_for_completion_timeout(%struct.completion* %done7, i64 %cond)
  %tobool9 = icmp ne i64 %call8, 0
  br i1 %tobool9, label %if.else, label %if.then10

if.then10:                                        ; preds = %cond.end
  call void bitcast (void (%struct.urb.824*)* @usb_kill_urb to void (%struct.urb*)*)(%struct.urb* %urb)
  %status = getelementptr inbounds %struct.api_context, %struct.api_context* %ctx, i32 0, i32 1
  %2 = load i32, i32* %status, align 8, !tbaa !451
  %cmp = icmp eq i32 %2, -2
  %status14 = getelementptr inbounds %struct.api_context, %struct.api_context* %ctx, i32 0, i32 1
  %3 = load i32, i32* %status14, align 8
  %cond16 = select i1 %cmp, i32 -110, i32 %3
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_start_wait_urb.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool18 = icmp ne i32 %and, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %if.then26, label %out

if.then26:                                        ; preds = %if.then10
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !210
  %dev27 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 11
  %5 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !453
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %5, i32 0, i32 66
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %6 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !218
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %6, i32 0, i32 0
  %call29 = call i32 @usb_endpoint_num.247(%struct.usb_endpoint_descriptor* %desc)
  %call30 = call i32 @usb_urb_dir_in.248(%struct.urb* %urb)
  %tobool31 = icmp ne i32 %call30, 0
  %cond32 = select i1 %tobool31, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.45.737, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.44.736, i32 0, i32 0)
  %actual_length33 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %7 = load i32, i32* %actual_length33, align 4, !tbaa !292
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %8 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !294
  %call34 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_start_wait_urb.descriptor to %struct._ddebug*), %struct.device* %dev27, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.27.251, i32 0, i32 0), i8* %arraydecay, i32 %call29, i8* %cond32, i32 %7, i32 %8)
  br label %out

if.else:                                          ; preds = %cond.end
  %status38 = getelementptr inbounds %struct.api_context, %struct.api_context* %ctx, i32 0, i32 1
  %9 = load i32, i32* %status38, align 8, !tbaa !451
  br label %out

out:                                              ; preds = %if.else, %if.then26, %if.then10, %entry
  %retval1.1 = phi i32 [ %call, %entry ], [ %9, %if.else ], [ %cond16, %if.then26 ], [ %cond16, %if.then10 ]
  %tobool40 = icmp ne i32* %actual_length, null
  br i1 %tobool40, label %if.then41, label %if.end43

if.then41:                                        ; preds = %out
  %actual_length42 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %10 = load i32, i32* %actual_length42, align 4, !tbaa !292
  store i32 %10, i32* %actual_length, align 4, !tbaa !90
  br label %if.end43

if.end43:                                         ; preds = %if.then41, %out
  call void bitcast (void (%struct.urb.824*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %urb)
  %11 = bitcast %struct.api_context* %ctx to i8*
  ret i32 %retval1.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @init_completion(%struct.completion* %x) #1 {
entry:
  %done = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 0
  store i32 0, i32* %done, align 8, !tbaa !454
  %wait = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 1
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wait, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.32.252, i32 0, i32 0), %struct.lock_class_key* @init_completion.__key)
  ret void
}

declare i64 @wait_for_completion_timeout(%struct.completion*, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_num.247(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !286
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_urb_dir_in.248(%struct.urb* %urb) #1 {
entry:
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %0 = load i32, i32* %transfer_flags, align 4, !tbaa !323
  %and = and i32 %0, 512
  %cmp = icmp eq i32 %and, 512
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #2

declare void @complete(%struct.completion*) #2

; Function Attrs: nounwind uwtable
define void @usb_enable_endpoint(%struct.usb_device* %dev, %struct.usb_host_endpoint* %ep, i1 zeroext %reset_ep) #0 {
entry:
  %frombool = zext i1 %reset_ep to i8
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call = call i32 @usb_endpoint_num.247(%struct.usb_endpoint_descriptor* %desc)
  %desc1 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call2 = call i32 @usb_endpoint_dir_out.255(%struct.usb_endpoint_descriptor* %desc1)
  %desc3 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call4 = call i32 @usb_endpoint_xfer_control.256(%struct.usb_endpoint_descriptor* %desc3)
  %tobool = trunc i8 %frombool to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @usb_hcd_reset_endpoint(%struct.usb_device* %dev, %struct.usb_host_endpoint* %ep)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool5 = icmp ne i32 %call2, 0
  %tobool6 = icmp ne i32 %call4, 0
  %or.cond = or i1 %tobool5, %tobool6
  br i1 %or.cond, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 17
  %idxprom = sext i32 %call to i64
  %arrayidx = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out, i64 0, i64 %idxprom
  store %struct.usb_host_endpoint* %ep, %struct.usb_host_endpoint** %arrayidx, align 8, !tbaa !48
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end
  %tobool9 = icmp eq i32 %call2, 0
  %tobool11 = icmp ne i32 %call4, 0
  %or.cond1 = or i1 %tobool9, %tobool11
  br i1 %or.cond1, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end8
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 16
  %idxprom13 = sext i32 %call to i64
  %arrayidx14 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in, i64 0, i64 %idxprom13
  store %struct.usb_host_endpoint* %ep, %struct.usb_host_endpoint** %arrayidx14, align 8, !tbaa !48
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.end8
  %enabled = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 8
  store i32 1, i32* %enabled, align 4, !tbaa !386
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_dir_out.255(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !286
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 128
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_control.256(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_return.258(i32 %i, %union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #8, !srcloc !455
  %add = add nsw i32 %i, %0
  ret i32 %add
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @device_is_registered(%struct.device* %dev) #1 {
entry:
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %state_in_sysfs = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 7
  %bf.load = load i8, i8* %state_in_sysfs, align 4
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  ret i32 %bf.cast
}

; Function Attrs: nounwind uwtable
define internal void @remove_intf_ep_devs(%struct.usb_interface* %intf) #0 {
entry:
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %0 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !148
  %ep_devs_created = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load = load i8, i8* %ep_devs_created, align 8
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 4
  %1 = load i8, i8* %bNumEndpoints, align 4, !tbaa !270
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 3
  %2 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !271
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %2, i64 %idxprom
  call void @usb_remove_ep_devs(%struct.usb_host_endpoint* %arrayidx)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %ep_devs_created2 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load3 = load i8, i8* %ep_devs_created2, align 8
  %bf.clear4 = and i8 %bf.load3, -3
  store i8 %bf.clear4, i8* %ep_devs_created2, align 8
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_reset_configuration(%struct.usb_device* %dev) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.212(%struct.usb_bus* %0)
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp eq i32 %1, 8
  br i1 %cmp, label %cleanup104, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %i.0 = phi i32 [ 1, %if.end ], [ %inc, %for.body ]
  %cmp2 = icmp slt i32 %i.0, 16
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @usb_disable_endpoint(%struct.usb_device* %dev, i32 %i.0, i1 zeroext true)
  %add = add nsw i32 %i.0, 128
  call void @usb_disable_endpoint(%struct.usb_device* %dev, i32 %add, i1 zeroext true)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %3 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !146
  call void @mutex_lock_nested(%struct.mutex* %3, i32 0)
  %call3 = call i32 @usb_disable_lpm(%struct.usb_device* %dev)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.then4, label %if.end8

if.then4:                                         ; preds = %for.end
  %4 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %bandwidth_mutex7 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %5 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex7, align 8, !tbaa !146
  call void @mutex_unlock(%struct.mutex* %5)
  br label %cleanup104

if.end8:                                          ; preds = %for.end
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc29, %if.end8
  %retval1.0 = phi i32 [ 0, %if.end8 ], [ %retval1.1, %for.inc29 ]
  %i.1 = phi i32 [ 0, %if.end8 ], [ %inc30, %for.inc29 ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %6 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv = zext i8 %6 to i32
  %cmp10 = icmp slt i32 %i.1, %conv
  br i1 %cmp10, label %for.body12, label %for.end31

for.body12:                                       ; preds = %for.cond9
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 3
  %idxprom = sext i32 %i.1 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %7 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !48
  %call13 = call %struct.usb_host_interface* @usb_altnum_to_altsetting(%struct.usb_interface* %7, i32 0)
  %tobool14 = icmp ne %struct.usb_host_interface* %call13, null
  br i1 %tobool14, label %if.end17, label %if.then15

if.then15:                                        ; preds = %for.body12
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %7, i32 0, i32 0
  %8 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !60
  %arrayidx16 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %8, i64 0
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %for.body12
  %alt.0 = phi %struct.usb_host_interface* [ %call13, %for.body12 ], [ %arrayidx16, %if.then15 ]
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %7, i32 0, i32 1
  %9 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !148
  %cmp18 = icmp ne %struct.usb_host_interface* %alt.0, %9
  br i1 %cmp18, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end17
  %cur_altsetting21 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %7, i32 0, i32 1
  %10 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting21, align 8, !tbaa !148
  %call22 = call i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %dev, %struct.usb_host_config* null, %struct.usb_host_interface* %10, %struct.usb_host_interface* %alt.0)
  br label %if.end23

if.end23:                                         ; preds = %if.then20, %if.end17
  %retval1.1 = phi i32 [ %call22, %if.then20 ], [ %retval1.0, %if.end17 ]
  %cmp24 = icmp slt i32 %retval1.1, 0
  %. = select i1 %cmp24, i32 5, i32 0
  %SwitchLeaf = icmp eq i32 %., 5
  br i1 %SwitchLeaf, label %for.end31, label %for.inc29

for.inc29:                                        ; preds = %if.end23
  %inc30 = add nsw i32 %i.1, 1
  br label %for.cond9

for.end31:                                        ; preds = %if.end23, %for.cond9
  %retval1.2 = phi i32 [ %retval1.1, %if.end23 ], [ %retval1.0, %for.cond9 ]
  %cmp32 = icmp slt i32 %retval1.2, 0
  br i1 %cmp32, label %reset_old_alts, label %if.end61

reset_old_alts:                                   ; preds = %if.end61, %for.end31
  %retval1.3 = phi i32 [ %retval1.2, %for.end31 ], [ %call65, %if.end61 ]
  br label %for.cond35

for.cond35:                                       ; preds = %for.inc57, %reset_old_alts
  %i.2.sink = phi i32 [ %dec58, %for.inc57 ], [ %i.1, %reset_old_alts ]
  %dec58 = add nsw i32 %i.2.sink, -1
  %cmp36 = icmp sge i32 %dec58, 0
  br i1 %cmp36, label %for.body38, label %for.end59

for.body38:                                       ; preds = %for.cond35
  %interface40 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 3
  %idxprom41 = sext i32 %dec58 to i64
  %arrayidx42 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface40, i64 0, i64 %idxprom41
  %11 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx42, align 8, !tbaa !48
  %call44 = call %struct.usb_host_interface* @usb_altnum_to_altsetting(%struct.usb_interface* %11, i32 0)
  %tobool45 = icmp ne %struct.usb_host_interface* %call44, null
  br i1 %tobool45, label %if.end49, label %if.then46

if.then46:                                        ; preds = %for.body38
  %altsetting47 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %11, i32 0, i32 0
  %12 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting47, align 8, !tbaa !60
  %arrayidx48 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %12, i64 0
  br label %if.end49

if.end49:                                         ; preds = %if.then46, %for.body38
  %alt43.0 = phi %struct.usb_host_interface* [ %call44, %for.body38 ], [ %arrayidx48, %if.then46 ]
  %cur_altsetting50 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %11, i32 0, i32 1
  %13 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting50, align 8, !tbaa !148
  %cmp51 = icmp ne %struct.usb_host_interface* %alt43.0, %13
  br i1 %cmp51, label %if.then53, label %for.inc57

if.then53:                                        ; preds = %if.end49
  %cur_altsetting54 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %11, i32 0, i32 1
  %14 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting54, align 8, !tbaa !148
  %call55 = call i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %dev, %struct.usb_host_config* null, %struct.usb_host_interface* %alt43.0, %struct.usb_host_interface* %14)
  br label %for.inc57

for.inc57:                                        ; preds = %if.then53, %if.end49
  br label %for.cond35

for.end59:                                        ; preds = %for.cond35
  call void @usb_enable_lpm(%struct.usb_device* %dev)
  %bandwidth_mutex60 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %15 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex60, align 8, !tbaa !146
  call void @mutex_unlock(%struct.mutex* %15)
  br label %cleanup104

if.end61:                                         ; preds = %for.end31
  %call62 = call i32 @__create_pipe.224(%struct.usb_device* %dev, i32 0)
  %or = or i32 -2147483648, %call62
  %desc63 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 0
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc63, i32 0, i32 4
  %16 = load i8, i8* %bConfigurationValue, align 1, !tbaa !147
  %conv64 = zext i8 %16 to i16
  %call65 = call i32 @usb_control_msg(%struct.usb_device* %dev, i32 %or, i8 zeroext 9, i8 zeroext 0, i16 zeroext %conv64, i16 zeroext 0, i8* null, i16 zeroext 0, i32 5000)
  %cmp66 = icmp slt i32 %call65, 0
  br i1 %cmp66, label %reset_old_alts, label %if.end69

if.end69:                                         ; preds = %if.end61
  %bandwidth_mutex70 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %17 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex70, align 8, !tbaa !146
  call void @mutex_unlock(%struct.mutex* %17)
  br label %for.cond71

for.cond71:                                       ; preds = %for.inc101, %if.end69
  %i.3 = phi i32 [ 0, %if.end69 ], [ %inc102, %for.inc101 ]
  %desc72 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 0
  %bNumInterfaces73 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc72, i32 0, i32 3
  %18 = load i8, i8* %bNumInterfaces73, align 4, !tbaa !65
  %conv74 = zext i8 %18 to i32
  %cmp75 = icmp slt i32 %i.3, %conv74
  br i1 %cmp75, label %for.body77, label %for.end103

for.body77:                                       ; preds = %for.cond71
  %interface79 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 3
  %idxprom80 = sext i32 %i.3 to i64
  %arrayidx81 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface79, i64 0, i64 %idxprom80
  %19 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx81, align 8, !tbaa !48
  %call83 = call %struct.usb_host_interface* @usb_altnum_to_altsetting(%struct.usb_interface* %19, i32 0)
  %tobool84 = icmp ne %struct.usb_host_interface* %call83, null
  br i1 %tobool84, label %if.end88, label %if.then85

if.then85:                                        ; preds = %for.body77
  %altsetting86 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 0
  %20 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting86, align 8, !tbaa !60
  %arrayidx87 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %20, i64 0
  br label %if.end88

if.end88:                                         ; preds = %if.then85, %for.body77
  %alt82.0 = phi %struct.usb_host_interface* [ %call83, %for.body77 ], [ %arrayidx87, %if.then85 ]
  %cur_altsetting89 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 1
  %21 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting89, align 8, !tbaa !148
  %cmp90 = icmp ne %struct.usb_host_interface* %alt82.0, %21
  br i1 %cmp90, label %if.then92, label %if.end93

if.then92:                                        ; preds = %if.end88
  call void @remove_intf_ep_devs(%struct.usb_interface* %19)
  call void @usb_remove_sysfs_intf_files(%struct.usb_interface* %19)
  br label %if.end93

if.end93:                                         ; preds = %if.then92, %if.end88
  %cur_altsetting94 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 1
  store %struct.usb_host_interface* %alt82.0, %struct.usb_host_interface** %cur_altsetting94, align 8, !tbaa !148
  call void @usb_enable_interface(%struct.usb_device* %dev, %struct.usb_interface* %19, i1 zeroext true)
  %dev95 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 7
  %call96 = call i32 @device_is_registered(%struct.device* %dev95)
  %tobool97 = icmp ne i32 %call96, 0
  br i1 %tobool97, label %if.then98, label %for.inc101

if.then98:                                        ; preds = %if.end93
  call void @usb_create_sysfs_intf_files(%struct.usb_interface* %19)
  call void @create_intf_ep_devs(%struct.usb_interface* %19)
  br label %for.inc101

for.inc101:                                       ; preds = %if.then98, %if.end93
  %inc102 = add nsw i32 %i.3, 1
  br label %for.cond71

for.end103:                                       ; preds = %for.cond71
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %dev)
  br label %cleanup104

cleanup104:                                       ; preds = %for.end103, %for.end59, %if.then4, %entry
  %retval.0 = phi i32 [ -12, %if.then4 ], [ %retval1.3, %for.end59 ], [ 0, %for.end103 ], [ -113, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_set_interface(%struct.usb_device* %dev, i32 %interface, i32 %alternate) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.212(%struct.usb_bus* %0)
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp eq i32 %1, 8
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %dev, i32 %interface)
  %tobool = icmp ne %struct.usb_interface* %call1, null
  br i1 %tobool, label %if.end13, label %do.body3

do.body3:                                         ; preds = %if.end
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_set_interface.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool4 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool4, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then7, label %cleanup

if.then7:                                         ; preds = %do.body3
  %dev8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %call9 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_set_interface.descriptor to %struct._ddebug*), %struct.device* %dev8, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.11.266, i32 0, i32 0), i32 %interface)
  br label %cleanup

if.end13:                                         ; preds = %if.end
  %unregistering = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 6
  %bf.load14 = load i8, i8* %unregistering, align 8
  %bf.lshr15 = lshr i8 %bf.load14, 2
  %bf.clear16 = and i8 %bf.lshr15, 1
  %bf.cast = zext i8 %bf.clear16 to i32
  %tobool17 = icmp ne i32 %bf.cast, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end13
  %call20 = call %struct.usb_host_interface* @usb_altnum_to_altsetting(%struct.usb_interface* %call1, i32 %alternate)
  %tobool21 = icmp ne %struct.usb_host_interface* %call20, null
  br i1 %tobool21, label %if.end25, label %if.then22

if.then22:                                        ; preds = %if.end19
  %2 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

if.end25:                                         ; preds = %if.end19
  %bandwidth_mutex = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %3 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex, align 8, !tbaa !146
  call void @mutex_lock_nested(%struct.mutex* %3, i32 0)
  %call26 = call i32 @usb_disable_lpm(%struct.usb_device* %dev)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %if.then28, label %if.end32

if.then28:                                        ; preds = %if.end25
  %4 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %bandwidth_mutex31 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %5 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex31, align 8, !tbaa !146
  call void @mutex_unlock(%struct.mutex* %5)
  br label %cleanup

if.end32:                                         ; preds = %if.end25
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 1
  %6 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !148
  %call33 = call i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %dev, %struct.usb_host_config* null, %struct.usb_host_interface* %6, %struct.usb_host_interface* %call20)
  %cmp34 = icmp slt i32 %call33, 0
  br i1 %cmp34, label %if.then36, label %if.end40

if.then36:                                        ; preds = %if.end32
  %7 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  call void @usb_enable_lpm(%struct.usb_device* %dev)
  %bandwidth_mutex39 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %8 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex39, align 8, !tbaa !146
  call void @mutex_unlock(%struct.mutex* %8)
  br label %cleanup

if.end40:                                         ; preds = %if.end32
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 29
  %9 = load i32, i32* %quirks, align 4, !tbaa !259
  %and41 = and i32 %9, 4
  %tobool42 = icmp ne i32 %and41, 0
  br i1 %tobool42, label %if.end48, label %if.else

if.else:                                          ; preds = %if.end40
  %call44 = call i32 @__create_pipe.224(%struct.usb_device* %dev, i32 0)
  %or = or i32 -2147483648, %call44
  %conv45 = trunc i32 %alternate to i16
  %conv46 = trunc i32 %interface to i16
  %call47 = call i32 @usb_control_msg(%struct.usb_device* %dev, i32 %or, i8 zeroext 11, i8 zeroext 1, i16 zeroext %conv45, i16 zeroext %conv46, i8* null, i16 zeroext 0, i32 5000)
  br label %if.end48

if.end48:                                         ; preds = %if.else, %if.end40
  %ret.0 = phi i32 [ %call47, %if.else ], [ -32, %if.end40 ]
  %cmp49 = icmp eq i32 %ret.0, -32
  br i1 %cmp49, label %land.lhs.true, label %if.else76

land.lhs.true:                                    ; preds = %if.end48
  %num_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 2
  %10 = load i32, i32* %num_altsetting, align 8, !tbaa !59
  %cmp51 = icmp eq i32 %10, 1
  br i1 %cmp51, label %do.body55, label %if.else76

do.body55:                                        ; preds = %land.lhs.true
  %bf.load56 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_set_interface.descriptor.15 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr57 = lshr i32 %bf.load56, 18
  %bf.clear58 = and i32 %bf.lshr57, 255
  %and59 = and i32 %bf.clear58, 1
  %tobool60 = icmp ne i32 %and59, 0
  %lnot61 = xor i1 %tobool60, true
  %lnot63 = xor i1 %lnot61, true
  %lnot.ext64 = zext i1 %lnot63 to i32
  %conv65 = sext i32 %lnot.ext64 to i64
  %expval66 = call i64 @llvm.expect.i64(i64 %conv65, i64 0)
  %tobool67 = icmp ne i64 %expval66, 0
  br i1 %tobool67, label %if.then68, label %if.end84

if.then68:                                        ; preds = %do.body55
  %dev69 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %call70 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_set_interface.descriptor.15 to %struct._ddebug*), %struct.device* %dev69, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.16.269, i32 0, i32 0), i32 %interface, i32 %alternate)
  br label %if.end84

if.else76:                                        ; preds = %land.lhs.true, %if.end48
  %cmp77 = icmp slt i32 %ret.0, 0
  br i1 %cmp77, label %if.then79, label %if.end84

if.then79:                                        ; preds = %if.else76
  %cur_altsetting80 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 1
  %11 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting80, align 8, !tbaa !148
  %call81 = call i32 @usb_hcd_alloc_bandwidth(%struct.usb_device* %dev, %struct.usb_host_config* null, %struct.usb_host_interface* %call20, %struct.usb_host_interface* %11)
  call void @usb_enable_lpm(%struct.usb_device* %dev)
  %bandwidth_mutex82 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %12 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex82, align 8, !tbaa !146
  call void @mutex_unlock(%struct.mutex* %12)
  br label %cleanup

if.end84:                                         ; preds = %if.else76, %if.then68, %do.body55
  %manual.0 = phi i32 [ 1, %if.then68 ], [ 1, %do.body55 ], [ 0, %if.else76 ]
  %bandwidth_mutex85 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 17
  %13 = load %struct.mutex*, %struct.mutex** %bandwidth_mutex85, align 8, !tbaa !146
  call void @mutex_unlock(%struct.mutex* %13)
  %cur_altsetting86 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 1
  %14 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting86, align 8, !tbaa !148
  %cmp87 = icmp ne %struct.usb_host_interface* %14, %call20
  br i1 %cmp87, label %if.then89, label %if.end90

if.then89:                                        ; preds = %if.end84
  call void @remove_intf_ep_devs(%struct.usb_interface* %call1)
  call void @usb_remove_sysfs_intf_files(%struct.usb_interface* %call1)
  br label %if.end90

if.end90:                                         ; preds = %if.then89, %if.end84
  call void @usb_disable_interface(%struct.usb_device* %dev, %struct.usb_interface* %call1, i1 zeroext true)
  %cur_altsetting91 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 1
  store %struct.usb_host_interface* %call20, %struct.usb_host_interface** %cur_altsetting91, align 8, !tbaa !148
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %dev)
  %tobool92 = icmp ne i32 %manual.0, 0
  br i1 %tobool92, label %if.then93, label %if.end107

if.then93:                                        ; preds = %if.end90
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then93
  %i.0 = phi i32 [ 0, %if.then93 ], [ %inc, %for.body ]
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %call20, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 4
  %15 = load i8, i8* %bNumEndpoints, align 4, !tbaa !270
  %conv94 = zext i8 %15 to i32
  %cmp95 = icmp slt i32 %i.0, %conv94
  br i1 %cmp95, label %for.body, label %if.end107

for.body:                                         ; preds = %for.cond
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %call20, i32 0, i32 3
  %16 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !271
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %16, i64 %idxprom
  %desc97 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 0
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc97, i32 0, i32 2
  %17 = load i8, i8* %bEndpointAddress, align 2, !tbaa !449
  %conv98 = zext i8 %17 to i32
  %and99 = and i32 15, %conv98
  %call100 = call i32 @__create_pipe.224(%struct.usb_device* %dev, i32 %and99)
  %and101 = and i32 %conv98, 128
  %tobool102 = icmp ne i32 %and101, 0
  %lnot103 = xor i1 %tobool102, true
  %cond = select i1 %lnot103, i32 0, i32 128
  %or105 = or i32 %call100, %cond
  %call106 = call i32 @usb_clear_halt(%struct.usb_device* %dev, i32 %or105)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end107:                                        ; preds = %for.cond, %if.end90
  call void @usb_enable_interface(%struct.usb_device* %dev, %struct.usb_interface* %call1, i1 zeroext true)
  %dev108 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %call109 = call i32 @device_is_registered(%struct.device* %dev108)
  %tobool110 = icmp ne i32 %call109, 0
  br i1 %tobool110, label %if.then111, label %cleanup

if.then111:                                       ; preds = %if.end107
  call void @usb_create_sysfs_intf_files(%struct.usb_interface* %call1)
  call void @create_intf_ep_devs(%struct.usb_interface* %call1)
  br label %cleanup

cleanup:                                          ; preds = %if.then111, %if.end107, %if.then79, %if.then36, %if.then28, %if.then22, %if.end13, %if.then7, %do.body3, %entry
  %retval.0 = phi i32 [ -12, %if.then28 ], [ %call33, %if.then36 ], [ %ret.0, %if.then79 ], [ -22, %if.then22 ], [ -113, %entry ], [ -22, %if.then7 ], [ -22, %do.body3 ], [ -19, %if.end13 ], [ 0, %if.then111 ], [ 0, %if.end107 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_clear_halt(%struct.usb_device* %dev, i32 %pipe) #0 {
entry:
  %shr = ashr i32 %pipe, 15
  %and = and i32 %shr, 15
  %and1 = and i32 %pipe, 128
  %tobool = icmp ne i32 %and1, 0
  %or = or i32 %and, 128
  %or.and = select i1 %tobool, i32 %or, i32 %and
  %call = call i32 @__create_pipe.224(%struct.usb_device* %dev, i32 0)
  %or2 = or i32 -2147483648, %call
  %conv = trunc i32 %or.and to i16
  %call3 = call i32 @usb_control_msg(%struct.usb_device* %dev, i32 %or2, i8 zeroext 1, i8 zeroext 2, i16 zeroext 0, i16 zeroext %conv, i8* null, i16 zeroext 0, i32 5000)
  %cmp = icmp slt i32 %call3, 0
  br i1 %cmp, label %cleanup, label %if.end6

if.end6:                                          ; preds = %entry
  call void @usb_reset_endpoint(%struct.usb_device* %dev, i32 %or.and)
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %entry
  %retval.0 = phi i32 [ 0, %if.end6 ], [ %call3, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_reset_endpoint(%struct.usb_device* %dev, i32 %epaddr) #0 {
entry:
  %and = and i32 %epaddr, 15
  %and1 = and i32 %epaddr, 128
  %tobool = icmp ne i32 %and1, 0
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 16
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 17
  %ep_in.sink = select i1 %tobool, [16 x %struct.usb_host_endpoint*]* %ep_in, [16 x %struct.usb_host_endpoint*]* %ep_out
  %idxprom2 = zext i32 %and to i64
  %arrayidx3 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in.sink, i64 0, i64 %idxprom2
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx3, align 8, !tbaa !48
  %tobool4 = icmp ne %struct.usb_host_endpoint* %0, null
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %entry
  call void @usb_hcd_reset_endpoint(%struct.usb_device* %dev, %struct.usb_host_endpoint* %0)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_get_status(%struct.usb_device* %dev, i32 %type, i32 %target, i8* %data) #0 {
entry:
  %call.i = call i8* @__kmalloc(i64 2, i32 208) #8
  %0 = bitcast i8* %call.i to i16*
  %tobool = icmp ne i16* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @__create_pipe.224(%struct.usb_device* %dev, i32 0)
  %or = or i32 -2147483648, %call1
  %or2 = or i32 %or, 128
  %or3 = or i32 128, %type
  %conv = trunc i32 %or3 to i8
  %conv4 = trunc i32 %target to i16
  %1 = bitcast i16* %0 to i8*
  %call5 = call i32 @usb_control_msg(%struct.usb_device* %dev, i32 %or2, i8 zeroext 0, i8 zeroext %conv, i16 zeroext 0, i16 zeroext %conv4, i8* %1, i16 zeroext 2, i32 5000)
  %2 = load i16, i16* %0, align 2, !tbaa !143
  %3 = bitcast i8* %data to i16*
  store i16 %2, i16* %3, align 2, !tbaa !143
  %4 = bitcast i16* %0 to i8*
  call void @kfree(i8* %4)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call5, %if.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_get_descriptor(%struct.usb_device* %dev, i8 zeroext %type, i8 zeroext %index, i8* %buf, i32 %size) #0 {
entry:
  %conv = sext i32 %size to i64
  call void @llvm.memset.p0i8.i64(i8* %buf, i8 0, i64 %conv, i32 1, i1 false)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %result.0 = phi i32 [ undef, %entry ], [ %result.1, %for.inc ]
  %cmp = icmp slt i32 %i.0, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @__create_pipe.224(%struct.usb_device* %dev, i32 0)
  %or = or i32 -2147483648, %call
  %or2 = or i32 %or, 128
  %conv3 = zext i8 %type to i32
  %shl = shl i32 %conv3, 8
  %conv4 = zext i8 %index to i32
  %add = add nsw i32 %shl, %conv4
  %conv5 = trunc i32 %add to i16
  %conv6 = trunc i32 %size to i16
  %call7 = call i32 @usb_control_msg(%struct.usb_device* %dev, i32 %or2, i8 zeroext 6, i8 zeroext -128, i16 zeroext %conv5, i16 zeroext 0, i8* %buf, i16 zeroext %conv6, i32 5000)
  %cmp8 = icmp sle i32 %call7, 0
  %cmp10 = icmp ne i32 %call7, -110
  %or.cond = and i1 %cmp8, %cmp10
  br i1 %or.cond, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %cmp12 = icmp sgt i32 %call7, 1
  br i1 %cmp12, label %land.lhs.true14, label %for.end

land.lhs.true14:                                  ; preds = %if.end
  %arrayidx = getelementptr inbounds i8, i8* %buf, i64 1
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !84
  %conv15 = zext i8 %0 to i32
  %conv16 = zext i8 %type to i32
  %cmp17 = icmp ne i32 %conv15, %conv16
  br i1 %cmp17, label %for.inc, label %for.end

for.inc:                                          ; preds = %land.lhs.true14, %for.body
  %result.1 = phi i32 [ %call7, %for.body ], [ -61, %land.lhs.true14 ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %land.lhs.true14, %if.end, %for.cond
  %result.2 = phi i32 [ %call7, %land.lhs.true14 ], [ %call7, %if.end ], [ %result.0, %for.cond ]
  ret i32 %result.2
}

; Function Attrs: nounwind uwtable
define void @usb_sg_cancel(%struct.usb_sg_request* %io) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %lock = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  %call = call %struct.raw_spinlock* @spinlock_check.274(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %status = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 0
  %4 = load i32, i32* %status, align 8, !tbaa !456
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.end31, label %if.then

if.then:                                          ; preds = %entry
  %status5 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 0
  store i32 -104, i32* %status5, align 8, !tbaa !456
  %lock6 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  call void @spin_unlock.204(%struct.spinlock* %lock6)
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %LeafBlock ]
  %entries = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  %5 = load i32, i32* %entries, align 4, !tbaa !458
  %cmp7 = icmp slt i32 %i.0, %5
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %urbs = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %6 = load %struct.urb**, %struct.urb*** %urbs, align 8, !tbaa !459
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.urb*, %struct.urb** %6, i64 %idxprom
  %7 = load %struct.urb*, %struct.urb** %arrayidx, align 8, !tbaa !48
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %7, i32 0, i32 8
  %8 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !210
  %tobool9 = icmp ne %struct.usb_device* %8, null
  br i1 %tobool9, label %if.end, label %LeafBlock

if.end:                                           ; preds = %for.body
  %urbs11 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %9 = load %struct.urb**, %struct.urb*** %urbs11, align 8, !tbaa !459
  %idxprom12 = sext i32 %i.0 to i64
  %arrayidx13 = getelementptr inbounds %struct.urb*, %struct.urb** %9, i64 %idxprom12
  %10 = load %struct.urb*, %struct.urb** %arrayidx13, align 8, !tbaa !48
  %call14 = call i32 bitcast (i32 (%struct.urb.824*)* @usb_unlink_urb to i32 (%struct.urb*)*)(%struct.urb* %10)
  switch i32 %call14, label %if.then25 [
    i32 -115, label %LeafBlock
    i32 -19, label %LeafBlock
    i32 -16, label %LeafBlock
    i32 -43, label %LeafBlock
  ]

if.then25:                                        ; preds = %if.end
  %11 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.then25, %if.end, %if.end, %if.end, %if.end, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %lock30 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  call void @spin_lock.202(%struct.spinlock* %lock30)
  br label %if.end31

if.end31:                                         ; preds = %for.end, %entry
  %lock32 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  call void @spin_unlock_irqrestore.276(%struct.spinlock* %lock32, i64 %call2)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check.274(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore.276(%struct.spinlock* %lock, i64 %flags) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_sg_wait(%struct.usb_sg_request* %io) #0 {
entry:
  %entries1 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  %0 = load i32, i32* %entries1, align 4, !tbaa !458
  %lock = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  call void @spin_lock_irq.277(%struct.spinlock* %lock)
  br label %while.cond

while.cond:                                       ; preds = %if.end32, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %i.1, %if.end32 ]
  %cmp = icmp slt i32 %i.0, %0
  br i1 %cmp, label %land.rhs, label %while.end

land.rhs:                                         ; preds = %while.cond
  %status = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 0
  %1 = load i32, i32* %status, align 8, !tbaa !456
  %tobool = icmp ne i32 %1, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  %dev = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 3
  %2 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !460
  %urbs = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %3 = load %struct.urb**, %struct.urb*** %urbs, align 8, !tbaa !459
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.urb*, %struct.urb** %3, i64 %idxprom
  %4 = load %struct.urb*, %struct.urb** %arrayidx, align 8, !tbaa !48
  %dev2 = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 8
  store %struct.usb_device* %2, %struct.usb_device** %dev2, align 8, !tbaa !210
  %urbs3 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %5 = load %struct.urb**, %struct.urb*** %urbs3, align 8, !tbaa !459
  %idxprom4 = sext i32 %i.0 to i64
  %arrayidx5 = getelementptr inbounds %struct.urb*, %struct.urb** %5, i64 %idxprom4
  %6 = load %struct.urb*, %struct.urb** %arrayidx5, align 8, !tbaa !48
  %call = call i32 bitcast (i32 (%struct.urb.824*, i32)* @usb_submit_urb to i32 (%struct.urb*, i32)*)(%struct.urb* %6, i32 32)
  %lock6 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  call void @spin_unlock_irq.278(%struct.spinlock* %lock6)
  %Pivot6 = icmp slt i32 %call, -6
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %while.body
  %Pivot = icmp slt i32 %call, 0
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %call, 0
  br i1 %SwitchLeaf4, label %sw.bb7, label %sw.default

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %call, -6
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.default

LeafBlock:                                        ; preds = %while.body
  %.off = add i32 %call, 12
  %SwitchLeaf = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock, %LeafBlock1
  call void @yield()
  br label %sw.epilog

sw.bb7:                                           ; preds = %LeafBlock3
  %inc = add nsw i32 %i.0, 1
  call void @cpu_relax()
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  %urbs8 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %7 = load %struct.urb**, %struct.urb*** %urbs8, align 8, !tbaa !459
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds %struct.urb*, %struct.urb** %7, i64 %idxprom9
  %8 = load %struct.urb*, %struct.urb** %arrayidx10, align 8, !tbaa !48
  %status11 = getelementptr inbounds %struct.urb, %struct.urb* %8, i32 0, i32 12
  store i32 %call, i32* %status11, align 8, !tbaa !291
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_sg_wait.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool13 = icmp ne i32 %and, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot15 = xor i1 %lnot14, true
  %lnot.ext = zext i1 %lnot15 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool16 = icmp ne i64 %expval, 0
  br i1 %tobool16, label %if.then, label %do.end21

if.then:                                          ; preds = %sw.default
  %dev17 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 3
  %9 = load %struct.usb_device*, %struct.usb_device** %dev17, align 8, !tbaa !460
  %dev18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %9, i32 0, i32 11
  %call19 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_sg_wait.descriptor to %struct._ddebug*), %struct.device* %dev18, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.279, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.usb_sg_wait, i32 0, i32 0), i32 %call)
  br label %do.end21

do.end21:                                         ; preds = %if.then, %sw.default
  call void @usb_sg_cancel(%struct.usb_sg_request* %io)
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end21, %sw.bb7, %sw.bb
  %i.1 = phi i32 [ %i.0, %sw.bb ], [ %i.0, %do.end21 ], [ %inc, %sw.bb7 ]
  %retval.0 = phi i32 [ 0, %sw.bb ], [ %call, %do.end21 ], [ %call, %sw.bb7 ]
  %lock22 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  call void @spin_lock_irq.277(%struct.spinlock* %lock22)
  %tobool23 = icmp ne i32 %retval.0, 0
  br i1 %tobool23, label %land.lhs.true, label %if.end32

land.lhs.true:                                    ; preds = %sw.epilog
  %status24 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 0
  %10 = load i32, i32* %status24, align 8, !tbaa !456
  %cmp25 = icmp eq i32 %10, 0
  br i1 %cmp25, label %if.then30, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %status27 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 0
  %11 = load i32, i32* %status27, align 8, !tbaa !456
  %cmp28 = icmp eq i32 %11, -104
  br i1 %cmp28, label %if.then30, label %if.end32

if.then30:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %status31 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 0
  store i32 %retval.0, i32* %status31, align 8, !tbaa !456
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %lor.lhs.false, %sw.epilog
  br label %while.cond

while.end:                                        ; preds = %land.rhs, %while.cond
  %sub = sub nsw i32 %0, %i.0
  %count = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 7
  %12 = load i32, i32* %count, align 8, !tbaa !461
  %sub33 = sub nsw i32 %12, %sub
  store i32 %sub33, i32* %count, align 8, !tbaa !461
  %count34 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 7
  %13 = load i32, i32* %count34, align 8, !tbaa !461
  %cmp35 = icmp eq i32 %13, 0
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %while.end
  %complete = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 8
  call void @complete(%struct.completion* %complete)
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %while.end
  %lock39 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  call void @spin_unlock_irq.278(%struct.spinlock* %lock39)
  %complete40 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 8
  call void @wait_for_completion(%struct.completion* %complete40)
  call void @sg_clean(%struct.usb_sg_request* %io)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_irq.277(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irq.278(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

declare void @yield() #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @cpu_relax() #1 {
entry:
  call void @rep_nop()
  ret void
}

declare void @wait_for_completion(%struct.completion*) #2

; Function Attrs: nounwind uwtable
define internal void @sg_clean(%struct.usb_sg_request* %io) #0 {
entry:
  %urbs = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %0 = load %struct.urb**, %struct.urb*** %urbs, align 8, !tbaa !459
  %tobool = icmp ne %struct.urb** %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %entries = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  %1 = load i32, i32* %entries, align 4, !tbaa !458
  %dec = add nsw i32 %1, -1
  store i32 %dec, i32* %entries, align 4, !tbaa !458
  %tobool1 = icmp ne i32 %1, 0
  %urbs2 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %2 = load %struct.urb**, %struct.urb*** %urbs2, align 8, !tbaa !459
  br i1 %tobool1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %entries3 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  %3 = load i32, i32* %entries3, align 4, !tbaa !458
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %struct.urb*, %struct.urb** %2, i64 %idxprom
  %4 = load %struct.urb*, %struct.urb** %arrayidx, align 8, !tbaa !48
  call void bitcast (void (%struct.urb.824*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %4)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %5 = bitcast %struct.urb** %2 to i8*
  call void @kfree(i8* %5)
  %urbs5 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  store %struct.urb** null, %struct.urb*** %urbs5, align 8, !tbaa !459
  br label %if.end

if.end:                                           ; preds = %while.end, %entry
  %dev = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 3
  store %struct.usb_device* null, %struct.usb_device** %dev, align 8, !tbaa !460
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rep_nop() #1 {
entry:
  call void asm sideeffect "rep; nop", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !462
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_sg_init(%struct.usb_sg_request* %io, %struct.usb_device* %dev, i32 %pipe, i32 %period, %struct.scatterlist* %sg, i32 %nents, i64 %length, i32 %mem_flags) #0 {
entry:
  %tobool = icmp ne %struct.usb_sg_request* %io, null
  %tobool1 = icmp ne %struct.usb_device* %dev, null
  %or.cond = and i1 %tobool, %tobool1
  %tobool3 = icmp ne %struct.scatterlist* %sg, null
  %or.cond3 = and i1 %or.cond, %tobool3
  br i1 %or.cond3, label %lor.lhs.false4, label %cleanup94

lor.lhs.false4:                                   ; preds = %entry
  %shr = lshr i32 %pipe, 30
  %and = and i32 %shr, 3
  %cmp = icmp eq i32 %and, 2
  br i1 %cmp, label %cleanup94, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false4
  %shr6 = lshr i32 %pipe, 30
  %and7 = and i32 %shr6, 3
  %cmp8 = icmp eq i32 %and7, 0
  %cmp10 = icmp sle i32 %nents, 0
  %or.cond4 = or i1 %cmp8, %cmp10
  br i1 %or.cond4, label %cleanup94, label %do.body

do.body:                                          ; preds = %lor.lhs.false5
  %lock = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  %call = call %struct.raw_spinlock* @spinlock_check.274(%struct.spinlock* %lock)
  %lock12 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 2
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock12, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.280, i32 0, i32 0), %struct.lock_class_key* @usb_sg_init.__key)
  %dev15 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 3
  store %struct.usb_device* %dev, %struct.usb_device** %dev15, align 8, !tbaa !460
  %pipe16 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 4
  store i32 %pipe, i32* %pipe16, align 8, !tbaa !463
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %sg_tablesize = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %1, i32 0, i32 7
  %2 = load i32, i32* %sg_tablesize, align 4, !tbaa !464
  %cmp17 = icmp ugt i32 %2, 0
  %nents.sink = select i1 %cmp17, i32 1, i32 %nents
  %use_sg.0 = select i1 %cmp17, i32 1, i32 0
  %entries19 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  store i32 %nents.sink, i32* %entries19, align 4, !tbaa !458
  %entries21 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  %3 = load i32, i32* %entries21, align 4, !tbaa !458
  %conv = sext i32 %3 to i64
  %mul = mul i64 %conv, 8
  %call.i = call i8* @__kmalloc(i64 %mul, i32 %mem_flags) #8
  %4 = bitcast i8* %call.i to %struct.urb**
  %urbs = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  store %struct.urb** %4, %struct.urb*** %urbs, align 8, !tbaa !459
  %urbs23 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %5 = load %struct.urb**, %struct.urb*** %urbs23, align 8, !tbaa !459
  %tobool24 = icmp ne %struct.urb** %5, null
  br i1 %tobool24, label %if.end26, label %nomem

if.end26:                                         ; preds = %do.body
  %and27 = and i32 %pipe, 128
  %tobool28 = icmp ne i32 %and27, 0
  %or = or i32 128, 1
  %or. = select i1 %tobool28, i32 %or, i32 128
  br label %for.cond

for.cond:                                         ; preds = %for.inc83, %if.end26
  %i.0 = phi i32 [ 0, %if.end26 ], [ %inc84, %for.inc83 ]
  %length.addr.0 = phi i64 [ %length, %if.end26 ], [ %length.addr.3, %for.inc83 ]
  %sg.addr.0 = phi %struct.scatterlist* [ %sg, %if.end26 ], [ %call85, %for.inc83 ]
  %entries31 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  %6 = load i32, i32* %entries31, align 4, !tbaa !458
  %cmp32 = icmp slt i32 %i.0, %6
  br i1 %cmp32, label %for.body, label %for.end86

for.body:                                         ; preds = %for.cond
  %call34 = call %struct.urb* bitcast (%struct.urb.824* (i32, i32)* @usb_alloc_urb to %struct.urb* (i32, i32)*)(i32 0, i32 %mem_flags)
  %tobool35 = icmp ne %struct.urb* %call34, null
  br i1 %tobool35, label %if.end38, label %if.then36

if.then36:                                        ; preds = %for.body
  %entries37 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  store i32 %i.0, i32* %entries37, align 4, !tbaa !458
  br label %NodeBlock

if.end38:                                         ; preds = %for.body
  %urbs39 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %7 = load %struct.urb**, %struct.urb*** %urbs39, align 8, !tbaa !459
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.urb*, %struct.urb** %7, i64 %idxprom
  store %struct.urb* %call34, %struct.urb** %arrayidx, align 8, !tbaa !48
  %dev40 = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 8
  store %struct.usb_device* null, %struct.usb_device** %dev40, align 8, !tbaa !210
  %pipe41 = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 10
  store i32 %pipe, i32* %pipe41, align 8, !tbaa !212
  %interval = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 25
  store i32 %period, i32* %interval, align 8, !tbaa !296
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 13
  store i32 %or., i32* %transfer_flags, align 4, !tbaa !323
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 28
  store void (%struct.urb*)* @sg_complete, void (%struct.urb*)** %complete, align 8, !tbaa !295
  %8 = bitcast %struct.usb_sg_request* %io to i8*
  %context = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 27
  store i8* %8, i8** %context, align 8, !tbaa !290
  %sg42 = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 16
  store %struct.scatterlist* %sg.addr.0, %struct.scatterlist** %sg42, align 8, !tbaa !329
  %tobool43 = icmp ne i32 %use_sg.0, 0
  br i1 %tobool43, label %if.then44, label %if.else56

if.then44:                                        ; preds = %if.end38
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 14
  store i8* null, i8** %transfer_buffer, align 8, !tbaa !293
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 18
  store i32 %nents, i32* %num_sgs, align 4, !tbaa !330
  %conv45 = trunc i64 %length.addr.0 to i32
  %cmp46 = icmp eq i32 %conv45, 0
  br i1 %cmp46, label %if.then48, label %if.end81

if.then48:                                        ; preds = %if.then44
  br label %for.cond49

for.cond49:                                       ; preds = %for.body52, %if.then48
  %len.0 = phi i32 [ %conv45, %if.then48 ], [ %add, %for.body52 ]
  %sg2.0 = phi %struct.scatterlist* [ %sg.addr.0, %if.then48 ], [ %call54, %for.body52 ]
  %j.0 = phi i32 [ 0, %if.then48 ], [ %inc, %for.body52 ]
  %cmp50 = icmp slt i32 %j.0, %nents
  br i1 %cmp50, label %for.body52, label %if.end81

for.body52:                                       ; preds = %for.cond49
  %length53 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg2.0, i32 0, i32 3
  %9 = load i32, i32* %length53, align 4, !tbaa !378
  %add = add i32 %len.0, %9
  %inc = add nsw i32 %j.0, 1
  %call54 = call %struct.scatterlist* @sg_next(%struct.scatterlist* %sg2.0)
  br label %for.cond49

if.else56:                                        ; preds = %if.end38
  %call57 = call %struct.page* @sg_page.281(%struct.scatterlist* %sg.addr.0)
  %call58 = call i32 @PageHighMem()
  %tobool59 = icmp ne i32 %call58, 0
  br i1 %tobool59, label %if.end65, label %if.then60

if.then60:                                        ; preds = %if.else56
  %call61 = call i8* @sg_virt.282(%struct.scatterlist* %sg.addr.0)
  br label %if.end65

if.end65:                                         ; preds = %if.then60, %if.else56
  %.sink = phi i8* [ %call61, %if.then60 ], [ null, %if.else56 ]
  %transfer_buffer64 = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 14
  store i8* %.sink, i8** %transfer_buffer64, align 8, !tbaa !293
  %length66 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg.addr.0, i32 0, i32 3
  %10 = load i32, i32* %length66, align 4, !tbaa !378
  %tobool67 = icmp ne i64 %length.addr.0, 0
  br i1 %tobool67, label %if.then68, label %if.end81

if.then68:                                        ; preds = %if.end65
  %conv69 = zext i32 %10 to i64
  %cmp70 = icmp ult i64 %conv69, %length.addr.0
  %conv69.length.addr.0 = select i1 %cmp70, i64 %conv69, i64 %length.addr.0
  %conv72 = trunc i64 %conv69.length.addr.0 to i32
  %conv73 = zext i32 %conv72 to i64
  %sub = sub i64 %length.addr.0, %conv73
  %cmp74 = icmp eq i64 %sub, 0
  br i1 %cmp74, label %if.then76, label %if.end81

if.then76:                                        ; preds = %if.then68
  %add77 = add nsw i32 %i.0, 1
  %entries78 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  store i32 %add77, i32* %entries78, align 4, !tbaa !458
  br label %if.end81

if.end81:                                         ; preds = %if.then76, %if.then68, %if.end65, %for.cond49, %if.then44
  %length.addr.2 = phi i64 [ %length.addr.0, %for.cond49 ], [ %length.addr.0, %if.then44 ], [ %length.addr.0, %if.end65 ], [ %sub, %if.then76 ], [ %sub, %if.then68 ]
  %len.3 = phi i32 [ %conv45, %if.then44 ], [ %len.0, %for.cond49 ], [ %10, %if.end65 ], [ %conv72, %if.then76 ], [ %conv72, %if.then68 ]
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %call34, i32 0, i32 19
  store i32 %len.3, i32* %transfer_buffer_length, align 8, !tbaa !294
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end81, %if.then36
  %length.addr.3 = phi i64 [ %length.addr.2, %if.end81 ], [ %length.addr.0, %if.then36 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end81 ], [ 6, %if.then36 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 6
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 6
  br i1 %SwitchLeaf2, label %nomem, label %cleanup94

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc83, label %cleanup94

for.inc83:                                        ; preds = %LeafBlock
  %inc84 = add nsw i32 %i.0, 1
  %call85 = call %struct.scatterlist* @sg_next(%struct.scatterlist* %sg.addr.0)
  br label %for.cond

for.end86:                                        ; preds = %for.cond
  %urbs87 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 6
  %11 = load %struct.urb**, %struct.urb*** %urbs87, align 8, !tbaa !459
  %dec = add nsw i32 %i.0, -1
  %idxprom88 = sext i32 %dec to i64
  %arrayidx89 = getelementptr inbounds %struct.urb*, %struct.urb** %11, i64 %idxprom88
  %12 = load %struct.urb*, %struct.urb** %arrayidx89, align 8, !tbaa !48
  %transfer_flags90 = getelementptr inbounds %struct.urb, %struct.urb* %12, i32 0, i32 13
  %13 = load i32, i32* %transfer_flags90, align 4, !tbaa !323
  %and91 = and i32 %13, -129
  store i32 %and91, i32* %transfer_flags90, align 4, !tbaa !323
  %entries92 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 5
  %14 = load i32, i32* %entries92, align 4, !tbaa !458
  %count = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 7
  store i32 %14, i32* %count, align 8, !tbaa !461
  %status = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 0
  store i32 0, i32* %status, align 8, !tbaa !456
  %bytes = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 1
  store i64 0, i64* %bytes, align 8, !tbaa !465
  %complete93 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %io, i32 0, i32 8
  call void @init_completion(%struct.completion* %complete93)
  br label %cleanup94

nomem:                                            ; preds = %LeafBlock1, %do.body
  call void @sg_clean(%struct.usb_sg_request* %io)
  br label %cleanup94

cleanup94:                                        ; preds = %nomem, %for.end86, %LeafBlock, %LeafBlock1, %lor.lhs.false5, %lor.lhs.false4, %entry
  %retval.0 = phi i32 [ -12, %nomem ], [ 0, %for.end86 ], [ -22, %lor.lhs.false5 ], [ -22, %lor.lhs.false4 ], [ -22, %entry ], [ undef, %LeafBlock ], [ undef, %LeafBlock1 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sg_complete(%struct.urb* %urb) #0 {
entry:
  %context = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  %0 = load i8*, i8** %context, align 8, !tbaa !290
  %1 = bitcast i8* %0 to %struct.usb_sg_request*
  %status1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 12
  %2 = load i32, i32* %status1, align 8, !tbaa !291
  %lock = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 2
  call void @spin_lock.202(%struct.spinlock* %lock)
  %status2 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 0
  %3 = load i32, i32* %status2, align 8, !tbaa !456
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %status3 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 0
  %4 = load i32, i32* %status3, align 8, !tbaa !456
  %cmp = icmp ne i32 %4, -104
  %cmp4 = icmp ne i32 %2, -104
  %or.cond = or i1 %cmp, %cmp4
  br i1 %or.cond, label %land.lhs.true5, label %if.end

land.lhs.true5:                                   ; preds = %land.lhs.true
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %5 = load i32, i32* %actual_length, align 4, !tbaa !292
  %tobool6 = icmp ne i32 %5, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true5
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 9
  %6 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !218
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %6, i32 0, i32 0
  %call = call i32 @usb_endpoint_num.247(%struct.usb_endpoint_descriptor* %desc)
  %call8 = call i32 @usb_urb_dir_in.248(%struct.urb* %urb)
  %7 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true5, %land.lhs.true, %entry
  %status12 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 0
  %8 = load i32, i32* %status12, align 8, !tbaa !456
  %cmp13 = icmp eq i32 %8, 0
  br i1 %cmp13, label %switch.early.test, label %if.end57

switch.early.test:                                ; preds = %if.end
  switch i32 %2, label %if.then18 [
    i32 -104, label %if.end57
    i32 0, label %if.end57
  ]

if.then18:                                        ; preds = %switch.early.test
  %status19 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 0
  store i32 %2, i32* %status19, align 8, !tbaa !456
  %lock20 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 2
  call void @spin_unlock.204(%struct.spinlock* %lock20)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then18
  %i.0 = phi i32 [ 0, %if.then18 ], [ %inc, %for.inc ]
  %found.0 = phi i32 [ 0, %if.then18 ], [ %found.3, %for.inc ]
  %entries = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 5
  %9 = load i32, i32* %entries, align 4, !tbaa !458
  %cmp21 = icmp slt i32 %i.0, %9
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %urbs = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 6
  %10 = load %struct.urb**, %struct.urb*** %urbs, align 8, !tbaa !459
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.urb*, %struct.urb** %10, i64 %idxprom
  %11 = load %struct.urb*, %struct.urb** %arrayidx, align 8, !tbaa !48
  %tobool22 = icmp ne %struct.urb* %11, null
  br i1 %tobool22, label %lor.lhs.false23, label %for.inc

lor.lhs.false23:                                  ; preds = %for.body
  %urbs24 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 6
  %12 = load %struct.urb**, %struct.urb*** %urbs24, align 8, !tbaa !459
  %idxprom25 = sext i32 %i.0 to i64
  %arrayidx26 = getelementptr inbounds %struct.urb*, %struct.urb** %12, i64 %idxprom25
  %13 = load %struct.urb*, %struct.urb** %arrayidx26, align 8, !tbaa !48
  %dev27 = getelementptr inbounds %struct.urb, %struct.urb* %13, i32 0, i32 8
  %14 = load %struct.usb_device*, %struct.usb_device** %dev27, align 8, !tbaa !210
  %tobool28 = icmp ne %struct.usb_device* %14, null
  br i1 %tobool28, label %if.end30, label %for.inc

if.end30:                                         ; preds = %lor.lhs.false23
  %tobool31 = icmp ne i32 %found.0, 0
  %urbs33 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 6
  %15 = load %struct.urb**, %struct.urb*** %urbs33, align 8, !tbaa !459
  %idxprom34 = sext i32 %i.0 to i64
  %arrayidx35 = getelementptr inbounds %struct.urb*, %struct.urb** %15, i64 %idxprom34
  %16 = load %struct.urb*, %struct.urb** %arrayidx35, align 8, !tbaa !48
  br i1 %tobool31, label %if.then32, label %if.else

if.then32:                                        ; preds = %if.end30
  %call36 = call i32 bitcast (i32 (%struct.urb.824*)* @usb_unlink_urb to i32 (%struct.urb*)*)(%struct.urb* %16)
  switch i32 %call36, label %if.then44 [
    i32 -115, label %for.inc
    i32 -19, label %for.inc
    i32 -16, label %for.inc
    i32 -43, label %for.inc
  ]

if.then44:                                        ; preds = %if.then32
  %17 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %for.inc

if.else:                                          ; preds = %if.end30
  %cmp52 = icmp eq %struct.urb* %urb, %16
  %.found.0 = select i1 %cmp52, i32 1, i32 %found.0
  br label %for.inc

for.inc:                                          ; preds = %if.else, %if.then44, %if.then32, %if.then32, %if.then32, %if.then32, %lor.lhs.false23, %for.body
  %found.3 = phi i32 [ %found.0, %lor.lhs.false23 ], [ %found.0, %for.body ], [ %.found.0, %if.else ], [ %found.0, %if.then32 ], [ %found.0, %if.then32 ], [ %found.0, %if.then32 ], [ %found.0, %if.then32 ], [ %found.0, %if.then44 ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %lock56 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 2
  call void @spin_lock.202(%struct.spinlock* %lock56)
  br label %if.end57

if.end57:                                         ; preds = %for.end, %switch.early.test, %switch.early.test, %if.end
  %actual_length58 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %18 = load i32, i32* %actual_length58, align 4, !tbaa !292
  %conv = zext i32 %18 to i64
  %bytes = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 1
  %19 = load i64, i64* %bytes, align 8, !tbaa !465
  %add = add i64 %19, %conv
  store i64 %add, i64* %bytes, align 8, !tbaa !465
  %count = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 7
  %20 = load i32, i32* %count, align 8, !tbaa !461
  %dec = add nsw i32 %20, -1
  store i32 %dec, i32* %count, align 8, !tbaa !461
  %count59 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 7
  %21 = load i32, i32* %count59, align 8, !tbaa !461
  %tobool60 = icmp ne i32 %21, 0
  br i1 %tobool60, label %if.end62, label %if.then61

if.then61:                                        ; preds = %if.end57
  %complete = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 8
  call void @complete(%struct.completion* %complete)
  br label %if.end62

if.end62:                                         ; preds = %if.then61, %if.end57
  %lock63 = getelementptr inbounds %struct.usb_sg_request, %struct.usb_sg_request* %1, i32 0, i32 2
  call void @spin_unlock.204(%struct.spinlock* %lock63)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.page* @sg_page.281(%struct.scatterlist* %sg) #1 {
entry:
  %sg_magic = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 0
  %0 = load i64, i64* %sg_magic, align 8, !tbaa !381
  %cmp = icmp ne i64 %0, 2271560481
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.body8

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.56.674, i32 0, i32 0), i32 98, i64 12) #8, !srcloc !466
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.body8:                                         ; preds = %entry
  %page_link = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %1 = load i64, i64* %page_link, align 8, !tbaa !383
  %and = and i64 %1, 1
  %tobool9 = icmp ne i64 %and, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %do.body18, label %do.end26

do.body18:                                        ; preds = %do.body8
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.56.674, i32 0, i32 0), i32 99, i64 12) #8, !srcloc !467
  br label %do.body19

do.body19:                                        ; preds = %do.body19, %do.body18
  br label %do.body19

do.end26:                                         ; preds = %do.body8
  %page_link27 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %2 = load i64, i64* %page_link27, align 8, !tbaa !383
  %and28 = and i64 %2, -4
  %3 = inttoptr i64 %and28 to %struct.page*
  ret %struct.page* %3
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @PageHighMem() #1 {
entry:
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @sg_virt.282(%struct.scatterlist* %sg) #1 {
entry:
  %call = call %struct.page* @sg_page.281(%struct.scatterlist* %sg)
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %call to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %0 = inttoptr i64 %add.i to i8*
  %offset = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 2
  %1 = load i32, i32* %offset, align 8, !tbaa !373
  %idx.ext = zext i32 %1 to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  ret i8* %add.ptr
}

; Function Attrs: nounwind uwtable
define i32 @usb_bulk_msg(%struct.usb_device* %usb_dev, i32 %pipe, i8* %data, i32 %len, i32* %actual_length, i32 %timeout) #0 {
entry:
  %call = call %struct.usb_host_endpoint* @usb_pipe_endpoint.286(%struct.usb_device* %usb_dev, i32 %pipe)
  %tobool = icmp eq %struct.usb_host_endpoint* %call, null
  %cmp = icmp slt i32 %len, 0
  %or.cond = or i1 %tobool, %cmp
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call %struct.urb* bitcast (%struct.urb.824* (i32, i32)* @usb_alloc_urb to %struct.urb* (i32, i32)*)(i32 0, i32 208)
  %tobool2 = icmp ne %struct.urb* %call1, null
  br i1 %tobool2, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 0
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !468
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp5 = icmp eq i32 %and, 3
  br i1 %cmp5, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end4
  %and8 = and i32 %pipe, 1073741823
  %or = or i32 %and8, 1073741824
  %desc9 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call, i32 0, i32 0
  %bInterval = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc9, i32 0, i32 5
  %1 = load i8, i8* %bInterval, align 2, !tbaa !469
  %conv10 = zext i8 %1 to i32
  call void @usb_fill_int_urb.287(%struct.urb* %call1, %struct.usb_device* %usb_dev, i32 %or, i8* %data, i32 %len, void (%struct.urb*)* @usb_api_blocking_completion, i8* null, i32 %conv10)
  br label %if.end11

if.else:                                          ; preds = %if.end4
  call void @usb_fill_bulk_urb(%struct.urb* %call1, %struct.usb_device* %usb_dev, i32 %pipe, i8* %data, i32 %len, void (%struct.urb*)* @usb_api_blocking_completion, i8* null)
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.then7
  %call12 = call i32 @usb_start_wait_urb(%struct.urb* %call1, i32 %timeout, i32* %actual_length)
  br label %cleanup

cleanup:                                          ; preds = %if.end11, %if.end, %entry
  %retval.0 = phi i32 [ %call12, %if.end11 ], [ -22, %entry ], [ -12, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_host_endpoint* @usb_pipe_endpoint.286(%struct.usb_device* %dev, i32 %pipe) #1 {
entry:
  %and = and i32 %pipe, 128
  %tobool = icmp ne i32 %and, 0
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 17
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 16
  %ep_out.sink = select i1 %tobool, [16 x %struct.usb_host_endpoint*]* %ep_in, [16 x %struct.usb_host_endpoint*]* %ep_out
  %arraydecay1 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out.sink, i32 0, i32 0
  %shr = lshr i32 %pipe, 15
  %and2 = and i32 %shr, 15
  %idxprom = zext i32 %and2 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arraydecay1, i64 %idxprom
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8, !tbaa !48
  ret %struct.usb_host_endpoint* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_fill_int_urb.287(%struct.urb* %urb, %struct.usb_device* %dev, i32 %pipe, i8* %transfer_buffer, i32 %buffer_length, void (%struct.urb*)* %complete_fn, i8* %context, i32 %interval) #1 {
entry:
  %dev1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  store %struct.usb_device* %dev, %struct.usb_device** %dev1, align 8, !tbaa !210
  %pipe2 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 10
  store i32 %pipe, i32* %pipe2, align 8, !tbaa !212
  %transfer_buffer3 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  store i8* %transfer_buffer, i8** %transfer_buffer3, align 8, !tbaa !293
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  store i32 %buffer_length, i32* %transfer_buffer_length, align 8, !tbaa !294
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 28
  store void (%struct.urb*)* %complete_fn, void (%struct.urb*)** %complete, align 8, !tbaa !295
  %context4 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  store i8* %context, i8** %context4, align 8, !tbaa !290
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp eq i32 %0, 3
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %speed5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 4
  %1 = load i32, i32* %speed5, align 4, !tbaa !153
  %cmp6 = icmp eq i32 %1, 5
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %sub = sub nsw i32 %interval, 1
  %shl = shl i32 1, %sub
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %interval.sink = phi i32 [ %shl, %if.then ], [ %interval, %lor.lhs.false ]
  %interval8 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 25
  store i32 %interval.sink, i32* %interval8, align 8, !tbaa !296
  %start_frame = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 23
  store i32 -1, i32* %start_frame, align 8, !tbaa !297
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_fill_bulk_urb(%struct.urb* %urb, %struct.usb_device* %dev, i32 %pipe, i8* %transfer_buffer, i32 %buffer_length, void (%struct.urb*)* %complete_fn, i8* %context) #1 {
entry:
  %dev1 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  store %struct.usb_device* %dev, %struct.usb_device** %dev1, align 8, !tbaa !210
  %pipe2 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 10
  store i32 %pipe, i32* %pipe2, align 8, !tbaa !212
  %transfer_buffer3 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  store i8* %transfer_buffer, i8** %transfer_buffer3, align 8, !tbaa !293
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  store i32 %buffer_length, i32* %transfer_buffer_length, align 8, !tbaa !294
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 28
  store void (%struct.urb*)* %complete_fn, void (%struct.urb*)** %complete, align 8, !tbaa !295
  %context4 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  store i8* %context, i8** %context4, align 8, !tbaa !290
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_interrupt_msg(%struct.usb_device* %usb_dev, i32 %pipe, i8* %data, i32 %len, i32* %actual_length, i32 %timeout) #0 {
entry:
  %call = call i32 @usb_bulk_msg(%struct.usb_device* %usb_dev, i32 %pipe, i8* %data, i32 %len, i32* %actual_length, i32 %timeout)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @usb_get_device_descriptor(%struct.usb_device* %dev, i32 %size) #0 {
entry:
  %conv = zext i32 %size to i64
  %cmp = icmp ugt i64 %conv, 18
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call.i = call i8* @__kmalloc(i64 18, i32 16) #8
  %0 = bitcast i8* %call.i to %struct.usb_device_descriptor*
  %tobool = icmp ne %struct.usb_device_descriptor* %0, null
  br i1 %tobool, label %if.end3, label %cleanup

if.end3:                                          ; preds = %if.end
  %1 = bitcast %struct.usb_device_descriptor* %0 to i8*
  %call4 = call i32 @usb_get_descriptor(%struct.usb_device* %dev, i8 zeroext 1, i8 zeroext 0, i8* %1, i32 %size)
  %cmp5 = icmp sge i32 %call4, 0
  br i1 %cmp5, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end3
  %conv8 = zext i32 %size to i64
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %2 = bitcast %struct.usb_device_descriptor* %descriptor to i8*
  %3 = bitcast %struct.usb_device_descriptor* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 %conv8, i32 1, i1 false)
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.end3
  %4 = bitcast %struct.usb_device_descriptor* %0 to i8*
  call void @kfree(i8* %4)
  br label %cleanup

cleanup:                                          ; preds = %if.end9, %if.end, %entry
  %retval.0 = phi i32 [ %call4, %if.end9 ], [ -22, %entry ], [ -12, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_device_match(%struct.device* %dev, %struct.device_driver* %drv) #0 {
entry:
  %call = call i32 @is_usb_device(%struct.device* %dev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = call i32 @is_usb_device_driver(%struct.device_driver* %drv)
  %tobool2 = icmp ne i32 %call1, 0
  %. = select i1 %tobool2, i32 1, i32 0
  br label %return

if.else:                                          ; preds = %entry
  %call4 = call i32 @is_usb_interface.293(%struct.device* %dev)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end25

if.then6:                                         ; preds = %if.else
  %call7 = call i32 @is_usb_device_driver(%struct.device_driver* %drv)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %LeafBlock, label %if.end10

if.end10:                                         ; preds = %if.then6
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -48
  %1 = bitcast i8* %add.ptr to %struct.usb_interface*
  %2 = bitcast %struct.device_driver* %drv to i8*
  %add.ptr13 = getelementptr inbounds i8, i8* %2, i64 -168
  %3 = bitcast i8* %add.ptr13 to %struct.usb_driver*
  %id_table = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %3, i32 0, i32 9
  %4 = load %struct.usb_device_id*, %struct.usb_device_id** %id_table, align 8, !tbaa !470
  %call14 = call %struct.usb_device_id* @usb_match_id(%struct.usb_interface* %1, %struct.usb_device_id* %4)
  %tobool15 = icmp ne %struct.usb_device_id* %call14, null
  br i1 %tobool15, label %LeafBlock, label %if.end17

if.end17:                                         ; preds = %if.end10
  %call18 = call %struct.usb_device_id* @usb_match_dynamic_id(%struct.usb_interface* %1, %struct.usb_driver* %3)
  %tobool19 = icmp ne %struct.usb_device_id* %call18, null
  %.1 = select i1 %tobool19, i32 1, i32 0
  %.2 = select i1 %tobool19, i32 1, i32 undef
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end17, %if.end10, %if.then6
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then6 ], [ 1, %if.end10 ], [ %.1, %if.end17 ]
  %retval.0 = phi i32 [ 0, %if.then6 ], [ 1, %if.end10 ], [ %.2, %if.end17 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 1
  br i1 %SwitchLeaf, label %return, label %if.end25

if.end25:                                         ; preds = %LeafBlock, %if.else
  br label %return

return:                                           ; preds = %if.end25, %LeafBlock, %if.then
  %retval.1 = phi i32 [ %retval.0, %LeafBlock ], [ 0, %if.end25 ], [ %., %if.then ]
  ret i32 %retval.1
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_uevent(%struct.device* %dev, %struct.kobj_uevent_env* %env) #0 {
entry:
  %call = call i32 @is_usb_device(%struct.device* %dev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  br label %if.end9

if.else:                                          ; preds = %entry
  %call1 = call i32 @is_usb_interface.293(%struct.device* %dev)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %cleanup

if.then3:                                         ; preds = %if.else
  %2 = bitcast %struct.device* %dev to i8*
  %add.ptr6 = getelementptr inbounds i8, i8* %2, i64 -48
  %3 = bitcast i8* %add.ptr6 to %struct.usb_interface*
  %call7 = call %struct.usb_device* @interface_to_usbdev.294(%struct.usb_interface* %3)
  br label %if.end9

if.end9:                                          ; preds = %if.then3, %if.then
  %usb_dev.0 = phi %struct.usb_device* [ %1, %if.then ], [ %call7, %if.then3 ]
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev.0, i32 0, i32 0
  %4 = load i32, i32* %devnum, align 8, !tbaa !38
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %do.body, label %if.end18

do.body:                                          ; preds = %if.end9
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_uevent.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool11 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool11, true
  %lnot12 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot12 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  br i1 %tobool13, label %if.then14, label %cleanup

if.then14:                                        ; preds = %do.body
  %call15 = call i8* @dev_name.295(%struct.device* %dev)
  %call16 = call i32 (%struct._ddebug*, i8*, ...) @__dynamic_pr_debug(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_uevent.descriptor to %struct._ddebug*), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.30.296, i32 0, i32 0), i8* %call15)
  br label %cleanup

if.end18:                                         ; preds = %if.end9
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev.0, i32 0, i32 9
  %5 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %tobool19 = icmp ne %struct.usb_bus* %5, null
  br i1 %tobool19, label %if.end40, label %do.body21

do.body21:                                        ; preds = %if.end18
  %bf.load22 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_uevent.descriptor.31 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr23 = lshr i32 %bf.load22, 18
  %bf.clear24 = and i32 %bf.lshr23, 255
  %and25 = and i32 %bf.clear24, 1
  %tobool26 = icmp ne i32 %and25, 0
  %lnot27 = xor i1 %tobool26, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %if.then34, label %cleanup

if.then34:                                        ; preds = %do.body21
  %call35 = call i8* @dev_name.295(%struct.device* %dev)
  %call36 = call i32 (%struct._ddebug*, i8*, ...) @__dynamic_pr_debug(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_uevent.descriptor.31 to %struct._ddebug*), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.32.297, i32 0, i32 0), i8* %call35)
  br label %cleanup

if.end40:                                         ; preds = %if.end18
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev.0, i32 0, i32 12
  %idVendor = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 7
  %6 = load i16, i16* %idVendor, align 8, !tbaa !231
  %conv41 = zext i16 %6 to i32
  %descriptor42 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev.0, i32 0, i32 12
  %idProduct = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor42, i32 0, i32 8
  %7 = load i16, i16* %idProduct, align 2, !tbaa !232
  %conv43 = zext i16 %7 to i32
  %descriptor44 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev.0, i32 0, i32 12
  %bcdDevice = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor44, i32 0, i32 9
  %8 = load i16, i16* %bcdDevice, align 4, !tbaa !238
  %conv45 = zext i16 %8 to i32
  %call46 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33.298, i32 0, i32 0), i32 %conv41, i32 %conv43, i32 %conv45)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %cleanup, label %if.end49

if.end49:                                         ; preds = %if.end40
  %descriptor50 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev.0, i32 0, i32 12
  %bDeviceClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor50, i32 0, i32 3
  %9 = load i8, i8* %bDeviceClass, align 4, !tbaa !241
  %conv51 = zext i8 %9 to i32
  %descriptor52 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev.0, i32 0, i32 12
  %bDeviceSubClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor52, i32 0, i32 4
  %10 = load i8, i8* %bDeviceSubClass, align 1, !tbaa !243
  %conv53 = zext i8 %10 to i32
  %descriptor54 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usb_dev.0, i32 0, i32 12
  %bDeviceProtocol = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor54, i32 0, i32 5
  %11 = load i8, i8* %bDeviceProtocol, align 2, !tbaa !175
  %conv55 = zext i8 %11 to i32
  %call56 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.34.299, i32 0, i32 0), i32 %conv51, i32 %conv53, i32 %conv55)
  %tobool57 = icmp ne i32 %call56, 0
  %. = select i1 %tobool57, i32 -12, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end49, %if.end40, %if.then34, %do.body21, %if.then14, %do.body, %if.else
  %retval.0 = phi i32 [ 0, %if.else ], [ -19, %if.then14 ], [ -19, %do.body ], [ -19, %if.then34 ], [ -19, %do.body21 ], [ -12, %if.end40 ], [ %., %if.end49 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_usb_device(%struct.device* %dev) #1 {
entry:
  %type = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 4
  %0 = load %struct.device_type*, %struct.device_type** %type, align 8, !tbaa !58
  %cmp = icmp eq %struct.device_type* %0, @usb_device_type
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_usb_interface.293(%struct.device* %dev) #1 {
entry:
  %type = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 4
  %0 = load %struct.device_type*, %struct.device_type** %type, align 8, !tbaa !58
  %cmp = icmp eq %struct.device_type* %0, @usb_if_device_type
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_device* @interface_to_usbdev.294(%struct.usb_interface* %intf) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %parent, align 8, !tbaa !282
  %1 = bitcast %struct.device* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -136
  %2 = bitcast i8* %add.ptr to %struct.usb_device*
  ret %struct.usb_device* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name.295(%struct.device* %dev) #1 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !341
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !341
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name.302(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name.302(%struct.kobject* %kobj) #1 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !343
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_usb_device_driver(%struct.device_driver* %drv) #1 {
entry:
  %0 = bitcast %struct.device_driver* %drv to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usbdrv_wrap*
  %for_devices = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %1, i32 0, i32 1
  %2 = load i32, i32* %for_devices, align 8, !tbaa !471
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define %struct.usb_device_id* @usb_match_id(%struct.usb_interface* %interface, %struct.usb_device_id* %id) #0 {
entry:
  %cmp = icmp eq %struct.usb_device_id* %id, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %id.addr.0 = phi %struct.usb_device_id* [ %id, %if.end ], [ %incdec.ptr, %for.inc ]
  %idVendor = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 0, i32 1
  %0 = load i16, i16* %idVendor, align 2, !tbaa !235
  %conv = zext i16 %0 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %for.body, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.cond
  %idProduct = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 0, i32 2
  %1 = load i16, i16* %idProduct, align 4, !tbaa !236
  %conv1 = zext i16 %1 to i32
  %tobool2 = icmp ne i32 %conv1, 0
  br i1 %tobool2, label %for.body, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %bDeviceClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 0, i32 5
  %2 = load i8, i8* %bDeviceClass, align 2, !tbaa !240
  %conv4 = zext i8 %2 to i32
  %tobool5 = icmp ne i32 %conv4, 0
  br i1 %tobool5, label %for.body, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false3
  %bInterfaceClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 0, i32 8
  %3 = load i8, i8* %bInterfaceClass, align 1, !tbaa !472
  %conv7 = zext i8 %3 to i32
  %tobool8 = icmp ne i32 %conv7, 0
  br i1 %tobool8, label %for.body, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false6
  %driver_info = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 0, i32 12
  %4 = load i64, i64* %driver_info, align 8, !tbaa !277
  %tobool9 = icmp ne i64 %4, 0
  br i1 %tobool9, label %for.body, label %return

for.body:                                         ; preds = %lor.rhs, %lor.lhs.false6, %lor.lhs.false3, %lor.lhs.false, %for.cond
  %call = call i32 @usb_match_one_id(%struct.usb_interface* %interface, %struct.usb_device_id* %id.addr.0)
  %tobool10 = icmp ne i32 %call, 0
  br i1 %tobool10, label %return, label %for.inc

for.inc:                                          ; preds = %for.body
  %incdec.ptr = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 1
  br label %for.cond

return:                                           ; preds = %for.body, %lor.rhs, %entry
  %retval.0 = phi %struct.usb_device_id* [ null, %entry ], [ %id.addr.0, %for.body ], [ null, %lor.rhs ]
  ret %struct.usb_device_id* %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.usb_device_id* @usb_match_dynamic_id(%struct.usb_interface* %intf, %struct.usb_driver* %drv) #0 {
entry:
  %dynids = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %drv, i32 0, i32 10
  %lock = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 0
  call void @spin_lock.303(%struct.spinlock* %lock)
  %dynids1 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %drv, i32 0, i32 10
  %list = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids1, i32 0, i32 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %node8.sink = phi %struct.list_head* [ %node8, %for.inc ], [ %list, %entry ]
  %next9 = getelementptr inbounds %struct.list_head, %struct.list_head* %node8.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next9, align 8, !tbaa !48
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr11 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr11 to %struct.usb_dynid*
  %node = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %2, i32 0, i32 0
  %dynids2 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %drv, i32 0, i32 10
  %list3 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids2, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %node, %list3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %id = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %2, i32 0, i32 1
  %call = call i32 @usb_match_one_id(%struct.usb_interface* %intf, %struct.usb_device_id* %id)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %dynids4 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %drv, i32 0, i32 10
  %lock5 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids4, i32 0, i32 0
  call void @spin_unlock.304(%struct.spinlock* %lock5)
  %id6 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %2, i32 0, i32 1
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %node8 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %2, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %dynids12 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %drv, i32 0, i32 10
  %lock13 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids12, i32 0, i32 0
  call void @spin_unlock.304(%struct.spinlock* %lock13)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then
  %retval.0 = phi %struct.usb_device_id* [ %id6, %if.then ], [ null, %for.end ]
  ret %struct.usb_device_id* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock.303(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_match_one_id(%struct.usb_interface* %interface, %struct.usb_device_id* %id) #0 {
entry:
  %cmp = icmp eq %struct.usb_device_id* %id, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %interface, i32 0, i32 1
  %0 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !148
  %call = call %struct.usb_device* @interface_to_usbdev.294(%struct.usb_interface* %interface)
  %call1 = call i32 @usb_match_device(%struct.usb_device* %call, %struct.usb_device_id* %id)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end3, label %cleanup

if.end3:                                          ; preds = %if.end
  %call4 = call i32 @usb_match_one_id_intf(%struct.usb_device* %call, %struct.usb_host_interface* %0, %struct.usb_device_id* %id)
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry
  %retval.0 = phi i32 [ %call4, %if.end3 ], [ 0, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock.304(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_match_device(%struct.usb_device* %dev, %struct.usb_device_id* %id) #0 {
entry:
  %match_flags = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %0 = load i16, i16* %match_flags, align 8, !tbaa !233
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %idVendor = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 1
  %1 = load i16, i16* %idVendor, align 2, !tbaa !235
  %conv1 = zext i16 %1 to i32
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %idVendor2 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 7
  %2 = load i16, i16* %idVendor2, align 8, !tbaa !231
  %conv3 = zext i16 %2 to i32
  %cmp = icmp ne i32 %conv1, %conv3
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %match_flags5 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %3 = load i16, i16* %match_flags5, align 8, !tbaa !233
  %conv6 = zext i16 %3 to i32
  %and7 = and i32 %conv6, 2
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %land.lhs.true9, label %if.end17

land.lhs.true9:                                   ; preds = %if.end
  %idProduct = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 2
  %4 = load i16, i16* %idProduct, align 4, !tbaa !236
  %conv10 = zext i16 %4 to i32
  %descriptor11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %idProduct12 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor11, i32 0, i32 8
  %5 = load i16, i16* %idProduct12, align 2, !tbaa !232
  %conv13 = zext i16 %5 to i32
  %cmp14 = icmp ne i32 %conv10, %conv13
  br i1 %cmp14, label %return, label %if.end17

if.end17:                                         ; preds = %land.lhs.true9, %if.end
  %match_flags18 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %6 = load i16, i16* %match_flags18, align 8, !tbaa !233
  %conv19 = zext i16 %6 to i32
  %and20 = and i32 %conv19, 4
  %tobool21 = icmp ne i32 %and20, 0
  br i1 %tobool21, label %land.lhs.true22, label %if.end29

land.lhs.true22:                                  ; preds = %if.end17
  %bcdDevice_lo = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 3
  %7 = load i16, i16* %bcdDevice_lo, align 2, !tbaa !237
  %conv23 = zext i16 %7 to i32
  %descriptor24 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bcdDevice = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor24, i32 0, i32 9
  %8 = load i16, i16* %bcdDevice, align 4, !tbaa !238
  %conv25 = zext i16 %8 to i32
  %cmp26 = icmp sgt i32 %conv23, %conv25
  br i1 %cmp26, label %return, label %if.end29

if.end29:                                         ; preds = %land.lhs.true22, %if.end17
  %match_flags30 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %9 = load i16, i16* %match_flags30, align 8, !tbaa !233
  %conv31 = zext i16 %9 to i32
  %and32 = and i32 %conv31, 8
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %land.lhs.true34, label %if.end42

land.lhs.true34:                                  ; preds = %if.end29
  %bcdDevice_hi = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 4
  %10 = load i16, i16* %bcdDevice_hi, align 8, !tbaa !239
  %conv35 = zext i16 %10 to i32
  %descriptor36 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bcdDevice37 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor36, i32 0, i32 9
  %11 = load i16, i16* %bcdDevice37, align 4, !tbaa !238
  %conv38 = zext i16 %11 to i32
  %cmp39 = icmp slt i32 %conv35, %conv38
  br i1 %cmp39, label %return, label %if.end42

if.end42:                                         ; preds = %land.lhs.true34, %if.end29
  %match_flags43 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %12 = load i16, i16* %match_flags43, align 8, !tbaa !233
  %conv44 = zext i16 %12 to i32
  %and45 = and i32 %conv44, 16
  %tobool46 = icmp ne i32 %and45, 0
  br i1 %tobool46, label %land.lhs.true47, label %if.end55

land.lhs.true47:                                  ; preds = %if.end42
  %bDeviceClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 5
  %13 = load i8, i8* %bDeviceClass, align 2, !tbaa !240
  %conv48 = zext i8 %13 to i32
  %descriptor49 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bDeviceClass50 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor49, i32 0, i32 3
  %14 = load i8, i8* %bDeviceClass50, align 4, !tbaa !241
  %conv51 = zext i8 %14 to i32
  %cmp52 = icmp ne i32 %conv48, %conv51
  br i1 %cmp52, label %return, label %if.end55

if.end55:                                         ; preds = %land.lhs.true47, %if.end42
  %match_flags56 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %15 = load i16, i16* %match_flags56, align 8, !tbaa !233
  %conv57 = zext i16 %15 to i32
  %and58 = and i32 %conv57, 32
  %tobool59 = icmp ne i32 %and58, 0
  br i1 %tobool59, label %land.lhs.true60, label %if.end68

land.lhs.true60:                                  ; preds = %if.end55
  %bDeviceSubClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 6
  %16 = load i8, i8* %bDeviceSubClass, align 1, !tbaa !242
  %conv61 = zext i8 %16 to i32
  %descriptor62 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bDeviceSubClass63 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor62, i32 0, i32 4
  %17 = load i8, i8* %bDeviceSubClass63, align 1, !tbaa !243
  %conv64 = zext i8 %17 to i32
  %cmp65 = icmp ne i32 %conv61, %conv64
  br i1 %cmp65, label %return, label %if.end68

if.end68:                                         ; preds = %land.lhs.true60, %if.end55
  %match_flags69 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %18 = load i16, i16* %match_flags69, align 8, !tbaa !233
  %conv70 = zext i16 %18 to i32
  %and71 = and i32 %conv70, 64
  %tobool72 = icmp ne i32 %and71, 0
  br i1 %tobool72, label %land.lhs.true73, label %if.end81

land.lhs.true73:                                  ; preds = %if.end68
  %bDeviceProtocol = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 7
  %19 = load i8, i8* %bDeviceProtocol, align 4, !tbaa !244
  %conv74 = zext i8 %19 to i32
  %descriptor75 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bDeviceProtocol76 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor75, i32 0, i32 5
  %20 = load i8, i8* %bDeviceProtocol76, align 2, !tbaa !175
  %conv77 = zext i8 %20 to i32
  %cmp78 = icmp ne i32 %conv74, %conv77
  br i1 %cmp78, label %return, label %if.end81

if.end81:                                         ; preds = %land.lhs.true73, %if.end68
  br label %return

return:                                           ; preds = %if.end81, %land.lhs.true73, %land.lhs.true60, %land.lhs.true47, %land.lhs.true34, %land.lhs.true22, %land.lhs.true9, %land.lhs.true
  %retval.0 = phi i32 [ 1, %if.end81 ], [ 0, %land.lhs.true ], [ 0, %land.lhs.true9 ], [ 0, %land.lhs.true22 ], [ 0, %land.lhs.true34 ], [ 0, %land.lhs.true47 ], [ 0, %land.lhs.true60 ], [ 0, %land.lhs.true73 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_match_one_id_intf(%struct.usb_device* %dev, %struct.usb_host_interface* %intf, %struct.usb_device_id* %id) #0 {
entry:
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bDeviceClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 3
  %0 = load i8, i8* %bDeviceClass, align 4, !tbaa !241
  %conv = zext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 255
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %match_flags = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %1 = load i16, i16* %match_flags, align 8, !tbaa !233
  %conv2 = zext i16 %1 to i32
  %and = and i32 %conv2, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %land.lhs.true
  %match_flags4 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %2 = load i16, i16* %match_flags4, align 8, !tbaa !233
  %conv5 = zext i16 %2 to i32
  %and6 = and i32 %conv5, 1920
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %return, label %if.end

if.end:                                           ; preds = %land.lhs.true3, %land.lhs.true, %entry
  %match_flags8 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %3 = load i16, i16* %match_flags8, align 8, !tbaa !233
  %conv9 = zext i16 %3 to i32
  %and10 = and i32 %conv9, 128
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %land.lhs.true12, label %if.end19

land.lhs.true12:                                  ; preds = %if.end
  %bInterfaceClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 8
  %4 = load i8, i8* %bInterfaceClass, align 1, !tbaa !472
  %conv13 = zext i8 %4 to i32
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %intf, i32 0, i32 0
  %bInterfaceClass14 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 5
  %5 = load i8, i8* %bInterfaceClass14, align 1, !tbaa !433
  %conv15 = zext i8 %5 to i32
  %cmp16 = icmp ne i32 %conv13, %conv15
  br i1 %cmp16, label %return, label %if.end19

if.end19:                                         ; preds = %land.lhs.true12, %if.end
  %match_flags20 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %6 = load i16, i16* %match_flags20, align 8, !tbaa !233
  %conv21 = zext i16 %6 to i32
  %and22 = and i32 %conv21, 256
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %land.lhs.true24, label %if.end32

land.lhs.true24:                                  ; preds = %if.end19
  %bInterfaceSubClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 9
  %7 = load i8, i8* %bInterfaceSubClass, align 2, !tbaa !473
  %conv25 = zext i8 %7 to i32
  %desc26 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %intf, i32 0, i32 0
  %bInterfaceSubClass27 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc26, i32 0, i32 6
  %8 = load i8, i8* %bInterfaceSubClass27, align 2, !tbaa !269
  %conv28 = zext i8 %8 to i32
  %cmp29 = icmp ne i32 %conv25, %conv28
  br i1 %cmp29, label %return, label %if.end32

if.end32:                                         ; preds = %land.lhs.true24, %if.end19
  %match_flags33 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %9 = load i16, i16* %match_flags33, align 8, !tbaa !233
  %conv34 = zext i16 %9 to i32
  %and35 = and i32 %conv34, 512
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %land.lhs.true37, label %if.end45

land.lhs.true37:                                  ; preds = %if.end32
  %bInterfaceProtocol = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 10
  %10 = load i8, i8* %bInterfaceProtocol, align 1, !tbaa !474
  %conv38 = zext i8 %10 to i32
  %desc39 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %intf, i32 0, i32 0
  %bInterfaceProtocol40 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc39, i32 0, i32 7
  %11 = load i8, i8* %bInterfaceProtocol40, align 1, !tbaa !434
  %conv41 = zext i8 %11 to i32
  %cmp42 = icmp ne i32 %conv38, %conv41
  br i1 %cmp42, label %return, label %if.end45

if.end45:                                         ; preds = %land.lhs.true37, %if.end32
  %match_flags46 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 0
  %12 = load i16, i16* %match_flags46, align 8, !tbaa !233
  %conv47 = zext i16 %12 to i32
  %and48 = and i32 %conv47, 1024
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool49, label %land.lhs.true50, label %if.end58

land.lhs.true50:                                  ; preds = %if.end45
  %bInterfaceNumber = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 11
  %13 = load i8, i8* %bInterfaceNumber, align 8, !tbaa !475
  %conv51 = zext i8 %13 to i32
  %desc52 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %intf, i32 0, i32 0
  %bInterfaceNumber53 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc52, i32 0, i32 2
  %14 = load i8, i8* %bInterfaceNumber53, align 2, !tbaa !68
  %conv54 = zext i8 %14 to i32
  %cmp55 = icmp ne i32 %conv51, %conv54
  br i1 %cmp55, label %return, label %if.end58

if.end58:                                         ; preds = %land.lhs.true50, %if.end45
  br label %return

return:                                           ; preds = %if.end58, %land.lhs.true50, %land.lhs.true37, %land.lhs.true24, %land.lhs.true12, %land.lhs.true3
  %retval.0 = phi i32 [ 1, %if.end58 ], [ 0, %land.lhs.true3 ], [ 0, %land.lhs.true12 ], [ 0, %land.lhs.true24 ], [ 0, %land.lhs.true37 ], [ 0, %land.lhs.true50 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_autopm_get_interface_no_resume(%struct.usb_interface* %intf) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev.294(%struct.usb_interface* %intf)
  call void @usb_mark_last_busy.308(%struct.usb_device* %call)
  %pm_usage_cnt = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 9
  call void @atomic_inc.309(%union.anon.5* %pm_usage_cnt)
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @pm_runtime_get_noresume.310(%struct.device* %dev)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_mark_last_busy.308(%struct.usb_device* %udev) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_mark_last_busy.311(%struct.device* %dev)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.309(%union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #8, !srcloc !476
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_get_noresume.310(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %usage_count = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 11
  call void @atomic_inc.309(%union.anon.5* %usage_count)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_mark_last_busy.311(%struct.device* %dev) #1 {
entry:
  %0 = load volatile i64, i64* @jiffies, align 8, !tbaa !49
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %last_busy = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 18
  store volatile i64 %0, i64* %last_busy, align 8, !tbaa !49
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_autopm_get_interface_async(%struct.usb_interface* %intf) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i32 @pm_runtime_get(%struct.device* %dev)
  %cmp = icmp slt i32 %call, 0
  %cmp1 = icmp ne i32 %call, -115
  %or.cond = and i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %dev2 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @pm_runtime_put_noidle.312(%struct.device* %dev2)
  br label %if.end

if.else:                                          ; preds = %entry
  %pm_usage_cnt = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 9
  call void @atomic_inc.309(%union.anon.5* %pm_usage_cnt)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %cmp3 = icmp sgt i32 %call, 0
  %cmp4 = icmp eq i32 %call, -115
  %or.cond1 = or i1 %cmp3, %cmp4
  %status.0 = select i1 %or.cond1, i32 0, i32 %call
  ret i32 %status.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pm_runtime_get(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_resume(%struct.device* %dev, i32 5)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put_noidle.312(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %usage_count = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 11
  call void @atomic_add_unless.313(%union.anon.5* %usage_count, i32 -1, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_add_unless.313(%union.anon.5* %v, i32 %a, i32 %u) #1 {
entry:
  %call = call i32 @__atomic_add_unless.314(%union.anon.5* %v, i32 %a, i32 %u)
  %cmp = icmp ne i32 %call, %u
  %conv = zext i1 %cmp to i32
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__atomic_add_unless.314(%union.anon.5* %v, i32 %a, i32 %u) #1 {
entry:
  %call = call i32 @atomic_read.315(%union.anon.5* %v)
  br label %for.cond

for.cond:                                         ; preds = %if.end13, %entry
  %c.0 = phi i32 [ %call, %entry ], [ %call2, %if.end13 ]
  %cmp = icmp eq i32 %c.0, %u
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %for.end, label %if.end

if.end:                                           ; preds = %for.cond
  %add = add nsw i32 %c.0, %a
  %call2 = call i32 @atomic_cmpxchg.316(%union.anon.5* %v, i32 %c.0, i32 %add)
  %cmp3 = icmp eq i32 %call2, %c.0
  %lnot5 = xor i1 %cmp3, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %expval10 = call i64 @llvm.expect.i64(i64 %conv9, i64 1)
  %tobool11 = icmp ne i64 %expval10, 0
  br i1 %tobool11, label %for.end, label %if.end13

if.end13:                                         ; preds = %if.end
  br label %for.cond

for.end:                                          ; preds = %if.end, %for.cond
  ret i32 %c.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read.315(%union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !90
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_cmpxchg.316(%union.anon.5* %v, i32 %old, i32 %new) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; cmpxchgl $2,$1", "={ax},=*m,r,0,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %new, i32 %old, i32* %counter) #8, !srcloc !477
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define i32 @usb_autopm_get_interface(%struct.usb_interface* %intf) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i32 @pm_runtime_get_sync.319(%struct.device* %dev)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %dev1 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @pm_runtime_put_sync.320(%struct.device* %dev1)
  br label %if.end

if.else:                                          ; preds = %entry
  %pm_usage_cnt = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 9
  call void @atomic_inc.309(%union.anon.5* %pm_usage_cnt)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %cmp3 = icmp sgt i32 %call, 0
  %.call = select i1 %cmp3, i32 0, i32 %call
  ret i32 %.call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pm_runtime_get_sync.319(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_resume(%struct.device* %dev, i32 4)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put_sync.320(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_idle(%struct.device* %dev, i32 4)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_autopm_put_interface_no_suspend(%struct.usb_interface* %intf) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev.294(%struct.usb_interface* %intf)
  call void @usb_mark_last_busy.308(%struct.usb_device* %call)
  %pm_usage_cnt = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 9
  call void @atomic_dec.323(%union.anon.5* %pm_usage_cnt)
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @pm_runtime_put_noidle.312(%struct.device* %dev)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_dec.323(%union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #8, !srcloc !478
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_autopm_put_interface_async(%struct.usb_interface* %intf) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev.294(%struct.usb_interface* %intf)
  call void @usb_mark_last_busy.308(%struct.usb_device* %call)
  %pm_usage_cnt = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 9
  call void @atomic_dec.323(%union.anon.5* %pm_usage_cnt)
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @pm_runtime_put.326(%struct.device* %dev)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put.326(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_idle(%struct.device* %dev, i32 5)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_autopm_put_interface(%struct.usb_interface* %intf) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev.294(%struct.usb_interface* %intf)
  call void @usb_mark_last_busy.308(%struct.usb_device* %call)
  %pm_usage_cnt = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 9
  call void @atomic_dec.323(%union.anon.5* %pm_usage_cnt)
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @pm_runtime_put_sync.320(%struct.device* %dev)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_disable_autosuspend(%struct.usb_device* %udev) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_forbid(%struct.device* %dev)
  ret void
}

declare void @pm_runtime_forbid(%struct.device*) #2

; Function Attrs: nounwind uwtable
define void @usb_enable_autosuspend(%struct.usb_device* %udev) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_allow(%struct.device* %dev)
  ret void
}

declare void @pm_runtime_allow(%struct.device*) #2

; Function Attrs: nounwind uwtable
define void @usb_deregister(%struct.usb_driver* %driver) #0 {
entry:
  %0 = call i32 (i8*, ...) @printk(i8* null)
  call void @usb_remove_newid_files(%struct.usb_driver* %driver)
  %drvwrap = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver, i32 0, i32 11
  %driver1 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 0
  call void @driver_unregister(%struct.device_driver* %driver1)
  call void @usb_free_dynids(%struct.usb_driver* %driver)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usb_remove_newid_files(%struct.usb_driver* %usb_drv) #0 {
entry:
  %no_dynamic_id = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 12
  %bf.load = load i8, i8* %no_dynamic_id, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end4, label %if.end

if.end:                                           ; preds = %entry
  %probe = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 1
  %0 = load i32 (%struct.usb_interface*, %struct.usb_device_id*)*, i32 (%struct.usb_interface*, %struct.usb_device_id*)** %probe, align 8, !tbaa !479
  %cmp = icmp ne i32 (%struct.usb_interface*, %struct.usb_device_id*)* %0, null
  br i1 %cmp, label %if.then1, label %if.end4

if.then1:                                         ; preds = %if.end
  %drvwrap = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 11
  %driver = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 0
  call void @driver_remove_file(%struct.device_driver* %driver, %struct.driver_attribute* @driver_attr_remove_id)
  %drvwrap2 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 11
  %driver3 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap2, i32 0, i32 0
  call void @driver_remove_file(%struct.device_driver* %driver3, %struct.driver_attribute* @driver_attr_new_id)
  br label %if.end4

if.end4:                                          ; preds = %if.then1, %if.end, %entry
  ret void
}

declare void @driver_unregister(%struct.device_driver*) #2

; Function Attrs: nounwind uwtable
define internal void @usb_free_dynids(%struct.usb_driver* %usb_drv) #0 {
entry:
  %dynids = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 10
  %lock = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 0
  call void @spin_lock.303(%struct.spinlock* %lock)
  %dynids1 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 10
  %list = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids1, i32 0, i32 1
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !95
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.usb_dynid*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %.sink = phi %struct.usb_dynid* [ %5, %for.body ], [ %2, %entry ]
  %dynid.0 = phi %struct.usb_dynid* [ %2, %entry ], [ %5, %for.body ]
  %node11 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %.sink, i32 0, i32 0
  %next12 = getelementptr inbounds %struct.list_head, %struct.list_head* %node11, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next12, align 8, !tbaa !480
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr14 = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr14 to %struct.usb_dynid*
  %node6 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %dynid.0, i32 0, i32 0
  %dynids7 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 10
  %list8 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids7, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %node6, %list8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %node9 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %dynid.0, i32 0, i32 0
  call void @list_del(%struct.list_head* %node9)
  %6 = bitcast %struct.usb_dynid* %dynid.0 to i8*
  call void @kfree(i8* %6)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %dynids15 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 10
  %lock16 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids15, i32 0, i32 0
  call void @spin_unlock.304(%struct.spinlock* %lock16)
  ret void
}

declare void @driver_remove_file(%struct.device_driver*, %struct.driver_attribute*) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_dynids(%struct.device_driver* %driver, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_driver* %driver to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -168
  %1 = bitcast i8* %add.ptr to %struct.usb_driver*
  %dynids = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %1, i32 0, i32 10
  %call = call i64 @usb_show_dynids(%struct.__wait_queue_head* %dynids, i8* %buf)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @store_new_id(%struct.device_driver* %driver, i8* %buf, i64 %count) #0 {
entry:
  %0 = bitcast %struct.device_driver* %driver to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -168
  %1 = bitcast i8* %add.ptr to %struct.usb_driver*
  %dynids = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %1, i32 0, i32 10
  %call = call i64 @usb_store_new_id(%struct.__wait_queue_head* %dynids, %struct.device_driver* %driver, i8* %buf, i64 %count)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @usb_store_new_id(%struct.__wait_queue_head* %dynids, %struct.device_driver* %driver, i8* %buf, i64 %count) #0 {
entry:
  %idVendor = alloca i32, align 4
  %idProduct = alloca i32, align 4
  %bInterfaceClass = alloca i32, align 4
  %0 = bitcast i32* %idVendor to i8*
  store i32 0, i32* %idVendor, align 4, !tbaa !90
  %1 = bitcast i32* %idProduct to i8*
  store i32 0, i32* %idProduct, align 4, !tbaa !90
  %2 = bitcast i32* %bInterfaceClass to i8*
  store i32 0, i32* %bInterfaceClass, align 4, !tbaa !90
  %call = call i32 (i8*, i8*, ...) @sscanf(i8* %buf, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.337, i32 0, i32 0), i32* %idVendor, i32* %idProduct, i32* %bInterfaceClass)
  %cmp = icmp slt i32 %call, 2
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call2 = call i8* @kzalloc.338(i64 48, i32 208)
  %3 = bitcast i8* %call2 to %struct.usb_dynid*
  %tobool = icmp ne %struct.usb_dynid* %3, null
  br i1 %tobool, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %node = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %3, i32 0, i32 0
  call void @INIT_LIST_HEAD.339(%struct.list_head* %node)
  %4 = load i32, i32* %idVendor, align 4, !tbaa !90
  %conv = trunc i32 %4 to i16
  %id = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %3, i32 0, i32 1
  %idVendor5 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 1
  store i16 %conv, i16* %idVendor5, align 2, !tbaa !482
  %5 = load i32, i32* %idProduct, align 4, !tbaa !90
  %conv6 = trunc i32 %5 to i16
  %id7 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %3, i32 0, i32 1
  %idProduct8 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id7, i32 0, i32 2
  store i16 %conv6, i16* %idProduct8, align 4, !tbaa !483
  %id9 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %3, i32 0, i32 1
  %match_flags = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id9, i32 0, i32 0
  store i16 3, i16* %match_flags, align 8, !tbaa !484
  %cmp10 = icmp eq i32 %call, 3
  br i1 %cmp10, label %if.then12, label %if.end20

if.then12:                                        ; preds = %if.end4
  %6 = load i32, i32* %bInterfaceClass, align 4, !tbaa !90
  %conv13 = trunc i32 %6 to i8
  %id14 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %3, i32 0, i32 1
  %bInterfaceClass15 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id14, i32 0, i32 8
  store i8 %conv13, i8* %bInterfaceClass15, align 1, !tbaa !485
  %id16 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %3, i32 0, i32 1
  %match_flags17 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id16, i32 0, i32 0
  %7 = load i16, i16* %match_flags17, align 8, !tbaa !484
  %conv18 = zext i16 %7 to i32
  %or = or i32 %conv18, 128
  %conv19 = trunc i32 %or to i16
  store i16 %conv19, i16* %match_flags17, align 8, !tbaa !484
  br label %if.end20

if.end20:                                         ; preds = %if.then12, %if.end4
  %lock = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 0
  call void @spin_lock.303(%struct.spinlock* %lock)
  %node21 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %3, i32 0, i32 0
  %list = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 1
  call void @list_add_tail.340(%struct.list_head* %node21, %struct.list_head* %list)
  %lock22 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 0
  call void @spin_unlock.304(%struct.spinlock* %lock22)
  %call23 = call i32 @driver_attach(%struct.device_driver* %driver)
  %tobool24 = icmp ne i32 %call23, 0
  %conv26 = sext i32 %call23 to i64
  %conv26.count = select i1 %tobool24, i64 %conv26, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end20, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -12, %if.end ], [ %conv26.count, %if.end20 ]
  %8 = bitcast i32* %bInterfaceClass to i8*
  %9 = bitcast i32* %idProduct to i8*
  %10 = bitcast i32* %idVendor to i8*
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.338(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.339(%struct.list_head* %list) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !95
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !96
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.340(%struct.list_head* %new, %struct.list_head* %head) #1 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !96
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

declare i32 @driver_attach(%struct.device_driver*) #2

; Function Attrs: nounwind uwtable
define i64 @usb_show_dynids(%struct.__wait_queue_head* %dynids, i8* %buf) #0 {
entry:
  %list = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 1
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %node24.sink = phi %struct.list_head* [ %node24, %if.end ], [ %list, %entry ]
  %count.0 = phi i64 [ 0, %entry ], [ %add22, %if.end ]
  %next25 = getelementptr inbounds %struct.list_head, %struct.list_head* %node24.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next25, align 8, !tbaa !48
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr27 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr27 to %struct.usb_dynid*
  %node = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %2, i32 0, i32 0
  %list1 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %node, %list1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %id = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %2, i32 0, i32 1
  %bInterfaceClass = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 8
  %3 = load i8, i8* %bInterfaceClass, align 1, !tbaa !485
  %conv = zext i8 %3 to i32
  %cmp2 = icmp ne i32 %conv, 0
  %arrayidx = getelementptr inbounds i8, i8* %buf, i64 %count.0
  %sub = sub i64 4096, %count.0
  %id4 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %2, i32 0, i32 1
  %idVendor = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id4, i32 0, i32 1
  %4 = load i16, i16* %idVendor, align 2, !tbaa !482
  %conv5 = zext i16 %4 to i32
  %id6 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %2, i32 0, i32 1
  %idProduct = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id6, i32 0, i32 2
  %5 = load i16, i16* %idProduct, align 4, !tbaa !483
  %conv7 = zext i16 %5 to i32
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %id8 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %2, i32 0, i32 1
  %bInterfaceClass9 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id8, i32 0, i32 8
  %6 = load i8, i8* %bInterfaceClass9, align 1, !tbaa !485
  %conv10 = zext i8 %6 to i32
  %call = call i32 (i8*, i64, i8*, ...) @scnprintf(i8* %arrayidx, i64 %sub, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.1.342, i32 0, i32 0), i32 %conv5, i32 %conv7, i32 %conv10)
  br label %if.end

if.else:                                          ; preds = %for.body
  %call20 = call i32 (i8*, i64, i8*, ...) @scnprintf(i8* %arrayidx, i64 %sub, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.2.343, i32 0, i32 0), i32 %conv5, i32 %conv7)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %call20.sink = phi i32 [ %call20, %if.else ], [ %call, %if.then ]
  %conv21 = sext i32 %call20.sink to i64
  %add22 = add i64 %count.0, %conv21
  %node24 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %2, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret i64 %count.0
}

declare i32 @scnprintf(i8*, i64, i8*, ...) #2

; Function Attrs: nounwind uwtable
define internal i64 @store_remove_id(%struct.device_driver* %driver, i8* %buf, i64 %count) #0 {
entry:
  %idVendor = alloca i32, align 4
  %idProduct = alloca i32, align 4
  %0 = bitcast %struct.device_driver* %driver to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -168
  %1 = bitcast i8* %add.ptr to %struct.usb_driver*
  %2 = bitcast i32* %idVendor to i8*
  %3 = bitcast i32* %idProduct to i8*
  %call = call i32 (i8*, i8*, ...) @sscanf(i8* %buf, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.23.345, i32 0, i32 0), i32* %idVendor, i32* %idProduct)
  %cmp = icmp slt i32 %call, 2
  br i1 %cmp, label %cleanup31, label %if.end

if.end:                                           ; preds = %entry
  %dynids = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %1, i32 0, i32 10
  %lock = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 0
  call void @spin_lock.303(%struct.spinlock* %lock)
  %dynids2 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %1, i32 0, i32 10
  %list = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids2, i32 0, i32 1
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !95
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr4 = getelementptr inbounds i8, i8* %5, i64 0
  %6 = bitcast i8* %add.ptr4 to %struct.usb_dynid*
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %.sink = phi %struct.usb_dynid* [ %9, %for.inc ], [ %6, %if.end ]
  %dynid.0 = phi %struct.usb_dynid* [ %6, %if.end ], [ %9, %for.inc ]
  %node25 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %.sink, i32 0, i32 0
  %next26 = getelementptr inbounds %struct.list_head, %struct.list_head* %node25, i32 0, i32 0
  %7 = load %struct.list_head*, %struct.list_head** %next26, align 8, !tbaa !480
  %8 = bitcast %struct.list_head* %7 to i8*
  %add.ptr28 = getelementptr inbounds i8, i8* %8, i64 0
  %9 = bitcast i8* %add.ptr28 to %struct.usb_dynid*
  %node9 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %dynid.0, i32 0, i32 0
  %dynids10 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %1, i32 0, i32 10
  %list11 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids10, i32 0, i32 1
  %cmp12 = icmp ne %struct.list_head* %node9, %list11
  br i1 %cmp12, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %id13 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %dynid.0, i32 0, i32 1
  %idVendor14 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id13, i32 0, i32 1
  %10 = load i16, i16* %idVendor14, align 2, !tbaa !235
  %conv = zext i16 %10 to i32
  %11 = load i32, i32* %idVendor, align 4, !tbaa !90
  %cmp15 = icmp eq i32 %conv, %11
  br i1 %cmp15, label %land.lhs.true, label %LeafBlock

land.lhs.true:                                    ; preds = %for.body
  %idProduct17 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id13, i32 0, i32 2
  %12 = load i16, i16* %idProduct17, align 4, !tbaa !236
  %conv18 = zext i16 %12 to i32
  %13 = load i32, i32* %idProduct, align 4, !tbaa !90
  %cmp19 = icmp eq i32 %conv18, %13
  br i1 %cmp19, label %if.then21, label %LeafBlock

if.then21:                                        ; preds = %land.lhs.true
  %node22 = getelementptr inbounds %struct.usb_dynid, %struct.usb_dynid* %dynid.0, i32 0, i32 0
  call void @list_del(%struct.list_head* %node22)
  %14 = bitcast %struct.usb_dynid* %dynid.0 to i8*
  call void @kfree(i8* %14)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.then21, %land.lhs.true, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 2, %if.then21 ], [ 0, %land.lhs.true ], [ 0, %for.body ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf, label %for.end, label %for.inc

for.inc:                                          ; preds = %LeafBlock
  br label %for.cond

for.end:                                          ; preds = %LeafBlock, %for.cond
  %dynids29 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %1, i32 0, i32 10
  %lock30 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids29, i32 0, i32 0
  call void @spin_unlock.304(%struct.spinlock* %lock30)
  br label %cleanup31

cleanup31:                                        ; preds = %for.end, %entry
  %retval.0 = phi i64 [ %count, %for.end ], [ -22, %entry ]
  %15 = bitcast i32* %idProduct to i8*
  %16 = bitcast i32* %idVendor to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_register_driver(%struct.usb_driver* %new_driver, %struct.module* %owner, i8* %mod_name) #0 {
entry:
  %call = call i32 @usb_disabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %drvwrap = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %for_devices = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 1
  store i32 0, i32* %for_devices, align 8, !tbaa !486
  %name = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !487
  %drvwrap2 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %driver = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap2, i32 0, i32 0
  %name3 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver, i32 0, i32 0
  store i8* %0, i8** %name3, align 8, !tbaa !488
  %drvwrap4 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %driver5 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap4, i32 0, i32 0
  %bus = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver5, i32 0, i32 1
  store %struct.bus_type* @usb_bus_type, %struct.bus_type** %bus, align 8, !tbaa !489
  %drvwrap6 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %driver7 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap6, i32 0, i32 0
  %probe = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver7, i32 0, i32 7
  store i32 (%struct.device*)* @usb_probe_interface, i32 (%struct.device*)** %probe, align 8, !tbaa !490
  %drvwrap8 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %driver9 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap8, i32 0, i32 0
  %remove = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver9, i32 0, i32 8
  store i32 (%struct.device*)* @usb_unbind_interface, i32 (%struct.device*)** %remove, align 8, !tbaa !491
  %drvwrap10 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %driver11 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap10, i32 0, i32 0
  %owner12 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver11, i32 0, i32 2
  store %struct.module* %owner, %struct.module** %owner12, align 8, !tbaa !492
  %drvwrap13 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %driver14 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap13, i32 0, i32 0
  %mod_name15 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver14, i32 0, i32 3
  store i8* %mod_name, i8** %mod_name15, align 8, !tbaa !493
  %dynids = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 10
  %lock = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids, i32 0, i32 0
  call void @spinlock_check.348(%struct.spinlock* %lock)
  %dynids18 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 10
  %lock19 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids18, i32 0, i32 0
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock19, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %1 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.7.349, i32 0, i32 0), %struct.lock_class_key* @usb_register_driver.__key)
  %dynids22 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 10
  %list = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %dynids22, i32 0, i32 1
  call void @INIT_LIST_HEAD.339(%struct.list_head* %list)
  %drvwrap23 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %driver24 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap23, i32 0, i32 0
  %call25 = call i32 @driver_register(%struct.device_driver* %driver24)
  %tobool26 = icmp ne i32 %call25, 0
  br i1 %tobool26, label %cleanup, label %if.end28

if.end28:                                         ; preds = %if.end
  %call29 = call i32 @usb_create_newid_files(%struct.usb_driver* %new_driver)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %out_newid, label %if.end32

if.end32:                                         ; preds = %if.end28
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

out_newid:                                        ; preds = %if.end28
  %drvwrap35 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %new_driver, i32 0, i32 11
  %driver36 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap35, i32 0, i32 0
  call void @driver_unregister(%struct.device_driver* %driver36)
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %out_newid, %if.end32, %if.end, %entry
  %retval.0 = phi i32 [ -19, %entry ], [ %call29, %out_newid ], [ %call29, %if.end32 ], [ %call25, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_probe_interface(%struct.device* %dev) #0 {
entry:
  %driver1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver1, align 8, !tbaa !56
  %1 = bitcast %struct.device_driver* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -168
  %2 = bitcast i8* %add.ptr to %struct.usb_driver*
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr4 = getelementptr inbounds i8, i8* %3, i64 -48
  %4 = bitcast i8* %add.ptr4 to %struct.usb_interface*
  %call = call %struct.usb_device* @interface_to_usbdev.294(%struct.usb_interface* %4)
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_probe_interface.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then, label %do.end10

if.then:                                          ; preds = %entry
  %call8 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_probe_interface.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11.859, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.usb_probe_interface, i32 0, i32 0))
  br label %do.end10

do.end10:                                         ; preds = %if.then, %entry
  %needs_binding = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load11 = load i8, i8* %needs_binding, align 8
  %bf.clear12 = and i8 %bf.load11, -33
  store i8 %bf.clear12, i8* %needs_binding, align 8
  %call13 = call zeroext i1 @usb_device_is_owned(%struct.usb_device* %call)
  br i1 %call13, label %cleanup, label %if.end15

if.end15:                                         ; preds = %do.end10
  %authorized = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 22
  %bf.load16 = load i16, i16* %authorized, align 4
  %bf.lshr17 = lshr i16 %bf.load16, 3
  %bf.clear18 = and i16 %bf.lshr17, 1
  %bf.cast = zext i16 %bf.clear18 to i32
  %cmp = icmp eq i32 %bf.cast, 0
  br i1 %cmp, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end15
  %5 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end23:                                         ; preds = %if.end15
  %id_table = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 9
  %6 = load %struct.usb_device_id*, %struct.usb_device_id** %id_table, align 8, !tbaa !470
  %call24 = call %struct.usb_device_id* @usb_match_id(%struct.usb_interface* %4, %struct.usb_device_id* %6)
  %tobool25 = icmp ne %struct.usb_device_id* %call24, null
  br i1 %tobool25, label %if.end28, label %if.then26

if.then26:                                        ; preds = %if.end23
  %call27 = call %struct.usb_device_id* @usb_match_dynamic_id(%struct.usb_interface* %4, %struct.usb_driver* %2)
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %if.end23
  %id.0 = phi %struct.usb_device_id* [ %call24, %if.end23 ], [ %call27, %if.then26 ]
  %tobool29 = icmp ne %struct.usb_device_id* %id.0, null
  br i1 %tobool29, label %do.body33, label %cleanup

do.body33:                                        ; preds = %if.end28
  %bf.load34 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_probe_interface.descriptor.19 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr35 = lshr i32 %bf.load34, 18
  %bf.clear36 = and i32 %bf.lshr35, 255
  %and37 = and i32 %bf.clear36, 1
  %tobool38 = icmp ne i32 %and37, 0
  %lnot39 = xor i1 %tobool38, true
  %lnot41 = xor i1 %lnot39, true
  %lnot.ext42 = zext i1 %lnot41 to i32
  %conv43 = sext i32 %lnot.ext42 to i64
  %expval44 = call i64 @llvm.expect.i64(i64 %conv43, i64 0)
  %tobool45 = icmp ne i64 %expval44, 0
  br i1 %tobool45, label %if.then46, label %do.end52

if.then46:                                        ; preds = %do.body33
  %call47 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_probe_interface.descriptor.19 to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.20.363, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.usb_probe_interface, i32 0, i32 0))
  br label %do.end52

do.end52:                                         ; preds = %if.then46, %do.body33
  %call53 = call i32 @usb_autoresume_device(%struct.usb_device* %call)
  %tobool54 = icmp ne i32 %call53, 0
  br i1 %tobool54, label %cleanup, label %if.end56

if.end56:                                         ; preds = %do.end52
  %condition = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 5
  store i32 1, i32* %condition, align 4, !tbaa !51
  call void @pm_runtime_set_active.364(%struct.device* %dev)
  call void @pm_suspend_ignore_children.365(%struct.device* %dev, i1 zeroext false)
  %supports_autosuspend = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 12
  %bf.load58 = load i8, i8* %supports_autosuspend, align 8
  %bf.lshr59 = lshr i8 %bf.load58, 1
  %bf.clear60 = and i8 %bf.lshr59, 1
  %bf.cast61 = zext i8 %bf.clear60 to i32
  %tobool62 = icmp ne i32 %bf.cast61, 0
  br i1 %tobool62, label %if.then63, label %if.end64

if.then63:                                        ; preds = %if.end56
  call void @pm_runtime_enable(%struct.device* %dev)
  br label %if.end64

if.end64:                                         ; preds = %if.then63, %if.end56
  %call65 = call i32 @usb_unlocked_disable_lpm(%struct.usb_device* %call)
  %tobool66 = icmp ne i32 %call65, 0
  br i1 %tobool66, label %land.lhs.true, label %if.end75

land.lhs.true:                                    ; preds = %if.end64
  %disable_hub_initiated_lpm = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 12
  %bf.load67 = load i8, i8* %disable_hub_initiated_lpm, align 8
  %bf.lshr68 = lshr i8 %bf.load67, 2
  %bf.clear69 = and i8 %bf.lshr68, 1
  %bf.cast70 = zext i8 %bf.clear69 to i32
  %tobool71 = icmp ne i32 %bf.cast70, 0
  br i1 %tobool71, label %if.then72, label %if.end75

if.then72:                                        ; preds = %land.lhs.true
  %7 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %err

if.end75:                                         ; preds = %land.lhs.true, %if.end64
  %needs_altsetting0 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load76 = load i8, i8* %needs_altsetting0, align 8
  %bf.lshr77 = lshr i8 %bf.load76, 4
  %bf.clear78 = and i8 %bf.lshr77, 1
  %bf.cast79 = zext i8 %bf.clear78 to i32
  %tobool80 = icmp ne i32 %bf.cast79, 0
  br i1 %tobool80, label %if.then81, label %if.end91

if.then81:                                        ; preds = %if.end75
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 0
  %8 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !60
  %arrayidx = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %8, i64 0
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %9 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !68
  %conv82 = zext i8 %9 to i32
  %call83 = call i32 @usb_set_interface(%struct.usb_device* %call, i32 %conv82, i32 0)
  %cmp84 = icmp slt i32 %call83, 0
  br i1 %cmp84, label %err, label %if.end87

if.end87:                                         ; preds = %if.then81
  %needs_altsetting088 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load89 = load i8, i8* %needs_altsetting088, align 8
  %bf.clear90 = and i8 %bf.load89, -17
  store i8 %bf.clear90, i8* %needs_altsetting088, align 8
  br label %if.end91

if.end91:                                         ; preds = %if.end87, %if.end75
  %probe = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 1
  %10 = load i32 (%struct.usb_interface*, %struct.usb_device_id*)*, i32 (%struct.usb_interface*, %struct.usb_device_id*)** %probe, align 8, !tbaa !479
  %call92 = call i32 %10(%struct.usb_interface* %4, %struct.usb_device_id* %id.0)
  %tobool93 = icmp ne i32 %call92, 0
  br i1 %tobool93, label %err, label %if.end95

if.end95:                                         ; preds = %if.end91
  %condition96 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 5
  store i32 2, i32* %condition96, align 4, !tbaa !51
  %tobool97 = icmp ne i32 %call65, 0
  br i1 %tobool97, label %if.end99, label %if.then98

if.then98:                                        ; preds = %if.end95
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %call)
  br label %if.end99

if.end99:                                         ; preds = %if.then98, %if.end95
  call void @usb_autosuspend_device(%struct.usb_device* %call)
  br label %cleanup

err:                                              ; preds = %if.end91, %if.then81, %if.then72
  %error.0 = phi i32 [ %call65, %if.then72 ], [ %call83, %if.then81 ], [ %call92, %if.end91 ]
  call void @usb_set_intfdata.354(%struct.usb_interface* %4, i8* null)
  %needs_remote_wakeup = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load100 = load i8, i8* %needs_remote_wakeup, align 8
  %bf.clear101 = and i8 %bf.load100, -9
  store i8 %bf.clear101, i8* %needs_remote_wakeup, align 8
  %condition102 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 5
  store i32 0, i32* %condition102, align 4, !tbaa !51
  call void @usb_cancel_queued_reset(%struct.usb_interface* %4)
  %tobool103 = icmp ne i32 %call65, 0
  br i1 %tobool103, label %if.end105, label %if.then104

if.then104:                                       ; preds = %err
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %call)
  br label %if.end105

if.end105:                                        ; preds = %if.then104, %err
  %supports_autosuspend106 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 12
  %bf.load107 = load i8, i8* %supports_autosuspend106, align 8
  %bf.lshr108 = lshr i8 %bf.load107, 1
  %bf.clear109 = and i8 %bf.lshr108, 1
  %bf.cast110 = zext i8 %bf.clear109 to i32
  %tobool111 = icmp ne i32 %bf.cast110, 0
  br i1 %tobool111, label %if.then112, label %if.end113

if.then112:                                       ; preds = %if.end105
  call void @pm_runtime_disable.355(%struct.device* %dev)
  br label %if.end113

if.end113:                                        ; preds = %if.then112, %if.end105
  call void @pm_runtime_set_suspended.356(%struct.device* %dev)
  call void @usb_autosuspend_device(%struct.usb_device* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.end113, %if.end99, %do.end52, %if.end28, %if.then20, %do.end10
  %retval.0 = phi i32 [ -19, %if.then20 ], [ %error.0, %if.end113 ], [ %call92, %if.end99 ], [ -19, %do.end10 ], [ -19, %if.end28 ], [ %call53, %do.end52 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_unbind_interface(%struct.device* %dev) #0 {
entry:
  %driver1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver1, align 8, !tbaa !56
  %1 = bitcast %struct.device_driver* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -168
  %2 = bitcast i8* %add.ptr to %struct.usb_driver*
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr4 = getelementptr inbounds i8, i8* %3, i64 -48
  %4 = bitcast i8* %add.ptr4 to %struct.usb_interface*
  %condition = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 5
  store i32 3, i32* %condition, align 4, !tbaa !51
  %call = call %struct.usb_device* @interface_to_usbdev.294(%struct.usb_interface* %4)
  %call5 = call i32 @usb_autoresume_device(%struct.usb_device* %call)
  %call6 = call i32 @usb_unlocked_disable_lpm(%struct.usb_device* %call)
  %soft_unbind = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 12
  %bf.load = load i8, i8* %soft_unbind, align 8
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @usb_disable_interface(%struct.usb_device* %call, %struct.usb_interface* %4, i1 zeroext false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %disconnect = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 2
  %5 = load void (%struct.usb_interface*)*, void (%struct.usb_interface*)** %disconnect, align 8, !tbaa !494
  call void %5(%struct.usb_interface* %4)
  call void @usb_cancel_queued_reset(%struct.usb_interface* %4)
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 1
  %6 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !148
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %6, i32 0, i32 0
  %bAlternateSetting = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 3
  %7 = load i8, i8* %bAlternateSetting, align 1, !tbaa !61
  %conv = zext i8 %7 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end
  call void @usb_enable_interface(%struct.usb_device* %call, %struct.usb_interface* %4, i1 zeroext false)
  br label %if.end31

if.else:                                          ; preds = %if.end
  %tobool9 = icmp ne i32 %call5, 0
  br i1 %tobool9, label %if.end30.sink.split, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %dev10 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 7
  %power = getelementptr inbounds %struct.device, %struct.device* %dev10, i32 0, i32 9
  %is_prepared = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load11 = load i8, i8* %is_prepared, align 4
  %bf.lshr12 = lshr i8 %bf.load11, 2
  %bf.clear13 = and i8 %bf.lshr12, 1
  %bf.cast14 = trunc i8 %bf.clear13 to i1
  br i1 %bf.cast14, label %if.end30.sink.split, label %if.then15

if.then15:                                        ; preds = %land.lhs.true
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 0
  %8 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !60
  %arrayidx = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %8, i64 0
  %desc16 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc16, i32 0, i32 2
  %9 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !68
  %conv17 = zext i8 %9 to i32
  %call18 = call i32 @usb_set_interface(%struct.usb_device* %call, i32 %conv17, i32 0)
  %cmp19 = icmp slt i32 %call18, 0
  br i1 %cmp19, label %if.end30.sink.split, label %if.end31

if.end30.sink.split:                              ; preds = %if.then15, %land.lhs.true, %if.else
  %needs_altsetting026 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load22 = load i8, i8* %needs_altsetting026, align 8
  %bf.clear23 = and i8 %bf.load22, -17
  %bf.set = or i8 %bf.clear23, 16
  store i8 %bf.set, i8* %needs_altsetting026, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.end30.sink.split, %if.then15, %if.then8
  call void @usb_set_intfdata.354(%struct.usb_interface* %4, i8* null)
  %condition32 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 5
  store i32 0, i32* %condition32, align 4, !tbaa !51
  %needs_remote_wakeup = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load33 = load i8, i8* %needs_remote_wakeup, align 8
  %bf.clear34 = and i8 %bf.load33, -9
  store i8 %bf.clear34, i8* %needs_remote_wakeup, align 8
  %tobool35 = icmp ne i32 %call6, 0
  br i1 %tobool35, label %if.end37, label %if.then36

if.then36:                                        ; preds = %if.end31
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %call)
  br label %if.end37

if.end37:                                         ; preds = %if.then36, %if.end31
  %supports_autosuspend = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %2, i32 0, i32 12
  %bf.load38 = load i8, i8* %supports_autosuspend, align 8
  %bf.lshr39 = lshr i8 %bf.load38, 1
  %bf.clear40 = and i8 %bf.lshr39, 1
  %bf.cast41 = zext i8 %bf.clear40 to i32
  %tobool42 = icmp ne i32 %bf.cast41, 0
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end37
  call void @pm_runtime_disable.355(%struct.device* %dev)
  br label %if.end44

if.end44:                                         ; preds = %if.then43, %if.end37
  call void @pm_runtime_set_suspended.356(%struct.device* %dev)
  %pm_usage_cnt = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 9
  %call45 = call i32 @atomic_read.315(%union.anon.5* %pm_usage_cnt)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end44
  %r.0 = phi i32 [ %call45, %if.end44 ], [ %dec, %for.body ]
  %cmp46 = icmp sgt i32 %r.0, 0
  br i1 %cmp46, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @usb_autopm_put_interface_no_suspend(%struct.usb_interface* %4)
  %dec = add nsw i32 %r.0, -1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %pm_usage_cnt48 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 9
  call void @atomic_set.357(%union.anon.5* %pm_usage_cnt48, i32 0)
  %tobool49 = icmp ne i32 %call5, 0
  br i1 %tobool49, label %if.end51, label %if.then50

if.then50:                                        ; preds = %for.end
  call void @usb_autosuspend_device(%struct.usb_device* %call)
  br label %if.end51

if.end51:                                         ; preds = %if.then50, %for.end
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spinlock_check.348(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  ret void
}

declare i32 @driver_register(%struct.device_driver*) #2

; Function Attrs: nounwind uwtable
define internal i32 @usb_create_newid_files(%struct.usb_driver* %usb_drv) #0 {
entry:
  %no_dynamic_id = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 12
  %bf.load = load i8, i8* %no_dynamic_id, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %exit, label %if.end

if.end:                                           ; preds = %entry
  %probe = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 1
  %0 = load i32 (%struct.usb_interface*, %struct.usb_device_id*)*, i32 (%struct.usb_interface*, %struct.usb_device_id*)** %probe, align 8, !tbaa !479
  %cmp = icmp ne i32 (%struct.usb_interface*, %struct.usb_device_id*)* %0, null
  br i1 %cmp, label %if.then1, label %exit

if.then1:                                         ; preds = %if.end
  %drvwrap = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 11
  %driver = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 0
  %call = call i32 @driver_create_file(%struct.device_driver* %driver, %struct.driver_attribute* @driver_attr_new_id)
  %cmp2 = icmp eq i32 %call, 0
  br i1 %cmp2, label %if.then3, label %exit

if.then3:                                         ; preds = %if.then1
  %drvwrap4 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 11
  %driver5 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap4, i32 0, i32 0
  %call6 = call i32 @driver_create_file(%struct.device_driver* %driver5, %struct.driver_attribute* @driver_attr_remove_id)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %exit

if.then8:                                         ; preds = %if.then3
  %drvwrap9 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %usb_drv, i32 0, i32 11
  %driver10 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap9, i32 0, i32 0
  call void @driver_remove_file(%struct.device_driver* %driver10, %struct.driver_attribute* @driver_attr_new_id)
  br label %exit

exit:                                             ; preds = %if.then8, %if.then3, %if.then1, %if.end, %entry
  %error.2 = phi i32 [ 0, %entry ], [ 0, %if.end ], [ %call, %if.then1 ], [ %call6, %if.then8 ], [ %call6, %if.then3 ]
  ret i32 %error.2
}

declare i32 @driver_create_file(%struct.device_driver*, %struct.driver_attribute*) #2

; Function Attrs: nounwind uwtable
define i32 @usb_autoresume_device(%struct.usb_device* %udev) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call = call i32 @pm_runtime_get_sync.319(%struct.device* %dev)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_put_sync.320(%struct.device* %dev1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %cmp3 = icmp sgt i32 %call, 0
  %.call = select i1 %cmp3, i32 0, i32 %call
  ret i32 %.call
}

; Function Attrs: nounwind uwtable
define internal void @usb_cancel_queued_reset(%struct.usb_interface* %iface) #0 {
entry:
  %reset_running = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 6
  %bf.load = load i8, i8* %reset_running, align 8
  %bf.lshr = lshr i8 %bf.load, 6
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %reset_ws = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 10
  %call = call zeroext i1 @cancel_work_sync(%struct.work_struct* %reset_ws)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_set_intfdata.354(%struct.usb_interface* %intf, i8* %data) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i32 @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_disable.355(%struct.device* %dev) #1 {
entry:
  call void @__pm_runtime_disable(%struct.device* %dev, i1 zeroext true)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_set_suspended.356(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_set_status(%struct.device* %dev, i32 2)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set.357(%union.anon.5* %v, i32 %i) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !94
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_autosuspend_device(%struct.usb_device* %udev) #0 {
entry:
  call void @usb_mark_last_busy.308(%struct.usb_device* %udev)
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_put_sync_autosuspend.360(%struct.device* %dev)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put_sync_autosuspend.360(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_suspend(%struct.device* %dev, i32 12)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_set_active.364(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_set_status(%struct.device* %dev, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_suspend_ignore_children.365(%struct.device* %dev, i1 zeroext %enable) #1 {
entry:
  %frombool = zext i1 %enable to i8
  %tobool = trunc i8 %frombool to i1
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %ignore_children = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %0 = zext i1 %tobool to i8
  %bf.load = load i8, i8* %ignore_children, align 4
  %bf.shl = shl i8 %0, 4
  %bf.clear = and i8 %bf.load, -17
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, i8* %ignore_children, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_deregister_device_driver(%struct.usb_device_driver* %udriver) #0 {
entry:
  %0 = call i32 (i8*, ...) @printk(i8* null)
  %drvwrap = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %udriver, i32 0, i32 5
  %driver = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 0
  call void @driver_unregister(%struct.device_driver* %driver)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_register_device_driver(%struct.usb_device_driver* %new_udriver, %struct.module* %owner) #0 {
entry:
  %call = call i32 @usb_disabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %drvwrap = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %new_udriver, i32 0, i32 5
  %for_devices = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 1
  store i32 1, i32* %for_devices, align 8, !tbaa !495
  %name = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %new_udriver, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !497
  %drvwrap2 = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %new_udriver, i32 0, i32 5
  %driver = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap2, i32 0, i32 0
  %name3 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver, i32 0, i32 0
  store i8* %0, i8** %name3, align 8, !tbaa !498
  %drvwrap4 = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %new_udriver, i32 0, i32 5
  %driver5 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap4, i32 0, i32 0
  %bus = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver5, i32 0, i32 1
  store %struct.bus_type* @usb_bus_type, %struct.bus_type** %bus, align 8, !tbaa !499
  %drvwrap6 = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %new_udriver, i32 0, i32 5
  %driver7 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap6, i32 0, i32 0
  %probe = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver7, i32 0, i32 7
  store i32 (%struct.device*)* @usb_probe_device, i32 (%struct.device*)** %probe, align 8, !tbaa !500
  %drvwrap8 = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %new_udriver, i32 0, i32 5
  %driver9 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap8, i32 0, i32 0
  %remove = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver9, i32 0, i32 8
  store i32 (%struct.device*)* @usb_unbind_device, i32 (%struct.device*)** %remove, align 8, !tbaa !501
  %drvwrap10 = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %new_udriver, i32 0, i32 5
  %driver11 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap10, i32 0, i32 0
  %owner12 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver11, i32 0, i32 2
  store %struct.module* %owner, %struct.module** %owner12, align 8, !tbaa !502
  %drvwrap13 = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %new_udriver, i32 0, i32 5
  %driver14 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap13, i32 0, i32 0
  %call15 = call i32 @driver_register(%struct.device_driver* %driver14)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.else, label %if.then17

if.then17:                                        ; preds = %if.end
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.else:                                          ; preds = %if.end
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.then17, %entry
  %retval.0 = phi i32 [ -19, %entry ], [ %call15, %if.else ], [ %call15, %if.then17 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_probe_device(%struct.device* %dev) #0 {
entry:
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !56
  %1 = bitcast %struct.device_driver* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -40
  %2 = bitcast i8* %add.ptr to %struct.usb_device_driver*
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -136
  %4 = bitcast i8* %add.ptr3 to %struct.usb_device*
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_probe_device.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %do.end8

if.then:                                          ; preds = %entry
  %call = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_probe_device.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11.859, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.usb_probe_device, i32 0, i32 0))
  br label %do.end8

do.end8:                                          ; preds = %if.then, %entry
  %supports_autosuspend = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %2, i32 0, i32 6
  %bf.load9 = load i8, i8* %supports_autosuspend, align 8
  %bf.clear10 = and i8 %bf.load9, 1
  %bf.cast = zext i8 %bf.clear10 to i32
  %tobool11 = icmp ne i32 %bf.cast, 0
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %do.end8
  %call13 = call i32 @usb_autoresume_device(%struct.usb_device* %4)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %do.end8
  %error.0 = phi i32 [ 0, %do.end8 ], [ %call13, %if.then12 ]
  %tobool15 = icmp ne i32 %error.0, 0
  br i1 %tobool15, label %if.end18, label %if.then16

if.then16:                                        ; preds = %if.end14
  %probe = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %2, i32 0, i32 1
  %5 = load i32 (%struct.usb_device*)*, i32 (%struct.usb_device*)** %probe, align 8, !tbaa !503
  %call17 = call i32 %5(%struct.usb_device* %4)
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.end14
  %error.1 = phi i32 [ %error.0, %if.end14 ], [ %call17, %if.then16 ]
  ret i32 %error.1
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_unbind_device(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %2 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !56
  %3 = bitcast %struct.device_driver* %2 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.usb_device_driver*
  %disconnect = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %4, i32 0, i32 2
  %5 = load void (%struct.usb_device*)*, void (%struct.usb_device*)** %disconnect, align 8, !tbaa !504
  call void %5(%struct.usb_device* %1)
  %supports_autosuspend = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %4, i32 0, i32 6
  %bf.load = load i8, i8* %supports_autosuspend, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @usb_autosuspend_device(%struct.usb_device* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}

; Function Attrs: nounwind uwtable
define void @usb_driver_release_interface(%struct.usb_driver* %driver, %struct.usb_interface* %iface) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 7
  %driver2 = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver2, align 8, !tbaa !56
  %tobool = icmp ne %struct.device_driver* %0, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup.cont

lor.lhs.false:                                    ; preds = %entry
  %driver3 = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 7
  %1 = load %struct.device_driver*, %struct.device_driver** %driver3, align 8, !tbaa !56
  %drvwrap = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver, i32 0, i32 11
  %driver4 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 0
  %cmp = icmp ne %struct.device_driver* %1, %driver4
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %condition = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 5
  %2 = load i32, i32* %condition, align 4, !tbaa !51
  %cmp5 = icmp ne i32 %2, 2
  br i1 %cmp5, label %cleanup.cont, label %if.end7

if.end7:                                          ; preds = %if.end
  %condition8 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 5
  store i32 3, i32* %condition8, align 4, !tbaa !51
  %call = call i32 @device_is_registered.374(%struct.device* %dev1)
  %tobool9 = icmp ne i32 %call, 0
  br i1 %tobool9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end7
  call void @device_release_driver(%struct.device* %dev1)
  br label %cleanup.cont

if.else:                                          ; preds = %if.end7
  call void @device_lock.375(%struct.device* %dev1)
  %call11 = call i32 @usb_unbind_interface(%struct.device* %dev1)
  %driver12 = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 7
  store %struct.device_driver* null, %struct.device_driver** %driver12, align 8, !tbaa !56
  call void @device_unlock.376(%struct.device* %dev1)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.else, %if.then10, %if.end, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @device_is_registered.374(%struct.device* %dev) #1 {
entry:
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %state_in_sysfs = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 7
  %bf.load = load i8, i8* %state_in_sysfs, align 4
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  ret i32 %bf.cast
}

declare void @device_release_driver(%struct.device*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock.375(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock.376(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_driver_claim_interface(%struct.usb_driver* %driver, %struct.usb_interface* %iface, i8* %priv) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 7
  %driver3 = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver3, align 8, !tbaa !56
  %tobool = icmp ne %struct.device_driver* %0, null
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call %struct.usb_device* @interface_to_usbdev.294(%struct.usb_interface* %iface)
  %drvwrap = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver, i32 0, i32 11
  %driver4 = getelementptr inbounds %struct.usbdrv_wrap, %struct.usbdrv_wrap* %drvwrap, i32 0, i32 0
  %driver5 = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 7
  store %struct.device_driver* %driver4, %struct.device_driver** %driver5, align 8, !tbaa !56
  call void @usb_set_intfdata.354(%struct.usb_interface* %iface, i8* %priv)
  %needs_binding = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 6
  %bf.load = load i8, i8* %needs_binding, align 8
  %bf.clear = and i8 %bf.load, -33
  store i8 %bf.clear, i8* %needs_binding, align 8
  %condition = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 5
  store i32 2, i32* %condition, align 4, !tbaa !51
  %call6 = call i32 @usb_unlocked_disable_lpm(%struct.usb_device* %call)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end14

land.lhs.true:                                    ; preds = %if.end
  %disable_hub_initiated_lpm = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver, i32 0, i32 12
  %bf.load8 = load i8, i8* %disable_hub_initiated_lpm, align 8
  %bf.lshr = lshr i8 %bf.load8, 2
  %bf.clear9 = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear9 to i32
  %tobool10 = icmp ne i32 %bf.cast, 0
  br i1 %tobool10, label %if.then11, label %if.end14

if.then11:                                        ; preds = %land.lhs.true
  %1 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end14:                                         ; preds = %land.lhs.true, %if.end
  call void @pm_suspend_ignore_children.365(%struct.device* %dev1, i1 zeroext false)
  %supports_autosuspend = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver, i32 0, i32 12
  %bf.load15 = load i8, i8* %supports_autosuspend, align 8
  %bf.lshr16 = lshr i8 %bf.load15, 1
  %bf.clear17 = and i8 %bf.lshr16, 1
  %bf.cast18 = zext i8 %bf.clear17 to i32
  %tobool19 = icmp ne i32 %bf.cast18, 0
  br i1 %tobool19, label %if.then20, label %if.else

if.then20:                                        ; preds = %if.end14
  call void @pm_runtime_enable(%struct.device* %dev1)
  br label %if.end22

if.else:                                          ; preds = %if.end14
  call void @pm_runtime_set_active.364(%struct.device* %dev1)
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then20
  %call23 = call i32 @device_is_registered.374(%struct.device* %dev1)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.end22
  %call26 = call i32 @device_bind_driver(%struct.device* %dev1)
  br label %if.end27

if.end27:                                         ; preds = %if.then25, %if.end22
  %retval2.0 = phi i32 [ %call26, %if.then25 ], [ 0, %if.end22 ]
  %tobool28 = icmp ne i32 %call6, 0
  br i1 %tobool28, label %cleanup, label %if.then29

if.then29:                                        ; preds = %if.end27
  call void @usb_unlocked_enable_lpm(%struct.usb_device* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.then29, %if.end27, %if.then11, %entry
  %retval.0 = phi i32 [ -12, %if.then11 ], [ -16, %entry ], [ %retval2.0, %if.then29 ], [ %retval2.0, %if.end27 ]
  ret i32 %retval.0
}

declare i32 @device_bind_driver(%struct.device*) #2

; Function Attrs: nounwind uwtable
define void @usb_forced_unbind_intf(%struct.usb_interface* %intf) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %driver1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver1, align 8, !tbaa !104
  %1 = bitcast %struct.device_driver* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -168
  %2 = bitcast i8* %add.ptr to %struct.usb_driver*
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_forced_unbind_intf.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %do.end7

if.then:                                          ; preds = %entry
  %dev5 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_forced_unbind_intf.descriptor to %struct._ddebug*), %struct.device* %dev5, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.13.379, i32 0, i32 0))
  br label %do.end7

do.end7:                                          ; preds = %if.then, %entry
  call void @usb_driver_release_interface(%struct.usb_driver* %2, %struct.usb_interface* %intf)
  %needs_binding = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load8 = load i8, i8* %needs_binding, align 8
  %bf.clear9 = and i8 %bf.load8, -33
  %bf.set = or i8 %bf.clear9, 32
  store i8 %bf.set, i8* %needs_binding, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_rebind_intf(%struct.usb_interface* %intf) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !104
  %tobool = icmp ne %struct.device_driver* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @usb_forced_unbind_intf(%struct.usb_interface* %intf)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %dev1 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %power = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 9
  %is_prepared = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i8, i8* %is_prepared, align 4
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %if.end10, label %if.then2

if.then2:                                         ; preds = %if.end
  %needs_binding = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load3 = load i8, i8* %needs_binding, align 8
  %bf.clear4 = and i8 %bf.load3, -33
  store i8 %bf.clear4, i8* %needs_binding, align 8
  %dev5 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i32 @device_attach(%struct.device* %dev5)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then6, label %if.end10

if.then6:                                         ; preds = %if.then2
  %1 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end10

if.end10:                                         ; preds = %if.then6, %if.then2, %if.end
  ret void
}

declare i32 @device_attach(%struct.device*) #2

; Function Attrs: nounwind uwtable
define i32 @usb_suspend(%struct.device* %dev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  call void @unbind_no_pm_drivers_interfaces(%struct.usb_device* %1)
  %coerce.dive1 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %2 = load i32, i32* %coerce.dive1, align 4
  call void @choose_wakeup(%struct.usb_device* %1, i32 %2)
  %coerce.dive2 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %3 = load i32, i32* %coerce.dive2, align 4
  %call = call i32 @usb_suspend_both(%struct.usb_device* %1, i32 %3)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @unbind_no_pm_drivers_interfaces(%struct.usb_device* %udev) #0 {
entry:
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool, label %if.then, label %if.end10

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %1 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %if.end10

for.body:                                         ; preds = %for.cond
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %2 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !48
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %2, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %3 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !104
  %tobool2 = icmp ne %struct.device_driver* %3, null
  br i1 %tobool2, label %if.then3, label %for.inc

if.then3:                                         ; preds = %for.body
  %dev4 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %2, i32 0, i32 7
  %driver5 = getelementptr inbounds %struct.device, %struct.device* %dev4, i32 0, i32 7
  %4 = load %struct.device_driver*, %struct.device_driver** %driver5, align 8, !tbaa !104
  %5 = bitcast %struct.device_driver* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 -168
  %6 = bitcast i8* %add.ptr to %struct.usb_driver*
  %suspend = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %6, i32 0, i32 4
  %7 = load i32 (%struct.usb_interface*, i32)*, i32 (%struct.usb_interface*, i32)** %suspend, align 8, !tbaa !505
  %tobool6 = icmp ne i32 (%struct.usb_interface*, i32)* %7, null
  br i1 %tobool6, label %lor.lhs.false, label %if.then8

lor.lhs.false:                                    ; preds = %if.then3
  %resume = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %6, i32 0, i32 5
  %8 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %resume, align 8, !tbaa !506
  %tobool7 = icmp ne i32 (%struct.usb_interface*)* %8, null
  br i1 %tobool7, label %for.inc, label %if.then8

if.then8:                                         ; preds = %lor.lhs.false, %if.then3
  call void @usb_forced_unbind_intf(%struct.usb_interface* %2)
  br label %for.inc

for.inc:                                          ; preds = %if.then8, %lor.lhs.false, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end10:                                         ; preds = %for.cond, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @choose_wakeup(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %0 = load i32, i32* %event, align 4, !tbaa !42
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %event1 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %1 = load i32, i32* %event1, align 4, !tbaa !42
  %cmp2 = icmp eq i32 %1, 8
  br i1 %cmp2, label %if.then, label %if.end5

if.then:                                          ; preds = %lor.lhs.false, %entry
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %2 = load i32, i32* %state, align 8, !tbaa !50
  %cmp3 = icmp ne i32 %2, 8
  br i1 %cmp3, label %if.then4, label %cleanup.cont

if.then4:                                         ; preds = %if.then
  %do_remote_wakeup = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load = load i8, i8* %do_remote_wakeup, align 8
  %bf.clear = and i8 %bf.load, -2
  store i8 %bf.clear, i8* %do_remote_wakeup, align 8
  br label %cleanup.cont

if.end5:                                          ; preds = %lor.lhs.false
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call = call zeroext i1 @device_may_wakeup.389(%struct.device* %dev)
  %conv = zext i1 %call to i32
  %state6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %3 = load i32, i32* %state6, align 8, !tbaa !50
  %cmp7 = icmp eq i32 %3, 8
  br i1 %cmp7, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.end5
  %do_remote_wakeup9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load10 = load i8, i8* %do_remote_wakeup9, align 8
  %bf.clear11 = and i8 %bf.load10, 1
  %bf.cast = zext i8 %bf.clear11 to i32
  %cmp12 = icmp ne i32 %conv, %bf.cast
  br i1 %cmp12, label %if.then14, label %if.end17

if.then14:                                        ; preds = %land.lhs.true
  %dev15 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @pm_runtime_resume(%struct.device* %dev15)
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %land.lhs.true, %if.end5
  %do_remote_wakeup18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %4 = trunc i32 %conv to i8
  %bf.load19 = load i8, i8* %do_remote_wakeup18, align 8
  %bf.value = and i8 %4, 1
  %bf.clear20 = and i8 %bf.load19, -2
  %bf.set = or i8 %bf.clear20, %bf.value
  store i8 %bf.set, i8* %do_remote_wakeup18, align 8
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end17, %if.then4, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_suspend_both(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %done, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %state1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %1 = load i32, i32* %state1, align 8, !tbaa !50
  %cmp2 = icmp eq i32 %1, 8
  br i1 %cmp2, label %done, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %if.then3, label %if.end17

if.then3:                                         ; preds = %if.end
  %actconfig4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %3 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig4, align 8, !tbaa !64
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %3, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %4 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv = zext i8 %4 to i32
  %sub = sub nsw i32 %conv, 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then3
  %i.0 = phi i32 [ %sub, %if.then3 ], [ %dec, %for.inc ]
  %status.0 = phi i32 [ 0, %if.then3 ], [ %call., %for.inc ]
  %cmp5 = icmp sge i32 %i.0, 0
  br i1 %cmp5, label %for.body, label %if.end17

for.body:                                         ; preds = %for.cond
  %actconfig7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %5 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig7, align 8, !tbaa !64
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %6 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !48
  %coerce.dive8 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %7 = load i32, i32* %coerce.dive8, align 4
  %call = call i32 @usb_suspend_interface(%struct.usb_device* %udev, %struct.usb_interface* %6, i32 %7)
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %8 = load i32, i32* %event, align 4, !tbaa !42
  %and = and i32 %8, 1024
  %cmp9 = icmp ne i32 %and, 0
  %call. = select i1 %cmp9, i32 %call, i32 0
  %cmp13 = icmp ne i32 %call., 0
  br i1 %cmp13, label %if.end17, label %for.inc

for.inc:                                          ; preds = %for.body
  %dec = add nsw i32 %i.0, -1
  br label %for.cond

if.end17:                                         ; preds = %for.body, %for.cond, %if.end
  %n.0 = phi i32 [ 0, %if.end ], [ %conv, %for.cond ], [ %conv, %for.body ]
  %i.1 = phi i32 [ 0, %if.end ], [ %i.0, %for.cond ], [ %i.0, %for.body ]
  %status.3 = phi i32 [ 0, %if.end ], [ %call., %for.body ], [ %status.0, %for.cond ]
  %cmp18 = icmp eq i32 %status.3, 0
  br i1 %cmp18, label %if.then20, label %if.end30

if.then20:                                        ; preds = %if.end17
  %coerce.dive21 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %9 = load i32, i32* %coerce.dive21, align 4
  %call22 = call i32 @usb_suspend_device(%struct.usb_device* %udev, i32 %9)
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %10 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool23 = icmp ne %struct.usb_device* %10, null
  br i1 %tobool23, label %land.lhs.true, label %if.end30

land.lhs.true:                                    ; preds = %if.then20
  %event24 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %11 = load i32, i32* %event24, align 4, !tbaa !42
  %and25 = and i32 %11, 1024
  %cmp26 = icmp ne i32 %and25, 0
  %call22. = select i1 %cmp26, i32 %call22, i32 0
  br label %if.end30

if.end30:                                         ; preds = %land.lhs.true, %if.then20, %if.end17
  %status.5 = phi i32 [ %status.3, %if.end17 ], [ %call22, %if.then20 ], [ %call22., %land.lhs.true ]
  %cmp31 = icmp ne i32 %status.5, 0
  br i1 %cmp31, label %if.then33, label %if.else

if.then33:                                        ; preds = %if.end30
  %actconfig34 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %12 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig34, align 8, !tbaa !64
  %tobool35 = icmp ne %struct.usb_host_config* %12, null
  br i1 %tobool35, label %if.then36, label %done

if.then36:                                        ; preds = %if.then33
  %event37 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %13 = load i32, i32* %event37, align 4, !tbaa !42
  %xor = xor i32 %13, 18
  store i32 %xor, i32* %event37, align 4, !tbaa !42
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then36
  %i.2 = phi i32 [ %i.1, %if.then36 ], [ %inc, %while.body ]
  %inc = add nsw i32 %i.2, 1
  %cmp38 = icmp slt i32 %inc, %n.0
  br i1 %cmp38, label %while.body, label %done

while.body:                                       ; preds = %while.cond
  %actconfig40 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %14 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig40, align 8, !tbaa !64
  %interface41 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %14, i32 0, i32 3
  %idxprom42 = sext i32 %inc to i64
  %arrayidx43 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface41, i64 0, i64 %idxprom42
  %15 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx43, align 8, !tbaa !48
  %coerce.dive44 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %16 = load i32, i32* %coerce.dive44, align 4
  call void @usb_resume_interface(%struct.usb_device* %udev, %struct.usb_interface* %15, i32 %16, i32 0)
  br label %while.cond

if.else:                                          ; preds = %if.end30
  %can_submit = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %can_submit, align 4
  %bf.clear = and i16 %bf.load, -2
  store i16 %bf.clear, i16* %can_submit, align 4
  br label %for.cond47

for.cond47:                                       ; preds = %for.body50, %if.else
  %i.3 = phi i32 [ 0, %if.else ], [ %inc56, %for.body50 ]
  %cmp48 = icmp slt i32 %i.3, 16
  br i1 %cmp48, label %for.body50, label %done

for.body50:                                       ; preds = %for.cond47
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 17
  %idxprom51 = sext i32 %i.3 to i64
  %arrayidx52 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out, i64 0, i64 %idxprom51
  %17 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx52, align 8, !tbaa !48
  call void @usb_hcd_flush_endpoint(%struct.usb_device* %udev, %struct.usb_host_endpoint* %17)
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 16
  %idxprom53 = sext i32 %i.3 to i64
  %arrayidx54 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in, i64 0, i64 %idxprom53
  %18 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx54, align 8, !tbaa !48
  call void @usb_hcd_flush_endpoint(%struct.usb_device* %udev, %struct.usb_host_endpoint* %18)
  %inc56 = add nsw i32 %i.3, 1
  br label %for.cond47

done:                                             ; preds = %for.cond47, %while.cond, %if.then33, %lor.lhs.false, %entry
  %status.6 = phi i32 [ 0, %lor.lhs.false ], [ 0, %entry ], [ %status.5, %for.cond47 ], [ %status.5, %if.then33 ], [ %status.5, %while.cond ]
  ret i32 %status.6
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_suspend_interface(%struct.usb_device* %udev, %struct.usb_interface* %intf, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %done, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %condition = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 5
  %1 = load i32, i32* %condition, align 4, !tbaa !51
  %cmp1 = icmp eq i32 %1, 0
  br i1 %cmp1, label %done, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %driver2 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %2 = load %struct.device_driver*, %struct.device_driver** %driver2, align 8, !tbaa !104
  %3 = bitcast %struct.device_driver* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -168
  %4 = bitcast i8* %add.ptr to %struct.usb_driver*
  %suspend = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %4, i32 0, i32 4
  %5 = load i32 (%struct.usb_interface*, i32)*, i32 (%struct.usb_interface*, i32)** %suspend, align 8, !tbaa !505
  %coerce.dive3 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %6 = load i32, i32* %coerce.dive3, align 4
  %call = call i32 %5(%struct.usb_interface* %intf, i32 %6)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %done

land.lhs.true:                                    ; preds = %if.end
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %7 = load i32, i32* %event, align 4, !tbaa !42
  %and = and i32 %7, 1024
  %cmp4 = icmp ne i32 %and, 0
  br i1 %cmp4, label %done, label %if.then5

if.then5:                                         ; preds = %land.lhs.true
  %8 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %done

done:                                             ; preds = %if.then5, %land.lhs.true, %if.end, %lor.lhs.false, %entry
  %status.0 = phi i32 [ 0, %lor.lhs.false ], [ 0, %entry ], [ %call, %if.then5 ], [ %call, %land.lhs.true ], [ %call, %if.end ]
  ret i32 %status.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_suspend_device(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %done, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %state1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %1 = load i32, i32* %state1, align 8, !tbaa !50
  %cmp2 = icmp eq i32 %1, 8
  br i1 %cmp2, label %done, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %2 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !507
  %tobool = icmp ne %struct.device_driver* %2, null
  br i1 %tobool, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %driver5 = getelementptr inbounds %struct.device, %struct.device* %dev4, i32 0, i32 7
  %3 = load %struct.device_driver*, %struct.device_driver** %driver5, align 8, !tbaa !507
  %4 = bitcast %struct.device_driver* %3 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 -40
  %5 = bitcast i8* %add.ptr to %struct.usb_device_driver*
  br label %if.end6

if.else:                                          ; preds = %if.end
  %do_remote_wakeup = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load = load i8, i8* %do_remote_wakeup, align 8
  %bf.clear = and i8 %bf.load, -2
  store i8 %bf.clear, i8* %do_remote_wakeup, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.else, %if.then3
  %udriver.0 = phi %struct.usb_device_driver* [ %5, %if.then3 ], [ @usb_generic_driver, %if.else ]
  %suspend = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %udriver.0, i32 0, i32 3
  %6 = load i32 (%struct.usb_device*, i32)*, i32 (%struct.usb_device*, i32)** %suspend, align 8, !tbaa !508
  %coerce.dive7 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %7 = load i32, i32* %coerce.dive7, align 4
  %call = call i32 %6(%struct.usb_device* %udev, i32 %7)
  br label %done

done:                                             ; preds = %if.end6, %lor.lhs.false, %entry
  %status.0 = phi i32 [ %call, %if.end6 ], [ 0, %lor.lhs.false ], [ 0, %entry ]
  ret i32 %status.0
}

; Function Attrs: nounwind uwtable
define internal void @usb_resume_interface(%struct.usb_device* %udev, %struct.usb_interface* %intf, i32 %msg.coerce, i32 %reset_resume) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %done, label %if.end

if.end:                                           ; preds = %entry
  %condition = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 5
  %1 = load i32, i32* %condition, align 4, !tbaa !51
  %cmp1 = icmp eq i32 %1, 3
  br i1 %cmp1, label %done, label %if.end3

if.end3:                                          ; preds = %if.end
  %condition4 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 5
  %2 = load i32, i32* %condition4, align 4, !tbaa !51
  %cmp5 = icmp eq i32 %2, 0
  %needs_altsetting0 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load = load i8, i8* %needs_altsetting0, align 8
  br i1 %cmp5, label %if.then6, label %if.end16

if.then6:                                         ; preds = %if.end3
  %bf.lshr = lshr i8 %bf.load, 4
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %land.lhs.true, label %done

land.lhs.true:                                    ; preds = %if.then6
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %is_prepared = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load7 = load i8, i8* %is_prepared, align 4
  %bf.lshr8 = lshr i8 %bf.load7, 2
  %bf.clear9 = and i8 %bf.lshr8, 1
  %bf.cast10 = trunc i8 %bf.clear9 to i1
  br i1 %bf.cast10, label %done, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 0
  %3 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !60
  %arrayidx = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %3, i64 0
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %4 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !68
  %conv = zext i8 %4 to i32
  %call = call i32 @usb_set_interface(%struct.usb_device* %udev, i32 %conv, i32 0)
  %needs_altsetting012 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load13 = load i8, i8* %needs_altsetting012, align 8
  %bf.clear14 = and i8 %bf.load13, -17
  store i8 %bf.clear14, i8* %needs_altsetting012, align 8
  br label %done

if.end16:                                         ; preds = %if.end3
  %bf.lshr18 = lshr i8 %bf.load, 5
  %bf.clear19 = and i8 %bf.lshr18, 1
  %bf.cast20 = zext i8 %bf.clear19 to i32
  %tobool21 = icmp ne i32 %bf.cast20, 0
  br i1 %tobool21, label %done, label %if.end23

if.end23:                                         ; preds = %if.end16
  %dev24 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %driver25 = getelementptr inbounds %struct.device, %struct.device* %dev24, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver25, align 8, !tbaa !104
  %6 = bitcast %struct.device_driver* %5 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 -168
  %7 = bitcast i8* %add.ptr to %struct.usb_driver*
  %tobool26 = icmp ne i32 %reset_resume, 0
  br i1 %tobool26, label %if.then27, label %if.else44

if.then27:                                        ; preds = %if.end23
  %reset_resume28 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %7, i32 0, i32 6
  %8 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %reset_resume28, align 8, !tbaa !509
  %tobool29 = icmp ne i32 (%struct.usb_interface*)* %8, null
  br i1 %tobool29, label %if.then30, label %if.else

if.then30:                                        ; preds = %if.then27
  %reset_resume31 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %7, i32 0, i32 6
  %9 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %reset_resume31, align 8, !tbaa !509
  %call32 = call i32 %9(%struct.usb_interface* %intf)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %done

if.then34:                                        ; preds = %if.then30
  %10 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %done

if.else:                                          ; preds = %if.then27
  %needs_binding38 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load39 = load i8, i8* %needs_binding38, align 8
  %bf.clear40 = and i8 %bf.load39, -33
  %bf.set = or i8 %bf.clear40, 32
  store i8 %bf.set, i8* %needs_binding38, align 8
  %11 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %done

if.else44:                                        ; preds = %if.end23
  %resume = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %7, i32 0, i32 5
  %12 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %resume, align 8, !tbaa !506
  %call45 = call i32 %12(%struct.usb_interface* %intf)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %if.then47, label %done

if.then47:                                        ; preds = %if.else44
  %13 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %done

done:                                             ; preds = %if.then47, %if.else44, %if.else, %if.then34, %if.then30, %if.end16, %if.then11, %land.lhs.true, %if.then6, %if.end, %entry
  %status.2 = phi i32 [ 0, %entry ], [ 0, %if.end ], [ 0, %if.then11 ], [ 0, %land.lhs.true ], [ 0, %if.then6 ], [ 0, %if.end16 ], [ 0, %if.else ], [ %call32, %if.then34 ], [ %call32, %if.then30 ], [ %call45, %if.then47 ], [ %call45, %if.else44 ]
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @device_may_wakeup.389(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %can_wakeup = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i8, i8* %can_wakeup, align 4
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %power1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %wakeup = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power1, i32 0, i32 5
  %0 = load %struct.wakeup_source*, %struct.wakeup_source** %wakeup, align 8, !tbaa !403
  %tobool2 = icmp ne %struct.wakeup_source* %0, null
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %1 = phi i1 [ false, %entry ], [ %lnot3, %land.rhs ]
  ret i1 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_resume(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_resume(%struct.device* %dev, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_resume_complete(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 3
  %2 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp ne i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @do_rebind_interfaces(%struct.usb_device* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @do_rebind_interfaces(%struct.usb_device* %udev) #0 {
entry:
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %1 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %if.end4

for.body:                                         ; preds = %for.cond
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %2 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !48
  %needs_binding = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %2, i32 0, i32 6
  %bf.load = load i8, i8* %needs_binding, align 8
  %bf.lshr = lshr i8 %bf.load, 5
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool2 = icmp ne i32 %bf.cast, 0
  br i1 %tobool2, label %if.then3, label %for.inc

if.then3:                                         ; preds = %for.body
  call void @usb_rebind_intf(%struct.usb_interface* %2)
  br label %for.inc

for.inc:                                          ; preds = %if.then3, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end4:                                          ; preds = %for.cond, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_resume(%struct.device* %dev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %coerce.dive1 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %2 = load i32, i32* %coerce.dive1, align 4
  %call = call i32 @usb_resume_both(%struct.usb_device* %1, i32 %2)
  switch i32 %call, label %if.end6 [
    i32 0, label %if.then
    i32 -19, label %if.then5
    i32 -108, label %if.then5
  ]

if.then:                                          ; preds = %entry
  call void @pm_runtime_disable.355(%struct.device* %dev)
  call void @pm_runtime_set_active.364(%struct.device* %dev)
  call void @pm_runtime_enable(%struct.device* %dev)
  call void @unbind_no_reset_resume_drivers_interfaces(%struct.usb_device* %1)
  br label %if.end6

if.then5:                                         ; preds = %entry, %entry
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.then, %entry
  %status.0 = phi i32 [ 0, %if.then5 ], [ %call, %if.then ], [ %call, %entry ]
  ret i32 %status.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_resume_both(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %done, label %if.end

if.end:                                           ; preds = %entry
  %can_submit = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %can_submit, align 4
  %bf.clear = and i16 %bf.load, -2
  %bf.set = or i16 %bf.clear, 1
  store i16 %bf.set, i16* %can_submit, align 4
  %state1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %1 = load i32, i32* %state1, align 8, !tbaa !50
  %cmp2 = icmp eq i32 %1, 8
  br i1 %cmp2, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %reset_resume = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load3 = load i8, i8* %reset_resume, align 8
  %bf.lshr = lshr i8 %bf.load3, 1
  %bf.clear4 = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear4 to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then5, label %if.end7

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %coerce.dive6 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %2 = load i32, i32* %coerce.dive6, align 4
  %call = call i32 @usb_resume_device(%struct.usb_device* %udev, i32 %2)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %lor.lhs.false
  %status.0 = phi i32 [ %call, %if.then5 ], [ 0, %lor.lhs.false ]
  %cmp8 = icmp eq i32 %status.0, 0
  br i1 %cmp8, label %land.lhs.true, label %if.end22

land.lhs.true:                                    ; preds = %if.end7
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %3 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool9 = icmp ne %struct.usb_host_config* %3, null
  br i1 %tobool9, label %if.then10, label %if.end22

if.then10:                                        ; preds = %land.lhs.true
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then10
  %i.0 = phi i32 [ 0, %if.then10 ], [ %inc, %for.body ]
  %actconfig11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %4 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig11, align 8, !tbaa !64
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %4, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %5 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv = zext i8 %5 to i32
  %cmp12 = icmp slt i32 %i.0, %conv
  br i1 %cmp12, label %for.body, label %if.end22

for.body:                                         ; preds = %for.cond
  %actconfig14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %6 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig14, align 8, !tbaa !64
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %6, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %7 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !48
  %reset_resume15 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load16 = load i8, i8* %reset_resume15, align 8
  %bf.lshr17 = lshr i8 %bf.load16, 1
  %bf.clear18 = and i8 %bf.lshr17, 1
  %bf.cast19 = zext i8 %bf.clear18 to i32
  %coerce.dive20 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %8 = load i32, i32* %coerce.dive20, align 4
  call void @usb_resume_interface(%struct.usb_device* %udev, %struct.usb_interface* %7, i32 %8, i32 %bf.cast19)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end22:                                         ; preds = %for.cond, %land.lhs.true, %if.end7
  call void @usb_mark_last_busy.308(%struct.usb_device* %udev)
  br label %done

done:                                             ; preds = %if.end22, %entry
  %status.1 = phi i32 [ %status.0, %if.end22 ], [ -19, %entry ]
  %tobool23 = icmp ne i32 %status.1, 0
  br i1 %tobool23, label %if.end28, label %if.then24

if.then24:                                        ; preds = %done
  %reset_resume25 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load26 = load i8, i8* %reset_resume25, align 8
  %bf.clear27 = and i8 %bf.load26, -3
  store i8 %bf.clear27, i8* %reset_resume25, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.then24, %done
  ret i32 %status.1
}

; Function Attrs: nounwind uwtable
define internal void @unbind_no_reset_resume_drivers_interfaces(%struct.usb_device* %udev) #0 {
entry:
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %1 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %if.end5

for.body:                                         ; preds = %for.cond
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %0, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %2 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !48
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %2, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %3 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !104
  %tobool2 = icmp ne %struct.device_driver* %3, null
  br i1 %tobool2, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %needs_binding = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %2, i32 0, i32 6
  %bf.load = load i8, i8* %needs_binding, align 8
  %bf.lshr = lshr i8 %bf.load, 5
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool3 = icmp ne i32 %bf.cast, 0
  br i1 %tobool3, label %if.then4, label %for.inc

if.then4:                                         ; preds = %land.lhs.true
  call void @usb_forced_unbind_intf(%struct.usb_interface* %2)
  br label %for.inc

for.inc:                                          ; preds = %if.then4, %land.lhs.true, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end5:                                          ; preds = %for.cond, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_resume_device(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 3
  %0 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %done, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %1 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !507
  %cmp1 = icmp eq %struct.device_driver* %1, null
  br i1 %cmp1, label %done, label %if.end3

if.end3:                                          ; preds = %if.end
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %2 = load i32, i32* %event, align 4, !tbaa !42
  %and = and i32 %2, 1024
  %cmp4 = icmp ne i32 %and, 0
  br i1 %cmp4, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end3
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %3 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool = icmp ne %struct.usb_device* %3, null
  br i1 %tobool, label %land.lhs.true5, label %if.end12

land.lhs.true5:                                   ; preds = %land.lhs.true
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %4 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %hs_companion = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %4, i32 0, i32 11
  %5 = load %struct.usb_bus*, %struct.usb_bus** %hs_companion, align 8, !tbaa !510
  %tobool6 = icmp ne %struct.usb_bus* %5, null
  br i1 %tobool6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %land.lhs.true5
  %dev8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %bus9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %6 = load %struct.usb_bus*, %struct.usb_bus** %bus9, align 8, !tbaa !2
  %hs_companion10 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %6, i32 0, i32 11
  %7 = load %struct.usb_bus*, %struct.usb_bus** %hs_companion10, align 8, !tbaa !510
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %7, i32 0, i32 10
  %8 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !228
  %dev11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 11
  %call = call i32 @device_pm_wait_for_dev(%struct.device* %dev8, %struct.device* %dev11)
  br label %if.end12

if.end12:                                         ; preds = %if.then7, %land.lhs.true5, %land.lhs.true, %if.end3
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %9 = load i32, i32* %quirks, align 4, !tbaa !259
  %and13 = and i32 %9, 2
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end12
  %reset_resume = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %bf.load = load i8, i8* %reset_resume, align 8
  %bf.clear = and i8 %bf.load, -3
  %bf.set = or i8 %bf.clear, 2
  store i8 %bf.set, i8* %reset_resume, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %if.end12
  %dev17 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %driver18 = getelementptr inbounds %struct.device, %struct.device* %dev17, i32 0, i32 7
  %10 = load %struct.device_driver*, %struct.device_driver** %driver18, align 8, !tbaa !507
  %11 = bitcast %struct.device_driver* %10 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %11, i64 -40
  %12 = bitcast i8* %add.ptr to %struct.usb_device_driver*
  %resume = getelementptr inbounds %struct.usb_device_driver, %struct.usb_device_driver* %12, i32 0, i32 4
  %13 = load i32 (%struct.usb_device*, i32)*, i32 (%struct.usb_device*, i32)** %resume, align 8, !tbaa !511
  %coerce.dive19 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %14 = load i32, i32* %coerce.dive19, align 4
  %call20 = call i32 %13(%struct.usb_device* %udev, i32 %14)
  br label %done

done:                                             ; preds = %if.end16, %if.end, %entry
  %status.0 = phi i32 [ %call20, %if.end16 ], [ 0, %entry ], [ -107, %if.end ]
  ret i32 %status.0
}

declare i32 @device_pm_wait_for_dev(%struct.device*, %struct.device*) #2

; Function Attrs: nounwind uwtable
define i32 @usb_runtime_suspend(%struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %union.anon.5, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %call = call i32 @autosuspend_check(%struct.usb_device* %1)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  store i32 1026, i32* %event, align 4, !tbaa !42
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  %2 = load i32, i32* %coerce.dive, align 4
  %call1 = call i32 @usb_suspend_both(%struct.usb_device* %1, i32 %2)
  switch i32 %call1, label %cleanup [
    i32 -11, label %if.then4
    i32 -16, label %if.then4
    i32 0, label %if.end8
  ]

if.then4:                                         ; preds = %if.end, %if.end
  call void @usb_mark_last_busy.308(%struct.usb_device* %1)
  %cmp6 = icmp ne i32 %call1, 0
  br i1 %cmp6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.then4, %if.end
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %if.then4, %if.end, %entry
  %retval.0 = phi i32 [ %call1, %if.end8 ], [ -11, %entry ], [ -16, %if.end ], [ -16, %if.then4 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @autosuspend_check(%struct.usb_device* %udev) #0 {
entry:
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool, label %if.then, label %if.end29

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.inc ]
  %w.0 = phi i32 [ 0, %if.then ], [ %w.1, %for.inc ]
  %retval.0 = phi i32 [ undef, %if.then ], [ %retval.3, %for.inc ]
  %actconfig1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %1 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig1, align 8, !tbaa !64
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %1, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %2 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv = zext i8 %2 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %if.end29

for.body:                                         ; preds = %for.cond
  %actconfig3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %3 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig3, align 8, !tbaa !64
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %3, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %4 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !48
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 7
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %disable_depth = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 13
  %bf.load = load i16, i16* %disable_depth, align 8
  %bf.clear = and i16 %bf.load, 7
  %bf.cast = zext i16 %bf.clear to i32
  %tobool4 = icmp ne i32 %bf.cast, 0
  br i1 %tobool4, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %dev6 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 7
  %power7 = getelementptr inbounds %struct.device, %struct.device* %dev6, i32 0, i32 9
  %usage_count = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power7, i32 0, i32 11
  %call = call i32 @atomic_read.315(%union.anon.5* %usage_count)
  %cmp8 = icmp sgt i32 %call, 0
  br i1 %cmp8, label %cleanup52, label %if.end11

if.end11:                                         ; preds = %if.end
  %needs_remote_wakeup = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load12 = load i8, i8* %needs_remote_wakeup, align 8
  %bf.lshr = lshr i8 %bf.load12, 3
  %bf.clear13 = and i8 %bf.lshr, 1
  %bf.cast14 = zext i8 %bf.clear13 to i32
  %or = or i32 %w.0, %bf.cast14
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %5 = load i32, i32* %quirks, align 4, !tbaa !259
  %and = and i32 %5, 2
  %tobool15 = icmp ne i32 %and, 0
  br i1 %tobool15, label %if.then16, label %for.inc

if.then16:                                        ; preds = %if.end11
  %dev17 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 7
  %driver18 = getelementptr inbounds %struct.device, %struct.device* %dev17, i32 0, i32 7
  %6 = load %struct.device_driver*, %struct.device_driver** %driver18, align 8, !tbaa !104
  %7 = bitcast %struct.device_driver* %6 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 -168
  %8 = bitcast i8* %add.ptr to %struct.usb_driver*
  %reset_resume = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %8, i32 0, i32 6
  %9 = load i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)** %reset_resume, align 8, !tbaa !509
  %tobool19 = icmp ne i32 (%struct.usb_interface*)* %9, null
  br i1 %tobool19, label %lor.lhs.false, label %LeafBlock

lor.lhs.false:                                    ; preds = %if.then16
  %needs_remote_wakeup20 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 6
  %bf.load21 = load i8, i8* %needs_remote_wakeup20, align 8
  %bf.lshr22 = lshr i8 %bf.load21, 3
  %bf.clear23 = and i8 %bf.lshr22, 1
  %bf.cast24 = zext i8 %bf.clear23 to i32
  %tobool25 = icmp ne i32 %bf.cast24, 0
  %. = select i1 %tobool25, i32 1, i32 0
  %.retval.0 = select i1 %tobool25, i32 -95, i32 %retval.0
  br label %LeafBlock

LeafBlock:                                        ; preds = %lor.lhs.false, %if.then16
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then16 ], [ %., %lor.lhs.false ]
  %retval.1 = phi i32 [ -95, %if.then16 ], [ %.retval.0, %lor.lhs.false ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup52

for.inc:                                          ; preds = %LeafBlock, %if.end11, %for.body
  %w.1 = phi i32 [ %w.0, %for.body ], [ %or, %LeafBlock ], [ %or, %if.end11 ]
  %retval.3 = phi i32 [ %retval.0, %for.body ], [ %retval.0, %if.end11 ], [ %retval.1, %LeafBlock ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end29:                                         ; preds = %for.cond, %entry
  %w.2 = phi i32 [ 0, %entry ], [ %w.0, %for.cond ]
  %tobool30 = icmp ne i32 %w.2, 0
  br i1 %tobool30, label %land.lhs.true, label %if.end49

land.lhs.true:                                    ; preds = %if.end29
  %dev31 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call32 = call zeroext i1 @device_can_wakeup.396(%struct.device* %dev31)
  br i1 %call32, label %if.end49, label %do.body34

do.body34:                                        ; preds = %land.lhs.true
  %bf.load35 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @autosuspend_check.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr36 = lshr i32 %bf.load35, 18
  %bf.clear37 = and i32 %bf.lshr36, 255
  %and38 = and i32 %bf.clear37, 1
  %tobool39 = icmp ne i32 %and38, 0
  %lnot = xor i1 %tobool39, true
  %lnot40 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot40 to i32
  %conv41 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv41, i64 0)
  %tobool42 = icmp ne i64 %expval, 0
  br i1 %tobool42, label %if.then43, label %cleanup52

if.then43:                                        ; preds = %do.body34
  %dev44 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call45 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @autosuspend_check.descriptor to %struct._ddebug*), %struct.device* %dev44, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.29.397, i32 0, i32 0))
  br label %cleanup52

if.end49:                                         ; preds = %land.lhs.true, %if.end29
  %do_remote_wakeup = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 33
  %10 = trunc i32 %w.2 to i8
  %bf.load50 = load i8, i8* %do_remote_wakeup, align 8
  %bf.value = and i8 %10, 1
  %bf.clear51 = and i8 %bf.load50, -2
  %bf.set = or i8 %bf.clear51, %bf.value
  store i8 %bf.set, i8* %do_remote_wakeup, align 8
  br label %cleanup52

cleanup52:                                        ; preds = %if.end49, %if.then43, %do.body34, %LeafBlock, %if.end
  %retval.4 = phi i32 [ 0, %if.end49 ], [ -16, %if.end ], [ -95, %if.then43 ], [ -95, %do.body34 ], [ %retval.1, %LeafBlock ]
  ret i32 %retval.4
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @device_can_wakeup.396(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %can_wakeup = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i8, i8* %can_wakeup, align 4
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define i32 @usb_runtime_resume(%struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %union.anon.5, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  store i32 1040, i32* %event, align 4, !tbaa !42
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %.compoundliteral, i32 0, i32 0
  %2 = load i32, i32* %coerce.dive, align 4
  %call = call i32 @usb_resume_both(%struct.usb_device* %1, i32 %2)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @usb_runtime_idle(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %call = call i32 @autosuspend_check(%struct.usb_device* %1)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @pm_runtime_autosuspend(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_autosuspend(%struct.device* %dev) #1 {
entry:
  %call = call i32 @__pm_runtime_suspend(%struct.device* %dev, i32 8)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_set_usb2_hardware_lpm(%struct.usb_device* %udev, i32 %enable) #0 {
entry:
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 9
  %0 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call = call %struct.usb_hcd* @bus_to_hcd.404(%struct.usb_bus* %0)
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %1 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %set_usb2_hw_lpm = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 38
  %2 = load i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)** %set_usb2_hw_lpm, align 8, !tbaa !512
  %tobool = icmp ne i32 (%struct.usb_hcd*, %struct.usb_device*, i32)* %2, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %driver1 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call, i32 0, i32 8
  %3 = load %struct.hc_driver*, %struct.hc_driver** %driver1, align 8, !tbaa !71
  %set_usb2_hw_lpm2 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %3, i32 0, i32 38
  %4 = load i32 (%struct.usb_hcd*, %struct.usb_device*, i32)*, i32 (%struct.usb_hcd*, %struct.usb_device*, i32)** %set_usb2_hw_lpm2, align 8, !tbaa !512
  %call3 = call i32 %4(%struct.usb_hcd* %call, %struct.usb_device* %udev, i32 %enable)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.then
  %usb2_hw_lpm_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %5 = trunc i32 %enable to i16
  %bf.load = load i16, i16* %usb2_hw_lpm_enabled, align 4
  %bf.value = and i16 %5, 1
  %bf.shl = shl i16 %bf.value, 8
  %bf.clear = and i16 %bf.load, -257
  %bf.set = or i16 %bf.clear, %bf.shl
  store i16 %bf.set, i16* %usb2_hw_lpm_enabled, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.then, %entry
  %ret.0 = phi i32 [ -1, %entry ], [ %call3, %if.then5 ], [ %call3, %if.then ]
  ret i32 %ret.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd* @bus_to_hcd.404(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd*
  ret %struct.usb_hcd* %1
}

; Function Attrs: nounwind uwtable
define void @usb_release_interface_cache(%struct.arch_spinlock* %ref) #0 {
entry:
  %0 = bitcast %struct.arch_spinlock* %ref to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -4
  %1 = bitcast i8* %add.ptr to %struct.usb_interface_cache*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %j.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %num_altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %1, i32 0, i32 0
  %2 = load i32, i32* %num_altsetting, align 8, !tbaa !69
  %cmp = icmp ult i32 %j.0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %1, i32 0, i32 2
  %idxprom = sext i32 %j.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i64 0, i64 %idxprom
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 3
  %3 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !271
  %4 = bitcast %struct.usb_host_endpoint* %3 to i8*
  call void @kfree(i8* %4)
  %string = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 4
  %5 = load i8*, i8** %string, align 8, !tbaa !513
  call void @kfree(i8* %5)
  %inc = add nsw i32 %j.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %6 = bitcast %struct.usb_interface_cache* %1 to i8*
  call void @kfree(i8* %6)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_destroy_configuration(%struct.usb_device* %dev) #0 {
entry:
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !167
  %tobool = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %rawdescriptors = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 18
  %1 = load i8**, i8*** %rawdescriptors, align 8, !tbaa !169
  %tobool1 = icmp ne i8** %1, null
  br i1 %tobool1, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then2
  %i.0 = phi i32 [ 0, %if.then2 ], [ %inc, %for.body ]
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 13
  %2 = load i8, i8* %bNumConfigurations, align 1, !tbaa !166
  %conv = zext i8 %2 to i32
  %cmp = icmp slt i32 %i.0, %conv
  %rawdescriptors4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 18
  %3 = load i8**, i8*** %rawdescriptors4, align 8, !tbaa !169
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %3, i64 %idxprom
  %4 = load i8*, i8** %arrayidx, align 8, !tbaa !48
  call void @kfree(i8* %4)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %5 = bitcast i8** %3 to i8*
  call void @kfree(i8* %5)
  %rawdescriptors6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 18
  store i8** null, i8*** %rawdescriptors6, align 8, !tbaa !169
  br label %if.end7

if.end7:                                          ; preds = %for.end, %if.end
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc34, %if.end7
  %c.0 = phi i32 [ 0, %if.end7 ], [ %inc35, %for.inc34 ]
  %descriptor9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bNumConfigurations10 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor9, i32 0, i32 13
  %6 = load i8, i8* %bNumConfigurations10, align 1, !tbaa !166
  %conv11 = zext i8 %6 to i32
  %cmp12 = icmp slt i32 %c.0, %conv11
  %config15 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  %7 = load %struct.usb_host_config*, %struct.usb_host_config** %config15, align 8, !tbaa !167
  br i1 %cmp12, label %for.body14, label %for.end36

for.body14:                                       ; preds = %for.cond8
  %idxprom16 = sext i32 %c.0 to i64
  %arrayidx17 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %7, i64 %idxprom16
  %string = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx17, i32 0, i32 1
  %8 = load i8*, i8** %string, align 8, !tbaa !444
  call void @kfree(i8* %8)
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc31, %for.body14
  %i.1 = phi i32 [ 0, %for.body14 ], [ %inc32, %for.inc31 ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx17, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %9 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv19 = zext i8 %9 to i32
  %cmp20 = icmp slt i32 %i.1, %conv19
  br i1 %cmp20, label %for.body22, label %for.inc34

for.body22:                                       ; preds = %for.cond18
  %intf_cache = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx17, i32 0, i32 4
  %idxprom23 = sext i32 %i.1 to i64
  %arrayidx24 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache, i64 0, i64 %idxprom23
  %10 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx24, align 8, !tbaa !48
  %tobool25 = icmp ne %struct.usb_interface_cache* %10, null
  br i1 %tobool25, label %if.then26, label %for.inc31

if.then26:                                        ; preds = %for.body22
  %intf_cache27 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx17, i32 0, i32 4
  %idxprom28 = sext i32 %i.1 to i64
  %arrayidx29 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache27, i64 0, i64 %idxprom28
  %11 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx29, align 8, !tbaa !48
  %ref = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %11, i32 0, i32 1
  call void @kref_put.409(%struct.arch_spinlock* %ref, void (%struct.arch_spinlock*)* @usb_release_interface_cache)
  br label %for.inc31

for.inc31:                                        ; preds = %if.then26, %for.body22
  %inc32 = add nsw i32 %i.1, 1
  br label %for.cond18

for.inc34:                                        ; preds = %for.cond18
  %inc35 = add nsw i32 %c.0, 1
  br label %for.cond8

for.end36:                                        ; preds = %for.cond8
  %12 = bitcast %struct.usb_host_config* %7 to i8*
  call void @kfree(i8* %12)
  %config38 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  store %struct.usb_host_config* null, %struct.usb_host_config** %config38, align 8, !tbaa !167
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end36, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put.409(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* %release) #1 {
entry:
  call void @kref_sub.410(%struct.arch_spinlock* %kref, i32 1, void (%struct.arch_spinlock*)* %release)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_sub.410(%struct.arch_spinlock* %kref, i32 %count, void (%struct.arch_spinlock*)* %release) #1 {
entry:
  %cmp = icmp eq void (%struct.arch_spinlock*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.10.486, i32 0, i32 0), i32 71)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_sub_and_test.412(i32 %count, %union.anon.5* %refcount)
  %tobool14 = icmp ne i32 %call, 0
  br i1 %tobool14, label %if.then15, label %return

if.then15:                                        ; preds = %if.end
  call void %release(%struct.arch_spinlock* %kref)
  br label %return

return:                                           ; preds = %if.then15, %if.end
  %retval.0 = phi i32 [ 1, %if.then15 ], [ 0, %if.end ]
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_sub_and_test.412(i32 %i, %union.anon.5* %v) #1 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subl $2,$0; sete $1", "=*m,=*qm,ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32 %i, i32* %counter) #8, !srcloc !514
  %0 = load i8, i8* %c, align 1, !tbaa !84
  %conv = zext i8 %0 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @usb_get_configuration(%struct.usb_device* %dev) #0 {
entry:
  %_max1 = alloca i32, align 4
  %_max2 = alloca i32, align 4
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 13
  %0 = load i8, i8* %bNumConfigurations, align 1, !tbaa !166
  %conv = zext i8 %0 to i32
  %authorized = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 22
  %bf.load = load i16, i16* %authorized, align 4
  %bf.lshr = lshr i16 %bf.load, 3
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 0
  br i1 %cmp, label %out_not_authorized, label %if.end

if.end:                                           ; preds = %entry
  %cmp3 = icmp sgt i32 %conv, 8
  br i1 %cmp3, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end
  %1 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %descriptor6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bNumConfigurations7 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor6, i32 0, i32 13
  store i8 8, i8* %bNumConfigurations7, align 1, !tbaa !166
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %if.end
  %ncfg.0 = phi i32 [ 8, %if.then5 ], [ %conv, %if.end ]
  %cmp9 = icmp slt i32 %ncfg.0, 1
  br i1 %cmp9, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end8
  %2 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end13:                                         ; preds = %if.end8
  %conv14 = sext i32 %ncfg.0 to i64
  %mul = mul i64 %conv14, 680
  %conv15 = trunc i64 %mul to i32
  %conv16 = zext i32 %conv15 to i64
  %call17 = call i8* @kzalloc.417(i64 %conv16, i32 208)
  %3 = bitcast i8* %call17 to %struct.usb_host_config*
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  store %struct.usb_host_config* %3, %struct.usb_host_config** %config, align 8, !tbaa !167
  %config18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  %4 = load %struct.usb_host_config*, %struct.usb_host_config** %config18, align 8, !tbaa !167
  %tobool = icmp ne %struct.usb_host_config* %4, null
  br i1 %tobool, label %if.end20, label %err2

if.end20:                                         ; preds = %if.end13
  %conv21 = sext i32 %ncfg.0 to i64
  %mul22 = mul i64 %conv21, 8
  %conv23 = trunc i64 %mul22 to i32
  %conv24 = zext i32 %conv23 to i64
  %call25 = call i8* @kzalloc.417(i64 %conv24, i32 208)
  %5 = bitcast i8* %call25 to i8**
  %rawdescriptors = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 18
  store i8** %5, i8*** %rawdescriptors, align 8, !tbaa !169
  %rawdescriptors26 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 18
  %6 = load i8**, i8*** %rawdescriptors26, align 8, !tbaa !169
  %tobool27 = icmp ne i8** %6, null
  br i1 %tobool27, label %if.end29, label %err2

if.end29:                                         ; preds = %if.end20
  %call.i1 = call i8* @__kmalloc(i64 9, i32 208) #8
  %7 = bitcast i8* %call.i1 to %struct.usb_config_descriptor*
  %tobool31 = icmp ne %struct.usb_config_descriptor* %7, null
  br i1 %tobool31, label %if.end33, label %err2

if.end33:                                         ; preds = %if.end29
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end33
  %cfgno.0 = phi i32 [ 0, %if.end33 ], [ %inc, %for.inc ]
  %cmp34 = icmp ult i32 %cfgno.0, %ncfg.0
  br i1 %cmp34, label %for.body, label %err

for.body:                                         ; preds = %for.cond
  %conv36 = trunc i32 %cfgno.0 to i8
  %8 = bitcast %struct.usb_config_descriptor* %7 to i8*
  %call37 = call i32 @usb_get_descriptor(%struct.usb_device* %dev, i8 zeroext 2, i8 zeroext %conv36, i8* %8, i32 9)
  %cmp38 = icmp slt i32 %call37, 0
  br i1 %cmp38, label %if.then40, label %if.else

if.then40:                                        ; preds = %for.body
  %9 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %cmp42 = icmp ne i32 %call37, -32
  br i1 %cmp42, label %err, label %if.end45

if.end45:                                         ; preds = %if.then40
  %10 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %conv47 = trunc i32 %cfgno.0 to i8
  %descriptor48 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bNumConfigurations49 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor48, i32 0, i32 13
  store i8 %conv47, i8* %bNumConfigurations49, align 1, !tbaa !166
  br label %err

if.else:                                          ; preds = %for.body
  %cmp50 = icmp slt i32 %call37, 4
  br i1 %cmp50, label %if.then52, label %if.end55

if.then52:                                        ; preds = %if.else
  %11 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %err

if.end55:                                         ; preds = %if.else
  %12 = bitcast i32* %_max1 to i8*
  %wTotalLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %7, i32 0, i32 2
  %13 = load i16, i16* %wTotalLength, align 1, !tbaa !515
  %conv56 = zext i16 %13 to i32
  store i32 %conv56, i32* %_max1, align 4, !tbaa !90
  %14 = bitcast i32* %_max2 to i8*
  store i32 9, i32* %_max2, align 4, !tbaa !90
  %15 = load i32, i32* %_max1, align 4, !tbaa !90
  %16 = load i32, i32* %_max2, align 4, !tbaa !90
  %cmp59 = icmp sgt i32 %15, %16
  %17 = load i32, i32* %_max1, align 4
  %18 = load i32, i32* %_max2, align 4
  %cond = select i1 %cmp59, i32 %17, i32 %18
  %19 = bitcast i32* %_max2 to i8*
  %20 = bitcast i32* %_max1 to i8*
  %conv61 = zext i32 %cond to i64
  %call.i = call i8* @__kmalloc(i64 %conv61, i32 208) #8
  %tobool63 = icmp ne i8* %call.i, null
  br i1 %tobool63, label %if.end65, label %err

if.end65:                                         ; preds = %if.end55
  %conv66 = trunc i32 %cfgno.0 to i8
  %call67 = call i32 @usb_get_descriptor(%struct.usb_device* %dev, i8 zeroext 2, i8 zeroext %conv66, i8* %call.i, i32 %cond)
  %cmp68 = icmp slt i32 %call67, 0
  br i1 %cmp68, label %if.then70, label %if.end72

if.then70:                                        ; preds = %if.end65
  %21 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  call void @kfree(i8* %call.i)
  br label %err

if.end72:                                         ; preds = %if.end65
  %cmp73 = icmp ult i32 %call67, %cond
  br i1 %cmp73, label %if.then75, label %if.end77

if.then75:                                        ; preds = %if.end72
  %22 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end77

if.end77:                                         ; preds = %if.then75, %if.end72
  %length.0 = phi i32 [ %call67, %if.then75 ], [ %cond, %if.end72 ]
  %rawdescriptors78 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 18
  %23 = load i8**, i8*** %rawdescriptors78, align 8, !tbaa !169
  %idxprom = zext i32 %cfgno.0 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %23, i64 %idxprom
  store i8* %call.i, i8** %arrayidx, align 8, !tbaa !48
  %config79 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  %24 = load %struct.usb_host_config*, %struct.usb_host_config** %config79, align 8, !tbaa !167
  %idxprom80 = zext i32 %cfgno.0 to i64
  %arrayidx81 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %24, i64 %idxprom80
  %call82 = call i32 @usb_parse_configuration(%struct.usb_device* %dev, %struct.usb_host_config* %arrayidx81, i8* %call.i, i32 %length.0)
  %cmp83 = icmp slt i32 %call82, 0
  %inc = add i32 %cfgno.0, 1
  br i1 %cmp83, label %err, label %for.inc

for.inc:                                          ; preds = %if.end77
  br label %for.cond

err:                                              ; preds = %if.end77, %if.then70, %if.end55, %if.then52, %if.end45, %if.then40, %for.cond
  %cfgno.1 = phi i32 [ %cfgno.0, %if.then52 ], [ %cfgno.0, %if.then70 ], [ %cfgno.0, %if.then40 ], [ %cfgno.0, %if.end55 ], [ %cfgno.0, %for.cond ], [ %cfgno.0, %if.end45 ], [ %inc, %if.end77 ]
  %result.0 = phi i32 [ -22, %if.then52 ], [ %call67, %if.then70 ], [ %call37, %if.then40 ], [ -12, %if.end55 ], [ 0, %for.cond ], [ 0, %if.end45 ], [ %call82, %if.end77 ]
  %25 = bitcast %struct.usb_config_descriptor* %7 to i8*
  call void @kfree(i8* %25)
  br label %out_not_authorized

out_not_authorized:                               ; preds = %err, %entry
  %cfgno.2 = phi i32 [ %cfgno.1, %err ], [ 0, %entry ]
  %result.1 = phi i32 [ %result.0, %err ], [ 0, %entry ]
  %conv88 = trunc i32 %cfgno.2 to i8
  %descriptor89 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bNumConfigurations90 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor89, i32 0, i32 13
  store i8 %conv88, i8* %bNumConfigurations90, align 1, !tbaa !166
  br label %err2

err2:                                             ; preds = %out_not_authorized, %if.end29, %if.end20, %if.end13
  %result.2 = phi i32 [ %result.1, %out_not_authorized ], [ -12, %if.end13 ], [ -12, %if.end20 ], [ -12, %if.end29 ]
  %cmp91 = icmp eq i32 %result.2, -12
  br i1 %cmp91, label %if.then93, label %cleanup

if.then93:                                        ; preds = %err2
  %26 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then93, %err2, %if.then11
  %retval.0 = phi i32 [ -22, %if.then11 ], [ %result.2, %if.then93 ], [ %result.2, %err2 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.417(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_parse_configuration(%struct.usb_device* %dev, %struct.usb_host_config* %config, i8* %buffer, i32 %size) #0 {
entry:
  %n = alloca i32, align 4
  %inums = alloca [32 x i8], align 16
  %nalts = alloca [32 x i8], align 16
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 11
  %0 = bitcast i32* %n to i8*
  %1 = bitcast [32 x i8]* %inums to i8*
  %2 = bitcast [32 x i8]* %nalts to i8*
  %cmp = icmp uge i64 9, 64
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %3 = bitcast %struct.usb_config_descriptor* %desc to i8*
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i8* @__memcpy(i8* %3, i8* %buffer, i64 9)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %buffer, i64 9, i32 1, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %desc4 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bDescriptorType = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc4, i32 0, i32 1
  %4 = load i8, i8* %bDescriptorType, align 1, !tbaa !516
  %conv = zext i8 %4 to i32
  %cmp5 = icmp ne i32 %conv, 2
  br i1 %cmp5, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %desc7 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc7, i32 0, i32 0
  %5 = load i8, i8* %bLength, align 8, !tbaa !517
  %conv8 = zext i8 %5 to i32
  %cmp9 = icmp slt i32 %conv8, 9
  br i1 %cmp9, label %if.then11, label %if.end19

if.then11:                                        ; preds = %lor.lhs.false, %if.end
  %6 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup309

if.end19:                                         ; preds = %lor.lhs.false
  %desc20 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc20, i32 0, i32 4
  %7 = load i8, i8* %bConfigurationValue, align 1, !tbaa !147
  %conv21 = zext i8 %7 to i32
  %desc22 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bLength23 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc22, i32 0, i32 0
  %8 = load i8, i8* %bLength23, align 8, !tbaa !517
  %conv24 = zext i8 %8 to i32
  %idx.ext = sext i32 %conv24 to i64
  %add.ptr = getelementptr inbounds i8, i8* %buffer, i64 %idx.ext
  %desc25 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bLength26 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc25, i32 0, i32 0
  %9 = load i8, i8* %bLength26, align 8, !tbaa !517
  %conv27 = zext i8 %9 to i32
  %sub = sub nsw i32 %size, %conv27
  %desc28 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc28, i32 0, i32 3
  %10 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv29 = zext i8 %10 to i32
  %cmp30 = icmp sgt i32 %conv29, 32
  br i1 %cmp30, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.end19
  %11 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %if.end19
  %nintf.0 = phi i32 [ 32, %if.then32 ], [ %conv29, %if.end19 ]
  store i32 0, i32* %n, align 4, !tbaa !90
  br label %for.cond

for.cond:                                         ; preds = %for.inc151, %if.end34
  %buffer2.0 = phi i8* [ %add.ptr, %if.end34 ], [ %add.ptr155, %for.inc151 ]
  %size2.0 = phi i32 [ %sub, %if.end34 ], [ %sub158, %for.inc151 ]
  %iad_num.0 = phi i32 [ 0, %if.end34 ], [ %iad_num.4, %for.inc151 ]
  %cmp35 = icmp sgt i32 %size2.0, 0
  br i1 %cmp35, label %for.body, label %for.end159

for.body:                                         ; preds = %for.cond
  %conv37 = sext i32 %size2.0 to i64
  %cmp38 = icmp ult i64 %conv37, 2
  br i1 %cmp38, label %if.then40, label %if.end43

if.then40:                                        ; preds = %for.body
  %call41 = call i8* @plural(i32 %size2.0)
  %12 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.end159

if.end43:                                         ; preds = %for.body
  %13 = bitcast i8* %buffer2.0 to %struct.usb_descriptor_header*
  %bLength44 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %13, i32 0, i32 0
  %14 = load i8, i8* %bLength44, align 1, !tbaa !45
  %conv45 = zext i8 %14 to i32
  %cmp46 = icmp sgt i32 %conv45, %size2.0
  br i1 %cmp46, label %if.then53, label %lor.lhs.false48

lor.lhs.false48:                                  ; preds = %if.end43
  %bLength49 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %13, i32 0, i32 0
  %15 = load i8, i8* %bLength49, align 1, !tbaa !45
  %conv50 = zext i8 %15 to i32
  %cmp51 = icmp slt i32 %conv50, 2
  br i1 %cmp51, label %if.then53, label %if.end57

if.then53:                                        ; preds = %lor.lhs.false48, %if.end43
  %16 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.end159

if.end57:                                         ; preds = %lor.lhs.false48
  %bDescriptorType58 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %13, i32 0, i32 1
  %17 = load i8, i8* %bDescriptorType58, align 1, !tbaa !47
  %conv59 = zext i8 %17 to i32
  %cmp60 = icmp eq i32 %conv59, 4
  br i1 %cmp60, label %if.then62, label %if.else119

if.then62:                                        ; preds = %if.end57
  %18 = bitcast %struct.usb_descriptor_header* %13 to %struct.usb_interface_descriptor*
  %bLength63 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %18, i32 0, i32 0
  %19 = load i8, i8* %bLength63, align 1, !tbaa !518
  %conv64 = zext i8 %19 to i32
  %cmp65 = icmp slt i32 %conv64, 9
  br i1 %cmp65, label %if.then67, label %if.end71

if.then67:                                        ; preds = %if.then62
  %20 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.inc151

if.end71:                                         ; preds = %if.then62
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %18, i32 0, i32 2
  %21 = load i8, i8* %bInterfaceNumber, align 1, !tbaa !150
  %conv72 = zext i8 %21 to i32
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 29
  %22 = load i32, i32* %quirks, align 4, !tbaa !259
  %and = and i32 %22, 32
  %tobool = icmp ne i32 %and, 0
  %23 = load i32, i32* %n, align 4
  %cmp73 = icmp sge i32 %23, %conv29
  %or.cond = and i1 %tobool, %cmp73
  br i1 %or.cond, label %if.then75, label %if.end77

if.then75:                                        ; preds = %if.end71
  %24 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.inc151

if.end77:                                         ; preds = %if.end71
  %cmp78 = icmp sge i32 %conv72, %conv29
  br i1 %cmp78, label %if.then80, label %if.end83

if.then80:                                        ; preds = %if.end77
  %25 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end83

if.end83:                                         ; preds = %if.then80, %if.end77
  br label %for.cond84

for.cond84:                                       ; preds = %for.inc, %if.end83
  %i.0 = phi i32 [ 0, %if.end83 ], [ %inc, %for.inc ]
  %26 = load i32, i32* %n, align 4, !tbaa !90
  %cmp85 = icmp slt i32 %i.0, %26
  br i1 %cmp85, label %for.body87, label %for.end

for.body87:                                       ; preds = %for.cond84
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* %inums, i64 0, i64 %idxprom
  %27 = load i8, i8* %arrayidx, align 1, !tbaa !84
  %conv88 = zext i8 %27 to i32
  %cmp89 = icmp eq i32 %conv88, %conv72
  br i1 %cmp89, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body87
  %inc = add nsw i32 %i.0, 1
  br label %for.cond84

for.end:                                          ; preds = %for.body87, %for.cond84
  %28 = load i32, i32* %n, align 4, !tbaa !90
  %cmp93 = icmp slt i32 %i.0, %28
  br i1 %cmp93, label %if.then95, label %if.else106

if.then95:                                        ; preds = %for.end
  %idxprom96 = sext i32 %i.0 to i64
  %arrayidx97 = getelementptr inbounds [32 x i8], [32 x i8]* %nalts, i64 0, i64 %idxprom96
  %29 = load i8, i8* %arrayidx97, align 1, !tbaa !84
  %conv98 = zext i8 %29 to i32
  %cmp99 = icmp slt i32 %conv98, 255
  br i1 %cmp99, label %if.then101, label %for.inc151

if.then101:                                       ; preds = %if.then95
  %idxprom102 = sext i32 %i.0 to i64
  %arrayidx103 = getelementptr inbounds [32 x i8], [32 x i8]* %nalts, i64 0, i64 %idxprom102
  %30 = load i8, i8* %arrayidx103, align 1, !tbaa !84
  %inc104 = add i8 %30, 1
  store i8 %inc104, i8* %arrayidx103, align 1, !tbaa !84
  br label %for.inc151

if.else106:                                       ; preds = %for.end
  %31 = load i32, i32* %n, align 4, !tbaa !90
  %cmp107 = icmp slt i32 %31, 32
  br i1 %cmp107, label %if.then109, label %for.inc151

if.then109:                                       ; preds = %if.else106
  %conv110 = trunc i32 %conv72 to i8
  %32 = load i32, i32* %n, align 4, !tbaa !90
  %idxprom111 = sext i32 %32 to i64
  %arrayidx112 = getelementptr inbounds [32 x i8], [32 x i8]* %inums, i64 0, i64 %idxprom111
  store i8 %conv110, i8* %arrayidx112, align 1, !tbaa !84
  %33 = load i32, i32* %n, align 4, !tbaa !90
  %idxprom113 = sext i32 %33 to i64
  %arrayidx114 = getelementptr inbounds [32 x i8], [32 x i8]* %nalts, i64 0, i64 %idxprom113
  store i8 1, i8* %arrayidx114, align 1, !tbaa !84
  %34 = load i32, i32* %n, align 4, !tbaa !90
  %inc115 = add nsw i32 %34, 1
  store i32 %inc115, i32* %n, align 4, !tbaa !90
  br label %for.inc151

if.else119:                                       ; preds = %if.end57
  %bDescriptorType120 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %13, i32 0, i32 1
  %35 = load i8, i8* %bDescriptorType120, align 1, !tbaa !47
  %conv121 = zext i8 %35 to i32
  %cmp122 = icmp eq i32 %conv121, 11
  br i1 %cmp122, label %if.then124, label %if.else134

if.then124:                                       ; preds = %if.else119
  %cmp125 = icmp eq i32 %iad_num.0, 16
  br i1 %cmp125, label %if.then127, label %if.else129

if.then127:                                       ; preds = %if.then124
  %36 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.inc151

if.else129:                                       ; preds = %if.then124
  %37 = bitcast %struct.usb_descriptor_header* %13 to %struct.usb_interface_assoc_descriptor*
  %intf_assoc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 2
  %idxprom130 = zext i32 %iad_num.0 to i64
  %arrayidx131 = getelementptr inbounds [16 x %struct.usb_interface_assoc_descriptor*], [16 x %struct.usb_interface_assoc_descriptor*]* %intf_assoc, i64 0, i64 %idxprom130
  store %struct.usb_interface_assoc_descriptor* %37, %struct.usb_interface_assoc_descriptor** %arrayidx131, align 8, !tbaa !48
  %inc132 = add i32 %iad_num.0, 1
  br label %for.inc151

if.else134:                                       ; preds = %if.else119
  %bDescriptorType135 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %13, i32 0, i32 1
  %38 = load i8, i8* %bDescriptorType135, align 1, !tbaa !47
  %conv136 = zext i8 %38 to i32
  %cmp137 = icmp eq i32 %conv136, 1
  br i1 %cmp137, label %if.then144, label %lor.lhs.false139

lor.lhs.false139:                                 ; preds = %if.else134
  %bDescriptorType140 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %13, i32 0, i32 1
  %39 = load i8, i8* %bDescriptorType140, align 1, !tbaa !47
  %conv141 = zext i8 %39 to i32
  %cmp142 = icmp eq i32 %conv141, 2
  br i1 %cmp142, label %if.then144, label %for.inc151

if.then144:                                       ; preds = %lor.lhs.false139, %if.else134
  %40 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.inc151

for.inc151:                                       ; preds = %if.then144, %lor.lhs.false139, %if.else129, %if.then127, %if.then109, %if.else106, %if.then101, %if.then95, %if.then75, %if.then67
  %iad_num.4 = phi i32 [ %iad_num.0, %if.then127 ], [ %inc132, %if.else129 ], [ %iad_num.0, %if.then144 ], [ %iad_num.0, %lor.lhs.false139 ], [ %iad_num.0, %if.then67 ], [ %iad_num.0, %if.then75 ], [ %iad_num.0, %if.else106 ], [ %iad_num.0, %if.then109 ], [ %iad_num.0, %if.then95 ], [ %iad_num.0, %if.then101 ]
  %bLength152 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %13, i32 0, i32 0
  %41 = load i8, i8* %bLength152, align 1, !tbaa !45
  %conv153 = zext i8 %41 to i32
  %idx.ext154 = sext i32 %conv153 to i64
  %add.ptr155 = getelementptr inbounds i8, i8* %buffer2.0, i64 %idx.ext154
  %bLength156 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %13, i32 0, i32 0
  %42 = load i8, i8* %bLength156, align 1, !tbaa !45
  %conv157 = zext i8 %42 to i32
  %sub158 = sub nsw i32 %size2.0, %conv157
  br label %for.cond

for.end159:                                       ; preds = %if.then53, %if.then40, %for.cond
  %sub.ptr.lhs.cast = ptrtoint i8* %buffer2.0 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %add.ptr to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv160 = trunc i64 %sub.ptr.sub to i32
  %sub.ptr.lhs.cast161 = ptrtoint i8* %buffer2.0 to i64
  %sub.ptr.rhs.cast162 = ptrtoint i8* %buffer to i64
  %sub.ptr.sub163 = sub i64 %sub.ptr.lhs.cast161, %sub.ptr.rhs.cast162
  %conv164 = trunc i64 %sub.ptr.sub163 to i16
  %desc165 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %wTotalLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc165, i32 0, i32 2
  store i16 %conv164, i16* %wTotalLength, align 2, !tbaa !168
  %43 = load i32, i32* %n, align 4, !tbaa !90
  %cmp166 = icmp ne i32 %43, %nintf.0
  %44 = load i32, i32* %n, align 4, !tbaa !90
  br i1 %cmp166, label %if.then168, label %if.else171

if.then168:                                       ; preds = %for.end159
  %45 = load i32, i32* %n, align 4, !tbaa !90
  %call169 = call i8* @plural(i32 %45)
  %46 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end177

if.else171:                                       ; preds = %for.end159
  %cmp172 = icmp eq i32 %44, 0
  br i1 %cmp172, label %if.then174, label %if.end177

if.then174:                                       ; preds = %if.else171
  %47 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end177

if.end177:                                        ; preds = %if.then174, %if.else171, %if.then168
  %48 = load i32, i32* %n, align 4, !tbaa !90
  %conv178 = trunc i32 %48 to i8
  %desc179 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bNumInterfaces180 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc179, i32 0, i32 3
  store i8 %conv178, i8* %bNumInterfaces180, align 4, !tbaa !65
  br label %for.cond181

for.cond181:                                      ; preds = %for.inc204, %if.end177
  %i.1 = phi i32 [ 0, %if.end177 ], [ %inc205, %for.inc204 ]
  %cmp182 = icmp slt i32 %i.1, %48
  br i1 %cmp182, label %for.body184, label %for.end206

for.body184:                                      ; preds = %for.cond181
  br label %for.cond185

for.cond185:                                      ; preds = %for.inc196, %for.body184
  %j.0 = phi i32 [ 0, %for.body184 ], [ %inc197, %for.inc196 ]
  %cmp186 = icmp slt i32 %j.0, %48
  br i1 %cmp186, label %for.body188, label %for.end198

for.body188:                                      ; preds = %for.cond185
  %idxprom189 = sext i32 %j.0 to i64
  %arrayidx190 = getelementptr inbounds [32 x i8], [32 x i8]* %inums, i64 0, i64 %idxprom189
  %49 = load i8, i8* %arrayidx190, align 1, !tbaa !84
  %conv191 = zext i8 %49 to i32
  %cmp192 = icmp eq i32 %conv191, %i.1
  br i1 %cmp192, label %for.end198, label %for.inc196

for.inc196:                                       ; preds = %for.body188
  %inc197 = add nsw i32 %j.0, 1
  br label %for.cond185

for.end198:                                       ; preds = %for.body188, %for.cond185
  %cmp199 = icmp sge i32 %j.0, %48
  br i1 %cmp199, label %if.then201, label %for.inc204

if.then201:                                       ; preds = %for.end198
  %50 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.inc204

for.inc204:                                       ; preds = %if.then201, %for.end198
  %inc205 = add nsw i32 %i.1, 1
  br label %for.cond181

for.end206:                                       ; preds = %for.cond181
  br label %for.cond207

for.cond207:                                      ; preds = %if.end232, %for.end206
  %i.2 = phi i32 [ 0, %for.end206 ], [ %inc234, %if.end232 ]
  %cmp208 = icmp slt i32 %i.2, %48
  br i1 %cmp208, label %for.body210, label %for.end235

for.body210:                                      ; preds = %for.cond207
  %idxprom211 = sext i32 %i.2 to i64
  %arrayidx212 = getelementptr inbounds [32 x i8], [32 x i8]* %nalts, i64 0, i64 %idxprom211
  %51 = load i8, i8* %arrayidx212, align 1, !tbaa !84
  %conv213 = zext i8 %51 to i32
  %cmp214 = icmp sgt i32 %conv213, 128
  br i1 %cmp214, label %if.then216, label %if.end223

if.then216:                                       ; preds = %for.body210
  %52 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %idxprom221 = sext i32 %i.2 to i64
  %arrayidx222 = getelementptr inbounds [32 x i8], [32 x i8]* %nalts, i64 0, i64 %idxprom221
  store i8 -128, i8* %arrayidx222, align 1, !tbaa !84
  br label %if.end223

if.end223:                                        ; preds = %if.then216, %for.body210
  %j.1 = phi i32 [ 128, %if.then216 ], [ %conv213, %for.body210 ]
  %conv224 = sext i32 %j.1 to i64
  %mul = mul i64 40, %conv224
  %add = add i64 8, %mul
  %conv225 = trunc i64 %add to i32
  %conv226 = sext i32 %conv225 to i64
  %call227 = call i8* @kzalloc.417(i64 %conv226, i32 208)
  %53 = bitcast i8* %call227 to %struct.usb_interface_cache*
  %intf_cache = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 4
  %idxprom228 = sext i32 %i.2 to i64
  %arrayidx229 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache, i64 0, i64 %idxprom228
  store %struct.usb_interface_cache* %53, %struct.usb_interface_cache** %arrayidx229, align 8, !tbaa !48
  %tobool230 = icmp ne %struct.usb_interface_cache* %53, null
  br i1 %tobool230, label %if.end232, label %cleanup309

if.end232:                                        ; preds = %if.end223
  %ref = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %53, i32 0, i32 1
  call void @kref_init.439(%struct.arch_spinlock* %ref)
  %inc234 = add nsw i32 %i.2, 1
  br label %for.cond207

for.end235:                                       ; preds = %for.cond207
  %extra = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 5
  store i8* %add.ptr, i8** %extra, align 8, !tbaa !519
  %call236 = call i32 @find_next_descriptor(i8* %add.ptr, i32 %conv160, i32 4, i32 4, i32* %n)
  %extralen = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 6
  store i32 %call236, i32* %extralen, align 8, !tbaa !520
  %54 = load i32, i32* %n, align 4, !tbaa !90
  %cmp237 = icmp sgt i32 %54, 0
  br i1 %cmp237, label %do.body240, label %if.end252

do.body240:                                       ; preds = %for.end235
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_parse_configuration.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and241 = and i32 %bf.clear, 1
  %tobool242 = icmp ne i32 %and241, 0
  %lnot = xor i1 %tobool242, true
  %lnot243 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot243 to i32
  %conv244 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv244, i64 0)
  %tobool245 = icmp ne i64 %expval, 0
  br i1 %tobool245, label %if.then246, label %if.end252

if.then246:                                       ; preds = %do.body240
  %55 = load i32, i32* %n, align 4, !tbaa !90
  %56 = load i32, i32* %n, align 4, !tbaa !90
  %call247 = call i8* @plural(i32 %56)
  %call248 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_parse_configuration.descriptor to %struct._ddebug*), %struct.device* %dev1, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.29.440, i32 0, i32 0), i32 %55, i8* %call247, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.1.580, i32 0, i32 0))
  br label %if.end252

if.end252:                                        ; preds = %if.then246, %do.body240, %for.end235
  %idx.ext253 = sext i32 %call236 to i64
  %add.ptr254 = getelementptr inbounds i8, i8* %add.ptr, i64 %idx.ext253
  %sub255 = sub nsw i32 %conv160, %call236
  br label %while.cond

while.cond:                                       ; preds = %if.end263, %if.end252
  %size.addr.0 = phi i32 [ %sub255, %if.end252 ], [ %sub266, %if.end263 ]
  %buffer.addr.0 = phi i8* [ %add.ptr254, %if.end252 ], [ %add.ptr265, %if.end263 ]
  %cmp256 = icmp sgt i32 %size.addr.0, 0
  br i1 %cmp256, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %inums, i32 0, i32 0
  %arraydecay258 = getelementptr inbounds [32 x i8], [32 x i8]* %nalts, i32 0, i32 0
  %call259 = call i32 @usb_parse_interface(%struct.device* %dev1, %struct.usb_host_config* %config, i8* %buffer.addr.0, i32 %size.addr.0, i8* %arraydecay, i8* %arraydecay258)
  %cmp260 = icmp slt i32 %call259, 0
  br i1 %cmp260, label %cleanup309, label %if.end263

if.end263:                                        ; preds = %while.body
  %idx.ext264 = sext i32 %call259 to i64
  %add.ptr265 = getelementptr inbounds i8, i8* %buffer.addr.0, i64 %idx.ext264
  %sub266 = sub nsw i32 %size.addr.0, %call259
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %for.cond267

for.cond267:                                      ; preds = %for.inc306, %while.end
  %i.3 = phi i32 [ 0, %while.end ], [ %inc307, %for.inc306 ]
  %cmp268 = icmp slt i32 %i.3, %48
  br i1 %cmp268, label %for.body270, label %cleanup309

for.body270:                                      ; preds = %for.cond267
  %intf_cache271 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 4
  %idxprom272 = sext i32 %i.3 to i64
  %arrayidx273 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache271, i64 0, i64 %idxprom272
  %57 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx273, align 8, !tbaa !48
  br label %for.cond274

for.cond274:                                      ; preds = %for.inc303, %for.body270
  %j.2 = phi i32 [ 0, %for.body270 ], [ %inc304, %for.inc303 ]
  %num_altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %57, i32 0, i32 0
  %58 = load i32, i32* %num_altsetting, align 8, !tbaa !69
  %cmp275 = icmp ult i32 %j.2, %58
  br i1 %cmp275, label %for.body277, label %for.inc306

for.body277:                                      ; preds = %for.cond274
  store i32 0, i32* %n, align 4, !tbaa !90
  br label %for.cond278

for.cond278:                                      ; preds = %for.inc291, %for.body277
  %59 = load i32, i32* %n, align 4, !tbaa !90
  %num_altsetting279 = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %57, i32 0, i32 0
  %60 = load i32, i32* %num_altsetting279, align 8, !tbaa !69
  %cmp280 = icmp ult i32 %59, %60
  br i1 %cmp280, label %for.body282, label %for.end293

for.body282:                                      ; preds = %for.cond278
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %57, i32 0, i32 2
  %61 = load i32, i32* %n, align 4, !tbaa !90
  %idxprom283 = sext i32 %61 to i64
  %arrayidx284 = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i64 0, i64 %idxprom283
  %desc285 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx284, i32 0, i32 0
  %bAlternateSetting = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc285, i32 0, i32 3
  %62 = load i8, i8* %bAlternateSetting, align 1, !tbaa !61
  %conv286 = zext i8 %62 to i32
  %cmp287 = icmp eq i32 %conv286, %j.2
  br i1 %cmp287, label %for.end293, label %for.inc291

for.inc291:                                       ; preds = %for.body282
  %63 = load i32, i32* %n, align 4, !tbaa !90
  %inc292 = add nsw i32 %63, 1
  store i32 %inc292, i32* %n, align 4, !tbaa !90
  br label %for.cond278

for.end293:                                       ; preds = %for.body282, %for.cond278
  %64 = load i32, i32* %n, align 4, !tbaa !90
  %num_altsetting294 = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %57, i32 0, i32 0
  %65 = load i32, i32* %num_altsetting294, align 8, !tbaa !69
  %cmp295 = icmp uge i32 %64, %65
  br i1 %cmp295, label %if.then297, label %for.inc303

if.then297:                                       ; preds = %for.end293
  %66 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.inc303

for.inc303:                                       ; preds = %if.then297, %for.end293
  %inc304 = add nsw i32 %j.2, 1
  br label %for.cond274

for.inc306:                                       ; preds = %for.cond274
  %inc307 = add nsw i32 %i.3, 1
  br label %for.cond267

cleanup309:                                       ; preds = %for.cond267, %while.body, %if.end223, %if.then11
  %retval.0 = phi i32 [ -22, %if.then11 ], [ -12, %if.end223 ], [ %call259, %while.body ], [ 0, %for.cond267 ]
  %67 = bitcast [32 x i8]* %nalts to i8*
  %68 = bitcast [32 x i8]* %inums to i8*
  %69 = bitcast i32* %n to i8*
  ret i32 %retval.0
}

declare i8* @__memcpy(i8*, i8*, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @plural(i32 %n) #1 {
entry:
  %cmp = icmp eq i32 %n, 1
  %cond = select i1 %cmp, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.27.821, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8.787, i32 0, i32 0)
  ret i8* %cond
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_init.439(%struct.arch_spinlock* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  call void @atomic_set.472(%union.anon.5* %refcount, i32 1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @find_next_descriptor(i8* %buffer, i32 %size, i32 %dt1, i32 %dt2, i32* %num_skipped) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %n.0 = phi i32 [ 0, %entry ], [ %inc, %if.end ]
  %size.addr.0 = phi i32 [ %size, %entry ], [ %sub, %if.end ]
  %buffer.addr.0 = phi i8* [ %buffer, %entry ], [ %add.ptr, %if.end ]
  %cmp = icmp sgt i32 %size.addr.0, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %0 = bitcast i8* %buffer.addr.0 to %struct.usb_descriptor_header*
  %bDescriptorType = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %0, i32 0, i32 1
  %1 = load i8, i8* %bDescriptorType, align 1, !tbaa !47
  %conv = zext i8 %1 to i32
  %cmp1 = icmp eq i32 %conv, %dt1
  br i1 %cmp1, label %while.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %bDescriptorType3 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %0, i32 0, i32 1
  %2 = load i8, i8* %bDescriptorType3, align 1, !tbaa !47
  %conv4 = zext i8 %2 to i32
  %cmp5 = icmp eq i32 %conv4, %dt2
  br i1 %cmp5, label %while.end, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %bLength = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %0, i32 0, i32 0
  %3 = load i8, i8* %bLength, align 1, !tbaa !45
  %conv7 = zext i8 %3 to i32
  %idx.ext = sext i32 %conv7 to i64
  %add.ptr = getelementptr inbounds i8, i8* %buffer.addr.0, i64 %idx.ext
  %bLength8 = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %0, i32 0, i32 0
  %4 = load i8, i8* %bLength8, align 1, !tbaa !45
  %conv9 = zext i8 %4 to i32
  %sub = sub nsw i32 %size.addr.0, %conv9
  %inc = add nsw i32 %n.0, 1
  br label %while.cond

while.end:                                        ; preds = %lor.lhs.false, %while.body, %while.cond
  %tobool = icmp ne i32* %num_skipped, null
  br i1 %tobool, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.end
  store i32 %n.0, i32* %num_skipped, align 4, !tbaa !90
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.end
  %sub.ptr.lhs.cast = ptrtoint i8* %buffer.addr.0 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %buffer to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv12 = trunc i64 %sub.ptr.sub to i32
  ret i32 %conv12
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_parse_interface(%struct.device* %ddev, %struct.usb_host_config* %config, i8* %buffer, i32 %size, i8* %inums, i8* %nalts) #0 {
entry:
  %n = alloca i32, align 4
  %0 = bitcast i32* %n to i8*
  %1 = bitcast i8* %buffer to %struct.usb_interface_descriptor*
  %bLength = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %1, i32 0, i32 0
  %2 = load i8, i8* %bLength, align 1, !tbaa !518
  %conv = zext i8 %2 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr inbounds i8, i8* %buffer, i64 %idx.ext
  %bLength2 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %1, i32 0, i32 0
  %3 = load i8, i8* %bLength2, align 1, !tbaa !518
  %conv3 = zext i8 %3 to i32
  %sub = sub nsw i32 %size, %conv3
  %bLength4 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %1, i32 0, i32 0
  %4 = load i8, i8* %bLength4, align 1, !tbaa !518
  %conv5 = zext i8 %4 to i32
  %cmp = icmp slt i32 %conv5, 9
  br i1 %cmp, label %skip_to_next_interface_descriptor, label %if.end

if.end:                                           ; preds = %entry
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %1, i32 0, i32 2
  %5 = load i8, i8* %bInterfaceNumber, align 1, !tbaa !150
  %conv7 = zext i8 %5 to i32
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %6 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv8 = zext i8 %6 to i32
  %cmp9 = icmp slt i32 %i.0, %conv8
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8, i8* %inums, i64 %idxprom
  %7 = load i8, i8* %arrayidx, align 1, !tbaa !84
  %conv11 = zext i8 %7 to i32
  %cmp12 = icmp eq i32 %conv11, %conv7
  br i1 %cmp12, label %if.then14, label %for.inc

if.then14:                                        ; preds = %for.body
  %intf_cache = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 4
  %idxprom15 = sext i32 %i.0 to i64
  %arrayidx16 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache, i64 0, i64 %idxprom15
  %8 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx16, align 8, !tbaa !48
  br label %for.end

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %if.then14, %for.cond
  %intfc.0 = phi %struct.usb_interface_cache* [ %8, %if.then14 ], [ null, %for.cond ]
  %tobool = icmp ne %struct.usb_interface_cache* %intfc.0, null
  br i1 %tobool, label %lor.lhs.false, label %skip_to_next_interface_descriptor

lor.lhs.false:                                    ; preds = %for.end
  %num_altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intfc.0, i32 0, i32 0
  %9 = load i32, i32* %num_altsetting, align 8, !tbaa !69
  %idxprom18 = sext i32 %i.0 to i64
  %arrayidx19 = getelementptr inbounds i8, i8* %nalts, i64 %idxprom18
  %10 = load i8, i8* %arrayidx19, align 1, !tbaa !84
  %conv20 = zext i8 %10 to i32
  %cmp21 = icmp uge i32 %9, %conv20
  br i1 %cmp21, label %skip_to_next_interface_descriptor, label %if.end24

if.end24:                                         ; preds = %lor.lhs.false
  %bAlternateSetting = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %1, i32 0, i32 3
  %11 = load i8, i8* %bAlternateSetting, align 1, !tbaa !149
  %conv25 = zext i8 %11 to i32
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intfc.0, i32 0, i32 2
  %arrayidx26 = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i64 0, i64 0
  br label %for.cond27

for.cond27:                                       ; preds = %for.inc39, %if.end24
  %alt.0 = phi %struct.usb_host_interface* [ %arrayidx26, %if.end24 ], [ %incdec.ptr, %for.inc39 ]
  %i.1 = phi i32 [ 0, %if.end24 ], [ %inc40, %for.inc39 ]
  %num_altsetting28 = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intfc.0, i32 0, i32 0
  %12 = load i32, i32* %num_altsetting28, align 8, !tbaa !69
  %cmp29 = icmp ult i32 %i.1, %12
  br i1 %cmp29, label %for.body31, label %for.end41

for.body31:                                       ; preds = %for.cond27
  %desc32 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 0
  %bAlternateSetting33 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc32, i32 0, i32 3
  %13 = load i8, i8* %bAlternateSetting33, align 1, !tbaa !61
  %conv34 = zext i8 %13 to i32
  %cmp35 = icmp eq i32 %conv34, %conv25
  br i1 %cmp35, label %if.then37, label %for.inc39

if.then37:                                        ; preds = %for.body31
  %14 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %skip_to_next_interface_descriptor

for.inc39:                                        ; preds = %for.body31
  %inc40 = add nsw i32 %i.1, 1
  %incdec.ptr = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 1
  br label %for.cond27

for.end41:                                        ; preds = %for.cond27
  %num_altsetting42 = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intfc.0, i32 0, i32 0
  %15 = load i32, i32* %num_altsetting42, align 8, !tbaa !69
  %inc43 = add i32 %15, 1
  store i32 %inc43, i32* %num_altsetting42, align 8, !tbaa !69
  %cmp44 = icmp uge i64 9, 64
  %desc47 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 0
  %16 = bitcast %struct.usb_interface_descriptor* %desc47 to i8*
  %17 = bitcast %struct.usb_interface_descriptor* %1 to i8*
  br i1 %cmp44, label %if.then46, label %if.else

if.then46:                                        ; preds = %for.end41
  %call48 = call i8* @__memcpy(i8* %16, i8* %17, i64 9)
  br label %if.end50

if.else:                                          ; preds = %for.end41
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %16, i8* %17, i64 9, i32 1, i1 false)
  br label %if.end50

if.end50:                                         ; preds = %if.else, %if.then46
  %extra = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 2
  store i8* %add.ptr, i8** %extra, align 8, !tbaa !521
  %call51 = call i32 @find_next_descriptor(i8* %add.ptr, i32 %sub, i32 5, i32 4, i32* %n)
  %extralen = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 1
  store i32 %call51, i32* %extralen, align 4, !tbaa !522
  %18 = load i32, i32* %n, align 4, !tbaa !90
  %cmp52 = icmp sgt i32 %18, 0
  br i1 %cmp52, label %do.body55, label %if.end66

do.body55:                                        ; preds = %if.end50
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_parse_interface.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool56 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool56, true
  %lnot57 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot57 to i32
  %conv58 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv58, i64 0)
  %tobool59 = icmp ne i64 %expval, 0
  br i1 %tobool59, label %if.then60, label %if.end66

if.then60:                                        ; preds = %do.body55
  %19 = load i32, i32* %n, align 4, !tbaa !90
  %20 = load i32, i32* %n, align 4, !tbaa !90
  %call61 = call i8* @plural(i32 %20)
  %call62 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_parse_interface.descriptor to %struct._ddebug*), %struct.device* %ddev, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.29.440, i32 0, i32 0), i32 %19, i8* %call61, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.74.616, i32 0, i32 0))
  br label %if.end66

if.end66:                                         ; preds = %if.then60, %do.body55, %if.end50
  %idx.ext67 = sext i32 %call51 to i64
  %add.ptr68 = getelementptr inbounds i8, i8* %add.ptr, i64 %idx.ext67
  %sub69 = sub nsw i32 %sub, %call51
  %desc70 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc70, i32 0, i32 4
  %21 = load i8, i8* %bNumEndpoints, align 4, !tbaa !270
  %conv71 = zext i8 %21 to i32
  %desc72 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 0
  %bNumEndpoints73 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc72, i32 0, i32 4
  store i8 0, i8* %bNumEndpoints73, align 4, !tbaa !270
  %cmp74 = icmp sgt i32 %conv71, 30
  br i1 %cmp74, label %if.then76, label %if.end78

if.then76:                                        ; preds = %if.end66
  %22 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end78

if.end78:                                         ; preds = %if.then76, %if.end66
  %num_ep.0 = phi i32 [ 30, %if.then76 ], [ %conv71, %if.end66 ]
  %cmp79 = icmp sgt i32 %num_ep.0, 0
  br i1 %cmp79, label %if.then81, label %if.end90

if.then81:                                        ; preds = %if.end78
  %conv82 = sext i32 %num_ep.0 to i64
  %mul = mul i64 64, %conv82
  %conv83 = trunc i64 %mul to i32
  %conv84 = sext i32 %conv83 to i64
  %call85 = call i8* @kzalloc.417(i64 %conv84, i32 208)
  %23 = bitcast i8* %call85 to %struct.usb_host_endpoint*
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 3
  store %struct.usb_host_endpoint* %23, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !271
  %endpoint86 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alt.0, i32 0, i32 3
  %24 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint86, align 8, !tbaa !271
  %tobool87 = icmp ne %struct.usb_host_endpoint* %24, null
  br i1 %tobool87, label %if.end90, label %cleanup

if.end90:                                         ; preds = %if.then81, %if.end78
  store i32 0, i32* %n, align 4, !tbaa !90
  br label %while.cond

while.cond:                                       ; preds = %if.end102, %if.end90
  %size.addr.0 = phi i32 [ %sub69, %if.end90 ], [ %sub106, %if.end102 ]
  %buffer.addr.0 = phi i8* [ %add.ptr68, %if.end90 ], [ %add.ptr105, %if.end102 ]
  %cmp91 = icmp sgt i32 %size.addr.0, 0
  br i1 %cmp91, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %25 = bitcast i8* %buffer.addr.0 to %struct.usb_descriptor_header*
  %bDescriptorType = getelementptr inbounds %struct.usb_descriptor_header, %struct.usb_descriptor_header* %25, i32 0, i32 1
  %26 = load i8, i8* %bDescriptorType, align 1, !tbaa !47
  %conv93 = zext i8 %26 to i32
  %cmp94 = icmp eq i32 %conv93, 4
  br i1 %cmp94, label %while.end, label %if.end97

if.end97:                                         ; preds = %while.body
  %call98 = call i32 @usb_parse_endpoint(%struct.device* %ddev, %struct.usb_host_interface* %alt.0, i32 %num_ep.0, i8* %buffer.addr.0, i32 %size.addr.0)
  %cmp99 = icmp slt i32 %call98, 0
  br i1 %cmp99, label %cleanup, label %if.end102

if.end102:                                        ; preds = %if.end97
  %27 = load i32, i32* %n, align 4, !tbaa !90
  %inc103 = add nsw i32 %27, 1
  store i32 %inc103, i32* %n, align 4, !tbaa !90
  %idx.ext104 = sext i32 %call98 to i64
  %add.ptr105 = getelementptr inbounds i8, i8* %buffer.addr.0, i64 %idx.ext104
  %sub106 = sub nsw i32 %size.addr.0, %call98
  br label %while.cond

while.end:                                        ; preds = %while.body, %while.cond
  %28 = load i32, i32* %n, align 4, !tbaa !90
  %cmp107 = icmp ne i32 %28, %conv71
  br i1 %cmp107, label %if.then109, label %if.end112

if.then109:                                       ; preds = %while.end
  %29 = load i32, i32* %n, align 4, !tbaa !90
  %call110 = call i8* @plural(i32 %29)
  %30 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end112

if.end112:                                        ; preds = %if.then109, %while.end
  %sub.ptr.lhs.cast = ptrtoint i8* %buffer.addr.0 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %buffer to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv113 = trunc i64 %sub.ptr.sub to i32
  br label %cleanup

skip_to_next_interface_descriptor:                ; preds = %if.then37, %lor.lhs.false, %for.end, %entry
  %call114 = call i32 @find_next_descriptor(i8* %add.ptr, i32 %sub, i32 4, i32 4, i32* null)
  %sub.ptr.lhs.cast115 = ptrtoint i8* %add.ptr to i64
  %sub.ptr.rhs.cast116 = ptrtoint i8* %buffer to i64
  %sub.ptr.sub117 = sub i64 %sub.ptr.lhs.cast115, %sub.ptr.rhs.cast116
  %conv118 = sext i32 %call114 to i64
  %add = add nsw i64 %sub.ptr.sub117, %conv118
  %conv119 = trunc i64 %add to i32
  br label %cleanup

cleanup:                                          ; preds = %skip_to_next_interface_descriptor, %if.end112, %if.end97, %if.then81
  %retval.0 = phi i32 [ %conv119, %skip_to_next_interface_descriptor ], [ %conv113, %if.end112 ], [ -12, %if.then81 ], [ %call98, %if.end97 ]
  %31 = bitcast i32* %n to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_parse_endpoint(%struct.device* %ddev, %struct.usb_host_interface* %ifp, i32 %num_ep, i8* %buffer, i32 %size) #0 {
entry:
  %n = alloca i32, align 4
  %0 = bitcast i32* %n to i8*
  %1 = bitcast i8* %buffer to %struct.usb_endpoint_descriptor*
  %bLength = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %1, i32 0, i32 0
  %2 = load i8, i8* %bLength, align 1, !tbaa !523
  %conv = zext i8 %2 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr inbounds i8, i8* %buffer, i64 %idx.ext
  %bLength2 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %1, i32 0, i32 0
  %3 = load i8, i8* %bLength2, align 1, !tbaa !523
  %conv3 = zext i8 %3 to i32
  %sub = sub nsw i32 %size, %conv3
  %bLength4 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %1, i32 0, i32 0
  %4 = load i8, i8* %bLength4, align 1, !tbaa !523
  %conv5 = zext i8 %4 to i32
  %cmp = icmp sge i32 %conv5, 9
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 9, i32* %n, align 4, !tbaa !90
  br label %if.end15

if.else:                                          ; preds = %entry
  %bLength7 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %1, i32 0, i32 0
  %5 = load i8, i8* %bLength7, align 1, !tbaa !523
  %conv8 = zext i8 %5 to i32
  %cmp9 = icmp sge i32 %conv8, 7
  br i1 %cmp9, label %if.then11, label %if.else12

if.then11:                                        ; preds = %if.else
  store i32 7, i32* %n, align 4, !tbaa !90
  br label %if.end15

if.else12:                                        ; preds = %if.else
  %6 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %skip_to_next_endpoint_or_interface_descriptor

if.end15:                                         ; preds = %if.then11, %if.then
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %1, i32 0, i32 2
  %7 = load i8, i8* %bEndpointAddress, align 1, !tbaa !286
  %conv16 = zext i8 %7 to i32
  %and = and i32 %conv16, -129
  %cmp17 = icmp sge i32 %and, 16
  %cmp19 = icmp eq i32 %and, 0
  %or.cond = or i1 %cmp17, %cmp19
  br i1 %or.cond, label %if.then21, label %if.end25

if.then21:                                        ; preds = %if.end15
  %8 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %skip_to_next_endpoint_or_interface_descriptor

if.end25:                                         ; preds = %if.end15
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %ifp, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 4
  %9 = load i8, i8* %bNumEndpoints, align 4, !tbaa !270
  %conv26 = zext i8 %9 to i32
  %cmp27 = icmp sge i32 %conv26, %num_ep
  br i1 %cmp27, label %skip_to_next_endpoint_or_interface_descriptor, label %if.end30

if.end30:                                         ; preds = %if.end25
  %endpoint31 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %ifp, i32 0, i32 3
  %10 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint31, align 8, !tbaa !271
  %desc32 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %ifp, i32 0, i32 0
  %bNumEndpoints33 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc32, i32 0, i32 4
  %11 = load i8, i8* %bNumEndpoints33, align 4, !tbaa !270
  %idxprom = zext i8 %11 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i64 %idxprom
  %desc34 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %ifp, i32 0, i32 0
  %bNumEndpoints35 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc34, i32 0, i32 4
  %12 = load i8, i8* %bNumEndpoints35, align 4, !tbaa !270
  %inc = add i8 %12, 1
  store i8 %inc, i8* %bNumEndpoints35, align 4, !tbaa !270
  %13 = load i32, i32* %n, align 4, !tbaa !90
  %conv36 = sext i32 %13 to i64
  %desc37 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 0
  %14 = bitcast %struct.usb_endpoint_descriptor* %desc37 to i8*
  %15 = bitcast %struct.usb_endpoint_descriptor* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %15, i64 %conv36, i32 1, i1 false)
  %urb_list = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 3
  call void @INIT_LIST_HEAD.449(%struct.list_head* %urb_list)
  %call38 = call i32 @usb_endpoint_xfer_int.450(%struct.usb_endpoint_descriptor* %1)
  %tobool = icmp ne i32 %call38, 0
  br i1 %tobool, label %if.then39, label %if.else48

if.then39:                                        ; preds = %if.end30
  %16 = bitcast %struct.device* %ddev to i8*
  %add.ptr41 = getelementptr inbounds i8, i8* %16, i64 -136
  %17 = bitcast i8* %add.ptr41 to %struct.usb_device*
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %17, i32 0, i32 4
  %18 = load i32, i32* %speed, align 4, !tbaa !153
  %Pivot = icmp slt i32 %18, 5
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.then39
  %SwitchLeaf2 = icmp eq i32 %18, 5
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.default

LeafBlock:                                        ; preds = %if.then39
  %SwitchLeaf = icmp eq i32 %18, 3
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock, %LeafBlock1
  %bInterval = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %1, i32 0, i32 5
  %19 = load i8, i8* %bInterval, align 1, !tbaa !287
  %conv42 = zext i8 %19 to i32
  %mul = mul nsw i32 %conv42, 8
  %call43 = call i32 @fls.451(i32 %mul)
  store i32 %call43, i32* %n, align 4, !tbaa !90
  %20 = load i32, i32* %n, align 4, !tbaa !90
  %cmp44 = icmp eq i32 %20, 0
  %.call43 = select i1 %cmp44, i32 9, i32 %call43
  store i32 %.call43, i32* %n, align 4
  br label %if.end60

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  store i32 32, i32* %n, align 4, !tbaa !90
  br label %if.end60

if.else48:                                        ; preds = %if.end30
  %call49 = call i32 @usb_endpoint_xfer_isoc.452(%struct.usb_endpoint_descriptor* %1)
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %if.then51, label %if.end60

if.then51:                                        ; preds = %if.else48
  %21 = bitcast %struct.device* %ddev to i8*
  %add.ptr54 = getelementptr inbounds i8, i8* %21, i64 -136
  %22 = bitcast i8* %add.ptr54 to %struct.usb_device*
  %speed55 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %22, i32 0, i32 4
  %23 = load i32, i32* %speed55, align 4, !tbaa !153
  %SwitchLeaf5 = icmp eq i32 %23, 3
  br i1 %SwitchLeaf5, label %sw.bb56, label %sw.default57

sw.bb56:                                          ; preds = %if.then51
  store i32 9, i32* %n, align 4, !tbaa !90
  br label %if.end60

sw.default57:                                     ; preds = %if.then51
  store i32 6, i32* %n, align 4, !tbaa !90
  br label %if.end60

if.end60:                                         ; preds = %sw.default57, %sw.bb56, %if.else48, %sw.default, %sw.bb
  %i.1 = phi i32 [ 1, %sw.default ], [ 1, %sw.bb ], [ 0, %if.else48 ], [ 1, %sw.default57 ], [ 1, %sw.bb56 ]
  %j.2 = phi i32 [ 16, %sw.bb ], [ 255, %sw.default ], [ 255, %if.else48 ], [ 16, %sw.default57 ], [ 16, %sw.bb56 ]
  %bInterval61 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %1, i32 0, i32 5
  %24 = load i8, i8* %bInterval61, align 1, !tbaa !287
  %conv62 = zext i8 %24 to i32
  %cmp63 = icmp slt i32 %conv62, %i.1
  br i1 %cmp63, label %if.then70, label %lor.lhs.false65

lor.lhs.false65:                                  ; preds = %if.end60
  %bInterval66 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %1, i32 0, i32 5
  %25 = load i8, i8* %bInterval66, align 1, !tbaa !287
  %conv67 = zext i8 %25 to i32
  %cmp68 = icmp sgt i32 %conv67, %j.2
  br i1 %cmp68, label %if.then70, label %if.end79

if.then70:                                        ; preds = %lor.lhs.false65, %if.end60
  %26 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %27 = load i32, i32* %n, align 4, !tbaa !90
  %conv76 = trunc i32 %27 to i8
  %desc77 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 0
  %bInterval78 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc77, i32 0, i32 5
  store i8 %conv76, i8* %bInterval78, align 2, !tbaa !469
  br label %if.end79

if.end79:                                         ; preds = %if.then70, %lor.lhs.false65
  %28 = bitcast %struct.device* %ddev to i8*
  %add.ptr82 = getelementptr inbounds i8, i8* %28, i64 -136
  %29 = bitcast i8* %add.ptr82 to %struct.usb_device*
  %speed83 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %29, i32 0, i32 4
  %30 = load i32, i32* %speed83, align 4, !tbaa !153
  %cmp84 = icmp eq i32 %30, 1
  br i1 %cmp84, label %land.lhs.true, label %if.end102

land.lhs.true:                                    ; preds = %if.end79
  %call86 = call i32 @usb_endpoint_xfer_bulk.454(%struct.usb_endpoint_descriptor* %1)
  %tobool87 = icmp ne i32 %call86, 0
  br i1 %tobool87, label %if.then88, label %if.end102

if.then88:                                        ; preds = %land.lhs.true
  %31 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %desc92 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 0
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc92, i32 0, i32 3
  store i8 3, i8* %bmAttributes, align 1, !tbaa !468
  %desc93 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 0
  %bInterval94 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc93, i32 0, i32 5
  store i8 1, i8* %bInterval94, align 2, !tbaa !469
  %desc95 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 0
  %call96 = call i32 @usb_endpoint_maxp.455(%struct.usb_endpoint_descriptor* %desc95)
  %cmp97 = icmp sgt i32 %call96, 8
  br i1 %cmp97, label %if.then99, label %if.end102

if.then99:                                        ; preds = %if.then88
  %desc100 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 0
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc100, i32 0, i32 4
  store i16 8, i16* %wMaxPacketSize, align 4, !tbaa !524
  br label %if.end102

if.end102:                                        ; preds = %if.then99, %if.then88, %land.lhs.true, %if.end79
  %32 = bitcast %struct.device* %ddev to i8*
  %add.ptr105 = getelementptr inbounds i8, i8* %32, i64 -136
  %33 = bitcast i8* %add.ptr105 to %struct.usb_device*
  %speed106 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %33, i32 0, i32 4
  %34 = load i32, i32* %speed106, align 4, !tbaa !153
  %cmp107 = icmp eq i32 %34, 3
  br i1 %cmp107, label %land.lhs.true109, label %if.end123

land.lhs.true109:                                 ; preds = %if.end102
  %call110 = call i32 @usb_endpoint_xfer_bulk.454(%struct.usb_endpoint_descriptor* %1)
  %tobool111 = icmp ne i32 %call110, 0
  br i1 %tobool111, label %if.then112, label %if.end123

if.then112:                                       ; preds = %land.lhs.true109
  %desc113 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 0
  %call114 = call i32 @usb_endpoint_maxp.455(%struct.usb_endpoint_descriptor* %desc113)
  %and115 = and i32 %call114, 2047
  %cmp116 = icmp ne i32 %and115, 512
  br i1 %cmp116, label %if.then118, label %if.end123

if.then118:                                       ; preds = %if.then112
  %35 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end123

if.end123:                                        ; preds = %if.then118, %if.then112, %land.lhs.true109, %if.end102
  %36 = bitcast %struct.device* %ddev to i8*
  %add.ptr126 = getelementptr inbounds i8, i8* %36, i64 -136
  %37 = bitcast i8* %add.ptr126 to %struct.usb_device*
  %speed127 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %37, i32 0, i32 4
  %38 = load i32, i32* %speed127, align 4, !tbaa !153
  %cmp128 = icmp eq i32 %38, 5
  br i1 %cmp128, label %if.then130, label %if.end131

if.then130:                                       ; preds = %if.end123
  call void @usb_parse_ss_endpoint_companion(%struct.usb_host_endpoint* %arrayidx, i8* %add.ptr, i32 %sub)
  br label %if.end131

if.end131:                                        ; preds = %if.then130, %if.end123
  %extra = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 6
  store i8* %add.ptr, i8** %extra, align 8, !tbaa !525
  %call132 = call i32 @find_next_descriptor(i8* %add.ptr, i32 %sub, i32 5, i32 4, i32* %n)
  %extralen = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 7
  store i32 %call132, i32* %extralen, align 8, !tbaa !526
  %sub.ptr.lhs.cast = ptrtoint i8* %add.ptr to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %buffer to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv133 = sext i32 %call132 to i64
  %add = add nsw i64 %sub.ptr.sub, %conv133
  %conv134 = trunc i64 %add to i32
  %39 = load i32, i32* %n, align 4, !tbaa !90
  %cmp135 = icmp sgt i32 %39, 0
  br i1 %cmp135, label %do.body138, label %cleanup

do.body138:                                       ; preds = %if.end131
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_parse_endpoint.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and139 = and i32 %bf.clear, 1
  %tobool140 = icmp ne i32 %and139, 0
  %lnot = xor i1 %tobool140, true
  %lnot141 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot141 to i32
  %conv142 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv142, i64 0)
  %tobool143 = icmp ne i64 %expval, 0
  br i1 %tobool143, label %if.then144, label %cleanup

if.then144:                                       ; preds = %do.body138
  %40 = load i32, i32* %n, align 4, !tbaa !90
  %41 = load i32, i32* %n, align 4, !tbaa !90
  %call145 = call i8* @plural(i32 %41)
  %call146 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_parse_endpoint.descriptor to %struct._ddebug*), %struct.device* %ddev, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.29.440, i32 0, i32 0), i32 %40, i8* %call145, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43.457, i32 0, i32 0))
  br label %cleanup

skip_to_next_endpoint_or_interface_descriptor:    ; preds = %if.end25, %if.then21, %if.else12
  %call151 = call i32 @find_next_descriptor(i8* %add.ptr, i32 %sub, i32 5, i32 4, i32* null)
  %sub.ptr.lhs.cast152 = ptrtoint i8* %add.ptr to i64
  %sub.ptr.rhs.cast153 = ptrtoint i8* %buffer to i64
  %sub.ptr.sub154 = sub i64 %sub.ptr.lhs.cast152, %sub.ptr.rhs.cast153
  %conv155 = sext i32 %call151 to i64
  %add156 = add nsw i64 %sub.ptr.sub154, %conv155
  %conv157 = trunc i64 %add156 to i32
  br label %cleanup

cleanup:                                          ; preds = %skip_to_next_endpoint_or_interface_descriptor, %if.then144, %do.body138, %if.end131
  %retval.0 = phi i32 [ %conv157, %skip_to_next_endpoint_or_interface_descriptor ], [ %conv134, %do.body138 ], [ %conv134, %if.then144 ], [ %conv134, %if.end131 ]
  %42 = bitcast i32* %n to i8*
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.449(%struct.list_head* %list) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !95
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !96
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_int.450(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 3
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @fls.451(i32 %x) #1 {
entry:
  %0 = call i32 asm "bsrl $1,$0", "=r,rm,0,~{dirflag},~{fpsr},~{flags}"(i32 %x, i32 -1) #9, !srcloc !527
  %add = add nsw i32 %0, 1
  ret i32 %add
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_isoc.452(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 1
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_bulk.454(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 2
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_maxp.455(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 4
  %0 = load i16, i16* %wMaxPacketSize, align 1, !tbaa !199
  %conv = zext i16 %0 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal void @usb_parse_ss_endpoint_companion(%struct.usb_host_endpoint* %ep, i8* %buffer, i32 %size) #0 {
entry:
  %0 = bitcast i8* %buffer to %struct.usb_ss_ep_comp_descriptor*
  %bDescriptorType = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 1
  %1 = load i8, i8* %bDescriptorType, align 1, !tbaa !528
  %conv = zext i8 %1 to i32
  %cmp = icmp ne i32 %conv, 48
  %cmp2 = icmp slt i32 %size, 6
  %or.cond = or i1 %cmp, %cmp2
  br i1 %or.cond, label %if.then, label %if.end17

if.then:                                          ; preds = %entry
  %2 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %ss_ep_comp = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %bLength = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp, i32 0, i32 0
  store i8 6, i8* %bLength, align 1, !tbaa !529
  %ss_ep_comp6 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %bDescriptorType7 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp6, i32 0, i32 1
  store i8 48, i8* %bDescriptorType7, align 1, !tbaa !530
  %desc8 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call9 = call i32 @usb_endpoint_xfer_isoc.452(%struct.usb_endpoint_descriptor* %desc8)
  %tobool = icmp ne i32 %call9, 0
  br i1 %tobool, label %if.then14, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %if.then
  %desc11 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call12 = call i32 @usb_endpoint_xfer_int.450(%struct.usb_endpoint_descriptor* %desc11)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then14, label %cleanup.cont

if.then14:                                        ; preds = %lor.lhs.false10, %if.then
  %desc15 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc15, i32 0, i32 4
  %3 = load i16, i16* %wMaxPacketSize, align 4, !tbaa !524
  %ss_ep_comp16 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %wBytesPerInterval = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp16, i32 0, i32 4
  store i16 %3, i16* %wBytesPerInterval, align 1, !tbaa !531
  br label %cleanup.cont

if.end17:                                         ; preds = %entry
  %cmp18 = icmp uge i64 6, 64
  %ss_ep_comp21 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %4 = bitcast %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp21 to i8*
  %5 = bitcast %struct.usb_ss_ep_comp_descriptor* %0 to i8*
  br i1 %cmp18, label %if.then20, label %if.else

if.then20:                                        ; preds = %if.end17
  %call22 = call i8* @__memcpy(i8* %4, i8* %5, i64 6)
  br label %if.end24

if.else:                                          ; preds = %if.end17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 6, i32 1, i1 false)
  br label %if.end24

if.end24:                                         ; preds = %if.else, %if.then20
  %desc25 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call26 = call i32 @usb_endpoint_xfer_control.461(%struct.usb_endpoint_descriptor* %desc25)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %land.lhs.true, label %if.else40

land.lhs.true:                                    ; preds = %if.end24
  %bMaxBurst = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 2
  %6 = load i8, i8* %bMaxBurst, align 1, !tbaa !532
  %conv28 = zext i8 %6 to i32
  %cmp29 = icmp ne i32 %conv28, 0
  br i1 %cmp29, label %if.then31, label %if.else40

if.then31:                                        ; preds = %land.lhs.true
  %7 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end55.sink.split

if.else40:                                        ; preds = %land.lhs.true, %if.end24
  %bMaxBurst41 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 2
  %8 = load i8, i8* %bMaxBurst41, align 1, !tbaa !532
  %conv42 = zext i8 %8 to i32
  %cmp43 = icmp sgt i32 %conv42, 15
  br i1 %cmp43, label %if.then45, label %if.end55

if.then45:                                        ; preds = %if.else40
  %9 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end55.sink.split

if.end55.sink.split:                              ; preds = %if.then45, %if.then31
  %.sink = phi i8 [ 15, %if.then45 ], [ 0, %if.then31 ]
  %ss_ep_comp52 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %bMaxBurst53 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp52, i32 0, i32 2
  store i8 %.sink, i8* %bMaxBurst53, align 1, !tbaa !425
  br label %if.end55

if.end55:                                         ; preds = %if.end55.sink.split, %if.else40
  %desc56 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call57 = call i32 @usb_endpoint_xfer_control.461(%struct.usb_endpoint_descriptor* %desc56)
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %land.lhs.true63, label %lor.lhs.false59

lor.lhs.false59:                                  ; preds = %if.end55
  %desc60 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call61 = call i32 @usb_endpoint_xfer_int.450(%struct.usb_endpoint_descriptor* %desc60)
  %tobool62 = icmp ne i32 %call61, 0
  br i1 %tobool62, label %land.lhs.true63, label %if.else79

land.lhs.true63:                                  ; preds = %lor.lhs.false59, %if.end55
  %bmAttributes = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 3
  %10 = load i8, i8* %bmAttributes, align 1, !tbaa !533
  %conv64 = zext i8 %10 to i32
  %cmp65 = icmp ne i32 %conv64, 0
  br i1 %cmp65, label %if.then67, label %if.else79

if.then67:                                        ; preds = %land.lhs.true63
  %desc68 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call69 = call i32 @usb_endpoint_xfer_control.461(%struct.usb_endpoint_descriptor* %desc68)
  %11 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %ss_ep_comp77 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %bmAttributes78 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp77, i32 0, i32 3
  store i8 0, i8* %bmAttributes78, align 1, !tbaa !426
  br label %if.end115

if.else79:                                        ; preds = %land.lhs.true63, %lor.lhs.false59
  %desc80 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call81 = call i32 @usb_endpoint_xfer_bulk.454(%struct.usb_endpoint_descriptor* %desc80)
  %tobool82 = icmp ne i32 %call81, 0
  br i1 %tobool82, label %land.lhs.true83, label %if.else95

land.lhs.true83:                                  ; preds = %if.else79
  %bmAttributes84 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 3
  %12 = load i8, i8* %bmAttributes84, align 1, !tbaa !533
  %conv85 = zext i8 %12 to i32
  %cmp86 = icmp sgt i32 %conv85, 16
  br i1 %cmp86, label %if.then88, label %if.else95

if.then88:                                        ; preds = %land.lhs.true83
  %13 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %ss_ep_comp93 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %bmAttributes94 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp93, i32 0, i32 3
  store i8 16, i8* %bmAttributes94, align 1, !tbaa !426
  br label %if.end115

if.else95:                                        ; preds = %land.lhs.true83, %if.else79
  %desc96 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call97 = call i32 @usb_endpoint_xfer_isoc.452(%struct.usb_endpoint_descriptor* %desc96)
  %tobool98 = icmp ne i32 %call97, 0
  br i1 %tobool98, label %land.lhs.true99, label %if.end115

land.lhs.true99:                                  ; preds = %if.else95
  %bmAttributes100 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 3
  %14 = load i8, i8* %bmAttributes100, align 1, !tbaa !533
  %conv101 = zext i8 %14 to i32
  %cmp102 = icmp sgt i32 %conv101, 2
  br i1 %cmp102, label %if.then104, label %if.end115

if.then104:                                       ; preds = %land.lhs.true99
  %15 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %ss_ep_comp111 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %bmAttributes112 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp111, i32 0, i32 3
  store i8 2, i8* %bmAttributes112, align 1, !tbaa !426
  br label %if.end115

if.end115:                                        ; preds = %if.then104, %land.lhs.true99, %if.else95, %if.then88, %if.then67
  %desc116 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call117 = call i32 @usb_endpoint_xfer_isoc.452(%struct.usb_endpoint_descriptor* %desc116)
  %tobool118 = icmp ne i32 %call117, 0
  br i1 %tobool118, label %if.then119, label %if.else129

if.then119:                                       ; preds = %if.end115
  %bMaxBurst120 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 2
  %16 = load i8, i8* %bMaxBurst120, align 1, !tbaa !532
  %conv121 = zext i8 %16 to i32
  %add122 = add nsw i32 %conv121, 1
  %bmAttributes123 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 3
  %17 = load i8, i8* %bmAttributes123, align 1, !tbaa !533
  %conv124 = zext i8 %17 to i32
  %add125 = add nsw i32 %conv124, 1
  %mul = mul nsw i32 %add122, %add125
  %desc126 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call127 = call i32 @usb_endpoint_maxp.455(%struct.usb_endpoint_descriptor* %desc126)
  %mul128 = mul nsw i32 %mul, %call127
  br label %if.end142

if.else129:                                       ; preds = %if.end115
  %desc130 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call131 = call i32 @usb_endpoint_xfer_int.450(%struct.usb_endpoint_descriptor* %desc130)
  %tobool132 = icmp ne i32 %call131, 0
  br i1 %tobool132, label %if.then133, label %if.end142

if.then133:                                       ; preds = %if.else129
  %desc134 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call135 = call i32 @usb_endpoint_maxp.455(%struct.usb_endpoint_descriptor* %desc134)
  %bMaxBurst136 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 2
  %18 = load i8, i8* %bMaxBurst136, align 1, !tbaa !532
  %conv137 = zext i8 %18 to i32
  %add138 = add nsw i32 %conv137, 1
  %mul139 = mul nsw i32 %call135, %add138
  br label %if.end142

if.end142:                                        ; preds = %if.then133, %if.else129, %if.then119
  %max_tx.1 = phi i32 [ %mul128, %if.then119 ], [ %mul139, %if.then133 ], [ 999999, %if.else129 ]
  %wBytesPerInterval143 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %0, i32 0, i32 4
  %19 = load i16, i16* %wBytesPerInterval143, align 1, !tbaa !534
  %conv144 = zext i16 %19 to i32
  %cmp145 = icmp sgt i32 %conv144, %max_tx.1
  br i1 %cmp145, label %if.then147, label %cleanup.cont

if.then147:                                       ; preds = %if.end142
  %desc148 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 0
  %call149 = call i32 @usb_endpoint_xfer_isoc.452(%struct.usb_endpoint_descriptor* %desc148)
  %20 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %conv158 = trunc i32 %max_tx.1 to i16
  %ss_ep_comp159 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %ep, i32 0, i32 1
  %wBytesPerInterval160 = getelementptr inbounds %struct.usb_ss_ep_comp_descriptor, %struct.usb_ss_ep_comp_descriptor* %ss_ep_comp159, i32 0, i32 4
  store i16 %conv158, i16* %wBytesPerInterval160, align 1, !tbaa !531
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then147, %if.end142, %if.then14, %lor.lhs.false10
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_control.461(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set.472(%union.anon.5* %v, i32 %i) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !94
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_release_bos_descriptor(%struct.usb_device* %dev) #0 {
entry:
  %bos = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %0 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos, align 8, !tbaa !177
  %tobool = icmp ne %struct.usb_host_bos* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %bos1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %1 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos1, align 8, !tbaa !177
  %desc = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %1, i32 0, i32 0
  %2 = load %struct.usb_bos_descriptor*, %struct.usb_bos_descriptor** %desc, align 8, !tbaa !535
  %3 = bitcast %struct.usb_bos_descriptor* %2 to i8*
  call void @kfree(i8* %3)
  %bos2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %4 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos2, align 8, !tbaa !177
  %5 = bitcast %struct.usb_host_bos* %4 to i8*
  call void @kfree(i8* %5)
  %bos3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  store %struct.usb_host_bos* null, %struct.usb_host_bos** %bos3, align 8, !tbaa !177
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_get_bos_descriptor(%struct.usb_device* %dev) #0 {
entry:
  %call = call i8* @kzalloc.417(i64 5, i32 208)
  %0 = bitcast i8* %call to %struct.usb_bos_descriptor*
  %tobool = icmp ne %struct.usb_bos_descriptor* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %1 = bitcast %struct.usb_bos_descriptor* %0 to i8*
  %call2 = call i32 @usb_get_descriptor(%struct.usb_device* %dev, i8 zeroext 15, i8 zeroext 0, i8* %1, i32 5)
  %cmp = icmp slt i32 %call2, 5
  br i1 %cmp, label %if.then3, label %if.end8

if.then3:                                         ; preds = %if.end
  %2 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %cmp5 = icmp sge i32 %call2, 0
  %.call2 = select i1 %cmp5, i32 -42, i32 %call2
  %3 = bitcast %struct.usb_bos_descriptor* %0 to i8*
  call void @kfree(i8* %3)
  br label %cleanup

if.end8:                                          ; preds = %if.end
  %bLength = getelementptr inbounds %struct.usb_bos_descriptor, %struct.usb_bos_descriptor* %0, i32 0, i32 0
  %4 = load i8, i8* %bLength, align 1, !tbaa !536
  %conv = zext i8 %4 to i32
  %wTotalLength = getelementptr inbounds %struct.usb_bos_descriptor, %struct.usb_bos_descriptor* %0, i32 0, i32 2
  %5 = load i16, i16* %wTotalLength, align 1, !tbaa !538
  %conv9 = zext i16 %5 to i32
  %bNumDeviceCaps = getelementptr inbounds %struct.usb_bos_descriptor, %struct.usb_bos_descriptor* %0, i32 0, i32 3
  %6 = load i8, i8* %bNumDeviceCaps, align 1, !tbaa !539
  %conv10 = zext i8 %6 to i32
  %7 = bitcast %struct.usb_bos_descriptor* %0 to i8*
  call void @kfree(i8* %7)
  %cmp11 = icmp slt i32 %conv9, %conv
  br i1 %cmp11, label %cleanup, label %if.end14

if.end14:                                         ; preds = %if.end8
  %call15 = call i8* @kzalloc.417(i64 32, i32 208)
  %8 = bitcast i8* %call15 to %struct.usb_host_bos*
  %bos16 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  store %struct.usb_host_bos* %8, %struct.usb_host_bos** %bos16, align 8, !tbaa !177
  %bos17 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %9 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos17, align 8, !tbaa !177
  %tobool18 = icmp ne %struct.usb_host_bos* %9, null
  br i1 %tobool18, label %if.end20, label %cleanup

if.end20:                                         ; preds = %if.end14
  %conv21 = sext i32 %conv9 to i64
  %call22 = call i8* @kzalloc.417(i64 %conv21, i32 208)
  %tobool23 = icmp ne i8* %call22, null
  br i1 %tobool23, label %if.end25, label %err

if.end25:                                         ; preds = %if.end20
  %10 = bitcast i8* %call22 to %struct.usb_bos_descriptor*
  %bos26 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %11 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos26, align 8, !tbaa !177
  %desc = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %11, i32 0, i32 0
  store %struct.usb_bos_descriptor* %10, %struct.usb_bos_descriptor** %desc, align 8, !tbaa !535
  %call27 = call i32 @usb_get_descriptor(%struct.usb_device* %dev, i8 zeroext 15, i8 zeroext 0, i8* %call22, i32 %conv9)
  %cmp28 = icmp slt i32 %call27, %conv9
  br i1 %cmp28, label %if.then30, label %if.end36

if.then30:                                        ; preds = %if.end25
  %12 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %cmp32 = icmp sge i32 %call27, 0
  %.call27 = select i1 %cmp32, i32 -42, i32 %call27
  br label %err

if.end36:                                         ; preds = %if.end25
  %sub = sub nsw i32 %conv9, %conv
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end36
  %length.0 = phi i32 [ %conv, %if.end36 ], [ %conv40, %for.inc ]
  %buffer.0 = phi i8* [ %call22, %if.end36 ], [ %add.ptr, %for.inc ]
  %total_len.0 = phi i32 [ %sub, %if.end36 ], [ %sub45, %for.inc ]
  %i.0 = phi i32 [ 0, %if.end36 ], [ %inc, %for.inc ]
  %cmp37 = icmp slt i32 %i.0, %conv10
  br i1 %cmp37, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %idx.ext = sext i32 %length.0 to i64
  %add.ptr = getelementptr inbounds i8, i8* %buffer.0, i64 %idx.ext
  %13 = bitcast i8* %add.ptr to %struct.usb_otg_descriptor*
  %bLength39 = getelementptr inbounds %struct.usb_otg_descriptor, %struct.usb_otg_descriptor* %13, i32 0, i32 0
  %14 = load i8, i8* %bLength39, align 1, !tbaa !540
  %conv40 = zext i8 %14 to i32
  %cmp41 = icmp slt i32 %total_len.0, %conv40
  br i1 %cmp41, label %cleanup, label %if.end44

if.end44:                                         ; preds = %for.body
  %sub45 = sub nsw i32 %total_len.0, %conv40
  %bDescriptorType = getelementptr inbounds %struct.usb_otg_descriptor, %struct.usb_otg_descriptor* %13, i32 0, i32 1
  %15 = load i8, i8* %bDescriptorType, align 1, !tbaa !542
  %conv46 = zext i8 %15 to i32
  %cmp47 = icmp ne i32 %conv46, 16
  br i1 %cmp47, label %if.then49, label %if.end51

if.then49:                                        ; preds = %if.end44
  %16 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %for.inc

if.end51:                                         ; preds = %if.end44
  %bDevCapabilityType = getelementptr inbounds %struct.usb_otg_descriptor, %struct.usb_otg_descriptor* %13, i32 0, i32 2
  %17 = load i8, i8* %bDevCapabilityType, align 1, !tbaa !543
  %conv52 = zext i8 %17 to i32
  %Pivot6 = icmp slt i32 %conv52, 3
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %if.end51
  %Pivot4 = icmp slt i32 %conv52, 4
  br i1 %Pivot4, label %sw.bb54, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %conv52, 4
  br i1 %SwitchLeaf2, label %sw.bb56, label %for.inc

NodeBlock:                                        ; preds = %if.end51
  %Pivot = icmp slt i32 %conv52, 2
  br i1 %Pivot, label %for.inc, label %sw.bb

sw.bb:                                            ; preds = %NodeBlock
  %18 = bitcast i8* %add.ptr to %struct.usb_ext_cap_descriptor*
  %bos53 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %19 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos53, align 8, !tbaa !177
  %ext_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %19, i32 0, i32 1
  store %struct.usb_ext_cap_descriptor* %18, %struct.usb_ext_cap_descriptor** %ext_cap, align 8, !tbaa !200
  br label %for.inc

sw.bb54:                                          ; preds = %NodeBlock3
  %20 = bitcast i8* %add.ptr to %struct.usb_ss_cap_descriptor*
  %bos55 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %21 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos55, align 8, !tbaa !177
  %ss_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %21, i32 0, i32 2
  store %struct.usb_ss_cap_descriptor* %20, %struct.usb_ss_cap_descriptor** %ss_cap, align 8, !tbaa !178
  br label %for.inc

sw.bb56:                                          ; preds = %LeafBlock1
  %22 = bitcast i8* %add.ptr to %struct.usb_ss_container_id_descriptor*
  %bos57 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 13
  %23 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos57, align 8, !tbaa !177
  %ss_id = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %23, i32 0, i32 3
  store %struct.usb_ss_container_id_descriptor* %22, %struct.usb_ss_container_id_descriptor** %ss_id, align 8, !tbaa !544
  br label %for.inc

for.inc:                                          ; preds = %sw.bb56, %sw.bb54, %sw.bb, %NodeBlock, %LeafBlock1, %if.then49
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

err:                                              ; preds = %if.then30, %if.end20
  %ret.2 = phi i32 [ %.call27, %if.then30 ], [ -12, %if.end20 ]
  call void @usb_release_bos_descriptor(%struct.usb_device* %dev)
  br label %cleanup

cleanup:                                          ; preds = %err, %for.body, %for.cond, %if.end14, %if.end8, %if.then3, %entry
  %retval.0 = phi i32 [ %.call2, %if.then3 ], [ %ret.2, %err ], [ -12, %entry ], [ -22, %if.end8 ], [ -12, %if.end14 ], [ 0, %for.cond ], [ 0, %for.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_deregister_dev(%struct.usb_interface* %intf, %struct.usb_class_driver* %class_driver) #0 {
entry:
  %minor = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  %0 = load i32, i32* %minor, align 8, !tbaa !57
  %cmp = icmp eq i32 %0, -1
  br i1 %cmp, label %return, label %do.body1

do.body1:                                         ; preds = %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_deregister_dev.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.end7

if.then4:                                         ; preds = %do.body1
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %minor5 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  %1 = load i32, i32* %minor5, align 8, !tbaa !57
  %call = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_deregister_dev.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.6.483, i32 0, i32 0), i32 %1)
  br label %do.end7

do.end7:                                          ; preds = %if.then4, %do.body1
  call void @down_write(%struct.rw_semaphore* @minor_rwsem)
  %minor8 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  %2 = load i32, i32* %minor8, align 8, !tbaa !57
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.file_operations*], [256 x %struct.file_operations*]* @usb_minors, i64 0, i64 %idxprom
  store %struct.file_operations* null, %struct.file_operations** %arrayidx, align 8, !tbaa !48
  call void @up_write(%struct.rw_semaphore* @minor_rwsem)
  %3 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !48
  %class = getelementptr inbounds %struct.usb_class, %struct.usb_class* %3, i32 0, i32 1
  %4 = load %struct.class*, %struct.class** %class, align 8, !tbaa !545
  %minor9 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  %5 = load i32, i32* %minor9, align 8, !tbaa !57
  %or = or i32 188743680, %5
  call void @device_destroy(%struct.class* %4, i32 %or)
  %usb_dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 8
  store %struct.device* null, %struct.device** %usb_dev, align 8, !tbaa !547
  %minor10 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  store i32 -1, i32* %minor10, align 8, !tbaa !57
  call void @destroy_usb_class()
  br label %return

return:                                           ; preds = %do.end7, %entry
  ret void
}

declare void @down_write(%struct.rw_semaphore*) #2

declare void @up_write(%struct.rw_semaphore*) #2

declare void @device_destroy(%struct.class*, i32) #2

; Function Attrs: nounwind uwtable
define internal void @destroy_usb_class() #0 {
entry:
  %0 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !48
  %tobool = icmp ne %struct.usb_class* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !48
  %kref = getelementptr inbounds %struct.usb_class, %struct.usb_class* %1, i32 0, i32 0
  call void @kref_put.484(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* @release_usb_class)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @release_usb_class(%struct.arch_spinlock* %kref) #0 {
entry:
  %0 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !48
  %class = getelementptr inbounds %struct.usb_class, %struct.usb_class* %0, i32 0, i32 1
  %1 = load %struct.class*, %struct.class** %class, align 8, !tbaa !545
  call void @class_destroy(%struct.class* %1)
  %2 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !48
  %3 = bitcast %struct.usb_class* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.usb_class* null, %struct.usb_class** @usb_class, align 8, !tbaa !48
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put.484(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* %release) #1 {
entry:
  call void @kref_sub.485(%struct.arch_spinlock* %kref, i32 1, void (%struct.arch_spinlock*)* %release)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_sub.485(%struct.arch_spinlock* %kref, i32 %count, void (%struct.arch_spinlock*)* %release) #1 {
entry:
  %cmp = icmp eq void (%struct.arch_spinlock*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.10.486, i32 0, i32 0), i32 71)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_sub_and_test.487(i32 %count, %union.anon.5* %refcount)
  %tobool14 = icmp ne i32 %call, 0
  br i1 %tobool14, label %if.then15, label %return

if.then15:                                        ; preds = %if.end
  call void %release(%struct.arch_spinlock* %kref)
  br label %return

return:                                           ; preds = %if.then15, %if.end
  %retval.0 = phi i32 [ 1, %if.then15 ], [ 0, %if.end ]
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_sub_and_test.487(i32 %i, %union.anon.5* %v) #1 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subl $2,$0; sete $1", "=*m,=*qm,ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32 %i, i32* %counter) #8, !srcloc !548
  %0 = load i8, i8* %c, align 1, !tbaa !84
  %conv = zext i8 %0 to i32
  ret i32 %conv
}

declare void @class_destroy(%struct.class*) #2

; Function Attrs: nounwind uwtable
define i32 @usb_register_dev(%struct.usb_interface* %intf, %struct.usb_class_driver* %class_driver) #0 {
entry:
  %name = alloca [20 x i8], align 16
  %0 = bitcast [20 x i8]* %name to i8*
  %fops = getelementptr inbounds %struct.usb_class_driver, %struct.usb_class_driver* %class_driver, i32 0, i32 2
  %1 = load %struct.file_operations*, %struct.file_operations** %fops, align 8, !tbaa !549
  %cmp = icmp eq %struct.file_operations* %1, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %minor3 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  %2 = load i32, i32* %minor3, align 8, !tbaa !57
  %cmp4 = icmp sge i32 %2, 0
  br i1 %cmp4, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %call = call i32 @init_usb_class()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %do.body9

do.body9:                                         ; preds = %if.end6
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_register_dev.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool10 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.then13, label %do.end17

if.then13:                                        ; preds = %do.body9
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call14 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_register_dev.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.4.492, i32 0, i32 0), i32 0)
  br label %do.end17

do.end17:                                         ; preds = %if.then13, %do.body9
  call void @down_write(%struct.rw_semaphore* @minor_rwsem)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end17
  %minor.0 = phi i32 [ 0, %do.end17 ], [ %inc, %for.inc ]
  %cmp18 = icmp slt i32 %minor.0, 256
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %minor.0 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.file_operations*], [256 x %struct.file_operations*]* @usb_minors, i64 0, i64 %idxprom
  %3 = load %struct.file_operations*, %struct.file_operations** %arrayidx, align 8, !tbaa !48
  %tobool20 = icmp ne %struct.file_operations* %3, null
  br i1 %tobool20, label %for.inc, label %if.end22

if.end22:                                         ; preds = %for.body
  %fops23 = getelementptr inbounds %struct.usb_class_driver, %struct.usb_class_driver* %class_driver, i32 0, i32 2
  %4 = load %struct.file_operations*, %struct.file_operations** %fops23, align 8, !tbaa !549
  %idxprom24 = sext i32 %minor.0 to i64
  %arrayidx25 = getelementptr inbounds [256 x %struct.file_operations*], [256 x %struct.file_operations*]* @usb_minors, i64 0, i64 %idxprom24
  store %struct.file_operations* %4, %struct.file_operations** %arrayidx25, align 8, !tbaa !48
  %minor26 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  store i32 %minor.0, i32* %minor26, align 8, !tbaa !57
  br label %for.end

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %minor.0, 1
  br label %for.cond

for.end:                                          ; preds = %if.end22, %for.cond
  call void @up_write(%struct.rw_semaphore* @minor_rwsem)
  %minor27 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  %5 = load i32, i32* %minor27, align 8, !tbaa !57
  %cmp28 = icmp slt i32 %5, 0
  br i1 %cmp28, label %cleanup, label %if.end31

if.end31:                                         ; preds = %for.end
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %name, i32 0, i32 0
  %name32 = getelementptr inbounds %struct.usb_class_driver, %struct.usb_class_driver* %class_driver, i32 0, i32 0
  %6 = load i8*, i8** %name32, align 8, !tbaa !551
  %sub = sub nsw i32 %minor.0, 0
  %call33 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 20, i8* %6, i32 %sub)
  %arraydecay34 = getelementptr inbounds [20 x i8], [20 x i8]* %name, i32 0, i32 0
  %call35 = call i8* @strrchr(i8* %arraydecay34, i32 47)
  %tobool36 = icmp ne i8* %call35, null
  br i1 %tobool36, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end31
  %arrayidx37 = getelementptr inbounds i8, i8* %call35, i64 1
  %7 = load i8, i8* %arrayidx37, align 1, !tbaa !84
  %conv38 = sext i8 %7 to i32
  %cmp39 = icmp ne i32 %conv38, 0
  br i1 %cmp39, label %if.then41, label %if.else

if.then41:                                        ; preds = %land.lhs.true
  %incdec.ptr = getelementptr inbounds i8, i8* %call35, i32 1
  br label %if.end43

if.else:                                          ; preds = %land.lhs.true, %if.end31
  %arraydecay42 = getelementptr inbounds [20 x i8], [20 x i8]* %name, i32 0, i32 0
  br label %if.end43

if.end43:                                         ; preds = %if.else, %if.then41
  %temp.0 = phi i8* [ %incdec.ptr, %if.then41 ], [ %arraydecay42, %if.else ]
  %8 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !48
  %class = getelementptr inbounds %struct.usb_class, %struct.usb_class* %8, i32 0, i32 1
  %9 = load %struct.class*, %struct.class** %class, align 8, !tbaa !545
  %dev44 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %or = or i32 188743680, %minor.0
  %10 = bitcast %struct.usb_class_driver* %class_driver to i8*
  %call45 = call %struct.device* (%struct.class*, %struct.device*, i32, i8*, i8*, ...) @device_create(%struct.class* %9, %struct.device* %dev44, i32 %or, i8* %10, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.5.493, i32 0, i32 0), i8* %temp.0)
  %usb_dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 8
  store %struct.device* %call45, %struct.device** %usb_dev, align 8, !tbaa !547
  %usb_dev46 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 8
  %11 = load %struct.device*, %struct.device** %usb_dev46, align 8, !tbaa !547
  %12 = bitcast %struct.device* %11 to i8*
  %call47 = call i64 @IS_ERR.494(i8* %12)
  %tobool48 = icmp ne i64 %call47, 0
  br i1 %tobool48, label %if.then49, label %cleanup

if.then49:                                        ; preds = %if.end43
  call void @down_write(%struct.rw_semaphore* @minor_rwsem)
  %idxprom50 = sext i32 %minor.0 to i64
  %arrayidx51 = getelementptr inbounds [256 x %struct.file_operations*], [256 x %struct.file_operations*]* @usb_minors, i64 0, i64 %idxprom50
  store %struct.file_operations* null, %struct.file_operations** %arrayidx51, align 8, !tbaa !48
  %minor52 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 4
  store i32 -1, i32* %minor52, align 8, !tbaa !57
  call void @up_write(%struct.rw_semaphore* @minor_rwsem)
  %usb_dev53 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 8
  %13 = load %struct.device*, %struct.device** %usb_dev53, align 8, !tbaa !547
  %14 = bitcast %struct.device* %13 to i8*
  %call54 = call i64 @PTR_ERR(i8* %14)
  %conv55 = trunc i64 %call54 to i32
  br label %cleanup

cleanup:                                          ; preds = %if.then49, %if.end43, %for.end, %if.end6, %if.end, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -98, %if.end ], [ %call, %if.end6 ], [ -54, %for.end ], [ %conv55, %if.then49 ], [ %call, %if.end43 ]
  %15 = bitcast [20 x i8]* %name to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @init_usb_class() #0 {
entry:
  %0 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !48
  %cmp = icmp ne %struct.usb_class* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !48
  %kref = getelementptr inbounds %struct.usb_class, %struct.usb_class* %1, i32 0, i32 0
  call void @kref_get.495(%struct.arch_spinlock* %kref)
  br label %exit

if.end:                                           ; preds = %entry
  %call.i = call i8* @__kmalloc(i64 16, i32 208) #8
  %2 = bitcast i8* %call.i to %struct.usb_class*
  store %struct.usb_class* %2, %struct.usb_class** @usb_class, align 8, !tbaa !48
  %3 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !48
  %tobool = icmp ne %struct.usb_class* %3, null
  br i1 %tobool, label %if.end2, label %exit

if.end2:                                          ; preds = %if.end
  %4 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !48
  %kref3 = getelementptr inbounds %struct.usb_class, %struct.usb_class* %4, i32 0, i32 0
  call void @kref_init.497(%struct.arch_spinlock* %kref3)
  %call4 = call %struct.class* @__class_create(%struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.8.498, i32 0, i32 0), %struct.lock_class_key* @init_usb_class.__key)
  %5 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !48
  %class = getelementptr inbounds %struct.usb_class, %struct.usb_class* %5, i32 0, i32 1
  store %struct.class* %call4, %struct.class** %class, align 8, !tbaa !545
  %6 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !48
  %class5 = getelementptr inbounds %struct.usb_class, %struct.usb_class* %6, i32 0, i32 1
  %7 = load %struct.class*, %struct.class** %class5, align 8, !tbaa !545
  %8 = bitcast %struct.class* %7 to i8*
  %call6 = call i64 @IS_ERR.494(i8* %8)
  %tobool7 = icmp ne i64 %call6, 0
  %9 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !48
  %class9 = getelementptr inbounds %struct.usb_class, %struct.usb_class* %9, i32 0, i32 1
  %10 = load %struct.class*, %struct.class** %class9, align 8, !tbaa !545
  br i1 %tobool7, label %if.then8, label %if.end12

if.then8:                                         ; preds = %if.end2
  %11 = bitcast %struct.class* %10 to i8*
  %call10 = call i64 @IS_ERR.494(i8* %11)
  %conv = trunc i64 %call10 to i32
  %12 = call i32 (i8*, ...) @printk(i8* null)
  %13 = load %struct.usb_class*, %struct.usb_class** @usb_class, align 8, !tbaa !48
  %14 = bitcast %struct.usb_class* %13 to i8*
  call void @kfree(i8* %14)
  store %struct.usb_class* null, %struct.usb_class** @usb_class, align 8, !tbaa !48
  br label %exit

if.end12:                                         ; preds = %if.end2
  %devnode = getelementptr inbounds %struct.class, %struct.class* %10, i32 0, i32 7
  store i8* (%struct.device*, i16*)* @usb_devnode.500, i8* (%struct.device*, i16*)** %devnode, align 8, !tbaa !552
  br label %exit

exit:                                             ; preds = %if.end12, %if.then8, %if.end, %if.then
  %result.0 = phi i32 [ 0, %if.then ], [ %conv, %if.then8 ], [ 0, %if.end12 ], [ -12, %if.end ]
  ret i32 %result.0
}

declare i8* @strrchr(i8*, i32) #2

declare %struct.device* @device_create(%struct.class*, %struct.device*, i32, i8*, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR.494(i8* %ptr) #1 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #1 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_get.495(%struct.arch_spinlock* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_add_return.502(i32 1, %union.anon.5* %refcount)
  %cmp = icmp slt i32 %call, 2
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  %0 = load i8, i8* @kref_get.__warned.503, align 1, !tbaa !43, !range !44
  %tobool7 = trunc i8 %0 to i1
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %tobool14 = icmp ne i32 %lnot.ext13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.10.486, i32 0, i32 0), i32 47)
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then
  %tobool23 = icmp ne i32 %lnot.ext13, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end
  store i8 1, i8* @kref_get.__warned.503, align 1, !tbaa !43
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_init.497(%struct.arch_spinlock* %kref) #1 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  call void @atomic_set.501(%union.anon.5* %refcount, i32 1)
  ret void
}

declare %struct.class* @__class_create(%struct.module*, i8*, %struct.lock_class_key*) #2

; Function Attrs: nounwind uwtable
define internal i8* @usb_devnode.500(%struct.device* %dev, i16* %mode) #0 {
entry:
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.usb_class_driver*
  %tobool = icmp ne %struct.usb_class_driver* %0, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %devnode = getelementptr inbounds %struct.usb_class_driver, %struct.usb_class_driver* %0, i32 0, i32 1
  %1 = load i8* (%struct.device*, i16*)*, i8* (%struct.device*, i16*)** %devnode, align 8, !tbaa !554
  %tobool1 = icmp ne i8* (%struct.device*, i16*)* %1, null
  br i1 %tobool1, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %devnode2 = getelementptr inbounds %struct.usb_class_driver, %struct.usb_class_driver* %0, i32 0, i32 1
  %2 = load i8* (%struct.device*, i16*)*, i8* (%struct.device*, i16*)** %devnode2, align 8, !tbaa !554
  %call3 = call i8* %2(%struct.device* %dev, i16* %mode)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %lor.lhs.false, %entry
  %retval.0 = phi i8* [ %call3, %if.end ], [ null, %lor.lhs.false ], [ null, %entry ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set.501(%union.anon.5* %v, i32 %i) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !94
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_return.502(i32 %i, %union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #8, !srcloc !555
  %add = add nsw i32 %i, %0
  ret i32 %add
}

; Function Attrs: nounwind uwtable
define i32 @usb_major_init() #0 {
entry:
  %call = call i32 @register_chrdev(i32 180, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.774, i32 0, i32 0), %struct.file_operations* @usb_fops)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @register_chrdev(i32 %major, i8* %name, %struct.file_operations* %fops) #1 {
entry:
  %call = call i32 @__register_chrdev(i32 %major, i32 0, i32 256, i8* %name, %struct.file_operations* %fops)
  ret i32 %call
}

declare i32 @__register_chrdev(i32, i32, i32, i8*, %struct.file_operations*) #2

declare i64 @noop_llseek(%struct.file*, i64, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @usb_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %call = call i32 @iminor(%struct.inode* %inode)
  call void @down_read(%struct.rw_semaphore* @minor_rwsem)
  %idxprom = sext i32 %call to i64
  %arrayidx = getelementptr inbounds [256 x %struct.file_operations*], [256 x %struct.file_operations*]* @usb_minors, i64 0, i64 %idxprom
  %0 = load %struct.file_operations*, %struct.file_operations** %arrayidx, align 8, !tbaa !48
  %tobool = icmp ne %struct.file_operations* %0, null
  br i1 %tobool, label %land.lhs.true, label %done

land.lhs.true:                                    ; preds = %entry
  %owner = getelementptr inbounds %struct.file_operations, %struct.file_operations* %0, i32 0, i32 0
  %1 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !556
  %call2 = call zeroext i1 @try_module_get(%struct.module* %1)
  %. = select i1 %call2, %struct.file_operations* %0, %struct.file_operations* null
  %tobool3 = icmp ne %struct.file_operations* %., null
  br i1 %tobool3, label %if.end, label %done

if.end:                                           ; preds = %land.lhs.true
  %f_op = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %2 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8, !tbaa !558
  %f_op4 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  store %struct.file_operations* %., %struct.file_operations** %f_op4, align 8, !tbaa !558
  %f_op5 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %3 = load %struct.file_operations*, %struct.file_operations** %f_op5, align 8, !tbaa !558
  %open = getelementptr inbounds %struct.file_operations, %struct.file_operations* %3, i32 0, i32 11
  %4 = load i32 (%struct.inode*, %struct.file*)*, i32 (%struct.inode*, %struct.file*)** %open, align 8, !tbaa !564
  %tobool6 = icmp ne i32 (%struct.inode*, %struct.file*)* %4, null
  br i1 %tobool6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end
  %f_op8 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %5 = load %struct.file_operations*, %struct.file_operations** %f_op8, align 8, !tbaa !558
  %open9 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %5, i32 0, i32 11
  %6 = load i32 (%struct.inode*, %struct.file*)*, i32 (%struct.inode*, %struct.file*)** %open9, align 8, !tbaa !564
  %call10 = call i32 %6(%struct.inode* %inode, %struct.file* %file)
  br label %if.end11

if.end11:                                         ; preds = %if.then7, %if.end
  %err.0 = phi i32 [ %call10, %if.then7 ], [ -19, %if.end ]
  %tobool12 = icmp ne i32 %err.0, 0
  br i1 %tobool12, label %do.body, label %do.body30

do.body:                                          ; preds = %if.end11
  %f_op14 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %7 = load %struct.file_operations*, %struct.file_operations** %f_op14, align 8, !tbaa !558
  %tobool15 = icmp ne %struct.file_operations* %7, null
  br i1 %tobool15, label %if.then16, label %do.end

if.then16:                                        ; preds = %do.body
  %f_op17 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %8 = load %struct.file_operations*, %struct.file_operations** %f_op17, align 8, !tbaa !558
  %owner18 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %8, i32 0, i32 0
  %9 = load %struct.module*, %struct.module** %owner18, align 8, !tbaa !556
  call void @module_put(%struct.module* %9)
  br label %do.end

do.end:                                           ; preds = %if.then16, %do.body
  %tobool20 = icmp ne %struct.file_operations* %2, null
  br i1 %tobool20, label %land.lhs.true21, label %cond.false25

land.lhs.true21:                                  ; preds = %do.end
  %owner22 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %2, i32 0, i32 0
  %10 = load %struct.module*, %struct.module** %owner22, align 8, !tbaa !556
  %call23 = call zeroext i1 @try_module_get(%struct.module* %10)
  br i1 %call23, label %cond.end26, label %cond.false25

cond.false25:                                     ; preds = %land.lhs.true21, %do.end
  br label %cond.end26

cond.end26:                                       ; preds = %cond.false25, %land.lhs.true21
  %cond27 = phi %struct.file_operations* [ null, %cond.false25 ], [ %2, %land.lhs.true21 ]
  %f_op28 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  store %struct.file_operations* %cond27, %struct.file_operations** %f_op28, align 8, !tbaa !558
  br label %do.body30

do.body30:                                        ; preds = %cond.end26, %if.end11
  %tobool31 = icmp ne %struct.file_operations* %2, null
  br i1 %tobool31, label %if.then32, label %done

if.then32:                                        ; preds = %do.body30
  %owner33 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %2, i32 0, i32 0
  %11 = load %struct.module*, %struct.module** %owner33, align 8, !tbaa !556
  call void @module_put(%struct.module* %11)
  br label %done

done:                                             ; preds = %if.then32, %do.body30, %land.lhs.true, %entry
  %err.1 = phi i32 [ -19, %land.lhs.true ], [ -19, %entry ], [ %err.0, %if.then32 ], [ %err.0, %do.body30 ]
  call void @up_read(%struct.rw_semaphore* @minor_rwsem)
  ret i32 %err.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @iminor(%struct.inode* %inode) #1 {
entry:
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 13
  %0 = load i32, i32* %i_rdev, align 4, !tbaa !565
  %and = and i32 %0, 1048575
  ret i32 %and
}

declare zeroext i1 @try_module_get(%struct.module*) #2

declare void @module_put(%struct.module*) #2

; Function Attrs: nounwind uwtable
define void @usb_major_cleanup() #0 {
entry:
  call void @unregister_chrdev(i32 180, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.774, i32 0, i32 0))
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @unregister_chrdev(i32 %major, i8* %name) #1 {
entry:
  call void @__unregister_chrdev(i32 %major, i32 0, i32 256, i8* %name)
  ret void
}

declare void @__unregister_chrdev(i32, i32, i32, i8*) #2

; Function Attrs: nounwind uwtable
define i32 @hcd_buffer_create(%struct.usb_hcd.2297* %hcd) #0 {
entry:
  %name = alloca [16 x i8], align 16
  %0 = bitcast [16 x i8]* %name to i8*
  %self = getelementptr inbounds %struct.usb_hcd.2297, %struct.usb_hcd.2297* %hcd, i32 0, i32 0
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %1 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !306
  %dma_mask = getelementptr inbounds %struct.device, %struct.device* %1, i32 0, i32 12
  %2 = load i64*, i64** %dma_mask, align 8, !tbaa !79
  %tobool = icmp ne i64* %2, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %driver = getelementptr inbounds %struct.usb_hcd.2297, %struct.usb_hcd.2297* %hcd, i32 0, i32 8
  %3 = load %struct.hc_driver.2300*, %struct.hc_driver.2300** %driver, align 8, !tbaa !71
  %flags = getelementptr inbounds %struct.hc_driver.2300, %struct.hc_driver.2300* %3, i32 0, i32 4
  %4 = load i32, i32* %flags, align 8, !tbaa !159
  %and = and i32 %4, 2
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.end, label %cleanup

if.end:                                           ; preds = %land.lhs.true, %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 4
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x i64], [4 x i64]* @pool_max, i64 0, i64 %idxprom
  %5 = load i64, i64* %arrayidx, align 8, !tbaa !49
  %conv = trunc i64 %5 to i32
  %tobool2 = icmp ne i32 %conv, 0
  br i1 %tobool2, label %if.end4, label %for.inc

if.end4:                                          ; preds = %for.body
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %name, i32 0, i32 0
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 16, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.512, i32 0, i32 0), i32 %conv)
  %arraydecay5 = getelementptr inbounds [16 x i8], [16 x i8]* %name, i32 0, i32 0
  %self6 = getelementptr inbounds %struct.usb_hcd.2297, %struct.usb_hcd.2297* %hcd, i32 0, i32 0
  %controller7 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self6, i32 0, i32 0
  %6 = load %struct.device*, %struct.device** %controller7, align 8, !tbaa !306
  %conv8 = sext i32 %conv to i64
  %conv9 = sext i32 %conv to i64
  %call10 = call %struct.dma_pool* @dma_pool_create(i8* %arraydecay5, %struct.device* %6, i64 %conv8, i64 %conv9, i64 0)
  %pool = getelementptr inbounds %struct.usb_hcd.2297, %struct.usb_hcd.2297* %hcd, i32 0, i32 20
  %idxprom11 = sext i32 %i.0 to i64
  %arrayidx12 = getelementptr inbounds [4 x %struct.dma_pool*], [4 x %struct.dma_pool*]* %pool, i64 0, i64 %idxprom11
  store %struct.dma_pool* %call10, %struct.dma_pool** %arrayidx12, align 8, !tbaa !48
  %pool13 = getelementptr inbounds %struct.usb_hcd.2297, %struct.usb_hcd.2297* %hcd, i32 0, i32 20
  %idxprom14 = sext i32 %i.0 to i64
  %arrayidx15 = getelementptr inbounds [4 x %struct.dma_pool*], [4 x %struct.dma_pool*]* %pool13, i64 0, i64 %idxprom14
  %7 = load %struct.dma_pool*, %struct.dma_pool** %arrayidx15, align 8, !tbaa !48
  %tobool16 = icmp ne %struct.dma_pool* %7, null
  br i1 %tobool16, label %for.inc, label %if.then17

if.then17:                                        ; preds = %if.end4
  call void @hcd_buffer_destroy(%struct.usb_hcd.2297* %hcd)
  br label %cleanup

for.inc:                                          ; preds = %if.end4, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.then17, %for.cond, %land.lhs.true
  %retval.0 = phi i32 [ -12, %if.then17 ], [ 0, %land.lhs.true ], [ 0, %for.cond ]
  %8 = bitcast [16 x i8]* %name to i8*
  ret i32 %retval.0
}

declare %struct.dma_pool* @dma_pool_create(i8*, %struct.device*, i64, i64, i64) #2

; Function Attrs: nounwind uwtable
define void @hcd_buffer_destroy(%struct.usb_hcd.2297* %hcd) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %pool1 = getelementptr inbounds %struct.usb_hcd.2297, %struct.usb_hcd.2297* %hcd, i32 0, i32 20
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.dma_pool*], [4 x %struct.dma_pool*]* %pool1, i64 0, i64 %idxprom
  %0 = load %struct.dma_pool*, %struct.dma_pool** %arrayidx, align 8, !tbaa !48
  %tobool = icmp ne %struct.dma_pool* %0, null
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @dma_pool_destroy(%struct.dma_pool* %0)
  %pool2 = getelementptr inbounds %struct.usb_hcd.2297, %struct.usb_hcd.2297* %hcd, i32 0, i32 20
  %idxprom3 = sext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds [4 x %struct.dma_pool*], [4 x %struct.dma_pool*]* %pool2, i64 0, i64 %idxprom3
  store %struct.dma_pool* null, %struct.dma_pool** %arrayidx4, align 8, !tbaa !48
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @dma_pool_destroy(%struct.dma_pool*) #2

; Function Attrs: nounwind uwtable
define i8* @hcd_buffer_alloc(%struct.usb_bus* %bus, i64 %size, i32 %mem_flags, i64* %dma) #0 {
entry:
  %call = call %struct.usb_hcd.2297* @bus_to_hcd.517(%struct.usb_bus* %bus)
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !78
  %dma_mask = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 12
  %1 = load i64*, i64** %dma_mask, align 8, !tbaa !79
  %tobool = icmp ne i64* %1, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %driver = getelementptr inbounds %struct.usb_hcd.2297, %struct.usb_hcd.2297* %call, i32 0, i32 8
  %2 = load %struct.hc_driver.2300*, %struct.hc_driver.2300** %driver, align 8, !tbaa !71
  %flags = getelementptr inbounds %struct.hc_driver.2300, %struct.hc_driver.2300* %2, i32 0, i32 4
  %3 = load i32, i32* %flags, align 8, !tbaa !159
  %and = and i32 %3, 2
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  store i64 -1, i64* %dma, align 8, !tbaa !339
  %call.i = call i8* @__kmalloc(i64 %size, i32 %mem_flags) #8
  br label %cleanup

if.end:                                           ; preds = %land.lhs.true, %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x i64], [4 x i64]* @pool_max, i64 0, i64 %idxprom
  %4 = load i64, i64* %arrayidx, align 8, !tbaa !49
  %cmp3 = icmp ule i64 %size, %4
  br i1 %cmp3, label %if.then4, label %for.inc

if.then4:                                         ; preds = %for.body
  %pool = getelementptr inbounds %struct.usb_hcd.2297, %struct.usb_hcd.2297* %call, i32 0, i32 20
  %idxprom5 = sext i32 %i.0 to i64
  %arrayidx6 = getelementptr inbounds [4 x %struct.dma_pool*], [4 x %struct.dma_pool*]* %pool, i64 0, i64 %idxprom5
  %5 = load %struct.dma_pool*, %struct.dma_pool** %arrayidx6, align 8, !tbaa !48
  %call7 = call i8* @dma_pool_alloc(%struct.dma_pool* %5, i32 %mem_flags, i64* %dma)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %self = getelementptr inbounds %struct.usb_hcd.2297, %struct.usb_hcd.2297* %call, i32 0, i32 0
  %controller9 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %6 = load %struct.device*, %struct.device** %controller9, align 8, !tbaa !306
  %call10 = call i8* @dma_alloc_attrs(%struct.device* %6, i64 %size, i64* %dma, i32 %mem_flags, %struct.sigset_t* null)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then4, %if.then
  %retval.0 = phi i8* [ %call7, %if.then4 ], [ %call10, %for.end ], [ %call.i, %if.then ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd.2297* @bus_to_hcd.517(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd.2297*
  ret %struct.usb_hcd.2297* %1
}

declare i8* @dma_pool_alloc(%struct.dma_pool*, i32, i64*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dma_alloc_attrs(%struct.device* %dev, i64 %size, i64* %dma_handle, i32 %gfp, %struct.sigset_t* %attrs) #1 {
entry:
  %call = call %struct.dma_map_ops* @get_dma_ops.519(%struct.device* %dev)
  %and = and i32 %gfp, -8
  %tobool = icmp ne %struct.device* %dev, null
  %dev.x86_dma_fallback_dev = select i1 %tobool, %struct.device* %dev, %struct.device* @x86_dma_fallback_dev
  %call1 = call i32 @is_device_dma_capable(%struct.device* %dev.x86_dma_fallback_dev)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end4, label %cleanup

if.end4:                                          ; preds = %entry
  %alloc = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 0
  %0 = load i8* (%struct.device*, i64, i64*, i32, %struct.sigset_t*)*, i8* (%struct.device*, i64, i64*, i32, %struct.sigset_t*)** %alloc, align 8, !tbaa !571
  %tobool5 = icmp ne i8* (%struct.device*, i64, i64*, i32, %struct.sigset_t*)* %0, null
  br i1 %tobool5, label %if.end7, label %cleanup

if.end7:                                          ; preds = %if.end4
  %alloc8 = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 0
  %1 = load i8* (%struct.device*, i64, i64*, i32, %struct.sigset_t*)*, i8* (%struct.device*, i64, i64*, i32, %struct.sigset_t*)** %alloc8, align 8, !tbaa !571
  %call9 = call i32 @dma_alloc_coherent_gfp_flags(%struct.device* %dev.x86_dma_fallback_dev, i32 %and)
  %call10 = call i8* %1(%struct.device* %dev.x86_dma_fallback_dev, i64 %size, i64* %dma_handle, i32 %call9, %struct.sigset_t* %attrs)
  %2 = load i64, i64* %dma_handle, align 8, !tbaa !339
  call void @debug_dma_alloc_coherent(%struct.device* %dev.x86_dma_fallback_dev, i64 %size, i64 %2, i8* %call10)
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %if.end4, %entry
  %retval.0 = phi i8* [ %call10, %if.end7 ], [ null, %entry ], [ null, %if.end4 ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.dma_map_ops* @get_dma_ops.519(%struct.device* %dev) #1 {
entry:
  %tobool = icmp ne %struct.device* %dev, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %archdata = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 17
  %dma_ops = getelementptr inbounds %struct.dev_archdata, %struct.dev_archdata* %archdata, i32 0, i32 0
  %0 = load %struct.dma_map_ops*, %struct.dma_map_ops** %dma_ops, align 8, !tbaa !340
  %tobool4 = icmp ne %struct.dma_map_ops* %0, null
  br i1 %tobool4, label %if.else, label %return

if.else:                                          ; preds = %lor.lhs.false
  %archdata5 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 17
  %dma_ops6 = getelementptr inbounds %struct.dev_archdata, %struct.dev_archdata* %archdata5, i32 0, i32 0
  br label %return

return:                                           ; preds = %if.else, %lor.lhs.false, %entry
  %dma_ops6.sink = phi %struct.dma_map_ops** [ %dma_ops6, %if.else ], [ @dma_ops, %lor.lhs.false ], [ @dma_ops, %entry ]
  %1 = load %struct.dma_map_ops*, %struct.dma_map_ops** %dma_ops6.sink, align 8, !tbaa !48
  ret %struct.dma_map_ops* %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_device_dma_capable(%struct.device* %dev) #1 {
entry:
  %dma_mask = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 12
  %0 = load i64*, i64** %dma_mask, align 8, !tbaa !79
  %cmp = icmp ne i64* %0, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %dma_mask1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 12
  %1 = load i64*, i64** %dma_mask1, align 8, !tbaa !79
  %2 = load i64, i64* %1, align 8, !tbaa !339
  %cmp2 = icmp ne i64 %2, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp2, %land.rhs ]
  %land.ext = zext i1 %3 to i32
  ret i32 %land.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @dma_alloc_coherent_gfp_flags(%struct.device* %dev, i32 %gfp) #1 {
entry:
  %call = call i64 @dma_alloc_coherent_mask(%struct.device* %dev, i32 %gfp)
  %cmp = icmp ule i64 %call, 16777215
  %or = or i32 %gfp, 1
  %or.gfp = select i1 %cmp, i32 %or, i32 %gfp
  %cmp1 = icmp ugt i64 %call, 4294967295
  %and = and i32 %or.gfp, 1
  %tobool = icmp ne i32 %and, 0
  %or.cond = or i1 %cmp1, %tobool
  %or3 = or i32 %or.gfp, 4
  %gfp.addr.1 = select i1 %or.cond, i32 %or.gfp, i32 %or3
  ret i32 %gfp.addr.1
}

declare void @debug_dma_alloc_coherent(%struct.device*, i64, i64, i8*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @dma_alloc_coherent_mask(%struct.device* %dev, i32 %gfp) #1 {
entry:
  %coherent_dma_mask = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 13
  %0 = load i64, i64* %coherent_dma_mask, align 8, !tbaa !572
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %and = and i32 %gfp, 1
  %tobool1 = icmp ne i32 %and, 0
  %cond = select i1 %tobool1, i64 16777215, i64 4294967295
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %dma_mask.0 = phi i64 [ %0, %entry ], [ %cond, %if.then ]
  ret i64 %dma_mask.0
}

; Function Attrs: nounwind uwtable
define void @hcd_buffer_free(%struct.usb_bus* %bus, i64 %size, i8* %addr, i64 %dma) #0 {
entry:
  %call = call %struct.usb_hcd.2297* @bus_to_hcd.517(%struct.usb_bus* %bus)
  %tobool = icmp ne i8* %addr, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %controller = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %bus, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %controller, align 8, !tbaa !78
  %dma_mask = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 12
  %1 = load i64*, i64** %dma_mask, align 8, !tbaa !79
  %tobool1 = icmp ne i64* %1, null
  br i1 %tobool1, label %if.end4, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %driver = getelementptr inbounds %struct.usb_hcd.2297, %struct.usb_hcd.2297* %call, i32 0, i32 8
  %2 = load %struct.hc_driver.2300*, %struct.hc_driver.2300** %driver, align 8, !tbaa !71
  %flags = getelementptr inbounds %struct.hc_driver.2300, %struct.hc_driver.2300* %2, i32 0, i32 4
  %3 = load i32, i32* %flags, align 8, !tbaa !159
  %and = and i32 %3, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %land.lhs.true
  call void @kfree(i8* %addr)
  br label %cleanup.cont

if.end4:                                          ; preds = %land.lhs.true, %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %i.0 = phi i32 [ 0, %if.end4 ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x i64], [4 x i64]* @pool_max, i64 0, i64 %idxprom
  %4 = load i64, i64* %arrayidx, align 8, !tbaa !49
  %cmp5 = icmp ule i64 %size, %4
  br i1 %cmp5, label %if.then6, label %for.inc

if.then6:                                         ; preds = %for.body
  %pool = getelementptr inbounds %struct.usb_hcd.2297, %struct.usb_hcd.2297* %call, i32 0, i32 20
  %idxprom7 = sext i32 %i.0 to i64
  %arrayidx8 = getelementptr inbounds [4 x %struct.dma_pool*], [4 x %struct.dma_pool*]* %pool, i64 0, i64 %idxprom7
  %5 = load %struct.dma_pool*, %struct.dma_pool** %arrayidx8, align 8, !tbaa !48
  call void @dma_pool_free(%struct.dma_pool* %5, i8* %addr, i64 %dma)
  br label %cleanup.cont

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %self = getelementptr inbounds %struct.usb_hcd.2297, %struct.usb_hcd.2297* %call, i32 0, i32 0
  %controller10 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 0
  %6 = load %struct.device*, %struct.device** %controller10, align 8, !tbaa !306
  call void @dma_free_attrs(%struct.device* %6, i64 %size, i8* %addr, i64 %dma, %struct.sigset_t* null)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %if.then6, %if.then3, %entry
  ret void
}

declare void @dma_pool_free(%struct.dma_pool*, i8*, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @dma_free_attrs(%struct.device* %dev, i64 %size, i8* %vaddr, i64 %bus, %struct.sigset_t* %attrs) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy3 = alloca i64, align 8
  %__dummy24 = alloca i64, align 8
  %call = call %struct.dma_map_ops* @get_dma_ops.519(%struct.device* %dev)
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %call1 = call i64 @arch_local_save_flags.522()
  %4 = bitcast i64* %__dummy3 to i8*
  %5 = bitcast i64* %__dummy24 to i8*
  %6 = bitcast i64* %__dummy24 to i8*
  %7 = bitcast i64* %__dummy3 to i8*
  %call9 = call i32 @arch_irqs_disabled_flags.523(i64 %call1)
  %tobool = icmp ne i32 %call9, 0
  %lnot = xor i1 %tobool, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %tobool11 = icmp ne i32 %lnot.ext, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool17 = icmp ne i64 %expval, 0
  br i1 %tobool17, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.1.524, i32 0, i32 0), i32 166)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @debug_dma_free_coherent(%struct.device* %dev, i64 %size, i8* %vaddr, i64 %bus)
  %free = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 1
  %8 = load void (%struct.device*, i64, i8*, i64, %struct.sigset_t*)*, void (%struct.device*, i64, i8*, i64, %struct.sigset_t*)** %free, align 8, !tbaa !573
  %tobool26 = icmp ne void (%struct.device*, i64, i8*, i64, %struct.sigset_t*)* %8, null
  br i1 %tobool26, label %if.then27, label %if.end29

if.then27:                                        ; preds = %if.end
  %free28 = getelementptr inbounds %struct.dma_map_ops, %struct.dma_map_ops* %call, i32 0, i32 1
  %9 = load void (%struct.device*, i64, i8*, i64, %struct.sigset_t*)*, void (%struct.device*, i64, i8*, i64, %struct.sigset_t*)** %free28, align 8, !tbaa !573
  call void %9(%struct.device* %dev, i64 %size, i8* %vaddr, i64 %bus, %struct.sigset_t* %attrs)
  br label %if.end29

if.end29:                                         ; preds = %if.then27, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @arch_local_save_flags.522() #1 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops.581, %struct.pv_irq_ops.581* @pv_irq_ops, i32 0, i32 0, i32 0), align 8, !tbaa !349
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.9.881, i32 0, i32 0), i32 824, i64 12) #8, !srcloc !574
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call i64 asm sideeffect "771:\0A\09call *${2:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${1:c}\0A  .byte 772b-771b\0A  .short ${3:c}\0A.popsection\0A", "={ax},i,i,i,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 44, i8** getelementptr inbounds (%struct.pv_irq_ops.581, %struct.pv_irq_ops.581* @pv_irq_ops, i32 0, i32 0, i32 0), i32 1) #8, !srcloc !575
  ret i64 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @arch_irqs_disabled_flags.523(i64 %flags) #1 {
entry:
  %and = and i64 %flags, 512
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

declare void @debug_dma_free_coherent(%struct.device*, i64, i8*, i64) #2

; Function Attrs: nounwind uwtable
define internal zeroext i16 @dev_string_attrs_are_visible(%struct.kobject* %kobj, %struct.attribute* %a, i32 %n) #0 {
entry:
  %0 = bitcast %struct.kobject* %kobj to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.device*
  %2 = bitcast %struct.device* %1 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 -136
  %3 = bitcast i8* %add.ptr3 to %struct.usb_device*
  %cmp = icmp eq %struct.attribute* %a, getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_manufacturer, i32 0, i32 0)
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %manufacturer = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 25
  %4 = load i8*, i8** %manufacturer, align 8, !tbaa !40
  %cmp4 = icmp eq i8* %4, null
  br i1 %cmp4, label %cleanup, label %if.end19

if.else:                                          ; preds = %entry
  %cmp6 = icmp eq %struct.attribute* %a, getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_product, i32 0, i32 0)
  br i1 %cmp6, label %if.then7, label %if.else11

if.then7:                                         ; preds = %if.else
  %product = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 24
  %5 = load i8*, i8** %product, align 8, !tbaa !39
  %cmp8 = icmp eq i8* %5, null
  br i1 %cmp8, label %cleanup, label %if.end19

if.else11:                                        ; preds = %if.else
  %cmp12 = icmp eq %struct.attribute* %a, getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_serial, i32 0, i32 0)
  br i1 %cmp12, label %if.then13, label %if.end19

if.then13:                                        ; preds = %if.else11
  %serial = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 26
  %6 = load i8*, i8** %serial, align 8, !tbaa !41
  %cmp14 = icmp eq i8* %6, null
  br i1 %cmp14, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.then13, %if.else11, %if.then7, %if.then
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %a, i32 0, i32 1
  %7 = load i16, i16* %mode, align 8, !tbaa !576
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.then13, %if.then7, %if.then
  %retval.0 = phi i16 [ %7, %if.end19 ], [ 0, %if.then ], [ 0, %if.then7 ], [ 0, %if.then13 ]
  ret i16 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_serial(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_lock.529(%struct.device* %dev2)
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %dev3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.531(%struct.device* %dev3)
  %conv = sext i32 %2 to i64
  ret i64 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock.529(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  ret void
}

declare i32 @sprintf(i8*, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock.531(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @show_product(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_lock.529(%struct.device* %dev2)
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %dev3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.531(%struct.device* %dev3)
  %conv = sext i32 %2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_manufacturer(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_lock.529(%struct.device* %dev2)
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %dev3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.531(%struct.device* %dev3)
  %conv = sext i32 %2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_ltm_capable(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  call void @usb_device_supports_ltm.535(%struct.usb_device* %1)
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv3 = sext i32 %2 to i64
  ret i64 %conv3
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_device_supports_ltm.535(%struct.usb_device* %udev) #1 {
entry:
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp ne i32 %0, 5
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %bos = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %1 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos, align 8, !tbaa !177
  %tobool = icmp ne %struct.usb_host_bos* %1, null
  br i1 %tobool, label %lor.lhs.false1, label %return

lor.lhs.false1:                                   ; preds = %lor.lhs.false
  %bos2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %2 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos2, align 8, !tbaa !177
  %ss_cap = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %2, i32 0, i32 2
  %3 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap, align 8, !tbaa !178
  %tobool3 = icmp ne %struct.usb_ss_cap_descriptor* %3, null
  br i1 %tobool3, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false1
  %bos4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 13
  %4 = load %struct.usb_host_bos*, %struct.usb_host_bos** %bos4, align 8, !tbaa !177
  %ss_cap5 = getelementptr inbounds %struct.usb_host_bos, %struct.usb_host_bos* %4, i32 0, i32 2
  %5 = load %struct.usb_ss_cap_descriptor*, %struct.usb_ss_cap_descriptor** %ss_cap5, align 8, !tbaa !178
  %bmAttributes = getelementptr inbounds %struct.usb_ss_cap_descriptor, %struct.usb_ss_cap_descriptor* %5, i32 0, i32 3
  %6 = load i8, i8* %bmAttributes, align 1, !tbaa !180
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 2
  %tobool6 = icmp ne i32 %and, 0
  br label %return

return:                                           ; preds = %if.end, %lor.lhs.false1, %lor.lhs.false, %entry
  %retval.0 = phi i1 [ %tobool6, %if.end ], [ false, %lor.lhs.false1 ], [ false, %lor.lhs.false ], [ false, %entry ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @show_removable(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %removable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 36
  %2 = load i32, i32* %removable, align 4, !tbaa !227
  %Pivot = icmp slt i32 %2, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %2, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %2, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock, %LeafBlock1
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @usb_remove_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_lock.529(%struct.device* %dev1)
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 3
  %2 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp ne i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @usb_set_configuration(%struct.usb_device* %1, i32 -1)
  %call2 = call i32 @usb_remove_device(%struct.usb_device* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rc.0 = phi i32 [ %call2, %if.then ], [ 0, %entry ]
  %cmp3 = icmp eq i32 %rc.0, 0
  %conv = trunc i64 %count to i32
  %conv.rc.0 = select i1 %cmp3, i32 %conv, i32 %rc.0
  %dev6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.531(%struct.device* %dev6)
  %conv7 = sext i32 %conv.rc.0 to i64
  ret i64 %conv7
}

; Function Attrs: nounwind uwtable
define internal i64 @usb_dev_authorized_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %authorized = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 22
  %bf.load = load i16, i16* %authorized, align 4
  %bf.lshr = lshr i16 %bf.load, 3
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6.543, i32 0, i32 0), i32 %bf.cast)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @usb_dev_authorized_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %size) #0 {
entry:
  %val = alloca i32, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %2 = bitcast i32* %val to i8*
  %call = call i32 (i8*, i8*, ...) @sscanf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6.543, i32 0, i32 0), i32* %val)
  %conv = sext i32 %call to i64
  %cmp = icmp ne i64 %conv, 1
  br i1 %cmp, label %if.end10, label %if.else

if.else:                                          ; preds = %entry
  %3 = load i32, i32* %val, align 4, !tbaa !90
  %cmp2 = icmp eq i32 %3, 0
  br i1 %cmp2, label %if.then4, label %if.else7

if.then4:                                         ; preds = %if.else
  %call5 = call i32 @usb_deauthorize_device(%struct.usb_device* %1)
  br label %if.end

if.else7:                                         ; preds = %if.else
  %call8 = call i32 @usb_authorize_device(%struct.usb_device* %1)
  br label %if.end

if.end:                                           ; preds = %if.else7, %if.then4
  %call8.sink = phi i32 [ %call8, %if.else7 ], [ %call5, %if.then4 ]
  %conv9 = sext i32 %call8.sink to i64
  br label %if.end10

if.end10:                                         ; preds = %if.end, %entry
  %result.1 = phi i64 [ %conv9, %if.end ], [ -22, %entry ]
  %cmp11 = icmp slt i64 %result.1, 0
  %result.1.size = select i1 %cmp11, i64 %result.1, i64 %size
  %4 = bitcast i32* %val to i8*
  ret i64 %result.1.size
}

; Function Attrs: nounwind uwtable
define internal i64 @show_avoid_reset_quirk(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @set_avoid_reset_quirk(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i32, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %2 = bitcast i32* %val to i8*
  %call = call i32 (i8*, i8*, ...) @sscanf(i8* %buf, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.7.545, i32 0, i32 0), i32* %val)
  %cmp = icmp ne i32 %call, 1
  %3 = load i32, i32* %val, align 4
  %cmp1 = icmp slt i32 %3, 0
  %or.cond = or i1 %cmp, %cmp1
  %4 = load i32, i32* %val, align 4
  %cmp3 = icmp sgt i32 %4, 1
  %or.cond1 = or i1 %or.cond, %cmp3
  br i1 %or.cond1, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_lock.529(%struct.device* %dev4)
  %5 = load i32, i32* %val, align 4, !tbaa !90
  %tobool = icmp ne i32 %5, 0
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 29
  %6 = load i32, i32* %quirks, align 4, !tbaa !259
  %and = and i32 %6, -17
  %or = or i32 %6, 16
  %and.sink = select i1 %tobool, i32 %or, i32 %and
  store i32 %and.sink, i32* %quirks, align 4, !tbaa !259
  %dev8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.531(%struct.device* %dev8)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %count, %if.end ], [ -22, %entry ]
  %7 = bitcast i32* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_quirks(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_maxchild(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_version(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv3 = sext i32 %0 to i64
  ret i64 %conv3
}

; Function Attrs: nounwind uwtable
define internal i64 @show_devpath(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_devnum(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_busnum(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_speed(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %speed1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 4
  %2 = load i32, i32* %speed1, align 4, !tbaa !153
  %Pivot10 = icmp slt i32 %2, 3
  br i1 %Pivot10, label %NodeBlock1, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %2, 4
  %Pivot6 = icmp slt i32 %2, 5
  %or.cond = or i1 %Pivot8, %Pivot6
  br i1 %or.cond, label %sw.epilog, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %2, 5
  br i1 %SwitchLeaf4, label %sw.epilog, label %sw.default

NodeBlock1:                                       ; preds = %entry
  %Pivot2 = icmp slt i32 %2, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %2, 2
  br i1 %Pivot, label %sw.epilog, label %sw.bb2

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %2, 0
  br i1 %SwitchLeaf, label %sw.bb2, label %sw.default

sw.bb2:                                           ; preds = %LeafBlock, %NodeBlock
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock3
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb2, %NodeBlock, %LeafBlock3, %NodeBlock7
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_bMaxPacketSize0(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_bNumConfigurations(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_bDeviceProtocol(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_bDeviceSubClass(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_bDeviceClass(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_bcdDevice(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_idProduct(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_idVendor(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_urbnum(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %urbnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 30
  call void @atomic_read.571(%union.anon.5* %urbnum)
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %2 to i64
  ret i64 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_read.571(%union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !90
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @show_bMaxPower(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %actconfig1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig1, align 8, !tbaa !64
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  call void @usb_get_max_power.573(%struct.usb_device* %1, %struct.usb_host_config* %2)
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %3 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_get_max_power.573(%struct.usb_device* %udev, %struct.usb_host_config* %c) #1 {
entry:
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp eq i32 %0, 5
  %cond = select i1 %cmp, i32 8, i32 2
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %c, i32 0, i32 0
  %bMaxPower = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 7
  %1 = load i8, i8* %bMaxPower, align 8, !tbaa !267
  %conv = zext i8 %1 to i32
  %mul1 = mul i32 %conv, %cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @show_bmAttributes(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %actconfig1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig1, align 8, !tbaa !64
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv2 = sext i32 %3 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.then, %entry
  %retval.0 = phi i64 [ %conv2, %if.then ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_bConfigurationValue(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %actconfig1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig1, align 8, !tbaa !64
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv2 = sext i32 %3 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.then, %entry
  %retval.0 = phi i64 [ %conv2, %if.then ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @set_bConfigurationValue(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %config = alloca i32, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %2 = bitcast i32* %config to i8*
  %call = call i32 (i8*, i8*, ...) @sscanf(i8* %buf, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.7.545, i32 0, i32 0), i32* %config)
  %cmp = icmp ne i32 %call, 1
  %3 = load i32, i32* %config, align 4
  %cmp1 = icmp slt i32 %3, -1
  %or.cond = or i1 %cmp, %cmp1
  %4 = load i32, i32* %config, align 4
  %cmp3 = icmp sgt i32 %4, 255
  %or.cond1 = or i1 %or.cond, %cmp3
  br i1 %or.cond1, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_lock.529(%struct.device* %dev4)
  %5 = load i32, i32* %config, align 4, !tbaa !90
  %call5 = call i32 @usb_set_configuration(%struct.usb_device* %1, i32 %5)
  %dev6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.531(%struct.device* %dev6)
  %cmp7 = icmp slt i32 %call5, 0
  %conv = sext i32 %call5 to i64
  %cond = select i1 %cmp7, i64 %conv, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ %cond, %if.end ]
  %6 = bitcast i32* %config to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_bNumInterfaces(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %actconfig1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig1, align 8, !tbaa !64
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv2 = sext i32 %3 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.then, %entry
  %retval.0 = phi i64 [ %conv2, %if.then ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_configuration_string(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %actconfig1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig1, align 8, !tbaa !64
  %tobool = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %string = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i32 0, i32 1
  %3 = load i8*, i8** %string, align 8, !tbaa !444
  %tobool2 = icmp ne i8* %3, null
  br i1 %tobool2, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %4 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %4 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %lor.lhs.false, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ 0, %lor.lhs.false ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @intf_assoc_attrs_are_visible(%struct.kobject* %kobj, %struct.attribute* %a, i32 %n) #0 {
entry:
  %0 = bitcast %struct.kobject* %kobj to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.device*
  %2 = bitcast %struct.device* %1 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 -48
  %3 = bitcast i8* %add.ptr3 to %struct.usb_interface*
  %intf_assoc = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %3, i32 0, i32 3
  %4 = load %struct.usb_interface_assoc_descriptor*, %struct.usb_interface_assoc_descriptor** %intf_assoc, align 8, !tbaa !439
  %cmp = icmp eq %struct.usb_interface_assoc_descriptor* %4, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %a, i32 0, i32 1
  %5 = load i16, i16* %mode, align 8, !tbaa !576
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i16 [ %5, %if.end ], [ 0, %entry ]
  ret i16 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_iad_bFunctionProtocol(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_iad_bFunctionSubClass(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_iad_bFunctionClass(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_iad_bInterfaceCount(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_iad_bFirstInterface(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_supports_autosuspend(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -48
  %1 = bitcast i8* %add.ptr to %struct.usb_interface*
  %call = call %struct.usb_device* @interface_to_usbdev.590(%struct.usb_interface* %1)
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 11
  call void @device_lock.529(%struct.device* %dev1)
  %dev2 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %1, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev2, i32 0, i32 7
  %2 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !104
  %tobool = icmp ne %struct.device_driver* %2, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %dev4 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %1, i32 0, i32 7
  %driver5 = getelementptr inbounds %struct.device, %struct.device* %dev4, i32 0, i32 7
  %3 = load %struct.device_driver*, %struct.device_driver** %driver5, align 8, !tbaa !104
  %4 = bitcast %struct.device_driver* %3 to i8*
  %add.ptr7 = getelementptr inbounds i8, i8* %4, i64 -168
  %5 = bitcast i8* %add.ptr7 to %struct.usb_driver*
  %supports_autosuspend = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %5, i32 0, i32 12
  %bf.load = load i8, i8* %supports_autosuspend, align 8
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool8 = icmp ne i32 %bf.cast, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %6 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %dev11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 11
  call void @device_unlock.531(%struct.device* %dev11)
  %conv = sext i32 %6 to i64
  ret i64 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_device* @interface_to_usbdev.590(%struct.usb_interface* %intf) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %parent, align 8, !tbaa !282
  %1 = bitcast %struct.device* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -136
  %2 = bitcast i8* %add.ptr to %struct.usb_device*
  ret %struct.usb_device* %2
}

; Function Attrs: nounwind uwtable
define internal i64 @show_modalias(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -48
  %1 = bitcast i8* %add.ptr to %struct.usb_interface*
  %call = call %struct.usb_device* @interface_to_usbdev.590(%struct.usb_interface* %1)
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv19 = sext i32 %2 to i64
  ret i64 %conv19
}

; Function Attrs: nounwind uwtable
define internal i64 @show_bInterfaceProtocol(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_bInterfaceSubClass(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_bInterfaceClass(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_bNumEndpoints(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_bAlternateSetting(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_bInterfaceNumber(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define i32 @usb_create_sysfs_dev_files(%struct.usb_device* %udev) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call = call i32 @device_create_bin_file(%struct.device* %dev1, %struct.bin_attribute* @dev_bin_attr_descriptors)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %error, label %if.end

if.end:                                           ; preds = %entry
  %call3 = call i32 @add_persist_attributes(%struct.device* %dev1)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %error, label %if.end6

if.end6:                                          ; preds = %if.end
  %call7 = call i32 @add_power_attributes(%struct.device* %dev1)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %error, label %cleanup

error:                                            ; preds = %if.end6, %if.end, %entry
  %retval2.0 = phi i32 [ %call, %entry ], [ %call3, %if.end ], [ %call7, %if.end6 ]
  call void @usb_remove_sysfs_dev_files(%struct.usb_device* %udev)
  br label %cleanup

cleanup:                                          ; preds = %error, %if.end6
  %retval.0 = phi i32 [ %retval2.0, %error ], [ %call7, %if.end6 ]
  ret i32 %retval.0
}

declare i32 @device_create_bin_file(%struct.device*, %struct.bin_attribute*) #2

; Function Attrs: nounwind uwtable
define internal i32 @add_persist_attributes(%struct.device* %dev) #0 {
entry:
  %call = call i32 @is_usb_device.612(%struct.device* %dev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 12
  %bDeviceClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 3
  %2 = load i8, i8* %bDeviceClass, align 4, !tbaa !241
  %conv = zext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 9
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.then
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call3 = call i32 @sysfs_add_file_to_group(%struct.kobject* %kobj, %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_persist, i32 0, i32 0), i8* getelementptr inbounds ([0 x i8], [0 x i8]* @power_group_name, i32 0, i32 0))
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.then, %entry
  %rc.1 = phi i32 [ 0, %entry ], [ %call3, %if.then2 ], [ 0, %if.then ]
  ret i32 %rc.1
}

; Function Attrs: nounwind uwtable
define internal i32 @add_power_attributes(%struct.device* %dev) #0 {
entry:
  %call = call i32 @is_usb_device.612(%struct.device* %dev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call1 = call i32 @sysfs_merge_group(%struct.kobject* %kobj, %struct.attribute_group* @power_attr_group)
  %usb2_hw_lpm_capable = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 22
  %bf.load = load i16, i16* %usb2_hw_lpm_capable, align 4
  %bf.lshr = lshr i16 %bf.load, 7
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 1
  br i1 %cmp, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.then
  %kobj3 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call4 = call i32 @sysfs_merge_group(%struct.kobject* %kobj3, %struct.attribute_group* @usb2_hardware_lpm_attr_group)
  br label %if.end5

if.end5:                                          ; preds = %if.then2, %if.then, %entry
  %rc.1 = phi i32 [ 0, %entry ], [ %call4, %if.then2 ], [ %call1, %if.then ]
  ret i32 %rc.1
}

; Function Attrs: nounwind uwtable
define void @usb_remove_sysfs_dev_files(%struct.usb_device* %udev) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  call void @remove_power_attributes(%struct.device* %dev1)
  call void @remove_persist_attributes(%struct.device* %dev1)
  call void @device_remove_bin_file(%struct.device* %dev1, %struct.bin_attribute* @dev_bin_attr_descriptors)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @remove_power_attributes(%struct.device* %dev) #0 {
entry:
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  call void @sysfs_unmerge_group(%struct.kobject* %kobj, %struct.attribute_group* @usb2_hardware_lpm_attr_group)
  %kobj1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  call void @sysfs_unmerge_group(%struct.kobject* %kobj1, %struct.attribute_group* @power_attr_group)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @remove_persist_attributes(%struct.device* %dev) #0 {
entry:
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  call void @sysfs_remove_file_from_group(%struct.kobject* %kobj, %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_persist, i32 0, i32 0), i8* getelementptr inbounds ([0 x i8], [0 x i8]* @power_group_name, i32 0, i32 0))
  ret void
}

declare void @device_remove_bin_file(%struct.device*, %struct.bin_attribute*) #2

declare void @sysfs_remove_file_from_group(%struct.kobject*, %struct.attribute*, i8*) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_persist(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @set_persist(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %value = alloca i32, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %2 = bitcast i32* %value to i8*
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 12
  %bDeviceClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 3
  %3 = load i8, i8* %bDeviceClass, align 4, !tbaa !241
  %conv = zext i8 %3 to i32
  %cmp = icmp eq i32 %conv, 9
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 (i8*, i8*, ...) @sscanf(i8* %buf, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.7.545, i32 0, i32 0), i32* %value)
  %cmp2 = icmp ne i32 %call, 1
  br i1 %cmp2, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %dev6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_lock.529(%struct.device* %dev6)
  %4 = load i32, i32* %value, align 4, !tbaa !90
  %tobool = icmp ne i32 %4, 0
  %lnot = xor i1 %tobool, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %persist_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 22
  %5 = trunc i32 %lnot.ext to i16
  %bf.load = load i16, i16* %persist_enabled, align 4
  %bf.value = and i16 %5, 1
  %bf.shl = shl i16 %bf.value, 1
  %bf.clear = and i16 %bf.load, -3
  %bf.set = or i16 %bf.clear, %bf.shl
  store i16 %bf.set, i16* %persist_enabled, align 4
  %dev8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.531(%struct.device* %dev8)
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %if.end, %entry
  %retval.0 = phi i64 [ %count, %if.end5 ], [ -1, %entry ], [ -22, %if.end ]
  %6 = bitcast i32* %value to i8*
  ret i64 %retval.0
}

declare void @sysfs_unmerge_group(%struct.kobject*, %struct.attribute_group*) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_active_duration(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 3
  %2 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp ne i32 %2, 8
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load volatile i64, i64* @jiffies, align 8, !tbaa !49
  %active_duration = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 31
  %4 = load i64, i64* %active_duration, align 8, !tbaa !92
  %add = add i64 %3, %4
  br label %if.end

if.else:                                          ; preds = %entry
  %active_duration1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 31
  %5 = load i64, i64* %active_duration1, align 8, !tbaa !92
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %.sink = phi i64 [ %5, %if.else ], [ %add, %if.then ]
  %call2 = call i32 @jiffies_to_msecs(i64 %.sink)
  %6 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %6 to i64
  ret i64 %conv
}

declare i32 @jiffies_to_msecs(i64) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_connected_duration(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %2 = load volatile i64, i64* @jiffies, align 8, !tbaa !49
  %connect_time = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 32
  %3 = load i64, i64* %connect_time, align 8, !tbaa !91
  %sub = sub i64 %2, %3
  %call = call i32 @jiffies_to_msecs(i64 %sub)
  %4 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %4 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_level(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  call void @warn_level()
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 3
  %2 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp ne i32 %2, 8
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @set_level(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %conv = trunc i64 %count to i32
  %conv1 = trunc i64 %count to i32
  call void @warn_level()
  %call = call i8* @memchr(i8* %buf, i32 10, i64 %count)
  %tobool = icmp ne i8* %call, null
  %sub.ptr.lhs.cast = ptrtoint i8* %call to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %buf to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv2 = trunc i64 %sub.ptr.sub to i32
  %len.0 = select i1 %tobool, i32 %conv2, i32 %conv
  %dev3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_lock.529(%struct.device* %dev3)
  %conv4 = sext i32 %len.0 to i64
  %cmp = icmp eq i64 %conv4, 2
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %conv6 = sext i32 %len.0 to i64
  %call7 = call i32 @strncmp(i8* %buf, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @on_string, i32 0, i32 0), i64 %conv6)
  %cmp8 = icmp eq i32 %call7, 0
  br i1 %cmp8, label %if.then10, label %if.else

if.then10:                                        ; preds = %land.lhs.true
  call void @usb_disable_autosuspend(%struct.usb_device* %1)
  br label %if.end22

if.else:                                          ; preds = %land.lhs.true, %entry
  %conv11 = sext i32 %len.0 to i64
  %cmp12 = icmp eq i64 %conv11, 4
  br i1 %cmp12, label %land.lhs.true14, label %if.end22

land.lhs.true14:                                  ; preds = %if.else
  %conv15 = sext i32 %len.0 to i64
  %call16 = call i32 @strncmp(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.108, i32 0, i32 0), i64 %conv15)
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then19, label %if.end22

if.then19:                                        ; preds = %land.lhs.true14
  call void @usb_enable_autosuspend(%struct.usb_device* %1)
  br label %if.end22

if.end22:                                         ; preds = %if.then19, %land.lhs.true14, %if.else, %if.then10
  %rc.1 = phi i32 [ %conv1, %if.then10 ], [ %conv1, %if.then19 ], [ -22, %land.lhs.true14 ], [ -22, %if.else ]
  %dev23 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.531(%struct.device* %dev23)
  %conv24 = sext i32 %rc.1 to i64
  ret i64 %conv24
}

; Function Attrs: nounwind uwtable
define internal void @warn_level() #0 {
entry:
  %0 = load i32, i32* @warn_level.level_warned, align 4, !tbaa !90
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, i32* @warn_level.level_warned, align 4, !tbaa !90
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare i8* @memchr(i8*, i32, i64) #2

declare i32 @strncmp(i8*, i8*, i64) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_autosuspend(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @set_autosuspend(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %value = alloca i32, align 4
  %0 = bitcast i32* %value to i8*
  %call = call i32 (i8*, i8*, ...) @sscanf(i8* %buf, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.7.545, i32 0, i32 0), i32* %value)
  %cmp = icmp ne i32 %call, 1
  %1 = load i32, i32* %value, align 4
  %cmp1 = icmp sge i32 %1, 2147483
  %or.cond = or i1 %cmp, %cmp1
  %2 = load i32, i32* %value, align 4
  %cmp3 = icmp sle i32 %2, -2147483
  %or.cond1 = or i1 %or.cond, %cmp3
  br i1 %or.cond1, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %value, align 4, !tbaa !90
  %mul = mul nsw i32 %3, 1000
  call void @pm_runtime_set_autosuspend_delay(%struct.device* %dev, i32 %mul)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %count, %if.end ], [ -22, %entry ]
  %4 = bitcast i32* %value to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_usb2_hardware_lpm(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @set_usb2_hardware_lpm(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %value = alloca i8, align 1
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.usb_device*
  %dev1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_lock.529(%struct.device* %dev1)
  %call = call i32 @strtobool(i8* %buf, i8* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i8, i8* %value, align 1, !tbaa !43, !range !44
  %tobool2 = trunc i8 %2 to i1
  %conv = zext i1 %tobool2 to i32
  %call3 = call i32 @usb_set_usb2_hardware_lpm(%struct.usb_device* %1, i32 %conv)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %ret.0 = phi i32 [ %call, %entry ], [ %call3, %if.then ]
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  call void @device_unlock.531(%struct.device* %dev4)
  %tobool5 = icmp ne i32 %ret.0, 0
  %conv8 = sext i32 %ret.0 to i64
  %retval.0 = select i1 %tobool5, i64 %conv8, i64 %count
  ret i64 %retval.0
}

declare i32 @strtobool(i8*, i8*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_usb_device.612(%struct.device* %dev) #1 {
entry:
  %type = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 4
  %0 = load %struct.device_type*, %struct.device_type** %type, align 8, !tbaa !58
  %cmp = icmp eq %struct.device_type* %0, @usb_device_type
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare i32 @sysfs_merge_group(%struct.kobject*, %struct.attribute_group*) #2

declare i32 @sysfs_add_file_to_group(%struct.kobject*, %struct.attribute*, i8*) #2

; Function Attrs: nounwind uwtable
define internal i64 @read_descriptors(%struct.file* %filp, %struct.kobject* %kobj, %struct.bin_attribute* %attr, i8* %buf, i64 %off, i64 %count) #0 {
entry:
  %_min1 = alloca i64, align 8
  %_min2 = alloca i64, align 8
  %0 = bitcast %struct.kobject* %kobj to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.device*
  %2 = bitcast %struct.device* %1 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 -136
  %3 = bitcast i8* %add.ptr3 to %struct.usb_device*
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %nleft.0 = phi i64 [ %count, %entry ], [ %nleft.1, %for.inc ]
  %off.addr.0 = phi i64 [ %off, %entry ], [ %off.addr.1, %for.inc ]
  %buf.addr.0 = phi i8* [ %buf, %entry ], [ %buf.addr.1, %for.inc ]
  %cfgno.0 = phi i32 [ -1, %entry ], [ %inc, %for.inc ]
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 13
  %4 = load i8, i8* %bNumConfigurations, align 1, !tbaa !166
  %conv = zext i8 %4 to i32
  %cmp = icmp slt i32 %cfgno.0, %conv
  %cmp5 = icmp ugt i64 %nleft.0, 0
  %cmp5. = select i1 %cmp, i1 %cmp5, i1 false
  br i1 %cmp5., label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %cmp7 = icmp slt i32 %cfgno.0, 0
  br i1 %cmp7, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %descriptor9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 12
  %5 = bitcast %struct.usb_device_descriptor* %descriptor9 to i8*
  br label %if.end

if.else:                                          ; preds = %for.body
  %rawdescriptors = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 18
  %6 = load i8**, i8*** %rawdescriptors, align 8, !tbaa !169
  %idxprom = sext i32 %cfgno.0 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %6, i64 %idxprom
  %7 = load i8*, i8** %arrayidx, align 8, !tbaa !48
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 14
  %8 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !167
  %idxprom10 = sext i32 %cfgno.0 to i64
  %arrayidx11 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %8, i64 %idxprom10
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx11, i32 0, i32 0
  %wTotalLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 2
  %9 = load i16, i16* %wTotalLength, align 2, !tbaa !168
  %conv12 = zext i16 %9 to i64
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %srclen.0 = phi i64 [ 18, %if.then ], [ %conv12, %if.else ]
  %src.0 = phi i8* [ %5, %if.then ], [ %7, %if.else ]
  %cmp13 = icmp ult i64 %off.addr.0, %srclen.0
  br i1 %cmp13, label %if.then15, label %if.else25

if.then15:                                        ; preds = %if.end
  %10 = bitcast i64* %_min1 to i8*
  store i64 %nleft.0, i64* %_min1, align 8, !tbaa !49
  %11 = bitcast i64* %_min2 to i8*
  %sub = sub i64 %srclen.0, %off.addr.0
  store i64 %sub, i64* %_min2, align 8, !tbaa !49
  %12 = load i64, i64* %_min1, align 8, !tbaa !49
  %13 = load i64, i64* %_min2, align 8, !tbaa !49
  %cmp19 = icmp ult i64 %12, %13
  %14 = load i64, i64* %_min1, align 8
  %15 = load i64, i64* %_min2, align 8
  %cond = select i1 %cmp19, i64 %14, i64 %15
  %16 = bitcast i64* %_min2 to i8*
  %17 = bitcast i64* %_min1 to i8*
  %add.ptr21 = getelementptr i8, i8* %src.0, i64 %off.addr.0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %buf.addr.0, i8* %add.ptr21, i64 %cond, i32 1, i1 false)
  %sub23 = sub i64 %nleft.0, %cond
  %add.ptr24 = getelementptr inbounds i8, i8* %buf.addr.0, i64 %cond
  br label %for.inc

if.else25:                                        ; preds = %if.end
  %sub26 = sub i64 %off.addr.0, %srclen.0
  br label %for.inc

for.inc:                                          ; preds = %if.else25, %if.then15
  %nleft.1 = phi i64 [ %sub23, %if.then15 ], [ %nleft.0, %if.else25 ]
  %off.addr.1 = phi i64 [ 0, %if.then15 ], [ %sub26, %if.else25 ]
  %buf.addr.1 = phi i8* [ %add.ptr24, %if.then15 ], [ %buf.addr.0, %if.else25 ]
  %inc = add nsw i32 %cfgno.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %sub28 = sub i64 %count, %nleft.0
  ret i64 %sub28
}

; Function Attrs: nounwind uwtable
define void @usb_create_sysfs_intf_files(%struct.usb_interface* %intf) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev.590(%struct.usb_interface* %intf)
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %0 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !148
  %sysfs_files_created = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load = load i8, i8* %sysfs_files_created, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %cleanup.cont, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %unregistering = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load1 = load i8, i8* %unregistering, align 8
  %bf.lshr = lshr i8 %bf.load1, 2
  %bf.clear2 = and i8 %bf.lshr, 1
  %bf.cast3 = zext i8 %bf.clear2 to i32
  %tobool4 = icmp ne i32 %bf.cast3, 0
  br i1 %tobool4, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %string = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 4
  %1 = load i8*, i8** %string, align 8, !tbaa !513
  %tobool5 = icmp ne i8* %1, null
  br i1 %tobool5, label %if.end10, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 29
  %2 = load i32, i32* %quirks, align 4, !tbaa !259
  %and = and i32 %2, 8
  %tobool6 = icmp ne i32 %and, 0
  br i1 %tobool6, label %if.end10, label %if.then7

if.then7:                                         ; preds = %land.lhs.true
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 0
  %iInterface = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 8
  %3 = load i8, i8* %iInterface, align 8, !tbaa !579
  %conv = zext i8 %3 to i32
  %call8 = call i8* @usb_cache_string(%struct.usb_device* %call, i32 %conv)
  %string9 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 4
  store i8* %call8, i8** %string9, align 8, !tbaa !513
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %land.lhs.true, %if.end
  %string11 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i32 0, i32 4
  %4 = load i8*, i8** %string11, align 8, !tbaa !513
  %tobool12 = icmp ne i8* %4, null
  br i1 %tobool12, label %land.lhs.true13, label %if.end17

land.lhs.true13:                                  ; preds = %if.end10
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call14 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* @dev_attr_interface)
  br label %if.end17

if.end17:                                         ; preds = %land.lhs.true13, %if.end10
  %sysfs_files_created18 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load19 = load i8, i8* %sysfs_files_created18, align 8
  %bf.clear20 = and i8 %bf.load19, -2
  %bf.set = or i8 %bf.clear20, 1
  store i8 %bf.set, i8* %sysfs_files_created18, align 8
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end17, %lor.lhs.false, %entry
  ret void
}

declare i32 @device_create_file(%struct.device*, %struct.device_attribute*) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_interface_string(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -48
  %1 = bitcast i8* %add.ptr to %struct.usb_interface*
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %1, i32 0, i32 1
  %2 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !148
  %string1 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 4
  %3 = load i8*, i8** %string1, align 8, !tbaa !513
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !580
  %tobool = icmp ne i8* %3, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %4 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %4 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define void @usb_remove_sysfs_intf_files(%struct.usb_interface* %intf) #0 {
entry:
  %sysfs_files_created = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load = load i8, i8* %sysfs_files_created, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* @dev_attr_interface)
  %sysfs_files_created1 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 6
  %bf.load2 = load i8, i8* %sysfs_files_created1, align 8
  %bf.clear3 = and i8 %bf.load2, -2
  store i8 %bf.clear3, i8* %sysfs_files_created1, align 8
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare void @device_remove_file(%struct.device*, %struct.device_attribute*) #2

; Function Attrs: nounwind uwtable
define internal void @ep_device_release(%struct.device.2626* %dev) #0 {
entry:
  %0 = bitcast %struct.device.2626* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.ep_device*
  %2 = bitcast %struct.ep_device* %1 to i8*
  call void @kfree(i8* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_create_ep_devs(%struct.device.2626* %parent, %struct.usb_host_endpoint* %endpoint, %struct.usb_device.2852* %udev) #0 {
entry:
  %call = call i8* @kzalloc.622(i64 1152, i32 208)
  %0 = bitcast i8* %call to %struct.ep_device*
  %tobool = icmp ne %struct.ep_device* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %endpoint, i32 0, i32 0
  %desc2 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 0
  store %struct.usb_endpoint_descriptor* %desc, %struct.usb_endpoint_descriptor** %desc2, align 8, !tbaa !581
  %udev3 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 1
  store %struct.usb_device.2852* %udev, %struct.usb_device.2852** %udev3, align 8, !tbaa !583
  %dev = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 2
  %groups = getelementptr inbounds %struct.device.2626, %struct.device.2626* %dev, i32 0, i32 26
  store %struct.attribute_group** getelementptr inbounds ([2 x %struct.attribute_group*], [2 x %struct.attribute_group*]* @ep_dev_groups, i32 0, i32 0), %struct.attribute_group*** %groups, align 8, !tbaa !584
  %dev4 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 2
  %type = getelementptr inbounds %struct.device.2626, %struct.device.2626* %dev4, i32 0, i32 4
  store %struct.device_type.2628* bitcast ({ i8*, %struct.attribute_group**, i32 (%struct.device.2626*, %struct.kobj_uevent_env*)*, i8* (%struct.device.2626*, i16*, i32*, i32*)*, void (%struct.device.2626*)*, %struct.dev_pm_ops.2640* }* @usb_ep_device_type to %struct.device_type.2628*), %struct.device_type.2628** %type, align 8, !tbaa !585
  %dev5 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 2
  %parent6 = getelementptr inbounds %struct.device.2626, %struct.device.2626* %dev5, i32 0, i32 0
  store %struct.device.2626* %parent, %struct.device.2626** %parent6, align 8, !tbaa !586
  %dev7 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 2
  %desc8 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %endpoint, i32 0, i32 0
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc8, i32 0, i32 2
  %1 = load i8, i8* %bEndpointAddress, align 2, !tbaa !449
  %conv = zext i8 %1 to i32
  %call9 = call i32 (%struct.device.2626*, i8*, ...) bitcast (i32 (%struct.device*, i8*, ...)* @dev_set_name to i32 (%struct.device.2626*, i8*, ...)*)(%struct.device.2626* %dev7, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1.623, i32 0, i32 0), i32 %conv)
  %dev10 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 2
  %call11 = call i32 @device_register(%struct.device.2626* %dev10)
  %tobool12 = icmp ne i32 %call11, 0
  %dev17 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 2
  br i1 %tobool12, label %error_register, label %if.end14

if.end14:                                         ; preds = %if.end
  call void @device_enable_async_suspend.624(%struct.device.2626* %dev17)
  %ep_dev16 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %endpoint, i32 0, i32 5
  store %struct.ep_device* %0, %struct.ep_device** %ep_dev16, align 8, !tbaa !587
  br label %cleanup

error_register:                                   ; preds = %if.end
  call void bitcast (void (%struct.device*)* @put_device to void (%struct.device.2626*)*)(%struct.device.2626* %dev17)
  br label %cleanup

cleanup:                                          ; preds = %error_register, %if.end14, %entry
  %retval.0 = phi i32 [ %call11, %if.end14 ], [ %call11, %error_register ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.622(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

declare i32 @device_register(%struct.device.2626*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_enable_async_suspend.624(%struct.device.2626* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device.2626, %struct.device.2626* %dev, i32 0, i32 9
  %is_prepared = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i8, i8* %is_prepared, align 4
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %power1 = getelementptr inbounds %struct.device.2626, %struct.device.2626* %dev, i32 0, i32 9
  %async_suspend = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power1, i32 0, i32 1
  %bf.load2 = load i8, i8* %async_suspend, align 4
  %bf.clear3 = and i8 %bf.load2, -3
  %bf.set = or i8 %bf.clear3, 2
  store i8 %bf.set, i8* %async_suspend, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @show_ep_direction(%struct.device.2626* %dev, %struct.device_attribute.2824* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device.2626* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.ep_device*
  %desc = getelementptr inbounds %struct.ep_device, %struct.ep_device* %1, i32 0, i32 0
  %2 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %desc, align 8, !tbaa !581
  %call = call i32 @usb_endpoint_xfer_control.627(%struct.usb_endpoint_descriptor* %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end6, label %if.else

if.else:                                          ; preds = %entry
  %desc1 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %1, i32 0, i32 0
  %3 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %desc1, align 8, !tbaa !581
  call void @usb_endpoint_dir_in.628(%struct.usb_endpoint_descriptor* %3)
  br label %if.end6

if.end6:                                          ; preds = %if.else, %entry
  %4 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %4 to i64
  ret i64 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_control.627(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_endpoint_dir_in.628(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !286
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 128
  %cmp = icmp eq i32 %and, 128
  %conv1 = zext i1 %cmp to i32
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @show_ep_type(%struct.device.2626* %dev, %struct.device_attribute.2824* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device.2626* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.ep_device*
  %desc = getelementptr inbounds %struct.ep_device, %struct.ep_device* %1, i32 0, i32 0
  %2 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %desc, align 8, !tbaa !581
  %call = call i32 @usb_endpoint_type.634(%struct.usb_endpoint_descriptor* %2)
  %Pivot6 = icmp slt i32 %call, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %call, 3
  br i1 %Pivot4, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %call, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %NewDefault

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %call, 1
  br i1 %Pivot, label %LeafBlock, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %call, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %NewDefault

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %LeafBlock, %NodeBlock, %LeafBlock1, %NodeBlock3
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %3 to i64
  ret i64 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_type.634(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal i64 @show_ep_interval(%struct.device.2626* %dev, %struct.device_attribute.2824* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device.2626* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.ep_device*
  %desc = getelementptr inbounds %struct.ep_device, %struct.ep_device* %1, i32 0, i32 0
  %2 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %desc, align 8, !tbaa !581
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %2, i32 0, i32 2
  %3 = load i8, i8* %bEndpointAddress, align 1, !tbaa !286
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 128
  %desc1 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %1, i32 0, i32 0
  %4 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %desc1, align 8, !tbaa !581
  %call = call i32 @usb_endpoint_type.634(%struct.usb_endpoint_descriptor* %4)
  %Pivot6 = icmp slt i32 %call, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %call, 3
  br i1 %Pivot4, label %sw.bb9, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %call, 3
  br i1 %SwitchLeaf2, label %sw.bb19, label %sw.epilog

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %call, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb5

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %call, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %udev = getelementptr inbounds %struct.ep_device, %struct.ep_device* %1, i32 0, i32 1
  %5 = load %struct.usb_device.2852*, %struct.usb_device.2852** %udev, align 8, !tbaa !583
  %speed = getelementptr inbounds %struct.usb_device.2852, %struct.usb_device.2852* %5, i32 0, i32 4
  %6 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp eq i32 %6, 3
  br i1 %cmp, label %if.then, label %sw.epilog

if.then:                                          ; preds = %sw.bb
  br label %sw.epilog

sw.bb5:                                           ; preds = %NodeBlock
  br label %sw.epilog

sw.bb9:                                           ; preds = %NodeBlock3
  %udev10 = getelementptr inbounds %struct.ep_device, %struct.ep_device* %1, i32 0, i32 1
  %7 = load %struct.usb_device.2852*, %struct.usb_device.2852** %udev10, align 8, !tbaa !583
  %speed11 = getelementptr inbounds %struct.usb_device.2852, %struct.usb_device.2852* %7, i32 0, i32 4
  %8 = load i32, i32* %speed11, align 4, !tbaa !153
  %cmp12 = icmp ne i32 %8, 3
  %tobool = icmp ne i32 %and, 0
  %or.cond = or i1 %cmp12, %tobool
  br i1 %or.cond, label %sw.epilog, label %if.then14

if.then14:                                        ; preds = %sw.bb9
  br label %sw.epilog

sw.bb19:                                          ; preds = %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb19, %if.then14, %sw.bb9, %sw.bb5, %if.then, %sw.bb, %LeafBlock, %LeafBlock1
  %9 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv44 = sext i32 %9 to i64
  ret i64 %conv44
}

; Function Attrs: nounwind uwtable
define internal i64 @show_ep_wMaxPacketSize(%struct.device.2626* %dev, %struct.device_attribute.2824* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device.2626* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.ep_device*
  %desc = getelementptr inbounds %struct.ep_device, %struct.ep_device* %1, i32 0, i32 0
  %2 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %desc, align 8, !tbaa !581
  call void @usb_endpoint_maxp.643(%struct.usb_endpoint_descriptor* %2)
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %3 to i64
  ret i64 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_endpoint_maxp.643(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 4
  %0 = load i16, i16* %wMaxPacketSize, align 1, !tbaa !199
  %conv = zext i16 %0 to i32
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @show_ep_bInterval(%struct.device.2626* %dev, %struct.device_attribute.2824* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_ep_bmAttributes(%struct.device.2626* %dev, %struct.device_attribute.2824* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_ep_bEndpointAddress(%struct.device.2626* %dev, %struct.device_attribute.2824* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_ep_bLength(%struct.device.2626* %dev, %struct.device_attribute.2824* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define void @usb_remove_ep_devs(%struct.usb_host_endpoint* %endpoint) #0 {
entry:
  %ep_dev1 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %endpoint, i32 0, i32 5
  %0 = load %struct.ep_device*, %struct.ep_device** %ep_dev1, align 8, !tbaa !587
  %tobool = icmp ne %struct.ep_device* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.ep_device, %struct.ep_device* %0, i32 0, i32 2
  call void @device_unregister(%struct.device.2626* %dev)
  %ep_dev2 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %endpoint, i32 0, i32 5
  store %struct.ep_device* null, %struct.ep_device** %ep_dev2, align 8, !tbaa !587
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @device_unregister(%struct.device.2626*) #2

; Function Attrs: nounwind uwtable
define internal i32 @driver_probe(%struct.usb_interface* %intf, %struct.usb_device_id* %id) #0 {
entry:
  ret i32 -19
}

; Function Attrs: nounwind uwtable
define internal void @driver_disconnect(%struct.usb_interface* %intf) #0 {
entry:
  %call = call i8* @usb_get_intfdata.658(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.dev_state*
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 0
  %1 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !60
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %2 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !68
  %conv = zext i8 %2 to i32
  %tobool = icmp ne %struct.dev_state* %0, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %conv1 = zext i32 %conv to i64
  %cmp = icmp ult i64 %conv1, 64
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 1)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %ifclaimed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %ifclaimed, i32 %conv, i64* %ifclaimed) #8, !srcloc !588
  br label %if.end8

if.else:                                          ; preds = %if.end
  %3 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then6
  call void @usb_set_intfdata.661(%struct.usb_interface* %intf, i8* null)
  call void @destroy_async_on_interface(%struct.dev_state* %0, i32 %conv)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end8, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @driver_suspend(%struct.usb_interface* %intf, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @driver_resume(%struct.usb_interface* %intf) #0 {
entry:
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @usb_get_intfdata.658(%struct.usb_interface* %intf) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_set_intfdata.661(%struct.usb_interface* %intf, i8* %data) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i32 @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @destroy_async_on_interface(%struct.dev_state* %ps, i32 %ifnum) #0 {
entry:
  %hitlist = alloca %struct.list_head, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast %struct.list_head* %hitlist to i8*
  call void @INIT_LIST_HEAD.662(%struct.list_head* %hitlist)
  %1 = bitcast i64* %__dummy to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy2 to i8*
  %4 = bitcast i64* %__dummy to i8*
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check.663(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %async_pending, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !95
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %.sink = phi %struct.list_head* [ %6, %for.inc ], [ %5, %entry ]
  %p.0 = phi %struct.list_head* [ %5, %entry ], [ %6, %for.inc ]
  %next13 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next13, align 8, !tbaa !95
  %async_pending6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  %cmp7 = icmp ne %struct.list_head* %p.0, %async_pending6
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = bitcast %struct.list_head* %p.0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 0
  %8 = bitcast i8* %add.ptr to %struct.async*
  %ifnum10 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 5
  %9 = load i32, i32* %ifnum10, align 4, !tbaa !589
  %cmp11 = icmp eq i32 %ifnum, %9
  br i1 %cmp11, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @list_move_tail(%struct.list_head* %p.0, %struct.list_head* %hitlist)
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %lock14 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore.664(%struct.spinlock* %lock14, i64 %call2)
  call void @destroy_async(%struct.dev_state* %ps, %struct.list_head* %hitlist)
  %10 = bitcast %struct.list_head* %hitlist to i8*
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.662(%struct.list_head* %list) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !95
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !96
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check.663(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_move_tail(%struct.list_head* %list, %struct.list_head* %head) #1 {
entry:
  call void @__list_del_entry(%struct.list_head* %list)
  call void @list_add_tail.667(%struct.list_head* %list, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore.664(%struct.spinlock* %lock, i64 %flags) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @destroy_async(%struct.dev_state* %ps, %struct.list_head* %list) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy12 = alloca i64, align 8
  %__dummy213 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %lock17 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  %call18 = call %struct.raw_spinlock* @spinlock_check.663(%struct.spinlock* %lock17)
  %call19 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call18)
  %call5 = call i32 @list_empty.665(%struct.list_head* %list)
  %tobool = icmp ne i32 %call5, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !95
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 0
  %6 = bitcast i8* %add.ptr to %struct.async*
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %6, i32 0, i32 0
  call void @list_del_init.666(%struct.list_head* %asynclist)
  %urb7 = getelementptr inbounds %struct.async, %struct.async* %6, i32 0, i32 8
  %7 = load %struct.urb*, %struct.urb** %urb7, align 8, !tbaa !591
  %call8 = call %struct.urb* bitcast (%struct.urb.824* (%struct.urb.824*)* @usb_get_urb to %struct.urb* (%struct.urb*)*)(%struct.urb* %7)
  %lock9 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore.664(%struct.spinlock* %lock9, i64 %call19)
  call void bitcast (void (%struct.urb.824*)* @usb_kill_urb to void (%struct.urb*)*)(%struct.urb* %7)
  call void bitcast (void (%struct.urb.824*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %7)
  %8 = bitcast i64* %__dummy12 to i8*
  %9 = bitcast i64* %__dummy213 to i8*
  %10 = bitcast i64* %__dummy213 to i8*
  %11 = bitcast i64* %__dummy12 to i8*
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %lock24 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore.664(%struct.spinlock* %lock24, i64 %call19)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty.665(%struct.list_head* %head) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !95
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init.666(%struct.list_head* %entry1) #1 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD.662(%struct.list_head* %entry1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.667(%struct.list_head* %new, %struct.list_head* %head) #1 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !96
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_lseek(%struct.file* %file, i64 %offset, i32 %orig) #0 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %file)
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 0)
  %Pivot4 = icmp slt i32 %orig, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %orig, 2
  br i1 %Pivot, label %sw.bb2, label %sw.epilog

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %orig, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %f_pos = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  store i64 %offset, i64* %f_pos, align 8, !tbaa !592
  %f_pos1 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  %0 = load i64, i64* %f_pos1, align 8, !tbaa !592
  br label %sw.epilog

sw.bb2:                                           ; preds = %NodeBlock
  %f_pos3 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  %1 = load i64, i64* %f_pos3, align 8, !tbaa !592
  %add = add nsw i64 %1, %offset
  store i64 %add, i64* %f_pos3, align 8, !tbaa !592
  %f_pos4 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  %2 = load i64, i64* %f_pos4, align 8, !tbaa !592
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb2, %sw.bb, %LeafBlock, %NodeBlock
  %ret.0 = phi i64 [ %0, %sw.bb ], [ %2, %sw.bb2 ], [ -22, %LeafBlock ], [ -22, %NodeBlock ]
  %call6 = call %struct.inode* @file_inode(%struct.file* %file)
  %i_mutex7 = getelementptr inbounds %struct.inode, %struct.inode* %call6, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex7)
  ret i64 %ret.0
}

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_read(%struct.file* %file, i8* %buf, i64 %nbytes, i64* %ppos) #0 {
entry:
  %temp_desc = alloca %struct.usb_device_descriptor, align 1
  %_min1 = alloca i32, align 4
  %_min2 = alloca i32, align 4
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !593
  %1 = bitcast i8* %0 to %struct.dev_state*
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !594
  %3 = load i64, i64* %ppos, align 8, !tbaa !339
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock.668(%struct.device* %dev2)
  %call = call i32 @connected(%struct.dev_state* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %err

if.else:                                          ; preds = %entry
  %cmp = icmp slt i64 %3, 0
  br i1 %cmp, label %err, label %if.end4

if.end4:                                          ; preds = %if.else
  %cmp5 = icmp ult i64 %3, 18
  br i1 %cmp5, label %if.then6, label %if.end38

if.then6:                                         ; preds = %if.end4
  %4 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  %cmp7 = icmp uge i64 18, 64
  %5 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 12
  %6 = bitcast %struct.usb_device_descriptor* %descriptor to i8*
  br i1 %cmp7, label %if.then8, label %if.else10

if.then8:                                         ; preds = %if.then6
  %call9 = call i8* @__memcpy(i8* %5, i8* %6, i64 18)
  br label %do.body

if.else10:                                        ; preds = %if.then6
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 18, i32 1, i1 false)
  br label %do.body

do.body:                                          ; preds = %if.else10, %if.then8
  %sub = sub i64 18, %3
  %conv = trunc i64 %sub to i32
  %conv22 = zext i32 %conv to i64
  %cmp23 = icmp ugt i64 %conv22, %nbytes
  %conv26 = trunc i64 %nbytes to i32
  %len.0 = select i1 %cmp23, i32 %conv26, i32 %conv
  %7 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 %3
  call void @might_fault() #8
  %call.i1 = call i64 @_copy_to_user(i8* %buf, i8* %add.ptr, i32 %len.0) #8
  %conv.i2 = trunc i64 %call.i1 to i32
  %tobool29 = icmp ne i32 %conv.i2, 0
  br i1 %tobool29, label %cleanup, label %if.end31

if.end31:                                         ; preds = %do.body
  %conv32 = zext i32 %len.0 to i64
  %8 = load i64, i64* %ppos, align 8, !tbaa !339
  %add = add nsw i64 %8, %conv32
  store i64 %add, i64* %ppos, align 8, !tbaa !339
  %idx.ext = zext i32 %len.0 to i64
  %add.ptr33 = getelementptr inbounds i8, i8* %buf, i64 %idx.ext
  %conv34 = zext i32 %len.0 to i64
  %sub35 = sub i64 %nbytes, %conv34
  %conv36 = zext i32 %len.0 to i64
  %add37 = add nsw i64 0, %conv36
  br label %cleanup

cleanup:                                          ; preds = %if.end31, %do.body
  %ret.0 = phi i64 [ %add37, %if.end31 ], [ -14, %do.body ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end31 ], [ 2, %do.body ]
  %nbytes.addr.0 = phi i64 [ %sub35, %if.end31 ], [ %nbytes, %do.body ]
  %buf.addr.0 = phi i8* [ %add.ptr33, %if.end31 ], [ %buf, %do.body ]
  %9 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %cleanup
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf2, label %err, label %cleanup108

LeafBlock:                                        ; preds = %cleanup
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end38, label %cleanup108

if.end38:                                         ; preds = %LeafBlock, %if.end4
  %ret.1 = phi i64 [ 0, %if.end4 ], [ %ret.0, %LeafBlock ]
  %nbytes.addr.1 = phi i64 [ %nbytes, %if.end4 ], [ %nbytes.addr.0, %LeafBlock ]
  %buf.addr.1 = phi i8* [ %buf, %if.end4 ], [ %buf.addr.0, %LeafBlock ]
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end38
  %pos.0 = phi i64 [ 18, %if.end38 ], [ %pos.1, %for.inc ]
  %ret.2 = phi i64 [ %ret.1, %if.end38 ], [ %ret.5, %for.inc ]
  %i.0 = phi i32 [ 0, %if.end38 ], [ %inc, %for.inc ]
  %nbytes.addr.2 = phi i64 [ %nbytes.addr.1, %if.end38 ], [ %nbytes.addr.5, %for.inc ]
  %buf.addr.2 = phi i8* [ %buf.addr.1, %if.end38 ], [ %buf.addr.5, %for.inc ]
  %tobool39 = icmp ne i64 %nbytes.addr.2, 0
  br i1 %tobool39, label %land.rhs, label %err

land.rhs:                                         ; preds = %for.cond
  %descriptor40 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor40, i32 0, i32 13
  %10 = load i8, i8* %bNumConfigurations, align 1, !tbaa !166
  %conv41 = zext i8 %10 to i32
  %cmp42 = icmp slt i32 %i.0, %conv41
  br i1 %cmp42, label %for.body, label %err

for.body:                                         ; preds = %land.rhs
  %rawdescriptors = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 18
  %11 = load i8**, i8*** %rawdescriptors, align 8, !tbaa !169
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %11, i64 %idxprom
  %12 = load i8*, i8** %arrayidx, align 8, !tbaa !48
  %13 = bitcast i8* %12 to %struct.usb_config_descriptor*
  %wTotalLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %13, i32 0, i32 2
  %14 = load i16, i16* %wTotalLength, align 1, !tbaa !515
  %conv44 = zext i16 %14 to i32
  %15 = load i64, i64* %ppos, align 8, !tbaa !339
  %conv45 = zext i32 %conv44 to i64
  %add46 = add nsw i64 %pos.0, %conv45
  %cmp47 = icmp slt i64 %15, %add46
  br i1 %cmp47, label %if.then49, label %if.end100

if.then49:                                        ; preds = %for.body
  %config50 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 14
  %16 = load %struct.usb_host_config*, %struct.usb_host_config** %config50, align 8, !tbaa !167
  %idxprom51 = sext i32 %i.0 to i64
  %arrayidx52 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %16, i64 %idxprom51
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx52, i32 0, i32 0
  %wTotalLength53 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 2
  %17 = load i16, i16* %wTotalLength53, align 2, !tbaa !168
  %conv54 = zext i16 %17 to i32
  %conv55 = zext i32 %conv44 to i64
  %18 = load i64, i64* %ppos, align 8, !tbaa !339
  %sub56 = sub nsw i64 %18, %pos.0
  %sub57 = sub nsw i64 %conv55, %sub56
  %conv58 = trunc i64 %sub57 to i32
  %conv59 = zext i32 %conv58 to i64
  %cmp60 = icmp ugt i64 %conv59, %nbytes.addr.2
  %conv63 = trunc i64 %nbytes.addr.2 to i32
  %conv63.conv58 = select i1 %cmp60, i32 %conv63, i32 %conv58
  %conv65 = zext i32 %conv54 to i64
  %19 = load i64, i64* %ppos, align 8, !tbaa !339
  %sub66 = sub nsw i64 %19, %pos.0
  %cmp67 = icmp sgt i64 %conv65, %sub66
  br i1 %cmp67, label %if.then69, label %if.end88

if.then69:                                        ; preds = %if.then49
  %20 = load i64, i64* %ppos, align 8, !tbaa !339
  %sub70 = sub nsw i64 %20, %pos.0
  %conv71 = zext i32 %conv54 to i64
  %sub72 = sub nsw i64 %conv71, %sub70
  %conv73 = trunc i64 %sub72 to i32
  %rawdescriptors74 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 18
  %21 = load i8**, i8*** %rawdescriptors74, align 8, !tbaa !169
  %idxprom75 = sext i32 %i.0 to i64
  %arrayidx76 = getelementptr inbounds i8*, i8** %21, i64 %idxprom75
  %22 = load i8*, i8** %arrayidx76, align 8, !tbaa !48
  %23 = load i64, i64* %ppos, align 8, !tbaa !339
  %sub77 = sub nsw i64 %23, %pos.0
  %add.ptr78 = getelementptr inbounds i8, i8* %22, i64 %sub77
  %24 = bitcast i32* %_min1 to i8*
  store i32 %conv63.conv58, i32* %_min1, align 4, !tbaa !90
  %25 = bitcast i32* %_min2 to i8*
  store i32 %conv73, i32* %_min2, align 4, !tbaa !90
  %26 = load i32, i32* %_min1, align 4, !tbaa !90
  %27 = load i32, i32* %_min2, align 4, !tbaa !90
  %cmp82 = icmp ult i32 %26, %27
  %28 = load i32, i32* %_min1, align 4
  %29 = load i32, i32* %_min2, align 4
  %cond = select i1 %cmp82, i32 %28, i32 %29
  %30 = bitcast i32* %_min2 to i8*
  %31 = bitcast i32* %_min1 to i8*
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %buf.addr.2, i8* %add.ptr78, i32 %cond) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool85 = icmp ne i32 %conv.i, 0
  br i1 %tobool85, label %LeafBlock4, label %if.end88

if.end88:                                         ; preds = %if.then69, %if.then49
  %conv89 = zext i32 %conv63.conv58 to i64
  %32 = load i64, i64* %ppos, align 8, !tbaa !339
  %add90 = add nsw i64 %32, %conv89
  store i64 %add90, i64* %ppos, align 8, !tbaa !339
  %idx.ext91 = zext i32 %conv63.conv58 to i64
  %add.ptr92 = getelementptr inbounds i8, i8* %buf.addr.2, i64 %idx.ext91
  %conv93 = zext i32 %conv63.conv58 to i64
  %sub94 = sub i64 %nbytes.addr.2, %conv93
  %conv95 = zext i32 %conv63.conv58 to i64
  %add96 = add nsw i64 %ret.2, %conv95
  br label %LeafBlock4

LeafBlock4:                                       ; preds = %if.end88, %if.then69
  %ret.3 = phi i64 [ %add96, %if.end88 ], [ -14, %if.then69 ]
  %cleanup.dest.slot.1 = phi i32 [ 0, %if.end88 ], [ 2, %if.then69 ]
  %nbytes.addr.3 = phi i64 [ %sub94, %if.end88 ], [ %nbytes.addr.2, %if.then69 ]
  %buf.addr.3 = phi i8* [ %add.ptr92, %if.end88 ], [ %buf.addr.2, %if.then69 ]
  %SwitchLeaf5 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf5, label %if.end100, label %NodeBlock11

if.end100:                                        ; preds = %LeafBlock4, %for.body
  %ret.4 = phi i64 [ %ret.2, %for.body ], [ %ret.3, %LeafBlock4 ]
  %nbytes.addr.4 = phi i64 [ %nbytes.addr.2, %for.body ], [ %nbytes.addr.3, %LeafBlock4 ]
  %buf.addr.4 = phi i8* [ %buf.addr.2, %for.body ], [ %buf.addr.3, %LeafBlock4 ]
  %conv101 = zext i32 %conv44 to i64
  %add102 = add nsw i64 %pos.0, %conv101
  br label %NodeBlock11

NodeBlock11:                                      ; preds = %if.end100, %LeafBlock4
  %pos.1 = phi i64 [ %add102, %if.end100 ], [ %pos.0, %LeafBlock4 ]
  %ret.5 = phi i64 [ %ret.4, %if.end100 ], [ %ret.3, %LeafBlock4 ]
  %cleanup.dest.slot.2 = phi i32 [ 0, %if.end100 ], [ %cleanup.dest.slot.1, %LeafBlock4 ]
  %nbytes.addr.5 = phi i64 [ %nbytes.addr.4, %if.end100 ], [ %nbytes.addr.3, %LeafBlock4 ]
  %buf.addr.5 = phi i8* [ %buf.addr.4, %if.end100 ], [ %buf.addr.3, %LeafBlock4 ]
  %Pivot12 = icmp slt i32 %cleanup.dest.slot.2, 2
  br i1 %Pivot12, label %LeafBlock7, label %LeafBlock9

LeafBlock9:                                       ; preds = %NodeBlock11
  %SwitchLeaf10 = icmp eq i32 %cleanup.dest.slot.2, 2
  br i1 %SwitchLeaf10, label %err, label %cleanup108

LeafBlock7:                                       ; preds = %NodeBlock11
  %SwitchLeaf8 = icmp eq i32 %cleanup.dest.slot.2, 0
  br i1 %SwitchLeaf8, label %for.inc, label %cleanup108

for.inc:                                          ; preds = %LeafBlock7
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

err:                                              ; preds = %LeafBlock9, %land.rhs, %for.cond, %LeafBlock1, %if.else, %entry
  %ret.6 = phi i64 [ %ret.5, %LeafBlock9 ], [ %ret.0, %LeafBlock1 ], [ -19, %entry ], [ -22, %if.else ], [ %ret.2, %for.cond ], [ %ret.2, %land.rhs ]
  %dev107 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock.670(%struct.device* %dev107)
  br label %cleanup108

cleanup108:                                       ; preds = %err, %LeafBlock7, %LeafBlock9, %LeafBlock, %LeafBlock1
  %retval.0 = phi i64 [ %ret.6, %err ], [ undef, %LeafBlock1 ], [ undef, %LeafBlock ], [ undef, %LeafBlock7 ], [ undef, %LeafBlock9 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !593
  %1 = bitcast i8* %0 to %struct.dev_state*
  %wait1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 6
  call void @poll_wait(%struct.file* %file, %struct.__wait_queue_head* %wait1, %struct.poll_table_struct* %wait)
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 8
  %2 = load i32, i32* %f_mode, align 4, !tbaa !596
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %async_completed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 5
  %call = call i32 @list_empty.665(%struct.list_head* %async_completed)
  %tobool2 = icmp ne i32 %call, 0
  %or = or i32 0, 260
  %.or = select i1 %tobool2, i32 0, i32 %or
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %mask.0 = phi i32 [ 0, %entry ], [ %.or, %land.lhs.true ]
  %call3 = call i32 @connected(%struct.dev_state* %1)
  %tobool4 = icmp ne i32 %call3, 0
  %or6 = or i32 %mask.0, 24
  %mask.0.or6 = select i1 %tobool4, i32 %mask.0, i32 %or6
  ret i32 %mask.0.or6
}

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %0 = inttoptr i64 %arg to i8*
  %call = call i64 @usbdev_do_ioctl(%struct.file* %file, i32 %cmd, i8* %0)
  %conv = trunc i64 %call to i32
  %conv1 = sext i32 %conv to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_compat_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %conv = trunc i64 %arg to i32
  %call = call i8* @compat_ptr(i32 %conv)
  %call1 = call i64 @usbdev_do_ioctl(%struct.file* %file, i32 %cmd, i8* %call)
  %conv2 = trunc i64 %call1 to i32
  %conv3 = sext i32 %conv2 to i64
  ret i64 %conv3
}

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %call.i = call i8* @__kmalloc(i64 272, i32 208) #8
  %0 = bitcast i8* %call.i to %struct.dev_state*
  %tobool = icmp ne %struct.dev_state* %0, null
  br i1 %tobool, label %if.end, label %out_free_ps

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @usbfs_mutex, i32 0)
  %call1 = call i32 @imajor(%struct.inode* %inode)
  %cmp = icmp eq i32 %call1, 189
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 13
  %1 = load i32, i32* %i_rdev, align 4, !tbaa !565
  %call3 = call %struct.usb_device* @usbdev_lookup_by_devt(i32 %1)
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %dev.0 = phi %struct.usb_device* [ %call3, %if.then2 ], [ null, %if.end ]
  call void @mutex_unlock(%struct.mutex* @usbfs_mutex)
  %tobool5 = icmp ne %struct.usb_device* %dev.0, null
  br i1 %tobool5, label %if.end7, label %out_free_ps

if.end7:                                          ; preds = %if.end4
  %dev8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 11
  call void @device_lock.668(%struct.device* %dev8)
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 3
  %2 = load i32, i32* %state, align 8, !tbaa !50
  %cmp9 = icmp eq i32 %2, 0
  br i1 %cmp9, label %out_unlock_device, label %if.end11

if.end11:                                         ; preds = %if.end7
  %call12 = call i32 @usb_autoresume_device(%struct.usb_device* %dev.0)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %out_unlock_device, label %if.end15

if.end15:                                         ; preds = %if.end11
  %dev16 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  store %struct.usb_device* %dev.0, %struct.usb_device** %dev16, align 8, !tbaa !594
  %file17 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 2
  store %struct.file* %file, %struct.file** %file17, align 8, !tbaa !597
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  %call18 = call %struct.raw_spinlock* @spinlock_check.663(%struct.spinlock* %lock)
  %lock20 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock20, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %3 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.62.678, i32 0, i32 0), %struct.lock_class_key* @usbdev_open.__key)
  %list = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 0
  call void @INIT_LIST_HEAD.662(%struct.list_head* %list)
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 4
  call void @INIT_LIST_HEAD.662(%struct.list_head* %async_pending)
  %async_completed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 5
  call void @INIT_LIST_HEAD.662(%struct.list_head* %async_completed)
  %wait = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 6
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wait, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.64.679, i32 0, i32 0), %struct.lock_class_key* @usbdev_open.__key.63)
  %discsignr = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 7
  store i32 0, i32* %discsignr, align 8, !tbaa !598
  %4 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %call27 = call %struct.pid* @task_pid(%struct.task_struct* %4)
  %call28 = call %struct.pid* @get_pid(%struct.pid* %call27)
  %disc_pid = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 8
  store %struct.pid* %call28, %struct.pid** %disc_pid, align 8, !tbaa !600
  %call30 = call i32 @debug_lockdep_rcu_enabled()
  %5 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %cred = getelementptr inbounds %struct.task_struct, %struct.task_struct* %5, i32 0, i32 65
  %6 = load %struct.cred*, %struct.cred** %cred, align 8, !tbaa !601
  %call39 = call %struct.cred* @get_cred(%struct.cred* %6)
  %cred40 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 9
  store %struct.cred* %call39, %struct.cred** %cred40, align 8, !tbaa !602
  %disccontext = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 10
  store i8* null, i8** %disccontext, align 8, !tbaa !603
  %ifclaimed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 11
  store i64 0, i64* %ifclaimed, align 8, !tbaa !604
  %7 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %secid = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 12
  call void @security_task_getsecid(%struct.task_struct* %7, i32* %secid)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #8, !srcloc !605
  %list42 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 0
  %filelist = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 27
  call void @list_add_tail.667(%struct.list_head* %list42, %struct.list_head* %filelist)
  %8 = bitcast %struct.dev_state* %0 to i8*
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  store i8* %8, i8** %private_data, align 8, !tbaa !593
  %dev43 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 11
  call void @device_unlock.670(%struct.device* %dev43)
  %9 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool45 = trunc i8 %9 to i1
  br i1 %tobool45, label %if.then46, label %cleanup

if.then46:                                        ; preds = %if.end15
  %10 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  call void @task_pid_nr(%struct.task_struct* %10)
  %11 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %12 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

out_unlock_device:                                ; preds = %if.end11, %if.end7
  %ret.0 = phi i32 [ -19, %if.end7 ], [ %call12, %if.end11 ]
  %dev55 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 11
  call void @device_unlock.670(%struct.device* %dev55)
  call void @usb_put_dev(%struct.usb_device* %dev.0)
  br label %out_free_ps

out_free_ps:                                      ; preds = %out_unlock_device, %if.end4, %entry
  %ret.1 = phi i32 [ %ret.0, %out_unlock_device ], [ -12, %entry ], [ -19, %if.end4 ]
  %13 = bitcast %struct.dev_state* %0 to i8*
  call void @kfree(i8* %13)
  br label %cleanup

cleanup:                                          ; preds = %out_free_ps, %if.then46, %if.end15
  %retval.0 = phi i32 [ %ret.1, %out_free_ps ], [ %call12, %if.then46 ], [ %call12, %if.end15 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !593
  %1 = bitcast i8* %0 to %struct.dev_state*
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !594
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock.668(%struct.device* %dev2)
  call void @usb_hub_release_all_ports(%struct.usb_device* %2, %struct.dev_state* %1)
  %list = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 0
  call void @list_del_init.666(%struct.list_head* %list)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %ifnum.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %ifclaimed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 11
  %3 = load i64, i64* %ifclaimed, align 8, !tbaa !604
  %tobool = icmp ne i64 %3, 0
  %conv = zext i32 %ifnum.0 to i64
  %cmp = icmp ult i64 %conv, 64
  %4 = select i1 %tobool, i1 %cmp, i1 false
  br i1 %4, label %cond.false, label %for.end

cond.false:                                       ; preds = %for.cond
  %ifclaimed6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 11
  %call7 = call i32 @variable_test_bit.669(i32 %ifnum.0, i64* %ifclaimed6)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.then, label %for.inc

if.then:                                          ; preds = %cond.false
  %call9 = call i32 @releaseintf(%struct.dev_state* %1, i32 %ifnum.0)
  br label %for.inc

for.inc:                                          ; preds = %if.then, %cond.false
  %inc = add i32 %ifnum.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @destroy_all_async(%struct.dev_state* %1)
  call void @usb_autosuspend_device(%struct.usb_device* %2)
  %dev10 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock.670(%struct.device* %dev10)
  call void @usb_put_dev(%struct.usb_device* %2)
  %disc_pid = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 8
  %5 = load %struct.pid*, %struct.pid** %disc_pid, align 8, !tbaa !600
  call void @put_pid(%struct.pid* %5)
  %cred = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 9
  %6 = load %struct.cred*, %struct.cred** %cred, align 8, !tbaa !602
  call void @put_cred(%struct.cred* %6)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %call13 = call %struct.async* @async_getcompleted(%struct.dev_state* %1)
  %tobool12 = icmp ne %struct.async* %call13, null
  br i1 %tobool12, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @free_async(%struct.async* %call13)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %7 = bitcast %struct.dev_state* %1 to i8*
  call void @kfree(i8* %7)
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock.668(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @variable_test_bit.669(i32 %nr, i64* %addr) #1 {
entry:
  %0 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr) #8, !srcloc !606
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @releaseintf(%struct.dev_state* %ps, i32 %ifnum) #0 {
entry:
  %conv = zext i32 %ifnum to i64
  %cmp = icmp uge i64 %conv, 64
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev2 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8, !tbaa !594
  %call = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %0, i32 %ifnum)
  %tobool = icmp ne %struct.usb_interface* %call, null
  br i1 %tobool, label %if.else, label %cleanup

if.else:                                          ; preds = %if.end
  %ifclaimed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 11
  %call4 = call i32 @test_and_clear_bit.676(i32 %ifnum, i64* %ifclaimed)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %cleanup

if.then6:                                         ; preds = %if.else
  call void @usb_driver_release_interface(%struct.usb_driver* @usbfs_driver, %struct.usb_interface* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.then6, %if.else, %if.end, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -2, %if.end ], [ 0, %if.then6 ], [ -22, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @destroy_all_async(%struct.dev_state* %ps) #0 {
entry:
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  call void @destroy_async(%struct.dev_state* %ps, %struct.list_head* %async_pending)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock.670(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

declare void @put_pid(%struct.pid*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @put_cred(%struct.cred* %_cred) #1 {
entry:
  call void @__validate_creds(%struct.cred* %_cred, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.58.675, i32 0, i32 0), i32 247)
  %usage = getelementptr inbounds %struct.cred, %struct.cred* %_cred, i32 0, i32 0
  %call = call i32 @atomic_dec_and_test(%union.anon.5* %usage)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__put_cred(%struct.cred* %_cred)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.async* @async_getcompleted(%struct.dev_state* %ps) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check.663(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %async_completed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 5
  %call5 = call i32 @list_empty.665(%struct.list_head* %async_completed)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %async_completed6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 5
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %async_completed6, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !607
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 0
  %6 = bitcast i8* %add.ptr to %struct.async*
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %6, i32 0, i32 0
  call void @list_del_init.666(%struct.list_head* %asynclist)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %as.0 = phi %struct.async* [ null, %entry ], [ %6, %if.then ]
  %lock8 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore.664(%struct.spinlock* %lock8, i64 %call2)
  ret %struct.async* %as.0
}

; Function Attrs: nounwind uwtable
define internal void @free_async(%struct.async* %as) #0 {
entry:
  %pid = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 2
  %0 = load %struct.pid*, %struct.pid** %pid, align 8, !tbaa !608
  call void @put_pid(%struct.pid* %0)
  %cred = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 3
  %1 = load %struct.cred*, %struct.cred** %cred, align 8, !tbaa !609
  %tobool = icmp ne %struct.cred* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %cred1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 3
  %2 = load %struct.cred*, %struct.cred** %cred1, align 8, !tbaa !609
  call void @put_cred(%struct.cred* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %urb = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %3 = load %struct.urb*, %struct.urb** %urb, align 8, !tbaa !591
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %3, i32 0, i32 18
  %4 = load i32, i32* %num_sgs, align 4, !tbaa !330
  %cmp = icmp slt i32 %i.0, %4
  %urb2 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %5 = load %struct.urb*, %struct.urb** %urb2, align 8, !tbaa !591
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %5, i32 0, i32 16
  %6 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8, !tbaa !329
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %6, i64 %idxprom
  %call = call %struct.page* @sg_page.671(%struct.scatterlist* %arrayidx)
  %tobool3 = icmp ne %struct.page* %call, null
  br i1 %tobool3, label %if.then4, label %for.inc

if.then4:                                         ; preds = %for.body
  %urb5 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %7 = load %struct.urb*, %struct.urb** %urb5, align 8, !tbaa !591
  %sg6 = getelementptr inbounds %struct.urb, %struct.urb* %7, i32 0, i32 16
  %8 = load %struct.scatterlist*, %struct.scatterlist** %sg6, align 8, !tbaa !329
  %idxprom7 = sext i32 %i.0 to i64
  %arrayidx8 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %8, i64 %idxprom7
  %call9 = call i8* @sg_virt.672(%struct.scatterlist* %arrayidx8)
  call void @kfree(i8* %call9)
  br label %for.inc

for.inc:                                          ; preds = %if.then4, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = bitcast %struct.scatterlist* %6 to i8*
  call void @kfree(i8* %9)
  %urb13 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %10 = load %struct.urb*, %struct.urb** %urb13, align 8, !tbaa !591
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %10, i32 0, i32 14
  %11 = load i8*, i8** %transfer_buffer, align 8, !tbaa !293
  call void @kfree(i8* %11)
  %urb14 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %12 = load %struct.urb*, %struct.urb** %urb14, align 8, !tbaa !591
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %12, i32 0, i32 21
  %13 = load i8*, i8** %setup_packet, align 8, !tbaa !371
  call void @kfree(i8* %13)
  %urb15 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %14 = load %struct.urb*, %struct.urb** %urb15, align 8, !tbaa !591
  call void bitcast (void (%struct.urb.824*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %14)
  %mem_usage = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 9
  %15 = load i32, i32* %mem_usage, align 8, !tbaa !610
  call void @usbfs_decrease_memory_usage(i32 %15)
  %16 = bitcast %struct.async* %as to i8*
  call void @kfree(i8* %16)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.page* @sg_page.671(%struct.scatterlist* %sg) #1 {
entry:
  %sg_magic = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 0
  %0 = load i64, i64* %sg_magic, align 8, !tbaa !381
  %cmp = icmp ne i64 %0, 2271560481
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.body8

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.56.674, i32 0, i32 0), i32 98, i64 12) #8, !srcloc !611
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.body8:                                         ; preds = %entry
  %page_link = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %1 = load i64, i64* %page_link, align 8, !tbaa !383
  %and = and i64 %1, 1
  %tobool9 = icmp ne i64 %and, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %do.body18, label %do.end26

do.body18:                                        ; preds = %do.body8
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.56.674, i32 0, i32 0), i32 99, i64 12) #8, !srcloc !612
  br label %do.body19

do.body19:                                        ; preds = %do.body19, %do.body18
  br label %do.body19

do.end26:                                         ; preds = %do.body8
  %page_link27 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %2 = load i64, i64* %page_link27, align 8, !tbaa !383
  %and28 = and i64 %2, -4
  %3 = inttoptr i64 %and28 to %struct.page*
  ret %struct.page* %3
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @sg_virt.672(%struct.scatterlist* %sg) #1 {
entry:
  %call = call %struct.page* @sg_page.671(%struct.scatterlist* %sg)
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %call to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %0 = inttoptr i64 %add.i to i8*
  %offset = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 2
  %1 = load i32, i32* %offset, align 8, !tbaa !373
  %idx.ext = zext i32 %1 to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  ret i8* %add.ptr
}

; Function Attrs: nounwind uwtable
define internal void @usbfs_decrease_memory_usage(i32 %amount) #0 {
entry:
  call void @simpll__inlineasm_0(i32* getelementptr inbounds (%union.anon.5, %union.anon.5* @usbfs_memory_usage, i64 0, i32 0), i32 %amount, i32* getelementptr inbounds (%union.anon.5, %union.anon.5* @usbfs_memory_usage, i64 0, i32 0)) #8
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__validate_creds(%struct.cred* %cred, i8* %file, i32 %line) #1 {
entry:
  %call = call zeroext i1 @creds_are_invalid(%struct.cred* %cred)
  %lnot = xor i1 %call, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__invalid_creds(%struct.cred* %cred, i8* %file, i32 %line)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_dec_and_test(%union.anon.5* %v) #1 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0; sete $1", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32* %counter) #8, !srcloc !613
  %0 = load i8, i8* %c, align 1, !tbaa !84
  %conv = zext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

declare void @__put_cred(%struct.cred*) #2

declare zeroext i1 @creds_are_invalid(%struct.cred*) #2

declare void @__invalid_creds(%struct.cred*, i8*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_and_clear_bit.676(i32 %nr, i64* %addr) #1 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #8, !srcloc !614
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @imajor(%struct.inode* %inode) #1 {
entry:
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 13
  %0 = load i32, i32* %i_rdev, align 4, !tbaa !565
  %shr = lshr i32 %0, 20
  ret i32 %shr
}

; Function Attrs: nounwind uwtable
define internal %struct.usb_device* @usbdev_lookup_by_devt(i32 %devt) #0 {
entry:
  %conv = zext i32 %devt to i64
  %0 = inttoptr i64 %conv to i8*
  %call = call %struct.device* @bus_find_device(%struct.bus_type* @usb_bus_type, %struct.device* null, i8* %0, i32 (%struct.device*, i8*)* @match_devt)
  %tobool = icmp ne %struct.device* %call, null
  %1 = bitcast %struct.device* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -136
  %2 = bitcast i8* %add.ptr to %struct.usb_device*
  %retval.0 = select i1 %tobool, %struct.usb_device* %2, %struct.usb_device* null
  ret %struct.usb_device* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.pid* @task_pid(%struct.task_struct* %task) #1 {
entry:
  %pids = getelementptr inbounds %struct.task_struct, %struct.task_struct* %task, i32 0, i32 45
  %arrayidx = getelementptr inbounds [3 x %struct.pid_link], [3 x %struct.pid_link]* %pids, i64 0, i64 0
  %pid = getelementptr inbounds %struct.pid_link, %struct.pid_link* %arrayidx, i32 0, i32 1
  %0 = load %struct.pid*, %struct.pid** %pid, align 8, !tbaa !615
  ret %struct.pid* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.pid* @get_pid(%struct.pid* %pid) #1 {
entry:
  %tobool = icmp ne %struct.pid* %pid, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %count = getelementptr inbounds %struct.pid, %struct.pid* %pid, i32 0, i32 0
  call void @atomic_inc.682(%union.anon.5* %count)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.pid* %pid
}

declare i32 @debug_lockdep_rcu_enabled() #2

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.cred* @get_cred(%struct.cred* %cred) #1 {
entry:
  call void @__validate_creds(%struct.cred* %cred, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.58.675, i32 0, i32 0), i32 228)
  %call = call %struct.cred* @get_new_cred(%struct.cred* %cred)
  ret %struct.cred* %call
}

declare void @security_task_getsecid(%struct.task_struct*, i32*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @task_pid_nr(%struct.task_struct* %tsk) #1 {
entry:
  %pid = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i32 0, i32 35
  %0 = load i32, i32* %pid, align 8, !tbaa !617
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.cred* @get_new_cred(%struct.cred* %cred) #1 {
entry:
  %usage = getelementptr inbounds %struct.cred, %struct.cred* %cred, i32 0, i32 0
  call void @atomic_inc.682(%union.anon.5* %usage)
  ret %struct.cred* %cred
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.682(%union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #8, !srcloc !618
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @match_devt(%struct.device* %dev, i8* %data) #0 {
entry:
  %devt = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 20
  %0 = load i32, i32* %devt, align 8, !tbaa !619
  %1 = ptrtoint i8* %data to i64
  %conv = trunc i64 %1 to i32
  %cmp = icmp eq i32 %0, %conv
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @compat_ptr(i32 %uptr) #1 {
entry:
  %conv = zext i32 %uptr to i64
  %0 = inttoptr i64 %conv to i8*
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_do_ioctl(%struct.file* %file, i32 %cmd, i8* %p) #0 {
entry:
  %coerce = alloca %struct.load_weight, align 8
  %coerce31 = alloca %struct.load_weight, align 8
  %coerce47 = alloca %struct.load_weight, align 8
  %coerce73 = alloca %struct.load_weight, align 8
  %coerce129 = alloca %struct.load_weight, align 8
  %coerce145 = alloca %struct.load_weight, align 8
  %coerce161 = alloca %struct.load_weight, align 8
  %coerce187 = alloca %struct.load_weight, align 8
  %coerce318 = alloca %struct.load_weight, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !593
  %1 = bitcast i8* %0 to %struct.dev_state*
  %call = call %struct.inode* @file_inode(%struct.file* %file)
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !594
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 8
  %3 = load i32, i32* %f_mode, align 4, !tbaa !596
  %and = and i32 %3, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock.668(%struct.device* %dev2)
  %call3 = call i32 @connected(%struct.dev_state* %1)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %NodeBlock95, label %if.then5

if.then5:                                         ; preds = %if.end
  %dev6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock.670(%struct.device* %dev6)
  br label %cleanup

NodeBlock95:                                      ; preds = %if.end
  %Pivot96 = icmp slt i32 %cmd, -1072933614
  br i1 %Pivot96, label %NodeBlock43, label %NodeBlock93

NodeBlock93:                                      ; preds = %NodeBlock95
  %Pivot94 = icmp slt i32 %cmd, 21780
  br i1 %Pivot94, label %NodeBlock69, label %NodeBlock91

NodeBlock91:                                      ; preds = %NodeBlock93
  %Pivot92 = icmp slt i32 %cmd, 1074287884
  br i1 %Pivot92, label %NodeBlock77, label %NodeBlock89

NodeBlock89:                                      ; preds = %NodeBlock91
  %Pivot90 = icmp slt i32 %cmd, 1074287889
  br i1 %Pivot90, label %NodeBlock81, label %NodeBlock87

NodeBlock87:                                      ; preds = %NodeBlock89
  %Pivot88 = icmp slt i32 %cmd, 1090802952
  br i1 %Pivot88, label %LeafBlock83, label %LeafBlock85

LeafBlock85:                                      ; preds = %NodeBlock87
  %SwitchLeaf86 = icmp eq i32 %cmd, 1090802952
  br i1 %SwitchLeaf86, label %do.body76, label %sw.epilog

LeafBlock83:                                      ; preds = %NodeBlock87
  %SwitchLeaf84 = icmp eq i32 %cmd, 1074287889
  br i1 %SwitchLeaf84, label %do.body86, label %sw.epilog

NodeBlock81:                                      ; preds = %NodeBlock89
  %Pivot82 = icmp slt i32 %cmd, 1074287885
  br i1 %Pivot82, label %do.body231, label %LeafBlock79

LeafBlock79:                                      ; preds = %NodeBlock81
  %SwitchLeaf80 = icmp eq i32 %cmd, 1074287885
  br i1 %SwitchLeaf80, label %do.body241, label %sw.epilog

NodeBlock77:                                      ; preds = %NodeBlock91
  %Pivot78 = icmp slt i32 %cmd, 1074025740
  br i1 %Pivot78, label %LeafBlock71, label %NodeBlock75

NodeBlock75:                                      ; preds = %NodeBlock77
  %Pivot76 = icmp slt i32 %cmd, 1074025741
  br i1 %Pivot76, label %do.body190, label %LeafBlock73

LeafBlock73:                                      ; preds = %NodeBlock75
  %SwitchLeaf74 = icmp eq i32 %cmd, 1074025741
  br i1 %SwitchLeaf74, label %do.body200, label %sw.epilog

LeafBlock71:                                      ; preds = %NodeBlock77
  %SwitchLeaf72 = icmp eq i32 %cmd, 21780
  br i1 %SwitchLeaf72, label %do.body50, label %sw.epilog

NodeBlock69:                                      ; preds = %NodeBlock93
  %Pivot70 = icmp slt i32 %cmd, -1072671470
  br i1 %Pivot70, label %NodeBlock53, label %NodeBlock67

NodeBlock67:                                      ; preds = %NodeBlock69
  %Pivot68 = icmp slt i32 %cmd, -1072147198
  br i1 %Pivot68, label %NodeBlock59, label %NodeBlock65

NodeBlock65:                                      ; preds = %NodeBlock67
  %Pivot66 = icmp slt i32 %cmd, 21771
  br i1 %Pivot66, label %LeafBlock61, label %LeafBlock63

LeafBlock63:                                      ; preds = %NodeBlock65
  %SwitchLeaf64 = icmp eq i32 %cmd, 21771
  br i1 %SwitchLeaf64, label %do.body221, label %sw.epilog

LeafBlock61:                                      ; preds = %NodeBlock65
  %SwitchLeaf62 = icmp eq i32 %cmd, -1072147198
  br i1 %SwitchLeaf62, label %do.body18, label %sw.epilog

NodeBlock59:                                      ; preds = %NodeBlock67
  %Pivot60 = icmp slt i32 %cmd, -1072147200
  br i1 %Pivot60, label %LeafBlock55, label %LeafBlock57

LeafBlock57:                                      ; preds = %NodeBlock59
  %SwitchLeaf58 = icmp eq i32 %cmd, -1072147200
  br i1 %SwitchLeaf58, label %do.body, label %sw.epilog

LeafBlock55:                                      ; preds = %NodeBlock59
  %SwitchLeaf56 = icmp eq i32 %cmd, -1072671470
  br i1 %SwitchLeaf56, label %do.body281, label %sw.epilog

NodeBlock53:                                      ; preds = %NodeBlock69
  %Pivot54 = icmp slt i32 %cmd, -1072671488
  br i1 %Pivot54, label %LeafBlock45, label %NodeBlock51

NodeBlock51:                                      ; preds = %NodeBlock53
  %Pivot52 = icmp slt i32 %cmd, -1072671486
  br i1 %Pivot52, label %LeafBlock47, label %LeafBlock49

LeafBlock49:                                      ; preds = %NodeBlock51
  %SwitchLeaf50 = icmp eq i32 %cmd, -1072671486
  br i1 %SwitchLeaf50, label %do.body148, label %sw.epilog

LeafBlock47:                                      ; preds = %NodeBlock51
  %SwitchLeaf48 = icmp eq i32 %cmd, -1072671488
  br i1 %SwitchLeaf48, label %do.body132, label %sw.epilog

LeafBlock45:                                      ; preds = %NodeBlock53
  %SwitchLeaf46 = icmp eq i32 %cmd, -1072933614
  br i1 %SwitchLeaf46, label %do.body210, label %sw.epilog

NodeBlock43:                                      ; preds = %NodeBlock95
  %Pivot44 = icmp slt i32 %cmd, -2147199718
  br i1 %Pivot44, label %NodeBlock15, label %NodeBlock41

NodeBlock41:                                      ; preds = %NodeBlock43
  %Pivot42 = icmp slt i32 %cmd, -2146413298
  br i1 %Pivot42, label %NodeBlock25, label %NodeBlock39

NodeBlock39:                                      ; preds = %NodeBlock41
  %Pivot40 = icmp slt i32 %cmd, -2143791862
  br i1 %Pivot40, label %NodeBlock31, label %NodeBlock37

NodeBlock37:                                      ; preds = %NodeBlock39
  %Pivot38 = icmp slt i32 %cmd, -2130160357
  br i1 %Pivot38, label %LeafBlock33, label %LeafBlock35

LeafBlock35:                                      ; preds = %NodeBlock37
  %SwitchLeaf36 = icmp eq i32 %cmd, -2130160357
  br i1 %SwitchLeaf36, label %sw.bb312, label %sw.epilog

LeafBlock33:                                      ; preds = %NodeBlock37
  %SwitchLeaf34 = icmp eq i32 %cmd, -2143791862
  br i1 %SwitchLeaf34, label %do.body116, label %sw.epilog

NodeBlock31:                                      ; preds = %NodeBlock39
  %Pivot32 = icmp slt i32 %cmd, -2144578294
  br i1 %Pivot32, label %LeafBlock27, label %LeafBlock29

LeafBlock29:                                      ; preds = %NodeBlock31
  %SwitchLeaf30 = icmp eq i32 %cmd, -2144578294
  br i1 %SwitchLeaf30, label %do.body174, label %sw.epilog

LeafBlock27:                                      ; preds = %NodeBlock31
  %SwitchLeaf28 = icmp eq i32 %cmd, -2146413298
  br i1 %SwitchLeaf28, label %do.body251, label %sw.epilog

NodeBlock25:                                      ; preds = %NodeBlock41
  %Pivot26 = icmp slt i32 %cmd, -2146937596
  br i1 %Pivot26, label %LeafBlock17, label %NodeBlock23

NodeBlock23:                                      ; preds = %NodeBlock25
  %Pivot24 = icmp slt i32 %cmd, -2146937586
  br i1 %Pivot24, label %LeafBlock19, label %LeafBlock21

LeafBlock21:                                      ; preds = %NodeBlock23
  %SwitchLeaf22 = icmp eq i32 %cmd, -2146937586
  br i1 %SwitchLeaf22, label %do.body164, label %sw.epilog

LeafBlock19:                                      ; preds = %NodeBlock23
  %SwitchLeaf20 = icmp eq i32 %cmd, -2146937596
  br i1 %SwitchLeaf20, label %do.body96, label %sw.epilog

LeafBlock17:                                      ; preds = %NodeBlock25
  %SwitchLeaf18 = icmp eq i32 %cmd, -2147199718
  br i1 %SwitchLeaf18, label %sw.bb310, label %sw.epilog

NodeBlock15:                                      ; preds = %NodeBlock43
  %Pivot16 = icmp slt i32 %cmd, -2147199728
  br i1 %Pivot16, label %NodeBlock3, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %cmd, -2147199720
  br i1 %Pivot14, label %NodeBlock9, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %cmd, -2147199719
  %4 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool292 = trunc i8 %4 to i1
  br i1 %Pivot12, label %do.body291, label %do.body301

NodeBlock9:                                       ; preds = %NodeBlock13
  %Pivot10 = icmp slt i32 %cmd, -2147199723
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %cmd, -2147199723
  br i1 %SwitchLeaf8, label %do.body60, label %sw.epilog

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %cmd, -2147199728
  br i1 %SwitchLeaf6, label %do.body271, label %sw.epilog

NodeBlock3:                                       ; preds = %NodeBlock15
  %Pivot4 = icmp slt i32 %cmd, -2147199739
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %cmd, -2147199729
  br i1 %Pivot, label %LeafBlock1, label %do.body261

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, -2147199739
  br i1 %SwitchLeaf2, label %do.body106, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %cmd, -2147199741
  br i1 %SwitchLeaf, label %do.body34, label %sw.epilog

do.body:                                          ; preds = %LeafBlock57
  %5 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool8 = trunc i8 %5 to i1
  br i1 %tobool8, label %if.then9, label %do.end

if.then9:                                         ; preds = %do.body
  %6 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then9, %do.body
  %call13 = call i32 @proc_control(%struct.dev_state* %1, i8* %p)
  %cmp = icmp sge i32 %call13, 0
  br i1 %cmp, label %if.then14, label %sw.epilog

if.then14:                                        ; preds = %do.end
  %i_mtime = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call15 = call { i64, i64 } @current_kernel_time()
  %7 = bitcast %struct.load_weight* %coerce to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = extractvalue { i64, i64 } %call15, 0
  store i64 %9, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = extractvalue { i64, i64 } %call15, 1
  store i64 %11, i64* %10, align 8
  %12 = bitcast %struct.load_weight* %i_mtime to i8*
  %13 = bitcast %struct.load_weight* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 16, i32 8, i1 false), !tbaa.struct !620
  br label %sw.epilog

do.body18:                                        ; preds = %LeafBlock61
  %14 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool19 = trunc i8 %14 to i1
  br i1 %tobool19, label %if.then20, label %do.end25

if.then20:                                        ; preds = %do.body18
  %15 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end25

do.end25:                                         ; preds = %if.then20, %do.body18
  %call26 = call i32 @proc_bulk(%struct.dev_state* %1, i8* %p)
  %cmp27 = icmp sge i32 %call26, 0
  br i1 %cmp27, label %if.then28, label %sw.epilog

if.then28:                                        ; preds = %do.end25
  %i_mtime29 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call30 = call { i64, i64 } @current_kernel_time()
  %16 = bitcast %struct.load_weight* %coerce31 to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call30, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call30, 1
  store i64 %20, i64* %19, align 8
  %21 = bitcast %struct.load_weight* %i_mtime29 to i8*
  %22 = bitcast %struct.load_weight* %coerce31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %21, i8* %22, i64 16, i32 8, i1 false), !tbaa.struct !620
  br label %sw.epilog

do.body34:                                        ; preds = %LeafBlock
  %23 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool35 = trunc i8 %23 to i1
  br i1 %tobool35, label %if.then36, label %do.end41

if.then36:                                        ; preds = %do.body34
  %24 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end41

do.end41:                                         ; preds = %if.then36, %do.body34
  %call42 = call i32 @proc_resetep(%struct.dev_state* %1, i8* %p)
  %cmp43 = icmp sge i32 %call42, 0
  br i1 %cmp43, label %if.then44, label %sw.epilog

if.then44:                                        ; preds = %do.end41
  %i_mtime45 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call46 = call { i64, i64 } @current_kernel_time()
  %25 = bitcast %struct.load_weight* %coerce47 to { i64, i64 }*
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 0
  %27 = extractvalue { i64, i64 } %call46, 0
  store i64 %27, i64* %26, align 8
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 1
  %29 = extractvalue { i64, i64 } %call46, 1
  store i64 %29, i64* %28, align 8
  %30 = bitcast %struct.load_weight* %i_mtime45 to i8*
  %31 = bitcast %struct.load_weight* %coerce47 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %30, i8* %31, i64 16, i32 8, i1 false), !tbaa.struct !620
  br label %sw.epilog

do.body50:                                        ; preds = %LeafBlock71
  %32 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool51 = trunc i8 %32 to i1
  br i1 %tobool51, label %if.then52, label %do.end57

if.then52:                                        ; preds = %do.body50
  %33 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end57

do.end57:                                         ; preds = %if.then52, %do.body50
  %call58 = call i32 @proc_resetdevice(%struct.dev_state* %1)
  br label %sw.epilog

do.body60:                                        ; preds = %LeafBlock7
  %34 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool61 = trunc i8 %34 to i1
  br i1 %tobool61, label %if.then62, label %do.end67

if.then62:                                        ; preds = %do.body60
  %35 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end67

do.end67:                                         ; preds = %if.then62, %do.body60
  %call68 = call i32 @proc_clearhalt(%struct.dev_state* %1, i8* %p)
  %cmp69 = icmp sge i32 %call68, 0
  br i1 %cmp69, label %if.then70, label %sw.epilog

if.then70:                                        ; preds = %do.end67
  %i_mtime71 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call72 = call { i64, i64 } @current_kernel_time()
  %36 = bitcast %struct.load_weight* %coerce73 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = extractvalue { i64, i64 } %call72, 0
  store i64 %38, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = extractvalue { i64, i64 } %call72, 1
  store i64 %40, i64* %39, align 8
  %41 = bitcast %struct.load_weight* %i_mtime71 to i8*
  %42 = bitcast %struct.load_weight* %coerce73 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %41, i8* %42, i64 16, i32 8, i1 false), !tbaa.struct !620
  br label %sw.epilog

do.body76:                                        ; preds = %LeafBlock85
  %43 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool77 = trunc i8 %43 to i1
  br i1 %tobool77, label %if.then78, label %do.end83

if.then78:                                        ; preds = %do.body76
  %44 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end83

do.end83:                                         ; preds = %if.then78, %do.body76
  %call84 = call i32 @proc_getdriver(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body86:                                        ; preds = %LeafBlock83
  %45 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool87 = trunc i8 %45 to i1
  br i1 %tobool87, label %if.then88, label %do.end93

if.then88:                                        ; preds = %do.body86
  %46 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end93

do.end93:                                         ; preds = %if.then88, %do.body86
  %call94 = call i32 @proc_connectinfo(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body96:                                        ; preds = %LeafBlock19
  %47 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool97 = trunc i8 %47 to i1
  br i1 %tobool97, label %if.then98, label %do.end103

if.then98:                                        ; preds = %do.body96
  %48 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end103

do.end103:                                        ; preds = %if.then98, %do.body96
  %call104 = call i32 @proc_setintf(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body106:                                       ; preds = %LeafBlock1
  %49 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool107 = trunc i8 %49 to i1
  br i1 %tobool107, label %if.then108, label %do.end113

if.then108:                                       ; preds = %do.body106
  %50 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end113

do.end113:                                        ; preds = %if.then108, %do.body106
  %call114 = call i32 @proc_setconfig(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body116:                                       ; preds = %LeafBlock33
  %51 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool117 = trunc i8 %51 to i1
  br i1 %tobool117, label %if.then118, label %do.end123

if.then118:                                       ; preds = %do.body116
  %52 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end123

do.end123:                                        ; preds = %if.then118, %do.body116
  %call124 = call i32 @proc_submiturb(%struct.dev_state* %1, i8* %p)
  %cmp125 = icmp sge i32 %call124, 0
  br i1 %cmp125, label %if.then126, label %sw.epilog

if.then126:                                       ; preds = %do.end123
  %i_mtime127 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call128 = call { i64, i64 } @current_kernel_time()
  %53 = bitcast %struct.load_weight* %coerce129 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = extractvalue { i64, i64 } %call128, 0
  store i64 %55, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = extractvalue { i64, i64 } %call128, 1
  store i64 %57, i64* %56, align 8
  %58 = bitcast %struct.load_weight* %i_mtime127 to i8*
  %59 = bitcast %struct.load_weight* %coerce129 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %58, i8* %59, i64 16, i32 8, i1 false), !tbaa.struct !620
  br label %sw.epilog

do.body132:                                       ; preds = %LeafBlock47
  %60 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool133 = trunc i8 %60 to i1
  br i1 %tobool133, label %if.then134, label %do.end139

if.then134:                                       ; preds = %do.body132
  %61 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end139

do.end139:                                        ; preds = %if.then134, %do.body132
  %62 = bitcast i8* %p to %struct.usbdevfs_ctrltransfer32*
  %call140 = call i32 @proc_control_compat(%struct.dev_state* %1, %struct.usbdevfs_ctrltransfer32* %62)
  %cmp141 = icmp sge i32 %call140, 0
  br i1 %cmp141, label %if.then142, label %sw.epilog

if.then142:                                       ; preds = %do.end139
  %i_mtime143 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call144 = call { i64, i64 } @current_kernel_time()
  %63 = bitcast %struct.load_weight* %coerce145 to { i64, i64 }*
  %64 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %63, i32 0, i32 0
  %65 = extractvalue { i64, i64 } %call144, 0
  store i64 %65, i64* %64, align 8
  %66 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %63, i32 0, i32 1
  %67 = extractvalue { i64, i64 } %call144, 1
  store i64 %67, i64* %66, align 8
  %68 = bitcast %struct.load_weight* %i_mtime143 to i8*
  %69 = bitcast %struct.load_weight* %coerce145 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %68, i8* %69, i64 16, i32 8, i1 false), !tbaa.struct !620
  br label %sw.epilog

do.body148:                                       ; preds = %LeafBlock49
  %70 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool149 = trunc i8 %70 to i1
  br i1 %tobool149, label %if.then150, label %do.end155

if.then150:                                       ; preds = %do.body148
  %71 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end155

do.end155:                                        ; preds = %if.then150, %do.body148
  %72 = bitcast i8* %p to %struct.usb3_lpm_parameters*
  %call156 = call i32 @proc_bulk_compat(%struct.dev_state* %1, %struct.usb3_lpm_parameters* %72)
  %cmp157 = icmp sge i32 %call156, 0
  br i1 %cmp157, label %if.then158, label %sw.epilog

if.then158:                                       ; preds = %do.end155
  %i_mtime159 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call160 = call { i64, i64 } @current_kernel_time()
  %73 = bitcast %struct.load_weight* %coerce161 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = extractvalue { i64, i64 } %call160, 0
  store i64 %75, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = extractvalue { i64, i64 } %call160, 1
  store i64 %77, i64* %76, align 8
  %78 = bitcast %struct.load_weight* %i_mtime159 to i8*
  %79 = bitcast %struct.load_weight* %coerce161 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %78, i8* %79, i64 16, i32 8, i1 false), !tbaa.struct !620
  br label %sw.epilog

do.body164:                                       ; preds = %LeafBlock21
  %80 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool165 = trunc i8 %80 to i1
  br i1 %tobool165, label %if.then166, label %do.end171

if.then166:                                       ; preds = %do.body164
  %81 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end171

do.end171:                                        ; preds = %if.then166, %do.body164
  %call172 = call i32 @proc_disconnectsignal_compat(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body174:                                       ; preds = %LeafBlock29
  %82 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool175 = trunc i8 %82 to i1
  br i1 %tobool175, label %if.then176, label %do.end181

if.then176:                                       ; preds = %do.body174
  %83 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end181

do.end181:                                        ; preds = %if.then176, %do.body174
  %call182 = call i32 @proc_submiturb_compat(%struct.dev_state* %1, i8* %p)
  %cmp183 = icmp sge i32 %call182, 0
  br i1 %cmp183, label %if.then184, label %sw.epilog

if.then184:                                       ; preds = %do.end181
  %i_mtime185 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call186 = call { i64, i64 } @current_kernel_time()
  %84 = bitcast %struct.load_weight* %coerce187 to { i64, i64 }*
  %85 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %84, i32 0, i32 0
  %86 = extractvalue { i64, i64 } %call186, 0
  store i64 %86, i64* %85, align 8
  %87 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %84, i32 0, i32 1
  %88 = extractvalue { i64, i64 } %call186, 1
  store i64 %88, i64* %87, align 8
  %89 = bitcast %struct.load_weight* %i_mtime185 to i8*
  %90 = bitcast %struct.load_weight* %coerce187 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %89, i8* %90, i64 16, i32 8, i1 false), !tbaa.struct !620
  br label %sw.epilog

do.body190:                                       ; preds = %NodeBlock75
  %91 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool191 = trunc i8 %91 to i1
  br i1 %tobool191, label %if.then192, label %do.end197

if.then192:                                       ; preds = %do.body190
  %92 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end197

do.end197:                                        ; preds = %if.then192, %do.body190
  %call198 = call i32 @proc_reapurb_compat(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body200:                                       ; preds = %LeafBlock73
  %93 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool201 = trunc i8 %93 to i1
  br i1 %tobool201, label %if.then202, label %do.end207

if.then202:                                       ; preds = %do.body200
  %94 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end207

do.end207:                                        ; preds = %if.then202, %do.body200
  %call208 = call i32 @proc_reapurbnonblock_compat(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body210:                                       ; preds = %LeafBlock45
  %95 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool211 = trunc i8 %95 to i1
  br i1 %tobool211, label %if.then212, label %do.end217

if.then212:                                       ; preds = %do.body210
  %96 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end217

do.end217:                                        ; preds = %if.then212, %do.body210
  %call218 = call i32 @ptr_to_compat(i8* %p)
  %call219 = call i32 @proc_ioctl_compat(%struct.dev_state* %1, i32 %call218)
  br label %sw.epilog

do.body221:                                       ; preds = %LeafBlock63
  %97 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool222 = trunc i8 %97 to i1
  br i1 %tobool222, label %if.then223, label %do.end228

if.then223:                                       ; preds = %do.body221
  %98 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end228

do.end228:                                        ; preds = %if.then223, %do.body221
  %call229 = call i32 @proc_unlinkurb(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body231:                                       ; preds = %NodeBlock81
  %99 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool232 = trunc i8 %99 to i1
  br i1 %tobool232, label %if.then233, label %do.end238

if.then233:                                       ; preds = %do.body231
  %100 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end238

do.end238:                                        ; preds = %if.then233, %do.body231
  %call239 = call i32 @proc_reapurb(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body241:                                       ; preds = %LeafBlock79
  %101 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool242 = trunc i8 %101 to i1
  br i1 %tobool242, label %if.then243, label %do.end248

if.then243:                                       ; preds = %do.body241
  %102 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end248

do.end248:                                        ; preds = %if.then243, %do.body241
  %call249 = call i32 @proc_reapurbnonblock(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body251:                                       ; preds = %LeafBlock27
  %103 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool252 = trunc i8 %103 to i1
  br i1 %tobool252, label %if.then253, label %do.end258

if.then253:                                       ; preds = %do.body251
  %104 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end258

do.end258:                                        ; preds = %if.then253, %do.body251
  %call259 = call i32 @proc_disconnectsignal(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body261:                                       ; preds = %NodeBlock
  %105 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool262 = trunc i8 %105 to i1
  br i1 %tobool262, label %if.then263, label %do.end268

if.then263:                                       ; preds = %do.body261
  %106 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end268

do.end268:                                        ; preds = %if.then263, %do.body261
  %call269 = call i32 @proc_claiminterface(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body271:                                       ; preds = %LeafBlock5
  %107 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool272 = trunc i8 %107 to i1
  br i1 %tobool272, label %if.then273, label %do.end278

if.then273:                                       ; preds = %do.body271
  %108 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end278

do.end278:                                        ; preds = %if.then273, %do.body271
  %call279 = call i32 @proc_releaseinterface(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body281:                                       ; preds = %LeafBlock55
  %109 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool282 = trunc i8 %109 to i1
  br i1 %tobool282, label %if.then283, label %do.end288

if.then283:                                       ; preds = %do.body281
  %110 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end288

do.end288:                                        ; preds = %if.then283, %do.body281
  %call289 = call i32 @proc_ioctl_default(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body291:                                       ; preds = %NodeBlock11
  br i1 %tobool292, label %if.then293, label %do.end298

if.then293:                                       ; preds = %do.body291
  %111 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end298

do.end298:                                        ; preds = %if.then293, %do.body291
  %call299 = call i32 @proc_claim_port(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body301:                                       ; preds = %NodeBlock11
  br i1 %tobool292, label %if.then303, label %do.end308

if.then303:                                       ; preds = %do.body301
  %112 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end308

do.end308:                                        ; preds = %if.then303, %do.body301
  %call309 = call i32 @proc_release_port(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

sw.bb310:                                         ; preds = %LeafBlock17
  %call311 = call i32 @proc_get_capabilities(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

sw.bb312:                                         ; preds = %LeafBlock35
  %call313 = call i32 @proc_disconnect_claim(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb312, %sw.bb310, %do.end308, %do.end298, %do.end288, %do.end278, %do.end268, %do.end258, %do.end248, %do.end238, %do.end228, %do.end217, %do.end207, %do.end197, %if.then184, %do.end181, %do.end171, %if.then158, %do.end155, %if.then142, %do.end139, %if.then126, %do.end123, %do.end113, %do.end103, %do.end93, %do.end83, %if.then70, %do.end67, %do.end57, %if.then44, %do.end41, %if.then28, %do.end25, %if.then14, %do.end, %LeafBlock, %LeafBlock1, %LeafBlock5, %LeafBlock7, %LeafBlock17, %LeafBlock19, %LeafBlock21, %LeafBlock27, %LeafBlock29, %LeafBlock33, %LeafBlock35, %LeafBlock45, %LeafBlock47, %LeafBlock49, %LeafBlock55, %LeafBlock57, %LeafBlock61, %LeafBlock63, %LeafBlock71, %LeafBlock73, %LeafBlock79, %LeafBlock83, %LeafBlock85
  %ret.0 = phi i32 [ %call114, %do.end113 ], [ %call269, %do.end268 ], [ %call279, %do.end278 ], [ %call299, %do.end298 ], [ %call309, %do.end308 ], [ %call311, %sw.bb310 ], [ %call104, %do.end103 ], [ %call172, %do.end171 ], [ %call259, %do.end258 ], [ %call313, %sw.bb312 ], [ %call219, %do.end217 ], [ %call289, %do.end288 ], [ %call229, %do.end228 ], [ %call58, %do.end57 ], [ %call198, %do.end197 ], [ %call208, %do.end207 ], [ %call239, %do.end238 ], [ %call249, %do.end248 ], [ %call94, %do.end93 ], [ %call84, %do.end83 ], [ %call13, %if.then14 ], [ %call13, %do.end ], [ %call26, %if.then28 ], [ %call26, %do.end25 ], [ %call42, %if.then44 ], [ %call42, %do.end41 ], [ %call68, %if.then70 ], [ %call68, %do.end67 ], [ %call124, %if.then126 ], [ %call124, %do.end123 ], [ %call140, %if.then142 ], [ %call140, %do.end139 ], [ %call156, %if.then158 ], [ %call156, %do.end155 ], [ %call182, %if.then184 ], [ %call182, %do.end181 ], [ -25, %LeafBlock85 ], [ -25, %LeafBlock83 ], [ -25, %LeafBlock79 ], [ -25, %LeafBlock73 ], [ -25, %LeafBlock71 ], [ -25, %LeafBlock63 ], [ -25, %LeafBlock61 ], [ -25, %LeafBlock57 ], [ -25, %LeafBlock55 ], [ -25, %LeafBlock49 ], [ -25, %LeafBlock47 ], [ -25, %LeafBlock45 ], [ -25, %LeafBlock35 ], [ -25, %LeafBlock33 ], [ -25, %LeafBlock29 ], [ -25, %LeafBlock27 ], [ -25, %LeafBlock21 ], [ -25, %LeafBlock19 ], [ -25, %LeafBlock17 ], [ -25, %LeafBlock7 ], [ -25, %LeafBlock5 ], [ -25, %LeafBlock1 ], [ -25, %LeafBlock ]
  %dev314 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock.670(%struct.device* %dev314)
  %cmp315 = icmp sge i32 %ret.0, 0
  br i1 %cmp315, label %if.then316, label %if.end319

if.then316:                                       ; preds = %sw.epilog
  %i_atime = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 15
  %call317 = call { i64, i64 } @current_kernel_time()
  %113 = bitcast %struct.load_weight* %coerce318 to { i64, i64 }*
  %114 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %113, i32 0, i32 0
  %115 = extractvalue { i64, i64 } %call317, 0
  store i64 %115, i64* %114, align 8
  %116 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %113, i32 0, i32 1
  %117 = extractvalue { i64, i64 } %call317, 1
  store i64 %117, i64* %116, align 8
  %118 = bitcast %struct.load_weight* %i_atime to i8*
  %119 = bitcast %struct.load_weight* %coerce318 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %118, i8* %119, i64 16, i32 8, i1 false), !tbaa.struct !620
  br label %if.end319

if.end319:                                        ; preds = %if.then316, %sw.epilog
  %conv = sext i32 %ret.0 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end319, %if.then5, %entry
  %retval.0 = phi i64 [ %conv, %if.end319 ], [ -19, %if.then5 ], [ -1, %entry ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.inode* @file_inode(%struct.file* %f) #1 {
entry:
  %f_inode = getelementptr inbounds %struct.file, %struct.file* %f, i32 0, i32 2
  %0 = load %struct.inode*, %struct.inode** %f_inode, align 8, !tbaa !621
  ret %struct.inode* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @connected(%struct.dev_state* %ps) #0 {
entry:
  %list = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 0
  %call = call i32 @list_empty.665(%struct.list_head* %list)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !594
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp ne i32 %1, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  %land.ext = zext i1 %2 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_control(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %ctrl = alloca %struct.usbdevfs_ctrltransfer, align 8
  %_max1 = alloca i32, align 4
  %_max2 = alloca i32, align 4
  %_min1 = alloca i32, align 4
  %_min2 = alloca i32, align 4
  %_max183 = alloca i32, align 4
  %_max284 = alloca i32, align 4
  %_max1134 = alloca i32, align 4
  %_max2135 = alloca i32, align 4
  %_min1145 = alloca i32, align 4
  %_min2146 = alloca i32, align 4
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !594
  %1 = bitcast %struct.usbdevfs_ctrltransfer* %ctrl to i8*
  %2 = bitcast %struct.usbdevfs_ctrltransfer* %ctrl to i8*
  %call = call i64 @copy_from_user(i8* %2, i8* %arg, i64 24)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %bRequestType = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %3 = load i8, i8* %bRequestType, align 8, !tbaa !622
  %conv = zext i8 %3 to i32
  %bRequest = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %4 = load i8, i8* %bRequest, align 1, !tbaa !624
  %conv2 = zext i8 %4 to i32
  %wIndex = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %5 = load i16, i16* %wIndex, align 4, !tbaa !625
  %conv3 = zext i16 %5 to i32
  %call4 = call i32 @check_ctrlrecip(%struct.dev_state* %ps, i32 %conv, i32 %conv2, i32 %conv3)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %cleanup, label %if.end7

if.end7:                                          ; preds = %if.end
  %wLength8 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %6 = load i16, i16* %wLength8, align 2, !tbaa !626
  %conv9 = zext i16 %6 to i32
  %conv10 = zext i32 %conv9 to i64
  %cmp = icmp ugt i64 %conv10, 4096
  br i1 %cmp, label %cleanup, label %if.end13

if.end13:                                         ; preds = %if.end7
  %call14 = call i32 @usbfs_increase_memory_usage(i32 4296)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %cleanup, label %if.end17

if.end17:                                         ; preds = %if.end13
  %call18 = call i64 @__get_free_pages(i32 208, i32 0)
  %7 = inttoptr i64 %call18 to i8*
  %tobool19 = icmp ne i8* %7, null
  br i1 %tobool19, label %if.end21, label %done

if.end21:                                         ; preds = %if.end17
  %timeout = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 5
  %8 = load i32, i32* %timeout, align 8, !tbaa !627
  %9 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool22 = trunc i8 %9 to i1
  br i1 %tobool22, label %if.then23, label %do.end

if.then23:                                        ; preds = %if.end21
  %wValue = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 2
  %call29 = call zeroext i16 @__le16_to_cpup(i16* %wValue)
  %wIndex31 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %call32 = call zeroext i16 @__le16_to_cpup(i16* %wIndex31)
  %wLength34 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %call35 = call zeroext i16 @__le16_to_cpup(i16* %wLength34)
  %10 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then23, %if.end21
  %bRequestType39 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %11 = load i8, i8* %bRequestType39, align 8, !tbaa !622
  %conv40 = zext i8 %11 to i32
  %and = and i32 %conv40, 128
  %tobool41 = icmp ne i32 %and, 0
  %wLength43 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %12 = load i16, i16* %wLength43, align 2, !tbaa !626
  br i1 %tobool41, label %if.then42, label %if.else

if.then42:                                        ; preds = %do.end
  %conv44 = zext i16 %12 to i32
  %tobool45 = icmp ne i32 %conv44, 0
  br i1 %tobool45, label %land.lhs.true, label %if.end56

land.lhs.true:                                    ; preds = %if.then42
  %data = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 6
  %13 = load i8*, i8** %data, align 8, !tbaa !628
  %wLength46 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %14 = load i16, i16* %wLength46, align 2, !tbaa !626
  %conv47 = zext i16 %14 to i64
  %call48 = call %struct.thread_info* @current_thread_info()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call48, i32 0, i32 6
  %seg = getelementptr inbounds %struct.pgprot, %struct.pgprot* %addr_limit, i32 0, i32 0
  %15 = load i64, i64* %seg, align 8, !tbaa !629
  %16 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(i8* %13, i64 %conv47, i64 %15) #9, !srcloc !632
  %asmresult = extractvalue { i64, i64 } %16, 0
  %cmp50 = icmp eq i64 %asmresult, 0
  %lnot = xor i1 %cmp50, true
  %lnot52 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot52 to i32
  %conv53 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv53, i64 1)
  %tobool54 = icmp ne i64 %expval, 0
  br i1 %tobool54, label %if.end56, label %done

if.end56:                                         ; preds = %land.lhs.true, %if.then42
  %call57 = call i32 @__create_pipe.724(%struct.usb_device* %0, i32 0)
  %or = or i32 -2147483648, %call57
  %or58 = or i32 %or, 128
  %wLength59 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %17 = load i16, i16* %wLength59, align 2, !tbaa !626
  %conv60 = zext i16 %17 to i32
  call void @snoop_urb(i8* null, i32 0, i8* null, i32 0)
  %dev61 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock.670(%struct.device* %dev61)
  %bRequest62 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %18 = load i8, i8* %bRequest62, align 1, !tbaa !624
  %bRequestType63 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %19 = load i8, i8* %bRequestType63, align 8, !tbaa !622
  %wValue64 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 2
  %20 = load i16, i16* %wValue64, align 2, !tbaa !633
  %wIndex65 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %21 = load i16, i16* %wIndex65, align 4, !tbaa !625
  %wLength66 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %22 = load i16, i16* %wLength66, align 2, !tbaa !626
  %call67 = call i32 @usb_control_msg(%struct.usb_device* %0, i32 %or58, i8 zeroext %18, i8 zeroext %19, i16 zeroext %20, i16 zeroext %21, i8* %7, i16 zeroext %22, i32 %8)
  %dev68 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock.668(%struct.device* %dev68)
  %23 = bitcast i32* %_max1 to i8*
  store i32 %call67, i32* %_max1, align 4, !tbaa !90
  %24 = bitcast i32* %_max2 to i8*
  store i32 0, i32* %_max2, align 4, !tbaa !90
  %25 = load i32, i32* %_max1, align 4, !tbaa !90
  %26 = load i32, i32* %_max2, align 4, !tbaa !90
  %cmp72 = icmp sgt i32 %25, %26
  %27 = load i32, i32* %_max1, align 4
  %28 = load i32, i32* %_max2, align 4
  %cond = select i1 %cmp72, i32 %27, i32 %28
  %29 = bitcast i32* %_max2 to i8*
  %30 = bitcast i32* %_max1 to i8*
  %31 = bitcast i32* %_min1 to i8*
  store i32 %call67, i32* %_min1, align 4, !tbaa !90
  %32 = bitcast i32* %_min2 to i8*
  store i32 0, i32* %_min2, align 4, !tbaa !90
  %33 = load i32, i32* %_min1, align 4, !tbaa !90
  %34 = load i32, i32* %_min2, align 4, !tbaa !90
  %cmp77 = icmp slt i32 %33, %34
  %35 = load i32, i32* %_min1, align 4
  %36 = load i32, i32* %_min2, align 4
  %cond82 = select i1 %cmp77, i32 %35, i32 %36
  %37 = bitcast i32* %_min2 to i8*
  %38 = bitcast i32* %_min1 to i8*
  %39 = bitcast i32* %_max183 to i8*
  store i32 %call67, i32* %_max183, align 4, !tbaa !90
  %40 = bitcast i32* %_max284 to i8*
  store i32 0, i32* %_max284, align 4, !tbaa !90
  %41 = load i32, i32* %_max183, align 4, !tbaa !90
  %42 = load i32, i32* %_max284, align 4, !tbaa !90
  %cmp88 = icmp sgt i32 %41, %42
  %43 = load i32, i32* %_max183, align 4
  %44 = load i32, i32* %_max284, align 4
  %cond93 = select i1 %cmp88, i32 %43, i32 %44
  %45 = bitcast i32* %_max284 to i8*
  %46 = bitcast i32* %_max183 to i8*
  call void @snoop_urb(i8* null, i32 1, i8* %7, i32 %cond93)
  %cmp94 = icmp sgt i32 %call67, 0
  br i1 %cmp94, label %land.lhs.true96, label %if.end156

land.lhs.true96:                                  ; preds = %if.end56
  %wLength97 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %47 = load i16, i16* %wLength97, align 2, !tbaa !626
  %conv98 = zext i16 %47 to i32
  %tobool99 = icmp ne i32 %conv98, 0
  br i1 %tobool99, label %if.then100, label %if.end156

if.then100:                                       ; preds = %land.lhs.true96
  %data101 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 6
  %48 = load i8*, i8** %data101, align 8, !tbaa !628
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %48, i8* %7, i32 %call67) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool103 = icmp ne i32 %conv.i, 0
  br i1 %tobool103, label %done, label %if.end156

if.else:                                          ; preds = %do.end
  %tobool108 = icmp ne i16 %12, 0
  br i1 %tobool108, label %if.then109, label %if.end117

if.then109:                                       ; preds = %if.else
  %data110 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 6
  %49 = load i8*, i8** %data110, align 8, !tbaa !628
  %wLength111 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %50 = load i16, i16* %wLength111, align 2, !tbaa !626
  %conv112 = zext i16 %50 to i64
  %call113 = call i64 @copy_from_user(i8* %7, i8* %49, i64 %conv112)
  %tobool114 = icmp ne i64 %call113, 0
  br i1 %tobool114, label %done, label %if.end117

if.end117:                                        ; preds = %if.then109, %if.else
  %call118 = call i32 @__create_pipe.724(%struct.usb_device* %0, i32 0)
  %or119 = or i32 -2147483648, %call118
  %wLength120 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %51 = load i16, i16* %wLength120, align 2, !tbaa !626
  %conv121 = zext i16 %51 to i32
  %wLength122 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %52 = load i16, i16* %wLength122, align 2, !tbaa !626
  %conv123 = zext i16 %52 to i32
  call void @snoop_urb(i8* null, i32 0, i8* %7, i32 %conv123)
  %dev124 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock.670(%struct.device* %dev124)
  %call125 = call i32 @__create_pipe.724(%struct.usb_device* %0, i32 0)
  %or126 = or i32 -2147483648, %call125
  %bRequest127 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %53 = load i8, i8* %bRequest127, align 1, !tbaa !624
  %bRequestType128 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %54 = load i8, i8* %bRequestType128, align 8, !tbaa !622
  %wValue129 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 2
  %55 = load i16, i16* %wValue129, align 2, !tbaa !633
  %wIndex130 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %56 = load i16, i16* %wIndex130, align 4, !tbaa !625
  %wLength131 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %57 = load i16, i16* %wLength131, align 2, !tbaa !626
  %call132 = call i32 @usb_control_msg(%struct.usb_device* %0, i32 %or126, i8 zeroext %53, i8 zeroext %54, i16 zeroext %55, i16 zeroext %56, i8* %7, i16 zeroext %57, i32 %8)
  %dev133 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock.668(%struct.device* %dev133)
  %58 = bitcast i32* %_max1134 to i8*
  store i32 %call132, i32* %_max1134, align 4, !tbaa !90
  %59 = bitcast i32* %_max2135 to i8*
  store i32 0, i32* %_max2135, align 4, !tbaa !90
  %60 = load i32, i32* %_max1134, align 4, !tbaa !90
  %61 = load i32, i32* %_max2135, align 4, !tbaa !90
  %cmp139 = icmp sgt i32 %60, %61
  %62 = load i32, i32* %_max1134, align 4
  %63 = load i32, i32* %_max2135, align 4
  %cond144 = select i1 %cmp139, i32 %62, i32 %63
  %64 = bitcast i32* %_max2135 to i8*
  %65 = bitcast i32* %_max1134 to i8*
  %66 = bitcast i32* %_min1145 to i8*
  store i32 %call132, i32* %_min1145, align 4, !tbaa !90
  %67 = bitcast i32* %_min2146 to i8*
  store i32 0, i32* %_min2146, align 4, !tbaa !90
  %68 = load i32, i32* %_min1145, align 4, !tbaa !90
  %69 = load i32, i32* %_min2146, align 4, !tbaa !90
  %cmp150 = icmp slt i32 %68, %69
  %70 = load i32, i32* %_min1145, align 4
  %71 = load i32, i32* %_min2146, align 4
  %cond155 = select i1 %cmp150, i32 %70, i32 %71
  %72 = bitcast i32* %_min2146 to i8*
  %73 = bitcast i32* %_min1145 to i8*
  call void @snoop_urb(i8* null, i32 1, i8* null, i32 0)
  br label %if.end156

if.end156:                                        ; preds = %if.end117, %if.then100, %land.lhs.true96, %if.end56
  %i.0 = phi i32 [ %call132, %if.end117 ], [ %call67, %if.then100 ], [ %call67, %land.lhs.true96 ], [ %call67, %if.end56 ]
  %cmp157 = icmp slt i32 %i.0, 0
  %cmp160 = icmp ne i32 %i.0, -32
  %or.cond = and i1 %cmp157, %cmp160
  br i1 %or.cond, label %if.then162, label %done

if.then162:                                       ; preds = %if.end156
  %dev163 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %74 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %74, i32 0, i32 66
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %bRequestType165 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %75 = load i8, i8* %bRequestType165, align 8, !tbaa !622
  %conv166 = zext i8 %75 to i32
  %bRequest167 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %76 = load i8, i8* %bRequest167, align 1, !tbaa !624
  %conv168 = zext i8 %76 to i32
  %wLength169 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %77 = load i16, i16* %wLength169, align 2, !tbaa !626
  %conv170 = zext i16 %77 to i32
  %call171 = call i32 (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35.729, i32 0, i32 0), %struct.device* %dev163, i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.36.752, i32 0, i32 0), i8* %arraydecay, i32 %conv166, i32 %conv168, i32 %conv170, i32 %i.0)
  br label %done

done:                                             ; preds = %if.then162, %if.end156, %if.then109, %if.then100, %land.lhs.true, %if.end17
  %ret.0 = phi i32 [ -12, %if.end17 ], [ -22, %land.lhs.true ], [ -14, %if.then100 ], [ -14, %if.then109 ], [ %i.0, %if.then162 ], [ %i.0, %if.end156 ]
  %78 = ptrtoint i8* %7 to i64
  call void @free_pages(i64 %78, i32 0)
  call void @usbfs_decrease_memory_usage(i32 4296)
  br label %cleanup

cleanup:                                          ; preds = %done, %if.end13, %if.end7, %if.end, %entry
  %retval.0 = phi i32 [ %ret.0, %done ], [ -14, %entry ], [ %call4, %if.end ], [ -22, %if.end7 ], [ %call14, %if.end13 ]
  %79 = bitcast %struct.usbdevfs_ctrltransfer* %ctrl to i8*
  ret i32 %retval.0
}

declare { i64, i64 } @current_kernel_time() #2

; Function Attrs: nounwind uwtable
define internal i32 @proc_bulk(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %bulk = alloca %struct.usbdevfs_bulktransfer, align 8
  %len2 = alloca i32, align 4
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !594
  %1 = bitcast %struct.usbdevfs_bulktransfer* %bulk to i8*
  %2 = bitcast i32* %len2 to i8*
  %3 = bitcast %struct.usbdevfs_bulktransfer* %bulk to i8*
  %call = call i64 @copy_from_user(i8* %3, i8* %arg, i64 24)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev2 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8, !tbaa !594
  %ep = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %5 = load i32, i32* %ep, align 8, !tbaa !634
  %call3 = call i32 @findintfep(%struct.usb_device* %4, i32 %5)
  %cmp = icmp slt i32 %call3, 0
  br i1 %cmp, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %call6 = call i32 @checkintf(%struct.dev_state* %ps, i32 %call3)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %cleanup, label %if.end9

if.end9:                                          ; preds = %if.end5
  %ep10 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %6 = load i32, i32* %ep10, align 8, !tbaa !634
  %and = and i32 %6, 128
  %tobool11 = icmp ne i32 %and, 0
  %ep13 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %7 = load i32, i32* %ep13, align 8, !tbaa !634
  %and14 = and i32 %7, 127
  %call15 = call i32 @__create_pipe.724(%struct.usb_device* %0, i32 %and14)
  %or = or i32 -1073741824, %call15
  %or16 = or i32 %or, 128
  %pipe.0 = select i1 %tobool11, i32 %or16, i32 %or
  %ep22 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %8 = load i32, i32* %ep22, align 8, !tbaa !634
  %and23 = and i32 %8, 128
  %tobool24 = icmp ne i32 %and23, 0
  %lnot = xor i1 %tobool24, true
  %lnot.ext = zext i1 %lnot to i32
  %call25 = call zeroext i16 @usb_maxpacket.749(%struct.usb_device* %0, i32 %pipe.0, i32 %lnot.ext)
  %tobool26 = icmp ne i16 %call25, 0
  br i1 %tobool26, label %if.end28, label %cleanup

if.end28:                                         ; preds = %if.end9
  %len = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 1
  %9 = load i32, i32* %len, align 4, !tbaa !636
  %cmp29 = icmp uge i32 %9, 2146483647
  br i1 %cmp29, label %cleanup, label %if.end31

if.end31:                                         ; preds = %if.end28
  %conv = zext i32 %9 to i64
  %add = add i64 %conv, 192
  %conv32 = trunc i64 %add to i32
  %call33 = call i32 @usbfs_increase_memory_usage(i32 %conv32)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %cleanup, label %if.end36

if.end36:                                         ; preds = %if.end31
  %conv37 = zext i32 %9 to i64
  %call.i = call i8* @__kmalloc(i64 %conv37, i32 208) #8
  %tobool39 = icmp ne i8* %call.i, null
  br i1 %tobool39, label %if.end41, label %done

if.end41:                                         ; preds = %if.end36
  %timeout = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 2
  %10 = load i32, i32* %timeout, align 8, !tbaa !637
  %ep42 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %11 = load i32, i32* %ep42, align 8, !tbaa !634
  %and43 = and i32 %11, 128
  %tobool44 = icmp ne i32 %and43, 0
  %tobool46 = icmp ne i32 %9, 0
  br i1 %tobool44, label %if.then45, label %if.else73

if.then45:                                        ; preds = %if.end41
  br i1 %tobool46, label %land.lhs.true, label %if.end59

land.lhs.true:                                    ; preds = %if.then45
  %data = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %12 = load i8*, i8** %data, align 8, !tbaa !638
  %conv47 = zext i32 %9 to i64
  %call48 = call %struct.thread_info* @current_thread_info()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call48, i32 0, i32 6
  %seg = getelementptr inbounds %struct.pgprot, %struct.pgprot* %addr_limit, i32 0, i32 0
  %13 = load i64, i64* %seg, align 8, !tbaa !629
  %14 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(i8* %12, i64 %conv47, i64 %13) #9, !srcloc !639
  %asmresult = extractvalue { i64, i64 } %14, 0
  %cmp50 = icmp eq i64 %asmresult, 0
  %lnot52 = xor i1 %cmp50, true
  %lnot54 = xor i1 %lnot52, true
  %lnot.ext55 = zext i1 %lnot54 to i32
  %conv56 = sext i32 %lnot.ext55 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv56, i64 1)
  %tobool57 = icmp ne i64 %expval, 0
  br i1 %tobool57, label %if.end59, label %done

if.end59:                                         ; preds = %land.lhs.true, %if.then45
  call void @snoop_urb(i8* null, i32 0, i8* null, i32 0)
  %dev60 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock.670(%struct.device* %dev60)
  %call61 = call i32 @usb_bulk_msg(%struct.usb_device* %0, i32 %pipe.0, i8* %call.i, i32 %9, i32* %len2, i32 %10)
  %dev62 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock.668(%struct.device* %dev62)
  %15 = load i32, i32* %len2, align 4, !tbaa !90
  %16 = load i32, i32* %len2, align 4, !tbaa !90
  call void @snoop_urb(i8* null, i32 1, i8* %call.i, i32 %16)
  %tobool63 = icmp eq i32 %call61, 0
  %17 = load i32, i32* %len2, align 4
  %tobool65 = icmp ne i32 %17, 0
  %or.cond = and i1 %tobool63, %tobool65
  br i1 %or.cond, label %if.then66, label %if.end86

if.then66:                                        ; preds = %if.end59
  %data67 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %18 = load i8*, i8** %data67, align 8, !tbaa !638
  %19 = load i32, i32* %len2, align 4, !tbaa !90
  call void @might_fault() #8
  %call.i1 = call i64 @_copy_to_user(i8* %18, i8* %call.i, i32 %19) #8
  %conv.i = trunc i64 %call.i1 to i32
  %tobool69 = icmp ne i32 %conv.i, 0
  br i1 %tobool69, label %done, label %if.end86

if.else73:                                        ; preds = %if.end41
  br i1 %tobool46, label %if.then75, label %if.end82

if.then75:                                        ; preds = %if.else73
  %data76 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %20 = load i8*, i8** %data76, align 8, !tbaa !638
  %conv77 = zext i32 %9 to i64
  %call78 = call i64 @copy_from_user(i8* %call.i, i8* %20, i64 %conv77)
  %tobool79 = icmp ne i64 %call78, 0
  br i1 %tobool79, label %done, label %if.end82

if.end82:                                         ; preds = %if.then75, %if.else73
  call void @snoop_urb(i8* null, i32 0, i8* %call.i, i32 %9)
  %dev83 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock.670(%struct.device* %dev83)
  %call84 = call i32 @usb_bulk_msg(%struct.usb_device* %0, i32 %pipe.0, i8* %call.i, i32 %9, i32* %len2, i32 %10)
  %dev85 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock.668(%struct.device* %dev85)
  %21 = load i32, i32* %len2, align 4, !tbaa !90
  call void @snoop_urb(i8* null, i32 1, i8* null, i32 0)
  br label %if.end86

if.end86:                                         ; preds = %if.end82, %if.then66, %if.end59
  %i.0 = phi i32 [ %call84, %if.end82 ], [ %call61, %if.then66 ], [ %call61, %if.end59 ]
  %cmp87 = icmp slt i32 %i.0, 0
  %22 = load i32, i32* %len2, align 4
  %cond = select i1 %cmp87, i32 %i.0, i32 %22
  br label %done

done:                                             ; preds = %if.end86, %if.then75, %if.then66, %land.lhs.true, %if.end36
  %ret.0 = phi i32 [ -12, %if.end36 ], [ -22, %land.lhs.true ], [ -14, %if.then66 ], [ -14, %if.then75 ], [ %cond, %if.end86 ]
  call void @kfree(i8* %call.i)
  %conv89 = zext i32 %9 to i64
  %add90 = add i64 %conv89, 192
  %conv91 = trunc i64 %add90 to i32
  call void @usbfs_decrease_memory_usage(i32 %conv91)
  br label %cleanup

cleanup:                                          ; preds = %done, %if.end31, %if.end28, %if.end9, %if.end5, %if.end, %entry
  %retval.0 = phi i32 [ %ret.0, %done ], [ -14, %entry ], [ %call3, %if.end ], [ %call6, %if.end5 ], [ -22, %if.end9 ], [ -22, %if.end28 ], [ %call33, %if.end31 ]
  %23 = bitcast i32* %len2 to i8*
  %24 = bitcast %struct.usbdevfs_bulktransfer* %bulk to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_resetep(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4) #8, !srcloc !640
  %asmresult = extractvalue { i32*, i64 } %1, 0
  %asmresult1 = extractvalue { i32*, i64 } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !594
  %call = call i32 @findintfep(%struct.usb_device* %4, i32 %conv)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @checkintf(%struct.dev_state* %ps, i32 %call)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end4
  %dev9 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev9, align 8, !tbaa !594
  call void @usb_reset_endpoint(%struct.usb_device* %5, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end8 ], [ -14, %entry ], [ %call, %if.end ], [ %call5, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_resetdevice(%struct.dev_state* %ps) #0 {
entry:
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !594
  %call = call i32 @usb_reset_device(%struct.usb_device* %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_clearhalt(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4) #8, !srcloc !641
  %asmresult = extractvalue { i32*, i64 } %1, 0
  %asmresult1 = extractvalue { i32*, i64 } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !594
  %call = call i32 @findintfep(%struct.usb_device* %4, i32 %conv)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @checkintf(%struct.dev_state* %ps, i32 %call)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end4
  %and = and i32 %conv, 128
  %tobool9 = icmp ne i32 %and, 0
  %dev11 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev11, align 8, !tbaa !594
  %and12 = and i32 %conv, 127
  %call13 = call i32 @__create_pipe.724(%struct.usb_device* %5, i32 %and12)
  %or = or i32 -1073741824, %call13
  %or14 = or i32 %or, 128
  %pipe.0 = select i1 %tobool9, i32 %or14, i32 %or
  %dev20 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev20, align 8, !tbaa !594
  %call21 = call i32 @usb_clear_halt(%struct.usb_device* %6, i32 %pipe.0)
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call21, %if.end8 ], [ -14, %entry ], [ %call, %if.end ], [ %call5, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_getdriver(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %gd = alloca %struct.usbdevfs_getdriver, align 4
  %0 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  %1 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 260)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !594
  %interface = getelementptr inbounds %struct.usbdevfs_getdriver, %struct.usbdevfs_getdriver* %gd, i32 0, i32 0
  %3 = load i32, i32* %interface, align 4, !tbaa !642
  %call1 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %2, i32 %3)
  %tobool2 = icmp ne %struct.usb_interface* %call1, null
  br i1 %tobool2, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end
  %dev3 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev3, i32 0, i32 7
  %4 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !104
  %tobool4 = icmp ne %struct.device_driver* %4, null
  br i1 %tobool4, label %if.else, label %cleanup

if.else:                                          ; preds = %lor.lhs.false
  %driver6 = getelementptr inbounds %struct.usbdevfs_getdriver, %struct.usbdevfs_getdriver* %gd, i32 0, i32 1
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %driver6, i32 0, i32 0
  %dev7 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver8 = getelementptr inbounds %struct.device, %struct.device* %dev7, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver8, align 8, !tbaa !104
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %5, i32 0, i32 0
  %6 = load i8*, i8** %name, align 8, !tbaa !644
  %call9 = call i64 @strlcpy(i8* %arraydecay, i8* %6, i64 256)
  %7 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %arg, i8* %7, i32 260) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool11 = icmp ne i32 %conv.i, 0
  %cond = select i1 %tobool11, i32 -14, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.else, %lor.lhs.false, %if.end, %entry
  %retval.0 = phi i32 [ -14, %entry ], [ %cond, %if.else ], [ -61, %lor.lhs.false ], [ -61, %if.end ]
  %8 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_connectinfo(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %ci = alloca %struct.usbdevfs_connectinfo, align 4
  %0 = bitcast %struct.usbdevfs_connectinfo* %ci to i8*
  %devnum = getelementptr inbounds %struct.usbdevfs_connectinfo, %struct.usbdevfs_connectinfo* %ci, i32 0, i32 0
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !594
  %devnum1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 0
  %2 = load i32, i32* %devnum1, align 8, !tbaa !38
  store i32 %2, i32* %devnum, align 4, !tbaa !645
  %slow = getelementptr inbounds %struct.usbdevfs_connectinfo, %struct.usbdevfs_connectinfo* %ci, i32 0, i32 1
  %dev2 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8, !tbaa !594
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 4
  %4 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp eq i32 %4, 1
  %conv = zext i1 %cmp to i32
  %conv3 = trunc i32 %conv to i8
  store i8 %conv3, i8* %slow, align 4, !tbaa !647
  %5 = bitcast %struct.usbdevfs_connectinfo* %ci to i8*
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %arg, i8* %5, i32 8) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  %. = select i1 %tobool, i32 -14, i32 0
  %6 = bitcast %struct.usbdevfs_connectinfo* %ci to i8*
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_setintf(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %setintf = alloca %struct.exception_table_entry, align 4
  %0 = bitcast %struct.exception_table_entry* %setintf to i8*
  %1 = bitcast %struct.exception_table_entry* %setintf to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 8)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %interface = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %setintf, i32 0, i32 0
  %2 = load i32, i32* %interface, align 4, !tbaa !648
  %call1 = call i32 @checkintf(%struct.dev_state* %ps, i32 %2)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !594
  %interface5 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %setintf, i32 0, i32 0
  %4 = load i32, i32* %interface5, align 4, !tbaa !648
  %altsetting = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %setintf, i32 0, i32 1
  %5 = load i32, i32* %altsetting, align 4, !tbaa !650
  %call6 = call i32 @usb_set_interface(%struct.usb_device* %3, i32 %4, i32 %5)
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call6, %if.end4 ], [ -14, %entry ], [ %call1, %if.end ]
  %6 = bitcast %struct.exception_table_entry* %setintf to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_setconfig(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4) #8, !srcloc !651
  %asmresult = extractvalue { i32*, i64 } %1, 0
  %asmresult1 = extractvalue { i32*, i64 } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !594
  %actconfig2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 15
  %5 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig2, align 8, !tbaa !64
  %tobool3 = icmp ne %struct.usb_host_config* %5, null
  br i1 %tobool3, label %if.then4, label %if.end23

if.then4:                                         ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then4
  %i.0 = phi i32 [ 0, %if.then4 ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %6 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv5 = zext i8 %6 to i32
  %cmp = icmp slt i32 %i.0, %conv5
  br i1 %cmp, label %for.body, label %if.end23

for.body:                                         ; preds = %for.cond
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %7 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !48
  %call = call i32 @usb_interface_claimed(%struct.usb_interface* %7)
  %tobool7 = icmp ne i32 %call, 0
  br i1 %tobool7, label %if.then8, label %for.inc

if.then8:                                         ; preds = %for.body
  %8 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %9 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end23

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end23:                                         ; preds = %if.then8, %for.cond, %if.end
  %status.1 = phi i32 [ 0, %if.end ], [ -16, %if.then8 ], [ 0, %for.cond ]
  %cmp24 = icmp eq i32 %status.1, 0
  br i1 %cmp24, label %if.then26, label %cleanup

if.then26:                                        ; preds = %if.end23
  %tobool27 = icmp ne %struct.usb_host_config* %5, null
  br i1 %tobool27, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then26
  %desc28 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 0
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc28, i32 0, i32 4
  %10 = load i8, i8* %bConfigurationValue, align 1, !tbaa !147
  %conv29 = zext i8 %10 to i32
  %cmp30 = icmp eq i32 %conv29, %conv
  br i1 %cmp30, label %if.then32, label %if.else

if.then32:                                        ; preds = %land.lhs.true
  %dev33 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %11 = load %struct.usb_device*, %struct.usb_device** %dev33, align 8, !tbaa !594
  %call34 = call i32 @usb_reset_configuration(%struct.usb_device* %11)
  br label %cleanup

if.else:                                          ; preds = %land.lhs.true, %if.then26
  %dev35 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %12 = load %struct.usb_device*, %struct.usb_device** %dev35, align 8, !tbaa !594
  %call36 = call i32 @usb_set_configuration(%struct.usb_device* %12, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.then32, %if.end23, %entry
  %retval.0 = phi i32 [ -14, %entry ], [ %status.1, %if.end23 ], [ %call34, %if.then32 ], [ %call36, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_submiturb(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %uurb = alloca %struct.usbdevfs_urb, align 8
  %0 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  %1 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 56)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = bitcast i8* %arg to %struct.usbdevfs_urb*
  %iso_frame_desc = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 12
  %arraydecay = getelementptr inbounds [0 x %struct.uid_gid_extent], [0 x %struct.uid_gid_extent]* %iso_frame_desc, i32 0, i32 0
  %call1 = call i32 @proc_do_submiturb(%struct.dev_state* %ps, %struct.usbdevfs_urb* %uurb, %struct.uid_gid_extent* %arraydecay, i8* %arg)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call1, %if.end ], [ -14, %entry ]
  %3 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_control_compat(%struct.dev_state* %ps, %struct.usbdevfs_ctrltransfer32* %p32) #0 {
entry:
  %call = call i8* @compat_alloc_user_space(i64 24)
  %0 = bitcast i8* %call to %struct.usbdevfs_ctrltransfer*
  %1 = bitcast %struct.usbdevfs_ctrltransfer* %0 to i8*
  %2 = bitcast %struct.usbdevfs_ctrltransfer32* %p32 to i8*
  %call1 = call i64 @copy_in_user(i8* %1, i8* %2, i32 12)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  call void @might_fault()
  %data = getelementptr inbounds %struct.usbdevfs_ctrltransfer32, %struct.usbdevfs_ctrltransfer32* %p32, i32 0, i32 6
  %3 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %data, i64 4) #8, !srcloc !652
  %asmresult = extractvalue { i32*, i64 } %3, 0
  %asmresult2 = extractvalue { i32*, i64 } %3, 1
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  %conv = trunc i64 %asmresult2 to i32
  %tobool3 = icmp ne i32 %5, 0
  br i1 %tobool3, label %cleanup, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  call void @might_fault()
  %call5 = call i8* @compat_ptr(i32 %conv)
  %data6 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %0, i32 0, i32 6
  %6 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %call5, i8** %data6) #8, !srcloc !653
  %7 = ptrtoint i8* %6 to i64
  %8 = trunc i64 %7 to i32
  %tobool8 = icmp ne i32 %8, 0
  br i1 %tobool8, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false4
  %9 = bitcast %struct.usbdevfs_ctrltransfer* %0 to i8*
  %call9 = call i32 @proc_control(%struct.dev_state* %ps, i8* %9)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %lor.lhs.false4, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ %call9, %if.end ], [ -14, %lor.lhs.false4 ], [ -14, %lor.lhs.false ], [ -14, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_bulk_compat(%struct.dev_state* %ps, %struct.usb3_lpm_parameters* %p32) #0 {
entry:
  %call = call i8* @compat_alloc_user_space(i64 24)
  %0 = bitcast i8* %call to %struct.usbdevfs_bulktransfer*
  call void @might_fault()
  %ep = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %p32, i32 0, i32 0
  %1 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %ep, i64 4) #8, !srcloc !654
  %asmresult = extractvalue { i32*, i64 } %1, 0
  %asmresult1 = extractvalue { i32*, i64 } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  call void @might_fault()
  %ep2 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %0, i32 0, i32 0
  %4 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv, i32* %ep2) #8, !srcloc !655
  %tobool4 = icmp ne i32 %4, 0
  br i1 %tobool4, label %cleanup, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  call void @might_fault()
  %len = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %p32, i32 0, i32 1
  %5 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %len, i64 4) #8, !srcloc !656
  %asmresult8 = extractvalue { i32*, i64 } %5, 0
  %asmresult9 = extractvalue { i32*, i64 } %5, 1
  %6 = ptrtoint i32* %asmresult8 to i64
  %7 = trunc i64 %6 to i32
  %conv10 = trunc i64 %asmresult9 to i32
  %tobool12 = icmp ne i32 %7, 0
  br i1 %tobool12, label %cleanup, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %lor.lhs.false5
  call void @might_fault()
  %len16 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %0, i32 0, i32 1
  %8 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv10, i32* %len16) #8, !srcloc !657
  %tobool18 = icmp ne i32 %8, 0
  br i1 %tobool18, label %cleanup, label %lor.lhs.false19

lor.lhs.false19:                                  ; preds = %lor.lhs.false13
  call void @might_fault()
  %timeout = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %p32, i32 0, i32 2
  %9 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %timeout, i64 4) #8, !srcloc !658
  %asmresult22 = extractvalue { i32*, i64 } %9, 0
  %asmresult23 = extractvalue { i32*, i64 } %9, 1
  %10 = ptrtoint i32* %asmresult22 to i64
  %11 = trunc i64 %10 to i32
  %conv24 = trunc i64 %asmresult23 to i32
  %tobool26 = icmp ne i32 %11, 0
  br i1 %tobool26, label %cleanup, label %lor.lhs.false27

lor.lhs.false27:                                  ; preds = %lor.lhs.false19
  call void @might_fault()
  %timeout30 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %0, i32 0, i32 2
  %12 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv24, i32* %timeout30) #8, !srcloc !659
  %tobool32 = icmp ne i32 %12, 0
  br i1 %tobool32, label %cleanup, label %lor.lhs.false33

lor.lhs.false33:                                  ; preds = %lor.lhs.false27
  call void @might_fault()
  %data = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %p32, i32 0, i32 3
  %13 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %data, i64 4) #8, !srcloc !660
  %asmresult36 = extractvalue { i32*, i64 } %13, 0
  %asmresult37 = extractvalue { i32*, i64 } %13, 1
  %14 = ptrtoint i32* %asmresult36 to i64
  %15 = trunc i64 %14 to i32
  %conv38 = trunc i64 %asmresult37 to i32
  %tobool40 = icmp ne i32 %15, 0
  br i1 %tobool40, label %cleanup, label %lor.lhs.false41

lor.lhs.false41:                                  ; preds = %lor.lhs.false33
  call void @might_fault()
  %call44 = call i8* @compat_ptr(i32 %conv38)
  %data45 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %0, i32 0, i32 3
  %16 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %call44, i8** %data45) #8, !srcloc !661
  %17 = ptrtoint i8* %16 to i64
  %18 = trunc i64 %17 to i32
  %tobool47 = icmp ne i32 %18, 0
  br i1 %tobool47, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false41
  %19 = bitcast %struct.usbdevfs_bulktransfer* %0 to i8*
  %call48 = call i32 @proc_bulk(%struct.dev_state* %ps, i8* %19)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %lor.lhs.false41, %lor.lhs.false33, %lor.lhs.false27, %lor.lhs.false19, %lor.lhs.false13, %lor.lhs.false5, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ %call48, %if.end ], [ -14, %lor.lhs.false41 ], [ -14, %lor.lhs.false33 ], [ -14, %lor.lhs.false27 ], [ -14, %lor.lhs.false19 ], [ -14, %lor.lhs.false13 ], [ -14, %lor.lhs.false5 ], [ -14, %lor.lhs.false ], [ -14, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_disconnectsignal_compat(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %ds = alloca %struct.exception_table_entry, align 4
  %0 = bitcast %struct.exception_table_entry* %ds to i8*
  %1 = bitcast %struct.exception_table_entry* %ds to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 8)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %signr = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %ds, i32 0, i32 0
  %2 = load i32, i32* %signr, align 4, !tbaa !662
  %discsignr = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 7
  store i32 %2, i32* %discsignr, align 8, !tbaa !598
  %context = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %ds, i32 0, i32 1
  %3 = load i32, i32* %context, align 4, !tbaa !664
  %call1 = call i8* @compat_ptr(i32 %3)
  %disccontext = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 10
  store i8* %call1, i8** %disccontext, align 8, !tbaa !603
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -14, %entry ]
  %4 = bitcast %struct.exception_table_entry* %ds to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_submiturb_compat(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %uurb = alloca %struct.usbdevfs_urb, align 8
  %0 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  %1 = bitcast i8* %arg to %struct.usbdevfs_urb32*
  %call = call i32 @get_urb32(%struct.usbdevfs_urb* %uurb, %struct.usbdevfs_urb32* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = bitcast i8* %arg to %struct.usbdevfs_urb32*
  %iso_frame_desc = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 12
  %arraydecay = getelementptr inbounds [0 x %struct.uid_gid_extent], [0 x %struct.uid_gid_extent]* %iso_frame_desc, i32 0, i32 0
  %call1 = call i32 @proc_do_submiturb(%struct.dev_state* %ps, %struct.usbdevfs_urb* %uurb, %struct.uid_gid_extent* %arraydecay, i8* %arg)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call1, %if.end ], [ -14, %entry ]
  %3 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_reapurb_compat(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %call = call %struct.async* @reap_as(%struct.dev_state* %ps)
  %tobool = icmp ne %struct.async* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = bitcast i8* %arg to i8**
  %call2 = call i32 @processcompl_compat(%struct.async* %call, i8** %0)
  call void @free_async(%struct.async* %call)
  br label %cleanup

if.end:                                           ; preds = %entry
  %1 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %call4 = call i32 @signal_pending.717(%struct.task_struct* %1)
  %tobool5 = icmp ne i32 %call4, 0
  %. = select i1 %tobool5, i32 -4, i32 -5
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call2, %if.then ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_reapurbnonblock_compat(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %call = call %struct.async* @async_getcompleted(%struct.dev_state* %ps)
  %tobool = icmp ne %struct.async* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = bitcast i8* %arg to i8**
  %call2 = call i32 @processcompl_compat(%struct.async* %call, i8** %0)
  call void @free_async(%struct.async* %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %retval1.0 = phi i32 [ %call2, %if.then ], [ -11, %entry ]
  ret i32 %retval1.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @ptr_to_compat(i8* %uptr) #1 {
entry:
  %0 = ptrtoint i8* %uptr to i64
  %conv = trunc i64 %0 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_ioctl_compat(%struct.dev_state* %ps, i32 %arg) #0 {
entry:
  %ctrl = alloca %struct.usbdevfs_ioctl, align 8
  %0 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  %conv = zext i32 %arg to i64
  %conv1 = trunc i64 %conv to i32
  %call = call i8* @compat_ptr(i32 %conv1)
  %1 = bitcast i8* %call to %struct.uid_gid_extent*
  %call2 = call %struct.thread_info* @current_thread_info()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call2, i32 0, i32 6
  %seg = getelementptr inbounds %struct.pgprot, %struct.pgprot* %addr_limit, i32 0, i32 0
  %2 = load i64, i64* %seg, align 8, !tbaa !629
  %3 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(%struct.uid_gid_extent* %1, i64 12, i64 %2) #9, !srcloc !665
  %asmresult = extractvalue { i64, i64 } %3, 0
  %cmp = icmp eq i64 %asmresult, 0
  %lnot = xor i1 %cmp, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body, label %cleanup

do.body:                                          ; preds = %entry
  %ifno = getelementptr inbounds %struct.uid_gid_extent, %struct.uid_gid_extent* %1, i32 0, i32 0
  %4 = bitcast i32* %ifno to %struct.__large_struct*
  %5 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %4, i32 -14, i32 0) #8, !srcloc !666
  %asmresult7 = extractvalue { i32, i64 } %5, 0
  %asmresult8 = extractvalue { i32, i64 } %5, 1
  %conv9 = trunc i64 %asmresult8 to i32
  %ifno10 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 0
  store i32 %conv9, i32* %ifno10, align 8, !tbaa !667
  %tobool12 = icmp ne i32 %asmresult7, 0
  br i1 %tobool12, label %cleanup, label %do.body16

do.body16:                                        ; preds = %do.body
  %ioctl_code = getelementptr inbounds %struct.uid_gid_extent, %struct.uid_gid_extent* %1, i32 0, i32 1
  %6 = bitcast i32* %ioctl_code to %struct.__large_struct*
  %7 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %6, i32 -14, i32 0) #8, !srcloc !669
  %asmresult17 = extractvalue { i32, i64 } %7, 0
  %asmresult18 = extractvalue { i32, i64 } %7, 1
  %conv21 = trunc i64 %asmresult18 to i32
  %ioctl_code22 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 1
  store i32 %conv21, i32* %ioctl_code22, align 4, !tbaa !670
  %tobool24 = icmp ne i32 %asmresult17, 0
  br i1 %tobool24, label %cleanup, label %do.body28

do.body28:                                        ; preds = %do.body16
  %data = getelementptr inbounds %struct.uid_gid_extent, %struct.uid_gid_extent* %1, i32 0, i32 2
  %8 = bitcast i32* %data to %struct.__large_struct*
  %9 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %8, i32 -14, i32 0) #8, !srcloc !671
  %asmresult29 = extractvalue { i32, i64 } %9, 0
  %asmresult30 = extractvalue { i32, i64 } %9, 1
  %conv33 = trunc i64 %asmresult30 to i32
  %tobool35 = icmp ne i32 %asmresult29, 0
  br i1 %tobool35, label %cleanup, label %if.end

if.end:                                           ; preds = %do.body28
  %call36 = call i8* @compat_ptr(i32 %conv33)
  %data37 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 2
  store i8* %call36, i8** %data37, align 8, !tbaa !672
  %call38 = call i32 @proc_ioctl(%struct.dev_state* %ps, %struct.usbdevfs_ioctl* %ctrl)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %do.body28, %do.body16, %do.body, %entry
  %retval.0 = phi i32 [ %call38, %if.end ], [ -14, %do.body28 ], [ -14, %do.body16 ], [ -14, %do.body ], [ -14, %entry ]
  %10 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_unlinkurb(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check.663(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %call5 = call %struct.async* @async_getpending(%struct.dev_state* %ps, i8* %arg)
  %tobool = icmp ne %struct.async* %call5, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %lock6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore.664(%struct.spinlock* %lock6, i64 %call2)
  br label %cleanup

if.end:                                           ; preds = %entry
  %urb7 = getelementptr inbounds %struct.async, %struct.async* %call5, i32 0, i32 8
  %4 = load %struct.urb*, %struct.urb** %urb7, align 8, !tbaa !591
  %call8 = call %struct.urb* bitcast (%struct.urb.824* (%struct.urb.824*)* @usb_get_urb to %struct.urb* (%struct.urb*)*)(%struct.urb* %4)
  %lock9 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore.664(%struct.spinlock* %lock9, i64 %call2)
  call void bitcast (void (%struct.urb.824*)* @usb_kill_urb to void (%struct.urb*)*)(%struct.urb* %4)
  call void bitcast (void (%struct.urb.824*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %4)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ 0, %if.end ], [ -22, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_reapurb(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %call = call %struct.async* @reap_as(%struct.dev_state* %ps)
  %tobool = icmp ne %struct.async* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = bitcast i8* %arg to i8**
  %call2 = call i32 @processcompl(%struct.async* %call, i8** %0)
  call void @free_async(%struct.async* %call)
  br label %cleanup

if.end:                                           ; preds = %entry
  %1 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %call4 = call i32 @signal_pending.717(%struct.task_struct* %1)
  %tobool5 = icmp ne i32 %call4, 0
  %. = select i1 %tobool5, i32 -4, i32 -5
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call2, %if.then ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_reapurbnonblock(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %call = call %struct.async* @async_getcompleted(%struct.dev_state* %ps)
  %tobool = icmp ne %struct.async* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = bitcast i8* %arg to i8**
  %call2 = call i32 @processcompl(%struct.async* %call, i8** %0)
  call void @free_async(%struct.async* %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %retval1.0 = phi i32 [ %call2, %if.then ], [ -11, %entry ]
  ret i32 %retval1.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_disconnectsignal(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %ds = alloca %struct.usbdevfs_disconnectsignal, align 8
  %0 = bitcast %struct.usbdevfs_disconnectsignal* %ds to i8*
  %1 = bitcast %struct.usbdevfs_disconnectsignal* %ds to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 16)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %signr = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %ds, i32 0, i32 0
  %2 = load i32, i32* %signr, align 8, !tbaa !673
  %discsignr = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 7
  store i32 %2, i32* %discsignr, align 8, !tbaa !598
  %context = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %ds, i32 0, i32 1
  %3 = load i8*, i8** %context, align 8, !tbaa !675
  %disccontext = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 10
  store i8* %3, i8** %disccontext, align 8, !tbaa !603
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -14, %entry ]
  %4 = bitcast %struct.usbdevfs_disconnectsignal* %ds to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_claiminterface(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4) #8, !srcloc !676
  %asmresult = extractvalue { i32*, i64 } %1, 0
  %asmresult1 = extractvalue { i32*, i64 } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @claimintf(%struct.dev_state* %ps, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call, %if.end ], [ -14, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_releaseinterface(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4) #8, !srcloc !677
  %asmresult = extractvalue { i32*, i64 } %1, 0
  %asmresult1 = extractvalue { i32*, i64 } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @releaseintf(%struct.dev_state* %ps, i32 %conv)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  call void @destroy_async_on_interface(%struct.dev_state* %ps, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end4 ], [ -14, %entry ], [ %call, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_ioctl_default(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %ctrl = alloca %struct.usbdevfs_ioctl, align 8
  %0 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  %1 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 16)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @proc_ioctl(%struct.dev_state* %ps, %struct.usbdevfs_ioctl* %ctrl)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call1, %if.end ], [ -14, %entry ]
  %2 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_claim_port(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4) #8, !srcloc !678
  %asmresult = extractvalue { i32*, i64 } %1, 0
  %asmresult1 = extractvalue { i32*, i64 } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !594
  %call = call i32 @usb_hub_claim_port(%struct.usb_device* %4, i32 %conv, %struct.dev_state* %ps)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %do.body, label %cleanup

do.body:                                          ; preds = %if.end
  %5 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool4 = trunc i8 %5 to i1
  br i1 %tobool4, label %if.then5, label %cleanup

if.then5:                                         ; preds = %do.body
  %6 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  call void @task_pid_nr(%struct.task_struct* %6)
  %7 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %8 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then5, %do.body, %if.end, %entry
  %retval.0 = phi i32 [ -14, %entry ], [ %call, %do.body ], [ %call, %if.then5 ], [ %call, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_release_port(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4) #8, !srcloc !679
  %asmresult = extractvalue { i32*, i64 } %1, 0
  %asmresult1 = extractvalue { i32*, i64 } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !594
  %call = call i32 @usb_hub_release_port(%struct.usb_device* %4, i32 %conv, %struct.dev_state* %ps)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call, %if.end ], [ -14, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_get_capabilities(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !594
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %no_stop_on_short = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %1, i32 0, i32 6
  %bf.load = load i8, i8* %no_stop_on_short, align 1
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  %or = or i32 5, 2
  %.or = select i1 %tobool, i32 5, i32 %or
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !594
  %bus2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 9
  %3 = load %struct.usb_bus*, %struct.usb_bus** %bus2, align 8, !tbaa !2
  %sg_tablesize = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %3, i32 0, i32 7
  %4 = load i32, i32* %sg_tablesize, align 4, !tbaa !464
  %tobool3 = icmp ne i32 %4, 0
  %or5 = or i32 %.or, 8
  %caps.1 = select i1 %tobool3, i32 %or5, i32 %.or
  call void @might_fault()
  %5 = bitcast i8* %arg to i32*
  %6 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %caps.1, i32* %5) #8, !srcloc !680
  %tobool7 = icmp ne i32 %6, 0
  %. = select i1 %tobool7, i32 -14, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_disconnect_claim(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %dc = alloca %struct.usbdevfs_disconnect_claim, align 4
  %0 = bitcast %struct.usbdevfs_disconnect_claim* %dc to i8*
  %1 = bitcast %struct.usbdevfs_disconnect_claim* %dc to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 264)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup45, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !594
  %interface = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 0
  %3 = load i32, i32* %interface, align 4, !tbaa !681
  %call1 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %2, i32 %3)
  %tobool2 = icmp ne %struct.usb_interface* %call1, null
  br i1 %tobool2, label %if.end4, label %cleanup45

if.end4:                                          ; preds = %if.end
  %dev5 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev5, i32 0, i32 7
  %4 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !104
  %tobool6 = icmp ne %struct.device_driver* %4, null
  br i1 %tobool6, label %if.then7, label %if.end42

if.then7:                                         ; preds = %if.end4
  %dev9 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver10 = getelementptr inbounds %struct.device, %struct.device* %dev9, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver10, align 8, !tbaa !104
  %6 = bitcast %struct.device_driver* %5 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 -168
  %7 = bitcast i8* %add.ptr to %struct.usb_driver*
  %flags = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 1
  %8 = load i32, i32* %flags, align 4, !tbaa !683
  %and = and i32 %8, 1
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.then7
  %driver12 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 2
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %driver12, i32 0, i32 0
  %dev13 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver14 = getelementptr inbounds %struct.device, %struct.device* %dev13, i32 0, i32 7
  %9 = load %struct.device_driver*, %struct.device_driver** %driver14, align 8, !tbaa !104
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %9, i32 0, i32 0
  %10 = load i8*, i8** %name, align 8, !tbaa !644
  %call15 = call i32 @strncmp(i8* %arraydecay, i8* %10, i64 256)
  %cmp = icmp ne i32 %call15, 0
  br i1 %cmp, label %LeafBlock, label %if.end17

if.end17:                                         ; preds = %land.lhs.true, %if.then7
  %flags18 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 1
  %11 = load i32, i32* %flags18, align 4, !tbaa !683
  %and19 = and i32 %11, 2
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %land.lhs.true21, label %do.body31

land.lhs.true21:                                  ; preds = %if.end17
  %driver22 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 2
  %arraydecay23 = getelementptr inbounds [256 x i8], [256 x i8]* %driver22, i32 0, i32 0
  %dev24 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver25 = getelementptr inbounds %struct.device, %struct.device* %dev24, i32 0, i32 7
  %12 = load %struct.device_driver*, %struct.device_driver** %driver25, align 8, !tbaa !104
  %name26 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %12, i32 0, i32 0
  %13 = load i8*, i8** %name26, align 8, !tbaa !644
  %call27 = call i32 @strncmp(i8* %arraydecay23, i8* %13, i64 256)
  %cmp28 = icmp eq i32 %call27, 0
  br i1 %cmp28, label %LeafBlock, label %do.body31

do.body31:                                        ; preds = %land.lhs.true21, %if.end17
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @proc_disconnect_claim.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and32 = and i32 %bf.clear, 1
  %tobool33 = icmp ne i32 %and32, 0
  %lnot = xor i1 %tobool33, true
  %lnot34 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot34 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool35 = icmp ne i64 %expval, 0
  br i1 %tobool35, label %if.then36, label %do.end41

if.then36:                                        ; preds = %do.body31
  %dev37 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %call38 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @proc_disconnect_claim.descriptor to %struct._ddebug*), %struct.device* %dev37, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.60.709, i32 0, i32 0))
  br label %do.end41

do.end41:                                         ; preds = %if.then36, %do.body31
  call void @usb_driver_release_interface(%struct.usb_driver* %7, %struct.usb_interface* %call1)
  br label %LeafBlock

LeafBlock:                                        ; preds = %do.end41, %land.lhs.true21, %land.lhs.true
  %cleanup.dest.slot.0 = phi i32 [ 0, %do.end41 ], [ 1, %land.lhs.true ], [ 1, %land.lhs.true21 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end42, label %cleanup45

if.end42:                                         ; preds = %LeafBlock, %if.end4
  %interface43 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 0
  %14 = load i32, i32* %interface43, align 4, !tbaa !681
  %call44 = call i32 @claimintf(%struct.dev_state* %ps, i32 %14)
  br label %cleanup45

cleanup45:                                        ; preds = %if.end42, %LeafBlock, %if.end, %entry
  %retval.1 = phi i32 [ %call44, %if.end42 ], [ -14, %entry ], [ -22, %if.end ], [ -16, %LeafBlock ]
  %15 = bitcast %struct.usbdevfs_disconnect_claim* %dc to i8*
  ret i32 %retval.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @copy_from_user(i8* %to, i8* %from, i64 %n) #1 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %cmp = icmp eq i32 %conv, -1
  %conv2 = sext i32 %conv to i64
  %cmp3 = icmp uge i64 %conv2, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp3
  %lnot = xor i1 %1, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %conv7 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv7)
  br label %if.end24

if.else:                                          ; preds = %entry
  %tobool8 = icmp ne i32 1, 0
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  br i1 %tobool15, label %if.then16, label %if.end

if.then16:                                        ; preds = %if.else
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.37.713, i32 0, i32 0), i32 66, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.38.714, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then16, %if.else
  br label %if.end24

if.end24:                                         ; preds = %if.end, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.end ]
  ret i64 %n.addr.0
}

; Function Attrs: nounwind uwtable
define internal i32 @claimintf(%struct.dev_state* %ps, i32 %ifnum) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !594
  %conv = zext i32 %ifnum to i64
  %cmp = icmp uge i64 %conv, 64
  br i1 %cmp, label %cleanup, label %cond.false

cond.false:                                       ; preds = %entry
  %ifclaimed3 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 11
  %call4 = call i32 @variable_test_bit.669(i32 %ifnum, i64* %ifclaimed3)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %cleanup, label %if.end7

if.end7:                                          ; preds = %cond.false
  %call8 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %0, i32 %ifnum)
  %tobool9 = icmp ne %struct.usb_interface* %call8, null
  br i1 %tobool9, label %if.else, label %if.end12

if.else:                                          ; preds = %if.end7
  %1 = bitcast %struct.dev_state* %ps to i8*
  %call11 = call i32 @usb_driver_claim_interface(%struct.usb_driver* @usbfs_driver, %struct.usb_interface* %call8, i8* %1)
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.end7
  %err.0 = phi i32 [ %call11, %if.else ], [ -2, %if.end7 ]
  %cmp13 = icmp eq i32 %err.0, 0
  br i1 %cmp13, label %if.then15, label %cleanup

if.then15:                                        ; preds = %if.end12
  %ifclaimed16 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %ifclaimed16, i32 %ifnum, i64* %ifclaimed16) #8, !srcloc !684
  br label %cleanup

cleanup:                                          ; preds = %if.then15, %if.end12, %cond.false, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ 0, %cond.false ], [ %err.0, %if.then15 ], [ %err.0, %if.end12 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #7

declare void @might_fault() #2

declare i64 @_copy_from_user(i8*, i8*, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @proc_ioctl(%struct.dev_state* %ps, %struct.usbdevfs_ioctl* %ctl) #0 {
entry:
  %ioctl_code = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %0 = load i32, i32* %ioctl_code, align 4, !tbaa !670
  %shr = ashr i32 %0, 16
  %and = and i32 %shr, 16383
  %cmp = icmp sgt i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end17

if.then:                                          ; preds = %entry
  %conv = sext i32 %and to i64
  %call.i = call i8* @__kmalloc(i64 %conv, i32 208) #8
  %cmp2 = icmp eq i8* %call.i, null
  br i1 %cmp2, label %cleanup, label %if.end

if.end:                                           ; preds = %if.then
  %ioctl_code5 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %1 = load i32, i32* %ioctl_code5, align 4, !tbaa !670
  %shr6 = ashr i32 %1, 30
  %and7 = and i32 %shr6, 3
  %and8 = and i32 %and7, 1
  %tobool = icmp ne i32 %and8, 0
  br i1 %tobool, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.end
  %data = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 2
  %2 = load i8*, i8** %data, align 8, !tbaa !672
  %conv10 = sext i32 %and to i64
  %call11 = call i64 @copy_from_user(i8* %call.i, i8* %2, i64 %conv10)
  %tobool12 = icmp ne i64 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end17

if.then13:                                        ; preds = %if.then9
  call void @kfree(i8* %call.i)
  br label %cleanup

if.else:                                          ; preds = %if.end
  %conv15 = sext i32 %and to i64
  call void @llvm.memset.p0i8.i64(i8* %call.i, i8 0, i64 %conv15, i32 1, i1 false)
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.then9, %entry
  %buf.0 = phi i8* [ null, %entry ], [ %call.i, %if.then9 ], [ %call.i, %if.else ]
  %call18 = call i32 @connected(%struct.dev_state* %ps)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %if.end17
  call void @kfree(i8* %buf.0)
  br label %cleanup

if.end21:                                         ; preds = %if.end17
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !594
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 3
  %4 = load i32, i32* %state, align 8, !tbaa !50
  %cmp22 = icmp ne i32 %4, 7
  br i1 %cmp22, label %if.end86, label %if.else25

if.else25:                                        ; preds = %if.end21
  %dev26 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev26, align 8, !tbaa !594
  %ifno = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 0
  %6 = load i32, i32* %ifno, align 8, !tbaa !667
  %call27 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %5, i32 %6)
  %tobool28 = icmp ne %struct.usb_interface* %call27, null
  br i1 %tobool28, label %if.else30, label %if.end86

if.else30:                                        ; preds = %if.else25
  %ioctl_code31 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %7 = load i32, i32* %ioctl_code31, align 4, !tbaa !670
  %Pivot = icmp slt i32 %7, 21783
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.else30
  %SwitchLeaf2 = icmp eq i32 %7, 21783
  br i1 %SwitchLeaf2, label %sw.bb52, label %sw.default

LeafBlock:                                        ; preds = %if.else30
  %SwitchLeaf = icmp eq i32 %7, 21782
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %dev32 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call27, i32 0, i32 7
  %driver33 = getelementptr inbounds %struct.device, %struct.device* %dev32, i32 0, i32 7
  %8 = load %struct.device_driver*, %struct.device_driver** %driver33, align 8, !tbaa !104
  %tobool34 = icmp ne %struct.device_driver* %8, null
  br i1 %tobool34, label %if.then35, label %if.end86

if.then35:                                        ; preds = %sw.bb
  %dev36 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call27, i32 0, i32 7
  %driver37 = getelementptr inbounds %struct.device, %struct.device* %dev36, i32 0, i32 7
  %9 = load %struct.device_driver*, %struct.device_driver** %driver37, align 8, !tbaa !104
  %10 = bitcast %struct.device_driver* %9 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %10, i64 -168
  %11 = bitcast i8* %add.ptr to %struct.usb_driver*
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @proc_ioctl.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and39 = and i32 %bf.clear, 1
  %tobool40 = icmp ne i32 %and39, 0
  %lnot = xor i1 %tobool40, true
  %lnot41 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot41 to i32
  %conv42 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv42, i64 0)
  %tobool43 = icmp ne i64 %expval, 0
  br i1 %tobool43, label %if.then44, label %do.end49

if.then44:                                        ; preds = %if.then35
  %dev45 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call27, i32 0, i32 7
  %call46 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @proc_ioctl.descriptor to %struct._ddebug*), %struct.device* %dev45, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.60.709, i32 0, i32 0))
  br label %do.end49

do.end49:                                         ; preds = %if.then44, %if.then35
  call void @usb_driver_release_interface(%struct.usb_driver* %11, %struct.usb_interface* %call27)
  br label %if.end86

sw.bb52:                                          ; preds = %LeafBlock1
  %dev53 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call27, i32 0, i32 7
  %driver54 = getelementptr inbounds %struct.device, %struct.device* %dev53, i32 0, i32 7
  %12 = load %struct.device_driver*, %struct.device_driver** %driver54, align 8, !tbaa !104
  %tobool55 = icmp ne %struct.device_driver* %12, null
  br i1 %tobool55, label %if.end86, label %if.then56

if.then56:                                        ; preds = %sw.bb52
  %dev57 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call27, i32 0, i32 7
  %call58 = call i32 @device_attach(%struct.device* %dev57)
  br label %if.end86

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %dev61 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call27, i32 0, i32 7
  %driver62 = getelementptr inbounds %struct.device, %struct.device* %dev61, i32 0, i32 7
  %13 = load %struct.device_driver*, %struct.device_driver** %driver62, align 8, !tbaa !104
  %tobool63 = icmp ne %struct.device_driver* %13, null
  br i1 %tobool63, label %if.then64, label %if.end70

if.then64:                                        ; preds = %sw.default
  %dev66 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call27, i32 0, i32 7
  %driver67 = getelementptr inbounds %struct.device, %struct.device* %dev66, i32 0, i32 7
  %14 = load %struct.device_driver*, %struct.device_driver** %driver67, align 8, !tbaa !104
  %15 = bitcast %struct.device_driver* %14 to i8*
  %add.ptr69 = getelementptr inbounds i8, i8* %15, i64 -168
  %16 = bitcast i8* %add.ptr69 to %struct.usb_driver*
  br label %if.end70

if.end70:                                         ; preds = %if.then64, %sw.default
  %driver.0 = phi %struct.usb_driver* [ %16, %if.then64 ], [ null, %sw.default ]
  %cmp71 = icmp eq %struct.usb_driver* %driver.0, null
  br i1 %cmp71, label %if.end86, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end70
  %unlocked_ioctl = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver.0, i32 0, i32 3
  %17 = load i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32, i8*)** %unlocked_ioctl, align 8, !tbaa !685
  %cmp73 = icmp eq i32 (%struct.usb_interface*, i32, i8*)* %17, null
  br i1 %cmp73, label %if.end86, label %if.else76

if.else76:                                        ; preds = %lor.lhs.false
  %unlocked_ioctl77 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver.0, i32 0, i32 3
  %18 = load i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32, i8*)** %unlocked_ioctl77, align 8, !tbaa !685
  %ioctl_code78 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %19 = load i32, i32* %ioctl_code78, align 4, !tbaa !670
  %call79 = call i32 %18(%struct.usb_interface* %call27, i32 %19, i8* %buf.0)
  %cmp80 = icmp eq i32 %call79, -515
  %.call79 = select i1 %cmp80, i32 -25, i32 %call79
  br label %if.end86

if.end86:                                         ; preds = %if.else76, %lor.lhs.false, %if.end70, %if.then56, %sw.bb52, %do.end49, %sw.bb, %if.else25, %if.end21
  %retval1.6 = phi i32 [ -113, %if.end21 ], [ -22, %if.else25 ], [ 0, %do.end49 ], [ -61, %sw.bb ], [ %call58, %if.then56 ], [ -16, %sw.bb52 ], [ %.call79, %if.else76 ], [ -25, %lor.lhs.false ], [ -25, %if.end70 ]
  %cmp87 = icmp sge i32 %retval1.6, 0
  br i1 %cmp87, label %land.lhs.true, label %if.end104

land.lhs.true:                                    ; preds = %if.end86
  %ioctl_code89 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %20 = load i32, i32* %ioctl_code89, align 4, !tbaa !670
  %shr90 = ashr i32 %20, 30
  %and91 = and i32 %shr90, 3
  %and92 = and i32 %and91, 2
  %cmp93 = icmp ne i32 %and92, 0
  %cmp96 = icmp sgt i32 %and, 0
  %or.cond = and i1 %cmp93, %cmp96
  br i1 %or.cond, label %land.lhs.true98, label %if.end104

land.lhs.true98:                                  ; preds = %land.lhs.true
  %data99 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 2
  %21 = load i8*, i8** %data99, align 8, !tbaa !672
  call void @might_fault() #8
  %call.i1 = call i64 @_copy_to_user(i8* %21, i8* %buf.0, i32 %and) #8
  %conv.i = trunc i64 %call.i1 to i32
  %cmp101 = icmp ne i32 %conv.i, 0
  %.retval1.6 = select i1 %cmp101, i32 -14, i32 %retval1.6
  br label %if.end104

if.end104:                                        ; preds = %land.lhs.true98, %land.lhs.true, %if.end86
  %retval1.7 = phi i32 [ %retval1.6, %land.lhs.true ], [ %retval1.6, %if.end86 ], [ %.retval1.6, %land.lhs.true98 ]
  call void @kfree(i8* %buf.0)
  br label %cleanup

cleanup:                                          ; preds = %if.end104, %if.then20, %if.then13, %if.then
  %retval.0 = phi i32 [ -14, %if.then13 ], [ %retval1.7, %if.end104 ], [ -19, %if.then20 ], [ -12, %if.then ]
  ret i32 %retval.0
}

declare i64 @_copy_to_user(i8*, i8*, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @processcompl(%struct.async* %as, i8** %arg) #0 {
entry:
  %urb1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %0 = load %struct.urb*, %struct.urb** %urb1, align 8, !tbaa !591
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 7
  %1 = load i8*, i8** %userurb2, align 8, !tbaa !686
  %2 = bitcast i8* %1 to %struct.usbdevfs_urb*
  %userurb3 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 7
  %3 = load i8*, i8** %userurb3, align 8, !tbaa !686
  %userbuffer = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 6
  %4 = load i8*, i8** %userbuffer, align 8, !tbaa !687
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %entry
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %5 = load i32, i32* %actual_length, align 4, !tbaa !292
  %tobool4 = icmp ne i32 %5, 0
  br i1 %tobool4, label %if.then, label %if.end8

if.then:                                          ; preds = %land.lhs.true
  %userbuffer5 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 6
  %6 = load i8*, i8** %userbuffer5, align 8, !tbaa !687
  %call = call i32 @copy_urb_data_to_user(i8* %6, %struct.urb* %0)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.then, %land.lhs.true, %entry
  call void @might_fault()
  %status = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 10
  %7 = load i32, i32* %status, align 4, !tbaa !688
  %status9 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 2
  %8 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %7, i32* %status9) #8, !srcloc !689
  %tobool10 = icmp ne i32 %8, 0
  br i1 %tobool10, label %cleanup, label %if.end12

if.end12:                                         ; preds = %if.end8
  call void @might_fault()
  %actual_length15 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %9 = load i32, i32* %actual_length15, align 4, !tbaa !292
  %actual_length16 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 6
  %10 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %9, i32* %actual_length16) #8, !srcloc !690
  %tobool18 = icmp ne i32 %10, 0
  br i1 %tobool18, label %cleanup, label %if.end20

if.end20:                                         ; preds = %if.end12
  call void @might_fault()
  %error_count = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 26
  %11 = load i32, i32* %error_count, align 4, !tbaa !691
  %error_count23 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 9
  %12 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %11, i32* %error_count23) #8, !srcloc !692
  %tobool25 = icmp ne i32 %12, 0
  br i1 %tobool25, label %cleanup, label %if.end27

if.end27:                                         ; preds = %if.end20
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 9
  %13 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !218
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %13, i32 0, i32 0
  %call28 = call i32 @usb_endpoint_xfer_isoc.716(%struct.usb_endpoint_descriptor* %desc)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then30, label %if.end56

if.then30:                                        ; preds = %if.end27
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then30
  %i.0 = phi i32 [ 0, %if.then30 ], [ %inc, %for.inc ]
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 24
  %14 = load i32, i32* %number_of_packets, align 4, !tbaa !427
  %cmp = icmp ult i32 %i.0, %14
  br i1 %cmp, label %for.body, label %if.end56

for.body:                                         ; preds = %for.cond
  call void @might_fault()
  %iso_frame_desc = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 29
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb3_lpm_parameters], [0 x %struct.usb3_lpm_parameters]* %iso_frame_desc, i64 0, i64 %idxprom
  %actual_length33 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %arrayidx, i32 0, i32 2
  %15 = load i32, i32* %actual_length33, align 8, !tbaa !431
  %iso_frame_desc34 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 12
  %idxprom35 = zext i32 %i.0 to i64
  %arrayidx36 = getelementptr inbounds [0 x %struct.uid_gid_extent], [0 x %struct.uid_gid_extent]* %iso_frame_desc34, i64 0, i64 %idxprom35
  %actual_length37 = getelementptr inbounds %struct.uid_gid_extent, %struct.uid_gid_extent* %arrayidx36, i32 0, i32 1
  %16 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %15, i32* %actual_length37) #8, !srcloc !693
  %tobool39 = icmp ne i32 %16, 0
  br i1 %tobool39, label %cleanup, label %if.end41

if.end41:                                         ; preds = %for.body
  call void @might_fault()
  %iso_frame_desc44 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 29
  %idxprom45 = zext i32 %i.0 to i64
  %arrayidx46 = getelementptr inbounds [0 x %struct.usb3_lpm_parameters], [0 x %struct.usb3_lpm_parameters]* %iso_frame_desc44, i64 0, i64 %idxprom45
  %status47 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %arrayidx46, i32 0, i32 3
  %17 = load i32, i32* %status47, align 4, !tbaa !430
  %iso_frame_desc48 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 12
  %idxprom49 = zext i32 %i.0 to i64
  %arrayidx50 = getelementptr inbounds [0 x %struct.uid_gid_extent], [0 x %struct.uid_gid_extent]* %iso_frame_desc48, i64 0, i64 %idxprom49
  %status51 = getelementptr inbounds %struct.uid_gid_extent, %struct.uid_gid_extent* %arrayidx50, i32 0, i32 2
  %18 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %17, i32* %status51) #8, !srcloc !694
  %tobool53 = icmp ne i32 %18, 0
  br i1 %tobool53, label %cleanup, label %for.inc

for.inc:                                          ; preds = %if.end41
  %inc = add i32 %i.0, 1
  br label %for.cond

if.end56:                                         ; preds = %for.cond, %if.end27
  call void @might_fault()
  %19 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %3, i8** %arg) #8, !srcloc !695
  %20 = ptrtoint i8* %19 to i64
  %21 = trunc i64 %20 to i32
  %tobool60 = icmp ne i32 %21, 0
  %. = select i1 %tobool60, i32 -14, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end56, %if.end41, %for.body, %if.end20, %if.end12, %if.end8, %if.then
  %retval.0 = phi i32 [ %., %if.end56 ], [ -14, %if.end41 ], [ -14, %for.body ], [ -14, %if.end20 ], [ -14, %if.end12 ], [ -14, %if.end8 ], [ -14, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @copy_urb_data_to_user(i8* %userbuffer, %struct.urb* %urb) #0 {
entry:
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 24
  %0 = load i32, i32* %number_of_packets, align 4, !tbaa !427
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %1 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !294
  br label %if.end

if.else:                                          ; preds = %entry
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %2 = load i32, i32* %actual_length, align 4, !tbaa !292
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %len.0 = phi i32 [ %1, %if.then ], [ %2, %if.else ]
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %3 = load i32, i32* %num_sgs, align 4, !tbaa !330
  %cmp1 = icmp eq i32 %3, 0
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %4 = load i8*, i8** %transfer_buffer, align 8, !tbaa !293
  call void @might_fault() #8
  %call.i1 = call i64 @_copy_to_user(i8* %userbuffer, i8* %4, i32 %len.0) #8
  %conv.i2 = trunc i64 %call.i1 to i32
  %tobool = icmp ne i32 %conv.i2, 0
  %. = select i1 %tobool, i32 -14, i32 0
  br label %cleanup

if.end5:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %if.end5
  %len.1 = phi i32 [ %len.0, %if.end5 ], [ %sub, %if.end14 ]
  %i.0 = phi i32 [ 0, %if.end5 ], [ %inc, %if.end14 ]
  %userbuffer.addr.0 = phi i8* [ %userbuffer, %if.end5 ], [ %add.ptr, %if.end14 ]
  %num_sgs6 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %5 = load i32, i32* %num_sgs6, align 4, !tbaa !330
  %cmp7 = icmp ult i32 %i.0, %5
  %tobool8 = icmp ne i32 %len.1, 0
  %tobool8. = select i1 %cmp7, i1 %tobool8, i1 false
  br i1 %tobool8., label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %cmp9 = icmp ugt i32 %len.1, 16384
  %.len.1 = select i1 %cmp9, i32 16384, i32 %len.1
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 16
  %6 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8, !tbaa !329
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %6, i64 %idxprom
  %call10 = call i8* @sg_virt.672(%struct.scatterlist* %arrayidx)
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %userbuffer.addr.0, i8* %call10, i32 %.len.1) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool12 = icmp ne i32 %conv.i, 0
  br i1 %tobool12, label %cleanup, label %if.end14

if.end14:                                         ; preds = %for.body
  %idx.ext = zext i32 %.len.1 to i64
  %add.ptr = getelementptr inbounds i8, i8* %userbuffer.addr.0, i64 %idx.ext
  %sub = sub i32 %len.1, %.len.1
  %inc = add i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.body, %for.cond, %if.then2
  %retval.0 = phi i32 [ %., %if.then2 ], [ -14, %for.body ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_isoc.716(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 1
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define internal %struct.async* @reap_as(%struct.dev_state* %ps) #0 {
entry:
  %wait = alloca %struct.__wait_queue, align 8
  %__ret = alloca i64, align 8
  %0 = bitcast %struct.__wait_queue* %wait to i8*
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !246
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 1
  %1 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %2 = bitcast %struct.task_struct* %1 to i8*
  store i8* %2, i8** %private, align 8, !tbaa !248
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @default_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !249
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  store %struct.list_head* null, %struct.list_head** %next, align 8, !tbaa !95
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  store %struct.list_head* null, %struct.list_head** %prev, align 8, !tbaa !96
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !594
  %wait2 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 6
  call void @add_wait_queue(%struct.__wait_queue_head* %wait2, %struct.__wait_queue* %wait)
  br label %for.cond

for.cond:                                         ; preds = %if.end9, %entry
  %4 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %state = getelementptr inbounds %struct.task_struct, %struct.task_struct* %4, i32 0, i32 0
  store volatile i64 1, i64* %state, align 8, !tbaa !696
  %call4 = call %struct.async* @async_getcompleted(%struct.dev_state* %ps)
  %tobool = icmp ne %struct.async* %call4, null
  br i1 %tobool, label %for.end, label %if.end

if.end:                                           ; preds = %for.cond
  %5 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %call6 = call i32 @signal_pending.717(%struct.task_struct* %5)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %for.end, label %if.end9

if.end9:                                          ; preds = %if.end
  %dev10 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 11
  call void @device_unlock.670(%struct.device* %dev10)
  call void @schedule()
  %dev11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 11
  call void @device_lock.668(%struct.device* %dev11)
  br label %for.cond

for.end:                                          ; preds = %if.end, %for.cond
  %wait12 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 6
  call void @remove_wait_queue(%struct.__wait_queue_head* %wait12, %struct.__wait_queue* %wait)
  %6 = bitcast i64* %__ret to i8*
  store volatile i64 0, i64* %__ret, align 8, !tbaa !49
  %7 = load volatile i64, i64* %__ret, align 8, !tbaa !49
  %8 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %state15 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %8, i32 0, i32 0
  %9 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %state15, i64 %7, i64* %state15) #8, !srcloc !697
  store volatile i64 %9, i64* %__ret, align 8, !tbaa !49
  %10 = load volatile i64, i64* %__ret, align 8, !tbaa !49
  %11 = bitcast i64* %__ret to i8*
  %12 = bitcast %struct.__wait_queue* %wait to i8*
  ret %struct.async* %call4
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @signal_pending.717(%struct.task_struct* %p) #1 {
entry:
  %call = call i32 @test_tsk_thread_flag.718(%struct.task_struct* %p, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_tsk_thread_flag.718(%struct.task_struct* %tsk, i32 %flag) #1 {
entry:
  %stack = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i32 0, i32 1
  %0 = load i8*, i8** %stack, align 8, !tbaa !252
  %1 = bitcast i8* %0 to %struct.thread_info*
  %call = call i32 @test_ti_thread_flag.719(%struct.thread_info* %1, i32 %flag)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_ti_thread_flag.719(%struct.thread_info* %ti, i32 %flag) #1 {
entry:
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i32 0, i32 2
  %0 = bitcast i32* %flags to i64*
  %call = call i32 @variable_test_bit.669(i32 %flag, i64* %0)
  ret i32 %call
}

declare i32 @default_wake_function(%struct.__wait_queue*, i32, i32, i8*) #2

declare void @add_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #2

declare void @remove_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #2

; Function Attrs: nounwind uwtable
define internal %struct.async* @async_getpending(%struct.dev_state* %ps, i8* %userurb) #0 {
entry:
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %asynclist6.sink = phi %struct.list_head* [ %asynclist4, %for.inc ], [ %async_pending, %entry ]
  %next7 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist6.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next7, align 8, !tbaa !48
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr9 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr9 to %struct.async*
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 0
  %async_pending1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  %cmp = icmp ne %struct.list_head* %asynclist, %async_pending1
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 7
  %3 = load i8*, i8** %userurb2, align 8, !tbaa !686
  %cmp3 = icmp eq i8* %3, %userurb
  %asynclist4 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 0
  br i1 %cmp3, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @list_del_init.666(%struct.list_head* %asynclist4)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond
  %retval.0 = phi %struct.async* [ %2, %if.then ], [ null, %for.cond ]
  ret %struct.async* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info() #1 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #4, !srcloc !698
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: nounwind uwtable
define internal i32 @processcompl_compat(%struct.async* %as, i8** %arg) #0 {
entry:
  %urb1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %0 = load %struct.urb*, %struct.urb** %urb1, align 8, !tbaa !591
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 7
  %1 = load i8*, i8** %userurb2, align 8, !tbaa !686
  %2 = bitcast i8* %1 to %struct.usbdevfs_urb32*
  %userurb3 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 7
  %3 = load i8*, i8** %userurb3, align 8, !tbaa !686
  %userbuffer = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 6
  %4 = load i8*, i8** %userbuffer, align 8, !tbaa !687
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %entry
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %5 = load i32, i32* %actual_length, align 4, !tbaa !292
  %tobool4 = icmp ne i32 %5, 0
  br i1 %tobool4, label %if.then, label %if.end8

if.then:                                          ; preds = %land.lhs.true
  %userbuffer5 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 6
  %6 = load i8*, i8** %userbuffer5, align 8, !tbaa !687
  %call = call i32 @copy_urb_data_to_user(i8* %6, %struct.urb* %0)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.then, %land.lhs.true, %entry
  call void @might_fault()
  %status = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 10
  %7 = load i32, i32* %status, align 4, !tbaa !688
  %status9 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 2
  %8 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %7, i32* %status9) #8, !srcloc !699
  %tobool10 = icmp ne i32 %8, 0
  br i1 %tobool10, label %cleanup, label %if.end12

if.end12:                                         ; preds = %if.end8
  call void @might_fault()
  %actual_length15 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %9 = load i32, i32* %actual_length15, align 4, !tbaa !292
  %actual_length16 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 6
  %10 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %9, i32* %actual_length16) #8, !srcloc !700
  %tobool18 = icmp ne i32 %10, 0
  br i1 %tobool18, label %cleanup, label %if.end20

if.end20:                                         ; preds = %if.end12
  call void @might_fault()
  %error_count = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 26
  %11 = load i32, i32* %error_count, align 4, !tbaa !691
  %error_count23 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 9
  %12 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %11, i32* %error_count23) #8, !srcloc !701
  %tobool25 = icmp ne i32 %12, 0
  br i1 %tobool25, label %cleanup, label %if.end27

if.end27:                                         ; preds = %if.end20
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 9
  %13 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !218
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %13, i32 0, i32 0
  %call28 = call i32 @usb_endpoint_xfer_isoc.716(%struct.usb_endpoint_descriptor* %desc)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then30, label %if.end56

if.then30:                                        ; preds = %if.end27
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then30
  %i.0 = phi i32 [ 0, %if.then30 ], [ %inc, %for.inc ]
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 24
  %14 = load i32, i32* %number_of_packets, align 4, !tbaa !427
  %cmp = icmp ult i32 %i.0, %14
  br i1 %cmp, label %for.body, label %if.end56

for.body:                                         ; preds = %for.cond
  call void @might_fault()
  %iso_frame_desc = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 29
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb3_lpm_parameters], [0 x %struct.usb3_lpm_parameters]* %iso_frame_desc, i64 0, i64 %idxprom
  %actual_length33 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %arrayidx, i32 0, i32 2
  %15 = load i32, i32* %actual_length33, align 8, !tbaa !431
  %iso_frame_desc34 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 12
  %idxprom35 = zext i32 %i.0 to i64
  %arrayidx36 = getelementptr inbounds [0 x %struct.uid_gid_extent], [0 x %struct.uid_gid_extent]* %iso_frame_desc34, i64 0, i64 %idxprom35
  %actual_length37 = getelementptr inbounds %struct.uid_gid_extent, %struct.uid_gid_extent* %arrayidx36, i32 0, i32 1
  %16 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %15, i32* %actual_length37) #8, !srcloc !702
  %tobool39 = icmp ne i32 %16, 0
  br i1 %tobool39, label %cleanup, label %if.end41

if.end41:                                         ; preds = %for.body
  call void @might_fault()
  %iso_frame_desc44 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 29
  %idxprom45 = zext i32 %i.0 to i64
  %arrayidx46 = getelementptr inbounds [0 x %struct.usb3_lpm_parameters], [0 x %struct.usb3_lpm_parameters]* %iso_frame_desc44, i64 0, i64 %idxprom45
  %status47 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %arrayidx46, i32 0, i32 3
  %17 = load i32, i32* %status47, align 4, !tbaa !430
  %iso_frame_desc48 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 12
  %idxprom49 = zext i32 %i.0 to i64
  %arrayidx50 = getelementptr inbounds [0 x %struct.uid_gid_extent], [0 x %struct.uid_gid_extent]* %iso_frame_desc48, i64 0, i64 %idxprom49
  %status51 = getelementptr inbounds %struct.uid_gid_extent, %struct.uid_gid_extent* %arrayidx50, i32 0, i32 2
  %18 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %17, i32* %status51) #8, !srcloc !703
  %tobool53 = icmp ne i32 %18, 0
  br i1 %tobool53, label %cleanup, label %for.inc

for.inc:                                          ; preds = %if.end41
  %inc = add i32 %i.0, 1
  br label %for.cond

if.end56:                                         ; preds = %for.cond, %if.end27
  call void @might_fault()
  %call59 = call i32 @ptr_to_compat(i8* %3)
  %19 = bitcast i8** %arg to i32*
  %20 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %call59, i32* %19) #8, !srcloc !704
  %tobool61 = icmp ne i32 %20, 0
  %. = select i1 %tobool61, i32 -14, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end56, %if.end41, %for.body, %if.end20, %if.end12, %if.end8, %if.then
  %retval.0 = phi i32 [ -14, %if.then ], [ -14, %if.end8 ], [ -14, %if.end12 ], [ -14, %if.end20 ], [ -14, %for.body ], [ -14, %if.end41 ], [ %., %if.end56 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @get_urb32(%struct.usbdevfs_urb* %kurb, %struct.usbdevfs_urb32* %uurb) #0 {
entry:
  %call = call %struct.thread_info* @current_thread_info()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 6
  %seg = getelementptr inbounds %struct.pgprot, %struct.pgprot* %addr_limit, i32 0, i32 0
  %0 = load i64, i64* %seg, align 8, !tbaa !629
  %1 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(%struct.usbdevfs_urb32* %uurb, i64 44, i64 %0) #9, !srcloc !705
  %asmresult = extractvalue { i64, i64 } %1, 0
  %cmp = icmp eq i64 %asmresult, 0
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body, label %cleanup

do.body:                                          ; preds = %entry
  %type = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 0
  %2 = bitcast i8* %type to %struct.__large_struct*
  %3 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movb $2,${1:b}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorb ${1:b},${1:b}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=q,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %2, i32 -14, i32 0) #8, !srcloc !706
  %asmresult3 = extractvalue { i32, i64 } %3, 0
  %asmresult4 = extractvalue { i32, i64 } %3, 1
  %conv5 = trunc i64 %asmresult4 to i8
  %type6 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 0
  store i8 %conv5, i8* %type6, align 8, !tbaa !707
  %tobool8 = icmp ne i32 %asmresult3, 0
  br i1 %tobool8, label %cleanup, label %do.body12

do.body12:                                        ; preds = %do.body
  %endpoint = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 1
  %4 = bitcast i8* %endpoint to %struct.__large_struct*
  %5 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movb $2,${1:b}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorb ${1:b},${1:b}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=q,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %4, i32 -14, i32 0) #8, !srcloc !709
  %asmresult13 = extractvalue { i32, i64 } %5, 0
  %asmresult14 = extractvalue { i32, i64 } %5, 1
  %conv17 = trunc i64 %asmresult14 to i8
  %endpoint18 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 1
  store i8 %conv17, i8* %endpoint18, align 1, !tbaa !710
  %tobool20 = icmp ne i32 %asmresult13, 0
  br i1 %tobool20, label %cleanup, label %do.body24

do.body24:                                        ; preds = %do.body12
  %status = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 2
  %6 = bitcast i32* %status to %struct.__large_struct*
  %7 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %6, i32 -14, i32 0) #8, !srcloc !711
  %asmresult25 = extractvalue { i32, i64 } %7, 0
  %asmresult26 = extractvalue { i32, i64 } %7, 1
  %conv29 = trunc i64 %asmresult26 to i32
  %status30 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 2
  store i32 %conv29, i32* %status30, align 4, !tbaa !712
  %tobool32 = icmp ne i32 %asmresult25, 0
  br i1 %tobool32, label %cleanup, label %do.body36

do.body36:                                        ; preds = %do.body24
  %flags = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 3
  %8 = bitcast i32* %flags to %struct.__large_struct*
  %9 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %8, i32 -14, i32 0) #8, !srcloc !713
  %asmresult37 = extractvalue { i32, i64 } %9, 0
  %asmresult38 = extractvalue { i32, i64 } %9, 1
  %conv41 = trunc i64 %asmresult38 to i32
  %flags42 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 3
  store i32 %conv41, i32* %flags42, align 8, !tbaa !714
  %tobool44 = icmp ne i32 %asmresult37, 0
  br i1 %tobool44, label %cleanup, label %do.body48

do.body48:                                        ; preds = %do.body36
  %buffer_length = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 5
  %10 = bitcast i32* %buffer_length to %struct.__large_struct*
  %11 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %10, i32 -14, i32 0) #8, !srcloc !715
  %asmresult49 = extractvalue { i32, i64 } %11, 0
  %asmresult50 = extractvalue { i32, i64 } %11, 1
  %conv53 = trunc i64 %asmresult50 to i32
  %buffer_length54 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 5
  store i32 %conv53, i32* %buffer_length54, align 8, !tbaa !716
  %tobool56 = icmp ne i32 %asmresult49, 0
  br i1 %tobool56, label %cleanup, label %do.body60

do.body60:                                        ; preds = %do.body48
  %actual_length = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 6
  %12 = bitcast i32* %actual_length to %struct.__large_struct*
  %13 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %12, i32 -14, i32 0) #8, !srcloc !717
  %asmresult61 = extractvalue { i32, i64 } %13, 0
  %asmresult62 = extractvalue { i32, i64 } %13, 1
  %conv65 = trunc i64 %asmresult62 to i32
  %actual_length66 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 6
  store i32 %conv65, i32* %actual_length66, align 4, !tbaa !718
  %tobool68 = icmp ne i32 %asmresult61, 0
  br i1 %tobool68, label %cleanup, label %do.body72

do.body72:                                        ; preds = %do.body60
  %start_frame = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 7
  %14 = bitcast i32* %start_frame to %struct.__large_struct*
  %15 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %14, i32 -14, i32 0) #8, !srcloc !719
  %asmresult73 = extractvalue { i32, i64 } %15, 0
  %asmresult74 = extractvalue { i32, i64 } %15, 1
  %conv77 = trunc i64 %asmresult74 to i32
  %start_frame78 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 7
  store i32 %conv77, i32* %start_frame78, align 8, !tbaa !720
  %tobool80 = icmp ne i32 %asmresult73, 0
  br i1 %tobool80, label %cleanup, label %do.body84

do.body84:                                        ; preds = %do.body72
  %number_of_packets = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 8
  %16 = bitcast i32* %number_of_packets to %struct.__large_struct*
  %17 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %16, i32 -14, i32 0) #8, !srcloc !721
  %asmresult85 = extractvalue { i32, i64 } %17, 0
  %asmresult86 = extractvalue { i32, i64 } %17, 1
  %conv89 = trunc i64 %asmresult86 to i32
  %number_of_packets90 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 8
  store i32 %conv89, i32* %number_of_packets90, align 4, !tbaa !722
  %tobool92 = icmp ne i32 %asmresult85, 0
  br i1 %tobool92, label %cleanup, label %do.body96

do.body96:                                        ; preds = %do.body84
  %error_count = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 9
  %18 = bitcast i32* %error_count to %struct.__large_struct*
  %19 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %18, i32 -14, i32 0) #8, !srcloc !723
  %asmresult97 = extractvalue { i32, i64 } %19, 0
  %asmresult98 = extractvalue { i32, i64 } %19, 1
  %conv101 = trunc i64 %asmresult98 to i32
  %error_count102 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 9
  store i32 %conv101, i32* %error_count102, align 8, !tbaa !724
  %tobool104 = icmp ne i32 %asmresult97, 0
  br i1 %tobool104, label %cleanup, label %do.body108

do.body108:                                       ; preds = %do.body96
  %signr = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 10
  %20 = bitcast i32* %signr to %struct.__large_struct*
  %21 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %20, i32 -14, i32 0) #8, !srcloc !725
  %asmresult109 = extractvalue { i32, i64 } %21, 0
  %asmresult110 = extractvalue { i32, i64 } %21, 1
  %conv113 = trunc i64 %asmresult110 to i32
  %signr114 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 10
  store i32 %conv113, i32* %signr114, align 4, !tbaa !726
  %tobool116 = icmp ne i32 %asmresult109, 0
  br i1 %tobool116, label %cleanup, label %do.body119

do.body119:                                       ; preds = %do.body108
  %buffer = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 4
  %22 = bitcast i32* %buffer to %struct.__large_struct*
  %23 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %22, i32 -14, i32 0) #8, !srcloc !727
  %asmresult120 = extractvalue { i32, i64 } %23, 0
  %asmresult121 = extractvalue { i32, i64 } %23, 1
  %conv124 = trunc i64 %asmresult121 to i32
  %tobool126 = icmp ne i32 %asmresult120, 0
  br i1 %tobool126, label %cleanup, label %if.end128

if.end128:                                        ; preds = %do.body119
  %call129 = call i8* @compat_ptr(i32 %conv124)
  %buffer130 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 4
  store i8* %call129, i8** %buffer130, align 8, !tbaa !728
  %usercontext = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 11
  %24 = bitcast i32* %usercontext to %struct.__large_struct*
  %25 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %24, i32 -14, i32 0) #8, !srcloc !729
  %asmresult134 = extractvalue { i32, i64 } %25, 0
  %asmresult135 = extractvalue { i32, i64 } %25, 1
  %conv138 = trunc i64 %asmresult135 to i32
  %tobool140 = icmp ne i32 %asmresult134, 0
  br i1 %tobool140, label %cleanup, label %if.end142

if.end142:                                        ; preds = %if.end128
  %call143 = call i8* @compat_ptr(i32 %conv138)
  %usercontext144 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 11
  store i8* %call143, i8** %usercontext144, align 8, !tbaa !730
  br label %cleanup

cleanup:                                          ; preds = %if.end142, %if.end128, %do.body119, %do.body108, %do.body96, %do.body84, %do.body72, %do.body60, %do.body48, %do.body36, %do.body24, %do.body12, %do.body, %entry
  %retval.0 = phi i32 [ 0, %if.end142 ], [ -14, %do.body108 ], [ -14, %do.body96 ], [ -14, %do.body84 ], [ -14, %do.body72 ], [ -14, %do.body60 ], [ -14, %do.body48 ], [ -14, %do.body36 ], [ -14, %do.body24 ], [ -14, %do.body12 ], [ -14, %do.body ], [ -14, %entry ], [ -14, %do.body119 ], [ -14, %if.end128 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_do_submiturb(%struct.dev_state* %ps, %struct.usbdevfs_urb* %uurb, %struct.uid_gid_extent* %iso_frame_desc, i8* %arg) #0 {
entry:
  %_min1 = alloca i32, align 4
  %_min2 = alloca i32, align 4
  %flags = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %0 = load i32, i32* %flags, align 8, !tbaa !714
  %and = and i32 %0, -232
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %buffer_length = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %1 = load i32, i32* %buffer_length, align 8, !tbaa !716
  %cmp = icmp sgt i32 %1, 0
  br i1 %cmp, label %land.lhs.true, label %if.end3

land.lhs.true:                                    ; preds = %if.end
  %buffer = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %2 = load i8*, i8** %buffer, align 8, !tbaa !728
  %tobool1 = icmp ne i8* %2, null
  br i1 %tobool1, label %if.end3, label %cleanup

if.end3:                                          ; preds = %land.lhs.true, %if.end
  %type = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  %3 = load i8, i8* %type, align 8, !tbaa !707
  %conv = zext i8 %3 to i32
  %cmp4 = icmp eq i32 %conv, 2
  br i1 %cmp4, label %land.lhs.true6, label %if.then11

land.lhs.true6:                                   ; preds = %if.end3
  %endpoint = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %4 = load i8, i8* %endpoint, align 1, !tbaa !710
  %conv7 = zext i8 %4 to i32
  %and8 = and i32 %conv7, -129
  %cmp9 = icmp eq i32 %and8, 0
  br i1 %cmp9, label %if.end22, label %if.then11

if.then11:                                        ; preds = %land.lhs.true6, %if.end3
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !594
  %endpoint12 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %6 = load i8, i8* %endpoint12, align 1, !tbaa !710
  %conv13 = zext i8 %6 to i32
  %call = call i32 @findintfep(%struct.usb_device* %5, i32 %conv13)
  %cmp14 = icmp slt i32 %call, 0
  br i1 %cmp14, label %cleanup, label %if.end17

if.end17:                                         ; preds = %if.then11
  %call18 = call i32 @checkintf(%struct.dev_state* %ps, i32 %call)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %cleanup, label %if.end22

if.end22:                                         ; preds = %if.end17, %land.lhs.true6
  %ifnum.0 = phi i32 [ -1, %land.lhs.true6 ], [ %call, %if.end17 ]
  %endpoint23 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %7 = load i8, i8* %endpoint23, align 1, !tbaa !710
  %conv24 = zext i8 %7 to i32
  %and25 = and i32 %conv24, 128
  %cmp26 = icmp ne i32 %and25, 0
  %dev29 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %8 = load %struct.usb_device*, %struct.usb_device** %dev29, align 8, !tbaa !594
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 17
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 16
  %ep_out.sink = select i1 %cmp26, [16 x %struct.usb_host_endpoint*]* %ep_in, [16 x %struct.usb_host_endpoint*]* %ep_out
  %is_in.0 = select i1 %cmp26, i32 1, i32 0
  %endpoint34 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %9 = load i8, i8* %endpoint34, align 1, !tbaa !710
  %conv35 = zext i8 %9 to i32
  %and36 = and i32 %conv35, 15
  %idxprom37 = sext i32 %and36 to i64
  %arrayidx38 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out.sink, i64 0, i64 %idxprom37
  %10 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx38, align 8, !tbaa !48
  %tobool40 = icmp ne %struct.usb_host_endpoint* %10, null
  br i1 %tobool40, label %if.end42, label %cleanup

if.end42:                                         ; preds = %if.end22
  %type43 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  %11 = load i8, i8* %type43, align 8, !tbaa !707
  %conv44 = zext i8 %11 to i32
  %Pivot6 = icmp slt i32 %conv44, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %if.end42
  %Pivot4 = icmp slt i32 %conv44, 3
  br i1 %Pivot4, label %sw.bb, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %conv44, 3
  br i1 %SwitchLeaf2, label %sw.bb118, label %cleanup

NodeBlock:                                        ; preds = %if.end42
  %Pivot = icmp slt i32 %conv44, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb134

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv44, 0
  br i1 %SwitchLeaf, label %sw.bb141, label %cleanup

sw.bb:                                            ; preds = %NodeBlock3
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %call45 = call i32 @usb_endpoint_xfer_control.720(%struct.usb_endpoint_descriptor* %desc)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %if.end48, label %cleanup

if.end48:                                         ; preds = %sw.bb
  %buffer_length49 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %12 = load i32, i32* %buffer_length49, align 8, !tbaa !716
  %cmp50 = icmp slt i32 %12, 8
  br i1 %cmp50, label %cleanup, label %if.end53

if.end53:                                         ; preds = %if.end48
  %call.i4 = call i8* @__kmalloc(i64 8, i32 208) #8
  %13 = bitcast i8* %call.i4 to %struct.usb_ctrlrequest*
  %tobool55 = icmp ne %struct.usb_ctrlrequest* %13, null
  br i1 %tobool55, label %if.end57, label %cleanup

if.end57:                                         ; preds = %if.end53
  %14 = bitcast %struct.usb_ctrlrequest* %13 to i8*
  %buffer58 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %15 = load i8*, i8** %buffer58, align 8, !tbaa !728
  %call59 = call i64 @copy_from_user(i8* %14, i8* %15, i64 8)
  %tobool60 = icmp ne i64 %call59, 0
  br i1 %tobool60, label %error, label %if.end62

if.end62:                                         ; preds = %if.end57
  %buffer_length63 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %16 = load i32, i32* %buffer_length63, align 8, !tbaa !716
  %wLength = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 4
  %call64 = call zeroext i16 @__le16_to_cpup(i16* %wLength)
  %conv65 = zext i16 %call64 to i32
  %add = add nsw i32 %conv65, 8
  %cmp66 = icmp slt i32 %16, %add
  br i1 %cmp66, label %error, label %if.end69

if.end69:                                         ; preds = %if.end62
  %bRequestType = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 0
  %17 = load i8, i8* %bRequestType, align 1, !tbaa !394
  %conv70 = zext i8 %17 to i32
  %bRequest = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 1
  %18 = load i8, i8* %bRequest, align 1, !tbaa !396
  %conv71 = zext i8 %18 to i32
  %wIndex = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 3
  %call72 = call zeroext i16 @__le16_to_cpup(i16* %wIndex)
  %conv73 = zext i16 %call72 to i32
  %call74 = call i32 @check_ctrlrecip(%struct.dev_state* %ps, i32 %conv70, i32 %conv71, i32 %conv73)
  %tobool75 = icmp ne i32 %call74, 0
  br i1 %tobool75, label %error, label %if.end77

if.end77:                                         ; preds = %if.end69
  %number_of_packets = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  store i32 0, i32* %number_of_packets, align 4, !tbaa !722
  %wLength78 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 4
  %call79 = call zeroext i16 @__le16_to_cpup(i16* %wLength78)
  %conv80 = zext i16 %call79 to i32
  %buffer_length81 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  store i32 %conv80, i32* %buffer_length81, align 8, !tbaa !716
  %buffer82 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %19 = load i8*, i8** %buffer82, align 8, !tbaa !728
  %add.ptr = getelementptr i8, i8* %19, i64 8
  store i8* %add.ptr, i8** %buffer82, align 8, !tbaa !728
  %bRequestType83 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 0
  %20 = load i8, i8* %bRequestType83, align 1, !tbaa !394
  %conv84 = zext i8 %20 to i32
  %and85 = and i32 %conv84, 128
  %tobool86 = icmp ne i32 %and85, 0
  br i1 %tobool86, label %land.lhs.true87, label %if.else94

land.lhs.true87:                                  ; preds = %if.end77
  %buffer_length88 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %21 = load i32, i32* %buffer_length88, align 8, !tbaa !716
  %tobool89 = icmp ne i32 %21, 0
  br i1 %tobool89, label %if.then90, label %if.else94

if.then90:                                        ; preds = %land.lhs.true87
  %endpoint91 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %22 = load i8, i8* %endpoint91, align 1, !tbaa !710
  %conv92 = zext i8 %22 to i32
  %or = or i32 %conv92, 128
  br label %if.end99

if.else94:                                        ; preds = %land.lhs.true87, %if.end77
  %endpoint95 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %23 = load i8, i8* %endpoint95, align 1, !tbaa !710
  %conv96 = zext i8 %23 to i32
  %and97 = and i32 %conv96, -129
  br label %if.end99

if.end99:                                         ; preds = %if.else94, %if.then90
  %and97.sink = phi i32 [ %and97, %if.else94 ], [ %or, %if.then90 ]
  %endpoint95.sink = phi i8* [ %endpoint95, %if.else94 ], [ %endpoint91, %if.then90 ]
  %is_in.1 = phi i32 [ 1, %if.then90 ], [ 0, %if.else94 ]
  %conv98 = trunc i32 %and97.sink to i8
  store i8 %conv98, i8* %endpoint95.sink, align 1, !tbaa !710
  %24 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool100 = trunc i8 %24 to i1
  br i1 %tobool100, label %if.then101, label %sw.epilog186

if.then101:                                       ; preds = %if.end99
  %wValue = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 2
  %call108 = call zeroext i16 @__le16_to_cpup(i16* %wValue)
  %wIndex110 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 3
  %call111 = call zeroext i16 @__le16_to_cpup(i16* %wIndex110)
  %wLength113 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 4
  %call114 = call zeroext i16 @__le16_to_cpup(i16* %wLength113)
  %25 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %sw.epilog186

sw.bb118:                                         ; preds = %LeafBlock1
  %desc119 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %call120 = call i32 @usb_endpoint_type.722(%struct.usb_endpoint_descriptor* %desc119)
  %Pivot13 = icmp slt i32 %call120, 3
  br i1 %Pivot13, label %LeafBlock8, label %LeafBlock10

LeafBlock10:                                      ; preds = %sw.bb118
  %SwitchLeaf11 = icmp eq i32 %call120, 3
  br i1 %SwitchLeaf11, label %sw.bb122, label %sw.epilog

LeafBlock8:                                       ; preds = %sw.bb118
  %SwitchLeaf9 = icmp ule i32 %call120, 1
  br i1 %SwitchLeaf9, label %cleanup, label %sw.epilog

sw.bb122:                                         ; preds = %LeafBlock10
  %type123 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  store i8 1, i8* %type123, align 8, !tbaa !707
  br label %interrupt_urb

sw.epilog:                                        ; preds = %LeafBlock8, %LeafBlock10
  %number_of_packets124 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  store i32 0, i32* %number_of_packets124, align 4, !tbaa !722
  %buffer_length125 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %26 = load i32, i32* %buffer_length125, align 8, !tbaa !716
  %add126 = add nsw i32 %26, 16384
  %sub = sub nsw i32 %add126, 1
  %div = sdiv i32 %sub, 16384
  %cmp127 = icmp eq i32 %div, 1
  br i1 %cmp127, label %if.then132, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.epilog
  %dev129 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %27 = load %struct.usb_device*, %struct.usb_device** %dev129, align 8, !tbaa !594
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %27, i32 0, i32 9
  %28 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %sg_tablesize = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %28, i32 0, i32 7
  %29 = load i32, i32* %sg_tablesize, align 4, !tbaa !464
  %cmp130 = icmp ugt i32 %div, %29
  br i1 %cmp130, label %if.then132, label %sw.epilog186

if.then132:                                       ; preds = %lor.lhs.false, %sw.epilog
  br label %sw.epilog186

sw.bb134:                                         ; preds = %NodeBlock
  %desc135 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %call136 = call i32 @usb_endpoint_xfer_int.723(%struct.usb_endpoint_descriptor* %desc135)
  %tobool137 = icmp ne i32 %call136, 0
  br i1 %tobool137, label %interrupt_urb, label %cleanup

interrupt_urb:                                    ; preds = %sw.bb134, %sw.bb122
  %number_of_packets140 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  store i32 0, i32* %number_of_packets140, align 4, !tbaa !722
  br label %sw.epilog186

sw.bb141:                                         ; preds = %LeafBlock
  %number_of_packets142 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %30 = load i32, i32* %number_of_packets142, align 4, !tbaa !722
  %cmp143 = icmp slt i32 %30, 1
  br i1 %cmp143, label %cleanup, label %lor.lhs.false145

lor.lhs.false145:                                 ; preds = %sw.bb141
  %number_of_packets146 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %31 = load i32, i32* %number_of_packets146, align 4, !tbaa !722
  %cmp147 = icmp sgt i32 %31, 128
  br i1 %cmp147, label %cleanup, label %if.end150

if.end150:                                        ; preds = %lor.lhs.false145
  %desc151 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %call152 = call i32 @usb_endpoint_xfer_isoc.716(%struct.usb_endpoint_descriptor* %desc151)
  %tobool153 = icmp ne i32 %call152, 0
  br i1 %tobool153, label %if.end155, label %cleanup

if.end155:                                        ; preds = %if.end150
  %number_of_packets156 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %32 = load i32, i32* %number_of_packets156, align 4, !tbaa !722
  %conv157 = sext i32 %32 to i64
  %mul = mul i64 12, %conv157
  %conv158 = trunc i64 %mul to i32
  %conv159 = zext i32 %conv158 to i64
  %call.i3 = call i8* @__kmalloc(i64 %conv159, i32 208) #8
  %33 = bitcast i8* %call.i3 to %struct.uid_gid_extent*
  %tobool161 = icmp ne %struct.uid_gid_extent* %33, null
  br i1 %tobool161, label %if.end163, label %cleanup

if.end163:                                        ; preds = %if.end155
  %34 = bitcast %struct.uid_gid_extent* %33 to i8*
  %35 = bitcast %struct.uid_gid_extent* %iso_frame_desc to i8*
  %conv164 = zext i32 %conv158 to i64
  %call165 = call i64 @copy_from_user(i8* %34, i8* %35, i64 %conv164)
  %tobool166 = icmp ne i64 %call165, 0
  br i1 %tobool166, label %error, label %if.end168

if.end168:                                        ; preds = %if.end163
  br label %for.cond

for.cond:                                         ; preds = %if.end177, %if.end168
  %totlen.0 = phi i32 [ 0, %if.end168 ], [ %add181, %if.end177 ]
  %u.0 = phi i32 [ 0, %if.end168 ], [ %inc, %if.end177 ]
  %number_of_packets169 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %36 = load i32, i32* %number_of_packets169, align 4, !tbaa !722
  %cmp170 = icmp ult i32 %u.0, %36
  %idxprom172 = zext i32 %u.0 to i64
  br i1 %cmp170, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arrayidx173 = getelementptr inbounds %struct.uid_gid_extent, %struct.uid_gid_extent* %33, i64 %idxprom172
  %length = getelementptr inbounds %struct.uid_gid_extent, %struct.uid_gid_extent* %arrayidx173, i32 0, i32 0
  %37 = load i32, i32* %length, align 4, !tbaa !731
  %cmp174 = icmp ugt i32 %37, 49152
  br i1 %cmp174, label %error, label %if.end177

if.end177:                                        ; preds = %for.body
  %idxprom178 = zext i32 %u.0 to i64
  %arrayidx179 = getelementptr inbounds %struct.uid_gid_extent, %struct.uid_gid_extent* %33, i64 %idxprom178
  %length180 = getelementptr inbounds %struct.uid_gid_extent, %struct.uid_gid_extent* %arrayidx179, i32 0, i32 0
  %38 = load i32, i32* %length180, align 4, !tbaa !731
  %add181 = add i32 %totlen.0, %38
  %inc = add i32 %u.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %mul183 = mul i64 %idxprom172, 16
  %conv184 = trunc i64 %mul183 to i32
  %buffer_length185 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  store i32 %totlen.0, i32* %buffer_length185, align 8, !tbaa !716
  br label %sw.epilog186

sw.epilog186:                                     ; preds = %for.end, %interrupt_urb, %if.then132, %lor.lhs.false, %if.then101, %if.end99
  %u.1 = phi i32 [ %conv184, %for.end ], [ 0, %interrupt_urb ], [ 8, %if.then101 ], [ 8, %if.end99 ], [ 0, %if.then132 ], [ 0, %lor.lhs.false ]
  %dr.0 = phi %struct.usb_ctrlrequest* [ null, %for.end ], [ null, %interrupt_urb ], [ %13, %if.then101 ], [ %13, %if.end99 ], [ null, %if.then132 ], [ null, %lor.lhs.false ]
  %isopkt.0 = phi %struct.uid_gid_extent* [ %33, %for.end ], [ null, %interrupt_urb ], [ null, %if.then101 ], [ null, %if.end99 ], [ null, %if.then132 ], [ null, %lor.lhs.false ]
  %is_in.2 = phi i32 [ %is_in.0, %for.end ], [ %is_in.0, %interrupt_urb ], [ %is_in.1, %if.then101 ], [ %is_in.1, %if.end99 ], [ %is_in.0, %if.then132 ], [ %is_in.0, %lor.lhs.false ]
  %num_sgs.1 = phi i32 [ 0, %for.end ], [ 0, %interrupt_urb ], [ 0, %if.then101 ], [ 0, %if.end99 ], [ 0, %if.then132 ], [ %div, %lor.lhs.false ]
  %buffer_length187 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %39 = load i32, i32* %buffer_length187, align 8, !tbaa !716
  %cmp188 = icmp uge i32 %39, 2146483647
  br i1 %cmp188, label %error, label %if.end191

if.end191:                                        ; preds = %sw.epilog186
  %buffer_length192 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %40 = load i32, i32* %buffer_length192, align 8, !tbaa !716
  %cmp193 = icmp sgt i32 %40, 0
  br i1 %cmp193, label %land.lhs.true195, label %if.end207

land.lhs.true195:                                 ; preds = %if.end191
  %buffer196 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %41 = load i8*, i8** %buffer196, align 8, !tbaa !728
  %buffer_length197 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %42 = load i32, i32* %buffer_length197, align 8, !tbaa !716
  %conv198 = sext i32 %42 to i64
  %call199 = call %struct.thread_info* @current_thread_info()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call199, i32 0, i32 6
  %seg = getelementptr inbounds %struct.pgprot, %struct.pgprot* %addr_limit, i32 0, i32 0
  %43 = load i64, i64* %seg, align 8, !tbaa !629
  %44 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(i8* %41, i64 %conv198, i64 %43) #9, !srcloc !733
  %asmresult = extractvalue { i64, i64 } %44, 0
  %cmp201 = icmp eq i64 %asmresult, 0
  %lnot = xor i1 %cmp201, true
  %lnot203 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot203 to i32
  %conv204 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv204, i64 1)
  %tobool205 = icmp ne i64 %expval, 0
  br i1 %tobool205, label %if.end207, label %error

if.end207:                                        ; preds = %land.lhs.true195, %if.end191
  %number_of_packets208 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %45 = load i32, i32* %number_of_packets208, align 4, !tbaa !722
  %call209 = call %struct.async* @alloc_async(i32 %45)
  %tobool210 = icmp ne %struct.async* %call209, null
  br i1 %tobool210, label %if.end212, label %error

if.end212:                                        ; preds = %if.end207
  %buffer_length213 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %46 = load i32, i32* %buffer_length213, align 8, !tbaa !716
  %conv214 = sext i32 %46 to i64
  %add215 = add i64 280, %conv214
  %conv216 = sext i32 %num_sgs.1 to i64
  %mul217 = mul i64 %conv216, 40
  %add218 = add i64 %add215, %mul217
  %conv219 = zext i32 %u.1 to i64
  %add220 = add i64 %conv219, %add218
  %conv221 = trunc i64 %add220 to i32
  %call222 = call i32 @usbfs_increase_memory_usage(i32 %conv221)
  %tobool223 = icmp ne i32 %call222, 0
  br i1 %tobool223, label %error, label %if.end225

if.end225:                                        ; preds = %if.end212
  %mem_usage = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 9
  store i32 %conv221, i32* %mem_usage, align 8, !tbaa !610
  %tobool226 = icmp ne i32 %num_sgs.1, 0
  br i1 %tobool226, label %if.then227, label %if.else275

if.then227:                                       ; preds = %if.end225
  %conv228 = sext i32 %num_sgs.1 to i64
  %mul229 = mul i64 %conv228, 40
  %call.i2 = call i8* @__kmalloc(i64 %mul229, i32 208) #8
  %47 = bitcast i8* %call.i2 to %struct.scatterlist*
  %urb = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %48 = load %struct.urb*, %struct.urb** %urb, align 8, !tbaa !591
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %48, i32 0, i32 16
  store %struct.scatterlist* %47, %struct.scatterlist** %sg, align 8, !tbaa !329
  %urb231 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %49 = load %struct.urb*, %struct.urb** %urb231, align 8, !tbaa !591
  %sg232 = getelementptr inbounds %struct.urb, %struct.urb* %49, i32 0, i32 16
  %50 = load %struct.scatterlist*, %struct.scatterlist** %sg232, align 8, !tbaa !329
  %tobool233 = icmp ne %struct.scatterlist* %50, null
  br i1 %tobool233, label %if.end235, label %error

if.end235:                                        ; preds = %if.then227
  %urb236 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %51 = load %struct.urb*, %struct.urb** %urb236, align 8, !tbaa !591
  %num_sgs237 = getelementptr inbounds %struct.urb, %struct.urb* %51, i32 0, i32 18
  store i32 %num_sgs.1, i32* %num_sgs237, align 4, !tbaa !330
  %urb238 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %52 = load %struct.urb*, %struct.urb** %urb238, align 8, !tbaa !591
  %sg239 = getelementptr inbounds %struct.urb, %struct.urb* %52, i32 0, i32 16
  %53 = load %struct.scatterlist*, %struct.scatterlist** %sg239, align 8, !tbaa !329
  %urb240 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %54 = load %struct.urb*, %struct.urb** %urb240, align 8, !tbaa !591
  %num_sgs241 = getelementptr inbounds %struct.urb, %struct.urb* %54, i32 0, i32 18
  %55 = load i32, i32* %num_sgs241, align 4, !tbaa !330
  call void @sg_init_table(%struct.scatterlist* %53, i32 %55)
  %buffer_length242 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %56 = load i32, i32* %buffer_length242, align 8, !tbaa !716
  br label %for.cond243

for.cond243:                                      ; preds = %if.end270, %if.end235
  %i.0 = phi i32 [ 0, %if.end235 ], [ %inc273, %if.end270 ]
  %totlen.1 = phi i32 [ %56, %if.end235 ], [ %sub271, %if.end270 ]
  %urb244 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %57 = load %struct.urb*, %struct.urb** %urb244, align 8, !tbaa !591
  %num_sgs245 = getelementptr inbounds %struct.urb, %struct.urb* %57, i32 0, i32 18
  %58 = load i32, i32* %num_sgs245, align 4, !tbaa !330
  %cmp246 = icmp slt i32 %i.0, %58
  br i1 %cmp246, label %for.body248, label %if.end313

for.body248:                                      ; preds = %for.cond243
  %cmp249 = icmp ugt i32 %totlen.1, 16384
  %.totlen.1 = select i1 %cmp249, i32 16384, i32 %totlen.1
  %conv251 = zext i32 %.totlen.1 to i64
  %call.i1 = call i8* @__kmalloc(i64 %conv251, i32 208) #8
  %tobool253 = icmp ne i8* %call.i1, null
  br i1 %tobool253, label %if.end255, label %error

if.end255:                                        ; preds = %for.body248
  %urb256 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %59 = load %struct.urb*, %struct.urb** %urb256, align 8, !tbaa !591
  %sg257 = getelementptr inbounds %struct.urb, %struct.urb* %59, i32 0, i32 16
  %60 = load %struct.scatterlist*, %struct.scatterlist** %sg257, align 8, !tbaa !329
  %idxprom258 = sext i32 %i.0 to i64
  %arrayidx259 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %60, i64 %idxprom258
  call void @sg_set_buf(%struct.scatterlist* %arrayidx259, i8* %call.i1, i32 %.totlen.1)
  %tobool260 = icmp ne i32 %is_in.2, 0
  br i1 %tobool260, label %if.end270, label %if.then261

if.then261:                                       ; preds = %if.end255
  %buffer262 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %61 = load i8*, i8** %buffer262, align 8, !tbaa !728
  %conv263 = zext i32 %.totlen.1 to i64
  %call264 = call i64 @copy_from_user(i8* %call.i1, i8* %61, i64 %conv263)
  %tobool265 = icmp ne i64 %call264, 0
  br i1 %tobool265, label %error, label %if.end267

if.end267:                                        ; preds = %if.then261
  %buffer268 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %62 = load i8*, i8** %buffer268, align 8, !tbaa !728
  %idx.ext = zext i32 %.totlen.1 to i64
  %add.ptr269 = getelementptr i8, i8* %62, i64 %idx.ext
  store i8* %add.ptr269, i8** %buffer268, align 8, !tbaa !728
  br label %if.end270

if.end270:                                        ; preds = %if.end267, %if.end255
  %sub271 = sub i32 %totlen.1, %.totlen.1
  %inc273 = add nsw i32 %i.0, 1
  br label %for.cond243

if.else275:                                       ; preds = %if.end225
  %buffer_length276 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %63 = load i32, i32* %buffer_length276, align 8, !tbaa !716
  %cmp277 = icmp sgt i32 %63, 0
  br i1 %cmp277, label %if.then279, label %if.end313

if.then279:                                       ; preds = %if.else275
  %buffer_length280 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %64 = load i32, i32* %buffer_length280, align 8, !tbaa !716
  %conv281 = sext i32 %64 to i64
  %call.i = call i8* @__kmalloc(i64 %conv281, i32 208) #8
  %urb283 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %65 = load %struct.urb*, %struct.urb** %urb283, align 8, !tbaa !591
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %65, i32 0, i32 14
  store i8* %call.i, i8** %transfer_buffer, align 8, !tbaa !293
  %urb284 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %66 = load %struct.urb*, %struct.urb** %urb284, align 8, !tbaa !591
  %transfer_buffer285 = getelementptr inbounds %struct.urb, %struct.urb* %66, i32 0, i32 14
  %67 = load i8*, i8** %transfer_buffer285, align 8, !tbaa !293
  %tobool286 = icmp ne i8* %67, null
  br i1 %tobool286, label %if.end288, label %error

if.end288:                                        ; preds = %if.then279
  %tobool289 = icmp ne i32 %is_in.2, 0
  br i1 %tobool289, label %if.else300, label %if.then290

if.then290:                                       ; preds = %if.end288
  %urb291 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %68 = load %struct.urb*, %struct.urb** %urb291, align 8, !tbaa !591
  %transfer_buffer292 = getelementptr inbounds %struct.urb, %struct.urb* %68, i32 0, i32 14
  %69 = load i8*, i8** %transfer_buffer292, align 8, !tbaa !293
  %buffer293 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %70 = load i8*, i8** %buffer293, align 8, !tbaa !728
  %buffer_length294 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %71 = load i32, i32* %buffer_length294, align 8, !tbaa !716
  %conv295 = sext i32 %71 to i64
  %call296 = call i64 @copy_from_user(i8* %69, i8* %70, i64 %conv295)
  %tobool297 = icmp ne i64 %call296, 0
  br i1 %tobool297, label %error, label %if.end313

if.else300:                                       ; preds = %if.end288
  %type301 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  %72 = load i8, i8* %type301, align 8, !tbaa !707
  %conv302 = zext i8 %72 to i32
  %cmp303 = icmp eq i32 %conv302, 0
  br i1 %cmp303, label %if.then305, label %if.end313

if.then305:                                       ; preds = %if.else300
  %urb306 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %73 = load %struct.urb*, %struct.urb** %urb306, align 8, !tbaa !591
  %transfer_buffer307 = getelementptr inbounds %struct.urb, %struct.urb* %73, i32 0, i32 14
  %74 = load i8*, i8** %transfer_buffer307, align 8, !tbaa !293
  %buffer_length308 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %75 = load i32, i32* %buffer_length308, align 8, !tbaa !716
  %conv309 = sext i32 %75 to i64
  call void @llvm.memset.p0i8.i64(i8* %74, i8 0, i64 %conv309, i32 1, i1 false)
  br label %if.end313

if.end313:                                        ; preds = %if.then305, %if.else300, %if.then290, %if.else275, %for.cond243
  %dev314 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %76 = load %struct.usb_device*, %struct.usb_device** %dev314, align 8, !tbaa !594
  %urb315 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %77 = load %struct.urb*, %struct.urb** %urb315, align 8, !tbaa !591
  %dev316 = getelementptr inbounds %struct.urb, %struct.urb* %77, i32 0, i32 8
  store %struct.usb_device* %76, %struct.usb_device** %dev316, align 8, !tbaa !210
  %type317 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  %78 = load i8, i8* %type317, align 8, !tbaa !707
  %conv318 = zext i8 %78 to i32
  %shl = shl i32 %conv318, 30
  %dev319 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %79 = load %struct.usb_device*, %struct.usb_device** %dev319, align 8, !tbaa !594
  %endpoint320 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %80 = load i8, i8* %endpoint320, align 1, !tbaa !710
  %conv321 = zext i8 %80 to i32
  %and322 = and i32 %conv321, 15
  %call323 = call i32 @__create_pipe.724(%struct.usb_device* %79, i32 %and322)
  %or324 = or i32 %shl, %call323
  %endpoint325 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %81 = load i8, i8* %endpoint325, align 1, !tbaa !710
  %conv326 = zext i8 %81 to i32
  %and327 = and i32 %conv326, 128
  %or328 = or i32 %or324, %and327
  %urb329 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %82 = load %struct.urb*, %struct.urb** %urb329, align 8, !tbaa !591
  %pipe = getelementptr inbounds %struct.urb, %struct.urb* %82, i32 0, i32 10
  store i32 %or328, i32* %pipe, align 8, !tbaa !212
  %tobool330 = icmp ne i32 %is_in.2, 0
  %cond331 = select i1 %tobool330, i32 512, i32 0
  %flags332 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %83 = load i32, i32* %flags332, align 8, !tbaa !714
  %and333 = and i32 %83, 2
  %tobool334 = icmp ne i32 %and333, 0
  %or336 = or i32 %cond331, 2
  %or336.cond331 = select i1 %tobool334, i32 %or336, i32 %cond331
  %flags338 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %84 = load i32, i32* %flags338, align 8, !tbaa !714
  %and339 = and i32 %84, 1
  %tobool340 = icmp ne i32 %and339, 0
  %or342 = or i32 %or336.cond331, 1
  %u.3 = select i1 %tobool340, i32 %or342, i32 %or336.cond331
  %flags344 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %85 = load i32, i32* %flags344, align 8, !tbaa !714
  %and345 = and i32 %85, 32
  %tobool346 = icmp ne i32 %and345, 0
  %or348 = or i32 %u.3, 32
  %or348.u.3 = select i1 %tobool346, i32 %or348, i32 %u.3
  %flags350 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %86 = load i32, i32* %flags350, align 8, !tbaa !714
  %and351 = and i32 %86, 64
  %tobool352 = icmp ne i32 %and351, 0
  %or354 = or i32 %or348.u.3, 64
  %u.5 = select i1 %tobool352, i32 %or354, i32 %or348.u.3
  %flags356 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %87 = load i32, i32* %flags356, align 8, !tbaa !714
  %and357 = and i32 %87, 128
  %tobool358 = icmp ne i32 %and357, 0
  %or360 = or i32 %u.5, 128
  %or360.u.5 = select i1 %tobool358, i32 %or360, i32 %u.5
  %urb362 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %88 = load %struct.urb*, %struct.urb** %urb362, align 8, !tbaa !591
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %88, i32 0, i32 13
  store i32 %or360.u.5, i32* %transfer_flags, align 4, !tbaa !323
  %buffer_length363 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %89 = load i32, i32* %buffer_length363, align 8, !tbaa !716
  %urb364 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %90 = load %struct.urb*, %struct.urb** %urb364, align 8, !tbaa !591
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %90, i32 0, i32 19
  store i32 %89, i32* %transfer_buffer_length, align 8, !tbaa !294
  %91 = bitcast %struct.usb_ctrlrequest* %dr.0 to i8*
  %urb365 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %92 = load %struct.urb*, %struct.urb** %urb365, align 8, !tbaa !591
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %92, i32 0, i32 21
  store i8* %91, i8** %setup_packet, align 8, !tbaa !371
  %start_frame = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 7
  %93 = load i32, i32* %start_frame, align 8, !tbaa !720
  %urb366 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %94 = load %struct.urb*, %struct.urb** %urb366, align 8, !tbaa !591
  %start_frame367 = getelementptr inbounds %struct.urb, %struct.urb* %94, i32 0, i32 23
  store i32 %93, i32* %start_frame367, align 8, !tbaa !297
  %number_of_packets368 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %95 = load i32, i32* %number_of_packets368, align 4, !tbaa !722
  %urb369 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %96 = load %struct.urb*, %struct.urb** %urb369, align 8, !tbaa !591
  %number_of_packets370 = getelementptr inbounds %struct.urb, %struct.urb* %96, i32 0, i32 24
  store i32 %95, i32* %number_of_packets370, align 4, !tbaa !427
  %type371 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  %97 = load i8, i8* %type371, align 8, !tbaa !707
  %conv372 = zext i8 %97 to i32
  %cmp373 = icmp eq i32 %conv372, 0
  br i1 %cmp373, label %if.then379, label %lor.lhs.false375

lor.lhs.false375:                                 ; preds = %if.end313
  %dev376 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %98 = load %struct.usb_device*, %struct.usb_device** %dev376, align 8, !tbaa !594
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %98, i32 0, i32 4
  %99 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp377 = icmp eq i32 %99, 3
  br i1 %cmp377, label %if.then379, label %if.else394

if.then379:                                       ; preds = %lor.lhs.false375, %if.end313
  %100 = bitcast i32* %_min1 to i8*
  store i32 15, i32* %_min1, align 4, !tbaa !90
  %101 = bitcast i32* %_min2 to i8*
  %desc380 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %bInterval = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc380, i32 0, i32 5
  %102 = load i8, i8* %bInterval, align 2, !tbaa !469
  %conv381 = zext i8 %102 to i32
  %sub382 = sub nsw i32 %conv381, 1
  store i32 %sub382, i32* %_min2, align 4, !tbaa !90
  %103 = load i32, i32* %_min1, align 4, !tbaa !90
  %104 = load i32, i32* %_min2, align 4, !tbaa !90
  %cmp386 = icmp slt i32 %103, %104
  %105 = load i32, i32* %_min1, align 4
  %106 = load i32, i32* %_min2, align 4
  %cond391 = select i1 %cmp386, i32 %105, i32 %106
  %107 = bitcast i32* %_min2 to i8*
  %108 = bitcast i32* %_min1 to i8*
  %shl392 = shl i32 1, %cond391
  br label %if.end400

if.else394:                                       ; preds = %lor.lhs.false375
  %desc395 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %bInterval396 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc395, i32 0, i32 5
  %109 = load i8, i8* %bInterval396, align 2, !tbaa !469
  %conv397 = zext i8 %109 to i32
  br label %if.end400

if.end400:                                        ; preds = %if.else394, %if.then379
  %conv397.sink = phi i32 [ %conv397, %if.else394 ], [ %shl392, %if.then379 ]
  %urb398 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %110 = load %struct.urb*, %struct.urb** %urb398, align 8, !tbaa !591
  %interval399 = getelementptr inbounds %struct.urb, %struct.urb* %110, i32 0, i32 25
  store i32 %conv397.sink, i32* %interval399, align 8, !tbaa !296
  %111 = bitcast %struct.async* %call209 to i8*
  %urb401 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %112 = load %struct.urb*, %struct.urb** %urb401, align 8, !tbaa !591
  %context = getelementptr inbounds %struct.urb, %struct.urb* %112, i32 0, i32 27
  store i8* %111, i8** %context, align 8, !tbaa !290
  %urb402 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %113 = load %struct.urb*, %struct.urb** %urb402, align 8, !tbaa !591
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %113, i32 0, i32 28
  store void (%struct.urb*)* @async_completed, void (%struct.urb*)** %complete, align 8, !tbaa !295
  br label %for.cond403

for.cond403:                                      ; preds = %for.body407, %if.end400
  %totlen.2 = phi i32 [ 0, %if.end400 ], [ %add423, %for.body407 ]
  %u.7 = phi i32 [ 0, %if.end400 ], [ %inc425, %for.body407 ]
  %number_of_packets404 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %114 = load i32, i32* %number_of_packets404, align 4, !tbaa !722
  %cmp405 = icmp ult i32 %u.7, %114
  br i1 %cmp405, label %for.body407, label %for.end426

for.body407:                                      ; preds = %for.cond403
  %urb408 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %115 = load %struct.urb*, %struct.urb** %urb408, align 8, !tbaa !591
  %iso_frame_desc409 = getelementptr inbounds %struct.urb, %struct.urb* %115, i32 0, i32 29
  %idxprom410 = zext i32 %u.7 to i64
  %arrayidx411 = getelementptr inbounds [0 x %struct.usb3_lpm_parameters], [0 x %struct.usb3_lpm_parameters]* %iso_frame_desc409, i64 0, i64 %idxprom410
  %offset = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %arrayidx411, i32 0, i32 0
  store i32 %totlen.2, i32* %offset, align 8, !tbaa !734
  %idxprom412 = zext i32 %u.7 to i64
  %arrayidx413 = getelementptr inbounds %struct.uid_gid_extent, %struct.uid_gid_extent* %isopkt.0, i64 %idxprom412
  %length414 = getelementptr inbounds %struct.uid_gid_extent, %struct.uid_gid_extent* %arrayidx413, i32 0, i32 0
  %116 = load i32, i32* %length414, align 4, !tbaa !731
  %urb415 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %117 = load %struct.urb*, %struct.urb** %urb415, align 8, !tbaa !591
  %iso_frame_desc416 = getelementptr inbounds %struct.urb, %struct.urb* %117, i32 0, i32 29
  %idxprom417 = zext i32 %u.7 to i64
  %arrayidx418 = getelementptr inbounds [0 x %struct.usb3_lpm_parameters], [0 x %struct.usb3_lpm_parameters]* %iso_frame_desc416, i64 0, i64 %idxprom417
  %length419 = getelementptr inbounds %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters* %arrayidx418, i32 0, i32 1
  store i32 %116, i32* %length419, align 4, !tbaa !428
  %idxprom420 = zext i32 %u.7 to i64
  %arrayidx421 = getelementptr inbounds %struct.uid_gid_extent, %struct.uid_gid_extent* %isopkt.0, i64 %idxprom420
  %length422 = getelementptr inbounds %struct.uid_gid_extent, %struct.uid_gid_extent* %arrayidx421, i32 0, i32 0
  %118 = load i32, i32* %length422, align 4, !tbaa !731
  %add423 = add i32 %totlen.2, %118
  %inc425 = add i32 %u.7, 1
  br label %for.cond403

for.end426:                                       ; preds = %for.cond403
  %119 = bitcast %struct.uid_gid_extent* %isopkt.0 to i8*
  call void @kfree(i8* %119)
  %ps427 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 1
  store %struct.dev_state* %ps, %struct.dev_state** %ps427, align 8, !tbaa !735
  %userurb = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 7
  store i8* %arg, i8** %userurb, align 8, !tbaa !686
  %tobool428 = icmp ne i32 %is_in.2, 0
  br i1 %tobool428, label %land.lhs.true429, label %if.end437

land.lhs.true429:                                 ; preds = %for.end426
  %buffer_length430 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %120 = load i32, i32* %buffer_length430, align 8, !tbaa !716
  %cmp431 = icmp sgt i32 %120, 0
  br i1 %cmp431, label %if.then433, label %if.end437

if.then433:                                       ; preds = %land.lhs.true429
  %buffer434 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %121 = load i8*, i8** %buffer434, align 8, !tbaa !728
  br label %if.end437

if.end437:                                        ; preds = %if.then433, %land.lhs.true429, %for.end426
  %.sink = phi i8* [ %121, %if.then433 ], [ null, %land.lhs.true429 ], [ null, %for.end426 ]
  %userbuffer436 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 6
  store i8* %.sink, i8** %userbuffer436, align 8, !tbaa !687
  %signr = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 10
  %122 = load i32, i32* %signr, align 4, !tbaa !726
  %signr438 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 4
  store i32 %122, i32* %signr438, align 8, !tbaa !736
  %ifnum439 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 5
  store i32 %ifnum.0, i32* %ifnum439, align 4, !tbaa !589
  %123 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %call441 = call %struct.pid* @task_pid(%struct.task_struct* %123)
  %call442 = call %struct.pid* @get_pid(%struct.pid* %call441)
  %pid = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 2
  store %struct.pid* %call442, %struct.pid** %pid, align 8, !tbaa !608
  %call444 = call i32 @debug_lockdep_rcu_enabled()
  %124 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %cred = getelementptr inbounds %struct.task_struct, %struct.task_struct* %124, i32 0, i32 65
  %125 = load %struct.cred*, %struct.cred** %cred, align 8, !tbaa !601
  %call455 = call %struct.cred* @get_cred(%struct.cred* %125)
  %cred456 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 3
  store %struct.cred* %call455, %struct.cred** %cred456, align 8, !tbaa !609
  %126 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %secid = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 11
  call void @security_task_getsecid(%struct.task_struct* %126, i32* %secid)
  %dev458 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %127 = load %struct.usb_device*, %struct.usb_device** %dev458, align 8, !tbaa !594
  %userurb459 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 7
  %128 = load i8*, i8** %userurb459, align 8, !tbaa !686
  %urb460 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %129 = load %struct.urb*, %struct.urb** %urb460, align 8, !tbaa !591
  %pipe461 = getelementptr inbounds %struct.urb, %struct.urb* %129, i32 0, i32 10
  %130 = load i32, i32* %pipe461, align 8, !tbaa !212
  %urb462 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %131 = load %struct.urb*, %struct.urb** %urb462, align 8, !tbaa !591
  %transfer_buffer_length463 = getelementptr inbounds %struct.urb, %struct.urb* %131, i32 0, i32 19
  %132 = load i32, i32* %transfer_buffer_length463, align 8, !tbaa !294
  call void @snoop_urb(i8* %128, i32 0, i8* null, i32 0)
  %tobool464 = icmp ne i32 %is_in.2, 0
  br i1 %tobool464, label %if.end469, label %if.then465

if.then465:                                       ; preds = %if.end437
  %urb466 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %133 = load %struct.urb*, %struct.urb** %urb466, align 8, !tbaa !591
  %urb467 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %134 = load %struct.urb*, %struct.urb** %urb467, align 8, !tbaa !591
  %transfer_buffer_length468 = getelementptr inbounds %struct.urb, %struct.urb* %134, i32 0, i32 19
  %135 = load i32, i32* %transfer_buffer_length468, align 8, !tbaa !294
  call void @snoop_urb_data(%struct.urb* %133, i32 %135)
  br label %if.end469

if.end469:                                        ; preds = %if.then465, %if.end437
  call void @async_newpending(%struct.async* %call209)
  %desc470 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %call471 = call i32 @usb_endpoint_xfer_bulk.725(%struct.usb_endpoint_descriptor* %desc470)
  %tobool472 = icmp ne i32 %call471, 0
  br i1 %tobool472, label %if.then473, label %if.else503

if.then473:                                       ; preds = %if.end469
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_lock_irq.726(%struct.spinlock* %lock)
  %desc474 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %call475 = call i32 @usb_endpoint_num.727(%struct.usb_endpoint_descriptor* %desc474)
  %desc476 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc476, i32 0, i32 2
  %136 = load i8, i8* %bEndpointAddress, align 2, !tbaa !449
  %conv477 = zext i8 %136 to i32
  %and478 = and i32 %conv477, 128
  %shr = ashr i32 %and478, 3
  %or479 = or i32 %call475, %shr
  %conv480 = trunc i32 %or479 to i8
  %bulk_addr = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 12
  store i8 %conv480, i8* %bulk_addr, align 4, !tbaa !737
  %flags481 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %137 = load i32, i32* %flags481, align 8, !tbaa !714
  %and482 = and i32 %137, 4
  %tobool483 = icmp ne i32 %and482, 0
  br i1 %tobool483, label %if.then484, label %if.else485

if.then484:                                       ; preds = %if.then473
  %bulk_status = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 13
  store i8 1, i8* %bulk_status, align 1, !tbaa !738
  br label %if.end490

if.else485:                                       ; preds = %if.then473
  %bulk_addr486 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 12
  %138 = load i8, i8* %bulk_addr486, align 4, !tbaa !737
  %conv487 = zext i8 %138 to i32
  %shl488 = shl i32 1, %conv487
  %neg = xor i32 %shl488, -1
  %disabled_bulk_eps = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 13
  %139 = load i32, i32* %disabled_bulk_eps, align 4, !tbaa !739
  %and489 = and i32 %139, %neg
  store i32 %and489, i32* %disabled_bulk_eps, align 4, !tbaa !739
  br label %if.end490

if.end490:                                        ; preds = %if.else485, %if.then484
  %disabled_bulk_eps491 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 13
  %140 = load i32, i32* %disabled_bulk_eps491, align 4, !tbaa !739
  %bulk_addr492 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 12
  %141 = load i8, i8* %bulk_addr492, align 4, !tbaa !737
  %conv493 = zext i8 %141 to i32
  %shl494 = shl i32 1, %conv493
  %and495 = and i32 %140, %shl494
  %tobool496 = icmp ne i32 %and495, 0
  br i1 %tobool496, label %if.end501, label %if.else498

if.else498:                                       ; preds = %if.end490
  %urb499 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %142 = load %struct.urb*, %struct.urb** %urb499, align 8, !tbaa !591
  %call500 = call i32 bitcast (i32 (%struct.urb.824*, i32)* @usb_submit_urb to i32 (%struct.urb*, i32)*)(%struct.urb* %142, i32 32)
  br label %if.end501

if.end501:                                        ; preds = %if.else498, %if.end490
  %ret.0 = phi i32 [ %call500, %if.else498 ], [ -121, %if.end490 ]
  %lock502 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irq.728(%struct.spinlock* %lock502)
  br label %if.end506

if.else503:                                       ; preds = %if.end469
  %urb504 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %143 = load %struct.urb*, %struct.urb** %urb504, align 8, !tbaa !591
  %call505 = call i32 bitcast (i32 (%struct.urb.824*, i32)* @usb_submit_urb to i32 (%struct.urb*, i32)*)(%struct.urb* %143, i32 208)
  br label %if.end506

if.end506:                                        ; preds = %if.else503, %if.end501
  %ret.1 = phi i32 [ %ret.0, %if.end501 ], [ %call505, %if.else503 ]
  %tobool507 = icmp ne i32 %ret.1, 0
  br i1 %tobool507, label %if.then508, label %cleanup

if.then508:                                       ; preds = %if.end506
  %dev509 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %144 = load %struct.usb_device*, %struct.usb_device** %dev509, align 8, !tbaa !594
  %dev510 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %144, i32 0, i32 11
  %call511 = call i32 (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35.729, i32 0, i32 0), %struct.device* %dev510, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.55.730, i32 0, i32 0), i32 %ret.1)
  %dev512 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %145 = load %struct.usb_device*, %struct.usb_device** %dev512, align 8, !tbaa !594
  %userurb513 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 7
  %146 = load i8*, i8** %userurb513, align 8, !tbaa !686
  %urb514 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %147 = load %struct.urb*, %struct.urb** %urb514, align 8, !tbaa !591
  %pipe515 = getelementptr inbounds %struct.urb, %struct.urb* %147, i32 0, i32 10
  %148 = load i32, i32* %pipe515, align 8, !tbaa !212
  call void @snoop_urb(i8* %146, i32 1, i8* null, i32 0)
  call void @async_removepending(%struct.async* %call209)
  br label %error

error:                                            ; preds = %if.then508, %if.then290, %if.then279, %if.then261, %for.body248, %if.then227, %if.end212, %if.end207, %land.lhs.true195, %sw.epilog186, %for.body, %if.end163, %if.end69, %if.end62, %if.end57
  %ret.2 = phi i32 [ %ret.1, %if.then508 ], [ -14, %if.end57 ], [ -22, %if.end62 ], [ %call74, %if.end69 ], [ -14, %if.end163 ], [ -22, %for.body ], [ -22, %sw.epilog186 ], [ -14, %land.lhs.true195 ], [ -12, %if.end207 ], [ %call222, %if.end212 ], [ -12, %if.then227 ], [ -12, %for.body248 ], [ -14, %if.then261 ], [ -12, %if.then279 ], [ -14, %if.then290 ]
  %dr.1 = phi %struct.usb_ctrlrequest* [ null, %if.then508 ], [ %13, %if.end57 ], [ %13, %if.end62 ], [ %13, %if.end69 ], [ null, %if.end163 ], [ null, %for.body ], [ %dr.0, %sw.epilog186 ], [ %dr.0, %land.lhs.true195 ], [ %dr.0, %if.end207 ], [ %dr.0, %if.end212 ], [ %dr.0, %if.then227 ], [ %dr.0, %for.body248 ], [ %dr.0, %if.then261 ], [ %dr.0, %if.then279 ], [ %dr.0, %if.then290 ]
  %as.0 = phi %struct.async* [ %call209, %if.then508 ], [ null, %if.end57 ], [ null, %if.end62 ], [ null, %if.end69 ], [ null, %if.end163 ], [ null, %for.body ], [ null, %sw.epilog186 ], [ null, %land.lhs.true195 ], [ %call209, %if.end207 ], [ %call209, %if.end212 ], [ %call209, %if.then227 ], [ %call209, %for.body248 ], [ %call209, %if.then261 ], [ %call209, %if.then279 ], [ %call209, %if.then290 ]
  %isopkt.1 = phi %struct.uid_gid_extent* [ null, %if.then508 ], [ null, %if.end57 ], [ null, %if.end62 ], [ null, %if.end69 ], [ %33, %if.end163 ], [ %33, %for.body ], [ %isopkt.0, %sw.epilog186 ], [ %isopkt.0, %land.lhs.true195 ], [ %isopkt.0, %if.end207 ], [ %isopkt.0, %if.end212 ], [ %isopkt.0, %if.then227 ], [ %isopkt.0, %for.body248 ], [ %isopkt.0, %if.then261 ], [ %isopkt.0, %if.then279 ], [ %isopkt.0, %if.then290 ]
  %149 = bitcast %struct.uid_gid_extent* %isopkt.1 to i8*
  call void @kfree(i8* %149)
  %150 = bitcast %struct.usb_ctrlrequest* %dr.1 to i8*
  call void @kfree(i8* %150)
  %tobool517 = icmp ne %struct.async* %as.0, null
  br i1 %tobool517, label %if.then518, label %cleanup

if.then518:                                       ; preds = %error
  call void @free_async(%struct.async* %as.0)
  br label %cleanup

cleanup:                                          ; preds = %if.then518, %error, %if.end506, %if.end155, %if.end150, %lor.lhs.false145, %sw.bb141, %sw.bb134, %LeafBlock8, %if.end53, %if.end48, %sw.bb, %LeafBlock, %LeafBlock1, %if.end22, %if.end17, %if.then11, %land.lhs.true, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -22, %land.lhs.true ], [ %call, %if.then11 ], [ %call18, %if.end17 ], [ -2, %if.end22 ], [ -22, %sw.bb ], [ -22, %if.end48 ], [ -12, %if.end53 ], [ -22, %LeafBlock8 ], [ -22, %sw.bb134 ], [ -22, %lor.lhs.false145 ], [ -22, %sw.bb141 ], [ -22, %if.end150 ], [ -12, %if.end155 ], [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ 0, %if.end506 ], [ %ret.2, %if.then518 ], [ %ret.2, %error ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @findintfep(%struct.usb_device* %dev, i32 %ep) #0 {
entry:
  %and = and i32 %ep, -144
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool1 = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool1, label %if.end3, label %cleanup

if.end3:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc32, %if.end3
  %i.0 = phi i32 [ 0, %if.end3 ], [ %inc33, %for.inc32 ]
  %actconfig4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %1 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig4, align 8, !tbaa !64
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %1, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %2 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv = zext i8 %2 to i32
  %cmp = icmp ult i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %actconfig6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %3 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig6, align 8, !tbaa !64
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %3, i32 0, i32 3
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %4 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !48
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc29, %for.body
  %j.0 = phi i32 [ 0, %for.body ], [ %inc30, %for.inc29 ]
  %num_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 2
  %5 = load i32, i32* %num_altsetting, align 8, !tbaa !59
  %cmp8 = icmp ult i32 %j.0, %5
  br i1 %cmp8, label %for.body10, label %for.inc32

for.body10:                                       ; preds = %for.cond7
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 0
  %6 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !60
  %idxprom11 = zext i32 %j.0 to i64
  %arrayidx12 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %6, i64 %idxprom11
  br label %for.cond13

for.cond13:                                       ; preds = %for.inc, %for.body10
  %e.0 = phi i32 [ 0, %for.body10 ], [ %inc, %for.inc ]
  %desc14 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx12, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc14, i32 0, i32 4
  %7 = load i8, i8* %bNumEndpoints, align 4, !tbaa !270
  %conv15 = zext i8 %7 to i32
  %cmp16 = icmp ult i32 %e.0, %conv15
  br i1 %cmp16, label %for.body18, label %for.inc29

for.body18:                                       ; preds = %for.cond13
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx12, i32 0, i32 3
  %8 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !271
  %idxprom19 = zext i32 %e.0 to i64
  %arrayidx20 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %8, i64 %idxprom19
  %desc21 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx20, i32 0, i32 0
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc21, i32 0, i32 2
  %9 = load i8, i8* %bEndpointAddress, align 1, !tbaa !286
  %conv22 = zext i8 %9 to i32
  %cmp23 = icmp eq i32 %conv22, %ep
  br i1 %cmp23, label %if.then25, label %for.inc

if.then25:                                        ; preds = %for.body18
  %desc26 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx12, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc26, i32 0, i32 2
  %10 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !68
  %conv27 = zext i8 %10 to i32
  br label %cleanup

for.inc:                                          ; preds = %for.body18
  %inc = add i32 %e.0, 1
  br label %for.cond13

for.inc29:                                        ; preds = %for.cond13
  %inc30 = add i32 %j.0, 1
  br label %for.cond7

for.inc32:                                        ; preds = %for.cond7
  %inc33 = add i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.then25, %for.cond, %if.end, %entry
  %retval.0 = phi i32 [ %conv27, %if.then25 ], [ -22, %entry ], [ -3, %if.end ], [ -2, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @checkintf(%struct.dev_state* %ps, i32 %ifnum) #0 {
entry:
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !594
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp ne i32 %1, 7
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %conv = zext i32 %ifnum to i64
  %cmp1 = icmp uge i64 %conv, 64
  br i1 %cmp1, label %return, label %cond.false

cond.false:                                       ; preds = %if.end
  %ifclaimed5 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 11
  %call6 = call i32 @variable_test_bit.669(i32 %ifnum, i64* %ifclaimed5)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %return, label %if.end9

if.end9:                                          ; preds = %cond.false
  %2 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  call void @task_pid_nr(%struct.task_struct* %2)
  %3 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !599
  %4 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %call16 = call i32 @claimintf(%struct.dev_state* %ps, i32 %ifnum)
  br label %return

return:                                           ; preds = %if.end9, %cond.false, %if.end, %entry
  %retval.0 = phi i32 [ %call16, %if.end9 ], [ -113, %entry ], [ -22, %if.end ], [ 0, %cond.false ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_control.720(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @__le16_to_cpup(i16* %p) #1 {
entry:
  %0 = load i16, i16* %p, align 2, !tbaa !143
  ret i16 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @check_ctrlrecip(%struct.dev_state* %ps, i32 %requesttype, i32 %request, i32 %index) #0 {
entry:
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !594
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !50
  %cmp = icmp ne i32 %1, 4
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !594
  %state2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 3
  %3 = load i32, i32* %state2, align 8, !tbaa !50
  %cmp3 = icmp ne i32 %3, 6
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %dev5 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev5, align 8, !tbaa !594
  %state6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 3
  %5 = load i32, i32* %state6, align 8, !tbaa !50
  %cmp7 = icmp ne i32 %5, 7
  br i1 %cmp7, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true4, %land.lhs.true, %entry
  %and = and i32 96, %requesttype
  %cmp8 = icmp eq i32 64, %and
  br i1 %cmp8, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end
  %cmp11 = icmp eq i32 %requesttype, 161
  %cmp13 = icmp eq i32 %request, 0
  %or.cond = and i1 %cmp11, %cmp13
  br i1 %or.cond, label %if.then14, label %if.end23

if.then14:                                        ; preds = %if.end10
  %dev15 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev15, align 8, !tbaa !594
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 15
  %7 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %shr = lshr i32 %index, 8
  %and16 = and i32 %index, 255
  %call = call %struct.usb_host_interface* @usb_find_alt_setting(%struct.usb_host_config* %7, i32 %shr, i32 %and16)
  %tobool = icmp ne %struct.usb_host_interface* %call, null
  br i1 %tobool, label %land.lhs.true17, label %if.end23

land.lhs.true17:                                  ; preds = %if.then14
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %call, i32 0, i32 0
  %bInterfaceClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 5
  %8 = load i8, i8* %bInterfaceClass, align 1, !tbaa !433
  %conv = zext i8 %8 to i32
  %cmp18 = icmp eq i32 %conv, 7
  %shr21 = lshr i32 %index, 8
  %shr21.index = select i1 %cmp18, i32 %shr21, i32 %index
  br label %if.end23

if.end23:                                         ; preds = %land.lhs.true17, %if.then14, %if.end10
  %index.addr.1 = phi i32 [ %index, %if.end10 ], [ %index, %if.then14 ], [ %shr21.index, %land.lhs.true17 ]
  %and24 = and i32 %index.addr.1, 255
  %and25 = and i32 %requesttype, 31
  %Pivot = icmp slt i32 %and25, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end23
  %SwitchLeaf2 = icmp ne i32 %and25, 2
  %and26 = and i32 %and24, -129
  %cmp27 = icmp eq i32 %and26, 0
  %or.cond3 = or i1 %SwitchLeaf2, %cmp27
  br i1 %or.cond3, label %cleanup, label %if.end30

LeafBlock:                                        ; preds = %if.end23
  %SwitchLeaf = icmp eq i32 %and25, 1
  br i1 %SwitchLeaf, label %sw.bb38, label %cleanup

if.end30:                                         ; preds = %LeafBlock1
  %dev31 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %dev31, align 8, !tbaa !594
  %call32 = call i32 @findintfep(%struct.usb_device* %9, i32 %and24)
  %cmp33 = icmp sge i32 %call32, 0
  br i1 %cmp33, label %if.then35, label %cleanup

if.then35:                                        ; preds = %if.end30
  %call36 = call i32 @checkintf(%struct.dev_state* %ps, i32 %call32)
  br label %cleanup

sw.bb38:                                          ; preds = %LeafBlock
  %call39 = call i32 @checkintf(%struct.dev_state* %ps, i32 %and24)
  br label %cleanup

cleanup:                                          ; preds = %sw.bb38, %if.then35, %if.end30, %LeafBlock, %LeafBlock1, %if.end, %land.lhs.true4
  %retval.0 = phi i32 [ -113, %land.lhs.true4 ], [ 0, %if.end ], [ %call39, %sw.bb38 ], [ %call36, %if.then35 ], [ %call32, %if.end30 ], [ 0, %LeafBlock1 ], [ 0, %LeafBlock ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_type.722(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_int.723(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 3
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define internal %struct.async* @alloc_async(i32 %numisoframes) #0 {
entry:
  %call = call i8* @kzalloc.746(i64 88, i32 208)
  %0 = bitcast i8* %call to %struct.async*
  %tobool = icmp ne %struct.async* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call %struct.urb* bitcast (%struct.urb.824* (i32, i32)* @usb_alloc_urb to %struct.urb* (i32, i32)*)(i32 %numisoframes, i32 208)
  %urb = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  store %struct.urb* %call1, %struct.urb** %urb, align 8, !tbaa !591
  %urb2 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  %1 = load %struct.urb*, %struct.urb** %urb2, align 8, !tbaa !591
  %tobool3 = icmp ne %struct.urb* %1, null
  br i1 %tobool3, label %cleanup, label %if.then4

if.then4:                                         ; preds = %if.end
  %2 = bitcast %struct.async* %0 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

cleanup:                                          ; preds = %if.then4, %if.end, %entry
  %retval.0 = phi %struct.async* [ null, %if.then4 ], [ null, %entry ], [ %0, %if.end ]
  ret %struct.async* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usbfs_increase_memory_usage(i32 %amount) #0 {
entry:
  %0 = load volatile i32, i32* @usbfs_memory_mb, align 4, !tbaa !90
  %cmp = icmp eq i32 %0, 0
  %cmp1 = icmp ugt i32 %0, 2047
  %or.cond = or i1 %cmp, %cmp1
  %shl = shl i32 %0, 20
  %lim.0 = select i1 %or.cond, i32 2146483647, i32 %shl
  %1 = load volatile i32, i32* getelementptr inbounds (%union.anon.5, %union.anon.5* @usbfs_memory_usage, i64 0, i32 0), align 4, !tbaa !90
  %cmp2 = icmp ule i32 %1, %lim.0
  br i1 %cmp2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %entry
  call void @simpll__inlineasm_0(i32* getelementptr inbounds (%union.anon.5, %union.anon.5* @usbfs_memory_usage, i64 0, i32 0), i32 %amount, i32* getelementptr inbounds (%union.anon.5, %union.anon.5* @usbfs_memory_usage, i64 0, i32 0)) #8
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %entry
  %retval.0 = phi i32 [ -12, %if.end4 ], [ 0, %entry ]
  ret i32 %retval.0
}

declare void @sg_init_table(%struct.scatterlist*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_set_buf(%struct.scatterlist* %sg, i8* %buf, i32 %buflen) #1 {
entry:
  %0 = ptrtoint i8* %buf to i64
  %call = call zeroext i1 @__virt_addr_valid(i64 %0)
  %lnot = xor i1 %call, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body3, label %do.end8

do.body3:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.56.674, i32 0, i32 0), i32 115, i64 12) #8, !srcloc !740
  br label %do.body4

do.body4:                                         ; preds = %do.body4, %do.body3
  br label %do.body4

do.end8:                                          ; preds = %entry
  %1 = ptrtoint i8* %buf to i64
  %call9 = call i64 @__phys_addr(i64 %1)
  %shr = lshr i64 %call9, 12
  %add.ptr = getelementptr inbounds %struct.page, %struct.page* inttoptr (i64 -24189255811072 to %struct.page*), i64 %shr
  %2 = ptrtoint i8* %buf to i64
  %and = and i64 %2, 4095
  %conv10 = trunc i64 %and to i32
  call void @sg_set_page(%struct.scatterlist* %sg, %struct.page* %add.ptr, i32 %buflen, i32 %conv10)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__create_pipe.724(%struct.usb_device* %dev, i32 %endpoint) #1 {
entry:
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 0
  %0 = load i32, i32* %devnum, align 8, !tbaa !38
  %shl = shl i32 %0, 8
  %shl1 = shl i32 %endpoint, 15
  %or = or i32 %shl, %shl1
  ret i32 %or
}

; Function Attrs: nounwind uwtable
define internal void @async_completed(%struct.urb* %urb) #0 {
entry:
  %sinfo = alloca %struct.siginfo, align 8
  %context = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  %0 = load i8*, i8** %context, align 8, !tbaa !290
  %1 = bitcast i8* %0 to %struct.async*
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 1
  %2 = load %struct.dev_state*, %struct.dev_state** %ps1, align 8, !tbaa !735
  %3 = bitcast %struct.siginfo* %sinfo to i8*
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %2, i32 0, i32 3
  call void @spin_lock.742(%struct.spinlock* %lock)
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 0
  %async_completed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %2, i32 0, i32 5
  call void @list_move_tail(%struct.list_head* %asynclist, %struct.list_head* %async_completed)
  %status = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 12
  %4 = load i32, i32* %status, align 8, !tbaa !291
  %status2 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 10
  store i32 %4, i32* %status2, align 4, !tbaa !688
  %signr3 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 4
  %5 = load i32, i32* %signr3, align 8, !tbaa !736
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %do.body

if.then:                                          ; preds = %entry
  %signr4 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 4
  %6 = load i32, i32* %signr4, align 8, !tbaa !736
  %si_signo = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 0
  store i32 %6, i32* %si_signo, align 8, !tbaa !741
  %status5 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 10
  %7 = load i32, i32* %status5, align 4, !tbaa !688
  %si_errno = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 1
  store i32 %7, i32* %si_errno, align 4, !tbaa !743
  %si_code = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 2
  store i32 -4, i32* %si_code, align 8, !tbaa !744
  %userurb = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 7
  %8 = load i8*, i8** %userurb, align 8, !tbaa !686
  %_sifields = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 3
  %_sigfault = bitcast %union.anon.39* %_sifields to %struct.anon.41*
  %_addr = getelementptr inbounds %struct.anon.41, %struct.anon.41* %_sigfault, i32 0, i32 0
  store i8* %8, i8** %_addr, align 8, !tbaa !84
  %pid6 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 2
  %9 = load %struct.pid*, %struct.pid** %pid6, align 8, !tbaa !608
  %call = call %struct.pid* @get_pid(%struct.pid* %9)
  %cred7 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 3
  %10 = load %struct.cred*, %struct.cred** %cred7, align 8, !tbaa !609
  %call8 = call %struct.cred* @get_cred(%struct.cred* %10)
  %secid9 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 11
  %11 = load i32, i32* %secid9, align 8, !tbaa !745
  br label %do.body

do.body:                                          ; preds = %if.then, %entry
  %pid.0 = phi %struct.pid* [ %call, %if.then ], [ null, %entry ]
  %secid.0 = phi i32 [ %11, %if.then ], [ 0, %entry ]
  %cred.0 = phi %struct.cred* [ %call8, %if.then ], [ null, %entry ]
  %12 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool10 = trunc i8 %12 to i1
  br i1 %tobool10, label %if.then11, label %do.end

if.then11:                                        ; preds = %do.body
  %13 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then11, %do.body
  %dev15 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %14 = load %struct.usb_device*, %struct.usb_device** %dev15, align 8, !tbaa !210
  %userurb16 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 7
  %15 = load i8*, i8** %userurb16, align 8, !tbaa !686
  %pipe = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 10
  %16 = load i32, i32* %pipe, align 8, !tbaa !212
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %17 = load i32, i32* %actual_length, align 4, !tbaa !292
  %status17 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 10
  %18 = load i32, i32* %status17, align 4, !tbaa !688
  call void @snoop_urb(i8* %15, i32 1, i8* null, i32 0)
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %19 = load i32, i32* %transfer_flags, align 4, !tbaa !323
  %and = and i32 %19, 512
  %cmp = icmp eq i32 %and, 128
  br i1 %cmp, label %if.then18, label %if.end20

if.then18:                                        ; preds = %do.end
  %actual_length19 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %20 = load i32, i32* %actual_length19, align 4, !tbaa !292
  call void @snoop_urb_data(%struct.urb* %urb, i32 %20)
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %do.end
  %status21 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 10
  %21 = load i32, i32* %status21, align 4, !tbaa !688
  %cmp22 = icmp slt i32 %21, 0
  br i1 %cmp22, label %land.lhs.true, label %if.end35

land.lhs.true:                                    ; preds = %if.end20
  %bulk_addr = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 12
  %22 = load i8, i8* %bulk_addr, align 4, !tbaa !737
  %conv = zext i8 %22 to i32
  %tobool23 = icmp ne i32 %conv, 0
  br i1 %tobool23, label %land.lhs.true24, label %if.end35

land.lhs.true24:                                  ; preds = %land.lhs.true
  %status25 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 10
  %23 = load i32, i32* %status25, align 4, !tbaa !688
  %cmp26 = icmp ne i32 %23, -104
  br i1 %cmp26, label %land.lhs.true28, label %if.end35

land.lhs.true28:                                  ; preds = %land.lhs.true24
  %status29 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 10
  %24 = load i32, i32* %status29, align 4, !tbaa !688
  %cmp30 = icmp ne i32 %24, -2
  br i1 %cmp30, label %if.then32, label %if.end35

if.then32:                                        ; preds = %land.lhs.true28
  %bulk_addr33 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 12
  %25 = load i8, i8* %bulk_addr33, align 4, !tbaa !737
  %conv34 = zext i8 %25 to i32
  call void @cancel_bulk_urbs(%struct.dev_state* %2, i32 %conv34)
  br label %if.end35

if.end35:                                         ; preds = %if.then32, %land.lhs.true28, %land.lhs.true24, %land.lhs.true, %if.end20
  %lock36 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %2, i32 0, i32 3
  call void @spin_unlock.744(%struct.spinlock* %lock36)
  %tobool37 = icmp ne i32 %5, 0
  br i1 %tobool37, label %if.then38, label %if.end41

if.then38:                                        ; preds = %if.end35
  %si_signo39 = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 0
  %26 = load i32, i32* %si_signo39, align 8, !tbaa !741
  %call40 = call i32 @kill_pid_info_as_cred(i32 %26, %struct.siginfo* %sinfo, %struct.pid* %pid.0, %struct.cred* %cred.0, i32 %secid.0)
  call void @put_pid(%struct.pid* %pid.0)
  call void @put_cred(%struct.cred* %cred.0)
  br label %if.end41

if.end41:                                         ; preds = %if.then38, %if.end35
  %wait = getelementptr inbounds %struct.dev_state, %struct.dev_state* %2, i32 0, i32 6
  call void @__wake_up(%struct.__wait_queue_head* %wait, i32 3, i32 1, i8* null)
  %27 = bitcast %struct.siginfo* %sinfo to i8*
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @snoop_urb(i8* %userurb, i32 %when, i8* %data, i32 %data_len) #0 {
entry:
  %0 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %tobool8 = icmp ne i8* %userurb, null
  %cmp = icmp eq i32 %when, 0
  br i1 %tobool8, label %if.then9, label %if.else14

if.then9:                                         ; preds = %if.end
  br i1 %cmp, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then9
  %1 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %if.end23

if.else:                                          ; preds = %if.then9
  %2 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %if.end23

if.else14:                                        ; preds = %if.end
  br i1 %cmp, label %if.then16, label %if.else19

if.then16:                                        ; preds = %if.else14
  %3 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %if.end23

if.else19:                                        ; preds = %if.else14
  %4 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %if.end23

if.end23:                                         ; preds = %if.else19, %if.then16, %if.else, %if.then10
  %tobool24 = icmp ne i8* %data, null
  %cmp25 = icmp ugt i32 %data_len, 0
  %or.cond = and i1 %tobool24, %cmp25
  br i1 %or.cond, label %if.then26, label %cleanup.cont

if.then26:                                        ; preds = %if.end23
  %conv = zext i32 %data_len to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35.729, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.50.731, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %data, i64 %conv, i1 zeroext true)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then26, %if.end23, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @snoop_urb_data(%struct.urb* %urb, i32 %len) #0 {
entry:
  %0 = load i8, i8* @usbfs_snoop, align 1, !tbaa !43, !range !44
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %1 = load i32, i32* %num_sgs, align 4, !tbaa !330
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %2 = load i8*, i8** %transfer_buffer, align 8, !tbaa !293
  %conv = zext i32 %len to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35.729, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.50.731, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %2, i64 %conv, i1 zeroext true)
  br label %cleanup.cont

if.end2:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end2
  %i.0 = phi i32 [ 0, %if.end2 ], [ %inc, %for.body ]
  %len.addr.0 = phi i32 [ %len, %if.end2 ], [ %sub, %for.body ]
  %num_sgs3 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %3 = load i32, i32* %num_sgs3, align 4, !tbaa !330
  %cmp4 = icmp slt i32 %i.0, %3
  %tobool6 = icmp ne i32 %len.addr.0, 0
  %tobool6. = select i1 %cmp4, i1 %tobool6, i1 false
  br i1 %tobool6., label %for.body, label %cleanup.cont

for.body:                                         ; preds = %for.cond
  %cmp7 = icmp ugt i32 %len.addr.0, 16384
  %.len.addr.0 = select i1 %cmp7, i32 16384, i32 %len.addr.0
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 16
  %4 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8, !tbaa !329
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %4, i64 %idxprom
  %call = call i8* @sg_virt.672(%struct.scatterlist* %arrayidx)
  %conv9 = sext i32 %.len.addr.0 to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35.729, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.50.731, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %call, i64 %conv9, i1 zeroext true)
  %sub = sub i32 %len.addr.0, %.len.addr.0
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup.cont:                                     ; preds = %for.cond, %if.then1, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @async_newpending(%struct.async* %as) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 1
  %0 = load %struct.dev_state*, %struct.dev_state** %ps1, align 8, !tbaa !735
  %1 = bitcast i64* %__dummy to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy2 to i8*
  %4 = bitcast i64* %__dummy to i8*
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check.663(%struct.spinlock* %lock)
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 0
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 4
  call void @list_add_tail.667(%struct.list_head* %asynclist, %struct.list_head* %async_pending)
  %lock6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  call void @spin_unlock_irqrestore.664(%struct.spinlock* %lock6, i64 %call3)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_bulk.725(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 2
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_irq.726(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_num.727(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !286
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irq.728(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

declare i32 @dev_printk(i8*, %struct.device*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define internal void @async_removepending(%struct.async* %as) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 1
  %0 = load %struct.dev_state*, %struct.dev_state** %ps1, align 8, !tbaa !735
  %1 = bitcast i64* %__dummy to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy2 to i8*
  %4 = bitcast i64* %__dummy to i8*
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check.663(%struct.spinlock* %lock)
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 0
  call void @list_del_init.666(%struct.list_head* %asynclist)
  %lock6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  call void @spin_unlock_irqrestore.664(%struct.spinlock* %lock6, i64 %call3)
  ret void
}

declare void @print_hex_dump(i8*, i8*, i32, i32, i32, i8*, i64, i1 zeroext) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock.742(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @cancel_bulk_urbs(%struct.dev_state* %ps, i32 %bulk_addr) #0 {
entry:
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %asynclist13.sink = phi %struct.list_head* [ %asynclist13, %for.inc ], [ %async_pending, %entry ]
  %next14 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist13.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next14, align 8, !tbaa !48
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr16 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr16 to %struct.async*
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 0
  %async_pending1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  %cmp = icmp ne %struct.list_head* %asynclist, %async_pending1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %bulk_addr2 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 12
  %3 = load i8, i8* %bulk_addr2, align 4, !tbaa !737
  %conv = zext i8 %3 to i32
  %cmp3 = icmp eq i32 %conv, %bulk_addr
  br i1 %cmp3, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %bulk_status = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 13
  %4 = load i8, i8* %bulk_status, align 1, !tbaa !738
  %conv5 = zext i8 %4 to i32
  %cmp6 = icmp ne i32 %conv5, 1
  br i1 %cmp6, label %rescan.preheader, label %if.end

if.end:                                           ; preds = %if.then
  %bulk_status9 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 13
  store i8 2, i8* %bulk_status9, align 1, !tbaa !738
  %bulk_addr10 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 12
  store i8 0, i8* %bulk_addr10, align 4, !tbaa !737
  br label %for.inc

for.inc:                                          ; preds = %if.end, %for.body
  %asynclist13 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %shl = shl i32 1, %bulk_addr
  %disabled_bulk_eps = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 13
  %5 = load i32, i32* %disabled_bulk_eps, align 4, !tbaa !739
  %or = or i32 %5, %shl
  store i32 %or, i32* %disabled_bulk_eps, align 4, !tbaa !739
  br label %rescan.preheader

rescan.preheader:                                 ; preds = %for.end, %if.then
  br label %rescan

rescan:                                           ; preds = %if.then32, %rescan.preheader
  %async_pending18 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc38, %rescan
  %asynclist40.sink = phi %struct.list_head* [ %asynclist40, %for.inc38 ], [ %async_pending18, %rescan ]
  %next41 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist40.sink, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next41, align 8, !tbaa !48
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr43 = getelementptr inbounds i8, i8* %7, i64 0
  %8 = bitcast i8* %add.ptr43 to %struct.async*
  %asynclist23 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 0
  %async_pending24 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  %cmp25 = icmp ne %struct.list_head* %asynclist23, %async_pending24
  br i1 %cmp25, label %for.body27, label %for.end44

for.body27:                                       ; preds = %for.cond22
  %bulk_status28 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 13
  %9 = load i8, i8* %bulk_status28, align 1, !tbaa !738
  %conv29 = zext i8 %9 to i32
  %cmp30 = icmp eq i32 %conv29, 2
  br i1 %cmp30, label %if.then32, label %for.inc38

if.then32:                                        ; preds = %for.body27
  %bulk_status33 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 13
  store i8 0, i8* %bulk_status33, align 1, !tbaa !738
  %urb34 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 8
  %10 = load %struct.urb*, %struct.urb** %urb34, align 8, !tbaa !591
  %call = call %struct.urb* bitcast (%struct.urb.824* (%struct.urb.824*)* @usb_get_urb to %struct.urb* (%struct.urb*)*)(%struct.urb* %10)
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_unlock.744(%struct.spinlock* %lock)
  %call35 = call i32 bitcast (i32 (%struct.urb.824*)* @usb_unlink_urb to i32 (%struct.urb*)*)(%struct.urb* %10)
  call void bitcast (void (%struct.urb.824*)* @usb_free_urb to void (%struct.urb*)*)(%struct.urb* %10)
  %lock36 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_lock.742(%struct.spinlock* %lock36)
  br label %rescan

for.inc38:                                        ; preds = %for.body27
  %asynclist40 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 0
  br label %for.cond22

for.end44:                                        ; preds = %for.cond22
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock.744(%struct.spinlock* %lock) #1 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.4* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

declare i32 @kill_pid_info_as_cred(i32, %struct.siginfo*, %struct.pid*, %struct.cred*, i32) #2

declare zeroext i1 @__virt_addr_valid(i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_set_page(%struct.scatterlist* %sg, %struct.page* %page, i32 %len, i32 %offset) #1 {
entry:
  call void @sg_assign_page(%struct.scatterlist* %sg, %struct.page* %page)
  %offset1 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 2
  store i32 %offset, i32* %offset1, align 8, !tbaa !373
  %length = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 3
  store i32 %len, i32* %length, align 4, !tbaa !378
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_assign_page(%struct.scatterlist* %sg, %struct.page* %page) #1 {
entry:
  %page_link1 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %0 = load i64, i64* %page_link1, align 8, !tbaa !383
  %and = and i64 %0, 3
  %1 = ptrtoint %struct.page* %page to i64
  %and2 = and i64 %1, 3
  %tobool = icmp ne i64 %and2, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.body11

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.56.674, i32 0, i32 0), i32 65, i64 12) #8, !srcloc !746
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.body11:                                        ; preds = %entry
  %sg_magic = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 0
  %2 = load i64, i64* %sg_magic, align 8, !tbaa !381
  %cmp = icmp ne i64 %2, 2271560481
  %lnot13 = xor i1 %cmp, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv17 = sext i32 %lnot.ext16 to i64
  %expval18 = call i64 @llvm.expect.i64(i64 %conv17, i64 0)
  %tobool19 = icmp ne i64 %expval18, 0
  br i1 %tobool19, label %do.body21, label %do.body30

do.body21:                                        ; preds = %do.body11
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.56.674, i32 0, i32 0), i32 67, i64 12) #8, !srcloc !747
  br label %do.body22

do.body22:                                        ; preds = %do.body22, %do.body21
  br label %do.body22

do.body30:                                        ; preds = %do.body11
  %page_link31 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %3 = load i64, i64* %page_link31, align 8, !tbaa !383
  %and32 = and i64 %3, 1
  %tobool33 = icmp ne i64 %and32, 0
  %lnot34 = xor i1 %tobool33, true
  %lnot36 = xor i1 %lnot34, true
  %lnot.ext37 = zext i1 %lnot36 to i32
  %conv38 = sext i32 %lnot.ext37 to i64
  %expval39 = call i64 @llvm.expect.i64(i64 %conv38, i64 0)
  %tobool40 = icmp ne i64 %expval39, 0
  br i1 %tobool40, label %do.body42, label %do.end50

do.body42:                                        ; preds = %do.body30
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.56.674, i32 0, i32 0), i32 68, i64 12) #8, !srcloc !748
  br label %do.body43

do.body43:                                        ; preds = %do.body43, %do.body42
  br label %do.body43

do.end50:                                         ; preds = %do.body30
  %4 = ptrtoint %struct.page* %page to i64
  %or = or i64 %and, %4
  %page_link51 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  store i64 %or, i64* %page_link51, align 8, !tbaa !383
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_add(i32 %i, %union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; addl $1,$0", "=*m,ir,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #8, !srcloc !749
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.746(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

declare i8* @compat_alloc_user_space(i64) #2

declare i64 @copy_in_user(i8*, i8*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_interface_claimed(%struct.usb_interface* %iface) #1 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !104
  %cmp = icmp ne %struct.device_driver* %0, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare i64 @strlcpy(i8*, i8*, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @usb_maxpacket.749(%struct.usb_device* %udev, i32 %pipe, i32 %is_out) #1 {
entry:
  %shr = ashr i32 %pipe, 15
  %and = and i32 %shr, 15
  %tobool = icmp ne i32 %is_out, 0
  %and1 = and i32 %pipe, 128
  %tobool2 = icmp ne i32 %and1, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.51.750, i32 0, i32 0), i32 1773)
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.then
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 17
  br label %if.end47

if.else:                                          ; preds = %entry
  %lnot25 = xor i1 %lnot3, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %tobool27 = icmp ne i32 %lnot.ext26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.else
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.51.750, i32 0, i32 0), i32 1776)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.else
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 16
  br label %if.end47

if.end47:                                         ; preds = %if.end36, %if.end
  %ep_in.sink = phi [16 x %struct.usb_host_endpoint*]* [ %ep_in, %if.end36 ], [ %ep_out, %if.end ]
  %idxprom45 = zext i32 %and to i64
  %arrayidx46 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in.sink, i64 0, i64 %idxprom45
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx46, align 8, !tbaa !48
  %tobool48 = icmp ne %struct.usb_host_endpoint* %0, null
  br i1 %tobool48, label %if.end50, label %cleanup

if.end50:                                         ; preds = %if.end47
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %0, i32 0, i32 0
  %call = call i32 @usb_endpoint_maxp.751(%struct.usb_endpoint_descriptor* %desc)
  %conv51 = trunc i32 %call to i16
  br label %cleanup

cleanup:                                          ; preds = %if.end50, %if.end47
  %retval.0 = phi i16 [ %conv51, %if.end50 ], [ 0, %if.end47 ]
  ret i16 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_maxp.751(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 4
  %0 = load i16, i16* %wMaxPacketSize, align 1, !tbaa !199
  %conv = zext i16 %0 to i32
  ret i32 %conv
}

declare i64 @__get_free_pages(i32, i32) #2

declare void @free_pages(i64, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @poll_wait(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #1 {
entry:
  %tobool = icmp ne %struct.poll_table_struct* %p, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %0 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8, !tbaa !750
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.__wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %1 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8, !tbaa !750
  call void %1(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_devio_init() #5 section ".init.text" {
entry:
  %call = call i32 @register_chrdev_region(i32 198180864, i32 8192, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.3.756, i32 0, i32 0))
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = call i32 (i8*, ...) @printk(i8* null)
  br label %out

if.end:                                           ; preds = %entry
  call void @cdev_init(%struct.cdev* @usb_device_cdev, %struct.file_operations* @usbdev_file_operations)
  %call3 = call i32 @cdev_add(%struct.cdev* @usb_device_cdev, i32 198180864, i32 8192)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %1 = call i32 (i8*, ...) @printk(i8* null)
  call void @unregister_chrdev_region(i32 198180864, i32 8192)
  br label %out

if.end7:                                          ; preds = %if.end
  call void @usb_register_notify(%struct.notifier_block* @usbdev_nb)
  br label %out

out:                                              ; preds = %if.end7, %if.then5, %if.then
  %retval1.0 = phi i32 [ %call, %if.then ], [ %call3, %if.then5 ], [ %call3, %if.end7 ]
  ret i32 %retval1.0
}

declare i32 @register_chrdev_region(i32, i32, i8*) #2

declare void @cdev_init(%struct.cdev*, %struct.file_operations*) #2

declare i32 @cdev_add(%struct.cdev*, i32, i32) #2

declare void @unregister_chrdev_region(i32, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_notify(%struct.notifier_block* %self, i64 %action, i8* %dev) #0 {
entry:
  %Pivot = icmp slt i64 %action, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i64 %action, 2
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.epilog

LeafBlock:                                        ; preds = %entry
  ret i32 1

sw.bb:                                            ; preds = %LeafBlock1
  %0 = bitcast i8* %dev to %struct.usb_device*
  call void @usbdev_remove(%struct.usb_device* %0)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb, %LeafBlock1
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal void @usbdev_remove(%struct.usb_device* %udev) #0 {
entry:
  %sinfo = alloca %struct.siginfo, align 8
  %0 = bitcast %struct.siginfo* %sinfo to i8*
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %filelist = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 27
  %call = call i32 @list_empty.665(%struct.list_head* %filelist)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %filelist1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 27
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %filelist1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !752
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.dev_state*
  call void @destroy_all_async(%struct.dev_state* %3)
  %wait = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 6
  call void @__wake_up(%struct.__wait_queue_head* %wait, i32 3, i32 0, i8* null)
  %list = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 0
  call void @list_del_init.666(%struct.list_head* %list)
  %discsignr = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 7
  %4 = load i32, i32* %discsignr, align 8, !tbaa !598
  %tobool2 = icmp ne i32 %4, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %discsignr3 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 7
  %5 = load i32, i32* %discsignr3, align 8, !tbaa !598
  %si_signo = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 0
  store i32 %5, i32* %si_signo, align 8, !tbaa !741
  %si_errno = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 1
  store i32 32, i32* %si_errno, align 4, !tbaa !743
  %si_code = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 2
  store i32 -4, i32* %si_code, align 8, !tbaa !744
  %disccontext = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 10
  %6 = load i8*, i8** %disccontext, align 8, !tbaa !603
  %_sifields = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 3
  %_sigfault = bitcast %union.anon.39* %_sifields to %struct.anon.41*
  %_addr = getelementptr inbounds %struct.anon.41, %struct.anon.41* %_sigfault, i32 0, i32 0
  store i8* %6, i8** %_addr, align 8, !tbaa !84
  %discsignr4 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 7
  %7 = load i32, i32* %discsignr4, align 8, !tbaa !598
  %disc_pid = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 8
  %8 = load %struct.pid*, %struct.pid** %disc_pid, align 8, !tbaa !600
  %cred = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 9
  %9 = load %struct.cred*, %struct.cred** %cred, align 8, !tbaa !602
  %secid = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 12
  %10 = load i32, i32* %secid, align 8, !tbaa !753
  %call5 = call i32 @kill_pid_info_as_cred(i32 %7, %struct.siginfo* %sinfo, %struct.pid* %8, %struct.cred* %9, i32 %10)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %11 = bitcast %struct.siginfo* %sinfo to i8*
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_devio_cleanup() #0 {
entry:
  call void @usb_unregister_notify(%struct.notifier_block* @usbdev_nb)
  call void @cdev_del(%struct.cdev* @usb_device_cdev)
  call void @unregister_chrdev_region(i32 198180864, i32 8192)
  ret void
}

declare void @cdev_del(%struct.cdev*) #2

; Function Attrs: nounwind uwtable
define void @usb_unregister_notify(%struct.notifier_block* %nb) #0 {
entry:
  %call = call i32 @blocking_notifier_chain_unregister(%struct.blocking_notifier_head* @usb_notifier_list, %struct.notifier_block* %nb)
  ret void
}

declare i32 @blocking_notifier_chain_unregister(%struct.blocking_notifier_head*, %struct.notifier_block*) #2

; Function Attrs: nounwind uwtable
define void @usb_register_notify(%struct.notifier_block* %nb) #0 {
entry:
  %call = call i32 @blocking_notifier_chain_register(%struct.blocking_notifier_head* @usb_notifier_list, %struct.notifier_block* %nb)
  ret void
}

declare i32 @blocking_notifier_chain_register(%struct.blocking_notifier_head*, %struct.notifier_block*) #2

; Function Attrs: nounwind uwtable
define void @usb_notify_add_device(%struct.usb_device* %udev) #0 {
entry:
  %0 = bitcast %struct.usb_device* %udev to i8*
  %call = call i32 @blocking_notifier_call_chain(%struct.blocking_notifier_head* @usb_notifier_list, i64 1, i8* %0)
  ret void
}

declare i32 @blocking_notifier_call_chain(%struct.blocking_notifier_head*, i64, i8*) #2

; Function Attrs: nounwind uwtable
define void @usb_notify_remove_device(%struct.usb_device* %udev) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @usbfs_mutex, i32 0)
  %0 = bitcast %struct.usb_device* %udev to i8*
  %call = call i32 @blocking_notifier_call_chain(%struct.blocking_notifier_head* @usb_notifier_list, i64 2, i8* %0)
  call void @mutex_unlock(%struct.mutex* @usbfs_mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_notify_add_bus(%struct.usb_bus* %ubus) #0 {
entry:
  %0 = bitcast %struct.usb_bus* %ubus to i8*
  %call = call i32 @blocking_notifier_call_chain(%struct.blocking_notifier_head* @usb_notifier_list, i64 3, i8* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_notify_remove_bus(%struct.usb_bus* %ubus) #0 {
entry:
  %0 = bitcast %struct.usb_bus* %ubus to i8*
  %call = call i32 @blocking_notifier_call_chain(%struct.blocking_notifier_head* @usb_notifier_list, i64 4, i8* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @generic_probe(%struct.usb_device* %udev) #0 {
entry:
  %authorized = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load = load i16, i16* %authorized, align 4
  %bf.lshr = lshr i16 %bf.load, 3
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end10

if.else:                                          ; preds = %entry
  %call1 = call i32 @usb_choose_configuration(%struct.usb_device* %udev)
  %cmp2 = icmp sge i32 %call1, 0
  br i1 %cmp2, label %if.then3, label %if.end10

if.then3:                                         ; preds = %if.else
  %call4 = call i32 @usb_set_configuration(%struct.usb_device* %udev, i32 %call1)
  switch i32 %call4, label %if.then6 [
    i32 0, label %if.end10
    i32 -19, label %if.end10
  ]

if.then6:                                         ; preds = %if.then3
  %1 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end10

if.end10:                                         ; preds = %if.then6, %if.then3, %if.then3, %if.else, %if.then
  call void @usb_notify_add_device(%struct.usb_device* %udev)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @generic_disconnect(%struct.usb_device* %udev) #0 {
entry:
  call void @usb_notify_remove_device(%struct.usb_device* %udev)
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %tobool = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @usb_set_configuration(%struct.usb_device* %udev, i32 -1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @generic_suspend(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool = icmp ne %struct.usb_device* %0, null
  %event = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %1 = load i32, i32* %event, align 4
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 @hcd_bus_suspend(%struct.usb_device* %udev, i32 %1)
  br label %if.end8

if.else:                                          ; preds = %entry
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.end8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %event2 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %2 = load i32, i32* %event2, align 4, !tbaa !42
  %cmp3 = icmp eq i32 %2, 8
  br i1 %cmp3, label %if.end8, label %if.else5

if.else5:                                         ; preds = %lor.lhs.false
  %coerce.dive6 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %3 = load i32, i32* %coerce.dive6, align 4
  %call7 = call i32 @usb_port_suspend(%struct.usb_device* %udev, i32 %3)
  br label %if.end8

if.end8:                                          ; preds = %if.else5, %lor.lhs.false, %if.else, %if.then
  %rc.1 = phi i32 [ %call, %if.then ], [ %call7, %if.else5 ], [ 0, %lor.lhs.false ], [ 0, %if.else ]
  ret i32 %rc.1
}

; Function Attrs: nounwind uwtable
define internal i32 @generic_resume(%struct.usb_device* %udev, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %union.anon.5, align 4
  %coerce.dive = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 8
  %0 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool = icmp ne %struct.usb_device* %0, null
  %coerce.dive2 = getelementptr inbounds %union.anon.5, %union.anon.5* %msg, i32 0, i32 0
  %1 = load i32, i32* %coerce.dive2, align 4
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 @hcd_bus_resume(%struct.usb_device* %udev, i32 %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call3 = call i32 @usb_port_resume(%struct.usb_device* %udev, i32 %1)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %rc.0 = phi i32 [ %call3, %if.else ], [ %call, %if.then ]
  ret i32 %rc.0
}

; Function Attrs: nounwind uwtable
define i32 @usb_choose_configuration(%struct.usb_device* %udev) #0 {
entry:
  %call = call zeroext i1 @usb_device_is_owned(%struct.usb_device* %udev)
  br i1 %call, label %cleanup71, label %if.end

if.end:                                           ; preds = %entry
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 14
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !167
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 13
  %1 = load i8, i8* %bNumConfigurations, align 1, !tbaa !166
  %conv = zext i8 %1 to i32
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %best.0 = phi %struct.usb_host_config* [ null, %if.end ], [ %best.3, %for.inc ]
  %c.0 = phi %struct.usb_host_config* [ %0, %if.end ], [ %incdec.ptr, %for.inc ]
  %insufficient_power.0 = phi i32 [ 0, %if.end ], [ %insufficient_power.1, %for.inc ]
  %i.0 = phi i32 [ 0, %if.end ], [ %inc43, %for.inc ]
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %desc2 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %c.0, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc2, i32 0, i32 3
  %2 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv3 = zext i8 %2 to i32
  %cmp4 = icmp sgt i32 %conv3, 0
  br i1 %cmp4, label %if.then6, label %if.end8

if.then6:                                         ; preds = %for.body
  %intf_cache = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %c.0, i32 0, i32 4
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache, i64 0, i64 0
  %3 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx, align 8, !tbaa !48
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %3, i32 0, i32 2
  %arraydecay = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i32 0, i32 0
  %desc7 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arraydecay, i32 0, i32 0
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %for.body
  %desc.0 = phi %struct.usb_interface_descriptor* [ %desc7, %if.then6 ], [ null, %for.body ]
  %call9 = call i32 @usb_get_max_power.779(%struct.usb_device* %udev, %struct.usb_host_config* %c.0)
  %bus_mA = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 19
  %4 = load i16, i16* %bus_mA, align 8, !tbaa !258
  %conv10 = zext i16 %4 to i32
  %cmp11 = icmp ugt i32 %call9, %conv10
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end8
  %inc = add nsw i32 %insufficient_power.0, 1
  br label %NodeBlock

if.end14:                                         ; preds = %if.end8
  %cmp15 = icmp eq i32 %i.0, 0
  %cmp17 = icmp sgt i32 %conv, 1
  %or.cond = and i1 %cmp15, %cmp17
  %tobool = icmp ne %struct.usb_interface_descriptor* %desc.0, null
  %or.cond1 = and i1 %or.cond, %tobool
  br i1 %or.cond1, label %land.lhs.true20, label %if.else

land.lhs.true20:                                  ; preds = %if.end14
  %call21 = call i32 @is_rndis(%struct.usb_interface_descriptor* %desc.0)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %NodeBlock, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true20
  %call23 = call i32 @is_activesync(%struct.usb_interface_descriptor* %desc.0)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %NodeBlock, label %if.else

if.else:                                          ; preds = %lor.lhs.false, %if.end14
  %descriptor26 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bDeviceClass = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor26, i32 0, i32 3
  %5 = load i8, i8* %bDeviceClass, align 4, !tbaa !241
  %conv27 = zext i8 %5 to i32
  %cmp28 = icmp ne i32 %conv27, 255
  %tobool31 = icmp ne %struct.usb_interface_descriptor* %desc.0, null
  %or.cond2 = and i1 %cmp28, %tobool31
  br i1 %or.cond2, label %land.lhs.true32, label %if.else37

land.lhs.true32:                                  ; preds = %if.else
  %bInterfaceClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc.0, i32 0, i32 5
  %6 = load i8, i8* %bInterfaceClass, align 1, !tbaa !754
  %conv33 = zext i8 %6 to i32
  %cmp34 = icmp ne i32 %conv33, 255
  br i1 %cmp34, label %NodeBlock, label %if.else37

if.else37:                                        ; preds = %land.lhs.true32, %if.else
  %tobool38 = icmp ne %struct.usb_host_config* %best.0, null
  %best.0.c.0 = select i1 %tobool38, %struct.usb_host_config* %best.0, %struct.usb_host_config* %c.0
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.else37, %land.lhs.true32, %lor.lhs.false, %land.lhs.true20, %if.then13
  %best.3 = phi %struct.usb_host_config* [ %best.0, %if.then13 ], [ %c.0, %land.lhs.true32 ], [ %best.0.c.0, %if.else37 ], [ %c.0, %lor.lhs.false ], [ %c.0, %land.lhs.true20 ]
  %insufficient_power.1 = phi i32 [ %inc, %if.then13 ], [ %insufficient_power.0, %land.lhs.true32 ], [ %insufficient_power.0, %land.lhs.true20 ], [ %insufficient_power.0, %lor.lhs.false ], [ %insufficient_power.0, %if.else37 ]
  %cleanup.dest.slot.0 = phi i32 [ 4, %if.then13 ], [ 2, %land.lhs.true32 ], [ 0, %land.lhs.true20 ], [ 0, %lor.lhs.false ], [ 0, %if.else37 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 4
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 2
  %or.cond3 = and i1 %Pivot, %SwitchLeaf
  br i1 %or.cond3, label %for.end, label %for.inc

for.inc:                                          ; preds = %NodeBlock
  %inc43 = add nsw i32 %i.0, 1
  %incdec.ptr = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %c.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %NodeBlock, %for.cond
  %best.4 = phi %struct.usb_host_config* [ %best.0, %for.cond ], [ %best.3, %NodeBlock ]
  %insufficient_power.2 = phi i32 [ %insufficient_power.0, %for.cond ], [ %insufficient_power.1, %NodeBlock ]
  %cmp44 = icmp sgt i32 %insufficient_power.2, 0
  br i1 %cmp44, label %if.then46, label %if.end49

if.then46:                                        ; preds = %for.end
  %call47 = call i8* @plural.780(i32 %insufficient_power.2)
  %7 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %if.end49

if.end49:                                         ; preds = %if.then46, %for.end
  %tobool50 = icmp ne %struct.usb_host_config* %best.4, null
  br i1 %tobool50, label %if.then51, label %if.else66

if.then51:                                        ; preds = %if.end49
  %desc52 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %best.4, i32 0, i32 0
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc52, i32 0, i32 4
  %8 = load i8, i8* %bConfigurationValue, align 1, !tbaa !147
  %conv53 = zext i8 %8 to i32
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_choose_configuration.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool55 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool55, true
  %lnot56 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot56 to i32
  %conv57 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv57, i64 0)
  %tobool58 = icmp ne i64 %expval, 0
  br i1 %tobool58, label %if.then59, label %cleanup71

if.then59:                                        ; preds = %if.then51
  %dev60 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call61 = call i8* @plural.780(i32 %conv)
  %call62 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_choose_configuration.descriptor to %struct._ddebug*), %struct.device* %dev60, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.3.782, i32 0, i32 0), i32 %conv53, i32 %conv, i8* %call61)
  br label %cleanup71

if.else66:                                        ; preds = %if.end49
  %call68 = call i8* @plural.780(i32 %conv)
  %9 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup71

cleanup71:                                        ; preds = %if.else66, %if.then59, %if.then51, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ -1, %if.else66 ], [ %conv53, %if.then59 ], [ %conv53, %if.then51 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_get_max_power.779(%struct.usb_device* %udev, %struct.usb_host_config* %c) #1 {
entry:
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 4
  %0 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp eq i32 %0, 5
  %cond = select i1 %cmp, i32 8, i32 2
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %c, i32 0, i32 0
  %bMaxPower = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 7
  %1 = load i8, i8* %bMaxPower, align 8, !tbaa !267
  %conv = zext i8 %1 to i32
  %mul1 = mul i32 %conv, %cond
  ret i32 %mul1
}

; Function Attrs: nounwind uwtable
define internal i32 @is_rndis(%struct.usb_interface_descriptor* %desc) #0 {
entry:
  %bInterfaceClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 5
  %0 = load i8, i8* %bInterfaceClass, align 1, !tbaa !754
  %conv = zext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 2
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %bInterfaceSubClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 6
  %1 = load i8, i8* %bInterfaceSubClass, align 1, !tbaa !755
  %conv2 = zext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 2
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %bInterfaceProtocol = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 7
  %2 = load i8, i8* %bInterfaceProtocol, align 1, !tbaa !756
  %conv5 = zext i8 %2 to i32
  %cmp6 = icmp eq i32 %conv5, 255
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %3 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp6, %land.rhs ]
  %land.ext = zext i1 %3 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define internal i32 @is_activesync(%struct.usb_interface_descriptor* %desc) #0 {
entry:
  %bInterfaceClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 5
  %0 = load i8, i8* %bInterfaceClass, align 1, !tbaa !754
  %conv = zext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 239
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %bInterfaceSubClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 6
  %1 = load i8, i8* %bInterfaceSubClass, align 1, !tbaa !755
  %conv2 = zext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 1
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %bInterfaceProtocol = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 7
  %2 = load i8, i8* %bInterfaceProtocol, align 1, !tbaa !756
  %conv5 = zext i8 %2 to i32
  %cmp6 = icmp eq i32 %conv5, 1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %3 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp6, %land.rhs ]
  %land.ext = zext i1 %3 to i32
  ret i32 %land.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @plural.780(i32 %n) #1 {
entry:
  %cmp = icmp eq i32 %n, 1
  %cond = select i1 %cmp, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.27.821, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8.787, i32 0, i32 0)
  ret i8* %cond
}

; Function Attrs: nounwind uwtable
define void @usb_detect_quirks(%struct.usb_device* %udev) #0 {
entry:
  %call = call i32 @__usb_detect_quirks(%struct.usb_device* %udev, %struct.usb_device_id* getelementptr inbounds ([33 x %struct.usb_device_id], [33 x %struct.usb_device_id]* @usb_quirk_list, i32 0, i32 0))
  %quirks = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  store i32 %call, i32* %quirks, align 4, !tbaa !259
  %quirks1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %0 = load i32, i32* %quirks1, align 4, !tbaa !259
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %do.body2, label %if.end10

do.body2:                                         ; preds = %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_detect_quirks.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool3 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool3, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then6, label %if.end10

if.then6:                                         ; preds = %do.body2
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %quirks7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %1 = load i32, i32* %quirks7, align 4, !tbaa !259
  %call8 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_detect_quirks.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.2.790, i32 0, i32 0), i32 %1)
  br label %if.end10

if.end10:                                         ; preds = %if.then6, %do.body2, %entry
  %quirks11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %2 = load i32, i32* %quirks11, align 4, !tbaa !259
  %and12 = and i32 %2, 16
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.end17, label %if.then14

if.then14:                                        ; preds = %if.end10
  %persist_enabled = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 22
  %bf.load15 = load i16, i16* %persist_enabled, align 4
  %bf.clear16 = and i16 %bf.load15, -3
  %bf.set = or i16 %bf.clear16, 2
  store i16 %bf.set, i16* %persist_enabled, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %if.end10
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @__usb_detect_quirks(%struct.usb_device* %udev, %struct.usb_device_id* %id) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %id.addr.0 = phi %struct.usb_device_id* [ %id, %entry ], [ %incdec.ptr, %for.inc ]
  %quirks.0 = phi i32 [ 0, %entry ], [ %quirks.1, %for.inc ]
  %match_flags = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 0, i32 0
  %0 = load i16, i16* %match_flags, align 8, !tbaa !233
  %tobool = icmp ne i16 %0, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @usb_match_device(%struct.usb_device* %udev, %struct.usb_device_id* %id.addr.0)
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.end, label %for.inc

if.end:                                           ; preds = %for.body
  %match_flags2 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 0, i32 0
  %1 = load i16, i16* %match_flags2, align 8, !tbaa !233
  %conv = zext i16 %1 to i32
  %and = and i32 %conv, 896
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %call4 = call zeroext i1 @usb_match_any_interface(%struct.usb_device* %udev, %struct.usb_device_id* %id.addr.0)
  br i1 %call4, label %if.end6, label %for.inc

if.end6:                                          ; preds = %land.lhs.true, %if.end
  %driver_info = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 0, i32 12
  %2 = load i64, i64* %driver_info, align 8, !tbaa !277
  %conv7 = trunc i64 %2 to i32
  %or = or i32 %quirks.0, %conv7
  br label %for.inc

for.inc:                                          ; preds = %if.end6, %land.lhs.true, %for.body
  %quirks.1 = phi i32 [ %or, %if.end6 ], [ %quirks.0, %for.body ], [ %quirks.0, %land.lhs.true ]
  %incdec.ptr = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id.addr.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret i32 %quirks.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @usb_match_any_interface(%struct.usb_device* %udev, %struct.usb_device_id* %id) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc20, %for.inc19 ]
  %retval.0 = phi i1 [ undef, %entry ], [ %retval.3, %for.inc19 ]
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 13
  %0 = load i8, i8* %bNumConfigurations, align 1, !tbaa !166
  %conv = zext i8 %0 to i32
  %cmp = icmp ult i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %cleanup22

for.body:                                         ; preds = %for.cond
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 14
  %1 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !167
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %1, i64 %idxprom
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %for.body
  %j.0 = phi i32 [ 0, %for.body ], [ %inc, %for.inc ]
  %retval.1 = phi i1 [ %retval.0, %for.body ], [ %retval.2, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %2 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv3 = zext i8 %2 to i32
  %cmp4 = icmp ult i32 %j.0, %conv3
  br i1 %cmp4, label %for.body6, label %LeafBlock4

for.body6:                                        ; preds = %for.cond2
  %intf_cache = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx, i32 0, i32 4
  %idxprom7 = zext i32 %j.0 to i64
  %arrayidx8 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache, i64 0, i64 %idxprom7
  %3 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx8, align 8, !tbaa !48
  %num_altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %3, i32 0, i32 0
  %4 = load i32, i32* %num_altsetting, align 8, !tbaa !69
  %cmp9 = icmp eq i32 %4, 0
  br i1 %cmp9, label %NodeBlock, label %if.end

if.end:                                           ; preds = %for.body6
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %3, i32 0, i32 2
  %arrayidx11 = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i64 0, i64 0
  %call = call i32 @usb_match_one_id_intf(%struct.usb_device* %udev, %struct.usb_host_interface* %arrayidx11, %struct.usb_device_id* %id)
  %tobool = icmp ne i32 %call, 0
  %. = select i1 %tobool, i32 1, i32 0
  %.retval.1 = select i1 %tobool, i1 true, i1 %retval.1
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end, %for.body6
  %cleanup.dest.slot.0 = phi i32 [ 7, %for.body6 ], [ %., %if.end ]
  %retval.2 = phi i1 [ %retval.1, %for.body6 ], [ %.retval.1, %if.end ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 7
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 7
  br i1 %SwitchLeaf2, label %for.inc, label %LeafBlock4

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc, label %LeafBlock4

for.inc:                                          ; preds = %LeafBlock, %LeafBlock1
  %inc = add i32 %j.0, 1
  br label %for.cond2

LeafBlock4:                                       ; preds = %LeafBlock, %LeafBlock1, %for.cond2
  %cleanup.dest.slot.1 = phi i32 [ 0, %for.cond2 ], [ %cleanup.dest.slot.0, %LeafBlock1 ], [ %cleanup.dest.slot.0, %LeafBlock ]
  %retval.3 = phi i1 [ %retval.1, %for.cond2 ], [ %retval.2, %LeafBlock1 ], [ %retval.2, %LeafBlock ]
  %SwitchLeaf5 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf5, label %for.inc19, label %cleanup22

for.inc19:                                        ; preds = %LeafBlock4
  %inc20 = add i32 %i.0, 1
  br label %for.cond

cleanup22:                                        ; preds = %LeafBlock4, %for.cond
  %retval.4 = phi i1 [ false, %for.cond ], [ %retval.3, %LeafBlock4 ]
  ret i1 %retval.4
}

; Function Attrs: nounwind uwtable
define void @usb_detect_interface_quirks(%struct.usb_device* %udev) #0 {
entry:
  %call = call i32 @__usb_detect_quirks(%struct.usb_device* %udev, %struct.usb_device_id* getelementptr inbounds ([2 x %struct.usb_device_id], [2 x %struct.usb_device_id]* @usb_interface_quirk_list, i32 0, i32 0))
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %cleanup.cont, label %do.body1

do.body1:                                         ; preds = %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_detect_interface_quirks.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.end8

if.then4:                                         ; preds = %do.body1
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call5 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_detect_interface_quirks.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.3.795, i32 0, i32 0), i32 %call)
  br label %do.end8

do.end8:                                          ; preds = %if.then4, %do.body1
  %quirks9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 29
  %0 = load i32, i32* %quirks9, align 4, !tbaa !259
  %or = or i32 %0, %call
  store i32 %or, i32* %quirks9, align 4, !tbaa !259
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %do.end8, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @usb_device_lseek(%struct.file* %file, i64 %offset, i32 %orig) #0 {
entry:
  %call = call %struct.inode* @file_inode.840(%struct.file* %file)
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 0)
  %Pivot4 = icmp slt i32 %orig, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %orig, 2
  br i1 %Pivot, label %sw.bb2, label %sw.epilog

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %orig, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %f_pos = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  store i64 %offset, i64* %f_pos, align 8, !tbaa !592
  %f_pos1 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  %0 = load i64, i64* %f_pos1, align 8, !tbaa !592
  br label %sw.epilog

sw.bb2:                                           ; preds = %NodeBlock
  %f_pos3 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  %1 = load i64, i64* %f_pos3, align 8, !tbaa !592
  %add = add nsw i64 %1, %offset
  store i64 %add, i64* %f_pos3, align 8, !tbaa !592
  %f_pos4 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  %2 = load i64, i64* %f_pos4, align 8, !tbaa !592
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb2, %sw.bb, %LeafBlock, %NodeBlock
  %ret.0 = phi i64 [ %0, %sw.bb ], [ %2, %sw.bb2 ], [ -22, %LeafBlock ], [ -22, %NodeBlock ]
  %call6 = call %struct.inode* @file_inode.840(%struct.file* %file)
  %i_mutex7 = getelementptr inbounds %struct.inode, %struct.inode* %call6, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex7)
  ret i64 %ret.0
}

; Function Attrs: nounwind uwtable
define internal i64 @usb_device_read(%struct.file* %file, i8* %buf, i64 %nbytes, i64* %ppos) #0 {
entry:
  %buf.addr = alloca i8*, align 8
  %nbytes.addr = alloca i64, align 8
  %skip_bytes = alloca i64, align 8
  store i8* %buf, i8** %buf.addr, align 8, !tbaa !48
  store i64 %nbytes, i64* %nbytes.addr, align 8, !tbaa !49
  %0 = bitcast i64* %skip_bytes to i8*
  %1 = load i64, i64* %ppos, align 8, !tbaa !339
  store i64 %1, i64* %skip_bytes, align 8, !tbaa !339
  %2 = load i64, i64* %ppos, align 8, !tbaa !339
  %cmp = icmp slt i64 %2, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %3 = load i64, i64* %nbytes.addr, align 8, !tbaa !49
  %cmp1 = icmp ule i64 %3, 0
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %4 = load i8*, i8** %buf.addr, align 8, !tbaa !48
  %5 = load i64, i64* %nbytes.addr, align 8, !tbaa !49
  %call = call %struct.thread_info* @current_thread_info.801()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 6
  %seg = getelementptr inbounds %struct.pgprot, %struct.pgprot* %addr_limit, i32 0, i32 0
  %6 = load i64, i64* %seg, align 8, !tbaa !629
  %7 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(i8* %4, i64 %5, i64 %6) #9, !srcloc !757
  %asmresult = extractvalue { i64, i64 } %7, 0
  %cmp5 = icmp eq i64 %asmresult, 0
  %lnot = xor i1 %cmp5, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.end8, label %cleanup

if.end8:                                          ; preds = %if.end3
  call void @mutex_lock_nested(%struct.mutex* @usb_bus_list_lock, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end8
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @usb_bus_list, i32 0, i32 0), %if.end8 ]
  %total_written.0 = phi i64 [ 0, %if.end8 ], [ %total_written.1, %for.inc ]
  %8 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !48
  %9 = bitcast %struct.list_head* %8 to i8*
  %add.ptr27 = getelementptr inbounds i8, i8* %9, i64 -72
  %10 = bitcast i8* %add.ptr27 to %struct.usb_bus*
  %bus_list = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %10, i32 0, i32 12
  %cmp10 = icmp ne %struct.list_head* %bus_list, @usb_bus_list
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call12 = call %struct.usb_hcd* @bus_to_hcd.802(%struct.usb_bus* %10)
  %rh_registered = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call12, i32 0, i32 11
  %bf.load = load i8, i8* %rh_registered, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool13 = icmp ne i32 %bf.cast, 0
  br i1 %tobool13, label %if.end15, label %for.inc

if.end15:                                         ; preds = %for.body
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %10, i32 0, i32 10
  %11 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !228
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %11, i32 0, i32 11
  call void @device_lock.803(%struct.device* %dev)
  %root_hub16 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %10, i32 0, i32 10
  %12 = load %struct.usb_device*, %struct.usb_device** %root_hub16, align 8, !tbaa !228
  %call17 = call i64 @usb_device_dump(i8** %buf.addr, i64* %nbytes.addr, i64* %skip_bytes, i64* %ppos, %struct.usb_device* %12, i32 0)
  %root_hub18 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %10, i32 0, i32 10
  %13 = load %struct.usb_device*, %struct.usb_device** %root_hub18, align 8, !tbaa !228
  %dev19 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 11
  call void @device_unlock.804(%struct.device* %dev19)
  %cmp20 = icmp slt i64 %call17, 0
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end15
  call void @mutex_unlock(%struct.mutex* @usb_bus_list_lock)
  br label %cleanup

if.end23:                                         ; preds = %if.end15
  %add = add nsw i64 %total_written.0, %call17
  br label %for.inc

for.inc:                                          ; preds = %if.end23, %for.body
  %total_written.1 = phi i64 [ %add, %if.end23 ], [ %total_written.0, %for.body ]
  %bus_list25 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %10, i32 0, i32 12
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %bus_list25, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @mutex_unlock(%struct.mutex* @usb_bus_list_lock)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then22, %if.end3, %if.end, %entry
  %retval.0 = phi i64 [ %call17, %if.then22 ], [ %total_written.0, %for.end ], [ -22, %entry ], [ 0, %if.end ], [ -14, %if.end3 ]
  %14 = bitcast i64* %skip_bytes to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_device_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  call void @poll_wait.798(%struct.file* %file, %struct.__wait_queue_head* getelementptr inbounds (%struct.device_connect_event, %struct.device_connect_event* @device_event, i32 0, i32 1), %struct.poll_table_struct* %wait)
  %call = call i32 @atomic_read.799(%union.anon.5* getelementptr inbounds (%struct.device_connect_event, %struct.device_connect_event* @device_event, i32 0, i32 0))
  %f_version = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 13
  %0 = load i64, i64* %f_version, align 8, !tbaa !758
  %conv = zext i32 %call to i64
  %cmp = icmp ne i64 %0, %conv
  br i1 %cmp, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  %conv2 = zext i32 %call to i64
  %f_version3 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 13
  store i64 %conv2, i64* %f_version3, align 8, !tbaa !758
  br label %cleanup

cleanup:                                          ; preds = %if.then, %entry
  %retval.0 = phi i32 [ 65, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @poll_wait.798(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #1 {
entry:
  %tobool = icmp ne %struct.poll_table_struct* %p, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %0 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8, !tbaa !750
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.__wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %1 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8, !tbaa !750
  call void %1(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read.799(%union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !90
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.801() #1 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #4, !srcloc !759
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd* @bus_to_hcd.802(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd*
  ret %struct.usb_hcd* %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock.803(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @usb_device_dump(i8** %buffer, i64* %nbytes, i64* %skip_bytes, i64* %file_offset, %struct.usb_device* %usbdev, i32 %level) #0 {
entry:
  %0 = load i64, i64* %nbytes, align 8, !tbaa !49
  %cmp = icmp ule i64 %0, 0
  %cmp1 = icmp sgt i32 %level, 6
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %entry
  %call = call i64 @__get_free_pages(i32 16, i32 1)
  %1 = inttoptr i64 %call to i8*
  %tobool = icmp ne i8* %1, null
  br i1 %tobool, label %if.end5, label %cleanup

if.end5:                                          ; preds = %if.end3
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usbdev, i32 0, i32 8
  %2 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool6 = icmp ne %struct.usb_device* %2, null
  br i1 %tobool6, label %land.lhs.true, label %if.end12

land.lhs.true:                                    ; preds = %if.end5
  %parent7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usbdev, i32 0, i32 8
  %3 = load %struct.usb_device*, %struct.usb_device** %parent7, align 8, !tbaa !89
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 0
  %4 = load i32, i32* %devnum, align 8, !tbaa !38
  %cmp8 = icmp ne i32 %4, -1
  br i1 %cmp8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %land.lhs.true
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %land.lhs.true, %if.end5
  %speed13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usbdev, i32 0, i32 4
  %5 = load i32, i32* %speed13, align 4, !tbaa !153
  %Pivot8 = icmp slt i32 %5, 2
  br i1 %Pivot8, label %NodeBlock, label %NodeBlock5

NodeBlock5:                                       ; preds = %if.end12
  %Pivot6 = icmp slt i32 %5, 3
  br i1 %Pivot6, label %sw.epilog, label %NodeBlock3

NodeBlock3:                                       ; preds = %NodeBlock5
  %Pivot4 = icmp slt i32 %5, 5
  br i1 %Pivot4, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %5, 5
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

NodeBlock:                                        ; preds = %if.end12
  %Pivot = icmp slt i32 %5, 1
  br i1 %Pivot, label %LeafBlock, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %5, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock, %NodeBlock, %LeafBlock1, %NodeBlock3, %NodeBlock5
  %6 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext = sext i32 %6 to i64
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 %idx.ext
  %cmp19 = icmp eq i32 %level, 0
  br i1 %cmp19, label %if.then20, label %if.end32

if.then20:                                        ; preds = %sw.epilog
  %speed21 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usbdev, i32 0, i32 4
  %7 = load i32, i32* %speed21, align 4, !tbaa !153
  %cmp22 = icmp eq i32 %7, 3
  br i1 %cmp22, label %if.end26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then20
  br label %if.end26

if.end26:                                         ; preds = %lor.lhs.false, %if.then20
  %8 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext30 = sext i32 %8 to i64
  %add.ptr31 = getelementptr inbounds i8, i8* %add.ptr, i64 %idx.ext30
  br label %if.end32

if.end32:                                         ; preds = %if.end26, %sw.epilog
  %data_end.0 = phi i8* [ %add.ptr31, %if.end26 ], [ %add.ptr, %sw.epilog ]
  %add.ptr33 = getelementptr inbounds i8, i8* %1, i64 8192
  %add.ptr34 = getelementptr inbounds i8, i8* %add.ptr33, i64 -256
  %call35 = call i8* @usb_dump_desc(i8* %data_end.0, i8* %add.ptr34, %struct.usb_device* %usbdev)
  %add.ptr36 = getelementptr inbounds i8, i8* %1, i64 8192
  %add.ptr37 = getelementptr inbounds i8, i8* %add.ptr36, i64 -256
  %cmp38 = icmp ugt i8* %call35, %add.ptr37
  br i1 %cmp38, label %if.then39, label %if.end43

if.then39:                                        ; preds = %if.end32
  %9 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext41 = sext i32 %9 to i64
  %add.ptr42 = getelementptr inbounds i8, i8* %call35, i64 %idx.ext41
  br label %if.end43

if.end43:                                         ; preds = %if.then39, %if.end32
  %data_end.1 = phi i8* [ %add.ptr42, %if.then39 ], [ %call35, %if.end32 ]
  %sub.ptr.lhs.cast = ptrtoint i8* %data_end.1 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  %conv44 = zext i32 %conv to i64
  %10 = load i64, i64* %skip_bytes, align 8, !tbaa !339
  %cmp45 = icmp sgt i64 %conv44, %10
  br i1 %cmp45, label %if.then47, label %if.else69

if.then47:                                        ; preds = %if.end43
  %11 = load i64, i64* %skip_bytes, align 8, !tbaa !339
  %conv48 = zext i32 %conv to i64
  %sub = sub nsw i64 %conv48, %11
  %conv49 = trunc i64 %sub to i32
  %conv50 = zext i32 %conv49 to i64
  %12 = load i64, i64* %nbytes, align 8, !tbaa !49
  %cmp51 = icmp ugt i64 %conv50, %12
  br i1 %cmp51, label %if.then53, label %if.end55

if.then53:                                        ; preds = %if.then47
  %13 = load i64, i64* %nbytes, align 8, !tbaa !49
  %conv54 = trunc i64 %13 to i32
  br label %if.end55

if.end55:                                         ; preds = %if.then53, %if.then47
  %length.0 = phi i32 [ %conv54, %if.then53 ], [ %conv49, %if.then47 ]
  %14 = load i8*, i8** %buffer, align 8, !tbaa !48
  %15 = load i64, i64* %skip_bytes, align 8, !tbaa !339
  %add.ptr56 = getelementptr inbounds i8, i8* %1, i64 %15
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %14, i8* %add.ptr56, i32 %length.0) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool58 = icmp ne i32 %conv.i, 0
  br i1 %tobool58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.end55
  %16 = ptrtoint i8* %1 to i64
  call void @free_pages(i64 %16, i32 1)
  br label %cleanup

if.end60:                                         ; preds = %if.end55
  %conv61 = zext i32 %length.0 to i64
  %17 = load i64, i64* %nbytes, align 8, !tbaa !49
  %sub62 = sub i64 %17, %conv61
  store i64 %sub62, i64* %nbytes, align 8, !tbaa !49
  %conv63 = zext i32 %length.0 to i64
  %18 = load i64, i64* %file_offset, align 8, !tbaa !339
  %add64 = add nsw i64 %18, %conv63
  store i64 %add64, i64* %file_offset, align 8, !tbaa !339
  %conv65 = zext i32 %length.0 to i64
  %add66 = add nsw i64 0, %conv65
  %19 = load i8*, i8** %buffer, align 8, !tbaa !48
  %idx.ext67 = zext i32 %length.0 to i64
  %add.ptr68 = getelementptr inbounds i8, i8* %19, i64 %idx.ext67
  store i8* %add.ptr68, i8** %buffer, align 8, !tbaa !48
  br label %if.end72

if.else69:                                        ; preds = %if.end43
  %conv70 = zext i32 %conv to i64
  %20 = load i64, i64* %skip_bytes, align 8, !tbaa !339
  %sub71 = sub nsw i64 %20, %conv70
  br label %if.end72

if.end72:                                         ; preds = %if.else69, %if.end60
  %sub71.sink = phi i64 [ %sub71, %if.else69 ], [ 0, %if.end60 ]
  %total_written.0 = phi i64 [ %add66, %if.end60 ], [ 0, %if.else69 ]
  store i64 %sub71.sink, i64* %skip_bytes, align 8, !tbaa !339
  %21 = ptrtoint i8* %1 to i64
  call void @free_pages(i64 %21, i32 1)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end72
  %inc92.sink = phi i32 [ %inc92, %for.inc ], [ 1, %if.end72 ]
  %chix.0 = phi i32 [ 1, %if.end72 ], [ %inc92, %for.inc ]
  %cnt.0 = phi i32 [ 0, %if.end72 ], [ %cnt.1, %for.inc ]
  %total_written.1 = phi i64 [ %total_written.0, %if.end72 ], [ %total_written.2, %for.inc ]
  %call93 = call %struct.usb_device* @usb_hub_find_child(%struct.usb_device* %usbdev, i32 %inc92.sink)
  %maxchild74 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %usbdev, i32 0, i32 28
  %22 = load i32, i32* %maxchild74, align 8, !tbaa !97
  %cmp75 = icmp sle i32 %chix.0, %22
  br i1 %cmp75, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %tobool77 = icmp ne %struct.usb_device* %call93, null
  br i1 %tobool77, label %if.else79, label %for.inc

if.else79:                                        ; preds = %for.body
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call93, i32 0, i32 11
  call void @device_lock.803(%struct.device* %dev)
  %add80 = add nsw i32 %level, 1
  %sub81 = sub nsw i32 %chix.0, 1
  %inc = add nsw i32 %cnt.0, 1
  %call82 = call i64 @usb_device_dump(i8** %buffer, i64* %nbytes, i64* %skip_bytes, i64* %file_offset, %struct.usb_device* %call93, i32 %add80)
  %conv83 = trunc i64 %call82 to i32
  %dev84 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call93, i32 0, i32 11
  call void @device_unlock.804(%struct.device* %dev84)
  %cmp85 = icmp eq i32 %conv83, -14
  br i1 %cmp85, label %cleanup, label %if.end88

if.end88:                                         ; preds = %if.else79
  %conv89 = sext i32 %conv83 to i64
  %add90 = add nsw i64 %total_written.1, %conv89
  br label %for.inc

for.inc:                                          ; preds = %if.end88, %for.body
  %cnt.1 = phi i32 [ %inc, %if.end88 ], [ %cnt.0, %for.body ]
  %total_written.2 = phi i64 [ %add90, %if.end88 ], [ %total_written.1, %for.body ]
  %inc92 = add nsw i32 %chix.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.else79, %for.cond, %if.then59, %if.end3, %entry
  %retval.0 = phi i64 [ -14, %if.then59 ], [ 0, %entry ], [ -12, %if.end3 ], [ %total_written.1, %if.else79 ], [ %total_written.1, %for.cond ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock.804(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_desc(i8* %start, i8* %end, %struct.usb_device* %dev) #0 {
entry:
  %cmp = icmp ugt i8* %start, %end
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %call = call i8* @usb_dump_device_descriptor(i8* %start, i8* %end, %struct.usb_device_descriptor* %descriptor)
  %cmp1 = icmp ugt i8* %call, %end
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %call4 = call i8* @usb_dump_device_strings(i8* %call, i8* %end, %struct.usb_device* %dev)
  br label %for.cond

for.cond:                                         ; preds = %if.end11, %if.end3
  %i.0 = phi i32 [ 0, %if.end3 ], [ %inc, %if.end11 ]
  %start.addr.0 = phi i8* [ %call4, %if.end3 ], [ %call17, %if.end11 ]
  %descriptor5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor5, i32 0, i32 13
  %0 = load i8, i8* %bNumConfigurations, align 1, !tbaa !166
  %conv = zext i8 %0 to i32
  %cmp6 = icmp sge i32 %i.0, %conv
  %cmp8 = icmp ugt i8* %start.addr.0, %end
  %or.cond = or i1 %cmp6, %cmp8
  br i1 %or.cond, label %cleanup, label %if.end11

if.end11:                                         ; preds = %for.cond
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 4
  %1 = load i32, i32* %speed, align 4, !tbaa !153
  %config = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %config, align 8, !tbaa !167
  %idx.ext = sext i32 %i.0 to i64
  %add.ptr = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %2, i64 %idx.ext
  %config12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 14
  %3 = load %struct.usb_host_config*, %struct.usb_host_config** %config12, align 8, !tbaa !167
  %idx.ext13 = sext i32 %i.0 to i64
  %add.ptr14 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %3, i64 %idx.ext13
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %4 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !64
  %cmp15 = icmp eq %struct.usb_host_config* %add.ptr14, %4
  %conv16 = zext i1 %cmp15 to i32
  %call17 = call i8* @usb_dump_config(i32 %1, i8* %start.addr.0, i8* %end, %struct.usb_host_config* %add.ptr)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %if.end, %entry
  %retval.0 = phi i8* [ %start, %entry ], [ %call, %if.end ], [ %start.addr.0, %for.cond ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_device_descriptor(i8* %start, i8* %end, %struct.usb_device_descriptor* %desc) #0 {
entry:
  %cmp = icmp ugt i8* %start, %end
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %bDeviceClass5 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %desc, i32 0, i32 3
  %0 = load i8, i8* %bDeviceClass5, align 1, !tbaa !760
  %conv6 = zext i8 %0 to i32
  call void @class_decode(i32 %conv6)
  %1 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds i8, i8* %start, i64 %idx.ext
  %cmp12 = icmp ugt i8* %add.ptr, %end
  br i1 %cmp12, label %cleanup, label %if.end15

if.end15:                                         ; preds = %if.end
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext23 = sext i32 %2 to i64
  %add.ptr24 = getelementptr inbounds i8, i8* %add.ptr, i64 %idx.ext23
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.end, %entry
  %retval.0 = phi i8* [ %add.ptr24, %if.end15 ], [ %start, %entry ], [ %add.ptr, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_device_strings(i8* %start, i8* %end, %struct.usb_device* %dev) #0 {
entry:
  %cmp = icmp ugt i8* %start, %end
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %manufacturer = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 25
  %0 = load i8*, i8** %manufacturer, align 8, !tbaa !40
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then1, label %if.end3

if.then1:                                         ; preds = %if.end
  %1 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds i8, i8* %start, i64 %idx.ext
  br label %if.end3

if.end3:                                          ; preds = %if.then1, %if.end
  %start.addr.0 = phi i8* [ %add.ptr, %if.then1 ], [ %start, %if.end ]
  %cmp4 = icmp ugt i8* %start.addr.0, %end
  br i1 %cmp4, label %return, label %if.end6

if.end6:                                          ; preds = %if.end3
  %product = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 24
  %2 = load i8*, i8** %product, align 8, !tbaa !39
  %tobool7 = icmp ne i8* %2, null
  br i1 %tobool7, label %if.then8, label %if.end13

if.then8:                                         ; preds = %if.end6
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext11 = sext i32 %3 to i64
  %add.ptr12 = getelementptr inbounds i8, i8* %start.addr.0, i64 %idx.ext11
  br label %if.end13

if.end13:                                         ; preds = %if.then8, %if.end6
  %start.addr.1 = phi i8* [ %add.ptr12, %if.then8 ], [ %start.addr.0, %if.end6 ]
  %cmp14 = icmp ugt i8* %start.addr.1, %end
  br i1 %cmp14, label %return, label %if.end16

if.end16:                                         ; preds = %if.end13
  %serial = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 26
  %4 = load i8*, i8** %serial, align 8, !tbaa !41
  %tobool17 = icmp ne i8* %4, null
  br i1 %tobool17, label %if.then18, label %return

if.then18:                                        ; preds = %if.end16
  %5 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext21 = sext i32 %5 to i64
  %add.ptr22 = getelementptr inbounds i8, i8* %start.addr.1, i64 %idx.ext21
  br label %return

return:                                           ; preds = %if.then18, %if.end16, %if.end13, %if.end3, %entry
  %retval.0 = phi i8* [ %start, %entry ], [ %start.addr.0, %if.end3 ], [ %start.addr.1, %if.end13 ], [ %add.ptr22, %if.then18 ], [ %start.addr.1, %if.end16 ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_config(i32 %speed, i8* %start, i8* %end, %struct.usb_host_config* %config) #0 {
entry:
  %cmp = icmp ugt i8* %start, %end
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %tobool = icmp ne %struct.usb_host_config* %config, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext = sext i32 %0 to i64
  %add.ptr = getelementptr inbounds i8, i8* %start, i64 %idx.ext
  br label %cleanup

if.end2:                                          ; preds = %if.end
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %call3 = call i8* @usb_dump_config_descriptor(i8* %start, i8* %end)
  br label %for.cond

for.cond:                                         ; preds = %if.end7, %if.end2
  %i.0 = phi i32 [ 0, %if.end2 ], [ %inc, %if.end7 ]
  %start.addr.0 = phi i8* [ %call3, %if.end2 ], [ %call11, %if.end7 ]
  %cmp4 = icmp slt i32 %i.0, 16
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %intf_assoc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 2
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x %struct.usb_interface_assoc_descriptor*], [16 x %struct.usb_interface_assoc_descriptor*]* %intf_assoc, i64 0, i64 %idxprom
  %1 = load %struct.usb_interface_assoc_descriptor*, %struct.usb_interface_assoc_descriptor** %arrayidx, align 8, !tbaa !48
  %cmp5 = icmp eq %struct.usb_interface_assoc_descriptor* %1, null
  br i1 %cmp5, label %for.end, label %if.end7

if.end7:                                          ; preds = %for.body
  %intf_assoc8 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 2
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [16 x %struct.usb_interface_assoc_descriptor*], [16 x %struct.usb_interface_assoc_descriptor*]* %intf_assoc8, i64 0, i64 %idxprom9
  %2 = load %struct.usb_interface_assoc_descriptor*, %struct.usb_interface_assoc_descriptor** %arrayidx10, align 8, !tbaa !48
  %call11 = call i8* @usb_dump_iad_descriptor(i8* %start.addr.0, i8* %end, %struct.usb_interface_assoc_descriptor* %2)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  br label %for.cond12

for.cond12:                                       ; preds = %for.inc34, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc35, %for.inc34 ]
  %start.addr.1 = phi i8* [ %start.addr.0, %for.end ], [ %start.addr.2, %for.inc34 ]
  %desc13 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc13, i32 0, i32 3
  %3 = load i8, i8* %bNumInterfaces, align 4, !tbaa !65
  %conv = zext i8 %3 to i32
  %cmp14 = icmp slt i32 %i.1, %conv
  br i1 %cmp14, label %for.body16, label %cleanup

for.body16:                                       ; preds = %for.cond12
  %intf_cache = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 4
  %idxprom17 = sext i32 %i.1 to i64
  %arrayidx18 = getelementptr inbounds [32 x %struct.usb_interface_cache*], [32 x %struct.usb_interface_cache*]* %intf_cache, i64 0, i64 %idxprom17
  %4 = load %struct.usb_interface_cache*, %struct.usb_interface_cache** %arrayidx18, align 8, !tbaa !48
  %interface19 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %config, i32 0, i32 3
  %idxprom20 = sext i32 %i.1 to i64
  %arrayidx21 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface19, i64 0, i64 %idxprom20
  %5 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx21, align 8, !tbaa !48
  br label %for.cond22

for.cond22:                                       ; preds = %if.end29, %for.body16
  %j.0 = phi i32 [ 0, %for.body16 ], [ %inc32, %if.end29 ]
  %start.addr.2 = phi i8* [ %start.addr.1, %for.body16 ], [ %call30, %if.end29 ]
  %num_altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %4, i32 0, i32 0
  %6 = load i32, i32* %num_altsetting, align 8, !tbaa !69
  %cmp23 = icmp ult i32 %j.0, %6
  br i1 %cmp23, label %for.body25, label %for.inc34

for.body25:                                       ; preds = %for.cond22
  %cmp26 = icmp ugt i8* %start.addr.2, %end
  br i1 %cmp26, label %cleanup, label %if.end29

if.end29:                                         ; preds = %for.body25
  %call30 = call i8* @usb_dump_interface(i32 %speed, i8* %start.addr.2, i8* %end, %struct.usb_interface_cache* %4, %struct.usb_interface* %5, i32 %j.0)
  %inc32 = add nsw i32 %j.0, 1
  br label %for.cond22

for.inc34:                                        ; preds = %for.cond22
  %inc35 = add nsw i32 %i.1, 1
  br label %for.cond12

cleanup:                                          ; preds = %for.body25, %for.cond12, %if.then1, %entry
  %retval.0 = phi i8* [ %add.ptr, %if.then1 ], [ %start, %entry ], [ %start.addr.2, %for.body25 ], [ %start.addr.1, %for.cond12 ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_config_descriptor(i8* %start, i8* %end) #0 {
entry:
  %cmp = icmp ugt i8* %start, %end
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext = sext i32 %0 to i64
  %add.ptr = getelementptr inbounds i8, i8* %start, i64 %idx.ext
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i8* [ %add.ptr, %if.end ], [ %start, %entry ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_iad_descriptor(i8* %start, i8* %end, %struct.usb_interface_assoc_descriptor* %iad) #0 {
entry:
  %cmp = icmp ugt i8* %start, %end
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %bFunctionClass3 = getelementptr inbounds %struct.usb_interface_assoc_descriptor, %struct.usb_interface_assoc_descriptor* %iad, i32 0, i32 4
  %0 = load i8, i8* %bFunctionClass3, align 1, !tbaa !761
  %conv4 = zext i8 %0 to i32
  call void @class_decode(i32 %conv4)
  %1 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr inbounds i8, i8* %start, i64 %idx.ext
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i8* [ %add.ptr, %if.end ], [ %start, %entry ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_interface(i32 %speed, i8* %start, i8* %end, %struct.usb_interface_cache* %intfc, %struct.usb_interface* %iface, i32 %setno) #0 {
entry:
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intfc, i32 0, i32 2
  %idxprom = sext i32 %setno to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i64 0, i64 %idxprom
  %call = call i8* @usb_dump_interface_descriptor(i8* %start, i8* %end, %struct.usb_interface_cache* %intfc, %struct.usb_interface* %iface, i32 %setno)
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %if.end ]
  %start.addr.0 = phi i8* [ %call, %entry ], [ %call8, %if.end ]
  %desc1 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc1, i32 0, i32 4
  %0 = load i8, i8* %bNumEndpoints, align 4, !tbaa !270
  %conv = zext i8 %0 to i32
  %cmp = icmp sge i32 %i.0, %conv
  %cmp3 = icmp ugt i8* %start.addr.0, %end
  %or.cond = or i1 %cmp, %cmp3
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %for.cond
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 3
  %1 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !271
  %idxprom5 = sext i32 %i.0 to i64
  %arrayidx6 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %1, i64 %idxprom5
  %desc7 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx6, i32 0, i32 0
  %call8 = call i8* @usb_dump_endpoint_descriptor(i32 %speed, i8* %start.addr.0, i8* %end, %struct.usb_endpoint_descriptor* %desc7)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond
  ret i8* %start.addr.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_interface_descriptor(i8* %start, i8* %end, %struct.usb_interface_cache* %intfc, %struct.usb_interface* %iface, i32 %setno) #0 {
entry:
  %cmp = icmp ugt i8* %start, %end
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %altsetting = getelementptr inbounds %struct.usb_interface_cache, %struct.usb_interface_cache* %intfc, i32 0, i32 2
  %idxprom = sext i32 %setno to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb_host_interface], [0 x %struct.usb_host_interface]* %altsetting, i64 0, i64 %idxprom
  %desc1 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %tobool = icmp ne %struct.usb_interface* %iface, null
  br i1 %tobool, label %if.then2, label %if.end8

if.then2:                                         ; preds = %if.end
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !104
  %tobool3 = icmp ne %struct.device_driver* %0, null
  br i1 %tobool3, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.then2
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.then2
  br label %if.end8

if.end8:                                          ; preds = %cond.end, %if.end
  %bInterfaceClass15 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc1, i32 0, i32 5
  %1 = load i8, i8* %bInterfaceClass15, align 1, !tbaa !754
  %conv16 = zext i8 %1 to i32
  call void @class_decode(i32 %conv16)
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext = sext i32 %2 to i64
  %add.ptr = getelementptr inbounds i8, i8* %start, i64 %idx.ext
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %entry
  %retval.0 = phi i8* [ %add.ptr, %if.end8 ], [ %start, %entry ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @usb_dump_endpoint_descriptor(i32 %speed, i8* %start, i8* %end, %struct.usb_endpoint_descriptor* %desc) #0 {
entry:
  %cmp = icmp ugt i8* %start, %end
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @usb_endpoint_dir_in.813(%struct.usb_endpoint_descriptor* %desc)
  %tobool = icmp ne i32 %call, 0
  %cond = select i1 %tobool, i32 73, i32 79
  %conv = trunc i32 %cond to i8
  %cmp1 = icmp eq i32 %speed, 3
  br i1 %cmp1, label %if.then3, label %if.end6

if.then3:                                         ; preds = %if.end
  %call4 = call i32 @usb_endpoint_maxp.814(%struct.usb_endpoint_descriptor* %desc)
  %and = and i32 %call4, 6144
  %Pivot = icmp slt i32 %and, 4096
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.then3
  %SwitchLeaf2 = icmp eq i32 %and, 4096
  br i1 %SwitchLeaf2, label %if.end6, label %NewDefault

LeafBlock:                                        ; preds = %if.then3
  %SwitchLeaf = icmp eq i32 %and, 2048
  br i1 %SwitchLeaf, label %if.end6, label %NewDefault

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %if.end6

if.end6:                                          ; preds = %NewDefault, %LeafBlock, %LeafBlock1, %if.end
  %call7 = call i32 @usb_endpoint_type.815(%struct.usb_endpoint_descriptor* %desc)
  %Pivot13 = icmp slt i32 %call7, 2
  br i1 %Pivot13, label %NodeBlock6, label %NodeBlock10

NodeBlock10:                                      ; preds = %if.end6
  %Pivot11 = icmp slt i32 %call7, 3
  br i1 %Pivot11, label %sw.bb17, label %LeafBlock8

LeafBlock8:                                       ; preds = %NodeBlock10
  %SwitchLeaf9 = icmp eq i32 %call7, 3
  br i1 %SwitchLeaf9, label %sw.bb28, label %cleanup

NodeBlock6:                                       ; preds = %if.end6
  %Pivot7 = icmp slt i32 %call7, 1
  br i1 %Pivot7, label %LeafBlock4, label %sw.bb14

LeafBlock4:                                       ; preds = %NodeBlock6
  %SwitchLeaf5 = icmp eq i32 %call7, 0
  br i1 %SwitchLeaf5, label %sw.bb8, label %cleanup

sw.bb8:                                           ; preds = %LeafBlock4
  %cmp9 = icmp eq i32 %speed, 3
  br i1 %cmp9, label %if.then11, label %sw.epilog42

if.then11:                                        ; preds = %sw.bb8
  br label %sw.epilog42

sw.bb14:                                          ; preds = %NodeBlock6
  br label %sw.epilog42

sw.bb17:                                          ; preds = %NodeBlock10
  %cmp18 = icmp eq i32 %speed, 3
  %conv20 = sext i8 %conv to i32
  %cmp21 = icmp eq i32 %conv20, 79
  %or.cond = and i1 %cmp18, %cmp21
  br i1 %or.cond, label %if.then23, label %sw.epilog42

if.then23:                                        ; preds = %sw.bb17
  br label %sw.epilog42

sw.bb28:                                          ; preds = %LeafBlock8
  switch i32 %speed, label %if.else38 [
    i32 3, label %if.then33
    i32 5, label %if.then33
  ]

if.then33:                                        ; preds = %sw.bb28, %sw.bb28
  br label %sw.epilog42

if.else38:                                        ; preds = %sw.bb28
  br label %sw.epilog42

sw.epilog42:                                      ; preds = %if.else38, %if.then33, %if.then23, %sw.bb17, %sw.bb14, %if.then11, %sw.bb8
  %call55 = call i32 @usb_endpoint_maxp.814(%struct.usb_endpoint_descriptor* %desc)
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %idx.ext = sext i32 %0 to i64
  %add.ptr = getelementptr inbounds i8, i8* %start, i64 %idx.ext
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog42, %LeafBlock4, %LeafBlock8, %entry
  %retval.0 = phi i8* [ %add.ptr, %sw.epilog42 ], [ %start, %entry ], [ %start, %LeafBlock4 ], [ %start, %LeafBlock8 ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_dir_in.813(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !286
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 128
  %cmp = icmp eq i32 %and, 128
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_maxp.814(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 4
  %0 = load i16, i16* %wMaxPacketSize, align 1, !tbaa !199
  %conv = zext i16 %0 to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_type.815(%struct.usb_endpoint_descriptor* %epd) #1 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !299
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal void @class_decode(i32 %class) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %ix.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %idxprom = sext i32 %ix.0 to i64
  %arrayidx = getelementptr inbounds [18 x %struct.usbdevfs_disconnectsignal], [18 x %struct.usbdevfs_disconnectsignal]* @clas_info, i64 0, i64 %idxprom
  %class1 = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %arrayidx, i32 0, i32 0
  %0 = load i32, i32* %class1, align 16, !tbaa !762
  %cmp = icmp ne i32 %0, -1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom2 = sext i32 %ix.0 to i64
  %arrayidx3 = getelementptr inbounds [18 x %struct.usbdevfs_disconnectsignal], [18 x %struct.usbdevfs_disconnectsignal]* @clas_info, i64 0, i64 %idxprom2
  %class4 = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %arrayidx3, i32 0, i32 0
  %1 = load i32, i32* %class4, align 16, !tbaa !762
  %cmp5 = icmp eq i32 %1, %class
  br i1 %cmp5, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %ix.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %idxprom6 = sext i32 %ix.0 to i64
  %arrayidx7 = getelementptr inbounds [18 x %struct.usbdevfs_disconnectsignal], [18 x %struct.usbdevfs_disconnectsignal]* @clas_info, i64 0, i64 %idxprom6
  %class_name = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %arrayidx7, i32 0, i32 1
  %2 = load i8*, i8** %class_name, align 8, !tbaa !764
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.inode* @file_inode.840(%struct.file* %f) #1 {
entry:
  %f_inode = getelementptr inbounds %struct.file, %struct.file* %f, i32 0, i32 2
  %0 = load %struct.inode*, %struct.inode** %f_inode, align 8, !tbaa !621
  ret %struct.inode* %0
}

; Function Attrs: nounwind uwtable
define void @usbfs_conn_disc_event() #0 {
entry:
  call void @atomic_add.841(i32 2, %union.anon.5* getelementptr inbounds (%struct.device_connect_event, %struct.device_connect_event* @device_event, i32 0, i32 0))
  call void @__wake_up(%struct.__wait_queue_head* getelementptr inbounds (%struct.device_connect_event, %struct.device_connect_event* @device_event, i32 0, i32 1), i32 3, i32 1, i8* null)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_add.841(i32 %i, %union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; addl $1,$0", "=*m,ir,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #8, !srcloc !765
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usb_port_device_release(%struct.device.4311* %dev) #0 {
entry:
  %0 = bitcast %struct.device.4311* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -8
  %1 = bitcast i8* %add.ptr to %struct.usb_port.4562*
  %2 = bitcast %struct.usb_port.4562* %1 to i8*
  call void @kfree(i8* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_port_runtime_suspend(%struct.device.4311* %dev) #0 {
entry:
  %0 = bitcast %struct.device.4311* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -8
  %1 = bitcast i8* %add.ptr to %struct.usb_port.4562*
  %parent = getelementptr inbounds %struct.device.4311, %struct.device.4311* %dev, i32 0, i32 0
  %2 = load %struct.device.4311*, %struct.device.4311** %parent, align 8, !tbaa !766
  %parent2 = getelementptr inbounds %struct.device.4311, %struct.device.4311* %2, i32 0, i32 0
  %3 = load %struct.device.4311*, %struct.device.4311** %parent2, align 8, !tbaa !766
  %4 = bitcast %struct.device.4311* %3 to i8*
  %add.ptr4 = getelementptr inbounds i8, i8* %4, i64 -136
  %5 = bitcast i8* %add.ptr4 to %struct.usb_device.4563*
  %parent6 = getelementptr inbounds %struct.device.4311, %struct.device.4311* %dev, i32 0, i32 0
  %6 = load %struct.device.4311*, %struct.device.4311** %parent6, align 8, !tbaa !766
  %7 = bitcast %struct.device.4311* %6 to i8*
  %add.ptr8 = getelementptr inbounds i8, i8* %7, i64 -48
  %8 = bitcast i8* %add.ptr8 to %struct.usb_interface.4584*
  %call = call %struct.usb_hub.4588* bitcast (%struct.usb_hub* (%struct.usb_device*)* @usb_hub_to_struct_hub to %struct.usb_hub.4588* (%struct.usb_device.4563*)*)(%struct.usb_device.4563* %5)
  %portnum = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %1, i32 0, i32 4
  %9 = load i8, i8* %portnum, align 4, !tbaa !767
  %conv = zext i8 %9 to i32
  %tobool = icmp ne %struct.usb_hub.4588* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %dev10 = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %1, i32 0, i32 1
  %call11 = call i32 bitcast (i32 (%struct.device*, i32)* @dev_pm_qos_flags to i32 (%struct.device.4311*, i32)*)(%struct.device.4311* %dev10, i32 1)
  %cmp = icmp eq i32 %call11, 2
  br i1 %cmp, label %cleanup, label %if.end14

if.end14:                                         ; preds = %if.end
  %call15 = call i32 bitcast (i32 (%struct.usb_interface*)* @usb_autopm_get_interface to i32 (%struct.usb_interface.4584*)*)(%struct.usb_interface.4584* %8)
  %busy_bits = getelementptr inbounds %struct.usb_hub.4588, %struct.usb_hub.4588* %call, i32 0, i32 12
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %busy_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i32 %conv, i64* %arraydecay) #8, !srcloc !768
  %call16 = call i32 bitcast (i32 (%struct.usb_device*, i32, i1)* @usb_hub_set_port_power to i32 (%struct.usb_device.4563*, i32, i1)*)(%struct.usb_device.4563* %5, i32 %conv, i1 zeroext false)
  %call17 = call i32 bitcast (i32 (%struct.usb_device*, i32, i32)* @usb_clear_port_feature to i32 (%struct.usb_device.4563*, i32, i32)*)(%struct.usb_device.4563* %5, i32 %conv, i32 16)
  %call18 = call i32 bitcast (i32 (%struct.usb_device*, i32, i32)* @usb_clear_port_feature to i32 (%struct.usb_device.4563*, i32, i32)*)(%struct.usb_device.4563* %5, i32 %conv, i32 17)
  %busy_bits19 = getelementptr inbounds %struct.usb_hub.4588, %struct.usb_hub.4588* %call, i32 0, i32 12
  %arraydecay20 = getelementptr inbounds [1 x i64], [1 x i64]* %busy_bits19, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay20, i32 %conv, i64* %arraydecay20) #8, !srcloc !769
  call void bitcast (void (%struct.usb_interface*)* @usb_autopm_put_interface to void (%struct.usb_interface.4584*)*)(%struct.usb_interface.4584* %8)
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %if.end, %entry
  %retval.0 = phi i32 [ %call16, %if.end14 ], [ -22, %entry ], [ -11, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_port_runtime_resume(%struct.device.4311* %dev) #0 {
entry:
  %0 = bitcast %struct.device.4311* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -8
  %1 = bitcast i8* %add.ptr to %struct.usb_port.4562*
  %parent = getelementptr inbounds %struct.device.4311, %struct.device.4311* %dev, i32 0, i32 0
  %2 = load %struct.device.4311*, %struct.device.4311** %parent, align 8, !tbaa !766
  %parent2 = getelementptr inbounds %struct.device.4311, %struct.device.4311* %2, i32 0, i32 0
  %3 = load %struct.device.4311*, %struct.device.4311** %parent2, align 8, !tbaa !766
  %4 = bitcast %struct.device.4311* %3 to i8*
  %add.ptr4 = getelementptr inbounds i8, i8* %4, i64 -136
  %5 = bitcast i8* %add.ptr4 to %struct.usb_device.4563*
  %parent6 = getelementptr inbounds %struct.device.4311, %struct.device.4311* %dev, i32 0, i32 0
  %6 = load %struct.device.4311*, %struct.device.4311** %parent6, align 8, !tbaa !766
  %7 = bitcast %struct.device.4311* %6 to i8*
  %add.ptr8 = getelementptr inbounds i8, i8* %7, i64 -48
  %8 = bitcast i8* %add.ptr8 to %struct.usb_interface.4584*
  %call = call %struct.usb_hub.4588* bitcast (%struct.usb_hub* (%struct.usb_device*)* @usb_hub_to_struct_hub to %struct.usb_hub.4588* (%struct.usb_device.4563*)*)(%struct.usb_device.4563* %5)
  %portnum = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %1, i32 0, i32 4
  %9 = load i8, i8* %portnum, align 4, !tbaa !767
  %conv = zext i8 %9 to i32
  %tobool = icmp ne %struct.usb_hub.4588* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call10 = call i32 bitcast (i32 (%struct.usb_interface*)* @usb_autopm_get_interface to i32 (%struct.usb_interface.4584*)*)(%struct.usb_interface.4584* %8)
  %busy_bits = getelementptr inbounds %struct.usb_hub.4588, %struct.usb_hub.4588* %call, i32 0, i32 12
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %busy_bits, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i32 %conv, i64* %arraydecay) #8, !srcloc !768
  %call11 = call i32 bitcast (i32 (%struct.usb_device*, i32, i1)* @usb_hub_set_port_power to i32 (%struct.usb_device.4563*, i32, i1)*)(%struct.usb_device.4563* %5, i32 %conv, i1 zeroext true)
  %child = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %1, i32 0, i32 0
  %10 = load %struct.usb_device.4563*, %struct.usb_device.4563** %child, align 8, !tbaa !102
  %tobool12 = icmp eq %struct.usb_device.4563* %10, null
  %tobool13 = icmp ne i32 %call11, 0
  %or.cond = or i1 %tobool12, %tobool13
  br i1 %or.cond, label %out, label %if.then14

if.then14:                                        ; preds = %if.end
  %call15 = call i32 @hub_port_debounce_be_connected(%struct.usb_hub.4588* %call, i32 %conv)
  %cmp = icmp slt i32 %call15, 0
  br i1 %cmp, label %do.body18, label %if.end29

do.body18:                                        ; preds = %if.then14
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_runtime_resume.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool19 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool19, true
  %lnot20 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot20 to i32
  %conv21 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool22 = icmp ne i64 %expval, 0
  br i1 %tobool22, label %if.then23, label %out

if.then23:                                        ; preds = %do.body18
  %dev24 = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %1, i32 0, i32 1
  %call25 = call i32 (%struct._ddebug*, %struct.device.4311*, i8*, ...) bitcast (i32 (%struct._ddebug*, %struct.device*, i8*, ...)* @__dynamic_dev_dbg to i32 (%struct._ddebug*, %struct.device.4311*, i8*, ...)*)(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_port_runtime_resume.descriptor to %struct._ddebug*), %struct.device.4311* %dev24, i8* getelementptr inbounds ([64 x i8], [64 x i8]* @.str.5.844, i32 0, i32 0), i32 %call15)
  br label %out

if.end29:                                         ; preds = %if.then14
  %call30 = call i32 bitcast (i32 (%struct.usb_device*, i32, i32)* @usb_clear_port_feature to i32 (%struct.usb_device.4563*, i32, i32)*)(%struct.usb_device.4563* %5, i32 %conv, i32 17)
  br label %out

out:                                              ; preds = %if.end29, %if.then23, %do.body18, %if.end
  %retval9.1 = phi i32 [ %call15, %if.then23 ], [ %call15, %do.body18 ], [ 0, %if.end29 ], [ %call11, %if.end ]
  %busy_bits32 = getelementptr inbounds %struct.usb_hub.4588, %struct.usb_hub.4588* %call, i32 0, i32 12
  %arraydecay33 = getelementptr inbounds [1 x i64], [1 x i64]* %busy_bits32, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay33, i32 %conv, i64* %arraydecay33) #8, !srcloc !769
  call void bitcast (void (%struct.usb_interface*)* @usb_autopm_put_interface to void (%struct.usb_interface.4584*)*)(%struct.usb_interface.4584* %8)
  br label %cleanup

cleanup:                                          ; preds = %out, %entry
  %retval.0 = phi i32 [ %retval9.1, %out ], [ -22, %entry ]
  ret i32 %retval.0
}

declare i32 @pm_generic_runtime_idle(%struct.device.4311*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hub_port_debounce_be_connected(%struct.usb_hub.4588* %hub, i32 %port1) #1 {
entry:
  %call = call i32 bitcast (i32 (%struct.usb_hub*, i32, i1)* @hub_port_debounce to i32 (%struct.usb_hub.4588*, i32, i1)*)(%struct.usb_hub.4588* %hub, i32 %port1, i1 zeroext true)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @usb_hub_create_port_device(%struct.usb_hub.4588* %hub, i32 %port1) #0 {
entry:
  %call = call i8* @kzalloc.850(i64 1160, i32 208)
  %0 = bitcast i8* %call to %struct.usb_port.4562*
  %tobool = icmp ne %struct.usb_port.4562* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %ports = getelementptr inbounds %struct.usb_hub.4588, %struct.usb_hub.4588* %hub, i32 0, i32 22
  %1 = load %struct.usb_port.4562**, %struct.usb_port.4562*** %ports, align 8, !tbaa !98
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port.4562*, %struct.usb_port.4562** %1, i64 %idxprom
  store %struct.usb_port.4562* %0, %struct.usb_port.4562** %arrayidx, align 8, !tbaa !48
  %conv = trunc i32 %port1 to i8
  %portnum = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %0, i32 0, i32 4
  store i8 %conv, i8* %portnum, align 4, !tbaa !767
  %power_is_on = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %0, i32 0, i32 5
  %bf.load = load i8, i8* %power_is_on, align 1
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %power_is_on, align 1
  %intfdev = getelementptr inbounds %struct.usb_hub.4588, %struct.usb_hub.4588* %hub, i32 0, i32 0
  %2 = load %struct.device.4311*, %struct.device.4311** %intfdev, align 8, !tbaa !173
  %dev = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %0, i32 0, i32 1
  %parent = getelementptr inbounds %struct.device.4311, %struct.device.4311* %dev, i32 0, i32 0
  store %struct.device.4311* %2, %struct.device.4311** %parent, align 8, !tbaa !770
  %dev2 = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %0, i32 0, i32 1
  %groups = getelementptr inbounds %struct.device.4311, %struct.device.4311* %dev2, i32 0, i32 26
  store %struct.attribute_group** getelementptr inbounds ([2 x %struct.attribute_group*], [2 x %struct.attribute_group*]* @port_dev_group, i32 0, i32 0), %struct.attribute_group*** %groups, align 8, !tbaa !771
  %dev3 = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %0, i32 0, i32 1
  %type = getelementptr inbounds %struct.device.4311, %struct.device.4311* %dev3, i32 0, i32 4
  store %struct.device_type.4314* bitcast ({ i8*, %struct.attribute_group**, i32 (%struct.device.4311*, %struct.kobj_uevent_env*)*, i8* (%struct.device.4311*, i16*, i32*, i32*)*, void (%struct.device.4311*)*, %struct.dev_pm_ops.4310* }* @usb_port_device_type to %struct.device_type.4314*), %struct.device_type.4314** %type, align 8, !tbaa !772
  %dev4 = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %0, i32 0, i32 1
  %call5 = call i32 (%struct.device.4311*, i8*, ...) bitcast (i32 (%struct.device*, i8*, ...)* @dev_set_name to i32 (%struct.device.4311*, i8*, ...)*)(%struct.device.4311* %dev4, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.7.909, i32 0, i32 0), i32 %port1)
  %dev6 = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %0, i32 0, i32 1
  %call7 = call i32 bitcast (i32 (%struct.device.2626*)* @device_register to i32 (%struct.device.4311*)*)(%struct.device.4311* %dev6)
  %tobool8 = icmp ne i32 %call7, 0
  %dev20 = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %0, i32 0, i32 1
  br i1 %tobool8, label %error_register, label %if.end10

if.end10:                                         ; preds = %if.end
  call void @pm_runtime_set_active.852(%struct.device.4311* %dev20)
  %dev13 = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %0, i32 0, i32 1
  %call14 = call i32 @dev_pm_qos_expose_flags(%struct.device.4311* %dev13, i32 1)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.end18, label %if.then16

if.then16:                                        ; preds = %if.end10
  %dev17 = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %0, i32 0, i32 1
  call void bitcast (void (%struct.device*)* @pm_runtime_enable to void (%struct.device.4311*)*)(%struct.device.4311* %dev17)
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.end10
  %dev19 = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %0, i32 0, i32 1
  call void @device_enable_async_suspend.853(%struct.device.4311* %dev19)
  br label %cleanup

error_register:                                   ; preds = %if.end
  call void bitcast (void (%struct.device*)* @put_device to void (%struct.device.4311*)*)(%struct.device.4311* %dev20)
  br label %cleanup

cleanup:                                          ; preds = %error_register, %if.end18, %entry
  %retval.0 = phi i32 [ 0, %if.end18 ], [ %call7, %error_register ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.850(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_set_active.852(%struct.device.4311* %dev) #1 {
entry:
  %call = call i32 bitcast (i32 (%struct.device*, i32)* @__pm_runtime_set_status to i32 (%struct.device.4311*, i32)*)(%struct.device.4311* %dev, i32 0)
  ret void
}

declare i32 @dev_pm_qos_expose_flags(%struct.device.4311*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_enable_async_suspend.853(%struct.device.4311* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device.4311, %struct.device.4311* %dev, i32 0, i32 9
  %is_prepared = getelementptr inbounds %struct.dev_pm_info.4318, %struct.dev_pm_info.4318* %power, i32 0, i32 1
  %bf.load = load i8, i8* %is_prepared, align 4
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %power1 = getelementptr inbounds %struct.device.4311, %struct.device.4311* %dev, i32 0, i32 9
  %async_suspend = getelementptr inbounds %struct.dev_pm_info.4318, %struct.dev_pm_info.4318* %power1, i32 0, i32 1
  %bf.load2 = load i8, i8* %async_suspend, align 4
  %bf.clear3 = and i8 %bf.load2, -3
  %bf.set = or i8 %bf.clear3, 2
  store i8 %bf.set, i8* %async_suspend, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @show_port_connect_type(%struct.device.4311* %dev, %struct.device_attribute.4530* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device.4311* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -8
  %1 = bitcast i8* %add.ptr to %struct.usb_port.4562*
  %connect_type = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %1, i32 0, i32 3
  %2 = load i32, i32* %connect_type, align 8, !tbaa !298
  %Pivot4 = icmp slt i32 %2, 2
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %2, 3
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %2, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %2, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock, %LeafBlock1, %NodeBlock
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define void @usb_hub_remove_port_device(%struct.usb_hub.4588* %hub, i32 %port1) #0 {
entry:
  %ports = getelementptr inbounds %struct.usb_hub.4588, %struct.usb_hub.4588* %hub, i32 0, i32 22
  %0 = load %struct.usb_port.4562**, %struct.usb_port.4562*** %ports, align 8, !tbaa !98
  %sub = sub nsw i32 %port1, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.usb_port.4562*, %struct.usb_port.4562** %0, i64 %idxprom
  %1 = load %struct.usb_port.4562*, %struct.usb_port.4562** %arrayidx, align 8, !tbaa !48
  %dev = getelementptr inbounds %struct.usb_port.4562, %struct.usb_port.4562* %1, i32 0, i32 1
  call void bitcast (void (%struct.device.2626*)* @device_unregister to void (%struct.device.4311*)*)(%struct.device.4311* %dev)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @hcd_pci_suspend(%struct.device* %dev) #0 {
entry:
  %call = call zeroext i1 @device_may_wakeup.870(%struct.device* %dev)
  %call1 = call i32 @suspend_common(%struct.device* %dev, i1 zeroext %call)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @hcd_pci_resume(%struct.device* %dev) #0 {
entry:
  %call = call i32 @resume_common(%struct.device* %dev, i32 16)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @check_root_hub_suspended(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.pci_dev*
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %1)
  %2 = bitcast i8* %call to %struct.usb_hcd*
  %flags = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 10
  %3 = load i64, i64* %flags, align 8, !tbaa !314
  %and = and i64 %3, 32
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  %shared_hcd = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 18
  %5 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd, align 8, !tbaa !342
  %tobool2 = icmp ne %struct.usb_hcd* %5, null
  br i1 %tobool2, label %if.then3, label %cleanup

if.then3:                                         ; preds = %if.end
  %shared_hcd4 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 18
  %6 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd4, align 8, !tbaa !342
  %flags5 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %6, i32 0, i32 10
  %7 = load i64, i64* %flags5, align 8, !tbaa !314
  %and6 = and i64 %7, 32
  %tobool7 = icmp ne i64 %and6, 0
  br i1 %tobool7, label %if.then8, label %cleanup

if.then8:                                         ; preds = %if.then3
  %8 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then8, %if.then3, %if.end, %if.then
  %retval.0 = phi i32 [ -16, %if.then ], [ -16, %if.then8 ], [ 0, %if.then3 ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @hcd_pci_restore(%struct.device* %dev) #0 {
entry:
  %call = call i32 @resume_common(%struct.device* %dev, i32 64)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @hcd_pci_suspend_noirq(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.pci_dev*
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %1)
  %2 = bitcast i8* %call to %struct.usb_hcd*
  %call2 = call i32 @check_root_hub_suspended(%struct.device* %dev)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call3 = call i32 @pci_save_state(%struct.pci_dev* %1)
  %flags = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 10
  %3 = load i64, i64* %flags, align 8, !tbaa !314
  %and = and i64 %3, 64
  %tobool4 = icmp ne i64 %and, 0
  br i1 %tobool4, label %if.then5, label %do.body8

if.then5:                                         ; preds = %if.end
  %call6 = call i32 @device_set_wakeup_enable(%struct.device* %dev, i1 zeroext false)
  br label %do.body8

do.body8:                                         ; preds = %if.then5, %if.end
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_suspend_noirq.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and9 = and i32 %bf.clear, 1
  %tobool10 = icmp ne i32 %and9, 0
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.then13, label %do.end19

if.then13:                                        ; preds = %do.body8
  %call14 = call zeroext i1 @device_may_wakeup.870(%struct.device* %dev)
  %conv15 = zext i1 %call14 to i32
  %call16 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_suspend_noirq.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.19.871, i32 0, i32 0), i32 %conv15)
  br label %do.end19

do.end19:                                         ; preds = %if.then13, %do.body8
  %call20 = call i32 @pci_prepare_to_sleep(%struct.pci_dev* %1)
  switch i32 %call20, label %do.body70 [
    i32 -5, label %do.body24
    i32 0, label %do.body48
  ]

do.body24:                                        ; preds = %do.end19
  %bf.load25 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_suspend_noirq.descriptor.20 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr26 = lshr i32 %bf.load25, 18
  %bf.clear27 = and i32 %bf.lshr26, 255
  %and28 = and i32 %bf.clear27, 1
  %tobool29 = icmp ne i32 %and28, 0
  %lnot30 = xor i1 %tobool29, true
  %lnot32 = xor i1 %lnot30, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %expval35 = call i64 @llvm.expect.i64(i64 %conv34, i64 0)
  %tobool36 = icmp ne i64 %expval35, 0
  br i1 %tobool36, label %if.then37, label %if.end74

if.then37:                                        ; preds = %do.body24
  %call38 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_suspend_noirq.descriptor.20 to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.21.872, i32 0, i32 0))
  br label %if.end74

do.body48:                                        ; preds = %do.end19
  %bf.load49 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_suspend_noirq.descriptor.22 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr50 = lshr i32 %bf.load49, 18
  %bf.clear51 = and i32 %bf.lshr50, 255
  %and52 = and i32 %bf.clear51, 1
  %tobool53 = icmp ne i32 %and52, 0
  %lnot54 = xor i1 %tobool53, true
  %lnot56 = xor i1 %lnot54, true
  %lnot.ext57 = zext i1 %lnot56 to i32
  %conv58 = sext i32 %lnot.ext57 to i64
  %expval59 = call i64 @llvm.expect.i64(i64 %conv58, i64 0)
  %tobool60 = icmp ne i64 %expval59, 0
  br i1 %tobool60, label %if.then61, label %if.end74

if.then61:                                        ; preds = %do.body48
  %current_state = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %1, i32 0, i32 25
  %4 = load i32, i32* %current_state, align 8, !tbaa !773
  %call62 = call i8* @pci_power_name(i32 %4)
  %call63 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_suspend_noirq.descriptor.22 to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23.873, i32 0, i32 0), i8* %call62)
  br label %if.end74

do.body70:                                        ; preds = %do.end19
  call void @__suspend_report_result(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.hcd_pci_suspend_noirq, i32 0, i32 0), i8* bitcast (i32 (%struct.pci_dev*)* @pci_prepare_to_sleep to i8*), i32 %call20)
  br label %cleanup

if.end74:                                         ; preds = %if.then61, %do.body48, %if.then37, %do.body24
  %retval1.0 = phi i32 [ 0, %if.then37 ], [ 0, %do.body24 ], [ %call20, %do.body48 ], [ %call20, %if.then61 ]
  call void @powermac_set_asic()
  br label %cleanup

cleanup:                                          ; preds = %if.end74, %do.body70, %entry
  %retval.0 = phi i32 [ %retval1.0, %if.end74 ], [ %call20, %do.body70 ], [ %call2, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @hcd_pci_resume_noirq(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.pci_dev*
  call void @powermac_set_asic()
  %call = call i32 @pci_back_from_sleep(%struct.pci_dev* %1)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @hcd_pci_runtime_suspend(%struct.device* %dev) #0 {
entry:
  %call = call i32 @suspend_common(%struct.device* %dev, i1 zeroext true)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %do.body2

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.pci_dev*
  call void @powermac_set_asic()
  br label %do.body2

do.body2:                                         ; preds = %if.then, %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_runtime_suspend.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then5, label %do.end9

if.then5:                                         ; preds = %do.body2
  %call6 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_runtime_suspend.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.24.869, i32 0, i32 0), i32 %call)
  br label %do.end9

do.end9:                                          ; preds = %if.then5, %do.body2
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @hcd_pci_runtime_resume(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.pci_dev*
  call void @powermac_set_asic()
  %call = call i32 @resume_common(%struct.device* %dev, i32 1040)
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_runtime_resume.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %do.end7

if.then:                                          ; preds = %entry
  %call5 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @hcd_pci_runtime_resume.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.25.863, i32 0, i32 0), i32 %call)
  br label %do.end7

do.end7:                                          ; preds = %if.then, %entry
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @powermac_set_asic() #1 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @resume_common(%struct.device* %dev, i32 %event) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.pci_dev*
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %1)
  %2 = bitcast i8* %call to %struct.usb_hcd*
  %flags = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 10
  %3 = load i64, i64* %flags, align 8, !tbaa !314
  %and = and i64 %3, 32
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %do.body7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %shared_hcd = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 18
  %4 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd, align 8, !tbaa !342
  %tobool2 = icmp ne %struct.usb_hcd* %4, null
  br i1 %tobool2, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %lor.lhs.false
  %shared_hcd3 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 18
  %5 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd3, align 8, !tbaa !342
  %flags4 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %5, i32 0, i32 10
  %6 = load i64, i64* %flags4, align 8, !tbaa !314
  %and5 = and i64 %6, 32
  %tobool6 = icmp ne i64 %and5, 0
  br i1 %tobool6, label %do.body7, label %if.end16

do.body7:                                         ; preds = %land.lhs.true, %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @resume_common.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and8 = and i32 %bf.clear, 1
  %tobool9 = icmp ne i32 %and8, 0
  %lnot = xor i1 %tobool9, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %if.then12, label %cleanup

if.then12:                                        ; preds = %do.body7
  %call13 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @resume_common.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.14.866, i32 0, i32 0))
  br label %cleanup

if.end16:                                         ; preds = %land.lhs.true, %lor.lhs.false
  %call17 = call i32 @pci_enable_device(%struct.pci_dev* %1)
  %cmp = icmp slt i32 %call17, 0
  br i1 %cmp, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.end16
  %7 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end21:                                         ; preds = %if.end16
  call void @pci_set_master(%struct.pci_dev* %1)
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 8
  %8 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %pci_resume = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %8, i32 0, i32 8
  %9 = load i32 (%struct.usb_hcd*, i1)*, i32 (%struct.usb_hcd*, i1)** %pci_resume, align 8, !tbaa !776
  %tobool22 = icmp ne i32 (%struct.usb_hcd*, i1)* %9, null
  br i1 %tobool22, label %land.lhs.true23, label %cleanup

land.lhs.true23:                                  ; preds = %if.end21
  %flags24 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 10
  %10 = load i64, i64* %flags24, align 8, !tbaa !314
  %and25 = and i64 %10, 64
  %tobool26 = icmp ne i64 %and25, 0
  br i1 %tobool26, label %cleanup, label %if.then27

if.then27:                                        ; preds = %land.lhs.true23
  %class = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %1, i32 0, i32 11
  %11 = load i32, i32* %class, align 4, !tbaa !777
  %cmp28 = icmp eq i32 %11, 787232
  %cmp31 = icmp ne i32 %event, 1040
  %or.cond = and i1 %cmp28, %cmp31
  br i1 %or.cond, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.then27
  call void @for_each_companion(%struct.pci_dev* %1, %struct.usb_hcd* %2, void (%struct.pci_dev*, %struct.usb_hcd*, %struct.pci_dev*, %struct.usb_hcd*)* @ehci_wait_for_companions)
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.then27
  %driver35 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 8
  %12 = load %struct.hc_driver*, %struct.hc_driver** %driver35, align 8, !tbaa !71
  %pci_resume36 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %12, i32 0, i32 8
  %13 = load i32 (%struct.usb_hcd*, i1)*, i32 (%struct.usb_hcd*, i1)** %pci_resume36, align 8, !tbaa !776
  %cmp37 = icmp eq i32 %event, 64
  %call39 = call i32 %13(%struct.usb_hcd* %2, i1 zeroext %cmp37)
  %tobool40 = icmp ne i32 %call39, 0
  br i1 %tobool40, label %if.then41, label %cleanup

if.then41:                                        ; preds = %if.end34
  %14 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %shared_hcd43 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 18
  %15 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd43, align 8, !tbaa !342
  %tobool44 = icmp ne %struct.usb_hcd* %15, null
  br i1 %tobool44, label %if.then45, label %if.end47

if.then45:                                        ; preds = %if.then41
  %shared_hcd46 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 18
  %16 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd46, align 8, !tbaa !342
  call void bitcast (void (%struct.usb_hcd.588*)* @usb_hc_died to void (%struct.usb_hcd*)*)(%struct.usb_hcd* %16)
  br label %if.end47

if.end47:                                         ; preds = %if.then45, %if.then41
  call void bitcast (void (%struct.usb_hcd.588*)* @usb_hc_died to void (%struct.usb_hcd*)*)(%struct.usb_hcd* %2)
  br label %cleanup

cleanup:                                          ; preds = %if.end47, %if.end34, %land.lhs.true23, %if.end21, %if.then19, %if.then12, %do.body7
  %retval.0 = phi i32 [ %call17, %if.then19 ], [ 0, %if.then12 ], [ 0, %do.body7 ], [ %call17, %land.lhs.true23 ], [ %call17, %if.end21 ], [ %call39, %if.end47 ], [ %call39, %if.end34 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @pci_get_drvdata(%struct.pci_dev* %pdev) #1 {
entry:
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 34
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

declare i32 @pci_enable_device(%struct.pci_dev*) #2

declare void @pci_set_master(%struct.pci_dev*) #2

; Function Attrs: nounwind uwtable
define internal void @ehci_wait_for_companions(%struct.pci_dev* %pdev, %struct.usb_hcd* %hcd, %struct.pci_dev* %companion, %struct.usb_hcd* %companion_hcd) #0 {
entry:
  %call = call i32 @is_ohci_or_uhci(%struct.pci_dev* %companion)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 34
  %dev1 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %companion, i32 0, i32 34
  %call2 = call i32 @device_pm_wait_for_dev(%struct.device* %dev, %struct.device* %dev1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @for_each_companion(%struct.pci_dev* %pdev, %struct.usb_hcd* %hcd, void (%struct.pci_dev*, %struct.usb_hcd*, %struct.pci_dev*, %struct.usb_hcd*)* %fn) #0 {
entry:
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 6
  %0 = load i32, i32* %devfn, align 8, !tbaa !778
  %shr = lshr i32 %0, 3
  %and = and i32 %shr, 31
  br label %while.cond

while.cond:                                       ; preds = %while.cond.backedge, %entry
  %companion.0 = phi %struct.pci_dev* [ null, %entry ], [ %call, %while.cond.backedge ]
  %call = call %struct.pci_dev* @pci_get_device(i32 -1, i32 -1, %struct.pci_dev* %companion.0)
  %cmp = icmp ne %struct.pci_dev* %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %call, i32 0, i32 1
  %1 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !779
  %bus1 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 1
  %2 = load %struct.pci_bus*, %struct.pci_bus** %bus1, align 8, !tbaa !779
  %cmp2 = icmp ne %struct.pci_bus* %1, %2
  br i1 %cmp2, label %while.cond.backedge, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %devfn3 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %call, i32 0, i32 6
  %3 = load i32, i32* %devfn3, align 8, !tbaa !778
  %shr4 = lshr i32 %3, 3
  %and5 = and i32 %shr4, 31
  %cmp6 = icmp ne i32 %and5, %and
  br i1 %cmp6, label %while.cond.backedge, label %if.end

while.cond.backedge:                              ; preds = %if.end9, %if.end, %lor.lhs.false, %while.body
  br label %while.cond

if.end:                                           ; preds = %lor.lhs.false
  %call7 = call i8* @pci_get_drvdata(%struct.pci_dev* %call)
  %4 = bitcast i8* %call7 to %struct.usb_hcd*
  %tobool = icmp ne %struct.usb_hcd* %4, null
  br i1 %tobool, label %if.end9, label %while.cond.backedge

if.end9:                                          ; preds = %if.end
  call void %fn(%struct.pci_dev* %pdev, %struct.usb_hcd* %hcd, %struct.pci_dev* %call, %struct.usb_hcd* %4)
  br label %while.cond.backedge

while.end:                                        ; preds = %while.cond
  ret void
}

declare %struct.pci_dev* @pci_get_device(i32, i32, %struct.pci_dev*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_ohci_or_uhci(%struct.pci_dev* %pdev) #1 {
entry:
  %class = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 11
  %0 = load i32, i32* %class, align 4, !tbaa !777
  %cmp = icmp eq i32 %0, 787216
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %class1 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 11
  %1 = load i32, i32* %class1, align 4, !tbaa !777
  %cmp2 = icmp eq i32 %1, 787200
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  %lor.ext = zext i1 %2 to i32
  ret i32 %lor.ext
}

; Function Attrs: nounwind uwtable
define internal i32 @suspend_common(%struct.device* %dev, i1 zeroext %do_wakeup) #0 {
entry:
  %frombool = zext i1 %do_wakeup to i8
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.pci_dev*
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %1)
  %2 = bitcast i8* %call to %struct.usb_hcd*
  %call2 = call i32 @check_root_hub_suspended(%struct.device* %dev)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 8
  %3 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %pci_suspend = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %3, i32 0, i32 7
  %4 = load i32 (%struct.usb_hcd*, i1)*, i32 (%struct.usb_hcd*, i1)** %pci_suspend, align 8, !tbaa !780
  %tobool3 = icmp ne i32 (%struct.usb_hcd*, i1)* %4, null
  br i1 %tobool3, label %land.lhs.true, label %if.end58

land.lhs.true:                                    ; preds = %if.end
  %flags = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 10
  %5 = load i64, i64* %flags, align 8, !tbaa !314
  %and = and i64 %5, 64
  %tobool4 = icmp ne i64 %and, 0
  br i1 %tobool4, label %if.end58, label %if.then5

if.then5:                                         ; preds = %land.lhs.true
  %tobool6 = trunc i8 %frombool to i1
  br i1 %tobool6, label %land.lhs.true7, label %if.end12

land.lhs.true7:                                   ; preds = %if.then5
  %flags8 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 10
  %6 = load i64, i64* %flags8, align 8, !tbaa !314
  %and9 = and i64 %6, 16
  %tobool10 = icmp ne i64 %and9, 0
  br i1 %tobool10, label %cleanup, label %if.end12

if.end12:                                         ; preds = %land.lhs.true7, %if.then5
  %tobool13 = trunc i8 %frombool to i1
  br i1 %tobool13, label %land.lhs.true14, label %if.end22

land.lhs.true14:                                  ; preds = %if.end12
  %shared_hcd = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 18
  %7 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd, align 8, !tbaa !342
  %tobool15 = icmp ne %struct.usb_hcd* %7, null
  br i1 %tobool15, label %land.lhs.true16, label %if.end22

land.lhs.true16:                                  ; preds = %land.lhs.true14
  %shared_hcd17 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 18
  %8 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd17, align 8, !tbaa !342
  %flags18 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %8, i32 0, i32 10
  %9 = load i64, i64* %flags18, align 8, !tbaa !314
  %and19 = and i64 %9, 16
  %tobool20 = icmp ne i64 %and19, 0
  br i1 %tobool20, label %cleanup, label %if.end22

if.end22:                                         ; preds = %land.lhs.true16, %land.lhs.true14, %if.end12
  %driver23 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 8
  %10 = load %struct.hc_driver*, %struct.hc_driver** %driver23, align 8, !tbaa !71
  %pci_suspend24 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %10, i32 0, i32 7
  %11 = load i32 (%struct.usb_hcd*, i1)*, i32 (%struct.usb_hcd*, i1)** %pci_suspend24, align 8, !tbaa !780
  %tobool25 = trunc i8 %frombool to i1
  %call26 = call i32 %11(%struct.usb_hcd* %2, i1 zeroext %tobool25)
  %driver27 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 8
  %12 = load %struct.hc_driver*, %struct.hc_driver** %driver27, align 8, !tbaa !71
  %pci_suspend28 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %12, i32 0, i32 7
  %13 = load i32 (%struct.usb_hcd*, i1)*, i32 (%struct.usb_hcd*, i1)** %pci_suspend28, align 8, !tbaa !780
  %14 = bitcast i32 (%struct.usb_hcd*, i1)* %13 to i8*
  call void @__suspend_report_result(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.suspend_common, i32 0, i32 0), i8* %14, i32 %call26)
  %cond = icmp eq i32 %call26, 0
  br i1 %cond, label %land.lhs.true29, label %if.end54

land.lhs.true29:                                  ; preds = %if.end22
  %tobool30 = trunc i8 %frombool to i1
  br i1 %tobool30, label %land.lhs.true31, label %lor.lhs.false

land.lhs.true31:                                  ; preds = %land.lhs.true29
  %flags32 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 10
  %15 = load i64, i64* %flags32, align 8, !tbaa !314
  %and33 = and i64 %15, 16
  %tobool34 = icmp ne i64 %and33, 0
  br i1 %tobool34, label %if.then46, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true31, %land.lhs.true29
  %cmp35 = icmp eq i32 %call26, 0
  br i1 %cmp35, label %land.lhs.true36, label %if.end54

land.lhs.true36:                                  ; preds = %lor.lhs.false
  %tobool37 = trunc i8 %frombool to i1
  br i1 %tobool37, label %land.lhs.true38, label %if.end54

land.lhs.true38:                                  ; preds = %land.lhs.true36
  %shared_hcd39 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 18
  %16 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd39, align 8, !tbaa !342
  %tobool40 = icmp ne %struct.usb_hcd* %16, null
  br i1 %tobool40, label %land.lhs.true41, label %if.end54

land.lhs.true41:                                  ; preds = %land.lhs.true38
  %shared_hcd42 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 18
  %17 = load %struct.usb_hcd*, %struct.usb_hcd** %shared_hcd42, align 8, !tbaa !342
  %flags43 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %17, i32 0, i32 10
  %18 = load i64, i64* %flags43, align 8, !tbaa !314
  %and44 = and i64 %18, 16
  %tobool45 = icmp ne i64 %and44, 0
  br i1 %tobool45, label %if.then46, label %if.end54

if.then46:                                        ; preds = %land.lhs.true41, %land.lhs.true31
  %driver47 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 8
  %19 = load %struct.hc_driver*, %struct.hc_driver** %driver47, align 8, !tbaa !71
  %pci_resume = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %19, i32 0, i32 8
  %20 = load i32 (%struct.usb_hcd*, i1)*, i32 (%struct.usb_hcd*, i1)** %pci_resume, align 8, !tbaa !776
  %tobool48 = icmp ne i32 (%struct.usb_hcd*, i1)* %20, null
  br i1 %tobool48, label %if.then49, label %if.end54

if.then49:                                        ; preds = %if.then46
  %driver50 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 8
  %21 = load %struct.hc_driver*, %struct.hc_driver** %driver50, align 8, !tbaa !71
  %pci_resume51 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %21, i32 0, i32 8
  %22 = load i32 (%struct.usb_hcd*, i1)*, i32 (%struct.usb_hcd*, i1)** %pci_resume51, align 8, !tbaa !776
  %call52 = call i32 %22(%struct.usb_hcd* %2, i1 zeroext false)
  br label %if.end54

if.end54:                                         ; preds = %if.then49, %if.then46, %land.lhs.true41, %land.lhs.true38, %land.lhs.true36, %lor.lhs.false, %if.end22
  %retval1.0 = phi i32 [ %call26, %land.lhs.true41 ], [ %call26, %land.lhs.true38 ], [ %call26, %land.lhs.true36 ], [ %call26, %lor.lhs.false ], [ %call26, %if.end22 ], [ -16, %if.then49 ], [ -16, %if.then46 ]
  %tobool55 = icmp ne i32 %retval1.0, 0
  br i1 %tobool55, label %cleanup, label %if.end58

if.end58:                                         ; preds = %if.end54, %land.lhs.true, %if.end
  %retval1.1 = phi i32 [ %call2, %land.lhs.true ], [ %call2, %if.end ], [ %retval1.0, %if.end54 ]
  %msix_enabled = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %2, i32 0, i32 11
  %bf.load = load i8, i8* %msix_enabled, align 8
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool59 = icmp ne i32 %bf.cast, 0
  br i1 %tobool59, label %if.end61, label %if.then60

if.then60:                                        ; preds = %if.end58
  %irq = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %1, i32 0, i32 36
  %23 = load i32, i32* %irq, align 4, !tbaa !781
  call void @synchronize_irq(i32 %23)
  br label %if.end61

if.end61:                                         ; preds = %if.then60, %if.end58
  call void @pci_disable_device(%struct.pci_dev* %1)
  br label %cleanup

cleanup:                                          ; preds = %if.end61, %if.end54, %land.lhs.true16, %land.lhs.true7, %entry
  %retval.0 = phi i32 [ %retval1.1, %if.end61 ], [ %call2, %entry ], [ -16, %land.lhs.true7 ], [ -16, %land.lhs.true16 ], [ %retval1.0, %if.end54 ]
  ret i32 %retval.0
}

declare void @__suspend_report_result(i8*, i8*, i32) #2

declare void @synchronize_irq(i32) #2

declare void @pci_disable_device(%struct.pci_dev*) #2

declare i32 @pci_back_from_sleep(%struct.pci_dev*) #2

declare i32 @pci_save_state(%struct.pci_dev*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @device_may_wakeup.870(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %can_wakeup = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 1
  %bf.load = load i8, i8* %can_wakeup, align 4
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %power1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %wakeup = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power1, i32 0, i32 5
  %0 = load %struct.wakeup_source*, %struct.wakeup_source** %wakeup, align 8, !tbaa !403
  %tobool2 = icmp ne %struct.wakeup_source* %0, null
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %1 = phi i1 [ false, %entry ], [ %lnot3, %land.rhs ]
  ret i1 %1
}

declare i32 @pci_prepare_to_sleep(%struct.pci_dev*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @pci_power_name(i32 %state) #1 {
entry:
  %add = add nsw i32 1, %state
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds [0 x i8*], [0 x i8*]* @pci_power_names, i64 0, i64 %idxprom
  %0 = load i8*, i8** %arrayidx, align 8, !tbaa !48
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_pci_shutdown(%struct.pci_dev* %dev) #0 {
entry:
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %dev)
  %0 = bitcast i8* %call to %struct.usb_hcd*
  %tobool = icmp ne %struct.usb_hcd* %0, null
  br i1 %tobool, label %cond.true, label %cleanup.cont

cond.true:                                        ; preds = %entry
  %flags = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 10
  %1 = load volatile i64, i64* %flags, align 8, !tbaa !49
  %and.i = and i64 1, %1
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool2 = icmp ne i32 %conv.i, 0
  br i1 %tobool2, label %land.lhs.true, label %cleanup.cont

land.lhs.true:                                    ; preds = %cond.true
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 8
  %2 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %shutdown = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %2, i32 0, i32 10
  %3 = load void (%struct.usb_hcd*)*, void (%struct.usb_hcd*)** %shutdown, align 8, !tbaa !303
  %tobool6 = icmp ne void (%struct.usb_hcd*)* %3, null
  br i1 %tobool6, label %if.then7, label %cleanup.cont

if.then7:                                         ; preds = %land.lhs.true
  %driver8 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 8
  %4 = load %struct.hc_driver*, %struct.hc_driver** %driver8, align 8, !tbaa !71
  %shutdown9 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %4, i32 0, i32 10
  %5 = load void (%struct.usb_hcd*)*, void (%struct.usb_hcd*)** %shutdown9, align 8, !tbaa !303
  call void %5(%struct.usb_hcd* %0)
  call void @pci_disable_device(%struct.pci_dev* %dev)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then7, %land.lhs.true, %cond.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @usb_hcd_pci_remove(%struct.pci_dev* %dev) #0 {
entry:
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %dev)
  %0 = bitcast i8* %call to %struct.usb_hcd*
  %tobool = icmp ne %struct.usb_hcd* %0, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %call1 = call zeroext i1 @pci_dev_run_wake(%struct.pci_dev* %dev)
  br i1 %call1, label %if.then2, label %do.body

if.then2:                                         ; preds = %if.end
  %dev3 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  call void @pm_runtime_get_noresume.877(%struct.device* %dev3)
  br label %do.body

do.body:                                          ; preds = %if.then2, %if.end
  call void @arch_local_irq_disable.878()
  call void @trace_hardirqs_off()
  %1 = bitcast %struct.usb_hcd* %0 to i8*
  %call5 = call i32 @usb_hcd_irq(i32 undef, i8* %1)
  call void @trace_hardirqs_on()
  call void @arch_local_irq_enable()
  %class = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 11
  %2 = load i32, i32* %class, align 4, !tbaa !777
  %cmp = icmp eq i32 %2, 787232
  br i1 %cmp, label %if.then9, label %if.else

if.then9:                                         ; preds = %do.body
  call void @down_write(%struct.rw_semaphore* @companions_rwsem)
  call void @for_each_companion(%struct.pci_dev* %dev, %struct.usb_hcd* %0, void (%struct.pci_dev*, %struct.usb_hcd*, %struct.pci_dev*, %struct.usb_hcd*)* @ehci_remove)
  call void bitcast (void (%struct.usb_hcd.588*)* @usb_remove_hcd to void (%struct.usb_hcd*)*)(%struct.usb_hcd* %0)
  %dev10 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %call11 = call i32 @dev_set_drvdata(%struct.device* %dev10, i8* null)
  call void @up_write(%struct.rw_semaphore* @companions_rwsem)
  br label %if.end14

if.else:                                          ; preds = %do.body
  call void @down_read(%struct.rw_semaphore* @companions_rwsem)
  %self = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 0
  %hs_companion = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 11
  store %struct.usb_bus* null, %struct.usb_bus** %hs_companion, align 8, !tbaa !782
  call void bitcast (void (%struct.usb_hcd.588*)* @usb_remove_hcd to void (%struct.usb_hcd*)*)(%struct.usb_hcd* %0)
  %dev12 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %call13 = call i32 @dev_set_drvdata(%struct.device* %dev12, i8* null)
  call void @up_read(%struct.rw_semaphore* @companions_rwsem)
  br label %if.end14

if.end14:                                         ; preds = %if.else, %if.then9
  %driver = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 8
  %3 = load %struct.hc_driver*, %struct.hc_driver** %driver, align 8, !tbaa !71
  %flags = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %3, i32 0, i32 4
  %4 = load i32, i32* %flags, align 8, !tbaa !159
  %and = and i32 %4, 1
  %tobool15 = icmp ne i32 %and, 0
  br i1 %tobool15, label %if.then16, label %if.else17

if.then16:                                        ; preds = %if.end14
  %regs = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 13
  %5 = load i8*, i8** %regs, align 8, !tbaa !783
  call void @iounmap(i8* %5)
  %rsrc_start = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 14
  %6 = load i64, i64* %rsrc_start, align 8, !tbaa !318
  %rsrc_len = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 15
  %7 = load i64, i64* %rsrc_len, align 8, !tbaa !784
  call void @__release_region(%struct.resource* @iomem_resource, i64 %6, i64 %7)
  br label %if.end20

if.else17:                                        ; preds = %if.end14
  %rsrc_start18 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 14
  %8 = load i64, i64* %rsrc_start18, align 8, !tbaa !318
  %rsrc_len19 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %0, i32 0, i32 15
  %9 = load i64, i64* %rsrc_len19, align 8, !tbaa !784
  call void @__release_region(%struct.resource* @ioport_resource, i64 %8, i64 %9)
  br label %if.end20

if.end20:                                         ; preds = %if.else17, %if.then16
  call void bitcast (void (%struct.usb_hcd.588*)* @usb_put_hcd to void (%struct.usb_hcd*)*)(%struct.usb_hcd* %0)
  call void @pci_disable_device(%struct.pci_dev* %dev)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end20, %entry
  ret void
}

declare zeroext i1 @pci_dev_run_wake(%struct.pci_dev*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_get_noresume.877(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %usage_count = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 11
  call void @atomic_inc.882(%union.anon.5* %usage_count)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @arch_local_irq_disable.878() #1 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops.581, %struct.pv_irq_ops.581* @pv_irq_ops, i32 0, i32 2, i32 0), align 8, !tbaa !352
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.9.881, i32 0, i32 0), i32 834, i64 12) #8, !srcloc !785
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call i64 asm sideeffect "771:\0A\09call *${2:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${1:c}\0A  .byte 772b-771b\0A  .short ${3:c}\0A.popsection\0A", "={ax},i,i,i,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 46, i8** getelementptr inbounds (%struct.pv_irq_ops.581, %struct.pv_irq_ops.581* @pv_irq_ops, i32 0, i32 2, i32 0), i32 1) #8, !srcloc !786
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @arch_local_irq_enable() #1 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops.581, %struct.pv_irq_ops.581* @pv_irq_ops, i32 0, i32 3, i32 0), align 8, !tbaa !787
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.9.881, i32 0, i32 0), i32 839, i64 12) #8, !srcloc !788
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call i64 asm sideeffect "771:\0A\09call *${2:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${1:c}\0A  .byte 772b-771b\0A  .short ${3:c}\0A.popsection\0A", "={ax},i,i,i,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 47, i8** getelementptr inbounds (%struct.pv_irq_ops.581, %struct.pv_irq_ops.581* @pv_irq_ops, i32 0, i32 3, i32 0), i32 1) #8, !srcloc !789
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @ehci_remove(%struct.pci_dev* %pdev, %struct.usb_hcd* %hcd, %struct.pci_dev* %companion, %struct.usb_hcd* %companion_hcd) #0 {
entry:
  %call = call i32 @is_ohci_or_uhci(%struct.pci_dev* %companion)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %self = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %companion_hcd, i32 0, i32 0
  %hs_companion = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 11
  store %struct.usb_bus* null, %struct.usb_bus** %hs_companion, align 8, !tbaa !782
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @iounmap(i8*) #2

declare void @__release_region(%struct.resource*, i64, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.882(%union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #8, !srcloc !790
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_hcd_pci_probe(%struct.pci_dev* %dev, %struct.pci_device_id* %id) #0 {
entry:
  %call = call i32 @usb_disabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup220, label %if.end

if.end:                                           ; preds = %entry
  %tobool2 = icmp ne %struct.pci_device_id* %id, null
  br i1 %tobool2, label %if.end4, label %cleanup220

if.end4:                                          ; preds = %if.end
  %driver_data = getelementptr inbounds %struct.pci_device_id, %struct.pci_device_id* %id, i32 0, i32 6
  %0 = load i64, i64* %driver_data, align 8, !tbaa !791
  %1 = inttoptr i64 %0 to %struct.hc_driver*
  %tobool5 = icmp ne %struct.hc_driver* %1, null
  br i1 %tobool5, label %if.end7, label %cleanup220

if.end7:                                          ; preds = %if.end4
  %call8 = call i32 @pci_enable_device(%struct.pci_dev* %dev)
  %cmp = icmp slt i32 %call8, 0
  br i1 %cmp, label %cleanup220, label %if.end10

if.end10:                                         ; preds = %if.end7
  %current_state = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 25
  store i32 0, i32* %current_state, align 8, !tbaa !773
  %flags = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 4
  %2 = load i32, i32* %flags, align 8, !tbaa !159
  %and = and i32 %2, 112
  %cmp11 = icmp ne i32 %and, 64
  br i1 %cmp11, label %if.then12, label %if.end20

if.then12:                                        ; preds = %if.end10
  %irq = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 36
  %3 = load i32, i32* %irq, align 4, !tbaa !781
  %tobool13 = icmp ne i32 %3, 0
  br i1 %tobool13, label %if.end18, label %if.then14

if.then14:                                        ; preds = %if.then12
  %call16 = call i8* @pci_name(%struct.pci_dev* %dev)
  %4 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %disable_pci

if.end18:                                         ; preds = %if.then12
  %irq19 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 36
  %5 = load i32, i32* %irq19, align 4, !tbaa !781
  br label %if.end20

if.end20:                                         ; preds = %if.end18, %if.end10
  %hcd_irq.0 = phi i32 [ %5, %if.end18 ], [ 0, %if.end10 ]
  %dev21 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %call22 = call i8* @pci_name(%struct.pci_dev* %dev)
  %call23 = call %struct.usb_hcd* bitcast (%struct.usb_hcd.588* (%struct.hc_driver.589*, %struct.device*, i8*)* @usb_create_hcd to %struct.usb_hcd* (%struct.hc_driver*, %struct.device*, i8*)*)(%struct.hc_driver* %1, %struct.device* %dev21, i8* %call22)
  %tobool24 = icmp ne %struct.usb_hcd* %call23, null
  br i1 %tobool24, label %if.end26, label %disable_pci

if.end26:                                         ; preds = %if.end20
  %flags27 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 4
  %6 = load i32, i32* %flags27, align 8, !tbaa !159
  %and28 = and i32 %6, 1
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.then30, label %if.else

if.then30:                                        ; preds = %if.end26
  %resource = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 37
  %arrayidx = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource, i64 0, i64 0
  %start = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx, i32 0, i32 0
  %7 = load i64, i64* %start, align 8, !tbaa !793
  %rsrc_start = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 14
  store i64 %7, i64* %rsrc_start, align 8, !tbaa !318
  %resource31 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 37
  %arrayidx32 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource31, i64 0, i64 0
  %start33 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx32, i32 0, i32 0
  %8 = load i64, i64* %start33, align 8, !tbaa !793
  %cmp34 = icmp eq i64 %8, 0
  br i1 %cmp34, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.then30
  %resource35 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 37
  %arrayidx36 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource35, i64 0, i64 0
  %end = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx36, i32 0, i32 1
  %9 = load i64, i64* %end, align 8, !tbaa !795
  %resource37 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 37
  %arrayidx38 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource37, i64 0, i64 0
  %start39 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx38, i32 0, i32 0
  %10 = load i64, i64* %start39, align 8, !tbaa !793
  %cmp40 = icmp eq i64 %9, %10
  br i1 %cmp40, label %cond.end, label %cond.false

cond.false:                                       ; preds = %land.lhs.true, %if.then30
  %resource41 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 37
  %arrayidx42 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource41, i64 0, i64 0
  %end43 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx42, i32 0, i32 1
  %11 = load i64, i64* %end43, align 8, !tbaa !795
  %resource44 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 37
  %arrayidx45 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource44, i64 0, i64 0
  %start46 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx45, i32 0, i32 0
  %12 = load i64, i64* %start46, align 8, !tbaa !793
  %sub = sub i64 %11, %12
  %add = add i64 %sub, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %land.lhs.true
  %cond = phi i64 [ %add, %cond.false ], [ 0, %land.lhs.true ]
  %rsrc_len = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 15
  store i64 %cond, i64* %rsrc_len, align 8, !tbaa !784
  %rsrc_start47 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 14
  %13 = load i64, i64* %rsrc_start47, align 8, !tbaa !318
  %rsrc_len48 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 15
  %14 = load i64, i64* %rsrc_len48, align 8, !tbaa !784
  %description = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 0
  %15 = load i8*, i8** %description, align 8, !tbaa !316
  %call49 = call %struct.resource* @__request_region(%struct.resource* @iomem_resource, i64 %13, i64 %14, i8* %15, i32 0)
  %tobool50 = icmp ne %struct.resource* %call49, null
  br i1 %tobool50, label %if.end63, label %do.body52

do.body52:                                        ; preds = %cond.end
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_pci_probe.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and53 = and i32 %bf.clear, 1
  %tobool54 = icmp ne i32 %and53, 0
  %lnot = xor i1 %tobool54, true
  %lnot55 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot55 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool56 = icmp ne i64 %expval, 0
  br i1 %tobool56, label %if.then57, label %put_hcd

if.then57:                                        ; preds = %do.body52
  %dev58 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %call59 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_pci_probe.descriptor to %struct._ddebug*), %struct.device* %dev58, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3.884, i32 0, i32 0))
  br label %put_hcd

if.end63:                                         ; preds = %cond.end
  %rsrc_start64 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 14
  %16 = load i64, i64* %rsrc_start64, align 8, !tbaa !318
  %rsrc_len65 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 15
  %17 = load i64, i64* %rsrc_len65, align 8, !tbaa !784
  %call66 = call i8* @ioremap_nocache(i64 %16, i64 %17)
  %regs = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 13
  store i8* %call66, i8** %regs, align 8, !tbaa !783
  %regs67 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 13
  %18 = load i8*, i8** %regs67, align 8, !tbaa !783
  %cmp68 = icmp eq i8* %18, null
  br i1 %cmp68, label %do.body72, label %if.end173

do.body72:                                        ; preds = %if.end63
  %bf.load73 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_pci_probe.descriptor.4 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr74 = lshr i32 %bf.load73, 18
  %bf.clear75 = and i32 %bf.lshr74, 255
  %and76 = and i32 %bf.clear75, 1
  %tobool77 = icmp ne i32 %and76, 0
  %lnot78 = xor i1 %tobool77, true
  %lnot80 = xor i1 %lnot78, true
  %lnot.ext81 = zext i1 %lnot80 to i32
  %conv82 = sext i32 %lnot.ext81 to i64
  %expval83 = call i64 @llvm.expect.i64(i64 %conv82, i64 0)
  %tobool84 = icmp ne i64 %expval83, 0
  br i1 %tobool84, label %if.then85, label %release_mem_region

if.then85:                                        ; preds = %do.body72
  %dev86 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %call87 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_pci_probe.descriptor.4 to %struct._ddebug*), %struct.device* %dev86, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5.885, i32 0, i32 0))
  br label %release_mem_region

if.else:                                          ; preds = %if.end26
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %region.0 = phi i32 [ 0, %if.else ], [ %inc, %for.inc ]
  %cmp94 = icmp slt i32 %region.0, 6
  br i1 %cmp94, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %resource96 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 37
  %idxprom = sext i32 %region.0 to i64
  %arrayidx97 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource96, i64 0, i64 %idxprom
  %flags98 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx97, i32 0, i32 3
  %19 = load i64, i64* %flags98, align 8, !tbaa !796
  %and99 = and i64 %19, 256
  %tobool100 = icmp ne i64 %and99, 0
  br i1 %tobool100, label %if.end102, label %for.inc

if.end102:                                        ; preds = %for.body
  %resource103 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 37
  %idxprom104 = sext i32 %region.0 to i64
  %arrayidx105 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource103, i64 0, i64 %idxprom104
  %start106 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx105, i32 0, i32 0
  %20 = load i64, i64* %start106, align 8, !tbaa !793
  %rsrc_start107 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 14
  store i64 %20, i64* %rsrc_start107, align 8, !tbaa !318
  %resource108 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 37
  %idxprom109 = sext i32 %region.0 to i64
  %arrayidx110 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource108, i64 0, i64 %idxprom109
  %start111 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx110, i32 0, i32 0
  %21 = load i64, i64* %start111, align 8, !tbaa !793
  %cmp112 = icmp eq i64 %21, 0
  br i1 %cmp112, label %land.lhs.true114, label %cond.false126

land.lhs.true114:                                 ; preds = %if.end102
  %resource115 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 37
  %idxprom116 = sext i32 %region.0 to i64
  %arrayidx117 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource115, i64 0, i64 %idxprom116
  %end118 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx117, i32 0, i32 1
  %22 = load i64, i64* %end118, align 8, !tbaa !795
  %resource119 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 37
  %idxprom120 = sext i32 %region.0 to i64
  %arrayidx121 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource119, i64 0, i64 %idxprom120
  %start122 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx121, i32 0, i32 0
  %23 = load i64, i64* %start122, align 8, !tbaa !793
  %cmp123 = icmp eq i64 %22, %23
  br i1 %cmp123, label %cond.end137, label %cond.false126

cond.false126:                                    ; preds = %land.lhs.true114, %if.end102
  %resource127 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 37
  %idxprom128 = sext i32 %region.0 to i64
  %arrayidx129 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource127, i64 0, i64 %idxprom128
  %end130 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx129, i32 0, i32 1
  %24 = load i64, i64* %end130, align 8, !tbaa !795
  %resource131 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 37
  %idxprom132 = sext i32 %region.0 to i64
  %arrayidx133 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource131, i64 0, i64 %idxprom132
  %start134 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx133, i32 0, i32 0
  %25 = load i64, i64* %start134, align 8, !tbaa !793
  %sub135 = sub i64 %24, %25
  %add136 = add i64 %sub135, 1
  br label %cond.end137

cond.end137:                                      ; preds = %cond.false126, %land.lhs.true114
  %cond138 = phi i64 [ %add136, %cond.false126 ], [ 0, %land.lhs.true114 ]
  %rsrc_len139 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 15
  store i64 %cond138, i64* %rsrc_len139, align 8, !tbaa !784
  %rsrc_start140 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 14
  %26 = load i64, i64* %rsrc_start140, align 8, !tbaa !318
  %rsrc_len141 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 15
  %27 = load i64, i64* %rsrc_len141, align 8, !tbaa !784
  %description142 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 0
  %28 = load i8*, i8** %description142, align 8, !tbaa !316
  %call143 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %26, i64 %27, i8* %28, i32 0)
  %tobool144 = icmp ne %struct.resource* %call143, null
  br i1 %tobool144, label %for.end, label %for.inc

for.inc:                                          ; preds = %cond.end137, %for.body
  %inc = add nsw i32 %region.0, 1
  br label %for.cond

for.end:                                          ; preds = %cond.end137, %for.cond
  %cmp147 = icmp eq i32 %region.0, 6
  br i1 %cmp147, label %do.body151, label %NodeBlock

do.body151:                                       ; preds = %for.end
  %bf.load152 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_pci_probe.descriptor.6 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr153 = lshr i32 %bf.load152, 18
  %bf.clear154 = and i32 %bf.lshr153, 255
  %and155 = and i32 %bf.clear154, 1
  %tobool156 = icmp ne i32 %and155, 0
  %lnot157 = xor i1 %tobool156, true
  %lnot159 = xor i1 %lnot157, true
  %lnot.ext160 = zext i1 %lnot159 to i32
  %conv161 = sext i32 %lnot.ext160 to i64
  %expval162 = call i64 @llvm.expect.i64(i64 %conv161, i64 0)
  %tobool163 = icmp ne i64 %expval162, 0
  br i1 %tobool163, label %if.then164, label %NodeBlock

if.then164:                                       ; preds = %do.body151
  %dev165 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %call166 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_hcd_pci_probe.descriptor.6 to %struct._ddebug*), %struct.device* %dev165, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7.886, i32 0, i32 0))
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.then164, %do.body151, %for.end
  %cleanup.dest.slot.0 = phi i32 [ 7, %if.then164 ], [ 7, %do.body151 ], [ 0, %for.end ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 7
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 7
  br i1 %SwitchLeaf2, label %put_hcd, label %cleanup220

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end173, label %cleanup220

if.end173:                                        ; preds = %LeafBlock, %if.end63
  call void @pci_set_master(%struct.pci_dev* %dev)
  %class = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 11
  %29 = load i32, i32* %class, align 4, !tbaa !777
  %cmp174 = icmp eq i32 %29, 787232
  br i1 %cmp174, label %if.then176, label %if.else186

if.then176:                                       ; preds = %if.end173
  call void @down_write(%struct.rw_semaphore* @companions_rwsem)
  %dev177 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %30 = bitcast %struct.usb_hcd* %call23 to i8*
  %call178 = call i32 @dev_set_drvdata(%struct.device* %dev177, i8* %30)
  call void @for_each_companion(%struct.pci_dev* %dev, %struct.usb_hcd* %call23, void (%struct.pci_dev*, %struct.usb_hcd*, %struct.pci_dev*, %struct.usb_hcd*)* @ehci_pre_add)
  %call179 = call i32 bitcast (i32 (%struct.usb_hcd.588*, i32, i64)* @usb_add_hcd to i32 (%struct.usb_hcd*, i32, i64)*)(%struct.usb_hcd* %call23, i32 %hcd_irq.0, i64 128)
  %cmp180 = icmp ne i32 %call179, 0
  br i1 %cmp180, label %if.then182, label %if.end185

if.then182:                                       ; preds = %if.then176
  %dev183 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %call184 = call i32 @dev_set_drvdata(%struct.device* %dev183, i8* null)
  br label %if.end185

if.end185:                                        ; preds = %if.then182, %if.then176
  call void @for_each_companion(%struct.pci_dev* %dev, %struct.usb_hcd* %call23, void (%struct.pci_dev*, %struct.usb_hcd*, %struct.pci_dev*, %struct.usb_hcd*)* @ehci_post_add)
  call void @up_write(%struct.rw_semaphore* @companions_rwsem)
  br label %if.end197

if.else186:                                       ; preds = %if.end173
  call void @down_read(%struct.rw_semaphore* @companions_rwsem)
  %dev187 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %31 = bitcast %struct.usb_hcd* %call23 to i8*
  %call188 = call i32 @dev_set_drvdata(%struct.device* %dev187, i8* %31)
  %call189 = call i32 bitcast (i32 (%struct.usb_hcd.588*, i32, i64)* @usb_add_hcd to i32 (%struct.usb_hcd*, i32, i64)*)(%struct.usb_hcd* %call23, i32 %hcd_irq.0, i64 128)
  %cmp190 = icmp ne i32 %call189, 0
  br i1 %cmp190, label %if.then192, label %if.else195

if.then192:                                       ; preds = %if.else186
  %dev193 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %call194 = call i32 @dev_set_drvdata(%struct.device* %dev193, i8* null)
  br label %if.end196

if.else195:                                       ; preds = %if.else186
  call void @for_each_companion(%struct.pci_dev* %dev, %struct.usb_hcd* %call23, void (%struct.pci_dev*, %struct.usb_hcd*, %struct.pci_dev*, %struct.usb_hcd*)* @non_ehci_add)
  br label %if.end196

if.end196:                                        ; preds = %if.else195, %if.then192
  call void @up_read(%struct.rw_semaphore* @companions_rwsem)
  br label %if.end197

if.end197:                                        ; preds = %if.end196, %if.end185
  %retval1.1 = phi i32 [ %call179, %if.end185 ], [ %call189, %if.end196 ]
  %cmp198 = icmp ne i32 %retval1.1, 0
  br i1 %cmp198, label %unmap_registers, label %if.end201

if.end201:                                        ; preds = %if.end197
  %call202 = call zeroext i1 @pci_dev_run_wake(%struct.pci_dev* %dev)
  br i1 %call202, label %if.then203, label %cleanup220

if.then203:                                       ; preds = %if.end201
  %dev204 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  call void @pm_runtime_put_noidle.887(%struct.device* %dev204)
  br label %cleanup220

unmap_registers:                                  ; preds = %if.end197
  %flags206 = getelementptr inbounds %struct.hc_driver, %struct.hc_driver* %1, i32 0, i32 4
  %32 = load i32, i32* %flags206, align 8, !tbaa !159
  %and207 = and i32 %32, 1
  %tobool208 = icmp ne i32 %and207, 0
  br i1 %tobool208, label %if.then209, label %if.else213

if.then209:                                       ; preds = %unmap_registers
  %regs210 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 13
  %33 = load i8*, i8** %regs210, align 8, !tbaa !783
  call void @iounmap(i8* %33)
  br label %release_mem_region

release_mem_region:                               ; preds = %if.then209, %if.then85, %do.body72
  %retval1.2 = phi i32 [ %retval1.1, %if.then209 ], [ -14, %if.then85 ], [ -14, %do.body72 ]
  %rsrc_start211 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 14
  %34 = load i64, i64* %rsrc_start211, align 8, !tbaa !318
  %rsrc_len212 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 15
  %35 = load i64, i64* %rsrc_len212, align 8, !tbaa !784
  call void @__release_region(%struct.resource* @iomem_resource, i64 %34, i64 %35)
  br label %put_hcd

if.else213:                                       ; preds = %unmap_registers
  %rsrc_start214 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 14
  %36 = load i64, i64* %rsrc_start214, align 8, !tbaa !318
  %rsrc_len215 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %call23, i32 0, i32 15
  %37 = load i64, i64* %rsrc_len215, align 8, !tbaa !784
  call void @__release_region(%struct.resource* @ioport_resource, i64 %36, i64 %37)
  br label %put_hcd

put_hcd:                                          ; preds = %if.else213, %release_mem_region, %LeafBlock1, %if.then57, %do.body52
  %retval1.4 = phi i32 [ -16, %LeafBlock1 ], [ -16, %if.then57 ], [ -16, %do.body52 ], [ %retval1.2, %release_mem_region ], [ %retval1.1, %if.else213 ]
  call void bitcast (void (%struct.usb_hcd.588*)* @usb_put_hcd to void (%struct.usb_hcd*)*)(%struct.usb_hcd* %call23)
  br label %disable_pci

disable_pci:                                      ; preds = %put_hcd, %if.end20, %if.then14
  %retval1.5 = phi i32 [ %retval1.4, %put_hcd ], [ -19, %if.then14 ], [ -12, %if.end20 ]
  call void @pci_disable_device(%struct.pci_dev* %dev)
  %call218 = call i8* @pci_name(%struct.pci_dev* %dev)
  %38 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup220

cleanup220:                                       ; preds = %disable_pci, %if.then203, %if.end201, %LeafBlock, %LeafBlock1, %if.end7, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %retval1.5, %disable_pci ], [ -19, %entry ], [ -22, %if.end ], [ -22, %if.end4 ], [ -19, %if.end7 ], [ %retval1.1, %if.then203 ], [ %retval1.1, %if.end201 ], [ undef, %LeafBlock1 ], [ undef, %LeafBlock ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @pci_name(%struct.pci_dev* %pdev) #1 {
entry:
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 34
  %call = call i8* @dev_name.893(%struct.device* %dev)
  ret i8* %call
}

declare %struct.resource* @__request_region(%struct.resource*, i64, i64, i8*, i32) #2

declare i8* @ioremap_nocache(i64, i64) #2

; Function Attrs: nounwind uwtable
define internal void @ehci_pre_add(%struct.pci_dev* %pdev, %struct.usb_hcd* %hcd, %struct.pci_dev* %companion, %struct.usb_hcd* %companion_hcd) #0 {
entry:
  %call = call i32 @is_ohci_or_uhci(%struct.pci_dev* %companion)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %self = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %companion_hcd, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self, i32 0, i32 10
  %0 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !151
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock.898(%struct.device* %dev)
  %call1 = call i32 @usb_set_configuration(%struct.usb_device* %0, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @ehci_post_add(%struct.pci_dev* %pdev, %struct.usb_hcd* %hcd, %struct.pci_dev* %companion, %struct.usb_hcd* %companion_hcd) #0 {
entry:
  %call = call i32 @is_ohci_or_uhci(%struct.pci_dev* %companion)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end20

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 34
  %call1 = call i8* @dev_get_drvdata(%struct.device* %dev)
  %tobool2 = icmp ne i8* %call1, null
  br i1 %tobool2, label %do.body4, label %if.end16

do.body4:                                         ; preds = %if.then
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @ehci_post_add.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool5 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool5, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then8, label %do.end14

if.then8:                                         ; preds = %do.body4
  %dev9 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 34
  %dev10 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %companion, i32 0, i32 34
  %call11 = call i8* @dev_name.893(%struct.device* %dev10)
  %call12 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @ehci_post_add.descriptor to %struct._ddebug*), %struct.device* %dev9, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.12.896, i32 0, i32 0), i8* %call11)
  br label %do.end14

do.end14:                                         ; preds = %if.then8, %do.body4
  %self = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %hcd, i32 0, i32 0
  %self15 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %companion_hcd, i32 0, i32 0
  %hs_companion = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self15, i32 0, i32 11
  store %struct.usb_bus* %self, %struct.usb_bus** %hs_companion, align 8, !tbaa !782
  br label %if.end16

if.end16:                                         ; preds = %do.end14, %if.then
  %self17 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %companion_hcd, i32 0, i32 0
  %root_hub = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self17, i32 0, i32 10
  %0 = load %struct.usb_device*, %struct.usb_device** %root_hub, align 8, !tbaa !151
  %call18 = call i32 @usb_set_configuration(%struct.usb_device* %0, i32 1)
  %dev19 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock.897(%struct.device* %dev19)
  br label %if.end20

if.end20:                                         ; preds = %if.end16, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @non_ehci_add(%struct.pci_dev* %pdev, %struct.usb_hcd* %hcd, %struct.pci_dev* %companion, %struct.usb_hcd* %companion_hcd) #0 {
entry:
  %call = call i32 @is_ohci_or_uhci(%struct.pci_dev* %pdev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %class = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %companion, i32 0, i32 11
  %0 = load i32, i32* %class, align 4, !tbaa !777
  %cmp = icmp eq i32 %0, 787232
  br i1 %cmp, label %do.body1, label %if.end11

do.body1:                                         ; preds = %land.lhs.true
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @non_ehci_add.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool2 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then5, label %do.end9

if.then5:                                         ; preds = %do.body1
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 34
  %dev6 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %companion, i32 0, i32 34
  %call7 = call i8* @dev_name.893(%struct.device* %dev6)
  %call8 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @non_ehci_add.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.13.894, i32 0, i32 0), i8* %call7)
  br label %do.end9

do.end9:                                          ; preds = %if.then5, %do.body1
  %self = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %companion_hcd, i32 0, i32 0
  %self10 = getelementptr inbounds %struct.usb_hcd, %struct.usb_hcd* %hcd, i32 0, i32 0
  %hs_companion = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %self10, i32 0, i32 11
  store %struct.usb_bus* %self, %struct.usb_bus** %hs_companion, align 8, !tbaa !782
  br label %if.end11

if.end11:                                         ; preds = %do.end9, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pm_runtime_put_noidle.887(%struct.device* %dev) #1 {
entry:
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %usage_count = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 11
  call void @atomic_add_unless.889(%union.anon.5* %usage_count, i32 -1, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_add_unless.889(%union.anon.5* %v, i32 %a, i32 %u) #1 {
entry:
  %call = call i32 @__atomic_add_unless.890(%union.anon.5* %v, i32 %a, i32 %u)
  %cmp = icmp ne i32 %call, %u
  %conv = zext i1 %cmp to i32
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__atomic_add_unless.890(%union.anon.5* %v, i32 %a, i32 %u) #1 {
entry:
  %call = call i32 @atomic_read.891(%union.anon.5* %v)
  br label %for.cond

for.cond:                                         ; preds = %if.end13, %entry
  %c.0 = phi i32 [ %call, %entry ], [ %call2, %if.end13 ]
  %cmp = icmp eq i32 %c.0, %u
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %for.end, label %if.end

if.end:                                           ; preds = %for.cond
  %add = add nsw i32 %c.0, %a
  %call2 = call i32 @atomic_cmpxchg.892(%union.anon.5* %v, i32 %c.0, i32 %add)
  %cmp3 = icmp eq i32 %call2, %c.0
  %lnot5 = xor i1 %cmp3, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %expval10 = call i64 @llvm.expect.i64(i64 %conv9, i64 1)
  %tobool11 = icmp ne i64 %expval10, 0
  br i1 %tobool11, label %for.end, label %if.end13

if.end13:                                         ; preds = %if.end
  br label %for.cond

for.end:                                          ; preds = %if.end, %for.cond
  ret i32 %c.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read.891(%union.anon.5* %v) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !90
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_cmpxchg.892(%union.anon.5* %v, i32 %old, i32 %new) #1 {
entry:
  %counter = getelementptr inbounds %union.anon.5, %union.anon.5* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; cmpxchgl $2,$1", "={ax},=*m,r,0,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %new, i32 %old, i32* %counter) #8, !srcloc !797
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name.893(%struct.device* %dev) #1 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !341
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !341
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name.895(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name.895(%struct.kobject* %kobj) #1 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !343
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock.897(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock.898(%struct.device* %dev) #1 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @usb_acpi_set_power_state(%struct.usb_device* %hdev, i32 %index, i1 zeroext %enable) #0 {
entry:
  %frombool = zext i1 %enable to i8
  %add = add nsw i32 %index, 1
  %call = call i8* @usb_get_hub_port_acpi_handle(%struct.usb_device* %hdev, i32 %add)
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %tobool1 = trunc i8 %frombool to i1
  %. = select i1 %tobool1, i8 0, i8 4
  %conv = zext i8 %. to i32
  %call4 = call i32 @acpi_bus_set_power(i8* %call, i32 %conv)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %do.body21, label %do.body7

do.body7:                                         ; preds = %if.end
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_acpi_set_power_state.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool8 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool8, true
  %lnot9 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv10 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv10, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %if.then12, label %cleanup

if.then12:                                        ; preds = %do.body7
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 11
  %tobool13 = trunc i8 %frombool to i1
  %conv14 = zext i1 %tobool13 to i32
  %call15 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_acpi_set_power_state.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.2.900, i32 0, i32 0), i32 %add, i32 %conv14)
  br label %cleanup

do.body21:                                        ; preds = %if.end
  %bf.load22 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_acpi_set_power_state.descriptor.3 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr23 = lshr i32 %bf.load22, 18
  %bf.clear24 = and i32 %bf.lshr23, 255
  %and25 = and i32 %bf.clear24, 1
  %tobool26 = icmp ne i32 %and25, 0
  %lnot27 = xor i1 %tobool26, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %if.then34, label %cleanup

if.then34:                                        ; preds = %do.body21
  %dev35 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %hdev, i32 0, i32 11
  %call36 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @usb_acpi_set_power_state.descriptor.3 to %struct._ddebug*), %struct.device* %dev35, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.4.901, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %if.then34, %do.body21, %if.then12, %do.body7, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ %call4, %do.body21 ], [ %call4, %if.then34 ], [ %call4, %do.body7 ], [ %call4, %if.then12 ]
  ret i32 %retval.0
}

declare i32 @acpi_bus_set_power(i8*, i32) #2

; Function Attrs: nounwind uwtable
define zeroext i1 @usb_acpi_power_manageable(%struct.usb_device* %hdev, i32 %index) #0 {
entry:
  %add = add nsw i32 %index, 1
  %call = call i8* @usb_get_hub_port_acpi_handle(%struct.usb_device* %hdev, i32 %add)
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  %call1 = call zeroext i1 @acpi_bus_power_manageable(i8* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.then, %entry
  %retval.0 = phi i1 [ %call1, %if.then ], [ false, %entry ]
  ret i1 %retval.0
}

declare zeroext i1 @acpi_bus_power_manageable(i8*) #2

; Function Attrs: nounwind uwtable
define i32 @usb_acpi_register() #0 {
entry:
  %call = call i32 @register_acpi_bus_type(%struct.acpi_bus_type* @usb_acpi_bus)
  ret i32 %call
}

declare i32 @register_acpi_bus_type(%struct.acpi_bus_type*) #2

; Function Attrs: nounwind uwtable
define internal zeroext i1 @usb_acpi_bus_match(%struct.device* %dev) #0 {
entry:
  %call = call i32 @is_usb_device.907(%struct.device* %dev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %call1 = call i32 @is_usb_port(%struct.device* %dev)
  %tobool2 = icmp ne i32 %call1, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %tobool2, %lor.rhs ]
  ret i1 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @usb_acpi_find_device(%struct.device* %dev, i8** %handle) #0 {
entry:
  %port_num = alloca i32, align 4
  %0 = bitcast i32* %port_num to i8*
  %call = call i32 @is_usb_device.907(%struct.device* %dev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -136
  %2 = bitcast i8* %add.ptr to %struct.usb_device*
  %parent = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 8
  %3 = load %struct.usb_device*, %struct.usb_device** %parent, align 8, !tbaa !89
  %tobool1 = icmp ne %struct.usb_device* %3, null
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %parent3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 8
  %4 = load %struct.usb_device*, %struct.usb_device** %parent3, align 8, !tbaa !89
  %portnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 20
  %5 = load i8, i8* %portnum, align 2, !tbaa !88
  %conv = zext i8 %5 to i32
  %call4 = call i32 @usb_get_hub_port_connect_type(%struct.usb_device* %4, i32 %conv)
  %Pivot = icmp slt i32 %call4, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.then2
  %SwitchLeaf2 = icmp eq i32 %call4, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %if.then2
  %SwitchLeaf = icmp eq i32 %call4, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock, %LeafBlock1
  %.sink = phi i32 [ 0, %sw.default ], [ 2, %LeafBlock1 ], [ 1, %LeafBlock ]
  %removable7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 36
  store i32 %.sink, i32* %removable7, align 4, !tbaa !227
  br label %cleanup58

if.end:                                           ; preds = %if.then
  %parent8 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %6 = load %struct.device*, %struct.device** %parent8, align 8, !tbaa !766
  %acpi_node = getelementptr inbounds %struct.device, %struct.device* %6, i32 0, i32 19
  %handle9 = getelementptr inbounds %union.anon.3, %union.anon.3* %acpi_node, i32 0, i32 0
  %7 = load i8*, i8** %handle9, align 8, !tbaa !300
  %8 = bitcast i8* %7 to i8**
  %9 = bitcast i8** %8 to i8*
  %portnum10 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 20
  %10 = load i8, i8* %portnum10, align 2, !tbaa !88
  %conv11 = zext i8 %10 to i64
  %call12 = call i8* @acpi_get_child(i8* %9, i64 %conv11)
  store i8* %call12, i8** %handle, align 8, !tbaa !48
  %11 = load i8*, i8** %handle, align 8, !tbaa !48
  %tobool13 = icmp ne i8* %11, null
  %. = select i1 %tobool13, i32 0, i32 -19
  br label %cleanup58

if.else:                                          ; preds = %entry
  %call16 = call i32 @is_usb_port(%struct.device* %dev)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.then18, label %cleanup58

if.then18:                                        ; preds = %if.else
  %call19 = call i8* @dev_name.908(%struct.device* %dev)
  %call20 = call i32 (i8*, i8*, ...) @sscanf(i8* %call19, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.7.909, i32 0, i32 0), i32* %port_num)
  %parent22 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %12 = load %struct.device*, %struct.device** %parent22, align 8, !tbaa !766
  %parent23 = getelementptr inbounds %struct.device, %struct.device* %12, i32 0, i32 0
  %13 = load %struct.device*, %struct.device** %parent23, align 8, !tbaa !766
  %14 = bitcast %struct.device* %13 to i8*
  %add.ptr25 = getelementptr inbounds i8, i8* %14, i64 -136
  %15 = bitcast i8* %add.ptr25 to %struct.usb_device*
  %parent26 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %15, i32 0, i32 8
  %16 = load %struct.usb_device*, %struct.usb_device** %parent26, align 8, !tbaa !89
  %tobool27 = icmp ne %struct.usb_device* %16, null
  br i1 %tobool27, label %if.else40, label %if.then28

if.then28:                                        ; preds = %if.then18
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %15, i32 0, i32 9
  %17 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !2
  %call29 = call %struct.usb_hcd* @bus_to_hcd.910(%struct.usb_bus* %17)
  %18 = load i32, i32* %port_num, align 4, !tbaa !90
  %call30 = call i32 bitcast (i32 (%struct.usb_hcd.588*, i32)* @usb_hcd_find_raw_port_number to i32 (%struct.usb_hcd*, i32)*)(%struct.usb_hcd* %call29, i32 %18)
  %dev31 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %15, i32 0, i32 11
  %acpi_node32 = getelementptr inbounds %struct.device, %struct.device* %dev31, i32 0, i32 19
  %handle33 = getelementptr inbounds %union.anon.3, %union.anon.3* %acpi_node32, i32 0, i32 0
  %19 = load i8*, i8** %handle33, align 8, !tbaa !300
  %conv34 = sext i32 %call30 to i64
  %call35 = call i8* @acpi_get_child(i8* %19, i64 %conv34)
  store i8* %call35, i8** %handle, align 8, !tbaa !48
  %20 = load i8*, i8** %handle, align 8, !tbaa !48
  %tobool36 = icmp ne i8* %20, null
  %.6 = select i1 %tobool36, i32 0, i32 1
  %SwitchLeaf5 = icmp eq i32 %.6, 0
  br i1 %SwitchLeaf5, label %if.end53, label %cleanup58

if.else40:                                        ; preds = %if.then18
  %parent41 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %15, i32 0, i32 8
  %21 = load %struct.usb_device*, %struct.usb_device** %parent41, align 8, !tbaa !89
  %portnum42 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %15, i32 0, i32 20
  %22 = load i8, i8* %portnum42, align 2, !tbaa !88
  %conv43 = zext i8 %22 to i32
  %call44 = call i8* @usb_get_hub_port_acpi_handle(%struct.usb_device* %21, i32 %conv43)
  %23 = bitcast i8* %call44 to i8**
  %tobool45 = icmp ne i8** %23, null
  br i1 %tobool45, label %if.end47, label %cleanup58

if.end47:                                         ; preds = %if.else40
  %24 = bitcast i8** %23 to i8*
  %25 = load i32, i32* %port_num, align 4, !tbaa !90
  %conv48 = sext i32 %25 to i64
  %call49 = call i8* @acpi_get_child(i8* %24, i64 %conv48)
  store i8* %call49, i8** %handle, align 8, !tbaa !48
  %26 = load i8*, i8** %handle, align 8, !tbaa !48
  %tobool50 = icmp ne i8* %26, null
  br i1 %tobool50, label %if.end53, label %cleanup58

if.end53:                                         ; preds = %if.end47, %if.then28
  %27 = load i8*, i8** %handle, align 8, !tbaa !48
  %28 = load i32, i32* %port_num, align 4, !tbaa !90
  call void @usb_acpi_check_port_connect_type(%struct.usb_device* %15, i8* %27, i32 %28)
  br label %cleanup58

cleanup58:                                        ; preds = %if.end53, %if.end47, %if.else40, %if.then28, %if.else, %if.end, %sw.epilog
  %retval.1 = phi i32 [ -19, %sw.epilog ], [ 0, %if.end53 ], [ %., %if.end ], [ -19, %if.else40 ], [ -19, %if.end47 ], [ -19, %if.else ], [ -19, %if.then28 ]
  %29 = bitcast i32* %port_num to i8*
  ret i32 %retval.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_usb_device.907(%struct.device* %dev) #1 {
entry:
  %type = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 4
  %0 = load %struct.device_type*, %struct.device_type** %type, align 8, !tbaa !58
  %cmp = icmp eq %struct.device_type* %0, @usb_device_type
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare i8* @acpi_get_child(i8*, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @is_usb_port(%struct.device* %dev) #1 {
entry:
  %type = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 4
  %0 = load %struct.device_type*, %struct.device_type** %type, align 8, !tbaa !58
  %cmp = icmp eq %struct.device_type* %0, bitcast ({ i8*, %struct.attribute_group**, i32 (%struct.device.4311*, %struct.kobj_uevent_env*)*, i8* (%struct.device.4311*, i16*, i32*, i32*)*, void (%struct.device.4311*)*, %struct.dev_pm_ops.4310* }* @usb_port_device_type to %struct.device_type*)
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name.908(%struct.device* %dev) #1 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !341
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !341
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name.912(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_hcd* @bus_to_hcd.910(%struct.usb_bus* %bus) #1 {
entry:
  %0 = bitcast %struct.usb_bus* %bus to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.usb_hcd*
  ret %struct.usb_hcd* %1
}

; Function Attrs: nounwind uwtable
define internal void @usb_acpi_check_port_connect_type(%struct.usb_device* %hdev, i8* %handle, i32 %port1) #0 {
entry:
  %buffer = alloca %struct.kernel_symbol, align 8
  %pld = alloca %struct.acpi_pld_info*, align 8
  %0 = bitcast %struct.kernel_symbol* %buffer to i8*
  %1 = bitcast %struct.kernel_symbol* %buffer to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* bitcast (%struct.kernel_symbol* @usb_acpi_check_port_connect_type.buffer to i8*), i64 16, i32 8, i1 false)
  %2 = bitcast %struct.acpi_pld_info** %pld to i8*
  %call = call i32 @acpi_get_physical_device_location(i8* %handle, %struct.acpi_pld_info** %pld)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @acpi_evaluate_object(i8* %handle, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.8.911, i32 0, i32 0), %struct.acpi_object_list* null, %struct.kernel_symbol* %buffer)
  %pointer = getelementptr inbounds %struct.kernel_symbol, %struct.kernel_symbol* %buffer, i32 0, i32 1
  %3 = load i8*, i8** %pointer, align 8, !tbaa !798
  %4 = bitcast i8* %3 to %union.acpi_object*
  %tobool2 = icmp ne %union.acpi_object* %4, null
  br i1 %tobool2, label %lor.lhs.false, label %out

lor.lhs.false:                                    ; preds = %if.end
  %type = bitcast %union.acpi_object* %4 to i32*
  %5 = load i32, i32* %type, align 8, !tbaa !84
  %cmp = icmp ne i32 %5, 4
  br i1 %cmp, label %out, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %package = bitcast %union.acpi_object* %4 to %struct.anon.50.5205*
  %count = getelementptr inbounds %struct.anon.50.5205, %struct.anon.50.5205* %package, i32 0, i32 1
  %6 = load i32, i32* %count, align 4, !tbaa !84
  %cmp4 = icmp ne i32 %6, 4
  br i1 %cmp4, label %out, label %if.end6

if.end6:                                          ; preds = %lor.lhs.false3
  %package7 = bitcast %union.acpi_object* %4 to %struct.anon.50.5205*
  %elements = getelementptr inbounds %struct.anon.50.5205, %struct.anon.50.5205* %package7, i32 0, i32 2
  %7 = load %union.acpi_object*, %union.acpi_object** %elements, align 8, !tbaa !84
  %arrayidx = getelementptr inbounds %union.acpi_object, %union.acpi_object* %7, i64 0
  %integer = bitcast %union.acpi_object* %arrayidx to %struct.shrink_control*
  %value = getelementptr inbounds %struct.shrink_control, %struct.shrink_control* %integer, i32 0, i32 1
  %8 = load i64, i64* %value, align 8, !tbaa !84
  %tobool8 = icmp ne i64 %8, 0
  %9 = load %struct.acpi_pld_info*, %struct.acpi_pld_info** %pld, align 8, !tbaa !48
  %user_visible = getelementptr inbounds %struct.acpi_pld_info, %struct.acpi_pld_info* %9, i32 0, i32 5
  %10 = load i8, i8* %user_visible, align 4, !tbaa !800
  %tobool10 = icmp ne i8 %10, 0
  br i1 %tobool8, label %if.then9, label %if.else13

if.then9:                                         ; preds = %if.end6
  br i1 %tobool10, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.then9
  call void @usb_set_hub_port_connect_type(%struct.usb_device* %hdev, i32 %port1, i32 1)
  br label %out

if.else:                                          ; preds = %if.then9
  call void @usb_set_hub_port_connect_type(%struct.usb_device* %hdev, i32 %port1, i32 2)
  br label %out

if.else13:                                        ; preds = %if.end6
  br i1 %tobool10, label %out, label %if.then16

if.then16:                                        ; preds = %if.else13
  call void @usb_set_hub_port_connect_type(%struct.usb_device* %hdev, i32 %port1, i32 3)
  br label %out

out:                                              ; preds = %if.then16, %if.else13, %if.else, %if.then11, %lor.lhs.false3, %lor.lhs.false, %if.end
  %ret.0 = phi i32 [ -22, %lor.lhs.false3 ], [ -22, %lor.lhs.false ], [ -22, %if.end ], [ 0, %if.else13 ], [ 0, %if.then16 ], [ 0, %if.then11 ], [ 0, %if.else ]
  %11 = load %struct.acpi_pld_info*, %struct.acpi_pld_info** %pld, align 8, !tbaa !48
  %12 = bitcast %struct.acpi_pld_info* %11 to i8*
  call void @kfree(i8* %12)
  %13 = bitcast %union.acpi_object* %4 to i8*
  call void @kfree(i8* %13)
  br label %cleanup

cleanup:                                          ; preds = %out, %entry
  %retval.0 = phi i32 [ %ret.0, %out ], [ -19, %entry ]
  %14 = bitcast %struct.acpi_pld_info** %pld to i8*
  %15 = bitcast %struct.kernel_symbol* %buffer to i8*
  ret void
}

declare i32 @acpi_get_physical_device_location(i8*, %struct.acpi_pld_info**) #2

declare i32 @acpi_evaluate_object(i8*, i8*, %struct.acpi_object_list*, %struct.kernel_symbol*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name.912(%struct.kobject* %kobj) #1 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !343
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define void @usb_acpi_unregister() #0 {
entry:
  %call = call i32 @unregister_acpi_bus_type(%struct.acpi_bus_type* @usb_acpi_bus)
  ret void
}

declare i32 @unregister_acpi_bus_type(%struct.acpi_bus_type*) #2

declare void @simpll__inlineasm_0(i32*, i32, i32*)

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind }
attributes #4 = { nounwind readnone }
attributes #5 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { inlinehint nounwind readnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind readnone speculatable }
attributes #8 = { nounwind }
attributes #9 = { nounwind readonly }

!llvm.ident = !{!0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{!3, !7, i64 64}
!3 = !{!"usb_device", !4, i64 0, !5, i64 4, !4, i64 20, !5, i64 24, !5, i64 28, !7, i64 32, !4, i64 40, !5, i64 44, !7, i64 56, !7, i64 64, !8, i64 72, !13, i64 136, !33, i64 1272, !7, i64 1296, !7, i64 1304, !7, i64 1312, !5, i64 1320, !5, i64 1448, !7, i64 1576, !10, i64 1584, !5, i64 1586, !5, i64 1587, !4, i64 1588, !4, i64 1588, !4, i64 1588, !4, i64 1588, !4, i64 1588, !4, i64 1588, !4, i64 1588, !4, i64 1588, !4, i64 1589, !4, i64 1589, !4, i64 1592, !7, i64 1600, !7, i64 1608, !7, i64 1616, !12, i64 1624, !4, i64 1640, !4, i64 1644, !16, i64 1648, !20, i64 1656, !20, i64 1664, !4, i64 1672, !4, i64 1672, !4, i64 1672, !7, i64 1680, !4, i64 1688, !5, i64 1692, !34, i64 1696, !34, i64 1712, !4, i64 1728}
!4 = !{!"int", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!"any pointer", !5, i64 0}
!8 = !{!"usb_host_endpoint", !9, i64 0, !11, i64 9, !12, i64 16, !7, i64 32, !7, i64 40, !7, i64 48, !4, i64 56, !4, i64 60}
!9 = !{!"usb_endpoint_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !10, i64 4, !5, i64 6, !5, i64 7, !5, i64 8}
!10 = !{!"short", !5, i64 0}
!11 = !{!"usb_ss_ep_comp_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !10, i64 4}
!12 = !{!"list_head", !7, i64 0, !7, i64 8}
!13 = !{!"device", !7, i64 0, !7, i64 8, !14, i64 16, !7, i64 80, !7, i64 88, !17, i64 96, !7, i64 264, !7, i64 272, !7, i64 280, !21, i64 288, !7, i64 880, !4, i64 888, !7, i64 896, !29, i64 904, !7, i64 912, !12, i64 920, !7, i64 936, !30, i64 944, !7, i64 960, !31, i64 968, !4, i64 976, !4, i64 980, !18, i64 984, !12, i64 1056, !32, i64 1072, !7, i64 1104, !7, i64 1112, !7, i64 1120, !7, i64 1128}
!14 = !{!"kobject", !7, i64 0, !12, i64 8, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !15, i64 56, !4, i64 60, !4, i64 60, !4, i64 60, !4, i64 60, !4, i64 60}
!15 = !{!"kref", !16, i64 0}
!16 = !{!"", !4, i64 0}
!17 = !{!"mutex", !16, i64 0, !18, i64 8, !12, i64 80, !7, i64 96, !7, i64 104, !7, i64 112, !19, i64 120}
!18 = !{!"spinlock", !5, i64 0}
!19 = !{!"lockdep_map", !7, i64 0, !5, i64 8, !7, i64 24, !4, i64 32, !20, i64 40}
!20 = !{!"long", !5, i64 0}
!21 = !{!"dev_pm_info", !22, i64 0, !4, i64 4, !4, i64 4, !23, i64 4, !23, i64 4, !23, i64 4, !23, i64 4, !18, i64 8, !12, i64 80, !24, i64 96, !7, i64 192, !23, i64 200, !23, i64 200, !26, i64 208, !20, i64 336, !27, i64 344, !25, i64 424, !16, i64 512, !16, i64 516, !4, i64 520, !4, i64 520, !4, i64 520, !4, i64 520, !4, i64 520, !4, i64 520, !4, i64 521, !4, i64 521, !4, i64 521, !4, i64 521, !4, i64 521, !5, i64 524, !5, i64 528, !4, i64 532, !4, i64 536, !20, i64 544, !20, i64 552, !20, i64 560, !20, i64 568, !7, i64 576, !7, i64 584}
!22 = !{!"pm_message", !4, i64 0}
!23 = !{!"_Bool", !5, i64 0}
!24 = !{!"completion", !4, i64 0, !25, i64 8}
!25 = !{!"__wait_queue_head", !18, i64 0, !12, i64 72}
!26 = !{!"timer_list", !12, i64 0, !20, i64 16, !7, i64 24, !7, i64 32, !20, i64 40, !4, i64 48, !4, i64 52, !7, i64 56, !5, i64 64, !19, i64 80}
!27 = !{!"work_struct", !28, i64 0, !12, i64 8, !7, i64 24, !19, i64 32}
!28 = !{!"", !20, i64 0}
!29 = !{!"long long", !5, i64 0}
!30 = !{!"dev_archdata", !7, i64 0, !7, i64 8}
!31 = !{!"acpi_dev_node", !7, i64 0}
!32 = !{!"klist_node", !7, i64 0, !12, i64 8, !15, i64 24}
!33 = !{!"usb_device_descriptor", !5, i64 0, !5, i64 1, !10, i64 2, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7, !10, i64 8, !10, i64 10, !10, i64 12, !5, i64 14, !5, i64 15, !5, i64 16, !5, i64 17}
!34 = !{!"usb3_lpm_parameters", !4, i64 0, !4, i64 4, !4, i64 8, !4, i64 12}
!35 = !{!36, !4, i64 8}
!36 = !{!"usb_bus", !7, i64 0, !4, i64 8, !7, i64 16, !5, i64 24, !5, i64 25, !5, i64 26, !4, i64 27, !4, i64 27, !4, i64 27, !4, i64 28, !4, i64 32, !37, i64 40, !7, i64 56, !7, i64 64, !12, i64 72, !4, i64 88, !4, i64 92, !4, i64 96, !4, i64 100, !7, i64 104, !4, i64 112}
!37 = !{!"usb_devmap", !5, i64 0}
!38 = !{!3, !4, i64 0}
!39 = !{!3, !7, i64 1600}
!40 = !{!3, !7, i64 1608}
!41 = !{!3, !7, i64 1616}
!42 = !{!22, !4, i64 0}
!43 = !{!23, !23, i64 0}
!44 = !{i8 0, i8 2}
!45 = !{!46, !5, i64 0}
!46 = !{!"usb_descriptor_header", !5, i64 0, !5, i64 1}
!47 = !{!46, !5, i64 1}
!48 = !{!7, !7, i64 0}
!49 = !{!20, !20, i64 0}
!50 = !{!3, !5, i64 24}
!51 = !{!52, !5, i64 36}
!52 = !{!"usb_interface", !7, i64 0, !7, i64 8, !4, i64 16, !7, i64 24, !4, i64 32, !5, i64 36, !4, i64 40, !4, i64 40, !4, i64 40, !4, i64 40, !4, i64 40, !4, i64 40, !4, i64 40, !4, i64 40, !13, i64 48, !7, i64 1184, !16, i64 1192, !27, i64 1200}
!53 = !{!54, !4, i64 0}
!54 = !{!"find_interface_arg", !4, i64 0, !7, i64 8}
!55 = !{!54, !7, i64 8}
!56 = !{!13, !7, i64 272}
!57 = !{!52, !4, i64 32}
!58 = !{!13, !7, i64 88}
!59 = !{!52, !4, i64 16}
!60 = !{!52, !7, i64 0}
!61 = !{!62, !5, i64 3}
!62 = !{!"usb_host_interface", !63, i64 0, !4, i64 12, !7, i64 16, !7, i64 24, !7, i64 32}
!63 = !{!"usb_interface_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7, !5, i64 8}
!64 = !{!3, !7, i64 1312}
!65 = !{!66, !5, i64 4}
!66 = !{!"usb_host_config", !67, i64 0, !7, i64 16, !5, i64 24, !5, i64 152, !5, i64 408, !7, i64 664, !4, i64 672}
!67 = !{!"usb_config_descriptor", !5, i64 0, !5, i64 1, !10, i64 2, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7, !5, i64 8}
!68 = !{!62, !5, i64 2}
!69 = !{!70, !4, i64 0}
!70 = !{!"usb_interface_cache", !4, i64 0, !15, i64 4, !5, i64 8}
!71 = !{!72, !7, i64 384}
!72 = !{!"usb_hcd", !36, i64 0, !15, i64 120, !7, i64 128, !4, i64 136, !5, i64 140, !26, i64 168, !7, i64 296, !27, i64 304, !7, i64 384, !7, i64 392, !20, i64 400, !4, i64 408, !4, i64 408, !4, i64 408, !4, i64 408, !4, i64 408, !4, i64 408, !4, i64 408, !4, i64 412, !7, i64 416, !29, i64 424, !29, i64 432, !4, i64 440, !7, i64 448, !7, i64 456, !7, i64 464, !5, i64 472, !4, i64 504, !5, i64 512}
!73 = !{!74, !7, i64 208}
!74 = !{!"hc_driver", !7, i64 0, !7, i64 8, !20, i64 16, !7, i64 24, !4, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !7, i64 112, !7, i64 120, !7, i64 128, !7, i64 136, !7, i64 144, !7, i64 152, !7, i64 160, !7, i64 168, !7, i64 176, !7, i64 184, !7, i64 192, !7, i64 200, !7, i64 208, !7, i64 216, !7, i64 224, !7, i64 232, !7, i64 240, !7, i64 248, !7, i64 256, !7, i64 264, !7, i64 272, !7, i64 280, !7, i64 288, !7, i64 296, !7, i64 304, !7, i64 312, !7, i64 320, !7, i64 328}
!75 = !{!3, !7, i64 400}
!76 = !{!3, !7, i64 224}
!77 = !{!3, !7, i64 1248}
!78 = !{!36, !7, i64 0}
!79 = !{!13, !7, i64 896}
!80 = !{!3, !7, i64 1032}
!81 = !{!3, !4, i64 1728}
!82 = !{!3, !5, i64 72}
!83 = !{!3, !5, i64 73}
!84 = !{!5, !5, i64 0}
!85 = !{!3, !4, i64 20}
!86 = !{!3, !7, i64 136}
!87 = !{!3, !5, i64 1587}
!88 = !{!3, !5, i64 1586}
!89 = !{!3, !7, i64 56}
!90 = !{!4, !4, i64 0}
!91 = !{!3, !20, i64 1664}
!92 = !{!3, !20, i64 1656}
!93 = !{!13, !4, i64 888}
!94 = !{!16, !4, i64 0}
!95 = !{!12, !7, i64 0}
!96 = !{!12, !7, i64 8}
!97 = !{!3, !4, i64 1640}
!98 = !{!99, !7, i64 960}
!99 = !{!"usb_hub", !7, i64 0, !7, i64 8, !15, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !17, i64 48, !4, i64 216, !4, i64 220, !12, i64 224, !5, i64 240, !5, i64 248, !5, i64 256, !5, i64 264, !5, i64 272, !7, i64 280, !100, i64 288, !4, i64 472, !4, i64 476, !4, i64 476, !4, i64 476, !4, i64 476, !4, i64 476, !5, i64 477, !101, i64 512, !101, i64 736, !7, i64 960}
!100 = !{!"usb_tt", !7, i64 0, !4, i64 8, !4, i64 12, !18, i64 16, !12, i64 88, !27, i64 104}
!101 = !{!"delayed_work", !27, i64 0, !26, i64 80, !7, i64 208, !4, i64 216}
!102 = !{!103, !7, i64 0}
!103 = !{!"usb_port", !7, i64 0, !13, i64 8, !7, i64 1144, !5, i64 1152, !5, i64 1156, !4, i64 1157, !4, i64 1157}
!104 = !{!52, !7, i64 320}
!105 = !{!106, !7, i64 56}
!106 = !{!"usb_driver", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !107, i64 80, !108, i64 168, !4, i64 296, !4, i64 296, !4, i64 296, !4, i64 296}
!107 = !{!"usb_dynids", !18, i64 0, !12, i64 72}
!108 = !{!"usbdrv_wrap", !109, i64 0, !4, i64 120}
!109 = !{!"device_driver", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !23, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !7, i64 112}
!110 = !{!106, !7, i64 64}
!111 = !{i32 -2146598437}
!112 = !{!113, !4, i64 20}
!113 = !{!"task_struct", !20, i64 0, !7, i64 8, !16, i64 16, !4, i64 20, !4, i64 24, !114, i64 32, !4, i64 40, !4, i64 44, !4, i64 48, !4, i64 52, !4, i64 56, !4, i64 60, !7, i64 64, !115, i64 72, !120, i64 448, !7, i64 520, !121, i64 528, !5, i64 536, !4, i64 540, !4, i64 544, !4, i64 548, !122, i64 552, !123, i64 1064, !12, i64 1096, !124, i64 1112, !7, i64 1152, !7, i64 1160, !4, i64 1168, !4, i64 1172, !4, i64 1176, !4, i64 1180, !4, i64 1184, !4, i64 1188, !4, i64 1192, !4, i64 1196, !4, i64 1196, !4, i64 1196, !4, i64 1196, !4, i64 1196, !4, i64 1196, !4, i64 1200, !4, i64 1204, !20, i64 1208, !7, i64 1216, !7, i64 1224, !12, i64 1232, !12, i64 1248, !7, i64 1264, !12, i64 1272, !12, i64 1288, !5, i64 1304, !12, i64 1376, !7, i64 1392, !7, i64 1400, !7, i64 1408, !20, i64 1416, !20, i64 1424, !20, i64 1432, !20, i64 1440, !20, i64 1448, !125, i64 1456, !20, i64 1472, !20, i64 1480, !126, i64 1488, !126, i64 1504, !20, i64 1520, !20, i64 1528, !127, i64 1536, !5, i64 1560, !7, i64 1608, !7, i64 1616, !5, i64 1624, !4, i64 1640, !4, i64 1644, !128, i64 1648, !20, i64 1656, !129, i64 1664, !7, i64 1848, !7, i64 1856, !7, i64 1864, !7, i64 1872, !7, i64 1880, !131, i64 1888, !131, i64 1896, !131, i64 1904, !132, i64 1912, !20, i64 1936, !20, i64 1944, !7, i64 1952, !7, i64 1960, !7, i64 1968, !7, i64 1976, !7, i64 1984, !4, i64 1992, !4, i64 1996, !133, i64 2000, !4, i64 2016, !4, i64 2020, !18, i64 2024, !134, i64 2096, !136, i64 2168, !7, i64 2184, !7, i64 2192, !4, i64 2200, !20, i64 2208, !20, i64 2216, !4, i64 2224, !4, i64 2228, !4, i64 2232, !4, i64 2236, !20, i64 2240, !20, i64 2248, !4, i64 2256, !4, i64 2260, !4, i64 2264, !4, i64 2268, !29, i64 2272, !4, i64 2280, !4, i64 2284, !5, i64 2288, !4, i64 4976, !7, i64 4984, !7, i64 4992, !7, i64 5000, !7, i64 5008, !7, i64 5016, !7, i64 5024, !20, i64 5032, !7, i64 5040, !137, i64 5048, !29, i64 5104, !29, i64 5112, !20, i64 5120, !131, i64 5128, !138, i64 5256, !4, i64 5260, !4, i64 5264, !7, i64 5272, !12, i64 5280, !7, i64 5296, !7, i64 5304, !12, i64 5312, !7, i64 5328, !5, i64 5336, !17, i64 5352, !12, i64 5520, !7, i64 5536, !10, i64 5544, !10, i64 5546, !4, i64 5548, !4, i64 5552, !4, i64 5556, !29, i64 5560, !139, i64 5568, !139, i64 5584, !7, i64 5600, !140, i64 5608, !7, i64 5624, !4, i64 5632, !4, i64 5636, !4, i64 5640, !20, i64 5648, !4, i64 5656, !5, i64 5664, !20, i64 9504, !20, i64 9512, !4, i64 9520, !7, i64 9528, !29, i64 9536, !16, i64 9544, !16, i64 9548, !20, i64 9552, !20, i64 9560, !141, i64 9568, !4, i64 9600, !16, i64 9604, !7, i64 9608, !4, i64 9616, !4, i64 9620}
!114 = !{!"llist_node", !7, i64 0}
!115 = !{!"sched_entity", !116, i64 0, !117, i64 16, !12, i64 40, !4, i64 56, !29, i64 64, !29, i64 72, !29, i64 80, !29, i64 88, !29, i64 96, !118, i64 104, !7, i64 320, !7, i64 328, !7, i64 336, !119, i64 344}
!116 = !{!"load_weight", !20, i64 0, !20, i64 8}
!117 = !{!"rb_node", !20, i64 0, !7, i64 8, !7, i64 16}
!118 = !{!"sched_statistics", !29, i64 0, !29, i64 8, !29, i64 16, !29, i64 24, !29, i64 32, !29, i64 40, !29, i64 48, !29, i64 56, !29, i64 64, !29, i64 72, !29, i64 80, !29, i64 88, !29, i64 96, !29, i64 104, !29, i64 112, !29, i64 120, !29, i64 128, !29, i64 136, !29, i64 144, !29, i64 152, !29, i64 160, !29, i64 168, !29, i64 176, !29, i64 184, !29, i64 192, !29, i64 200, !29, i64 208}
!119 = !{!"sched_avg", !4, i64 0, !4, i64 4, !29, i64 8, !29, i64 16, !20, i64 24}
!120 = !{!"sched_rt_entity", !12, i64 0, !20, i64 16, !20, i64 24, !4, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64}
!121 = !{!"hlist_head", !7, i64 0}
!122 = !{!"cpumask", !5, i64 0}
!123 = !{!"sched_info", !20, i64 0, !29, i64 8, !29, i64 16, !29, i64 24}
!124 = !{!"plist_node", !4, i64 0, !12, i64 8, !12, i64 24}
!125 = !{!"cputime", !20, i64 0, !20, i64 8}
!126 = !{!"timespec", !20, i64 0, !20, i64 8}
!127 = !{!"task_cputime", !20, i64 0, !20, i64 8, !29, i64 16}
!128 = !{!"sysv_sem", !7, i64 0}
!129 = !{!"thread_struct", !5, i64 0, !20, i64 24, !20, i64 32, !20, i64 40, !10, i64 48, !10, i64 50, !10, i64 52, !10, i64 54, !20, i64 56, !20, i64 64, !5, i64 72, !20, i64 104, !20, i64 112, !20, i64 120, !20, i64 128, !20, i64 136, !130, i64 144, !7, i64 160, !20, i64 168, !4, i64 176}
!130 = !{!"fpu", !4, i64 0, !4, i64 4, !7, i64 8}
!131 = !{!"", !5, i64 0}
!132 = !{!"sigpending", !12, i64 0, !131, i64 16}
!133 = !{!"seccomp", !4, i64 0, !7, i64 8}
!134 = !{!"raw_spinlock", !135, i64 0, !4, i64 4, !4, i64 8, !7, i64 16, !19, i64 24}
!135 = !{!"arch_spinlock", !5, i64 0}
!136 = !{!"plist_head", !12, i64 0}
!137 = !{!"task_io_accounting", !29, i64 0, !29, i64 8, !29, i64 16, !29, i64 24, !29, i64 32, !29, i64 40, !29, i64 48}
!138 = !{!"seqcount", !4, i64 0}
!139 = !{!"callback_head", !7, i64 0, !7, i64 8}
!140 = !{!"page_frag", !7, i64 0, !4, i64 8, !4, i64 12}
!141 = !{!"memcg_batch_info", !4, i64 0, !7, i64 8, !20, i64 16, !20, i64 24}
!142 = !{i64 0, i64 1, !84, i64 1, i64 1, !84, i64 2, i64 2, !143, i64 4, i64 1, !84, i64 5, i64 1, !84, i64 6, i64 1, !84, i64 7, i64 1, !84, i64 8, i64 2, !143, i64 10, i64 2, !143, i64 12, i64 2, !143, i64 14, i64 1, !84, i64 15, i64 1, !84, i64 16, i64 1, !84, i64 17, i64 1, !84}
!143 = !{!10, !10, i64 0}
!144 = !{i32 -2146962968, i32 -2146962929, i32 -2146962908, i32 -2146962871, i32 -2146962848, i32 -2146962978}
!145 = !{i32 -2146962260, i32 -2146962221, i32 -2146962200, i32 -2146962163, i32 -2146962140, i32 -2146962270}
!146 = !{!72, !7, i64 448}
!147 = !{!66, !5, i64 5}
!148 = !{!52, !7, i64 8}
!149 = !{!63, !5, i64 3}
!150 = !{!63, !5, i64 2}
!151 = !{!72, !7, i64 56}
!152 = !{!99, !7, i64 8}
!153 = !{!3, !5, i64 28}
!154 = !{!36, !5, i64 26}
!155 = !{!3, !10, i64 76}
!156 = !{!3, !7, i64 32}
!157 = !{!3, !4, i64 40}
!158 = !{!99, !7, i64 288}
!159 = !{!74, !4, i64 32}
!160 = !{!33, !5, i64 7}
!161 = !{!33, !5, i64 1}
!162 = !{!3, !5, i64 1279}
!163 = !{!72, !7, i64 392}
!164 = !{!3, !10, i64 1274}
!165 = !{!74, !7, i64 296}
!166 = !{!3, !5, i64 1289}
!167 = !{!3, !7, i64 1304}
!168 = !{!66, !10, i64 2}
!169 = !{!3, !7, i64 1576}
!170 = !{!67, !5, i64 5}
!171 = !{!3, !5, i64 1288}
!172 = !{!66, !5, i64 7}
!173 = !{!99, !7, i64 0}
!174 = !{!99, !4, i64 216}
!175 = !{!3, !5, i64 1278}
!176 = !{!99, !7, i64 40}
!177 = !{!3, !7, i64 1296}
!178 = !{!179, !7, i64 16}
!179 = !{!"usb_host_bos", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24}
!180 = !{!181, !5, i64 3}
!181 = !{!"usb_ss_cap_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !10, i64 4, !5, i64 6, !5, i64 7, !10, i64 8}
!182 = !{!74, !7, i64 312}
!183 = !{!74, !7, i64 320}
!184 = !{!181, !5, i64 7}
!185 = !{!181, !10, i64 8}
!186 = !{!3, !4, i64 1704}
!187 = !{!3, !4, i64 1700}
!188 = !{!3, !4, i64 1720}
!189 = !{!3, !4, i64 1716}
!190 = !{!191, !5, i64 0}
!191 = !{!"usb_set_sel_req", !5, i64 0, !5, i64 1, !10, i64 2, !10, i64 4}
!192 = !{!191, !5, i64 1}
!193 = !{!191, !10, i64 2}
!194 = !{!191, !10, i64 4}
!195 = !{!74, !7, i64 272}
!196 = !{!197, !7, i64 208}
!197 = !{!"usb_phy", !7, i64 0, !7, i64 8, !4, i64 16, !5, i64 20, !5, i64 24, !5, i64 28, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !198, i64 64, !10, i64 144, !10, i64 146, !12, i64 152, !7, i64 168, !7, i64 176, !7, i64 184, !7, i64 192, !7, i64 200, !7, i64 208, !7, i64 216}
!198 = !{!"atomic_notifier_head", !18, i64 0, !7, i64 72}
!199 = !{!9, !10, i64 4}
!200 = !{!179, !7, i64 8}
!201 = !{!202, !4, i64 3}
!202 = !{!"usb_ext_cap_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !4, i64 3}
!203 = !{!34, !4, i64 0}
!204 = !{!99, !7, i64 280}
!205 = !{!34, !4, i64 4}
!206 = !{!34, !4, i64 8}
!207 = !{!74, !7, i64 288}
!208 = !{!3, !4, i64 1708}
!209 = !{!3, !4, i64 1724}
!210 = !{!211, !7, i64 72}
!211 = !{!"urb", !15, i64 0, !7, i64 8, !16, i64 16, !16, i64 20, !4, i64 24, !12, i64 32, !12, i64 48, !7, i64 64, !7, i64 72, !7, i64 80, !4, i64 88, !4, i64 92, !4, i64 96, !4, i64 100, !7, i64 104, !29, i64 112, !7, i64 120, !4, i64 128, !4, i64 132, !4, i64 136, !4, i64 140, !7, i64 144, !29, i64 152, !4, i64 160, !4, i64 164, !4, i64 168, !4, i64 172, !7, i64 176, !7, i64 184, !5, i64 192}
!212 = !{!211, !4, i64 88}
!213 = !{!100, !4, i64 8}
!214 = !{!215, !4, i64 16}
!215 = !{!"usb_tt_clear", !12, i64 0, !4, i64 16, !10, i64 20, !7, i64 24, !7, i64 32}
!216 = !{!215, !10, i64 20}
!217 = !{!215, !7, i64 24}
!218 = !{!211, !7, i64 80}
!219 = !{!215, !7, i64 32}
!220 = !{!103, !7, i64 1144}
!221 = !{!74, !7, i64 216}
!222 = !{!3, !4, i64 1112}
!223 = !{!3, !5, i64 1287}
!224 = !{!3, !5, i64 1286}
!225 = !{!226, !10, i64 3}
!226 = !{!"usb_hub_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !10, i64 3, !5, i64 5, !5, i64 6, !5, i64 7}
!227 = !{!3, !5, i64 1692}
!228 = !{!36, !7, i64 56}
!229 = !{!230, !5, i64 2}
!230 = !{!"usb_otg_descriptor", !5, i64 0, !5, i64 1, !5, i64 2}
!231 = !{!3, !10, i64 1280}
!232 = !{!3, !10, i64 1282}
!233 = !{!234, !10, i64 0}
!234 = !{!"usb_device_id", !10, i64 0, !10, i64 2, !10, i64 4, !10, i64 6, !10, i64 8, !5, i64 10, !5, i64 11, !5, i64 12, !5, i64 13, !5, i64 14, !5, i64 15, !5, i64 16, !20, i64 24}
!235 = !{!234, !10, i64 2}
!236 = !{!234, !10, i64 4}
!237 = !{!234, !10, i64 6}
!238 = !{!3, !10, i64 1284}
!239 = !{!234, !10, i64 8}
!240 = !{!234, !5, i64 10}
!241 = !{!3, !5, i64 1276}
!242 = !{!234, !5, i64 11}
!243 = !{!3, !5, i64 1277}
!244 = !{!234, !5, i64 12}
!245 = !{i32 -2146065229, i32 -2146065190, i32 -2146065169, i32 -2146065132, i32 -2146065109, i32 -2146065239}
!246 = !{!247, !4, i64 0}
!247 = !{!"__wait_queue", !4, i64 0, !7, i64 8, !7, i64 16, !12, i64 24}
!248 = !{!247, !7, i64 8}
!249 = !{!247, !7, i64 16}
!250 = !{!226, !5, i64 2}
!251 = !{!99, !4, i64 220}
!252 = !{!113, !7, i64 8}
!253 = !{i32 476920, i32 476931}
!254 = !{!99, !7, i64 24}
!255 = !{i32 -2146960581, i32 -2146960542, i32 -2146960521, i32 -2146960484, i32 -2146960461, i32 -2146960591, i32 474921}
!256 = !{!226, !5, i64 5}
!257 = !{!99, !4, i64 472}
!258 = !{!3, !10, i64 1584}
!259 = !{!3, !4, i64 1644}
!260 = !{!74, !7, i64 192}
!261 = !{!74, !7, i64 184}
!262 = !{i32 -2146065441, i32 -2146065402, i32 -2146065381, i32 -2146065344, i32 -2146065321, i32 -2146065451}
!263 = !{!197, !7, i64 216}
!264 = !{i32 -2143521157, i32 -2143521132, i32 -2143520862, i32 -2143521065, i32 -2143521034, i32 -2143521004}
!265 = !{!36, !4, i64 32}
!266 = !{!226, !5, i64 6}
!267 = !{!66, !5, i64 8}
!268 = !{i32 -2146062594, i32 -2146062555, i32 -2146062534, i32 -2146062497, i32 -2146062474, i32 -2146062465}
!269 = !{!62, !5, i64 6}
!270 = !{!62, !5, i64 4}
!271 = !{!62, !7, i64 24}
!272 = !{!28, !20, i64 0}
!273 = !{i64 0, i64 8, !49}
!274 = !{!27, !7, i64 24}
!275 = !{!26, !7, i64 32}
!276 = !{!26, !20, i64 40}
!277 = !{!234, !20, i64 24}
!278 = !{!99, !7, i64 32}
!279 = !{!280, !5, i64 0}
!280 = !{!"usbdevfs_hub_portinfo", !5, i64 0, !5, i64 1}
!281 = !{!74, !7, i64 280}
!282 = !{!52, !7, i64 48}
!283 = !{!99, !4, i64 296}
!284 = !{!99, !4, i64 300}
!285 = !{!72, !4, i64 440}
!286 = !{!9, !5, i64 2}
!287 = !{!9, !5, i64 6}
!288 = !{!99, !7, i64 376}
!289 = !{!74, !7, i64 200}
!290 = !{!211, !7, i64 176}
!291 = !{!211, !4, i64 96}
!292 = !{!211, !4, i64 140}
!293 = !{!211, !7, i64 104}
!294 = !{!211, !4, i64 136}
!295 = !{!211, !7, i64 184}
!296 = !{!211, !4, i64 168}
!297 = !{!211, !4, i64 160}
!298 = !{!103, !5, i64 1152}
!299 = !{!9, !5, i64 3}
!300 = !{!13, !7, i64 968}
!301 = !{i32 -2143269028}
!302 = !{i32 -2143270248}
!303 = !{!74, !7, i64 80}
!304 = !{i32 -2146977224, i32 -2146977185, i32 -2146977164, i32 -2146977127, i32 -2146977104, i32 -2146977234}
!305 = !{!72, !4, i64 504}
!306 = !{!72, !7, i64 0}
!307 = !{!74, !7, i64 72}
!308 = !{!72, !4, i64 412}
!309 = !{!72, !7, i64 464}
!310 = !{i32 -2146977932, i32 -2146977893, i32 -2146977872, i32 -2146977835, i32 -2146977812, i32 -2146977942}
!311 = !{!72, !4, i64 136}
!312 = !{!74, !7, i64 40}
!313 = !{!74, !7, i64 48}
!314 = !{!72, !20, i64 400}
!315 = !{!74, !7, i64 24}
!316 = !{!74, !7, i64 0}
!317 = !{!72, !4, i64 8}
!318 = !{!72, !29, i64 424}
!319 = !{!72, !7, i64 296}
!320 = !{!74, !7, i64 144}
!321 = !{!211, !7, i64 8}
!322 = !{!211, !4, i64 24}
!323 = !{!211, !4, i64 100}
!324 = !{!74, !7, i64 120}
!325 = !{!36, !4, i64 112}
!326 = !{!327, !7, i64 16}
!327 = !{!"usb_mon_operations", !7, i64 0, !7, i64 8, !7, i64 16}
!328 = !{i32 -2146141447, i32 -2146141408, i32 -2146141387, i32 -2146141350, i32 -2146141327, i32 -2146141457}
!329 = !{!211, !7, i64 120}
!330 = !{!211, !4, i64 132}
!331 = !{!211, !29, i64 112}
!332 = !{!211, !29, i64 152}
!333 = !{i32 -2144347526, i32 -2144347501, i32 -2144347231, i32 -2144347434, i32 -2144347403, i32 -2144347373}
!334 = !{!335, !7, i64 56}
!335 = !{!"dma_map_ops", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !7, i64 112, !4, i64 120}
!336 = !{i32 -2144346279, i32 -2144346254, i32 -2144345984, i32 -2144346187, i32 -2144346156, i32 -2144346126}
!337 = !{!335, !7, i64 40}
!338 = !{i32 -2144348817, i32 -2144348792, i32 -2144348522, i32 -2144348725, i32 -2144348694, i32 -2144348664}
!339 = !{!29, !29, i64 0}
!340 = !{!13, !7, i64 944}
!341 = !{!13, !7, i64 80}
!342 = !{!72, !7, i64 456}
!343 = !{!14, !7, i64 0}
!344 = !{!345, !7, i64 8}
!345 = !{!"pv_irq_ops", !346, i64 0, !346, i64 8, !346, i64 16, !346, i64 24, !7, i64 32, !7, i64 40, !7, i64 48}
!346 = !{!"paravirt_callee_save", !7, i64 0}
!347 = !{i32 -2146209028, i32 -2146209003, i32 -2146208733, i32 -2146208936, i32 -2146208905, i32 -2146208875}
!348 = !{i32 -2146209492, i32 -2146208481, i32 -2146208459, i32 -2146208446, i32 -2146208123, i32 -2146208056, i32 -2146208354, i32 -2146208327, i32 -2146208299, i32 -2146208269}
!349 = !{!345, !7, i64 0}
!350 = !{i32 -2146212605, i32 -2146212580, i32 -2146212310, i32 -2146212513, i32 -2146212482, i32 -2146212452}
!351 = !{i32 -2146213025, i32 -2146211047, i32 -2146211025, i32 -2146211012, i32 -2146210689, i32 -2146210622, i32 -2146210920, i32 -2146210893, i32 -2146210865, i32 -2146210835}
!352 = !{!345, !7, i64 16}
!353 = !{i32 -2146206477, i32 -2146206452, i32 -2146206182, i32 -2146206385, i32 -2146206354, i32 -2146206324}
!354 = !{i32 -2146206925, i32 -2146205930, i32 -2146205908, i32 -2146205895, i32 -2146205572, i32 -2146205505, i32 -2146205803, i32 -2146205776, i32 -2146205748, i32 -2146205718}
!355 = !{i32 -2146141871, i32 -2146141832, i32 -2146141811, i32 -2146141774, i32 -2146141751, i32 -2146141881}
!356 = !{i32 -2146139024, i32 -2146138985, i32 -2146138964, i32 -2146138927, i32 -2146138904, i32 -2146138895}
!357 = !{!74, !20, i64 16}
!358 = !{!72, !7, i64 16}
!359 = !{!72, !5, i64 24}
!360 = !{!72, !7, i64 200}
!361 = !{!72, !20, i64 208}
!362 = !{!74, !7, i64 8}
!363 = !{!72, !7, i64 128}
!364 = !{!36, !4, i64 88}
!365 = !{!36, !4, i64 92}
!366 = !{!36, !4, i64 96}
!367 = !{!74, !7, i64 176}
!368 = !{!74, !7, i64 232}
!369 = !{!74, !7, i64 224}
!370 = !{!72, !5, i64 25}
!371 = !{!211, !7, i64 144}
!372 = !{!211, !4, i64 128}
!373 = !{!374, !4, i64 16}
!374 = !{!"scatterlist", !20, i64 0, !20, i64 8, !4, i64 16, !4, i64 20, !29, i64 24, !4, i64 32}
!375 = !{i32 -2144350167, i32 -2144350142, i32 -2144349872, i32 -2144350075, i32 -2144350044, i32 -2144350014}
!376 = !{!335, !7, i64 32}
!377 = !{!335, !7, i64 96}
!378 = !{!374, !4, i64 20}
!379 = !{i32 -2144348128, i32 -2144348103, i32 -2144347833, i32 -2144348036, i32 -2144348005, i32 -2144347975}
!380 = !{!335, !7, i64 48}
!381 = !{!374, !20, i64 0}
!382 = !{i32 -2144386590, i32 -2144386565, i32 -2144386295, i32 -2144386498, i32 -2144386467, i32 -2144386437}
!383 = !{!374, !20, i64 8}
!384 = !{i32 -2144386027, i32 -2144386002, i32 -2144385732, i32 -2144385935, i32 -2144385904, i32 -2144385874}
!385 = !{i32 -2144346893, i32 -2144346868, i32 -2144346598, i32 -2144346801, i32 -2144346770, i32 -2144346740}
!386 = !{!8, !4, i64 60}
!387 = !{!36, !4, i64 100}
!388 = !{i32 -2146136521, i32 -2146136482, i32 -2146136461, i32 -2146136424, i32 -2146136401, i32 -2146136392}
!389 = !{i32 -2146141659, i32 -2146141620, i32 -2146141599, i32 -2146141562, i32 -2146141539, i32 -2146141669}
!390 = !{!74, !7, i64 96}
!391 = !{!327, !7, i64 0}
!392 = !{!74, !7, i64 112}
!393 = !{!327, !7, i64 8}
!394 = !{!395, !5, i64 0}
!395 = !{!"usb_ctrlrequest", !5, i64 0, !5, i64 1, !10, i64 2, !10, i64 4, !10, i64 6}
!396 = !{!395, !5, i64 1}
!397 = !{!395, !10, i64 2}
!398 = !{!395, !10, i64 4}
!399 = !{!395, !10, i64 6}
!400 = !{!74, !7, i64 152}
!401 = !{!67, !5, i64 7}
!402 = !{!33, !5, i64 6}
!403 = !{!13, !7, i64 480}
!404 = !{!74, !7, i64 104}
!405 = !{!8, !7, i64 24}
!406 = !{!74, !7, i64 256}
!407 = !{!74, !7, i64 248}
!408 = !{!74, !7, i64 240}
!409 = !{!74, !7, i64 264}
!410 = !{!74, !7, i64 128}
!411 = !{!74, !7, i64 136}
!412 = !{!74, !7, i64 88}
!413 = !{!74, !7, i64 160}
!414 = !{!74, !7, i64 168}
!415 = !{!74, !7, i64 328}
!416 = !{!417, !7, i64 8}
!417 = !{!"usb_anchor", !12, i64 0, !25, i64 16, !18, i64 104, !4, i64 176}
!418 = !{!211, !7, i64 64}
!419 = !{i32 -2146192713, i32 -2146192674, i32 -2146192653, i32 -2146192616, i32 -2146192593, i32 -2146192723}
!420 = !{!417, !7, i64 0}
!421 = !{i32 -2146189866, i32 -2146189827, i32 -2146189806, i32 -2146189769, i32 -2146189746, i32 -2146189737}
!422 = !{i32 -2146732510}
!423 = !{i32 -2146192289, i32 -2146192250, i32 -2146192229, i32 -2146192192, i32 -2146192169, i32 -2146192299}
!424 = !{i32 -2146192501, i32 -2146192462, i32 -2146192441, i32 -2146192404, i32 -2146192381, i32 -2146192511}
!425 = !{!8, !5, i64 11}
!426 = !{!8, !5, i64 12}
!427 = !{!211, !4, i64 164}
!428 = !{!429, !4, i64 4}
!429 = !{!"usb_iso_packet_descriptor", !4, i64 0, !4, i64 4, !4, i64 8, !4, i64 12}
!430 = !{!429, !4, i64 12}
!431 = !{!429, !4, i64 8}
!432 = !{i32 414367}
!433 = !{!62, !5, i64 5}
!434 = !{!62, !5, i64 7}
!435 = !{i32 -2146099982, i32 -2146099943, i32 -2146099922, i32 -2146099885, i32 -2146099862, i32 -2146099992}
!436 = !{!437, !7, i64 0}
!437 = !{!"set_config_request", !7, i64 0, !4, i64 8, !27, i64 16, !12, i64 96}
!438 = !{!437, !4, i64 8}
!439 = !{!52, !7, i64 24}
!440 = !{!52, !7, i64 312}
!441 = !{!52, !7, i64 136}
!442 = !{!52, !7, i64 1160}
!443 = !{!52, !7, i64 944}
!444 = !{!66, !7, i64 16}
!445 = !{!66, !5, i64 6}
!446 = !{!447, !5, i64 3}
!447 = !{!"usb_interface_assoc_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7}
!448 = !{!447, !5, i64 2}
!449 = !{!8, !5, i64 2}
!450 = !{!3, !4, i64 1592}
!451 = !{!452, !4, i64 96}
!452 = !{!"api_context", !24, i64 0, !4, i64 96}
!453 = !{i32 -2146636416}
!454 = !{!24, !4, i64 0}
!455 = !{i32 -2146097135, i32 -2146097096, i32 -2146097075, i32 -2146097038, i32 -2146097015, i32 -2146097006}
!456 = !{!457, !4, i64 0}
!457 = !{!"usb_sg_request", !4, i64 0, !20, i64 8, !18, i64 16, !7, i64 88, !4, i64 96, !4, i64 100, !7, i64 104, !4, i64 112, !24, i64 120}
!458 = !{!457, !4, i64 100}
!459 = !{!457, !7, i64 104}
!460 = !{!457, !7, i64 88}
!461 = !{!457, !4, i64 112}
!462 = !{i32 720698}
!463 = !{!457, !4, i64 96}
!464 = !{!36, !4, i64 28}
!465 = !{!457, !20, i64 8}
!466 = !{i32 -2144582540, i32 -2144582515, i32 -2144582245, i32 -2144582448, i32 -2144582417, i32 -2144582387}
!467 = !{i32 -2144581977, i32 -2144581952, i32 -2144581682, i32 -2144581885, i32 -2144581854, i32 -2144581824}
!468 = !{!8, !5, i64 3}
!469 = !{!8, !5, i64 6}
!470 = !{!106, !7, i64 72}
!471 = !{!108, !4, i64 120}
!472 = !{!234, !5, i64 13}
!473 = !{!234, !5, i64 14}
!474 = !{!234, !5, i64 15}
!475 = !{!234, !5, i64 16}
!476 = !{i32 -2146150360, i32 -2146150321, i32 -2146150300, i32 -2146150263, i32 -2146150240, i32 -2146150370}
!477 = !{i32 -2146145222, i32 -2146145183, i32 -2146145162, i32 -2146145125, i32 -2146145102, i32 -2146145093}
!478 = !{i32 -2146150148, i32 -2146150109, i32 -2146150088, i32 -2146150051, i32 -2146150028, i32 -2146150158}
!479 = !{!106, !7, i64 8}
!480 = !{!481, !7, i64 0}
!481 = !{!"usb_dynid", !12, i64 0, !234, i64 16}
!482 = !{!481, !10, i64 18}
!483 = !{!481, !10, i64 20}
!484 = !{!481, !10, i64 16}
!485 = !{!481, !5, i64 29}
!486 = !{!106, !4, i64 288}
!487 = !{!106, !7, i64 0}
!488 = !{!106, !7, i64 168}
!489 = !{!106, !7, i64 176}
!490 = !{!106, !7, i64 224}
!491 = !{!106, !7, i64 232}
!492 = !{!106, !7, i64 184}
!493 = !{!106, !7, i64 192}
!494 = !{!106, !7, i64 16}
!495 = !{!496, !4, i64 160}
!496 = !{!"usb_device_driver", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !108, i64 40, !4, i64 168}
!497 = !{!496, !7, i64 0}
!498 = !{!496, !7, i64 40}
!499 = !{!496, !7, i64 48}
!500 = !{!496, !7, i64 96}
!501 = !{!496, !7, i64 104}
!502 = !{!496, !7, i64 56}
!503 = !{!496, !7, i64 8}
!504 = !{!496, !7, i64 16}
!505 = !{!106, !7, i64 32}
!506 = !{!106, !7, i64 40}
!507 = !{!3, !7, i64 408}
!508 = !{!496, !7, i64 24}
!509 = !{!106, !7, i64 48}
!510 = !{!36, !7, i64 64}
!511 = !{!496, !7, i64 32}
!512 = !{!74, !7, i64 304}
!513 = !{!62, !7, i64 32}
!514 = !{i32 -2146125013, i32 -2146124974, i32 -2146124953, i32 -2146124916, i32 -2146124893, i32 -2146125023}
!515 = !{!67, !10, i64 2}
!516 = !{!66, !5, i64 1}
!517 = !{!66, !5, i64 0}
!518 = !{!63, !5, i64 0}
!519 = !{!66, !7, i64 664}
!520 = !{!66, !4, i64 672}
!521 = !{!62, !7, i64 16}
!522 = !{!62, !4, i64 12}
!523 = !{!9, !5, i64 0}
!524 = !{!8, !10, i64 4}
!525 = !{!8, !7, i64 48}
!526 = !{!8, !4, i64 56}
!527 = !{i32 529953}
!528 = !{!11, !5, i64 1}
!529 = !{!8, !5, i64 9}
!530 = !{!8, !5, i64 10}
!531 = !{!8, !10, i64 13}
!532 = !{!11, !5, i64 2}
!533 = !{!11, !5, i64 3}
!534 = !{!11, !10, i64 4}
!535 = !{!179, !7, i64 0}
!536 = !{!537, !5, i64 0}
!537 = !{!"usb_bos_descriptor", !5, i64 0, !5, i64 1, !10, i64 2, !5, i64 4}
!538 = !{!537, !10, i64 2}
!539 = !{!537, !5, i64 4}
!540 = !{!541, !5, i64 0}
!541 = !{!"usb_dev_cap_header", !5, i64 0, !5, i64 1, !5, i64 2}
!542 = !{!541, !5, i64 1}
!543 = !{!541, !5, i64 2}
!544 = !{!179, !7, i64 24}
!545 = !{!546, !7, i64 8}
!546 = !{!"usb_class", !15, i64 0, !7, i64 8}
!547 = !{!52, !7, i64 1184}
!548 = !{i32 -2146217035, i32 -2146216996, i32 -2146216975, i32 -2146216938, i32 -2146216915, i32 -2146217045}
!549 = !{!550, !7, i64 16}
!550 = !{!"usb_class_driver", !7, i64 0, !7, i64 8, !7, i64 16, !4, i64 24}
!551 = !{!550, !7, i64 0}
!552 = !{!553, !7, i64 56}
!553 = !{!"class", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !7, i64 112, !7, i64 120}
!554 = !{!550, !7, i64 8}
!555 = !{i32 -2146214188, i32 -2146214149, i32 -2146214128, i32 -2146214091, i32 -2146214068, i32 -2146214059}
!556 = !{!557, !7, i64 0}
!557 = !{!"file_operations", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !7, i64 112, !7, i64 120, !7, i64 128, !7, i64 136, !7, i64 144, !7, i64 152, !7, i64 160, !7, i64 168, !7, i64 176, !7, i64 184, !7, i64 192, !7, i64 200, !7, i64 208}
!558 = !{!559, !7, i64 40}
!559 = !{!"file", !5, i64 0, !560, i64 16, !7, i64 32, !7, i64 40, !18, i64 48, !4, i64 120, !28, i64 128, !4, i64 136, !4, i64 140, !29, i64 144, !561, i64 152, !7, i64 248, !563, i64 256, !29, i64 288, !7, i64 296, !7, i64 304, !12, i64 312, !12, i64 328, !7, i64 344, !20, i64 352}
!560 = !{!"path", !7, i64 0, !7, i64 8}
!561 = !{!"fown_struct", !562, i64 0, !7, i64 72, !5, i64 80, !4, i64 84, !4, i64 88, !4, i64 92}
!562 = !{!"", !5, i64 0, !4, i64 8, !4, i64 12, !7, i64 16, !19, i64 24}
!563 = !{!"file_ra_state", !20, i64 0, !4, i64 8, !4, i64 12, !4, i64 16, !4, i64 20, !29, i64 24}
!564 = !{!557, !7, i64 88}
!565 = !{!566, !4, i64 76}
!566 = !{!"inode", !10, i64 0, !10, i64 2, !4, i64 4, !4, i64 8, !4, i64 12, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !20, i64 64, !5, i64 72, !4, i64 76, !29, i64 80, !126, i64 88, !126, i64 104, !126, i64 120, !18, i64 136, !10, i64 208, !4, i64 212, !20, i64 216, !20, i64 224, !17, i64 232, !20, i64 400, !567, i64 408, !12, i64 424, !12, i64 440, !12, i64 456, !5, i64 472, !29, i64 488, !16, i64 496, !16, i64 500, !16, i64 504, !7, i64 512, !7, i64 520, !568, i64 528, !5, i64 960, !12, i64 976, !5, i64 992, !4, i64 1000, !4, i64 1004, !121, i64 1008, !16, i64 1016, !7, i64 1024}
!567 = !{!"hlist_node", !7, i64 0, !7, i64 8}
!568 = !{!"address_space", !7, i64 0, !569, i64 8, !18, i64 24, !4, i64 96, !570, i64 104, !12, i64 112, !17, i64 128, !20, i64 296, !20, i64 304, !7, i64 312, !20, i64 320, !7, i64 328, !18, i64 336, !12, i64 408, !7, i64 424}
!569 = !{!"radix_tree_root", !4, i64 0, !4, i64 4, !7, i64 8}
!570 = !{!"rb_root", !7, i64 0}
!571 = !{!335, !7, i64 0}
!572 = !{!13, !29, i64 904}
!573 = !{!335, !7, i64 8}
!574 = !{i32 -2146290840, i32 -2146290815, i32 -2146290545, i32 -2146290748, i32 -2146290717, i32 -2146290687}
!575 = !{i32 -2146291260, i32 -2146289282, i32 -2146289260, i32 -2146289247, i32 -2146288924, i32 -2146288857, i32 -2146289155, i32 -2146289128, i32 -2146289100, i32 -2146289070}
!576 = !{!577, !10, i64 8}
!577 = !{!"attribute", !7, i64 0, !10, i64 8, !23, i64 10, !7, i64 16, !578, i64 24}
!578 = !{!"lock_class_key", !5, i64 0}
!579 = !{!62, !5, i64 8}
!580 = !{i32 -2143934645}
!581 = !{!582, !7, i64 0}
!582 = !{!"ep_device", !7, i64 0, !7, i64 8, !13, i64 16}
!583 = !{!582, !7, i64 8}
!584 = !{!582, !7, i64 1128}
!585 = !{!582, !7, i64 104}
!586 = !{!582, !7, i64 16}
!587 = !{!8, !7, i64 40}
!588 = !{i32 -2146884388, i32 -2146884349, i32 -2146884328, i32 -2146884291, i32 -2146884268, i32 -2146884398}
!589 = !{!590, !4, i64 44}
!590 = !{!"async", !12, i64 0, !7, i64 16, !7, i64 24, !7, i64 32, !4, i64 40, !4, i64 44, !7, i64 48, !7, i64 56, !7, i64 64, !4, i64 72, !4, i64 76, !4, i64 80, !5, i64 84, !5, i64 85}
!591 = !{!590, !7, i64 64}
!592 = !{!559, !29, i64 144}
!593 = !{!559, !7, i64 304}
!594 = !{!595, !7, i64 16}
!595 = !{!"dev_state", !12, i64 0, !7, i64 16, !7, i64 24, !18, i64 32, !12, i64 104, !12, i64 120, !25, i64 136, !4, i64 224, !7, i64 232, !7, i64 240, !7, i64 248, !20, i64 256, !4, i64 264, !4, i64 268}
!596 = !{!559, !4, i64 140}
!597 = !{!595, !7, i64 24}
!598 = !{!595, !4, i64 224}
!599 = !{i32 -2146626176}
!600 = !{!595, !7, i64 232}
!601 = !{!113, !7, i64 1616}
!602 = !{!595, !7, i64 240}
!603 = !{!595, !7, i64 248}
!604 = !{!595, !20, i64 256}
!605 = !{i32 -2143228482}
!606 = !{i32 554792, i32 554803}
!607 = !{!595, !7, i64 120}
!608 = !{!590, !7, i64 24}
!609 = !{!590, !7, i64 32}
!610 = !{!590, !4, i64 72}
!611 = !{i32 -2143589224, i32 -2143589199, i32 -2143588929, i32 -2143589132, i32 -2143589101, i32 -2143589071}
!612 = !{i32 -2143588661, i32 -2143588636, i32 -2143588366, i32 -2143588569, i32 -2143588538, i32 -2143588508}
!613 = !{i32 -2146084129, i32 -2146084090, i32 -2146084069, i32 -2146084032, i32 -2146084009, i32 -2146084139}
!614 = !{i32 -2146882709, i32 -2146882670, i32 -2146882649, i32 -2146882612, i32 -2146882589, i32 -2146882719, i32 552793}
!615 = !{!616, !7, i64 16}
!616 = !{!"pid_link", !567, i64 0, !7, i64 16}
!617 = !{!113, !4, i64 1200}
!618 = !{i32 -2146084553, i32 -2146084514, i32 -2146084493, i32 -2146084456, i32 -2146084433, i32 -2146084563}
!619 = !{!13, !4, i64 976}
!620 = !{i64 0, i64 8, !49, i64 8, i64 8, !49}
!621 = !{!559, !7, i64 32}
!622 = !{!623, !5, i64 0}
!623 = !{!"usbdevfs_ctrltransfer", !5, i64 0, !5, i64 1, !10, i64 2, !10, i64 4, !10, i64 6, !4, i64 8, !7, i64 16}
!624 = !{!623, !5, i64 1}
!625 = !{!623, !10, i64 4}
!626 = !{!623, !10, i64 6}
!627 = !{!623, !4, i64 8}
!628 = !{!623, !7, i64 16}
!629 = !{!630, !20, i64 32}
!630 = !{!"thread_info", !7, i64 0, !7, i64 8, !4, i64 16, !4, i64 20, !4, i64 24, !4, i64 28, !28, i64 32, !631, i64 40, !7, i64 88, !4, i64 96, !4, i64 96}
!631 = !{!"restart_block", !7, i64 0, !5, i64 8}
!632 = !{i32 -2143226355}
!633 = !{!623, !10, i64 2}
!634 = !{!635, !4, i64 0}
!635 = !{!"usbdevfs_bulktransfer", !4, i64 0, !4, i64 4, !4, i64 8, !7, i64 16}
!636 = !{!635, !4, i64 4}
!637 = !{!635, !4, i64 8}
!638 = !{!635, !7, i64 16}
!639 = !{i32 -2143223984}
!640 = !{i32 -2143223396}
!641 = !{i32 -2143222801}
!642 = !{!643, !4, i64 0}
!643 = !{!"usbdevfs_getdriver", !4, i64 0, !5, i64 4}
!644 = !{!109, !7, i64 0}
!645 = !{!646, !4, i64 0}
!646 = !{!"usbdevfs_connectinfo", !4, i64 0, !5, i64 4}
!647 = !{!646, !5, i64 4}
!648 = !{!649, !4, i64 0}
!649 = !{!"usbdevfs_setinterface", !4, i64 0, !4, i64 4}
!650 = !{!649, !4, i64 4}
!651 = !{i32 -2143222026}
!652 = !{i32 -2143204316}
!653 = !{i32 -2143202742}
!654 = !{i32 -2143202288}
!655 = !{i32 -2143200984}
!656 = !{i32 -2143200333}
!657 = !{i32 -2143199011}
!658 = !{i32 -2143198353}
!659 = !{i32 -2143196959}
!660 = !{i32 -2143196273}
!661 = !{i32 -2143194701}
!662 = !{!663, !4, i64 0}
!663 = !{!"usbdevfs_disconnectsignal32", !4, i64 0, !4, i64 4}
!664 = !{!663, !4, i64 4}
!665 = !{i32 -2142969102}
!666 = !{i32 -2142959022, i32 -2142959015, i32 -2142959001, i32 -2142958999, i32 -2142959672, i32 -2142958959, i32 -2142958911, i32 -2142958845, i32 -2142958783, i32 -2142958731, i32 -2142959592, i32 -2142959567, i32 -2142958526, i32 -2142959494, i32 -2142959469, i32 -2142958266, i32 -2142958342, i32 -2142958249, i32 -2142958298, i32 -2142960192, i32 -2142960151, i32 -2142957483, i32 -2142957469, i32 -2142957467, i32 -2142958140, i32 -2142957427, i32 -2142957379, i32 -2142957313, i32 -2142957251, i32 -2142957199, i32 -2142958060, i32 -2142958035, i32 -2142956994, i32 -2142957962, i32 -2142957937, i32 -2142956734, i32 -2142956810, i32 -2142956717, i32 -2142956766, i32 -2142960119, i32 -2142960080, i32 -2142960051, i32 -2142960005, i32 -2142959980, i32 -2142956700, i32 -2142956656, i32 -2142956633, i32 -2142956600, i32 -2142956569}
!667 = !{!668, !4, i64 0}
!668 = !{!"usbdevfs_ioctl", !4, i64 0, !4, i64 4, !7, i64 8}
!669 = !{i32 -2142942682, i32 -2142942675, i32 -2142942661, i32 -2142942659, i32 -2142943332, i32 -2142942619, i32 -2142942571, i32 -2142942505, i32 -2142942443, i32 -2142942391, i32 -2142943252, i32 -2142943227, i32 -2142942186, i32 -2142943154, i32 -2142943129, i32 -2142941926, i32 -2142942002, i32 -2142941909, i32 -2142941958, i32 -2142943858, i32 -2142943817, i32 -2142941143, i32 -2142941129, i32 -2142941127, i32 -2142941800, i32 -2142941087, i32 -2142941039, i32 -2142940973, i32 -2142940911, i32 -2142940859, i32 -2142941720, i32 -2142941695, i32 -2142940654, i32 -2142941622, i32 -2142941597, i32 -2142940394, i32 -2142940470, i32 -2142940377, i32 -2142940426, i32 -2142943785, i32 -2142943746, i32 -2142943717, i32 -2142943671, i32 -2142943646, i32 -2142940360, i32 -2142940316, i32 -2142940293, i32 -2142940260, i32 -2142940229}
!670 = !{!668, !4, i64 4}
!671 = !{i32 -2142926434, i32 -2142926427, i32 -2142926413, i32 -2142926411, i32 -2142927084, i32 -2142926371, i32 -2142926323, i32 -2142926257, i32 -2142926195, i32 -2142926143, i32 -2142927004, i32 -2142926979, i32 -2142925938, i32 -2142926906, i32 -2142926881, i32 -2142925678, i32 -2142925754, i32 -2142925661, i32 -2142925710, i32 -2142927604, i32 -2142927563, i32 -2142924895, i32 -2142924881, i32 -2142924879, i32 -2142925552, i32 -2142924839, i32 -2142924791, i32 -2142924725, i32 -2142924663, i32 -2142924611, i32 -2142925472, i32 -2142925447, i32 -2142924406, i32 -2142925374, i32 -2142925349, i32 -2142924146, i32 -2142924222, i32 -2142924129, i32 -2142924178, i32 -2142927531, i32 -2142927492, i32 -2142927463, i32 -2142927417, i32 -2142927392, i32 -2142924112, i32 -2142924068, i32 -2142924045, i32 -2142924012, i32 -2142923981}
!672 = !{!668, !7, i64 8}
!673 = !{!674, !4, i64 0}
!674 = !{!"usbdevfs_disconnectsignal", !4, i64 0, !7, i64 8}
!675 = !{!674, !7, i64 8}
!676 = !{i32 -2142973936}
!677 = !{i32 -2142973338}
!678 = !{i32 -2142919892}
!679 = !{i32 -2142918973}
!680 = !{i32 -2142917391}
!681 = !{!682, !4, i64 0}
!682 = !{!"usbdevfs_disconnect_claim", !4, i64 0, !4, i64 4, !5, i64 8}
!683 = !{!682, !4, i64 4}
!684 = !{i32 -2146885096, i32 -2146885057, i32 -2146885036, i32 -2146884999, i32 -2146884976, i32 -2146885106}
!685 = !{!106, !7, i64 24}
!686 = !{!590, !7, i64 56}
!687 = !{!590, !7, i64 48}
!688 = !{!590, !4, i64 76}
!689 = !{i32 -2143216356}
!690 = !{i32 -2143214593}
!691 = !{!211, !4, i64 172}
!692 = !{i32 -2143212807}
!693 = !{i32 -2143210775}
!694 = !{i32 -2143208694}
!695 = !{i32 -2143206500}
!696 = !{!113, !20, i64 0}
!697 = !{i32 -2143204557}
!698 = !{i32 -2146056434}
!699 = !{i32 -2142984186}
!700 = !{i32 -2142982420}
!701 = !{i32 -2142980631}
!702 = !{i32 -2142978596}
!703 = !{i32 -2142976512}
!704 = !{i32 -2142974691}
!705 = !{i32 -2143193851}
!706 = !{i32 -2143191267, i32 -2143191260, i32 -2143191246, i32 -2143191244, i32 -2143191917, i32 -2143191204, i32 -2143191156, i32 -2143191090, i32 -2143191028, i32 -2143190976, i32 -2143191837, i32 -2143191812, i32 -2143190771, i32 -2143191739, i32 -2143191714, i32 -2143190511, i32 -2143190587, i32 -2143190494, i32 -2143190543, i32 -2143192437, i32 -2143192396, i32 -2143189728, i32 -2143189714, i32 -2143189712, i32 -2143190385, i32 -2143189672, i32 -2143189624, i32 -2143189558, i32 -2143189496, i32 -2143189444, i32 -2143190305, i32 -2143190280, i32 -2143189239, i32 -2143190207, i32 -2143190182, i32 -2143188979, i32 -2143189055, i32 -2143188962, i32 -2143189011, i32 -2143192364, i32 -2143192325, i32 -2143192296, i32 -2143192250, i32 -2143192225, i32 -2143188945, i32 -2143188901, i32 -2143188878, i32 -2143188845, i32 -2143188814}
!707 = !{!708, !5, i64 0}
!708 = !{!"usbdevfs_urb", !5, i64 0, !5, i64 1, !4, i64 4, !4, i64 8, !7, i64 16, !4, i64 24, !4, i64 28, !4, i64 32, !4, i64 36, !4, i64 40, !4, i64 44, !7, i64 48, !5, i64 56}
!709 = !{i32 -2143170916, i32 -2143170909, i32 -2143170895, i32 -2143170893, i32 -2143175627, i32 -2143170853, i32 -2143170805, i32 -2143170739, i32 -2143170677, i32 -2143170625, i32 -2143175547, i32 -2143175522, i32 -2143170420, i32 -2143175449, i32 -2143175424, i32 -2143170160, i32 -2143170236, i32 -2143170143, i32 -2143170192, i32 -2143176151, i32 -2143176110, i32 -2143169377, i32 -2143169363, i32 -2143169361, i32 -2143170034, i32 -2143169321, i32 -2143169273, i32 -2143169207, i32 -2143169145, i32 -2143169093, i32 -2143169954, i32 -2143169929, i32 -2143168888, i32 -2143169856, i32 -2143169831, i32 -2143168628, i32 -2143168704, i32 -2143168611, i32 -2143168660, i32 -2143176078, i32 -2143176039, i32 -2143176010, i32 -2143175964, i32 -2143175939, i32 -2143168594, i32 -2143168550, i32 -2143168527, i32 -2143168494, i32 -2143168463}
!710 = !{!708, !5, i64 1}
!711 = !{i32 -2143147116, i32 -2143147109, i32 -2143147095, i32 -2143147093, i32 -2143147766, i32 -2143147053, i32 -2143147005, i32 -2143146939, i32 -2143146877, i32 -2143146825, i32 -2143147686, i32 -2143147661, i32 -2143146620, i32 -2143147588, i32 -2143147563, i32 -2143146360, i32 -2143146436, i32 -2143146343, i32 -2143146392, i32 -2143148288, i32 -2143148247, i32 -2143145577, i32 -2143145563, i32 -2143145561, i32 -2143146234, i32 -2143145521, i32 -2143145473, i32 -2143145407, i32 -2143145345, i32 -2143145293, i32 -2143146154, i32 -2143146129, i32 -2143145088, i32 -2143146056, i32 -2143146031, i32 -2143144828, i32 -2143144904, i32 -2143144811, i32 -2143144860, i32 -2143148215, i32 -2143148176, i32 -2143148147, i32 -2143148101, i32 -2143148076, i32 -2143144794, i32 -2143144750, i32 -2143144727, i32 -2143144694, i32 -2143144663}
!712 = !{!708, !4, i64 4}
!713 = !{i32 -2143130856, i32 -2143130849, i32 -2143130835, i32 -2143130833, i32 -2143131506, i32 -2143130793, i32 -2143130745, i32 -2143130679, i32 -2143130617, i32 -2143130565, i32 -2143131426, i32 -2143131401, i32 -2143130360, i32 -2143131328, i32 -2143131303, i32 -2143130100, i32 -2143130176, i32 -2143130083, i32 -2143130132, i32 -2143132027, i32 -2143131986, i32 -2143129317, i32 -2143129303, i32 -2143129301, i32 -2143129974, i32 -2143129261, i32 -2143129213, i32 -2143129147, i32 -2143129085, i32 -2143129033, i32 -2143129894, i32 -2143129869, i32 -2143128828, i32 -2143129796, i32 -2143129771, i32 -2143128568, i32 -2143128644, i32 -2143128551, i32 -2143128600, i32 -2143131954, i32 -2143131915, i32 -2143131886, i32 -2143131840, i32 -2143131815, i32 -2143128534, i32 -2143128490, i32 -2143128467, i32 -2143128434, i32 -2143128403}
!714 = !{!708, !4, i64 8}
!715 = !{i32 -2143114456, i32 -2143114449, i32 -2143114435, i32 -2143114433, i32 -2143115106, i32 -2143114393, i32 -2143114345, i32 -2143114279, i32 -2143114217, i32 -2143114165, i32 -2143115026, i32 -2143115001, i32 -2143113960, i32 -2143114928, i32 -2143114903, i32 -2143113700, i32 -2143113776, i32 -2143113683, i32 -2143113732, i32 -2143115635, i32 -2143115594, i32 -2143112917, i32 -2143112903, i32 -2143112901, i32 -2143113574, i32 -2143112861, i32 -2143112813, i32 -2143112747, i32 -2143112685, i32 -2143112633, i32 -2143113494, i32 -2143113469, i32 -2143112428, i32 -2143113396, i32 -2143113371, i32 -2143112168, i32 -2143112244, i32 -2143112151, i32 -2143112200, i32 -2143115562, i32 -2143115523, i32 -2143115494, i32 -2143115448, i32 -2143115423, i32 -2143112134, i32 -2143112090, i32 -2143112067, i32 -2143112034, i32 -2143112003}
!716 = !{!708, !4, i64 24}
!717 = !{i32 -2143098024, i32 -2143098017, i32 -2143098003, i32 -2143098001, i32 -2143098674, i32 -2143097961, i32 -2143097913, i32 -2143097847, i32 -2143097785, i32 -2143097733, i32 -2143098594, i32 -2143098569, i32 -2143097528, i32 -2143098496, i32 -2143098471, i32 -2143097268, i32 -2143097344, i32 -2143097251, i32 -2143097300, i32 -2143099203, i32 -2143099162, i32 -2143096485, i32 -2143096471, i32 -2143096469, i32 -2143097142, i32 -2143096429, i32 -2143096381, i32 -2143096315, i32 -2143096253, i32 -2143096201, i32 -2143097062, i32 -2143097037, i32 -2143095996, i32 -2143096964, i32 -2143096939, i32 -2143095736, i32 -2143095812, i32 -2143095719, i32 -2143095768, i32 -2143099130, i32 -2143099091, i32 -2143099062, i32 -2143099016, i32 -2143098991, i32 -2143095702, i32 -2143095658, i32 -2143095635, i32 -2143095602, i32 -2143095571}
!718 = !{!708, !4, i64 28}
!719 = !{i32 -2143077567, i32 -2143077560, i32 -2143077546, i32 -2143077544, i32 -2143078217, i32 -2143077504, i32 -2143077456, i32 -2143077390, i32 -2143077328, i32 -2143077276, i32 -2143078137, i32 -2143078112, i32 -2143077071, i32 -2143078039, i32 -2143078014, i32 -2143076811, i32 -2143076887, i32 -2143076794, i32 -2143076843, i32 -2143078744, i32 -2143078703, i32 -2143076028, i32 -2143076014, i32 -2143076012, i32 -2143076685, i32 -2143075972, i32 -2143075924, i32 -2143075858, i32 -2143075796, i32 -2143075744, i32 -2143076605, i32 -2143076580, i32 -2143075539, i32 -2143076507, i32 -2143076482, i32 -2143075279, i32 -2143075355, i32 -2143075262, i32 -2143075311, i32 -2143078671, i32 -2143078632, i32 -2143078603, i32 -2143078557, i32 -2143078532, i32 -2143075245, i32 -2143075201, i32 -2143075178, i32 -2143075145, i32 -2143075114}
!720 = !{!708, !4, i64 32}
!721 = !{i32 -2143061071, i32 -2143061064, i32 -2143061050, i32 -2143061048, i32 -2143061721, i32 -2143061008, i32 -2143060960, i32 -2143060894, i32 -2143060832, i32 -2143060780, i32 -2143061641, i32 -2143061616, i32 -2143060575, i32 -2143061543, i32 -2143061518, i32 -2143060315, i32 -2143060391, i32 -2143060298, i32 -2143060347, i32 -2143062254, i32 -2143062213, i32 -2143059532, i32 -2143059518, i32 -2143059516, i32 -2143060189, i32 -2143059476, i32 -2143059428, i32 -2143059362, i32 -2143059300, i32 -2143059248, i32 -2143060109, i32 -2143060084, i32 -2143059043, i32 -2143060011, i32 -2143059986, i32 -2143058783, i32 -2143058859, i32 -2143058766, i32 -2143058815, i32 -2143062181, i32 -2143062142, i32 -2143062113, i32 -2143062067, i32 -2143062042, i32 -2143058749, i32 -2143058705, i32 -2143058682, i32 -2143058649, i32 -2143058618}
!722 = !{!708, !4, i64 36}
!723 = !{i32 -2143044659, i32 -2143044652, i32 -2143044638, i32 -2143044636, i32 -2143045309, i32 -2143044596, i32 -2143044548, i32 -2143044482, i32 -2143044420, i32 -2143044368, i32 -2143045229, i32 -2143045204, i32 -2143044163, i32 -2143045131, i32 -2143045106, i32 -2143043903, i32 -2143043979, i32 -2143043886, i32 -2143043935, i32 -2143045836, i32 -2143045795, i32 -2143043120, i32 -2143043106, i32 -2143043104, i32 -2143043777, i32 -2143043064, i32 -2143043016, i32 -2143042950, i32 -2143042888, i32 -2143042836, i32 -2143043697, i32 -2143043672, i32 -2143042631, i32 -2143043599, i32 -2143043574, i32 -2143042371, i32 -2143042447, i32 -2143042354, i32 -2143042403, i32 -2143045763, i32 -2143045724, i32 -2143045695, i32 -2143045649, i32 -2143045624, i32 -2143042337, i32 -2143042293, i32 -2143042270, i32 -2143042237, i32 -2143042206}
!724 = !{!708, !4, i64 40}
!725 = !{i32 -2143028379, i32 -2143028372, i32 -2143028358, i32 -2143028356, i32 -2143029029, i32 -2143028316, i32 -2143028268, i32 -2143028202, i32 -2143028140, i32 -2143028088, i32 -2143028949, i32 -2143028924, i32 -2143027883, i32 -2143028851, i32 -2143028826, i32 -2143027623, i32 -2143027699, i32 -2143027606, i32 -2143027655, i32 -2143029550, i32 -2143029509, i32 -2143026840, i32 -2143026826, i32 -2143026824, i32 -2143027497, i32 -2143026784, i32 -2143026736, i32 -2143026670, i32 -2143026608, i32 -2143026556, i32 -2143027417, i32 -2143027392, i32 -2143026351, i32 -2143027319, i32 -2143027294, i32 -2143026091, i32 -2143026167, i32 -2143026074, i32 -2143026123, i32 -2143029477, i32 -2143029438, i32 -2143029409, i32 -2143029363, i32 -2143029338, i32 -2143026057, i32 -2143026013, i32 -2143025990, i32 -2143025957, i32 -2143025926}
!726 = !{!708, !4, i64 44}
!727 = !{i32 -2143012118, i32 -2143012111, i32 -2143012097, i32 -2143012095, i32 -2143012768, i32 -2143012055, i32 -2143012007, i32 -2143011941, i32 -2143011879, i32 -2143011827, i32 -2143012688, i32 -2143012663, i32 -2143011622, i32 -2143012590, i32 -2143012565, i32 -2143011362, i32 -2143011438, i32 -2143011345, i32 -2143011394, i32 -2143013290, i32 -2143013249, i32 -2143010579, i32 -2143010565, i32 -2143010563, i32 -2143011236, i32 -2143010523, i32 -2143010475, i32 -2143010409, i32 -2143010347, i32 -2143010295, i32 -2143011156, i32 -2143011131, i32 -2143010090, i32 -2143011058, i32 -2143011033, i32 -2143009830, i32 -2143009906, i32 -2143009813, i32 -2143009862, i32 -2143013217, i32 -2143013178, i32 -2143013149, i32 -2143013103, i32 -2143013078, i32 -2143009796, i32 -2143009752, i32 -2143009729, i32 -2143009696, i32 -2143009665}
!728 = !{!708, !7, i64 16}
!729 = !{i32 -2142995773, i32 -2142995766, i32 -2142995752, i32 -2142995750, i32 -2142996423, i32 -2142995710, i32 -2142995662, i32 -2142995596, i32 -2142995534, i32 -2142995482, i32 -2142996343, i32 -2142996318, i32 -2142995277, i32 -2142996245, i32 -2142996220, i32 -2142990956, i32 -2142991032, i32 -2142990939, i32 -2142990988, i32 -2142996950, i32 -2142996909, i32 -2142990173, i32 -2142990159, i32 -2142990157, i32 -2142990830, i32 -2142990117, i32 -2142990069, i32 -2142990003, i32 -2142989941, i32 -2142989889, i32 -2142990750, i32 -2142990725, i32 -2142989684, i32 -2142990652, i32 -2142990627, i32 -2142989424, i32 -2142989500, i32 -2142989407, i32 -2142989456, i32 -2142996877, i32 -2142996838, i32 -2142996809, i32 -2142996763, i32 -2142996738, i32 -2142989390, i32 -2142989346, i32 -2142989323, i32 -2142989290, i32 -2142989259}
!730 = !{!708, !7, i64 48}
!731 = !{!732, !4, i64 0}
!732 = !{!"usbdevfs_iso_packet_desc", !4, i64 0, !4, i64 4, !4, i64 8}
!733 = !{i32 -2143219866}
!734 = !{!429, !4, i64 0}
!735 = !{!590, !7, i64 16}
!736 = !{!590, !4, i64 40}
!737 = !{!590, !5, i64 84}
!738 = !{!590, !5, i64 85}
!739 = !{!595, !4, i64 268}
!740 = !{i32 -2143587987, i32 -2143587962, i32 -2143587692, i32 -2143587895, i32 -2143587864, i32 -2143587834}
!741 = !{!742, !4, i64 0}
!742 = !{!"siginfo", !4, i64 0, !4, i64 4, !4, i64 8, !5, i64 16}
!743 = !{!742, !4, i64 4}
!744 = !{!742, !4, i64 8}
!745 = !{!590, !4, i64 80}
!746 = !{i32 -2143590991, i32 -2143590966, i32 -2143590696, i32 -2143590899, i32 -2143590868, i32 -2143590838}
!747 = !{i32 -2143590445, i32 -2143590420, i32 -2143590150, i32 -2143590353, i32 -2143590322, i32 -2143590292}
!748 = !{i32 -2143589882, i32 -2143589857, i32 -2143589587, i32 -2143589790, i32 -2143589759, i32 -2143589729}
!749 = !{i32 -2146085189, i32 -2146085150, i32 -2146085129, i32 -2146085092, i32 -2146085069, i32 -2146085199}
!750 = !{!751, !7, i64 0}
!751 = !{!"poll_table_struct", !7, i64 0, !20, i64 8}
!752 = !{!3, !7, i64 1624}
!753 = !{!595, !4, i64 264}
!754 = !{!63, !5, i64 5}
!755 = !{!63, !5, i64 6}
!756 = !{!63, !5, i64 7}
!757 = !{i32 -2143513758}
!758 = !{!559, !29, i64 288}
!759 = !{i32 -2146093718}
!760 = !{!33, !5, i64 4}
!761 = !{!447, !5, i64 4}
!762 = !{!763, !4, i64 0}
!763 = !{!"class_info", !4, i64 0, !7, i64 8}
!764 = !{!763, !7, i64 8}
!765 = !{i32 -2146122473, i32 -2146122434, i32 -2146122413, i32 -2146122376, i32 -2146122353, i32 -2146122483}
!766 = !{!13, !7, i64 0}
!767 = !{!103, !5, i64 1156}
!768 = !{i32 -2147011921, i32 -2147011882, i32 -2147011861, i32 -2147011824, i32 -2147011801, i32 -2147011931}
!769 = !{i32 -2147011213, i32 -2147011174, i32 -2147011153, i32 -2147011116, i32 -2147011093, i32 -2147011223}
!770 = !{!103, !7, i64 8}
!771 = !{!103, !7, i64 1120}
!772 = !{!103, !7, i64 96}
!773 = !{!774, !4, i64 120}
!774 = !{!"pci_dev", !12, i64 0, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !4, i64 56, !10, i64 60, !10, i64 62, !10, i64 64, !10, i64 66, !4, i64 68, !5, i64 72, !5, i64 73, !5, i64 74, !5, i64 75, !5, i64 76, !5, i64 77, !5, i64 78, !5, i64 79, !10, i64 80, !7, i64 88, !29, i64 96, !775, i64 104, !4, i64 120, !5, i64 124, !4, i64 125, !4, i64 125, !4, i64 125, !4, i64 125, !4, i64 126, !4, i64 126, !4, i64 126, !4, i64 126, !4, i64 126, !4, i64 126, !4, i64 126, !4, i64 128, !4, i64 132, !7, i64 136, !4, i64 144, !13, i64 152, !4, i64 1288, !4, i64 1292, !5, i64 1296, !23, i64 2248, !4, i64 2249, !4, i64 2249, !4, i64 2249, !4, i64 2249, !4, i64 2249, !4, i64 2249, !4, i64 2249, !4, i64 2249, !4, i64 2250, !4, i64 2250, !4, i64 2250, !4, i64 2250, !4, i64 2250, !4, i64 2250, !4, i64 2250, !4, i64 2251, !4, i64 2251, !4, i64 2251, !4, i64 2251, !4, i64 2251, !4, i64 2251, !4, i64 2251, !4, i64 2251, !10, i64 2252, !16, i64 2256, !5, i64 2260, !121, i64 2328, !7, i64 2336, !4, i64 2344, !5, i64 2352, !5, i64 2488, !12, i64 2624, !7, i64 2640, !7, i64 2648, !5, i64 2656, !7, i64 2664, !29, i64 2672, !20, i64 2680}
!775 = !{!"device_dma_parameters", !4, i64 0, !20, i64 8}
!776 = !{!74, !7, i64 64}
!777 = !{!774, !4, i64 68}
!778 = !{!774, !4, i64 56}
!779 = !{!774, !7, i64 16}
!780 = !{!74, !7, i64 56}
!781 = !{!774, !4, i64 1292}
!782 = !{!72, !7, i64 64}
!783 = !{!72, !7, i64 416}
!784 = !{!72, !29, i64 432}
!785 = !{i32 -2146270419, i32 -2146270394, i32 -2146270124, i32 -2146270327, i32 -2146270296, i32 -2146270266}
!786 = !{i32 -2146270867, i32 -2146269872, i32 -2146269850, i32 -2146269837, i32 -2146269514, i32 -2146269447, i32 -2146269745, i32 -2146269718, i32 -2146269690, i32 -2146269660}
!787 = !{!345, !7, i64 24}
!788 = !{i32 -2146267897, i32 -2146267872, i32 -2146267602, i32 -2146267805, i32 -2146267774, i32 -2146267744}
!789 = !{i32 -2146268341, i32 -2146267350, i32 -2146267328, i32 -2146267315, i32 -2146266992, i32 -2146266925, i32 -2146267223, i32 -2146267196, i32 -2146267168, i32 -2146267138}
!790 = !{i32 -2146205601, i32 -2146205562, i32 -2146205541, i32 -2146205504, i32 -2146205481, i32 -2146205611}
!791 = !{!792, !20, i64 24}
!792 = !{!"pci_device_id", !4, i64 0, !4, i64 4, !4, i64 8, !4, i64 12, !4, i64 16, !4, i64 20, !20, i64 24}
!793 = !{!794, !29, i64 0}
!794 = !{!"resource", !29, i64 0, !29, i64 8, !7, i64 16, !20, i64 24, !7, i64 32, !7, i64 40, !7, i64 48}
!795 = !{!794, !29, i64 8}
!796 = !{!794, !20, i64 24}
!797 = !{i32 -2146200463, i32 -2146200424, i32 -2146200403, i32 -2146200366, i32 -2146200343, i32 -2146200334}
!798 = !{!799, !7, i64 8}
!799 = !{!"acpi_buffer", !29, i64 0, !7, i64 8}
!800 = !{!801, !5, i64 12}
!801 = !{!"acpi_pld_info", !5, i64 0, !5, i64 1, !4, i64 4, !10, i64 8, !10, i64 10, !5, i64 12, !5, i64 13, !5, i64 14, !5, i64 15, !5, i64 16, !5, i64 17, !5, i64 18, !5, i64 19, !5, i64 20, !5, i64 21, !5, i64 22, !5, i64 23, !5, i64 24, !5, i64 25, !5, i64 26, !5, i64 27, !5, i64 28, !5, i64 29, !5, i64 30, !10, i64 32, !10, i64 34}
