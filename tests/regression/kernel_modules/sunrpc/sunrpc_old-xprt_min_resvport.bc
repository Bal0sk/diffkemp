; ModuleID = 'tests/regression/kernel_modules/sunrpc/sunrpc_old-xprt_min_resvport.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_symbol = type { i64, i8* }
%struct.rpc_procinfo = type { i32, void (i8*, %struct.xdr_stream*, i8*)*, i32 (i8*, %struct.xdr_stream*, i8*)*, i32, i32, i32, i32, i32, i8* }
%struct.xdr_stream = type { i32*, %struct.xdr_buf*, i32*, %struct.iovec*, %struct.iovec, %struct.page**, i32 }
%struct.xdr_buf = type { [1 x %struct.iovec], [1 x %struct.iovec], %struct.page**, i32, i32, i32, i32, i32 }
%struct.iovec = type { i8*, i64 }
%struct.page = type { i64, %struct.address_space*, %struct.anon.0, %union.anon.39, %struct.pgprot, i64 }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %struct.atomic_t, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.36, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.38, i32, i32, %struct.hlist_head, %struct.atomic_t, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.load_weight*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.dentry = type { i32, %struct.atomic_t, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.39, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %struct.pgprot, i8* }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.vfsmount = type { %struct.dentry*, %struct.super_block*, i32 }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.nameidata = type { %struct.path, %struct.qstr, %struct.path, %struct.inode*, i32, i32, i32, i32, [9 x i8*] }
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, %struct.file* }
%struct.file = type { %union.anon.39, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.pgprot, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space*, i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %struct.pgprot, i32, i32, i8*, %struct.lockdep_map }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.list_head, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type { %struct.arch_spinlock, [128 x %struct.pidmap], i32, i32, %struct.task_struct*, %struct.kmem_cache*, i32, %struct.pid_namespace*, %struct.vfsmount*, %struct.dentry*, %struct.bsd_acct_struct*, %struct.user_namespace*, %struct.work_struct, i32, i32, i32, i32 }
%struct.arch_spinlock = type { %struct.atomic_t }
%struct.pidmap = type { %struct.atomic_t, i8* }
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.hlist_head, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, i8, i32, i32, i32, i32, i32, i32, i8, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.load_weight, i64, i64, %struct.load_weight, %struct.load_weight, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, i64, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.dma_attrs, %struct.dma_attrs, %struct.dma_attrs, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.dma_attrs*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %union.anon.39, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.tcp_mib, %struct.atomic_t, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i64, %struct.callback_head, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, %struct.memcg_batch_info, i32, %struct.atomic_t, %struct.uprobe_task*, i32, i32 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.cpumask = type { [64 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgprot*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.task_struct*, %struct.file*, %struct.mmu_notifier_mm*, %struct.page*, %struct.cpumask, i64, i64, i64, i32, i32, %struct.uprobes_state }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.tcp_mib*, %struct.tcp_mib*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head, %struct.lockdep_map }
%struct.mm_rss_stat = type { [3 x %struct.pgprot] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type { %struct.__wait_queue_head, %struct.atomic_t, i64*, %struct.page*, i64 }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.task_cputime = type { i64, i64, i64 }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.18 }
%union.anon.18 = type { %struct.exception_table_entry }
%struct.exception_table_entry = type { i32, i32 }
%struct.perf_event = type { %struct.list_head, %struct.list_head, %struct.list_head, %struct.hlist_node, i32, i32, %struct.perf_event*, %struct.pmu*, i32, i32, %struct.local64_t, %struct.pgprot, i64, i64, i64, i64, i64, i64, %struct.perf_event_attr, i16, i16, i16, %struct.hw_perf_event, %struct.perf_event_context*, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.mutex, %struct.list_head, %struct.perf_event*, i32, i32, %struct.list_head, %struct.task_struct*, %struct.mutex, %struct.atomic_t, %struct.ring_buffer*, %struct.list_head, %struct.__wait_queue_head, %struct.fasync_struct*, i32, i32, i32, %struct.irq_work, %struct.atomic_t, void (%struct.perf_event*)*, %struct.callback_head, %struct.pid_namespace*, i64, void (%struct.perf_event*, %struct.perf_sample_data*, %struct.pt_regs*)*, i8*, %struct.ftrace_event_call*, %struct.event_filter*, %struct.ftrace_ops, %struct.perf_cgroup*, i32 }
%struct.pmu = type { %struct.list_head, %struct.device*, %struct.attribute_group**, i8*, i32, i32*, %struct.perf_cpu_context*, i32, void (%struct.pmu*)*, void (%struct.pmu*)*, i32 (%struct.perf_event*)*, i32 (%struct.perf_event*, i32)*, void (%struct.perf_event*, i32)*, void (%struct.perf_event*, i32)*, void (%struct.perf_event*, i32)*, void (%struct.perf_event*)*, void (%struct.pmu*)*, i32 (%struct.pmu*)*, void (%struct.pmu*)*, i32 (%struct.perf_event*)*, void ()* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %union.anon.57, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.arch_spinlock, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type { %struct.sock_common, %struct.socket_lock_t, %struct.sk_buff_head, %struct.anon.66, i32, i32, %struct.atomic_t, i32, %struct.sk_filter*, %struct.socket_wq*, %struct.sk_buff_head, [2 x %struct.xfrm_policy*], i64, %struct.dst_entry*, %struct.dst_entry*, %struct.spinlock, %struct.atomic_t, %struct.atomic_t, i32, %struct.sk_buff_head, i32, i32, i32, i64, i64, i32, i32, i16, i32, i64, %struct.sk_buff_head, %struct.proto*, %struct.rwlock_t, i32, i32, i16, i16, i32, i32, %struct.pid*, %struct.cred*, i64, i64, i8*, %struct.timer_list, %struct.pgprot, %struct.socket*, i8*, %struct.page_frag, %struct.sk_buff*, i32, i32, i8*, i32, i32, %struct.cg_proto*, void (%struct.sock*)*, void (%struct.sock*, i32)*, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*, %struct.sk_buff*)*, void (%struct.sock*)* }
%struct.sock_common = type { %struct.pgprot, %struct.atomic_t, %struct.atomic_t, i16, i8, i8, i32, %union.anon.64, %struct.proto*, %struct.net*, [0 x i32], %union.anon.64, i32, %struct.atomic_t, [0 x i32] }
%struct.net = type { %struct.atomic_t, %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head, %struct.user_namespace*, i32, %struct.proc_dir_entry*, %struct.proc_dir_entry*, %struct.ctl_table_set, %struct.sock*, %struct.sock*, %struct.list_head, %struct.hlist_head*, %struct.hlist_head*, i32, i32, %struct.list_head, %struct.net_device*, %struct.netns_core, %struct.netns_mib, %struct.netns_packet, %struct.netns_unix, [48 x i8], %struct.netns_ipv4, %struct.netns_ipv6, %struct.netns_sctp, %struct.netns_dccp, %struct.netns_nf, %struct.netns_xt, %struct.netns_ct, [56 x i8], %struct.netns_nf_frag, %struct.sock*, %struct.sock*, %struct.sk_buff_head, %struct.net_generic*, [8 x i8], %struct.netns_xfrm, %struct.netns_ipvs*, %struct.sock*, %struct.atomic_t, [44 x i8] }
%struct.proc_dir_entry = type opaque
%struct.ctl_table_set = type { i32 (%struct.ctl_table_set*)*, %struct.ctl_dir }
%struct.ctl_dir = type { %struct.ctl_table_header, %struct.rb_root }
%struct.ctl_table_header = type { %union.anon.47, %struct.completion*, %struct.ctl_table*, %struct.ctl_table_root*, %struct.ctl_table_set*, %struct.ctl_dir*, %struct.ctl_node* }
%union.anon.47 = type { %struct.anon.48 }
%struct.anon.48 = type { %struct.ctl_table*, i32, i32, i32 }
%struct.ctl_table = type { i8*, i8*, i32, i16, %struct.ctl_table*, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)*, %struct.ctl_table_poll*, i8*, i8* }
%struct.ctl_table_poll = type { %struct.atomic_t, %struct.__wait_queue_head }
%struct.ctl_table_root = type { %struct.ctl_table_set, %struct.ctl_table_set* (%struct.ctl_table_root*, %struct.nsproxy*)*, i32 (%struct.ctl_table_header*, %struct.ctl_table*)* }
%struct.ctl_node = type { %struct.rb_node, %struct.ctl_table_header* }
%struct.net_device = type { [16 x i8], %struct.hlist_node, i8*, i64, i64, i64, i32, i64, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, i64, i64, i64, i64, i64, i32, i32, %struct.net_device_stats, %struct.pgprot, %struct.iw_handler_def*, %struct.iw_public_data*, %struct.net_device_ops*, %struct.ethtool_ops*, %struct.header_ops*, i32, i32, i16, i16, i8, i8, i8, i8, i32, i16, i16, i16, i16, [32 x i8], i8, i8, i8, i16, %struct.spinlock, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.kset*, i8, i32, i32, %struct.vlan_info*, %struct.dsa_switch_tree*, i8*, %struct.in_device*, %struct.dn_dev*, %struct.inet6_dev*, i8*, %struct.wireless_dev*, i64, i8*, %struct.netdev_rx_queue*, i32, i32, i32 (%struct.sk_buff**)*, i8*, %struct.netdev_queue*, [32 x i8], [16 x i8], %struct.netdev_queue*, i32, i32, %struct.Qdisc*, i64, %struct.spinlock, %struct.xps_dev_maps*, %struct.cpu_rmap*, i64, i32, %struct.timer_list, i32*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8, i8, i16, void (%struct.net_device*)*, %struct.netpoll_info*, %struct.net*, %union.anon.57, %struct.garp_port*, %struct.mrp_port*, %struct.device, [4 x %struct.attribute_group*], %struct.rtnl_link_ops*, i32, i16, %struct.dcbnl_rtnl_ops*, i8, [16 x %struct.nlattr], [16 x i8], i32, %struct.netprio_map*, %struct.phy_device*, %struct.lock_class_key*, i32, %struct.pm_qos_request, [24 x i8] }
%struct.net_device_stats = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.iw_handler_def = type opaque
%struct.iw_public_data = type opaque
%struct.net_device_ops = type { i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i16 (%struct.net_device*, %struct.sk_buff*)*, void (%struct.net_device*, i32)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i8*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ifreq*, i32)*, i32 (%struct.net_device*, %struct.ifmap*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.neigh_parms*)*, void (%struct.net_device*)*, %struct.net_device_stats* (%struct.net_device*, %struct.net_device_stats*)*, %struct.net_device_stats* (%struct.net_device*)*, i32 (%struct.net_device*, i16, i16)*, i32 (%struct.net_device*, i16, i16)*, void (%struct.net_device*)*, i32 (%struct.net_device*, %struct.netpoll_info*, i32)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32, i16, i8)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_info*)*, i32 (%struct.net_device*, i32, %struct.nlattr**)*, i32 (%struct.net_device*, i32, %struct.sk_buff*)*, i32 (%struct.net_device*, i8)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i16, %struct.scatterlist*, i32)*, i32 (%struct.net_device*, i16)*, i32 (%struct.net_device*, i16, %struct.scatterlist*, i32)*, i32 (%struct.net_device*, %struct.netdev_fcoe_hbainfo*)*, i32 (%struct.net_device*, i64*, i32)*, i32 (%struct.net_device*, %struct.sk_buff*, i16, i32)*, i32 (%struct.net_device*, %struct.net_device*)*, i32 (%struct.net_device*, %struct.net_device*)*, i64 (%struct.net_device*, i64)*, i32 (%struct.net_device*, i64)*, i32 (%struct.neighbour*)*, void (%struct.neighbour*)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*)*, i32 (%struct.sk_buff*, %struct.netlink_callback*, %struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.nlmsghdr*)*, i32 (%struct.sk_buff*, i32, i32, %struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.nlmsghdr*)*, i32 (%struct.net_device*, i1)* }
%struct.ifreq = type { %union.anon.52, %union.anon.53 }
%union.anon.52 = type { [16 x i8] }
%union.anon.53 = type { %struct.ifmap }
%struct.ifmap = type { i64, i64, i16, i8, i8, i8 }
%struct.neigh_parms = type { %struct.net*, %struct.net_device*, %struct.neigh_parms*, i32 (%struct.neighbour*)*, void (%struct.neighbour*)*, %struct.neigh_table*, i8*, i32, %struct.atomic_t, %struct.callback_head, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.neigh_table = type { %struct.neigh_table*, i32, i32, i32, i32 (i8*, %struct.net_device*, i32*)*, i32 (%struct.neighbour*)*, i32 (%struct.pneigh_entry*)*, void (%struct.pneigh_entry*)*, void (%struct.sk_buff*)*, i8*, %struct.neigh_parms, i32, i32, i32, i32, i64, %struct.delayed_work, %struct.timer_list, %struct.sk_buff_head, %struct.atomic_t, %struct.rwlock_t, i64, %struct.neigh_statistics*, %struct.neigh_hash_table*, %struct.pneigh_entry** }
%struct.pneigh_entry = type { %struct.pneigh_entry*, %struct.net*, %struct.net_device*, i8, [0 x i8] }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.workqueue_struct = type opaque
%struct.neigh_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.neigh_hash_table = type { %struct.neighbour**, i32, [4 x i32], %struct.callback_head }
%struct.neighbour = type { %struct.neighbour*, %struct.neigh_table*, %struct.neigh_parms*, i64, i64, %struct.rwlock_t, %struct.atomic_t, %struct.sk_buff_head, i32, %struct.timer_list, i64, %struct.atomic_t, i8, i8, i8, i8, %struct.seqlock_t, [32 x i8], %struct.hh_cache, i32 (%struct.neighbour*, %struct.sk_buff*)*, %struct.neigh_ops*, %struct.callback_head, %struct.net_device*, [0 x i8] }
%struct.seqlock_t = type { %struct.atomic_t, %struct.spinlock }
%struct.hh_cache = type { i16, i16, %struct.seqlock_t, [16 x i64] }
%struct.neigh_ops = type { i32, void (%struct.neighbour*, %struct.sk_buff*)*, void (%struct.neighbour*, %struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.sk_buff*)* }
%struct.ifla_vf_info = type { i32, [32 x i8], i32, i32, i32, i32 }
%struct.nlattr = type { i16, i16 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.netdev_fcoe_hbainfo = type { [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [256 x i8], [256 x i8] }
%struct.ndmsg = type { i8, i8, i16, i32, i16, i8, i8 }
%struct.netlink_callback = type { %struct.sk_buff*, %struct.nlmsghdr*, i32 (%struct.sk_buff*, %struct.netlink_callback*)*, i32 (%struct.netlink_callback*)*, i8*, %struct.module*, i16, i16, i32, i32, [6 x i64] }
%struct.nlmsghdr = type { i32, i16, i16, i32, i32 }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.kernel_symbol*, i64*, i8, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.u64_stats_sync, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, i32, i64*, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.load_weight*, void ()**, i32 }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.57 }
%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.u64_stats_sync = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.arch_spinlock, void ()*, void ()*, %struct.tracepoint_func* }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ethtool_ops = type { i32 (%struct.net_device*, %struct.ethtool_cmd*)*, i32 (%struct.net_device*, %struct.ethtool_cmd*)*, void (%struct.net_device*, %struct.ethtool_drvinfo*)*, i32 (%struct.net_device*)*, void (%struct.net_device*, %struct.ethtool_regs*, i8*)*, void (%struct.net_device*, %struct.ethtool_wolinfo*)*, i32 (%struct.net_device*, %struct.ethtool_wolinfo*)*, i32 (%struct.net_device*)*, void (%struct.net_device*, i32)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_coalesce*)*, i32 (%struct.net_device*, %struct.ethtool_coalesce*)*, void (%struct.net_device*, %struct.ethtool_ringparam*)*, i32 (%struct.net_device*, %struct.ethtool_ringparam*)*, void (%struct.net_device*, %struct.ethtool_pauseparam*)*, i32 (%struct.net_device*, %struct.ethtool_pauseparam*)*, void (%struct.net_device*, %struct.ethtool_test*, i64*)*, void (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32)*, void (%struct.net_device*, %struct.ethtool_stats*, i64*)*, i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.ethtool_rxnfc*, i32*)*, i32 (%struct.net_device*, %struct.ethtool_rxnfc*)*, i32 (%struct.net_device*, %struct.ethtool_flash*)*, i32 (%struct.net_device*, i32*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i32*)*, i32 (%struct.net_device*, i32*)*, void (%struct.net_device*, %struct.ethtool_ringparam*)*, i32 (%struct.net_device*, %struct.ethtool_ringparam*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*)*, i32 (%struct.net_device*, %struct.ethtool_ts_info*)*, i32 (%struct.net_device*, %struct.ethtool_modinfo*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eee*)*, i32 (%struct.net_device*, %struct.ethtool_eee*)* }
%struct.ethtool_cmd = type { i32, i32, i32, i16, i8, i8, i8, i8, i8, i8, i32, i32, i16, i8, i8, i32, [2 x i32] }
%struct.ethtool_drvinfo = type { i32, [32 x i8], [32 x i8], [32 x i8], [32 x i8], [32 x i8], [12 x i8], i32, i32, i32, i32, i32 }
%struct.ethtool_regs = type { i32, i32, i32, [0 x i8] }
%struct.ethtool_wolinfo = type { i32, i32, i32, [6 x i8] }
%struct.ethtool_coalesce = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ethtool_pauseparam = type { i32, i32, i32, i32 }
%struct.ethtool_test = type { i32, i32, i32, i32, [0 x i64] }
%struct.ethtool_stats = type { i32, i32, [0 x i64] }
%struct.ethtool_rxnfc = type { i32, i32, i64, %struct.ethtool_rx_flow_spec, i32, [0 x i32] }
%struct.ethtool_rx_flow_spec = type { i32, %union.ethtool_flow_union, %struct.ethtool_flow_ext, %union.ethtool_flow_union, %struct.ethtool_flow_ext, i64, i32 }
%union.ethtool_flow_union = type { %struct.ethtool_tcpip4_spec, [36 x i8] }
%struct.ethtool_tcpip4_spec = type { i32, i32, i16, i16, i8 }
%struct.ethtool_flow_ext = type { [2 x i8], [6 x i8], i16, i16, [2 x i32] }
%struct.ethtool_flash = type { i32, i32, [128 x i8] }
%struct.ethtool_ringparam = type { i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ethtool_eeprom = type { i32, i32, i32, i32, [0 x i8] }
%struct.ethtool_ts_info = type { i32, i32, i32, i32, [3 x i32], i32, [3 x i32] }
%struct.ethtool_modinfo = type { i32, i32, i32, [8 x i32] }
%struct.ethtool_eee = type { i32, i32, i32, i32, i32, i32, i32, i32, [2 x i32] }
%struct.header_ops = type { i32 (%struct.sk_buff*, %struct.net_device*, i16, i8*, i8*, i32)*, i32 (%struct.sk_buff*, i8*)*, i32 (%struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.hh_cache*, i16)*, void (%struct.hh_cache*, %struct.net_device*, i8*)* }
%struct.netdev_hw_addr_list = type { %struct.list_head, i32 }
%struct.vlan_info = type opaque
%struct.dsa_switch_tree = type { %struct.dsa_platform_data*, %struct.net_device*, i16, i8, i8, i32, %struct.work_struct, %struct.timer_list, [4 x %struct.dsa_switch*] }
%struct.dsa_platform_data = type { %struct.device*, i32, %struct.dsa_chip_data* }
%struct.dsa_chip_data = type { %struct.device*, i32, [12 x i8*], i8* }
%struct.dsa_switch = type { %struct.dsa_switch_tree*, i32, %struct.dsa_chip_data*, %struct.dsa_switch_driver*, %struct.mii_bus*, i32, i32, %struct.mii_bus*, [12 x %struct.net_device*] }
%struct.dsa_switch_driver = type { %struct.list_head, i16, i32, i8* (%struct.mii_bus*, i32)*, i32 (%struct.dsa_switch*)*, i32 (%struct.dsa_switch*, i8*)*, i32 (%struct.dsa_switch*, i32, i32)*, i32 (%struct.dsa_switch*, i32, i32, i16)*, void (%struct.dsa_switch*)*, void (%struct.dsa_switch*, i32, i8*)*, void (%struct.dsa_switch*, i32, i64*)*, i32 (%struct.dsa_switch*)* }
%struct.mii_bus = type opaque
%struct.in_device = type opaque
%struct.dn_dev = type opaque
%struct.inet6_dev = type { %struct.net_device*, %struct.list_head, %struct.ifmcaddr6*, %struct.ifmcaddr6*, %struct.spinlock, i8, i8, i8, i64, i64, %struct.timer_list, %struct.timer_list, %struct.ifacaddr6*, %struct.rwlock_t, %struct.atomic_t, i32, i32, [8 x i8], %struct.timer_list, %struct.list_head, %struct.in6_addr, %struct.neigh_parms*, %struct.inet6_dev*, %struct.ipv6_devconf, %struct.ipv6_devstat, i64, %struct.callback_head }
%struct.ifmcaddr6 = type { %struct.in6_addr, %struct.inet6_dev*, %struct.ifmcaddr6*, %struct.ip6_sf_list*, %struct.ip6_sf_list*, i32, i8, [2 x i64], %struct.timer_list, i32, i32, %struct.atomic_t, %struct.spinlock, i64, i64 }
%struct.ip6_sf_list = type { %struct.ip6_sf_list*, %struct.in6_addr, [2 x i64], i8, i8, i8 }
%struct.ifacaddr6 = type { %struct.in6_addr, %struct.inet6_dev*, %struct.rt6_info*, %struct.ifacaddr6*, i32, %struct.atomic_t, %struct.spinlock, i64, i64 }
%struct.rt6_info = type opaque
%struct.in6_addr = type { %union.anon.68 }
%union.anon.68 = type { [4 x i32] }
%struct.ipv6_devconf = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8* }
%struct.ipv6_devstat = type { %struct.proc_dir_entry*, [1 x %struct.ipstats_mib*], %struct.icmpv6_mib_device*, %struct.icmpmsg_mib* }
%struct.ipstats_mib = type { [32 x i64], %struct.u64_stats_sync }
%struct.icmpv6_mib_device = type { [6 x %struct.pgprot] }
%struct.icmpmsg_mib = type { [512 x %struct.pgprot] }
%struct.wireless_dev = type opaque
%struct.netdev_rx_queue = type { %struct.rps_map*, %struct.rps_dev_flow_table*, %struct.kobject, %struct.net_device*, [40 x i8] }
%struct.rps_map = type { i32, %struct.callback_head, [0 x i16] }
%struct.rps_dev_flow_table = type { i32, %struct.callback_head, [0 x %struct.rps_dev_flow] }
%struct.rps_dev_flow = type { i16, i16, i32 }
%struct.netdev_queue = type { %struct.net_device*, %struct.Qdisc*, %struct.Qdisc*, %struct.kobject, i32, [36 x i8], %struct.spinlock, i32, i64, i64, i64, [24 x i8], %struct.dql }
%struct.dql = type { i32, i32, i32, [52 x i8], i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, [20 x i8] }
%struct.Qdisc = type opaque
%struct.xps_dev_maps = type { %struct.callback_head, [0 x %struct.xps_map*] }
%struct.xps_map = type { i32, i32, %struct.callback_head, [0 x i16] }
%struct.cpu_rmap = type opaque
%struct.netpoll_info = type opaque
%struct.garp_port = type opaque
%struct.mrp_port = type opaque
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.rtnl_link_ops = type { %struct.list_head, i8*, i64, void (%struct.net_device*)*, i32, %struct.nlattr*, i32 (%struct.nlattr**, %struct.nlattr**)*, i32 (%struct.net*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**)*, i32 (%struct.net_device*, %struct.nlattr**, %struct.nlattr**)*, void (%struct.net_device*, %struct.list_head*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i32 ()*, i32 ()* }
%struct.dcbnl_rtnl_ops = type { i32 (%struct.net_device*, %struct.ieee_ets*)*, i32 (%struct.net_device*, %struct.ieee_ets*)*, i32 (%struct.net_device*, %struct.udp_mib*)*, i32 (%struct.net_device*, %struct.udp_mib*)*, i32 (%struct.net_device*, %struct.ieee_pfc*)*, i32 (%struct.net_device*, %struct.ieee_pfc*)*, i32 (%struct.net_device*, %struct.dcb_app*)*, i32 (%struct.net_device*, %struct.dcb_app*)*, i32 (%struct.net_device*, %struct.dcb_app*)*, i32 (%struct.net_device*, %struct.ieee_ets*)*, i32 (%struct.net_device*, %struct.ieee_pfc*)*, i8 (%struct.net_device*)*, i8 (%struct.net_device*, i8)*, void (%struct.net_device*, i8*)*, void (%struct.net_device*, i32, i8, i8, i8, i8)*, void (%struct.net_device*, i32, i8)*, void (%struct.net_device*, i32, i8, i8, i8, i8)*, void (%struct.net_device*, i32, i8)*, void (%struct.net_device*, i32, i8*, i8*, i8*, i8*)*, void (%struct.net_device*, i32, i8*)*, void (%struct.net_device*, i32, i8*, i8*, i8*, i8*)*, void (%struct.net_device*, i32, i8*)*, void (%struct.net_device*, i32, i8)*, void (%struct.net_device*, i32, i8*)*, i8 (%struct.net_device*)*, i8 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32, i8)*, i8 (%struct.net_device*)*, void (%struct.net_device*, i8)*, void (%struct.net_device*, i32, i32*)*, void (%struct.net_device*, i32, i32)*, void (%struct.net_device*, i32, i8*)*, void (%struct.net_device*, i32, i8)*, i8 (%struct.net_device*, i8, i16, i8)*, i8 (%struct.net_device*, i8, i16)*, i8 (%struct.net_device*, i32, i8*)*, i8 (%struct.net_device*, i32, i8)*, i8 (%struct.net_device*)*, i8 (%struct.net_device*, i8)*, i32 (%struct.net_device*, %struct.dcb_peer_app_info*, i16*)*, i32 (%struct.net_device*, %struct.dcb_app*)*, i32 (%struct.net_device*, %struct.cee_pg*)*, i32 (%struct.net_device*, %struct.cee_pfc*)* }
%struct.udp_mib = type { [8 x i64] }
%struct.ieee_ets = type { i8, i8, i8, [8 x i8], [8 x i8], [8 x i8], [8 x i8], [8 x i8], [8 x i8], [8 x i8] }
%struct.ieee_pfc = type { i8, i8, i8, i16, [8 x i64], [8 x i64] }
%struct.dcb_peer_app_info = type { i8, i8 }
%struct.dcb_app = type { i8, i8, i16 }
%struct.cee_pg = type { i8, i8, i8, i8, [8 x i8], [8 x i8] }
%struct.cee_pfc = type { i8, i8, i8, i8 }
%struct.netprio_map = type { %struct.callback_head, i32, [0 x i32] }
%struct.phy_device = type opaque
%struct.pm_qos_request = type { %struct.plist_node, i32, %struct.delayed_work }
%struct.netns_core = type { %struct.ctl_table_header*, i32, %struct.prot_inuse* }
%struct.prot_inuse = type opaque
%struct.netns_mib = type { [1 x %struct.tcp_mib*], [1 x %struct.ipstats_mib*], [1 x %struct.linux_mib*], [1 x %struct.udp_mib*], [1 x %struct.udp_mib*], [1 x %struct.icmp_mib*], %struct.icmpmsg_mib*, %struct.proc_dir_entry*, [1 x %struct.udp_mib*], [1 x %struct.udp_mib*], [1 x %struct.ipstats_mib*], [1 x %struct.icmpv6_mib*], %struct.icmpmsg_mib*, [1 x %struct.icmp_mib*] }
%struct.linux_mib = type { [95 x i64] }
%struct.icmpv6_mib = type { [6 x i64] }
%struct.icmp_mib = type { [28 x i64] }
%struct.netns_packet = type { %struct.mutex, %struct.hlist_head }
%struct.netns_unix = type { i32, %struct.ctl_table_header* }
%struct.netns_ipv4 = type { %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ipv4_devconf*, %struct.ipv4_devconf*, %struct.fib_rules_ops*, i8, %struct.fib_table*, %struct.fib_table*, %struct.fib_table*, i32, %struct.hlist_head*, %struct.sock*, %struct.sock**, %struct.inet_peer_base*, %struct.tcpm_hash_bucket*, i32, [44 x i8], %struct.netns_frags, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, i32, i32, i32, i32, i32, i32, i32, [2 x i32], [3 x i64], %struct.atomic_t, %struct.list_head, %struct.fib_rules_ops*, [48 x i8] }
%struct.ipv4_devconf = type opaque
%struct.fib_table = type opaque
%struct.inet_peer_base = type { %struct.inet_peer*, %struct.seqlock_t, i32, i32 }
%struct.inet_peer = type { %struct.inet_peer*, %struct.inet_peer*, %struct.inetpeer_addr, i32, [14 x i32], i32, i64, %union.anon.39, %union.anon.36, i32, %struct.atomic_t }
%struct.inetpeer_addr = type { %struct.in6_addr, i16 }
%struct.tcpm_hash_bucket = type opaque
%struct.netns_frags = type { i32, %struct.list_head, %struct.spinlock, [32 x i8], %struct.percpu_counter, i32, i32, i32, [12 x i8] }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.xt_table = type opaque
%struct.fib_rules_ops = type opaque
%struct.netns_ipv6 = type { %struct.netns_sysctl_ipv6, %struct.ipv6_devconf*, %struct.ipv6_devconf*, %struct.inet_peer_base*, [24 x i8], %struct.netns_frags, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.rt6_info*, %struct.rt6_statistics*, %struct.timer_list, %struct.hlist_head*, %struct.fib6_table*, [56 x i8], %struct.dst_ops, i32, i64, %struct.rt6_info*, %struct.rt6_info*, %struct.fib6_table*, %struct.fib_rules_ops*, %struct.sock**, %struct.sock*, %struct.sock*, %struct.sock*, %struct.list_head, %struct.fib_rules_ops*, %struct.atomic_t, [20 x i8] }
%struct.netns_sysctl_ipv6 = type { %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.rt6_statistics = type opaque
%struct.dst_ops = type { i16, i16, i32, i32 (%struct.dst_ops*)*, %struct.dst_entry* (%struct.dst_entry*, i32)*, i32 (%struct.dst_entry*)*, i32 (%struct.dst_entry*)*, i32* (%struct.dst_entry*, i64)*, void (%struct.dst_entry*)*, void (%struct.dst_entry*, %struct.net_device*, i32)*, %struct.dst_entry* (%struct.dst_entry*)*, void (%struct.sk_buff*)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*, i32)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*)*, i32 (%struct.sk_buff*)*, %struct.neighbour* (%struct.dst_entry*, %struct.sk_buff*, i8*)*, %struct.kmem_cache*, [8 x i8], %struct.percpu_counter, [24 x i8] }
%struct.fib6_table = type opaque
%struct.netns_sctp = type { [1 x %struct.sctp_mib*], %struct.proc_dir_entry*, %struct.ctl_table_header*, %struct.sock*, %struct.list_head, %struct.list_head, %struct.timer_list, %struct.list_head, %struct.spinlock, %struct.spinlock, i32, i32, i32, i32, i32, i32, i32, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i64 }
%struct.sctp_mib = type opaque
%struct.netns_dccp = type { %struct.sock*, %struct.sock* }
%struct.netns_nf = type { %struct.proc_dir_entry*, [13 x %struct.nf_logger*], %struct.ctl_table_header* }
%struct.nf_logger = type opaque
%struct.netns_xt = type { [13 x %struct.list_head], i8, %struct.ebt_table*, %struct.ebt_table*, %struct.ebt_table* }
%struct.ebt_table = type opaque
%struct.netns_ct = type { %struct.atomic_t, i32, i32, %struct.kmem_cache*, %struct.hlist_nulls_head*, %struct.hlist_head*, %struct.hlist_nulls_head, %struct.hlist_nulls_head, %struct.hlist_nulls_head, %struct.ip_conntrack_stat*, %struct.nf_ct_event_notifier*, %struct.nf_exp_event_notifier*, i32, i32, i32, i32, i32, i32, i32, i8, %struct.nf_ip_net, i32, i8, %struct.hlist_head*, i32, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, i8* }
%struct.hlist_nulls_head = type { %struct.hlist_nulls_node* }
%struct.hlist_nulls_node = type { %struct.hlist_nulls_node*, %struct.hlist_nulls_node** }
%struct.ip_conntrack_stat = type opaque
%struct.nf_ct_event_notifier = type opaque
%struct.nf_exp_event_notifier = type opaque
%struct.nf_ip_net = type { %struct.nf_generic_net, %struct.nf_tcp_net, %struct.nf_udp_net, %struct.nf_generic_net, %struct.nf_generic_net, %struct.ctl_table_header*, %struct.ctl_table* }
%struct.nf_tcp_net = type { %struct.nf_proto_net, [14 x i32], i32, i32, i32 }
%struct.nf_proto_net = type { %struct.ctl_table_header*, %struct.ctl_table*, %struct.ctl_table_header*, %struct.ctl_table*, i32 }
%struct.nf_udp_net = type { %struct.nf_proto_net, [2 x i32] }
%struct.nf_generic_net = type { %struct.nf_proto_net, i32 }
%struct.netns_nf_frag = type { %struct.netns_sysctl_ipv6, [48 x i8], %struct.netns_frags }
%struct.net_generic = type { i32, %struct.callback_head, [0 x i8*] }
%struct.netns_xfrm = type { %struct.list_head, %struct.hlist_head*, %struct.hlist_head*, %struct.hlist_head*, i32, i32, %struct.work_struct, %struct.hlist_head, %struct.work_struct, %struct.__wait_queue_head, %struct.list_head, %struct.hlist_head*, i32, [6 x %struct.hlist_head], [6 x %struct.xfrm_policy_hash], [6 x i32], %struct.work_struct, %struct.sock*, %struct.sock*, i32, i32, i32, i32, %struct.ctl_table_header*, [16 x i8], %struct.dst_ops, %struct.dst_ops }
%struct.xfrm_policy_hash = type { %struct.hlist_head*, i32 }
%struct.netns_ipvs = type opaque
%union.anon.64 = type { %struct.hlist_node }
%struct.socket_lock_t = type { %struct.spinlock, i32, %struct.__wait_queue_head, %struct.lockdep_map }
%struct.anon.66 = type { %struct.atomic_t, i32, %struct.sk_buff*, %struct.sk_buff* }
%struct.sk_filter = type { %struct.atomic_t, i32, i32 (%struct.sk_buff*, %struct.sock_filter*)*, %struct.callback_head, [0 x %struct.sock_filter] }
%struct.sock_filter = type { i16, i8, i8, i32 }
%struct.socket_wq = type { %struct.__wait_queue_head, %struct.fasync_struct*, %struct.callback_head, [16 x i8] }
%struct.xfrm_policy = type opaque
%struct.dst_entry = type { %struct.callback_head, %struct.dst_entry*, %struct.net_device*, %struct.dst_ops*, i64, i64, %struct.dst_entry*, %struct.dst_entry*, %struct.xfrm_state*, i32 (%struct.sk_buff*)*, i32 (%struct.sk_buff*)*, i16, i16, i16, i16, i16, i16, i32, [2 x i64], %struct.atomic_t, i32, i64, %union.anon.58 }
%struct.xfrm_state = type opaque
%union.anon.58 = type { %struct.dst_entry* }
%struct.sk_buff_head = type { %struct.sk_buff*, %struct.sk_buff*, i32, %struct.spinlock }
%struct.proto = type { void (%struct.sock*, i64)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, i32)*, %struct.sock* (%struct.sock*, i32, i32*)*, i32 (%struct.sock*, i32, i64)*, i32 (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, i32 (%struct.sock*, i32, i32, i8*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, i32 (%struct.sock*, i32, i64)*, i32 (%struct.kiocb*, %struct.sock*, %struct.msghdr*, i64)*, i32 (%struct.kiocb*, %struct.sock*, %struct.msghdr*, i64, i32, i32, i32*)*, i32 (%struct.sock*, %struct.page*, i32, i64, i32)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, %struct.sk_buff*)*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*, i16)*, void (%struct.sock*, i32)*, i32, void (%struct.sock*)*, %struct.pgprot*, %struct.percpu_counter*, i32*, i64*, i32*, i32*, i32, i8, %struct.kmem_cache*, i32, i32, %struct.percpu_counter*, %struct.request_sock_ops*, %struct.timewait_sock_ops*, %union.anon.67, %struct.module*, [32 x i8], %struct.list_head, i32 (%struct.mem_cgroup*, %struct.cgroup_subsys*)*, void (%struct.mem_cgroup*)*, %struct.cg_proto* (%struct.mem_cgroup*)* }
%struct.kiocb = type { %struct.atomic_t, %struct.file*, %struct.kioctx*, i32 (%struct.kiocb*, %struct.sched_info*)*, void (%struct.kiocb*)*, %union.anon.57, i64, i64, i8*, i16, i64, i8*, i64, %struct.iovec, %struct.iovec*, i64, i64, %struct.list_head, %struct.eventfd_ctx* }
%struct.kioctx = type opaque
%struct.eventfd_ctx = type opaque
%struct.msghdr = type { i8*, i32, %struct.iovec*, i64, i8*, i64, i32 }
%struct.sockaddr = type { i16, [14 x i8] }
%struct.request_sock_ops = type { i32, i32, %struct.kmem_cache*, i8*, i32 (%struct.sock*, %struct.request_sock*)*, void (%struct.sock*, %struct.sk_buff*, %struct.request_sock*)*, void (%struct.sock*, %struct.sk_buff*)*, void (%struct.request_sock*)*, void (%struct.sock*, %struct.request_sock*)* }
%struct.request_sock = type { %struct.request_sock*, i16, i8, i8, i32, i32, i32, i64, %struct.request_sock_ops*, %struct.sock*, i32, i32 }
%struct.timewait_sock_ops = type { %struct.kmem_cache*, i8*, i32, i32 (%struct.sock*, %struct.sock*, i8*)*, void (%struct.sock*)* }
%union.anon.67 = type { %struct.inet_hashinfo* }
%struct.inet_hashinfo = type { %struct.inet_ehash_bucket*, %struct.spinlock*, i32, i32, %struct.inet_bind_hashbucket*, i32, %struct.kmem_cache*, [16 x i8], [32 x %struct.inet_listen_hashbucket], %struct.atomic_t, [60 x i8] }
%struct.inet_ehash_bucket = type { %struct.hlist_nulls_head, %struct.hlist_nulls_head }
%struct.inet_bind_hashbucket = type { %struct.spinlock, %struct.hlist_head }
%struct.inet_listen_hashbucket = type { %struct.spinlock, %struct.hlist_nulls_head }
%struct.mem_cgroup = type opaque
%struct.cgroup_subsys = type { %struct.cgroup_subsys_state* (%struct.cgroup*)*, i32 (%struct.cgroup*)*, void (%struct.cgroup*)*, void (%struct.cgroup*)*, i32 (%struct.cgroup*, %struct.cgroup_taskset*)*, void (%struct.cgroup*, %struct.cgroup_taskset*)*, void (%struct.cgroup*, %struct.cgroup_taskset*)*, void (%struct.task_struct*)*, void (%struct.cgroup*, %struct.cgroup*, %struct.task_struct*)*, void (%struct.cgroup*)*, i32, i32, i32, i8, i8, i8, i8*, %struct.cgroupfs_root*, %struct.list_head, %struct.idr, %struct.spinlock, %struct.list_head, %struct.cftype*, %struct.cftype_set, %struct.module* }
%struct.cgroup_subsys_state = type { %struct.cgroup*, %struct.atomic_t, i64, %struct.css_id*, %struct.work_struct }
%struct.css_id = type opaque
%struct.cgroup = type { i64, %struct.atomic_t, i32, %struct.list_head, %struct.list_head, %struct.list_head, %struct.cgroup*, %struct.dentry*, %struct.cgroup_name*, [12 x %struct.cgroup_subsys_state*], %struct.cgroupfs_root*, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.callback_head, %struct.work_struct, %struct.list_head, %struct.spinlock, %struct.simple_xattrs }
%struct.cgroup_name = type { %struct.callback_head, [0 x i8] }
%struct.simple_xattrs = type { %struct.list_head, %struct.spinlock }
%struct.cgroup_taskset = type opaque
%struct.cgroupfs_root = type { %struct.super_block*, i64, i32, i64, %struct.list_head, %struct.cgroup, i32, %struct.list_head, %struct.list_head, i64, %struct.ida, [4096 x i8], [64 x i8] }
%struct.ida = type { %struct.idr, %struct.ida_bitmap* }
%struct.ida_bitmap = type { i64, [15 x i64] }
%struct.idr = type { %struct.idr_layer*, %struct.idr_layer*, %struct.idr_layer*, i32, i32, i32, %struct.spinlock }
%struct.idr_layer = type { i32, [4 x i64], [256 x %struct.idr_layer*], i32, i32, %struct.callback_head }
%struct.cftype = type { [64 x i8], i32, i16, i64, i32, i32 (%struct.inode*, %struct.file*)*, i64 (%struct.cgroup*, %struct.cftype*, %struct.file*, i8*, i64, i64*)*, i64 (%struct.cgroup*, %struct.cftype*)*, i64 (%struct.cgroup*, %struct.cftype*)*, i32 (%struct.cgroup*, %struct.cftype*, %struct.cgroup_map_cb*)*, i32 (%struct.cgroup*, %struct.cftype*, %struct.seq_file*)*, i64 (%struct.cgroup*, %struct.cftype*, %struct.file*, i8*, i64, i64*)*, i32 (%struct.cgroup*, %struct.cftype*, i64)*, i32 (%struct.cgroup*, %struct.cftype*, i64)*, i32 (%struct.cgroup*, %struct.cftype*, i8*)*, i32 (%struct.cgroup*, i32)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.cgroup*, %struct.cftype*, %struct.eventfd_ctx*, i8*)*, void (%struct.cgroup*, %struct.cftype*, %struct.eventfd_ctx*)* }
%struct.cgroup_map_cb = type { i32 (%struct.cgroup_map_cb*, i8*, i64)*, i8* }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.cftype_set = type { %struct.list_head, %struct.cftype* }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8], %struct.lockdep_map }
%struct.tvec_base = type opaque
%struct.socket = type { i32, i16, i64, %struct.socket_wq*, %struct.file*, %struct.sock*, %struct.proto_ops* }
%struct.proto_ops = type { i32, %struct.module*, i32 (%struct.socket*)*, i32 (%struct.socket*, %struct.sockaddr*, i32)*, i32 (%struct.socket*, %struct.sockaddr*, i32, i32)*, i32 (%struct.socket*, %struct.socket*)*, i32 (%struct.socket*, %struct.socket*, i32)*, i32 (%struct.socket*, %struct.sockaddr*, i32*, i32)*, i32 (%struct.file*, %struct.socket*, %struct.poll_table_struct*)*, i32 (%struct.socket*, i32, i64)*, i32 (%struct.socket*, i32, i64)*, i32 (%struct.socket*, i32)*, i32 (%struct.socket*, i32)*, i32 (%struct.socket*, i32, i32, i8*, i32)*, i32 (%struct.socket*, i32, i32, i8*, i32*)*, i32 (%struct.socket*, i32, i32, i8*, i32)*, i32 (%struct.socket*, i32, i32, i8*, i32*)*, i32 (%struct.kiocb*, %struct.socket*, %struct.msghdr*, i64)*, i32 (%struct.kiocb*, %struct.socket*, %struct.msghdr*, i64, i32)*, i32 (%struct.file*, %struct.socket*, %struct.vm_area_struct*)*, i64 (%struct.socket*, %struct.page*, i32, i64, i32)*, i64 (%struct.socket*, i64*, %struct.pipe_inode_info*, i64, i32)*, void (%struct.sock*, i32)* }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.sk_buff = type { %struct.sk_buff*, %struct.sk_buff*, %struct.pgprot, %struct.sock*, %struct.net_device*, [48 x i8], i64, %struct.sec_path*, i32, i32, i16, i16, %struct.atomic_t, i32, i16, i16, {}*, %struct.arch_spinlock*, %struct.sk_buff*, %struct.nf_bridge_info*, i32, i32, i16, i16, i16, i16, i16, i16, i32, i32, %struct.atomic_t, i32, i32, i32, i32, i32, i32, i32, i32, i8*, i8*, i32, %struct.atomic_t }
%struct.sec_path = type opaque
%struct.nf_bridge_info = type { %struct.atomic_t, i32, %struct.net_device*, %struct.net_device*, [4 x i64] }
%struct.cg_proto = type { void (%struct.sock*)*, %struct.res_counter*, %struct.percpu_counter*, i32*, i64*, i64, %struct.mem_cgroup* }
%struct.res_counter = type { i64, i64, i64, i64, i64, %struct.spinlock, %struct.res_counter* }
%struct.sysfs_dirent = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type opaque
%struct.acpi_device_id = type opaque
%struct.driver_private = type opaque
%struct.dev_pm_info = type { %struct.atomic_t, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.pgprot, i64, i64, i64, i64, i64, i8 }
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type { %struct.pm_qos_constraints, %struct.netdev_hw_addr_list, %struct.dev_pm_qos_request*, %struct.dev_pm_qos_request* }
%struct.pm_qos_constraints = type { %union.anon.39, i32, i32, i32, %struct.blocking_notifier_head* }
%struct.blocking_notifier_head = type { %struct.rw_semaphore, %struct.notifier_block* }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.dev_pm_qos_request = type { i32, %union.anon.55, %struct.device* }
%union.anon.55 = type { %struct.plist_node }
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i8*, i64, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, %struct.dma_attrs*)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i64, i32, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, %struct.dma_attrs*)*, void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.device_node = type opaque
%union.anon.57 = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.arch_spinlock }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.iommu_group = type opaque
%struct.perf_cpu_context = type { %struct.perf_event_context, %struct.perf_event_context*, i32, i32, %struct.list_head, i32, %struct.pmu*, %struct.perf_cgroup* }
%struct.perf_event_context = type { %struct.pmu*, i32, %struct.raw_spinlock, %struct.mutex, %struct.list_head, %struct.list_head, %struct.list_head, i32, i32, i32, i32, i32, i32, %struct.atomic_t, %struct.task_struct*, i64, i64, %struct.perf_event_context*, i64, i64, i32, i32, i32, %struct.callback_head }
%struct.local64_t = type { %struct.local_t }
%struct.local_t = type { %struct.pgprot }
%struct.perf_event_attr = type { i32, i32, i64, %struct.pgprot, i64, i64, i64, %struct.atomic_t, i32, %struct.pgprot, %struct.pgprot, i64, i64, i32, i32 }
%struct.hw_perf_event = type { %union.anon.73, i32, %struct.local64_t, i64, i64, %struct.local64_t, i64, i64, i64, i64 }
%union.anon.73 = type { %struct.anon.74 }
%struct.anon.74 = type { i64, i64, i64, i64, i32, i32, i32, i32, %struct.hw_perf_event_extra, %struct.hw_perf_event_extra }
%struct.hw_perf_event_extra = type { i64, i32, i32, i32 }
%struct.ring_buffer = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.irq_work = type { i64, %struct.llist_node, void (%struct.irq_work*)* }
%struct.perf_sample_data = type { i64, i64, %struct.exception_table_entry, i64, i64, i64, i64, %struct.exception_table_entry, i64, %struct.pgprot, %struct.perf_callchain_entry*, %struct.perf_raw_record*, %struct.perf_branch_stack*, %struct.perf_regs_user, i64, i64 }
%struct.perf_callchain_entry = type { i64, [127 x i64] }
%struct.perf_raw_record = type { i32, i8* }
%struct.perf_branch_stack = type { i64, [0 x %struct.task_cputime] }
%struct.perf_regs_user = type { i64, %struct.pt_regs* }
%struct.pt_regs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.ftrace_event_call = type { %struct.list_head, %struct.ftrace_event_class*, i8*, %struct.trace_event, i8*, %struct.event_filter*, %struct.list_head*, i8*, i8*, i32, i32, %struct.hlist_head* }
%struct.ftrace_event_class = type { i8*, i8*, i8*, i32 (%struct.ftrace_event_call*, i32, i8*)*, i32 (%struct.ftrace_event_call*)*, %struct.list_head* (%struct.ftrace_event_call*)*, %struct.list_head, i32 (%struct.ftrace_event_call*)* }
%struct.trace_event = type { %struct.hlist_node, %struct.list_head, i32, %struct.trace_event_functions* }
%struct.trace_event_functions = type { i32 (%struct.trace_iterator*, i32, %struct.trace_event*)*, i32 (%struct.trace_iterator*, i32, %struct.trace_event*)*, i32 (%struct.trace_iterator*, i32, %struct.trace_event*)*, i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* }
%struct.trace_iterator = type { %struct.trace_array*, %struct.tracer*, %struct.trace_buffer*, i8*, i32, %struct.mutex, %struct.ring_buffer_iter**, i64, %struct.trace_seq, %struct.trace_seq, %struct.sock_filter*, i64, i32, i32, i32, i64, i64, i64, %struct.cpumask*, i8 }
%struct.trace_array = type opaque
%struct.tracer = type opaque
%struct.trace_buffer = type opaque
%struct.ring_buffer_iter = type opaque
%struct.trace_seq = type { [4096 x i8], i32, i32, i32 }
%struct.event_filter = type opaque
%struct.ftrace_ops = type { void (i64, i64, %struct.ftrace_ops*, %struct.pt_regs*)*, %struct.ftrace_ops*, i64, i32*, %struct.ftrace_hash*, %struct.ftrace_hash*, %struct.mutex }
%struct.ftrace_hash = type opaque
%struct.perf_cgroup = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.21, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.24 }
%union.anon.21 = type { %struct.load_weight }
%union.anon.24 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net* }
%struct.uts_namespace = type { %struct.arch_spinlock, %struct.new_utsname, %struct.user_namespace*, i32 }
%struct.new_utsname = type { [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8] }
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %struct.pgprot, [2 x %struct.if_dqinfo], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, i64, i64, i64, i64, i64, i64, %struct.load_weight, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.load_weight], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %struct.pgprot, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %struct.pgprot }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %struct.pgprot, i64 ()*, %struct.pgprot, %struct.pgprot }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %struct.pgprot, i32, i32, i64, i64, i64, %struct.pgprot, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.autogroup = type opaque
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type { i16, i32, i8, i8, i64, i64, i64, i64, i64, i64, i64, i64, [32 x i8], i8, [3 x i8], [4 x i8], i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.dma_attrs }
%struct.dma_attrs = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.dma_attrs }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.raw_spinlock = type { %struct.arch_spinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, i8* }
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.26 }
%union.anon.26 = type { %struct.anon.30, [80 x i8] }
%struct.anon.30 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.tcp_mib = type { [16 x i64] }
%struct.css_set = type { %struct.atomic_t, %struct.hlist_node, %struct.list_head, %struct.list_head, [12 x %struct.cgroup_subsys_state*], %struct.callback_head }
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %struct.atomic_t, i32, i32 }
%struct.futex_pi_state = type opaque
%struct.mempolicy = type opaque
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.load_weight, %struct.load_weight, i64, i64, i32, i32, %struct.load_weight, %struct.load_weight, i64, i32 }
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type { i64, i64, i64, i64, i64 }
%struct.memcg_batch_info = type { i32, %struct.mem_cgroup*, i64, i64 }
%struct.uprobe_task = type { i32, %struct.arch_uprobe_task, %struct.return_instance*, i32, %struct.uprobe*, i64, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.return_instance = type opaque
%struct.uprobe = type opaque
%struct.kmem_cache = type { %struct.kmem_cache_cpu*, i64, i64, i32, i32, i32, i32, %struct.pgprot, %struct.pgprot, %struct.pgprot, i32, i32, void (i8*)*, i32, i32, i32, i8*, %struct.list_head, %struct.kobject, %struct.memcg_cache_params*, i32, i32, [1024 x %struct.kmem_cache_node*] }
%struct.kmem_cache_cpu = type { i8**, i64, %struct.page*, %struct.page*, [26 x i32] }
%struct.memcg_cache_params = type { i8, %union.anon.9 }
%union.anon.9 = type { %struct.anon.10 }
%struct.anon.10 = type { %struct.mem_cgroup*, %struct.list_head, %struct.kmem_cache*, i8, %struct.atomic_t, %struct.work_struct }
%struct.kmem_cache_node = type opaque
%struct.bsd_acct_struct = type opaque
%struct.user_namespace = type { %struct.uid_gid_map, %struct.uid_gid_map, %struct.uid_gid_map, %struct.atomic_t, %struct.user_namespace*, i32, i32, i32, i8, i8 }
%struct.uid_gid_map = type { i32, [5 x %struct.dma_tx_state] }
%struct.dma_tx_state = type { i32, i32, i32 }
%struct.work_struct = type { %struct.pgprot, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.14, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %struct.pgprot, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.39, %struct.pgprot }
%union.anon.14 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.pgprot, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.pgprot }
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x i32], [0 x i32*] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [44 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.pgprot, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %struct.atomic_t, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type { i8*, i32, i64 (%struct.dentry*, i8*, i64, i8*, i64, i32)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i32 (%struct.dentry*, i8*, i8*, i64, i32, i32)* }
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head, [3 x %struct.lockdep_map] }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.device_dma_parameters*)*, i32, i64, %struct.list_head, %struct.pgprot }
%struct.load_weight = type { i64, i64 }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%union.anon.36 = type { %struct.callback_head }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%union.anon.38 = type { %struct.pipe_inode_info* }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.atomic_t = type { i32 }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.rb_root = type { %struct.rb_node* }
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8*, i8*, %struct.lockdep_map }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.read_descriptor_t = type { i64, i64, %union.anon.57, i32 }
%struct.swap_info_struct = type opaque
%struct.backing_dev_info = type opaque
%struct.spinlock = type { %union.anon.11 }
%union.anon.11 = type { %struct.raw_spinlock }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.anon.0 = type { %struct.pgprot, %struct.pgprot }
%union.anon.39 = type { %struct.list_head }
%struct.pgprot = type { i64 }
%struct.rpc_call_ops = type { void (%struct.rpc_task*, i8*)*, void (%struct.rpc_task*, i8*)*, void (%struct.rpc_task*, i8*)*, void (i8*)* }
%struct.rpc_task = type { %struct.atomic_t, %struct.list_head, %struct.rpc_clnt*, %struct.rpc_rqst*, %struct.rpc_message, void (%struct.rpc_task*)*, void (%struct.rpc_task*)*, %struct.rpc_call_ops*, i8*, i64, i64, %struct.workqueue_struct*, %struct.rpc_wait_queue*, %union.anon.69, %struct.pgprot, i32, i32, i16, i16, i16, i8 }
%struct.rpc_clnt = type { %struct.atomic_t, %struct.list_head, %struct.list_head, %struct.spinlock, %struct.rpc_xprt*, %struct.rpc_procinfo*, i32, i32, i32, i8*, %struct.rpc_auth*, %struct.rpc_stat*, %struct.rpc_iostats*, i8, %struct.rpc_rtt*, %struct.rpc_timeout*, i32, [32 x i8], %struct.dentry*, %struct.rpc_clnt*, %struct.rpc_rtt, %struct.rpc_timeout, %struct.rpc_program*, i8* }
%struct.rpc_xprt = type { %struct.atomic_t, %struct.rpc_xprt_ops*, %struct.rpc_timeout*, %struct.__kernel_sockaddr_storage, i64, i32, i64, i64, i64, i32, %struct.rpc_wait_queue, %struct.rpc_wait_queue, %struct.rpc_wait_queue, %struct.rpc_wait_queue, %struct.list_head, i32, i32, %struct.atomic_t, i64, i8, i32, i32, i64, i64, i32, %struct.work_struct, %struct.timer_list, i64, i64, %struct.spinlock, %struct.spinlock, i32, %struct.rpc_task*, %struct.svc_xprt*, %struct.svc_serv*, i32, %struct.spinlock, %struct.list_head, %struct.list_head, %struct.anon.70, %struct.net*, i8*, [6 x i8*] }
%struct.rpc_xprt_ops = type { void (%struct.rpc_xprt*, i64, i64)*, i32 (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_task*)*, void (%struct.rpc_xprt*, i16)*, void (%struct.rpc_xprt*, %struct.rpc_task*)*, i8* (%struct.rpc_task*, i64)*, void (i8*)*, i32 (%struct.rpc_task*)*, void (%struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_task*)*, void (%struct.rpc_xprt*)*, void (%struct.rpc_xprt*)*, void (%struct.rpc_xprt*, %struct.seq_file*)* }
%struct.__kernel_sockaddr_storage = type { i16, [126 x i8] }
%struct.rpc_wait_queue = type { %struct.spinlock, [4 x %struct.list_head], i32, i8, i8, i8, i16, %struct.rpc_timer, i8* }
%struct.rpc_timer = type { %struct.timer_list, %struct.list_head, i64 }
%struct.svc_xprt = type { %struct.svc_xprt_class*, %struct.svc_xprt_ops*, %struct.arch_spinlock, %struct.list_head, %struct.list_head, i64, %struct.svc_serv*, %struct.atomic_t, %struct.mutex, %struct.spinlock, i8*, %struct.list_head, %struct.__kernel_sockaddr_storage, i64, %struct.__kernel_sockaddr_storage, i64, %struct.rpc_wait_queue, %struct.list_head, %struct.net*, %struct.rpc_xprt* }
%struct.svc_xprt_class = type { i8*, %struct.module*, %struct.svc_xprt_ops*, %struct.list_head, i32 }
%struct.svc_xprt_ops = type { %struct.svc_xprt* (%struct.svc_serv*, %struct.net*, %struct.sockaddr*, i32, i32)*, %struct.svc_xprt* (%struct.svc_xprt*)*, i32 (%struct.svc_xprt*)*, i32 (%struct.svc_rqst*)*, void (%struct.svc_rqst*)*, i32 (%struct.svc_rqst*)*, void (%struct.svc_rqst*)*, void (%struct.svc_xprt*)*, void (%struct.svc_xprt*)* }
%struct.svc_rqst = type { %struct.list_head, %struct.list_head, %struct.svc_xprt*, %struct.__kernel_sockaddr_storage, i64, %struct.__kernel_sockaddr_storage, i64, %struct.svc_serv*, %struct.svc_pool*, %struct.svc_procedure*, %struct.auth_ops*, %struct.svc_cred, i8*, %struct.svc_deferred_req*, i32, i64, %struct.xdr_buf, %struct.xdr_buf, [259 x %struct.page*], %struct.page**, i32, %struct.page**, [259 x %struct.iovec], i32, i32, i32, i32, i32, i8, i8*, i8*, i8*, i32, %struct.cache_req, i8, %struct.auth_domain*, %struct.auth_domain*, i32, %struct.svc_cacherep*, i32, %struct.__wait_queue_head, %struct.task_struct* }
%struct.svc_pool = type { i32, %struct.spinlock, %struct.list_head, %struct.list_head, i32, %struct.list_head, %struct.sched_info, i32, [20 x i8] }
%struct.svc_procedure = type { i32 (%struct.svc_rqst*, i8*, i8*)*, i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)*, i32, i32, i32, i32, i32 }
%struct.auth_ops = type { i8*, %struct.module*, i32, i32 (%struct.svc_rqst*, i32*)*, i32 (%struct.svc_rqst*)*, void (%struct.auth_domain*)*, i32 (%struct.svc_rqst*)* }
%struct.svc_cred = type { i32, i32, %struct.group_info*, i32, i8* }
%struct.svc_deferred_req = type { i32, %struct.svc_xprt*, %struct.__kernel_sockaddr_storage, i64, %struct.__kernel_sockaddr_storage, i64, %struct.cache_deferred_req, i64, i32, [0 x i32] }
%struct.cache_deferred_req = type { %struct.hlist_node, %struct.list_head, %struct.cache_head*, i8*, void (%struct.cache_deferred_req*, i32)* }
%struct.cache_head = type { %struct.cache_head*, i64, i64, %struct.arch_spinlock, i64 }
%struct.cache_req = type { %struct.cache_deferred_req* (%struct.cache_req*)*, i32 }
%struct.auth_domain = type { %struct.arch_spinlock, %struct.hlist_node, i8*, %struct.auth_ops* }
%struct.svc_cacherep = type opaque
%struct.svc_serv = type { %struct.svc_program*, %struct.svc_stat*, %struct.spinlock, i32, i32, i32, i32, i32, %struct.list_head, %struct.list_head, i32, %struct.timer_list, i8*, i32, %struct.svc_pool*, void (%struct.svc_serv*, %struct.net*)*, %struct.module*, i32 (i8*)*, %struct.list_head, %struct.spinlock, %struct.__wait_queue_head, %struct.svc_xprt* }
%struct.svc_program = type { %struct.svc_program*, i32, i32, i32, i32, %struct.svc_version**, i8*, i8*, %struct.svc_stat*, i32 (%struct.svc_rqst*)* }
%struct.svc_version = type { i32, i32, %struct.svc_procedure*, i32, i8, i32 (%struct.svc_rqst*, i32*)* }
%struct.svc_stat = type { %struct.svc_program*, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.anon.70 = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.rpc_auth = type { i32, i32, i32, i32, %struct.rpc_authops*, i32, %struct.atomic_t, %struct.rpc_cred_cache* }
%struct.rpc_authops = type { %struct.module*, i32, i8*, %struct.rpc_auth* (%struct.rpc_clnt*, i32)*, void (%struct.rpc_auth*)*, %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)*, %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)*, i32 (%struct.rpc_auth*)*, void (%struct.rpc_auth*)*, i32 (i32*, i32)*, i32 (%struct.rpcsec_gss_info*)*, i32 (i32, %struct.rpcsec_gss_info*)* }
%struct.rpc_cred = type { %struct.hlist_node, %struct.list_head, %struct.callback_head, %struct.rpc_auth*, %struct.rpc_credops*, i64, i64, i64, %struct.atomic_t, i32 }
%struct.rpc_credops = type { i8*, i32 (%struct.rpc_auth*, %struct.rpc_cred*)*, void (%struct.rpc_cred*)*, i32 (%struct.auth_cred*, %struct.rpc_cred*, i32)*, %struct.rpc_cred* (%struct.rpc_task*, %struct.rpc_cred*, i32)*, i32* (%struct.rpc_task*, i32*)*, i32 (%struct.rpc_task*)*, i32* (%struct.rpc_task*, i32*)*, i32 (%struct.rpc_task*, void (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)*, i32 (%struct.rpc_task*, i32 (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)* }
%struct.auth_cred = type { i32, i32, %struct.group_info*, i8*, i8 }
%struct.rpcsec_gss_info = type { %struct.rpcsec_gss_oid, i32, i32 }
%struct.rpcsec_gss_oid = type { i32, [32 x i8] }
%struct.rpc_cred_cache = type { %struct.hlist_head*, i32, %struct.spinlock }
%struct.rpc_stat = type { %struct.rpc_program*, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.rpc_iostats = type { i64, i64, i64, i64, i64, %struct.pgprot, %struct.pgprot, %struct.pgprot }
%struct.rpc_rtt = type { i64, [5 x i64], [5 x i64], [5 x i32] }
%struct.rpc_timeout = type { i64, i64, i64, i32, i8 }
%struct.rpc_program = type { i8*, i32, i32, %struct.rpc_version**, %struct.rpc_stat*, i8* }
%struct.rpc_version = type { i32, i32, %struct.rpc_procinfo* }
%struct.rpc_rqst = type { %struct.rpc_xprt*, %struct.xdr_buf, %struct.xdr_buf, %struct.rpc_task*, %struct.rpc_cred*, i32, i32, i32, i32, %struct.page**, void (%struct.rpc_rqst*)*, %struct.list_head, i32*, i64, i64, i64, i64, %struct.xdr_buf, i64, i64, %struct.pgprot, i32, i32, i32, %struct.pgprot, i32, %struct.list_head, i64, %struct.list_head }
%struct.rpc_message = type { %struct.rpc_procinfo*, i8*, i8*, %struct.rpc_cred* }
%union.anon.69 = type { %struct.work_struct }
%struct.pv_irq_ops = type { %union.anon.57, %union.anon.57, %union.anon.57, %union.anon.57, void ()*, void ()*, void ()* }
%struct.sockaddr_in = type { i16, i16, %struct.atomic_t, [8 x i8] }
%struct.xprt_class = type { %struct.list_head, i32, %struct.rpc_xprt* (%struct.xprt_create*)*, %struct.module*, [32 x i8] }
%struct.xprt_create = type { i32, %struct.net*, %struct.sockaddr*, %struct.sockaddr*, i64, i8*, %struct.svc_xprt*, i32 }
%struct.mempool_s = type { %struct.spinlock, i32, i32, i8**, i8*, i8* (i32, i8*)*, void (i8*, i8*)*, %struct.__wait_queue_head }
%struct.rpc_auth.2960 = type { i32, i32, i32, i32, %struct.rpc_authops.2961*, i32, %struct.atomic_t, %struct.rpc_cred_cache* }
%struct.rpc_authops.2961 = type { %struct.module*, i32, i8*, {}*, void (%struct.rpc_auth.2960*)*, %struct.rpc_cred.2963* (%struct.rpc_auth.2960*, %struct.auth_cred*, i32)*, %struct.rpc_cred.2963* (%struct.rpc_auth.2960*, %struct.auth_cred*, i32)*, i32 (%struct.rpc_auth.2960*)*, void (%struct.rpc_auth.2960*)*, i32 (i32*, i32)*, i32 (%struct.rpcsec_gss_info*)*, i32 (i32, %struct.rpcsec_gss_info*)* }
%struct.rpc_clnt.2966 = type { %struct.atomic_t, %struct.list_head, %struct.list_head, %struct.spinlock, %struct.rpc_xprt.2967*, %struct.rpc_procinfo*, i32, i32, i32, i8*, %struct.rpc_auth.2960*, %struct.rpc_stat*, %struct.rpc_iostats*, i8, %struct.rpc_rtt*, %struct.rpc_timeout*, i32, [32 x i8], %struct.dentry*, %struct.rpc_clnt.2966*, %struct.rpc_rtt, %struct.rpc_timeout, %struct.rpc_program*, i8* }
%struct.rpc_xprt.2967 = type { %struct.atomic_t, %struct.rpc_xprt_ops.2974*, %struct.rpc_timeout*, %struct.__kernel_sockaddr_storage, i64, i32, i64, i64, i64, i32, %struct.rpc_wait_queue, %struct.rpc_wait_queue, %struct.rpc_wait_queue, %struct.rpc_wait_queue, %struct.list_head, i32, i32, %struct.atomic_t, i64, i8, i32, i32, i64, i64, i32, %struct.work_struct, %struct.timer_list, i64, i64, %struct.spinlock, %struct.spinlock, i32, %struct.rpc_task.2977*, %struct.svc_xprt*, %struct.svc_serv*, i32, %struct.spinlock, %struct.list_head, %struct.list_head, %struct.anon.70, %struct.net*, i8*, [6 x i8*] }
%struct.rpc_xprt_ops.2974 = type { void (%struct.rpc_xprt.2967*, i64, i64)*, i32 (%struct.rpc_xprt.2967*, %struct.rpc_task.2977*)*, void (%struct.rpc_xprt.2967*, %struct.rpc_task.2977*)*, void (%struct.rpc_xprt.2967*, %struct.rpc_task.2977*)*, void (%struct.rpc_task.2977*)*, void (%struct.rpc_xprt.2967*, i16)*, void (%struct.rpc_xprt.2967*, %struct.rpc_task.2977*)*, i8* (%struct.rpc_task.2977*, i64)*, void (i8*)*, i32 (%struct.rpc_task.2977*)*, void (%struct.rpc_task.2977*)*, void (%struct.rpc_xprt.2967*, %struct.rpc_task.2977*)*, void (%struct.rpc_task.2977*)*, void (%struct.rpc_xprt.2967*)*, void (%struct.rpc_xprt.2967*)*, void (%struct.rpc_xprt.2967*, %struct.seq_file*)* }
%struct.rpc_task.2977 = type { %struct.atomic_t, %struct.list_head, %struct.rpc_clnt.2966*, %struct.rpc_rqst.2981*, %struct.rpc_message.2982, void (%struct.rpc_task.2977*)*, void (%struct.rpc_task.2977*)*, %struct.rpc_call_ops.2983*, i8*, i64, i64, %struct.workqueue_struct*, %struct.rpc_wait_queue*, %union.anon.69, %struct.pgprot, i32, i32, i16, i16, i16, i8 }
%struct.rpc_rqst.2981 = type { %struct.rpc_xprt.2967*, %struct.xdr_buf, %struct.xdr_buf, %struct.rpc_task.2977*, %struct.rpc_cred.2963*, i32, i32, i32, i32, %struct.page**, void (%struct.rpc_rqst.2981*)*, %struct.list_head, i32*, i64, i64, i64, i64, %struct.xdr_buf, i64, i64, %struct.pgprot, i32, i32, i32, %struct.pgprot, i32, %struct.list_head, i64, %struct.list_head }
%struct.rpc_cred.2963 = type { %struct.hlist_node, %struct.list_head, %struct.callback_head, %struct.rpc_auth.2960*, %struct.rpc_credops.2985*, i64, i64, i64, %struct.atomic_t, i32 }
%struct.rpc_credops.2985 = type { i8*, i32 (%struct.rpc_auth.2960*, %struct.rpc_cred.2963*)*, void (%struct.rpc_cred.2963*)*, i32 (%struct.auth_cred*, %struct.rpc_cred.2963*, i32)*, %struct.rpc_cred.2963* (%struct.rpc_task.2977*, %struct.rpc_cred.2963*, i32)*, i32* (%struct.rpc_task.2977*, i32*)*, i32 (%struct.rpc_task.2977*)*, i32* (%struct.rpc_task.2977*, i32*)*, i32 (%struct.rpc_task.2977*, void (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)*, i32 (%struct.rpc_task.2977*, i32 (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)* }
%struct.rpc_message.2982 = type { %struct.rpc_procinfo*, i8*, i8*, %struct.rpc_cred.2963* }
%struct.rpc_call_ops.2983 = type { void (%struct.rpc_task.2977*, i8*)*, void (%struct.rpc_task.2977*, i8*)*, void (%struct.rpc_task.2977*, i8*)*, void (i8*)* }
%struct.rpc_auth.2989 = type { i32, i32, i32, i32, %struct.rpc_authops.2990*, i32, %struct.atomic_t, %struct.rpc_cred_cache* }
%struct.rpc_authops.2990 = type { %struct.module*, i32, i8*, %struct.rpc_auth.2989* (%struct.rpc_clnt.2994*, i32)*, void (%struct.rpc_auth.2989*)*, %struct.rpc_cred.2995* (%struct.rpc_auth.2989*, %struct.auth_cred*, i32)*, %struct.rpc_cred.2995* (%struct.rpc_auth.2989*, %struct.auth_cred*, i32)*, {}*, void (%struct.rpc_auth.2989*)*, i32 (i32*, i32)*, i32 (%struct.rpcsec_gss_info*)*, i32 (i32, %struct.rpcsec_gss_info*)* }
%struct.rpc_clnt.2994 = type { %struct.atomic_t, %struct.list_head, %struct.list_head, %struct.spinlock, %struct.rpc_xprt.3466*, %struct.rpc_procinfo*, i32, i32, i32, i8*, %struct.rpc_auth.2989*, %struct.rpc_stat*, %struct.rpc_iostats*, i8, %struct.rpc_rtt*, %struct.rpc_timeout*, i32, [32 x i8], %struct.dentry*, %struct.rpc_clnt.2994*, %struct.rpc_rtt, %struct.rpc_timeout, %struct.rpc_program*, i8* }
%struct.rpc_xprt.3466 = type { %struct.atomic_t, %struct.rpc_xprt_ops.3473*, %struct.rpc_timeout*, %struct.__kernel_sockaddr_storage, i64, i32, i64, i64, i64, i32, %struct.rpc_wait_queue, %struct.rpc_wait_queue, %struct.rpc_wait_queue, %struct.rpc_wait_queue, %struct.list_head, i32, i32, %struct.atomic_t, i64, i8, i32, i32, i64, i64, i32, %struct.work_struct, %struct.timer_list, i64, i64, %struct.spinlock, %struct.spinlock, i32, %struct.rpc_task.3476*, %struct.svc_xprt*, %struct.svc_serv*, i32, %struct.spinlock, %struct.list_head, %struct.list_head, %struct.anon.70, %struct.net*, i8*, [6 x i8*] }
%struct.rpc_xprt_ops.3473 = type { void (%struct.rpc_xprt.3466*, i64, i64)*, i32 (%struct.rpc_xprt.3466*, %struct.rpc_task.3476*)*, void (%struct.rpc_xprt.3466*, %struct.rpc_task.3476*)*, void (%struct.rpc_xprt.3466*, %struct.rpc_task.3476*)*, void (%struct.rpc_task.3476*)*, void (%struct.rpc_xprt.3466*, i16)*, void (%struct.rpc_xprt.3466*, %struct.rpc_task.3476*)*, i8* (%struct.rpc_task.3476*, i64)*, void (i8*)*, i32 (%struct.rpc_task.3476*)*, void (%struct.rpc_task.3476*)*, void (%struct.rpc_xprt.3466*, %struct.rpc_task.3476*)*, void (%struct.rpc_task.3476*)*, void (%struct.rpc_xprt.3466*)*, void (%struct.rpc_xprt.3466*)*, void (%struct.rpc_xprt.3466*, %struct.seq_file*)* }
%struct.rpc_task.3476 = type { %struct.atomic_t, %struct.list_head, %struct.rpc_clnt.2994*, %struct.rpc_rqst.3481*, %struct.rpc_message.3482, void (%struct.rpc_task.3476*)*, void (%struct.rpc_task.3476*)*, %struct.rpc_call_ops.3483*, i8*, i64, i64, %struct.workqueue_struct*, %struct.rpc_wait_queue*, %union.anon.69, %struct.pgprot, i32, i32, i16, i16, i16, i8 }
%struct.rpc_rqst.3481 = type { %struct.rpc_xprt.3466*, %struct.xdr_buf, %struct.xdr_buf, %struct.rpc_task.3476*, %struct.rpc_cred.2995*, i32, i32, i32, i32, %struct.page**, void (%struct.rpc_rqst.3481*)*, %struct.list_head, i32*, i64, i64, i64, i64, %struct.xdr_buf, i64, i64, %struct.pgprot, i32, i32, i32, %struct.pgprot, i32, %struct.list_head, i64, %struct.list_head }
%struct.rpc_cred.2995 = type { %struct.hlist_node, %struct.list_head, %struct.callback_head, %struct.rpc_auth.2989*, %struct.rpc_credops.3486*, i64, i64, i64, %struct.atomic_t, i32 }
%struct.rpc_credops.3486 = type { i8*, i32 (%struct.rpc_auth.2989*, %struct.rpc_cred.2995*)*, void (%struct.rpc_cred.2995*)*, i32 (%struct.auth_cred*, %struct.rpc_cred.2995*, i32)*, %struct.rpc_cred.2995* (%struct.rpc_task.3476*, %struct.rpc_cred.2995*, i32)*, i32* (%struct.rpc_task.3476*, i32*)*, i32 (%struct.rpc_task.3476*)*, i32* (%struct.rpc_task.3476*, i32*)*, i32 (%struct.rpc_task.3476*, void (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)*, i32 (%struct.rpc_task.3476*, i32 (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)* }
%struct.rpc_message.3482 = type { %struct.rpc_procinfo*, i8*, i8*, %struct.rpc_cred.2995* }
%struct.rpc_call_ops.3483 = type { void (%struct.rpc_task.3476*, i8*)*, void (%struct.rpc_task.3476*, i8*)*, void (%struct.rpc_task.3476*, i8*)*, void (i8*)* }
%struct.svc_pool_map = type { i32, i32, i32, i32*, i32* }
%struct.pglist_data = type { [4 x %struct.zone], [2 x %struct.zonelist], i32, %struct.spinlock, i64, i64, i64, i32, %struct.tcp_mib, %struct.__wait_queue_head, %struct.__wait_queue_head, %struct.task_struct*, i32, i32, %struct.spinlock, i64, i64, [2488 x i8] }
%struct.zone = type { [3 x i64], i64, [4 x i64], i64, i32, i64, i64, %struct.per_cpu_pageset*, %struct.spinlock, i32, i8, i64, i64, %struct.seqlock_t, [11 x %struct.free_area], i32, i32, i32, [2836 x i8], %struct.zone_padding, %struct.spinlock, %struct.lruvec, i64, i64, [34 x %struct.pgprot], i32, [3612 x i8], %struct.zone_padding, %struct.__wait_queue_head*, i64, i64, %struct.pglist_data*, i64, i64, i64, i64, i8*, [4024 x i8] }
%struct.per_cpu_pageset = type { %struct.per_cpu_pages, i8, i8, [34 x i8] }
%struct.per_cpu_pages = type { i32, i32, i32, [3 x %struct.list_head] }
%struct.free_area = type { [5 x %struct.list_head], i64 }
%struct.lruvec = type { [5 x %struct.list_head], %struct.zone_reclaim_stat, %struct.zone* }
%struct.zone_reclaim_stat = type { [2 x i64], [2 x i64] }
%struct.zone_padding = type { [0 x i8] }
%struct.zonelist = type { %struct.zonelist_cache*, [4097 x %struct.zoneref], %struct.zonelist_cache }
%struct.zoneref = type { %struct.zone*, i32 }
%struct.zonelist_cache = type { [4096 x i16], [64 x i64], i64 }
%struct.auth_ops.5094 = type { i8*, %struct.module*, i32, {}*, i32 (%struct.svc_rqst.5096*)*, void (%struct.auth_domain.5097*)*, i32 (%struct.svc_rqst.5096*)* }
%struct.auth_domain.5097 = type { %struct.arch_spinlock, %struct.hlist_node, i8*, %struct.auth_ops.5094* }
%struct.svc_rqst.5096 = type { %struct.list_head, %struct.list_head, %struct.svc_xprt.5126*, %struct.__kernel_sockaddr_storage, i64, %struct.__kernel_sockaddr_storage, i64, %struct.svc_serv.5128*, %struct.svc_pool*, %struct.svc_procedure.5130*, %struct.auth_ops.5094*, %struct.svc_cred, i8*, %struct.svc_deferred_req.5132*, i32, i64, %struct.xdr_buf, %struct.xdr_buf, [259 x %struct.page*], %struct.page**, i32, %struct.page**, [259 x %struct.iovec], i32, i32, i32, i32, i32, i8, i8*, i8*, i8*, i32, %struct.cache_req, i8, %struct.auth_domain.5097*, %struct.auth_domain.5097*, i32, %struct.svc_cacherep*, i32, %struct.__wait_queue_head, %struct.task_struct* }
%struct.svc_xprt.5126 = type { %struct.svc_xprt_class.5138*, %struct.svc_xprt_ops.5139*, %struct.arch_spinlock, %struct.list_head, %struct.list_head, i64, %struct.svc_serv.5128*, %struct.atomic_t, %struct.mutex, %struct.spinlock, i8*, %struct.list_head, %struct.__kernel_sockaddr_storage, i64, %struct.__kernel_sockaddr_storage, i64, %struct.rpc_wait_queue, %struct.list_head, %struct.net*, %struct.rpc_xprt* }
%struct.svc_xprt_class.5138 = type { i8*, %struct.module*, %struct.svc_xprt_ops.5139*, %struct.list_head, i32 }
%struct.svc_xprt_ops.5139 = type { %struct.svc_xprt.5126* (%struct.svc_serv.5128*, %struct.net*, %struct.sockaddr*, i32, i32)*, %struct.svc_xprt.5126* (%struct.svc_xprt.5126*)*, i32 (%struct.svc_xprt.5126*)*, i32 (%struct.svc_rqst.5096*)*, void (%struct.svc_rqst.5096*)*, i32 (%struct.svc_rqst.5096*)*, void (%struct.svc_rqst.5096*)*, void (%struct.svc_xprt.5126*)*, void (%struct.svc_xprt.5126*)* }
%struct.svc_serv.5128 = type { %struct.svc_program.5148*, %struct.svc_stat*, %struct.spinlock, i32, i32, i32, i32, i32, %struct.list_head, %struct.list_head, i32, %struct.timer_list, i8*, i32, %struct.svc_pool*, void (%struct.svc_serv.5128*, %struct.net*)*, %struct.module*, i32 (i8*)*, %struct.list_head, %struct.spinlock, %struct.__wait_queue_head, %struct.svc_xprt.5126* }
%struct.svc_program.5148 = type { %struct.svc_program.5148*, i32, i32, i32, i32, %struct.svc_version.5150**, i8*, i8*, %struct.svc_stat*, i32 (%struct.svc_rqst.5096*)* }
%struct.svc_version.5150 = type { i32, i32, %struct.svc_procedure.5130*, i32, i8, {}* }
%struct.svc_procedure.5130 = type { i32 (%struct.svc_rqst.5096*, i8*, i8*)*, i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)*, i32, i32, i32, i32, i32 }
%struct.svc_deferred_req.5132 = type { i32, %struct.svc_xprt.5126*, %struct.__kernel_sockaddr_storage, i64, %struct.__kernel_sockaddr_storage, i64, %struct.cache_deferred_req, i64, i32, [0 x i32] }
%struct.auth_ops.5257 = type { i8*, %struct.module*, i32, i32 (%struct.svc_rqst.5259*, i32*)*, i32 (%struct.svc_rqst.5259*)*, void (%struct.auth_domain.5260*)*, i32 (%struct.svc_rqst.5259*)* }
%struct.svc_rqst.5259 = type { %struct.list_head, %struct.list_head, %struct.svc_xprt.5727*, %struct.__kernel_sockaddr_storage, i64, %struct.__kernel_sockaddr_storage, i64, %struct.svc_serv.5729*, %struct.svc_pool*, %struct.svc_procedure.5731*, %struct.auth_ops.5257*, %struct.svc_cred, i8*, %struct.svc_deferred_req.5733*, i32, i64, %struct.xdr_buf, %struct.xdr_buf, [259 x %struct.page*], %struct.page**, i32, %struct.page**, [259 x %struct.iovec], i32, i32, i32, i32, i32, i8, i8*, i8*, i8*, i32, %struct.cache_req, i8, %struct.auth_domain.5260*, %struct.auth_domain.5260*, i32, %struct.svc_cacherep*, i32, %struct.__wait_queue_head, %struct.task_struct* }
%struct.svc_xprt.5727 = type { %struct.svc_xprt_class.5737*, %struct.svc_xprt_ops.5738*, %struct.arch_spinlock, %struct.list_head, %struct.list_head, i64, %struct.svc_serv.5729*, %struct.atomic_t, %struct.mutex, %struct.spinlock, i8*, %struct.list_head, %struct.__kernel_sockaddr_storage, i64, %struct.__kernel_sockaddr_storage, i64, %struct.rpc_wait_queue, %struct.list_head, %struct.net*, %struct.rpc_xprt* }
%struct.svc_xprt_class.5737 = type { i8*, %struct.module*, %struct.svc_xprt_ops.5738*, %struct.list_head, i32 }
%struct.svc_xprt_ops.5738 = type { %struct.svc_xprt.5727* (%struct.svc_serv.5729*, %struct.net*, %struct.sockaddr*, i32, i32)*, %struct.svc_xprt.5727* (%struct.svc_xprt.5727*)*, i32 (%struct.svc_xprt.5727*)*, i32 (%struct.svc_rqst.5259*)*, void (%struct.svc_rqst.5259*)*, i32 (%struct.svc_rqst.5259*)*, void (%struct.svc_rqst.5259*)*, void (%struct.svc_xprt.5727*)*, void (%struct.svc_xprt.5727*)* }
%struct.svc_serv.5729 = type { %struct.svc_program.5742*, %struct.svc_stat*, %struct.spinlock, i32, i32, i32, i32, i32, %struct.list_head, %struct.list_head, i32, %struct.timer_list, i8*, i32, %struct.svc_pool*, void (%struct.svc_serv.5729*, %struct.net*)*, %struct.module*, i32 (i8*)*, %struct.list_head, %struct.spinlock, %struct.__wait_queue_head, %struct.svc_xprt.5727* }
%struct.svc_program.5742 = type { %struct.svc_program.5742*, i32, i32, i32, i32, %struct.svc_version.5744**, i8*, i8*, %struct.svc_stat*, i32 (%struct.svc_rqst.5259*)* }
%struct.svc_version.5744 = type { i32, i32, %struct.svc_procedure.5731*, i32, i8, {}* }
%struct.svc_procedure.5731 = type { i32 (%struct.svc_rqst.5259*, i8*, i8*)*, i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)*, i32, i32, i32, i32, i32 }
%struct.svc_deferred_req.5733 = type { i32, %struct.svc_xprt.5727*, %struct.__kernel_sockaddr_storage, i64, %struct.__kernel_sockaddr_storage, i64, %struct.cache_deferred_req, i64, i32, [0 x i32] }
%struct.auth_domain.5260 = type { %struct.arch_spinlock, %struct.hlist_node, i8*, %struct.auth_ops.5257* }
%struct.cache_detail = type { %struct.module*, i32, %struct.cache_head**, %struct.rwlock_t, %struct.atomic_t, i8*, void (%struct.arch_spinlock*)*, i32 (%struct.cache_detail*, %struct.cache_head*)*, void (%struct.cache_detail*, %struct.cache_head*, i8**, i32*)*, i32 (%struct.cache_detail*, i8*, i32)*, i32 (%struct.seq_file*, %struct.cache_detail*, %struct.cache_head*)*, void (%struct.cache_detail*, i32)*, %struct.cache_head* ()*, i32 (%struct.cache_head*, %struct.cache_head*)*, void (%struct.cache_head*, %struct.cache_head*)*, void (%struct.cache_head*, %struct.cache_head*)*, i64, %struct.list_head, i64, i32, %struct.list_head, %struct.atomic_t, i64, i64, %union.anon.71, %struct.net* }
%union.anon.71 = type { %struct.cache_detail_procfs }
%struct.cache_detail_procfs = type { %struct.proc_dir_entry*, %struct.proc_dir_entry*, %struct.proc_dir_entry*, %struct.proc_dir_entry* }
%struct.rpcb_info = type { i32, %struct.rpc_procinfo* }
%struct.sockaddr_un = type { i16, [108 x i8] }
%struct.pernet_operations = type { %struct.list_head, i32 (%struct.net*)*, void (%struct.net*)*, void (%struct.list_head*)*, i32*, i64 }
%struct.rpc_filelist = type { i8*, %struct.file_operations*, i16 }
%struct.rpc_task_setup = type { %struct.rpc_task*, %struct.rpc_clnt*, %struct.rpc_message*, %struct.rpc_call_ops*, i8*, %struct.workqueue_struct*, i16, i8 }
%struct.thread_info = type { %struct.task_struct*, %struct.exec_domain*, i32, i32, i32, i32, %struct.pgprot, %struct.restart_block, i8*, i8 }
%struct.exec_domain = type { i8*, void (i32, %struct.pt_regs*)*, i8, i8, i64*, i64*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.module*, %struct.exec_domain* }
%struct.map_segment = type opaque
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.72 }
%union.anon.72 = type { %struct.anon.73 }
%struct.anon.73 = type { i32*, i32, i32, i32, i64, i32* }
%struct.sunrpc_net = type { %struct.proc_dir_entry*, %struct.cache_detail*, %struct.cache_detail*, %struct.cache_detail*, %struct.cache_detail*, %struct.super_block*, %struct.mutex, %struct.list_head, %struct.spinlock, %struct.rpc_clnt*, %struct.rpc_clnt*, %struct.spinlock, i32, %struct.mutex, %struct.__wait_queue_head, %struct.rpc_clnt*, i32, i32, %struct.atomic_t, %struct.proc_dir_entry*, i32 }
%struct.sockaddr_in6 = type { i16, i16, i32, %struct.in6_addr, i32 }
%struct.rpc_create_args = type { %struct.net*, i32, %struct.sockaddr*, i64, %struct.sockaddr*, %struct.rpc_timeout*, i8*, %struct.rpc_program*, i32, i32, i32, i64, i8*, %struct.svc_xprt* }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }
%struct.xdr_skb_reader = type { %struct.sk_buff*, i32, i64, i32 }
%struct.sock_xprt = type { %struct.rpc_xprt, %struct.socket*, %struct.sock*, i32, i32, i32, i32, i32, i64, i64, %struct.delayed_work, %struct.__kernel_sockaddr_storage, i16, i64, i64, void (%struct.sock*, i32)*, void (%struct.sock*)*, void (%struct.sock*)* }
%struct.svc_sock = type { %struct.svc_xprt, %struct.socket*, %struct.sock*, void (%struct.sock*)*, void (%struct.sock*, i32)*, void (%struct.sock*)*, i32, i32, i32, [259 x %struct.page*] }
%struct.rpc_buffer = type { i64, [0 x i8] }
%struct.tcp_sock = type { %struct.inet_connection_sock, i16, i16, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.list_head, i64, %struct.anon.90, i32, i32, i32, i32, i32, i32, i16, i8, i8, i8, i8, i32, i32, i32, i32, i32, i32, i32, i32, i16, i8, i8, i32, i8, %struct.tcp_options_received, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.sk_buff*, %struct.sk_buff*, %struct.sk_buff*, %struct.sk_buff_head, [1 x %struct.exception_table_entry], [4 x %struct.exception_table_entry], [4 x %struct.exception_table_entry], %struct.sk_buff*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.dma_tx_state, %struct.dma_tx_state, %struct.exception_table_entry, i32, %struct.tcp_sock_af_ops*, %struct.tcp_md5sig_info*, %struct.tcp_fastopen_request*, %struct.request_sock* }
%struct.inet_connection_sock = type { %struct.inet_sock, %struct.request_sock_queue, %struct.inet_bind_bucket*, i64, %struct.timer_list, %struct.timer_list, i32, i32, %struct.tcp_congestion_ops*, %struct.inet_connection_sock_af_ops*, i32 (%struct.sock*, i32)*, i8, i8, i8, i8, i8, i8, i16, %struct.anon.88, %struct.ethtool_pauseparam, [16 x i32], i32 }
%struct.inet_sock = type { %struct.sock, %struct.ipv6_pinfo*, i32, i16, i16, i16, i16, %struct.ip_options_rcu*, i32, i8, i8, i8, i8, i8, i8, i32, i32, i32, %struct.ip_mc_socklist*, %struct.inet_cork_full }
%struct.ipv6_pinfo = type { %struct.in6_addr, %struct.in6_addr, %struct.in6_addr, %struct.in6_pktinfo, %struct.in6_addr*, %struct.in6_addr*, i32, i32, i32, i32, i32, %union.anon.79, i16, i8, i8, i8, i32, i32, %struct.ipv6_mc_socklist*, %struct.ipv6_ac_socklist*, %struct.ipv6_fl_socklist*, %struct.ipv6_txoptions*, %struct.sk_buff*, %struct.sk_buff*, %struct.anon.82 }
%struct.in6_pktinfo = type { %struct.in6_addr, i32 }
%union.anon.79 = type { %struct.anon.80 }
%struct.anon.80 = type { i16 }
%struct.ipv6_mc_socklist = type { %struct.in6_addr, i32, %struct.ipv6_mc_socklist*, %struct.rwlock_t, i32, %struct.ip6_sf_socklist*, %struct.callback_head }
%struct.ip6_sf_socklist = type { i32, i32, [0 x %struct.in6_addr] }
%struct.ipv6_ac_socklist = type { %struct.in6_addr, i32, %struct.ipv6_ac_socklist* }
%struct.ipv6_fl_socklist = type { %struct.ipv6_fl_socklist*, %struct.ip6_flowlabel*, %struct.callback_head }
%struct.ip6_flowlabel = type { %struct.ip6_flowlabel*, i32, %struct.atomic_t, %struct.in6_addr, %struct.ipv6_txoptions*, i64, %struct.callback_head, i8, %union.anon.81, i64, i64, %struct.net* }
%union.anon.81 = type { %struct.pid* }
%struct.ipv6_txoptions = type { i32, i16, i16, %struct.dcb_peer_app_info*, %struct.dcb_peer_app_info*, %struct.cee_pfc*, %struct.dcb_peer_app_info* }
%struct.anon.82 = type { %struct.ipv6_txoptions*, i8, i8 }
%struct.ip_options_rcu = type { %struct.callback_head, %struct.ip_options }
%struct.ip_options = type { i32, i32, i8, i8, i8, i8, i8, i8, i8, i8, [0 x i8] }
%struct.ip_mc_socklist = type opaque
%struct.inet_cork_full = type { %struct.inet_cork, %struct.flowi }
%struct.inet_cork = type { i32, i32, %struct.ip_options*, i32, i32, %struct.dst_entry*, i8 }
%struct.flowi = type { %union.anon.83 }
%union.anon.83 = type { %struct.flowi6 }
%struct.flowi6 = type { %struct.flowi_common, %struct.in6_addr, %struct.in6_addr, i32, %struct.atomic_t, [4 x i8] }
%struct.flowi_common = type { i32, i32, i32, i8, i8, i8, i8, i32 }
%struct.request_sock_queue = type { %struct.request_sock*, %struct.request_sock*, %struct.rwlock_t, i8, %struct.listen_sock*, %struct.fastopen_queue* }
%struct.listen_sock = type { i8, i8, i32, i32, i32, i32, i32, [0 x %struct.request_sock*] }
%struct.fastopen_queue = type { %struct.request_sock*, %struct.request_sock*, %struct.spinlock, i32, i32 }
%struct.inet_bind_bucket = type { %struct.net*, i16, i8, i8, i32, i32, %struct.hlist_node, %struct.hlist_head }
%struct.tcp_congestion_ops = type { %struct.list_head, i64, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*)*, i32 (%struct.sock*)*, void (%struct.sock*, i32, i32)*, void (%struct.sock*, i8)*, void (%struct.sock*, i32)*, i32 (%struct.sock*)*, void (%struct.sock*, i32, i32)*, void (%struct.sock*, i32, %struct.sk_buff*)*, [16 x i8], %struct.module* }
%struct.inet_connection_sock_af_ops = type { i32 (%struct.sk_buff*, %struct.flowi*)*, void (%struct.sock*, %struct.sk_buff*)*, i32 (%struct.sock*)*, void (%struct.sock*, %struct.sk_buff*)*, i32 (%struct.sock*, %struct.sk_buff*)*, %struct.sock* (%struct.sock*, %struct.sk_buff*, %struct.request_sock*, %struct.dst_entry*)*, i16, i16, i16, i32 (%struct.sock*, i32, i32, i8*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, i32 (%struct.sock*, i32, i32, i8*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, void (%struct.sock*, %struct.sockaddr*)*, i32 (%struct.sock*, %struct.inet_bind_bucket*, i1)* }
%struct.anon.88 = type { i8, i8, i8, i8, i32, i64, i32, i16, i16 }
%struct.anon.90 = type { %struct.sk_buff_head, %struct.task_struct*, %struct.iovec*, i32, i32, %struct.dma_chan*, i32, %struct.dma_pinned_list*, i32 }
%struct.dma_chan = type { %struct.dma_device*, i32, i32, i32, %struct.dma_chan_dev*, %struct.list_head, %struct.load_weight*, i32, i32, i8* }
%struct.dma_device = type { i32, i32, %struct.list_head, %struct.list_head, %struct.dma_attrs, i16, i16, i8, i8, i8, i8, i32, %struct.device*, i32 (%struct.dma_chan*)*, void (%struct.dma_chan*)*, %struct.dma_async_tx_descriptor* (%struct.dma_chan*, i64, i64, i64, i64)*, %struct.dma_async_tx_descriptor* (%struct.dma_chan*, i64, i64*, i32, i64, i64)*, %struct.dma_async_tx_descriptor* (%struct.dma_chan*, i64*, i32, i64, i32*, i64)*, %struct.dma_async_tx_descriptor* (%struct.dma_chan*, i64*, i64*, i32, i8*, i64, i64)*, %struct.dma_async_tx_descriptor* (%struct.dma_chan*, i64*, i64*, i32, i8*, i64, i32*, i64)*, %struct.dma_async_tx_descriptor* (%struct.dma_chan*, i64, i32, i64, i64)*, %struct.dma_async_tx_descriptor* (%struct.dma_chan*, i64)*, %struct.dma_async_tx_descriptor* (%struct.dma_chan*, %struct.scatterlist*, i32, %struct.scatterlist*, i32, i64)*, %struct.dma_async_tx_descriptor* (%struct.dma_chan*, %struct.scatterlist*, i32, i32, i64, i8*)*, %struct.dma_async_tx_descriptor* (%struct.dma_chan*, i64, i64, i64, i32, i64, i8*)*, %struct.dma_async_tx_descriptor* (%struct.dma_chan*, %struct.dma_interleaved_template*, i64)*, i32 (%struct.dma_chan*, i32, i64)*, i32 (%struct.dma_chan*, i32, %struct.dma_tx_state*)*, void (%struct.dma_chan*)* }
%struct.dma_async_tx_descriptor = type { i32, i32, i64, %struct.dma_chan*, i32 (%struct.dma_async_tx_descriptor*)*, void (i8*)*, i8* }
%struct.dma_interleaved_template = type { i64, i64, i32, i8, i8, i8, i8, i64, i64, [0 x %struct.load_weight] }
%struct.dma_chan_dev = type { %struct.dma_chan*, %struct.device, i32, %struct.atomic_t* }
%struct.dma_pinned_list = type { i32, [0 x %struct.dma_page_list] }
%struct.dma_page_list = type { i8*, i32, %struct.page** }
%struct.tcp_options_received = type { i64, i32, i32, i32, i16, i8, i16, i16 }
%struct.tcp_sock_af_ops = type { %struct.tcp_md5sig_key* (%struct.sock*, %struct.sock*)*, i32 (i8*, %struct.tcp_md5sig_key*, %struct.sock*, %struct.request_sock*, %struct.sk_buff*)*, i32 (%struct.sock*, i8*, i32)* }
%struct.tcp_md5sig_key = type { %struct.hlist_node, i8, i8, %union.tcp_md5_addr, [80 x i8], %struct.callback_head }
%union.tcp_md5_addr = type { %struct.in6_addr }
%struct.tcp_md5sig_info = type { %struct.hlist_head, %struct.callback_head }
%struct.tcp_fastopen_request = type { %struct.tcp_fastopen_cookie, %struct.msghdr*, i16 }
%struct.tcp_fastopen_cookie = type { i8, [16 x i8] }
%struct.anon.2 = type { [24 x i8], %struct.lockdep_map }
%struct.rpc_wait = type { %struct.list_head, %struct.list_head, %struct.list_head, i64 }
%struct.wait_bit_key = type { i8*, i32 }
%struct.ftrace_raw_rpc_task_queued = type { %struct.sock_filter, %struct.rpc_clnt*, %struct.rpc_task*, i64, i64, i32, i16, i32, [0 x i8] }
%struct.ftrace_event_file = type { %struct.list_head, %struct.ftrace_event_call*, %struct.dentry*, %struct.trace_array*, %struct.ftrace_subsystem_dir*, i64, %struct.atomic_t }
%struct.ftrace_subsystem_dir = type opaque
%struct.ring_buffer_event = type { i32, [0 x i32] }
%struct.stack_frame = type { %struct.stack_frame*, i64 }
%struct.ftrace_raw_rpc_task_running = type { %struct.sock_filter, %struct.rpc_clnt*, %struct.rpc_task*, i8*, i64, i32, i16, [0 x i8] }
%struct.ftrace_raw_rpc_connect_status = type { %struct.sock_filter, %struct.rpc_task*, %struct.rpc_clnt*, i32, [0 x i8] }
%struct.unx_cred = type { %struct.rpc_cred.2995, i32, [16 x i32] }
%struct.generic_cred = type { %struct.rpc_cred, %struct.auth_cred }
%struct.va_format = type { i8*, [1 x %struct.__va_list_tag]* }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%union.anon.75 = type { [5 x i64] }
%struct.in_pktinfo = type { i32, %struct.atomic_t, %struct.atomic_t }
%struct.unix_domain = type { %struct.auth_domain.5260 }
%struct.ip_map = type { %struct.cache_head, [8 x i8], %struct.in6_addr, %struct.unix_domain* }
%struct.unix_gid = type { %struct.cache_head, i32, %struct.group_info* }
%union.anon.74 = type { %struct.sockaddr_in6 }
%struct.rpcbind_args = type { %struct.rpc_xprt*, i32, i32, i32, i16, i8*, i8*, i8*, i32 }
%struct.xdr_array2_desc = type { i32, i32, i32, i32 (%struct.xdr_array2_desc*, i8*)* }
%struct.rpc_inode = type { %struct.inode, i8*, %struct.rpc_pipe*, %struct.__wait_queue_head }
%struct.rpc_pipe = type { %struct.list_head, %struct.list_head, %struct.list_head, i32, i32, i32, i32, %struct.delayed_work, %struct.rpc_pipe_ops*, %struct.spinlock, %struct.dentry* }
%struct.rpc_pipe_ops = type { i64 (%struct.file*, %struct.rpc_pipe_msg*, i8*, i64)*, i64 (%struct.file*, i8*, i64)*, void (%struct.inode*)*, i32 (%struct.inode*)*, void (%struct.rpc_pipe_msg*)* }
%struct.rpc_pipe_msg = type { %struct.list_head, i8*, i64, i64, i32 }
%struct.cache_reader = type { %struct.netdev_hw_addr_list, i32 }
%struct.cache_request = type { %struct.netdev_hw_addr_list, %struct.cache_head*, i8*, i32, i32 }
%struct.handle = type { %struct.cache_detail* }
%struct.thread_deferred_req = type { %struct.cache_deferred_req, %struct.completion }
%struct.cache_detail_pipefs = type { %struct.dentry* }
%struct.svc_xpt_user = type { %struct.list_head, void (%struct.svc_xpt_user*)* }
%struct.__large_struct = type { [100 x i64] }

@llvm.used = appending global [455 x i8*] [i8* bitcast (i64* @__kcrctab_rpc_create to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_create to i8*), i8* bitcast (i64* @__kcrctab_rpc_clone_client to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_clone_client to i8*), i8* bitcast (i64* @__kcrctab_rpc_clone_client_set_auth to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_clone_client_set_auth to i8*), i8* bitcast (i64* @__kcrctab_rpc_killall_tasks to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_killall_tasks to i8*), i8* bitcast (i64* @__kcrctab_rpc_shutdown_client to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_shutdown_client to i8*), i8* bitcast (i64* @__kcrctab_rpc_release_client to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_release_client to i8*), i8* bitcast (i64* @__kcrctab_rpc_bind_new_program to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_bind_new_program to i8*), i8* bitcast (i64* @__kcrctab_rpc_task_reset_client to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_task_reset_client to i8*), i8* bitcast (i64* @__kcrctab_rpc_run_task to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_run_task to i8*), i8* bitcast (i64* @__kcrctab_rpc_call_sync to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_call_sync to i8*), i8* bitcast (i64* @__kcrctab_rpc_call_async to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_call_async to i8*), i8* bitcast (i64* @__kcrctab_rpc_call_start to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_call_start to i8*), i8* bitcast (i64* @__kcrctab_rpc_peeraddr to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_peeraddr to i8*), i8* bitcast (i64* @__kcrctab_rpc_peeraddr2str to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_peeraddr2str to i8*), i8* bitcast (i64* @__kcrctab_rpc_localaddr to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_localaddr to i8*), i8* bitcast (i64* @__kcrctab_rpc_setbufsize to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_setbufsize to i8*), i8* bitcast (i64* @__kcrctab_rpc_protocol to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_protocol to i8*), i8* bitcast (i64* @__kcrctab_rpc_net_ns to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_net_ns to i8*), i8* bitcast (i64* @__kcrctab_rpc_max_payload to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_max_payload to i8*), i8* bitcast (i64* @__kcrctab_rpc_get_timeout to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_get_timeout to i8*), i8* bitcast (i64* @__kcrctab_rpc_force_rebind to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_force_rebind to i8*), i8* bitcast (i64* @__kcrctab_rpc_restart_call_prepare to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_restart_call_prepare to i8*), i8* bitcast (i64* @__kcrctab_rpc_restart_call to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_restart_call to i8*), i8* bitcast (i64* @__kcrctab_rpc_call_null to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_call_null to i8*), i8* bitcast (i64* @__kcrctab_xprt_register_transport to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_register_transport to i8*), i8* bitcast (i64* @__kcrctab_xprt_unregister_transport to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_unregister_transport to i8*), i8* bitcast (i64* @__kcrctab_xprt_load_transport to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_load_transport to i8*), i8* bitcast (i64* @__kcrctab_xprt_reserve_xprt to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_reserve_xprt to i8*), i8* bitcast (i64* @__kcrctab_xprt_reserve_xprt_cong to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_reserve_xprt_cong to i8*), i8* bitcast (i64* @__kcrctab_xprt_release_xprt to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_release_xprt to i8*), i8* bitcast (i64* @__kcrctab_xprt_release_xprt_cong to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_release_xprt_cong to i8*), i8* bitcast (i64* @__kcrctab_xprt_release_rqst_cong to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_release_rqst_cong to i8*), i8* bitcast (i64* @__kcrctab_xprt_adjust_cwnd to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_adjust_cwnd to i8*), i8* bitcast (i64* @__kcrctab_xprt_wake_pending_tasks to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_wake_pending_tasks to i8*), i8* bitcast (i64* @__kcrctab_xprt_wait_for_buffer_space to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_wait_for_buffer_space to i8*), i8* bitcast (i64* @__kcrctab_xprt_write_space to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_write_space to i8*), i8* bitcast (i64* @__kcrctab_xprt_set_retrans_timeout_def to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_set_retrans_timeout_def to i8*), i8* bitcast (i64* @__kcrctab_xprt_set_retrans_timeout_rtt to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_set_retrans_timeout_rtt to i8*), i8* bitcast (i64* @__kcrctab_xprt_disconnect_done to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_disconnect_done to i8*), i8* bitcast (i64* @__kcrctab_xprt_lookup_rqst to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_lookup_rqst to i8*), i8* bitcast (i64* @__kcrctab_xprt_complete_rqst to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_complete_rqst to i8*), i8* bitcast (i64* @__kcrctab_xprt_alloc_slot to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_alloc_slot to i8*), i8* bitcast (i64* @__kcrctab_xprt_lock_and_alloc_slot to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_lock_and_alloc_slot to i8*), i8* bitcast (i64* @__kcrctab_xprt_alloc to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_alloc to i8*), i8* bitcast (i64* @__kcrctab_xprt_free to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_free to i8*), i8* bitcast (i64* @__kcrctab_xdr_skb_read_bits to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_skb_read_bits to i8*), i8* bitcast (i64* @__kcrctab_xdr_partial_copy_from_skb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_partial_copy_from_skb to i8*), i8* bitcast (i64* @__kcrctab_csum_partial_copy_to_xdr to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_csum_partial_copy_to_xdr to i8*), i8* bitcast (i64* @__kcrctab_xs_swapper to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xs_swapper to i8*), i8* bitcast (%struct.kernel_param* @__param_min_resvport to i8*), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__UNIQUE_ID_min_resvporttype3027, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_max_resvport to i8*), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__UNIQUE_ID_max_resvporttype3028, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_tcp_slot_table_entries to i8*), i8* getelementptr inbounds ([48 x i8], [48 x i8]* @__UNIQUE_ID_tcp_slot_table_entriestype3063, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_tcp_max_slot_table_entries to i8*), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @__UNIQUE_ID_tcp_max_slot_table_entriestype3065, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_udp_slot_table_entries to i8*), i8* getelementptr inbounds ([48 x i8], [48 x i8]* @__UNIQUE_ID_udp_slot_table_entriestype3067, i32 0, i32 0), i8* bitcast (%struct.tracepoint** @__tracepoint_ptr_rpc_call_status to i8*), i8* bitcast (%struct.tracepoint** @__tracepoint_ptr_rpc_bind_status to i8*), i8* bitcast (%struct.tracepoint** @__tracepoint_ptr_rpc_connect_status to i8*), i8* bitcast (%struct.tracepoint** @__tracepoint_ptr_rpc_task_begin to i8*), i8* bitcast (%struct.tracepoint** @__tracepoint_ptr_rpc_task_run_action to i8*), i8* bitcast (%struct.tracepoint** @__tracepoint_ptr_rpc_task_complete to i8*), i8* bitcast (%struct.tracepoint** @__tracepoint_ptr_rpc_task_sleep to i8*), i8* bitcast (%struct.tracepoint** @__tracepoint_ptr_rpc_task_wakeup to i8*), i8* bitcast (%struct.ftrace_event_class* @event_class_rpc_task_status to i8*), i8* bitcast (%struct.ftrace_event_call* @event_rpc_call_status to i8*), i8* bitcast (%struct.ftrace_event_call** @__event_rpc_call_status to i8*), i8* bitcast (%struct.ftrace_event_call* @event_rpc_bind_status to i8*), i8* bitcast (%struct.ftrace_event_call** @__event_rpc_bind_status to i8*), i8* bitcast (%struct.ftrace_event_class* @event_class_rpc_connect_status to i8*), i8* bitcast (%struct.ftrace_event_call* @event_rpc_connect_status to i8*), i8* bitcast (%struct.ftrace_event_call** @__event_rpc_connect_status to i8*), i8* bitcast (%struct.ftrace_event_class* @event_class_rpc_task_running to i8*), i8* bitcast (%struct.ftrace_event_call* @event_rpc_task_begin to i8*), i8* bitcast (%struct.ftrace_event_call** @__event_rpc_task_begin to i8*), i8* bitcast (%struct.ftrace_event_call* @event_rpc_task_run_action to i8*), i8* bitcast (%struct.ftrace_event_call** @__event_rpc_task_run_action to i8*), i8* bitcast (%struct.ftrace_event_call* @event_rpc_task_complete to i8*), i8* bitcast (%struct.ftrace_event_call** @__event_rpc_task_complete to i8*), i8* bitcast (%struct.ftrace_event_class* @event_class_rpc_task_queued to i8*), i8* bitcast (%struct.ftrace_event_call* @event_rpc_task_sleep to i8*), i8* bitcast (%struct.ftrace_event_call** @__event_rpc_task_sleep to i8*), i8* bitcast (%struct.ftrace_event_call* @event_rpc_task_wakeup to i8*), i8* bitcast (%struct.ftrace_event_call** @__event_rpc_task_wakeup to i8*), i8* bitcast (i64* @__kcrctab_rpc_init_priority_wait_queue to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_init_priority_wait_queue to i8*), i8* bitcast (i64* @__kcrctab_rpc_init_wait_queue to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_init_wait_queue to i8*), i8* bitcast (i64* @__kcrctab_rpc_destroy_wait_queue to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_destroy_wait_queue to i8*), i8* bitcast (i64* @__kcrctab___rpc_wait_for_completion_task to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab___rpc_wait_for_completion_task to i8*), i8* bitcast (i64* @__kcrctab_rpc_sleep_on to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_sleep_on to i8*), i8* bitcast (i64* @__kcrctab_rpc_sleep_on_priority to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_sleep_on_priority to i8*), i8* bitcast (i64* @__kcrctab_rpc_queue_empty to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_queue_empty to i8*), i8* bitcast (i64* @__kcrctab_rpc_wake_up_queued_task to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_wake_up_queued_task to i8*), i8* bitcast (i64* @__kcrctab_rpc_wake_up_first to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_wake_up_first to i8*), i8* bitcast (i64* @__kcrctab_rpc_wake_up_next to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_wake_up_next to i8*), i8* bitcast (i64* @__kcrctab_rpc_wake_up to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_wake_up to i8*), i8* bitcast (i64* @__kcrctab_rpc_wake_up_status to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_wake_up_status to i8*), i8* bitcast (i64* @__kcrctab_rpc_delay to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_delay to i8*), i8* bitcast (i64* @__kcrctab_rpc_exit to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_exit to i8*), i8* bitcast (i64* @__kcrctab_rpc_malloc to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_malloc to i8*), i8* bitcast (i64* @__kcrctab_rpc_free to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_free to i8*), i8* bitcast (i64* @__kcrctab_rpc_put_task to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_put_task to i8*), i8* bitcast (i64* @__kcrctab_rpc_put_task_async to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_put_task_async to i8*), i8* bitcast (%struct.kernel_param* @__param_auth_hashtable_size to i8*), i8* getelementptr inbounds ([40 x i8], [40 x i8]* @__UNIQUE_ID_auth_hashtable_sizetype80, i32 0, i32 0), i8* getelementptr inbounds ([61 x i8], [61 x i8]* @__UNIQUE_ID_auth_hashtable_size81, i32 0, i32 0), i8* bitcast (i64* @__kcrctab_rpcauth_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpcauth_register to i8*), i8* bitcast (i64* @__kcrctab_rpcauth_unregister to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpcauth_unregister to i8*), i8* bitcast (i64* @__kcrctab_rpcauth_get_pseudoflavor to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpcauth_get_pseudoflavor to i8*), i8* bitcast (i64* @__kcrctab_rpcauth_get_gssinfo to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpcauth_get_gssinfo to i8*), i8* bitcast (i64* @__kcrctab_rpcauth_list_flavors to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpcauth_list_flavors to i8*), i8* bitcast (i64* @__kcrctab_rpcauth_create to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpcauth_create to i8*), i8* bitcast (i64* @__kcrctab_rpcauth_init_credcache to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpcauth_init_credcache to i8*), i8* bitcast (i64* @__kcrctab_rpcauth_destroy_credcache to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpcauth_destroy_credcache to i8*), i8* bitcast (i64* @__kcrctab_rpcauth_lookup_credcache to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpcauth_lookup_credcache to i8*), i8* bitcast (i64* @__kcrctab_rpcauth_init_cred to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpcauth_init_cred to i8*), i8* bitcast (i64* @__kcrctab_rpcauth_generic_bind_cred to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpcauth_generic_bind_cred to i8*), i8* bitcast (i64* @__kcrctab_put_rpccred to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_put_rpccred to i8*), i8* bitcast (i64* @__kcrctab_rpc_lookup_cred to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_lookup_cred to i8*), i8* bitcast (i64* @__kcrctab_rpc_lookup_machine_cred to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_lookup_machine_cred to i8*), i8* bitcast (%struct.kernel_param* @__param_pool_mode to i8*), i8* bitcast (i64* @__kcrctab_svc_rpcb_setup to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_rpcb_setup to i8*), i8* bitcast (i64* @__kcrctab_svc_rpcb_cleanup to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_rpcb_cleanup to i8*), i8* bitcast (i64* @__kcrctab_svc_bind to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_bind to i8*), i8* bitcast (i64* @__kcrctab_svc_create to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_create to i8*), i8* bitcast (i64* @__kcrctab_svc_create_pooled to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_create_pooled to i8*), i8* bitcast (i64* @__kcrctab_svc_shutdown_net to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_shutdown_net to i8*), i8* bitcast (i64* @__kcrctab_svc_destroy to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_destroy to i8*), i8* bitcast (i64* @__kcrctab_svc_prepare_thread to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_prepare_thread to i8*), i8* bitcast (i64* @__kcrctab_svc_set_num_threads to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_set_num_threads to i8*), i8* bitcast (i64* @__kcrctab_svc_exit_thread to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_exit_thread to i8*), i8* bitcast (i64* @__kcrctab_svc_process to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_process to i8*), i8* bitcast (i64* @__kcrctab_bc_svc_process to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_bc_svc_process to i8*), i8* bitcast (i64* @__kcrctab_svc_max_payload to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_max_payload to i8*), i8* bitcast (i64* @__kcrctab_svc_sock_update_bufs to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_sock_update_bufs to i8*), i8* bitcast (i64* @__kcrctab_svc_addsock to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_addsock to i8*), i8* bitcast (i64* @__kcrctab_svc_authenticate to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_authenticate to i8*), i8* bitcast (i64* @__kcrctab_svc_set_client to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_set_client to i8*), i8* bitcast (i64* @__kcrctab_svc_auth_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_auth_register to i8*), i8* bitcast (i64* @__kcrctab_svc_auth_unregister to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_auth_unregister to i8*), i8* bitcast (i64* @__kcrctab_auth_domain_put to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_auth_domain_put to i8*), i8* bitcast (i64* @__kcrctab_auth_domain_lookup to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_auth_domain_lookup to i8*), i8* bitcast (i64* @__kcrctab_auth_domain_find to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_auth_domain_find to i8*), i8* bitcast (i64* @__kcrctab_unix_domain_find to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_unix_domain_find to i8*), i8* bitcast (i64* @__kcrctab_svcauth_unix_purge to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svcauth_unix_purge to i8*), i8* bitcast (i64* @__kcrctab_svcauth_unix_set_client to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svcauth_unix_set_client to i8*), i8* bitcast (i64* @__kcrctab_rpc_ntop to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_ntop to i8*), i8* bitcast (i64* @__kcrctab_rpc_pton to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_pton to i8*), i8* bitcast (i64* @__kcrctab_rpc_uaddr2sockaddr to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_uaddr2sockaddr to i8*), i8* bitcast (i64* @__kcrctab_rpcb_getport_async to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpcb_getport_async to i8*), i8* bitcast (i64* @__kcrctab_rpc_init_rtt to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_init_rtt to i8*), i8* bitcast (i64* @__kcrctab_rpc_update_rtt to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_update_rtt to i8*), i8* bitcast (i64* @__kcrctab_rpc_calc_rto to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_calc_rto to i8*), i8* bitcast (i64* @__kcrctab_xdr_encode_netobj to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_encode_netobj to i8*), i8* bitcast (i64* @__kcrctab_xdr_decode_netobj to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_decode_netobj to i8*), i8* bitcast (i64* @__kcrctab_xdr_encode_opaque_fixed to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_encode_opaque_fixed to i8*), i8* bitcast (i64* @__kcrctab_xdr_encode_opaque to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_encode_opaque to i8*), i8* bitcast (i64* @__kcrctab_xdr_encode_string to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_encode_string to i8*), i8* bitcast (i64* @__kcrctab_xdr_decode_string_inplace to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_decode_string_inplace to i8*), i8* bitcast (i64* @__kcrctab_xdr_terminate_string to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_terminate_string to i8*), i8* bitcast (i64* @__kcrctab_xdr_inline_pages to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_inline_pages to i8*), i8* bitcast (i64* @__kcrctab__copy_from_pages to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab__copy_from_pages to i8*), i8* bitcast (i64* @__kcrctab_xdr_shift_buf to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_shift_buf to i8*), i8* bitcast (i64* @__kcrctab_xdr_stream_pos to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_stream_pos to i8*), i8* bitcast (i64* @__kcrctab_xdr_init_encode to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_init_encode to i8*), i8* bitcast (i64* @__kcrctab_xdr_reserve_space to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_reserve_space to i8*), i8* bitcast (i64* @__kcrctab_xdr_write_pages to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_write_pages to i8*), i8* bitcast (i64* @__kcrctab_xdr_init_decode to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_init_decode to i8*), i8* bitcast (i64* @__kcrctab_xdr_init_decode_pages to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_init_decode_pages to i8*), i8* bitcast (i64* @__kcrctab_xdr_set_scratch_buffer to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_set_scratch_buffer to i8*), i8* bitcast (i64* @__kcrctab_xdr_inline_decode to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_inline_decode to i8*), i8* bitcast (i64* @__kcrctab_xdr_read_pages to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_read_pages to i8*), i8* bitcast (i64* @__kcrctab_xdr_enter_page to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_enter_page to i8*), i8* bitcast (i64* @__kcrctab_xdr_buf_from_iov to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_buf_from_iov to i8*), i8* bitcast (i64* @__kcrctab_xdr_buf_subsegment to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_buf_subsegment to i8*), i8* bitcast (i64* @__kcrctab_xdr_buf_trim to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_buf_trim to i8*), i8* bitcast (i64* @__kcrctab_read_bytes_from_xdr_buf to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_read_bytes_from_xdr_buf to i8*), i8* bitcast (i64* @__kcrctab_write_bytes_to_xdr_buf to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_write_bytes_to_xdr_buf to i8*), i8* bitcast (i64* @__kcrctab_xdr_decode_word to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_decode_word to i8*), i8* bitcast (i64* @__kcrctab_xdr_encode_word to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_encode_word to i8*), i8* bitcast (i64* @__kcrctab_xdr_buf_read_netobj to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_buf_read_netobj to i8*), i8* bitcast (i64* @__kcrctab_xdr_decode_array2 to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_decode_array2 to i8*), i8* bitcast (i64* @__kcrctab_xdr_encode_array2 to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_encode_array2 to i8*), i8* bitcast (i64* @__kcrctab_xdr_process_buf to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xdr_process_buf to i8*), i8* bitcast (i64* @__kcrctab_sunrpc_net_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_sunrpc_net_id to i8*), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license125, i32 0, i32 0), i8* bitcast (i64* @__kcrctab_sunrpc_cache_lookup to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_sunrpc_cache_lookup to i8*), i8* bitcast (i64* @__kcrctab_sunrpc_cache_update to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_sunrpc_cache_update to i8*), i8* bitcast (i64* @__kcrctab_cache_check to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_cache_check to i8*), i8* bitcast (i64* @__kcrctab_sunrpc_init_cache_detail to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_sunrpc_init_cache_detail to i8*), i8* bitcast (i64* @__kcrctab_sunrpc_destroy_cache_detail to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_sunrpc_destroy_cache_detail to i8*), i8* bitcast (i64* @__kcrctab_cache_flush to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_cache_flush to i8*), i8* bitcast (i64* @__kcrctab_cache_purge to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_cache_purge to i8*), i8* bitcast (i64* @__kcrctab_qword_add to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_qword_add to i8*), i8* bitcast (i64* @__kcrctab_qword_addhex to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_qword_addhex to i8*), i8* bitcast (i64* @__kcrctab_sunrpc_cache_pipe_upcall to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_sunrpc_cache_pipe_upcall to i8*), i8* bitcast (i64* @__kcrctab_qword_get to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_qword_get to i8*), i8* bitcast (i64* @__kcrctab_cache_register_net to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_cache_register_net to i8*), i8* bitcast (i64* @__kcrctab_cache_unregister_net to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_cache_unregister_net to i8*), i8* bitcast (i64* @__kcrctab_cache_create_net to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_cache_create_net to i8*), i8* bitcast (i64* @__kcrctab_cache_destroy_net to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_cache_destroy_net to i8*), i8* bitcast (i64* @__kcrctab_sunrpc_cache_register_pipefs to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_sunrpc_cache_register_pipefs to i8*), i8* bitcast (i64* @__kcrctab_sunrpc_cache_unregister_pipefs to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_sunrpc_cache_unregister_pipefs to i8*), i8* bitcast (i64* @__kcrctab_rpc_pipefs_notifier_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_pipefs_notifier_register to i8*), i8* bitcast (i64* @__kcrctab_rpc_pipefs_notifier_unregister to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_pipefs_notifier_unregister to i8*), i8* bitcast (i64* @__kcrctab_rpc_pipe_generic_upcall to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_pipe_generic_upcall to i8*), i8* bitcast (i64* @__kcrctab_rpc_queue_upcall to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_queue_upcall to i8*), i8* bitcast (i64* @__kcrctab_rpc_destroy_pipe_data to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_destroy_pipe_data to i8*), i8* bitcast (i64* @__kcrctab_rpc_mkpipe_data to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_mkpipe_data to i8*), i8* bitcast (i64* @__kcrctab_rpc_rmdir to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_rmdir to i8*), i8* bitcast (i64* @__kcrctab_rpc_mkpipe_dentry to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_mkpipe_dentry to i8*), i8* bitcast (i64* @__kcrctab_rpc_unlink to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_unlink to i8*), i8* bitcast (i64* @__kcrctab_rpc_d_lookup_sb to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_d_lookup_sb to i8*), i8* bitcast (i64* @__kcrctab_rpc_get_sb_net to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_get_sb_net to i8*), i8* bitcast (i64* @__kcrctab_rpc_put_sb_net to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_put_sb_net to i8*), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__UNIQUE_ID_alias1182, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__UNIQUE_ID_alias1183, i32 0, i32 0), i8* bitcast (i64* @__kcrctab_svc_reg_xprt_class to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_reg_xprt_class to i8*), i8* bitcast (i64* @__kcrctab_svc_unreg_xprt_class to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_unreg_xprt_class to i8*), i8* bitcast (i64* @__kcrctab_svc_xprt_put to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_xprt_put to i8*), i8* bitcast (i64* @__kcrctab_svc_xprt_init to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_xprt_init to i8*), i8* bitcast (i64* @__kcrctab_svc_create_xprt to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_create_xprt to i8*), i8* bitcast (i64* @__kcrctab_svc_xprt_copy_addrs to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_xprt_copy_addrs to i8*), i8* bitcast (i64* @__kcrctab_svc_print_addr to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_print_addr to i8*), i8* bitcast (i64* @__kcrctab_svc_xprt_enqueue to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_xprt_enqueue to i8*), i8* bitcast (i64* @__kcrctab_svc_reserve to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_reserve to i8*), i8* bitcast (i64* @__kcrctab_svc_wake_up to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_wake_up to i8*), i8* bitcast (i64* @__kcrctab_svc_recv to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_recv to i8*), i8* bitcast (i64* @__kcrctab_svc_drop to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_drop to i8*), i8* bitcast (i64* @__kcrctab_svc_close_xprt to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_close_xprt to i8*), i8* bitcast (i64* @__kcrctab_svc_find_xprt to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_find_xprt to i8*), i8* bitcast (i64* @__kcrctab_svc_xprt_names to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_xprt_names to i8*), i8* bitcast (i64* @__kcrctab_svc_pool_stats_open to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_pool_stats_open to i8*), i8* bitcast (i64* @__kcrctab_xprt_setup_backchannel to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_setup_backchannel to i8*), i8* bitcast (i64* @__kcrctab_xprt_destroy_backchannel to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_xprt_destroy_backchannel to i8*), i8* bitcast (i64* @__kcrctab_svc_seq_show to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_seq_show to i8*), i8* bitcast (i64* @__kcrctab_rpc_alloc_iostats to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_alloc_iostats to i8*), i8* bitcast (i64* @__kcrctab_rpc_free_iostats to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_free_iostats to i8*), i8* bitcast (i64* @__kcrctab_rpc_count_iostats to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_count_iostats to i8*), i8* bitcast (i64* @__kcrctab_rpc_print_iostats to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_print_iostats to i8*), i8* bitcast (i64* @__kcrctab_rpc_proc_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_proc_register to i8*), i8* bitcast (i64* @__kcrctab_rpc_proc_unregister to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_proc_unregister to i8*), i8* bitcast (i64* @__kcrctab_svc_proc_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_proc_register to i8*), i8* bitcast (i64* @__kcrctab_svc_proc_unregister to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_svc_proc_unregister to i8*), i8* bitcast (i64* @__kcrctab_rpc_debug to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rpc_debug to i8*), i8* bitcast (i64* @__kcrctab_nfs_debug to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_nfs_debug to i8*), i8* bitcast (i64* @__kcrctab_nfsd_debug to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_nfsd_debug to i8*), i8* bitcast (i64* @__kcrctab_nlm_debug to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_nlm_debug to i8*)], section "llvm.metadata"
@__kcrctab_rpc_create = internal constant i64 ptrtoint (i8** @__crc_rpc_create to i64), section "___kcrctab_gpl+rpc_create", align 8
@__ksymtab_rpc_create = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_clnt* (%struct.rpc_create_args*)* @rpc_create to i64), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__kstrtab_rpc_create, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_create", align 8
@__kcrctab_rpc_clone_client = internal constant i64 ptrtoint (i8** @__crc_rpc_clone_client to i64), section "___kcrctab_gpl+rpc_clone_client", align 8
@__ksymtab_rpc_clone_client = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_clnt* (%struct.rpc_clnt*)* @rpc_clone_client to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_rpc_clone_client, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_clone_client", align 8
@__kcrctab_rpc_clone_client_set_auth = internal constant i64 ptrtoint (i8** @__crc_rpc_clone_client_set_auth to i64), section "___kcrctab_gpl+rpc_clone_client_set_auth", align 8
@__ksymtab_rpc_clone_client_set_auth = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_clnt* (%struct.rpc_clnt*, i32)* @rpc_clone_client_set_auth to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_rpc_clone_client_set_auth, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_clone_client_set_auth", align 8
@__kcrctab_rpc_killall_tasks = internal constant i64 ptrtoint (i8** @__crc_rpc_killall_tasks to i64), section "___kcrctab_gpl+rpc_killall_tasks", align 8
@__ksymtab_rpc_killall_tasks = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_clnt*)* @rpc_killall_tasks to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_rpc_killall_tasks, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_killall_tasks", align 8
@__kcrctab_rpc_shutdown_client = internal constant i64 ptrtoint (i8** @__crc_rpc_shutdown_client to i64), section "___kcrctab_gpl+rpc_shutdown_client", align 8
@__ksymtab_rpc_shutdown_client = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_clnt*)* @rpc_shutdown_client to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_rpc_shutdown_client, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_shutdown_client", align 8
@__kcrctab_rpc_release_client = internal constant i64 ptrtoint (i8** @__crc_rpc_release_client to i64), section "___kcrctab_gpl+rpc_release_client", align 8
@__ksymtab_rpc_release_client = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_clnt*)* @rpc_release_client to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_rpc_release_client, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_release_client", align 8
@__kcrctab_rpc_bind_new_program = internal constant i64 ptrtoint (i8** @__crc_rpc_bind_new_program to i64), section "___kcrctab_gpl+rpc_bind_new_program", align 8
@__ksymtab_rpc_bind_new_program = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_clnt* (%struct.rpc_clnt*, %struct.rpc_program*, i32)* @rpc_bind_new_program to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_rpc_bind_new_program, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_bind_new_program", align 8
@__kcrctab_rpc_task_reset_client = internal constant i64 ptrtoint (i8** @__crc_rpc_task_reset_client to i64), section "___kcrctab_gpl+rpc_task_reset_client", align 8
@__ksymtab_rpc_task_reset_client = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_task*, %struct.rpc_clnt*)* @rpc_task_reset_client to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_rpc_task_reset_client, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_task_reset_client", align 8
@__kcrctab_rpc_run_task = internal constant i64 ptrtoint (i8** @__crc_rpc_run_task to i64), section "___kcrctab_gpl+rpc_run_task", align 8
@__ksymtab_rpc_run_task = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_task* (%struct.rpc_task_setup*)* @rpc_run_task to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_rpc_run_task, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_run_task", align 8
@__kcrctab_rpc_call_sync = internal constant i64 ptrtoint (i8** @__crc_rpc_call_sync to i64), section "___kcrctab_gpl+rpc_call_sync", align 8
@__ksymtab_rpc_call_sync = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rpc_clnt*, %struct.rpc_message*, i32)* @rpc_call_sync to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_rpc_call_sync, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_call_sync", align 8
@__kcrctab_rpc_call_async = internal constant i64 ptrtoint (i8** @__crc_rpc_call_async to i64), section "___kcrctab_gpl+rpc_call_async", align 8
@__ksymtab_rpc_call_async = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rpc_clnt*, %struct.rpc_message*, i32, %struct.rpc_call_ops*, i8*)* @rpc_call_async to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_rpc_call_async, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_call_async", align 8
@__kcrctab_rpc_call_start = internal constant i64 ptrtoint (i8** @__crc_rpc_call_start to i64), section "___kcrctab_gpl+rpc_call_start", align 8
@__ksymtab_rpc_call_start = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_task*)* @rpc_call_start to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_rpc_call_start, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_call_start", align 8
@__kcrctab_rpc_peeraddr = internal constant i64 ptrtoint (i8** @__crc_rpc_peeraddr to i64), section "___kcrctab_gpl+rpc_peeraddr", align 8
@__ksymtab_rpc_peeraddr = internal constant %struct.kernel_symbol { i64 ptrtoint (i64 (%struct.rpc_clnt*, %struct.sockaddr*, i64)* @rpc_peeraddr to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_rpc_peeraddr, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_peeraddr", align 8
@__kcrctab_rpc_peeraddr2str = internal constant i64 ptrtoint (i8** @__crc_rpc_peeraddr2str to i64), section "___kcrctab_gpl+rpc_peeraddr2str", align 8
@__ksymtab_rpc_peeraddr2str = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (%struct.rpc_clnt*, i32)* @rpc_peeraddr2str to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_rpc_peeraddr2str, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_peeraddr2str", align 8
@__kcrctab_rpc_localaddr = internal constant i64 ptrtoint (i8** @__crc_rpc_localaddr to i64), section "___kcrctab_gpl+rpc_localaddr", align 8
@__ksymtab_rpc_localaddr = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rpc_clnt*, %struct.sockaddr*, i64)* @rpc_localaddr to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_rpc_localaddr, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_localaddr", align 8
@__kcrctab_rpc_setbufsize = internal constant i64 ptrtoint (i8** @__crc_rpc_setbufsize to i64), section "___kcrctab_gpl+rpc_setbufsize", align 8
@__ksymtab_rpc_setbufsize = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_clnt*, i32, i32)* @rpc_setbufsize to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_rpc_setbufsize, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_setbufsize", align 8
@__kcrctab_rpc_protocol = internal constant i64 ptrtoint (i8** @__crc_rpc_protocol to i64), section "___kcrctab_gpl+rpc_protocol", align 8
@__ksymtab_rpc_protocol = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rpc_clnt*)* @rpc_protocol to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_rpc_protocol, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_protocol", align 8
@__kcrctab_rpc_net_ns = internal constant i64 ptrtoint (i8** @__crc_rpc_net_ns to i64), section "___kcrctab_gpl+rpc_net_ns", align 8
@__ksymtab_rpc_net_ns = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.net* (%struct.rpc_clnt*)* @rpc_net_ns to i64), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__kstrtab_rpc_net_ns, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_net_ns", align 8
@__kcrctab_rpc_max_payload = internal constant i64 ptrtoint (i8** @__crc_rpc_max_payload to i64), section "___kcrctab_gpl+rpc_max_payload", align 8
@__ksymtab_rpc_max_payload = internal constant %struct.kernel_symbol { i64 ptrtoint (i64 (%struct.rpc_clnt*)* @rpc_max_payload to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_rpc_max_payload, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_max_payload", align 8
@__kcrctab_rpc_get_timeout = internal constant i64 ptrtoint (i8** @__crc_rpc_get_timeout to i64), section "___kcrctab_gpl+rpc_get_timeout", align 8
@__ksymtab_rpc_get_timeout = internal constant %struct.kernel_symbol { i64 ptrtoint (i64 (%struct.rpc_clnt*)* @rpc_get_timeout to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_rpc_get_timeout, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_get_timeout", align 8
@__kcrctab_rpc_force_rebind = internal constant i64 ptrtoint (i8** @__crc_rpc_force_rebind to i64), section "___kcrctab_gpl+rpc_force_rebind", align 8
@__ksymtab_rpc_force_rebind = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_clnt*)* @rpc_force_rebind to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_rpc_force_rebind, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_force_rebind", align 8
@__kcrctab_rpc_restart_call_prepare = internal constant i64 ptrtoint (i8** @__crc_rpc_restart_call_prepare to i64), section "___kcrctab_gpl+rpc_restart_call_prepare", align 8
@__ksymtab_rpc_restart_call_prepare = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rpc_task*)* @rpc_restart_call_prepare to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_rpc_restart_call_prepare, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_restart_call_prepare", align 8
@__kcrctab_rpc_restart_call = internal constant i64 ptrtoint (i8** @__crc_rpc_restart_call to i64), section "___kcrctab_gpl+rpc_restart_call", align 8
@__ksymtab_rpc_restart_call = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rpc_task*)* @rpc_restart_call to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_rpc_restart_call, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_restart_call", align 8
@__kcrctab_rpc_call_null = internal constant i64 ptrtoint (i8** @__crc_rpc_call_null to i64), section "___kcrctab_gpl+rpc_call_null", align 8
@__ksymtab_rpc_call_null = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_task* (%struct.rpc_clnt*, %struct.rpc_cred*, i32)* @rpc_call_null to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_rpc_call_null, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_call_null", align 8
@__kstrtab_rpc_call_null = internal constant [14 x i8] c"rpc_call_null\00", section "__ksymtab_strings", align 1
@rpcproc_null = internal global %struct.rpc_procinfo { i32 0, void (i8*, %struct.xdr_stream*, i8*)* @rpcproc_encode_null, i32 (i8*, %struct.xdr_stream*, i8*)* @rpcproc_decode_null, i32 0, i32 0, i32 0, i32 0, i32 0, i8* null }, align 8
@rpc_default_ops = internal constant %struct.rpc_call_ops { void (%struct.rpc_task*, i8*)* null, void (%struct.rpc_task*, i8*)* @rpc_default_callback, void (%struct.rpc_task*, i8*)* null, void (i8*)* null }, align 8
@.str.34 = private unnamed_addr constant [6 x i8] c"async\00", align 1
@.str.35 = private unnamed_addr constant [5 x i8] c"sync\00", align 1
@.str.33 = private unnamed_addr constant [41 x i8] c"\01dRPC: %5u call_start %s%d proc %s (%s)\0A\00", align 1
@.str.38 = private unnamed_addr constant [27 x i8] c"\01dRPC: %5u %s (status %d)\0A\00", align 1
@__func__.call_reserve = private unnamed_addr constant [13 x i8] c"call_reserve\00", align 1
@__func__.call_reserveresult = private unnamed_addr constant [19 x i8] c"call_reserveresult\00", align 1
@.str.39 = private unnamed_addr constant [47 x i8] c"\013%s: status=%d, but no request slot, exiting\0A\00", align 1
@.str.40 = private unnamed_addr constant [43 x i8] c"\013%s: status=%d, request allocated anyway\0A\00", align 1
@.str.41 = private unnamed_addr constant [38 x i8] c"\013%s: unrecognized error %d, exiting\0A\00", align 1
@__func__.call_retry_reserve = private unnamed_addr constant [19 x i8] c"call_retry_reserve\00", align 1
@__func__.call_refresh = private unnamed_addr constant [13 x i8] c"call_refresh\00", align 1
@__func__.call_refreshresult = private unnamed_addr constant [19 x i8] c"call_refreshresult\00", align 1
@.str.42 = private unnamed_addr constant [36 x i8] c"\01dRPC: %5u %s: retry refresh creds\0A\00", align 1
@.str.43 = private unnamed_addr constant [51 x i8] c"\01dRPC: %5u %s: refresh creds failed with error %d\0A\00", align 1
@__func__.call_allocate = private unnamed_addr constant [14 x i8] c"call_allocate\00", align 1
@.str.4 = private unnamed_addr constant [18 x i8] c"net/sunrpc/clnt.c\00", align 1
@.str.44 = private unnamed_addr constant [41 x i8] c"\01dRPC: %5u rpc_buffer allocation failed\0A\00", align 1
@current_task = external global %struct.task_struct*, align 8
@__func__.call_bind = private unnamed_addr constant [10 x i8] c"call_bind\00", align 1
@__func__.call_bind_status = private unnamed_addr constant [17 x i8] c"call_bind_status\00", align 1
@.str.81 = private unnamed_addr constant [34 x i8] c"\01dRPC: %5u rpcbind out of memory\0A\00", align 1
@.str.82 = private unnamed_addr constant [60 x i8] c"\01dRPC: %5u remote rpcbind: RPC program/version unavailable\0A\00", align 1
@.str.83 = private unnamed_addr constant [38 x i8] c"\01dRPC: %5u rpcbind request timed out\0A\00", align 1
@.str.84 = private unnamed_addr constant [48 x i8] c"\01dRPC: %5u unrecognized remote rpcbind service\0A\00", align 1
@.str.85 = private unnamed_addr constant [57 x i8] c"\01dRPC: %5u remote rpcbind version unavailable, retrying\0A\00", align 1
@.str.86 = private unnamed_addr constant [43 x i8] c"\01dRPC: %5u remote rpcbind unreachable: %d\0A\00", align 1
@.str.87 = private unnamed_addr constant [44 x i8] c"\01dRPC: %5u unrecognized rpcbind error (%d)\0A\00", align 1
@.str.75 = private unnamed_addr constant [33 x i8] c"\01dRPC: %5u call_timeout (minor)\0A\00", align 1
@.str.76 = private unnamed_addr constant [33 x i8] c"\01dRPC: %5u call_timeout (major)\0A\00", align 1
@call_timeout.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.77 = private unnamed_addr constant [43 x i8] c"\015%s: server %s not responding, timed out\0A\00", align 1
@call_timeout.__warned.79 = internal global i8 0, section ".data.unlikely", align 1
@.str.78 = private unnamed_addr constant [46 x i8] c"\015%s: server %s not responding, still trying\0A\00", align 1
@rpc_force_rebind.__warned = internal global i8 0, section ".data.unlikely", align 1
@rcu_read_unlock.__warned = internal global i8 0, section ".data.unlikely", align 1
@rcu_lock_map = external global %struct.lockdep_map, align 8
@kernel_stack = external global i64, align 8
@rcu_read_lock.__warned = internal global i8 0, section ".data.unlikely", align 1
@trace_rpc_bind_status.__warned = internal global i8 0, section ".data.unlikely", align 1
@debug_locks = external global i32, align 4
@rcu_sched_lock_map = external global %struct.lockdep_map, align 8
@pv_irq_ops = external global %struct.pv_irq_ops, align 8
@.str.45 = private unnamed_addr constant [46 x i8] c"\01dRPC: %5u call_connect xprt %p %s connected\0A\00", align 1
@__func__.call_connect_status = private unnamed_addr constant [20 x i8] c"call_connect_status\00", align 1
@trace_rpc_connect_status.__warned = internal global i8 0, section ".data.unlikely", align 1
@__func__.call_transmit = private unnamed_addr constant [14 x i8] c"call_transmit\00", align 1
@__func__.rpc_xdr_encode = private unnamed_addr constant [15 x i8] c"rpc_xdr_encode\00", align 1
@.str.80 = private unnamed_addr constant [45 x i8] c"\016RPC: couldn't encode RPC header, exit EIO\0A\00", align 1
@__func__.call_transmit_status = private unnamed_addr constant [21 x i8] c"call_transmit_status\00", align 1
@__func__.call_status = private unnamed_addr constant [12 x i8] c"call_status\00", align 1
@.str.48 = private unnamed_addr constant [32 x i8] c"%s: RPC call returned error %d\0A\00", align 1
@trace_rpc_call_status.__warned = internal global i8 0, section ".data.unlikely", align 1
@__func__.call_decode = private unnamed_addr constant [12 x i8] c"call_decode\00", align 1
@call_decode.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.49 = private unnamed_addr constant [20 x i8] c"\015%s: server %s OK\0A\00", align 1
@.str.50 = private unnamed_addr constant [54 x i8] c"\01dRPC:       %s: too small RPC reply size (%d bytes)\0A\00", align 1
@.str.51 = private unnamed_addr constant [34 x i8] c"\01dRPC: %5u call_decode result %d\0A\00", align 1
@.str.52 = private unnamed_addr constant [67 x i8] c"\01dRPC: %5u %s: XDR representation not a multiple of 4 bytes: 0x%x\0A\00", align 1
@__func__.rpc_verify_header = private unnamed_addr constant [18 x i8] c"rpc_verify_header\00", align 1
@.str.53 = private unnamed_addr constant [37 x i8] c"\01dRPC: %5u %s: not an RPC reply: %x\0A\00", align 1
@.str.54 = private unnamed_addr constant [43 x i8] c"\01dRPC: %5u %s: RPC call version mismatch!\0A\00", align 1
@.str.55 = private unnamed_addr constant [53 x i8] c"\01dRPC: %5u %s: RPC call rejected, unknown error: %x\0A\00", align 1
@.str.56 = private unnamed_addr constant [34 x i8] c"\01dRPC: %5u %s: retry stale creds\0A\00", align 1
@.str.57 = private unnamed_addr constant [36 x i8] c"\01dRPC: %5u %s: retry garbled creds\0A\00", align 1
@rpc_verify_header.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.58 = private unnamed_addr constant [52 x i8] c"\015RPC: server %s requires stronger authentication.\0A\00", align 1
@.str.59 = private unnamed_addr constant [39 x i8] c"\01dRPC: %5u %s: unknown auth error: %x\0A\00", align 1
@.str.60 = private unnamed_addr constant [33 x i8] c"\01dRPC: %5u %s: call rejected %d\0A\00", align 1
@.str.61 = private unnamed_addr constant [34 x i8] c"\01dRPC: %5u %s: auth check failed\0A\00", align 1
@rpc_verify_header.__warned.63 = internal global i8 0, section ".data.unlikely", align 1
@.str.62 = private unnamed_addr constant [55 x i8] c"\01dRPC: %5u %s: program %u is unsupported by server %s\0A\00", align 1
@rpc_verify_header.__warned.65 = internal global i8 0, section ".data.unlikely", align 1
@.str.64 = private unnamed_addr constant [64 x i8] c"\01dRPC: %5u %s: program %u, version %u unsupported by server %s\0A\00", align 1
@rpc_verify_header.__warned.67 = internal global i8 0, section ".data.unlikely", align 1
@.str.66 = private unnamed_addr constant [75 x i8] c"\01dRPC: %5u %s: proc %s unsupported by program %u, version %u on server %s\0A\00", align 1
@.str.68 = private unnamed_addr constant [35 x i8] c"\01dRPC: %5u %s: server saw garbage\0A\00", align 1
@.str.69 = private unnamed_addr constant [41 x i8] c"\01dRPC: %5u %s: server accept status: %x\0A\00", align 1
@.str.70 = private unnamed_addr constant [25 x i8] c"\01dRPC: %5u %s: retrying\0A\00", align 1
@.str.71 = private unnamed_addr constant [42 x i8] c"\01dRPC: %5u %s: call failed with error %d\0A\00", align 1
@.str.72 = private unnamed_addr constant [44 x i8] c"\01dRPC: %5u %s: server reply was truncated.\0A\00", align 1
@.str.37 = private unnamed_addr constant [8 x i8] c"no proc\00", align 1
@rpc_task_set_client.__warned = internal global i8 0, section ".data.unlikely", align 1
@memalloc_socks = external global %struct.arch_spinlock, align 4
@.str.7 = private unnamed_addr constant [37 x i8] c"\01dRPC:       rpc_release_client(%p)\0A\00", align 1
@destroy_wait = internal global %struct.__wait_queue_head { %struct.spinlock { %union.anon.11 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.22, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.__wait_queue_head* @destroy_wait to i8*), i64 72) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.__wait_queue_head* @destroy_wait to i8*), i64 72) to %struct.list_head*) } }, align 8
@rpc_free_client.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.23 = private unnamed_addr constant [42 x i8] c"\01dRPC:       destroying %s client for %s\0A\00", align 1
@rpc_free_client.__warned.24 = internal global i8 0, section ".data.unlikely", align 1
@rpc_net_ns.__warned = internal global i8 0, section ".data.unlikely", align 1
@net_generic.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.22 = private unnamed_addr constant [18 x i8] c"destroy_wait.lock\00", align 1
@__crc_rpc_call_null = extern_weak global i8*, align 8
@__kstrtab_rpc_restart_call = internal constant [17 x i8] c"rpc_restart_call\00", section "__ksymtab_strings", align 1
@__crc_rpc_restart_call = extern_weak global i8*, align 8
@__kstrtab_rpc_restart_call_prepare = internal constant [25 x i8] c"rpc_restart_call_prepare\00", section "__ksymtab_strings", align 1
@__crc_rpc_restart_call_prepare = extern_weak global i8*, align 8
@__kstrtab_rpc_force_rebind = internal constant [17 x i8] c"rpc_force_rebind\00", section "__ksymtab_strings", align 1
@__crc_rpc_force_rebind = extern_weak global i8*, align 8
@__kstrtab_rpc_get_timeout = internal constant [16 x i8] c"rpc_get_timeout\00", section "__ksymtab_strings", align 1
@rpc_get_timeout.__warned = internal global i8 0, section ".data.unlikely", align 1
@__crc_rpc_get_timeout = extern_weak global i8*, align 8
@__kstrtab_rpc_max_payload = internal constant [16 x i8] c"rpc_max_payload\00", section "__ksymtab_strings", align 1
@rpc_max_payload.__warned = internal global i8 0, section ".data.unlikely", align 1
@__crc_rpc_max_payload = extern_weak global i8*, align 8
@__kstrtab_rpc_net_ns = internal constant [11 x i8] c"rpc_net_ns\00", section "__ksymtab_strings", align 1
@__crc_rpc_net_ns = extern_weak global i8*, align 8
@__kstrtab_rpc_protocol = internal constant [13 x i8] c"rpc_protocol\00", section "__ksymtab_strings", align 1
@rpc_protocol.__warned = internal global i8 0, section ".data.unlikely", align 1
@__crc_rpc_protocol = extern_weak global i8*, align 8
@__kstrtab_rpc_setbufsize = internal constant [15 x i8] c"rpc_setbufsize\00", section "__ksymtab_strings", align 1
@rpc_setbufsize.__warned = internal global i8 0, section ".data.unlikely", align 1
@__crc_rpc_setbufsize = extern_weak global i8*, align 8
@__kstrtab_rpc_localaddr = internal constant [14 x i8] c"rpc_localaddr\00", section "__ksymtab_strings", align 1
@rpc_localaddr.__warned = internal global i8 0, section ".data.unlikely", align 1
@rpc_inaddr_loopback = internal constant %struct.sockaddr_in { i16 2, i16 0, %struct.atomic_t zeroinitializer, [8 x i8] zeroinitializer }, align 4
@rpc_in6addr_loopback = internal constant { i16, i16, i32, { { [16 x i8] } }, i32 } { i16 10, i16 0, i32 0, { { [16 x i8] } } zeroinitializer, i32 0 }, align 4
@.str.31 = private unnamed_addr constant [47 x i8] c"\01dRPC:       %s: address family not supported\0A\00", align 1
@__func__.rpc_anyaddr = private unnamed_addr constant [12 x i8] c"rpc_anyaddr\00", align 1
@.str.32 = private unnamed_addr constant [28 x i8] c"\01dRPC:       %s: succeeded\0A\00", align 1
@.str.25 = private unnamed_addr constant [43 x i8] c"\01dRPC:       can't create UDP socket (%d)\0A\00", align 1
@.str.26 = private unnamed_addr constant [41 x i8] c"\01dRPC:       can't bind UDP socket (%d)\0A\00", align 1
@.str.27 = private unnamed_addr constant [44 x i8] c"\01dRPC:       can't connect UDP socket (%d)\0A\00", align 1
@.str.28 = private unnamed_addr constant [38 x i8] c"\01dRPC:       getsockname failed (%d)\0A\00", align 1
@.str.29 = private unnamed_addr constant [27 x i8] c"\01dRPC:       %s succeeded\0A\00", align 1
@__func__.rpc_sockname = private unnamed_addr constant [13 x i8] c"rpc_sockname\00", align 1
@__crc_rpc_localaddr = extern_weak global i8*, align 8
@__kstrtab_rpc_peeraddr2str = internal constant [17 x i8] c"rpc_peeraddr2str\00", section "__ksymtab_strings", align 1
@rpc_peeraddr2str.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.10 = private unnamed_addr constant [12 x i8] c"unprintable\00", align 1
@__crc_rpc_peeraddr2str = extern_weak global i8*, align 8
@__kstrtab_rpc_peeraddr = internal constant [13 x i8] c"rpc_peeraddr\00", section "__ksymtab_strings", align 1
@rpc_peeraddr.__warned = internal global i8 0, section ".data.unlikely", align 1
@__crc_rpc_peeraddr = extern_weak global i8*, align 8
@__kstrtab_rpc_call_start = internal constant [15 x i8] c"rpc_call_start\00", section "__ksymtab_strings", align 1
@__crc_rpc_call_start = extern_weak global i8*, align 8
@__kstrtab_rpc_call_async = internal constant [15 x i8] c"rpc_call_async\00", section "__ksymtab_strings", align 1
@__crc_rpc_call_async = extern_weak global i8*, align 8
@__kstrtab_rpc_call_sync = internal constant [14 x i8] c"rpc_call_sync\00", section "__ksymtab_strings", align 1
@rpc_call_sync.__warned = internal global i8 0, section ".data.unlikely", align 1
@__crc_rpc_call_sync = extern_weak global i8*, align 8
@__kstrtab_rpc_run_task = internal constant [13 x i8] c"rpc_run_task\00", section "__ksymtab_strings", align 1
@__crc_rpc_run_task = extern_weak global i8*, align 8
@__kstrtab_rpc_task_reset_client = internal constant [22 x i8] c"rpc_task_reset_client\00", section "__ksymtab_strings", align 1
@__crc_rpc_task_reset_client = extern_weak global i8*, align 8
@__kstrtab_rpc_bind_new_program = internal constant [21 x i8] c"rpc_bind_new_program\00", section "__ksymtab_strings", align 1
@rpc_shutdown_client.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.5 = private unnamed_addr constant [45 x i8] c"\01dRPC:       shutting down %s client for %s\0A\00", align 1
@.str.3 = private unnamed_addr constant [46 x i8] c"\01dRPC:       killing all tasks for client %p\0A\00", align 1
@rpc_ping.msg = private unnamed_addr constant %struct.rpc_message { %struct.rpc_procinfo* @rpcproc_null, i8* null, i8* null, %struct.rpc_cred* null }, align 8
@__rpc_clone_client.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.18 = private unnamed_addr constant [36 x i8] c"\01dRPC:       %s: returned error %d\0A\00", align 1
@__func__.__rpc_clone_client = private unnamed_addr constant [19 x i8] c"__rpc_clone_client\00", align 1
@.str.15 = private unnamed_addr constant [50 x i8] c"\01dRPC:       creating %s client for %s (xprt %p)\0A\00", align 1
@.str.16 = private unnamed_addr constant [25 x i8] c"&(&clnt->cl_lock)->rlock\00", align 1
@rpc_new_client.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.17 = private unnamed_addr constant [54 x i8] c"\01dRPC:       Couldn't create auth handle (flavor %u)\0A\00", align 1
@.str.12 = private unnamed_addr constant [43 x i8] c"\016RPC: pipefs directory doesn't exist: %s\0A\00", align 1
@rpc_setup_pipedir_sb.clntid = internal global i32 0, align 4
@.str.13 = private unnamed_addr constant [7 x i8] c"clnt%x\00", align 1
@.str.14 = private unnamed_addr constant [53 x i8] c"\016RPC: Couldn't create pipefs entry %s/%s, error %d\0A\00", align 1
@__crc_rpc_bind_new_program = extern_weak global i8*, align 8
@__kstrtab_rpc_release_client = internal constant [19 x i8] c"rpc_release_client\00", section "__ksymtab_strings", align 1
@__crc_rpc_release_client = extern_weak global i8*, align 8
@__kstrtab_rpc_shutdown_client = internal constant [20 x i8] c"rpc_shutdown_client\00", section "__ksymtab_strings", align 1
@__crc_rpc_shutdown_client = extern_weak global i8*, align 8
@__kstrtab_rpc_killall_tasks = internal constant [18 x i8] c"rpc_killall_tasks\00", section "__ksymtab_strings", align 1
@__crc_rpc_killall_tasks = extern_weak global i8*, align 8
@__kstrtab_rpc_clone_client_set_auth = internal constant [26 x i8] c"rpc_clone_client_set_auth\00", section "__ksymtab_strings", align 1
@__crc_rpc_clone_client_set_auth = extern_weak global i8*, align 8
@__kstrtab_rpc_clone_client = internal constant [17 x i8] c"rpc_clone_client\00", section "__ksymtab_strings", align 1
@__crc_rpc_clone_client = extern_weak global i8*, align 8
@__kstrtab_rpc_create = internal constant [11 x i8] c"rpc_create\00", section "__ksymtab_strings", align 1
@.str = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@__crc_rpc_create = extern_weak global i8*, align 8
@rpc_clients_block = internal global %struct.notifier_block { i32 (%struct.notifier_block*, i64, i8*)* @rpc_pipefs_event, %struct.notifier_block* null, i32 1 }, align 8
@.str.11 = private unnamed_addr constant [26 x i8] c"\013%s: unknown event: %ld\0A\00", align 1
@__func__.__rpc_clnt_handle_event = private unnamed_addr constant [24 x i8] c"__rpc_clnt_handle_event\00", align 1
@.str.8 = private unnamed_addr constant [32 x i8] c"\01dRPC: rpc_run_bc_task req= %p\0A\00", align 1
@rpc_run_bc_task.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.9 = private unnamed_addr constant [34 x i8] c"\01dRPC: rpc_run_bc_task: task= %p\0A\00", align 1
@.str.88 = private unnamed_addr constant [51 x i8] c"\015RPC: Could not send backchannel reply error: %d\0A\00", align 1
@__func__.call_bc_transmit = private unnamed_addr constant [17 x i8] c"call_bc_transmit\00", align 1
@call_bc_transmit.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.91 = private unnamed_addr constant [5 x i8] c"none\00", align 1
@.str.92 = private unnamed_addr constant [53 x i8] c"\016%5u %04x %6d %8p %8p %8ld %8p %sv%u %s a:%ps q:%s\0A\00", align 1
@.str.90 = private unnamed_addr constant [57 x i8] c"\016-pid- flgs status -client- --rqstp- -timeout ---ops--\0A\00", align 1
@__kcrctab_xprt_register_transport = internal constant i64 ptrtoint (i8** @__crc_xprt_register_transport to i64), section "___kcrctab_gpl+xprt_register_transport", align 8
@__ksymtab_xprt_register_transport = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.xprt_class*)* @xprt_register_transport to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_xprt_register_transport, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_register_transport", align 8
@__kcrctab_xprt_unregister_transport = internal constant i64 ptrtoint (i8** @__crc_xprt_unregister_transport to i64), section "___kcrctab_gpl+xprt_unregister_transport", align 8
@__ksymtab_xprt_unregister_transport = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.xprt_class*)* @xprt_unregister_transport to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_xprt_unregister_transport, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_unregister_transport", align 8
@__kcrctab_xprt_load_transport = internal constant i64 ptrtoint (i8** @__crc_xprt_load_transport to i64), section "___kcrctab_gpl+xprt_load_transport", align 8
@__ksymtab_xprt_load_transport = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i8*)* @xprt_load_transport to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_xprt_load_transport, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_load_transport", align 8
@__kcrctab_xprt_reserve_xprt = internal constant i64 ptrtoint (i8** @__crc_xprt_reserve_xprt to i64), section "___kcrctab_gpl+xprt_reserve_xprt", align 8
@__ksymtab_xprt_reserve_xprt = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_reserve_xprt to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_xprt_reserve_xprt, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_reserve_xprt", align 8
@__kcrctab_xprt_reserve_xprt_cong = internal constant i64 ptrtoint (i8** @__crc_xprt_reserve_xprt_cong to i64), section "___kcrctab_gpl+xprt_reserve_xprt_cong", align 8
@__ksymtab_xprt_reserve_xprt_cong = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_reserve_xprt_cong to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_xprt_reserve_xprt_cong, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_reserve_xprt_cong", align 8
@__kcrctab_xprt_release_xprt = internal constant i64 ptrtoint (i8** @__crc_xprt_release_xprt to i64), section "___kcrctab_gpl+xprt_release_xprt", align 8
@__ksymtab_xprt_release_xprt = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_release_xprt to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_xprt_release_xprt, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_release_xprt", align 8
@__kcrctab_xprt_release_xprt_cong = internal constant i64 ptrtoint (i8** @__crc_xprt_release_xprt_cong to i64), section "___kcrctab_gpl+xprt_release_xprt_cong", align 8
@__ksymtab_xprt_release_xprt_cong = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_release_xprt_cong to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_xprt_release_xprt_cong, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_release_xprt_cong", align 8
@__kcrctab_xprt_release_rqst_cong = internal constant i64 ptrtoint (i8** @__crc_xprt_release_rqst_cong to i64), section "___kcrctab_gpl+xprt_release_rqst_cong", align 8
@__ksymtab_xprt_release_rqst_cong = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_task*)* @xprt_release_rqst_cong to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_xprt_release_rqst_cong, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_release_rqst_cong", align 8
@__kcrctab_xprt_adjust_cwnd = internal constant i64 ptrtoint (i8** @__crc_xprt_adjust_cwnd to i64), section "___kcrctab_gpl+xprt_adjust_cwnd", align 8
@__ksymtab_xprt_adjust_cwnd = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_xprt*, %struct.rpc_task*, i32)* @xprt_adjust_cwnd to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_xprt_adjust_cwnd, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_adjust_cwnd", align 8
@__kcrctab_xprt_wake_pending_tasks = internal constant i64 ptrtoint (i8** @__crc_xprt_wake_pending_tasks to i64), section "___kcrctab_gpl+xprt_wake_pending_tasks", align 8
@__ksymtab_xprt_wake_pending_tasks = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_xprt*, i32)* @xprt_wake_pending_tasks to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_xprt_wake_pending_tasks, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_wake_pending_tasks", align 8
@__kcrctab_xprt_wait_for_buffer_space = internal constant i64 ptrtoint (i8** @__crc_xprt_wait_for_buffer_space to i64), section "___kcrctab_gpl+xprt_wait_for_buffer_space", align 8
@__ksymtab_xprt_wait_for_buffer_space = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_task*, void (%struct.rpc_task*)*)* @xprt_wait_for_buffer_space to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab_xprt_wait_for_buffer_space, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_wait_for_buffer_space", align 8
@__kcrctab_xprt_write_space = internal constant i64 ptrtoint (i8** @__crc_xprt_write_space to i64), section "___kcrctab_gpl+xprt_write_space", align 8
@__ksymtab_xprt_write_space = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_xprt*)* @xprt_write_space to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_xprt_write_space, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_write_space", align 8
@__kcrctab_xprt_set_retrans_timeout_def = internal constant i64 ptrtoint (i8** @__crc_xprt_set_retrans_timeout_def to i64), section "___kcrctab_gpl+xprt_set_retrans_timeout_def", align 8
@__ksymtab_xprt_set_retrans_timeout_def = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_task*)* @xprt_set_retrans_timeout_def to i64), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__kstrtab_xprt_set_retrans_timeout_def, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_set_retrans_timeout_def", align 8
@__kcrctab_xprt_set_retrans_timeout_rtt = internal constant i64 ptrtoint (i8** @__crc_xprt_set_retrans_timeout_rtt to i64), section "___kcrctab_gpl+xprt_set_retrans_timeout_rtt", align 8
@__ksymtab_xprt_set_retrans_timeout_rtt = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_task*)* @xprt_set_retrans_timeout_rtt to i64), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__kstrtab_xprt_set_retrans_timeout_rtt, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_set_retrans_timeout_rtt", align 8
@__kcrctab_xprt_disconnect_done = internal constant i64 ptrtoint (i8** @__crc_xprt_disconnect_done to i64), section "___kcrctab_gpl+xprt_disconnect_done", align 8
@__ksymtab_xprt_disconnect_done = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_xprt*)* @xprt_disconnect_done to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_xprt_disconnect_done, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_disconnect_done", align 8
@__kcrctab_xprt_lookup_rqst = internal constant i64 ptrtoint (i8** @__crc_xprt_lookup_rqst to i64), section "___kcrctab_gpl+xprt_lookup_rqst", align 8
@__ksymtab_xprt_lookup_rqst = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_rqst* (%struct.rpc_xprt*, i32)* @xprt_lookup_rqst to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_xprt_lookup_rqst, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_lookup_rqst", align 8
@__kcrctab_xprt_complete_rqst = internal constant i64 ptrtoint (i8** @__crc_xprt_complete_rqst to i64), section "___kcrctab_gpl+xprt_complete_rqst", align 8
@__ksymtab_xprt_complete_rqst = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_task*, i32)* @xprt_complete_rqst to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_xprt_complete_rqst, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_complete_rqst", align 8
@__kcrctab_xprt_alloc_slot = internal constant i64 ptrtoint (i8** @__crc_xprt_alloc_slot to i64), section "___kcrctab_gpl+xprt_alloc_slot", align 8
@__ksymtab_xprt_alloc_slot = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_alloc_slot to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_xprt_alloc_slot, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_alloc_slot", align 8
@__kcrctab_xprt_lock_and_alloc_slot = internal constant i64 ptrtoint (i8** @__crc_xprt_lock_and_alloc_slot to i64), section "___kcrctab_gpl+xprt_lock_and_alloc_slot", align 8
@__ksymtab_xprt_lock_and_alloc_slot = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_lock_and_alloc_slot to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_xprt_lock_and_alloc_slot, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_lock_and_alloc_slot", align 8
@__kcrctab_xprt_alloc = internal constant i64 ptrtoint (i8** @__crc_xprt_alloc to i64), section "___kcrctab_gpl+xprt_alloc", align 8
@__ksymtab_xprt_alloc = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_xprt* (%struct.net*, i64, i32, i32)* @xprt_alloc to i64), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__kstrtab_xprt_alloc, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_alloc", align 8
@__kcrctab_xprt_free = internal constant i64 ptrtoint (i8** @__crc_xprt_free to i64), section "___kcrctab_gpl+xprt_free", align 8
@__ksymtab_xprt_free = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_xprt*)* @xprt_free to i64), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__kstrtab_xprt_free, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_free", align 8
@__kstrtab_xprt_free = internal constant [10 x i8] c"xprt_free\00", section "__ksymtab_strings", align 1
@__crc_xprt_free = extern_weak global i8*, align 8
@__kstrtab_xprt_alloc = internal constant [11 x i8] c"xprt_alloc\00", section "__ksymtab_strings", align 1
@.str.40.9 = private unnamed_addr constant [32 x i8] c"&(&xprt->transport_lock)->rlock\00", align 1
@xprt_init.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.42.10 = private unnamed_addr constant [30 x i8] c"&(&xprt->reserve_lock)->rlock\00", align 1
@xprt_init.__key.41 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.44.12 = private unnamed_addr constant [28 x i8] c"&(&xprt->bc_pa_lock)->rlock\00", align 1
@xprt_init.__key.43 = internal global %struct.lock_class_key zeroinitializer, align 1
@jiffies = external global i64, align 8
@.str.45.13 = private unnamed_addr constant [13 x i8] c"xprt_binding\00", align 1
@.str.46.14 = private unnamed_addr constant [13 x i8] c"xprt_pending\00", align 1
@.str.47.15 = private unnamed_addr constant [13 x i8] c"xprt_sending\00", align 1
@.str.48.16 = private unnamed_addr constant [13 x i8] c"xprt_backlog\00", align 1
@__crc_xprt_alloc = extern_weak global i8*, align 8
@__kstrtab_xprt_lock_and_alloc_slot = internal constant [25 x i8] c"xprt_lock_and_alloc_slot\00", section "__ksymtab_strings", align 1
@.str.16.23 = private unnamed_addr constant [66 x i8] c"\01dRPC:       dynamic allocation of request slot failed! Retrying\0A\00", align 1
@.str.17.24 = private unnamed_addr constant [39 x i8] c"\01dRPC:       waiting for request slot\0A\00", align 1
@.str.39.27 = private unnamed_addr constant [37 x i8] c"\01dRPC: %5u reserved req %p xid %08x\0A\00", align 1
@__crc_xprt_lock_and_alloc_slot = extern_weak global i8*, align 8
@__kstrtab_xprt_alloc_slot = internal constant [16 x i8] c"xprt_alloc_slot\00", section "__ksymtab_strings", align 1
@__crc_xprt_alloc_slot = extern_weak global i8*, align 8
@__kstrtab_xprt_complete_rqst = internal constant [19 x i8] c"xprt_complete_rqst\00", section "__ksymtab_strings", align 1
@.str.12.34 = private unnamed_addr constant [50 x i8] c"\01dRPC: %5u xid %08x complete (%d bytes received)\0A\00", align 1
@__crc_xprt_complete_rqst = extern_weak global i8*, align 8
@__kstrtab_xprt_lookup_rqst = internal constant [17 x i8] c"xprt_lookup_rqst\00", section "__ksymtab_strings", align 1
@.str.11.35 = private unnamed_addr constant [53 x i8] c"\01dRPC:       xprt_lookup_rqst did not find xid %08x\0A\00", align 1
@__crc_xprt_lookup_rqst = extern_weak global i8*, align 8
@__kstrtab_xprt_disconnect_done = internal constant [21 x i8] c"xprt_disconnect_done\00", section "__ksymtab_strings", align 1
@.str.7.36 = private unnamed_addr constant [40 x i8] c"\01dRPC:       disconnected transport %p\0A\00", align 1
@__crc_xprt_disconnect_done = extern_weak global i8*, align 8
@__kstrtab_xprt_set_retrans_timeout_rtt = internal constant [29 x i8] c"xprt_set_retrans_timeout_rtt\00", section "__ksymtab_strings", align 1
@__crc_xprt_set_retrans_timeout_rtt = extern_weak global i8*, align 8
@__kstrtab_xprt_set_retrans_timeout_def = internal constant [29 x i8] c"xprt_set_retrans_timeout_def\00", section "__ksymtab_strings", align 1
@__crc_xprt_set_retrans_timeout_def = extern_weak global i8*, align 8
@__kstrtab_xprt_write_space = internal constant [17 x i8] c"xprt_write_space\00", section "__ksymtab_strings", align 1
@.str.5.38 = private unnamed_addr constant [58 x i8] c"\01dRPC:       write space: waking waiting task on xprt %p\0A\00", align 1
@__crc_xprt_write_space = extern_weak global i8*, align 8
@__kstrtab_xprt_wait_for_buffer_space = internal constant [27 x i8] c"xprt_wait_for_buffer_space\00", section "__ksymtab_strings", align 1
@__crc_xprt_wait_for_buffer_space = extern_weak global i8*, align 8
@__kstrtab_xprt_wake_pending_tasks = internal constant [24 x i8] c"xprt_wake_pending_tasks\00", section "__ksymtab_strings", align 1
@__crc_xprt_wake_pending_tasks = extern_weak global i8*, align 8
@__kstrtab_xprt_adjust_cwnd = internal constant [17 x i8] c"xprt_adjust_cwnd\00", section "__ksymtab_strings", align 1
@.str.4.39 = private unnamed_addr constant [46 x i8] c"\01dRPC:       cong %ld, cwnd was %ld, now %ld\0A\00", align 1
@.str.30 = private unnamed_addr constant [52 x i8] c"\01dRPC: %5u xprt_cwnd_limited cong = %lu cwnd = %lu\0A\00", align 1
@__crc_xprt_adjust_cwnd = extern_weak global i8*, align 8
@__kstrtab_xprt_release_rqst_cong = internal constant [23 x i8] c"xprt_release_rqst_cong\00", section "__ksymtab_strings", align 1
@__crc_xprt_release_rqst_cong = extern_weak global i8*, align 8
@__kstrtab_xprt_release_xprt_cong = internal constant [23 x i8] c"xprt_release_xprt_cong\00", section "__ksymtab_strings", align 1
@__crc_xprt_release_xprt_cong = extern_weak global i8*, align 8
@__kstrtab_xprt_release_xprt = internal constant [18 x i8] c"xprt_release_xprt\00", section "__ksymtab_strings", align 1
@__crc_xprt_release_xprt = extern_weak global i8*, align 8
@__kstrtab_xprt_reserve_xprt_cong = internal constant [23 x i8] c"xprt_reserve_xprt_cong\00", section "__ksymtab_strings", align 1
@.str.3.41 = private unnamed_addr constant [40 x i8] c"\01dRPC: %5u failed to lock transport %p\0A\00", align 1
@__crc_xprt_reserve_xprt_cong = extern_weak global i8*, align 8
@__kstrtab_xprt_reserve_xprt = internal constant [18 x i8] c"xprt_reserve_xprt\00", section "__ksymtab_strings", align 1
@__crc_xprt_reserve_xprt = extern_weak global i8*, align 8
@__kstrtab_xprt_load_transport = internal constant [20 x i8] c"xprt_load_transport\00", section "__ksymtab_strings", align 1
@xprt_list_lock = internal global %struct.spinlock { %union.anon.11 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.29.43, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@xprt_list = internal global %struct.list_head { %struct.list_head* @xprt_list, %struct.list_head* @xprt_list }, align 8
@.str.2.42 = private unnamed_addr constant [7 x i8] c"xprt%s\00", align 1
@.str.29.43 = private unnamed_addr constant [15 x i8] c"xprt_list_lock\00", align 1
@__crc_xprt_load_transport = extern_weak global i8*, align 8
@__kstrtab_xprt_unregister_transport = internal constant [26 x i8] c"xprt_unregister_transport\00", section "__ksymtab_strings", align 1
@.str.1.44 = private unnamed_addr constant [42 x i8] c"\016RPC: Unregistered %s transport module.\0A\00", align 1
@__crc_xprt_unregister_transport = extern_weak global i8*, align 8
@__kstrtab_xprt_register_transport = internal constant [24 x i8] c"xprt_register_transport\00", section "__ksymtab_strings", align 1
@.str.63 = private unnamed_addr constant [40 x i8] c"\016RPC: Registered %s transport module.\0A\00", align 1
@__crc_xprt_register_transport = extern_weak global i8*, align 8
@.str.6.66 = private unnamed_addr constant [40 x i8] c"\014xprt_adjust_timeout: rq_timeout = 0!\0A\00", align 1
@.str.9.72 = private unnamed_addr constant [3 x i8] c"is\00", align 1
@.str.10.73 = private unnamed_addr constant [7 x i8] c"is not\00", align 1
@.str.8.74 = private unnamed_addr constant [46 x i8] c"\01dRPC: %5u xprt_connect xprt %p %s connected\0A\00", align 1
@.str.31.76 = private unnamed_addr constant [56 x i8] c"\01dRPC: %5u xprt_connect_status: connection established\0A\00", align 1
@.str.32.77 = private unnamed_addr constant [42 x i8] c"\01dRPC: %5u xprt_connect_status: retrying\0A\00", align 1
@.str.33.78 = private unnamed_addr constant [59 x i8] c"\01dRPC: %5u xprt_connect_status: connect attempt timed out\0A\00", align 1
@.str.34.79 = private unnamed_addr constant [66 x i8] c"\01dRPC: %5u xprt_connect_status: error %d connecting to server %s\0A\00", align 1
@.str.13.82 = private unnamed_addr constant [34 x i8] c"\01dRPC: %5u xprt_prepare_transmit\0A\00", align 1
@.str.14.87 = private unnamed_addr constant [30 x i8] c"\01dRPC: %5u xprt_transmit(%u)\0A\00", align 1
@.str.15.89 = private unnamed_addr constant [26 x i8] c"\01dRPC: %5u xmit complete\0A\00", align 1
@.str.35.90 = private unnamed_addr constant [23 x i8] c"\01dRPC: %5u xprt_timer\0A\00", align 1
@xprt_reserve.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.18.95 = private unnamed_addr constant [18 x i8] c"net/sunrpc/xprt.c\00", align 1
@rcu_read_unlock.__warned.98 = internal global i8 0, section ".data.unlikely", align 1
@rcu_read_lock.__warned.106 = internal global i8 0, section ".data.unlikely", align 1
@xprt_retry_reserve.__warned = internal global i8 0, section ".data.unlikely", align 1
@xprt_release.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.20.112 = private unnamed_addr constant [31 x i8] c"\01dRPC: %5u release request %p\0A\00", align 1
@.str.21.115 = private unnamed_addr constant [37 x i8] c"\013RPC: transport (%d) not supported\0A\00", align 1
@.str.22.116 = private unnamed_addr constant [49 x i8] c"\01dRPC:       xprt_create_transport: failed, %ld\0A\00", align 1
@.str.23.117 = private unnamed_addr constant [22 x i8] c"(&xprt->task_cleanup)\00", align 1
@xprt_create_transport.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.25.118 = private unnamed_addr constant [17 x i8] c"((&xprt->timer))\00", align 1
@xprt_create_transport.__key.24 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.27.119 = private unnamed_addr constant [15 x i8] c"(&xprt->timer)\00", align 1
@xprt_create_transport.__key.26 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.28.120 = private unnamed_addr constant [49 x i8] c"\01dRPC:       created transport %p with %u slots\0A\00", align 1
@.str.49.121 = private unnamed_addr constant [38 x i8] c"\01dRPC:       destroying transport %p\0A\00", align 1
@__kcrctab_xdr_skb_read_bits = internal constant i64 ptrtoint (i8** @__crc_xdr_skb_read_bits to i64), section "___kcrctab_gpl+xdr_skb_read_bits", align 8
@__ksymtab_xdr_skb_read_bits = internal constant %struct.kernel_symbol { i64 ptrtoint (i64 (%struct.xdr_skb_reader*, i8*, i64)* @xdr_skb_read_bits to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_xdr_skb_read_bits, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_skb_read_bits", align 8
@__kcrctab_xdr_partial_copy_from_skb = internal constant i64 ptrtoint (i8** @__crc_xdr_partial_copy_from_skb to i64), section "___kcrctab_gpl+xdr_partial_copy_from_skb", align 8
@__ksymtab_xdr_partial_copy_from_skb = internal constant %struct.kernel_symbol { i64 ptrtoint (i64 (%struct.xdr_buf*, i32, %struct.xdr_skb_reader*, i64 (%struct.xdr_skb_reader*, i8*, i64)*)* @xdr_partial_copy_from_skb to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_xdr_partial_copy_from_skb, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_partial_copy_from_skb", align 8
@__kcrctab_csum_partial_copy_to_xdr = internal constant i64 ptrtoint (i8** @__crc_csum_partial_copy_to_xdr to i64), section "___kcrctab_gpl+csum_partial_copy_to_xdr", align 8
@__ksymtab_csum_partial_copy_to_xdr = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.xdr_buf*, %struct.sk_buff*)* @csum_partial_copy_to_xdr to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_csum_partial_copy_to_xdr, i32 0, i32 0) }, section "___ksymtab_gpl+csum_partial_copy_to_xdr", align 8
@__kstrtab_csum_partial_copy_to_xdr = internal constant [25 x i8] c"csum_partial_copy_to_xdr\00", section "__ksymtab_strings", align 1
@__crc_csum_partial_copy_to_xdr = extern_weak global i8*, align 8
@__kstrtab_xdr_partial_copy_from_skb = internal constant [26 x i8] c"xdr_partial_copy_from_skb\00", section "__ksymtab_strings", align 1
@__crc_xdr_partial_copy_from_skb = extern_weak global i8*, align 8
@__kstrtab_xdr_skb_read_bits = internal constant [18 x i8] c"xdr_skb_read_bits\00", section "__ksymtab_strings", align 1
@__crc_xdr_skb_read_bits = extern_weak global i8*, align 8
@__kcrctab_xs_swapper = internal constant i64 ptrtoint (i8** @__crc_xs_swapper to i64), section "___kcrctab_gpl+xs_swapper", align 8
@__ksymtab_xs_swapper = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rpc_xprt*, i32)* @xs_swapper to i64), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__kstrtab_xs_swapper, i32 0, i32 0) }, section "___ksymtab_gpl+xs_swapper", align 8
@__param_min_resvport = internal constant %struct.kernel_param { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.4.245, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_portnr, i16 420, i16 -1, %union.anon.57 { i8* bitcast (i32* @xprt_min_resvport to i8*) } }, section "__param", align 8
@__UNIQUE_ID_min_resvporttype3027 = internal constant [29 x i8] c"parmtype=min_resvport:portnr\00", section ".modinfo", align 1
@__param_max_resvport = internal constant %struct.kernel_param { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.5.246, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_portnr, i16 420, i16 -1, %union.anon.57 { i8* bitcast (i32* @xprt_max_resvport to i8*) } }, section "__param", align 8
@__UNIQUE_ID_max_resvporttype3028 = internal constant [29 x i8] c"parmtype=max_resvport:portnr\00", section ".modinfo", align 1
@__param_tcp_slot_table_entries = internal constant %struct.kernel_param { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.2.243, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_slot_table_size, i16 420, i16 -1, %union.anon.57 { i8* bitcast (i32* @xprt_tcp_slot_table_entries to i8*) } }, section "__param", align 8
@__UNIQUE_ID_tcp_slot_table_entriestype3063 = internal constant [48 x i8] c"parmtype=tcp_slot_table_entries:slot_table_size\00", section ".modinfo", align 1
@__param_tcp_max_slot_table_entries = internal constant %struct.kernel_param { i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3.244, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_max_slot_table_size, i16 420, i16 -1, %union.anon.57 { i8* bitcast (i32* @xprt_max_tcp_slot_table_entries to i8*) } }, section "__param", align 8
@__UNIQUE_ID_tcp_max_slot_table_entriestype3065 = internal constant [56 x i8] c"parmtype=tcp_max_slot_table_entries:max_slot_table_size\00", section ".modinfo", align 1
@__param_udp_slot_table_entries = internal constant %struct.kernel_param { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1.242, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_slot_table_size, i16 420, i16 -1, %union.anon.57 { i8* bitcast (i32* @xprt_udp_slot_table_entries to i8*) } }, section "__param", align 8
@__UNIQUE_ID_udp_slot_table_entriestype3067 = internal constant [48 x i8] c"parmtype=udp_slot_table_entries:slot_table_size\00", section ".modinfo", align 1
@param_ops_slot_table_size = internal global %struct.kernel_param_ops { i32 (i8*, %struct.kernel_param*)* @param_set_slot_table_size, i32 (i8*, %struct.kernel_param*)* @param_get_uint, void (i8*)* null }, align 8
@xprt_udp_slot_table_entries = internal global i32 16, align 4
@param_ops_max_slot_table_size = internal global %struct.kernel_param_ops { i32 (i8*, %struct.kernel_param*)* @param_set_max_slot_table_size, i32 (i8*, %struct.kernel_param*)* @param_get_uint, void (i8*)* null }, align 8
@xprt_max_tcp_slot_table_entries = internal global i32 65536, align 4
@xprt_tcp_slot_table_entries = internal global i32 2, align 4
@param_ops_portnr = internal global %struct.kernel_param_ops { i32 (i8*, %struct.kernel_param*)* @param_set_portnr, i32 (i8*, %struct.kernel_param*)* @param_get_uint, void (i8*)* null }, align 8
@xprt_max_resvport = internal global i32 1023, align 4
@xprt_min_resvport = internal global i32 665, align 4
@__kstrtab_xs_swapper = internal constant [11 x i8] c"xs_swapper\00", section "__ksymtab_strings", align 1
@__crc_xs_swapper = extern_weak global i8*, align 8
@sunrpc_table_header = internal global %struct.ctl_table_header* null, align 8
@sunrpc_table = internal global [2 x %struct.ctl_table] [%struct.ctl_table { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1368, i32 0, i32 0), i8* null, i32 0, i16 365, %struct.ctl_table* getelementptr inbounds ([7 x %struct.ctl_table], [7 x %struct.ctl_table]* @xs_tunables_table, i32 0, i32 0), i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)* null, %struct.ctl_table_poll* null, i8* null, i8* null }, %struct.ctl_table zeroinitializer], align 16
@xs_local_transport = internal global %struct.xprt_class { %struct.list_head { %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_local_transport, i32 0, i32 0), %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_local_transport, i32 0, i32 0) }, i32 257, %struct.rpc_xprt* (%struct.xprt_create*)* @xs_setup_local, %struct.module* @__this_module, [32 x i8] c"named UNIX socket\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, align 8
@xs_udp_transport = internal global %struct.xprt_class { %struct.list_head { %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_udp_transport, i32 0, i32 0), %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_udp_transport, i32 0, i32 0) }, i32 17, %struct.rpc_xprt* (%struct.xprt_create*)* @xs_setup_udp, %struct.module* @__this_module, [32 x i8] c"udp\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, align 8
@xs_tcp_transport = internal global %struct.xprt_class { %struct.list_head { %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_tcp_transport, i32 0, i32 0), %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_tcp_transport, i32 0, i32 0) }, i32 6, %struct.rpc_xprt* (%struct.xprt_create*)* @xs_setup_tcp, %struct.module* @__this_module, [32 x i8] c"tcp\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, align 8
@xs_bc_tcp_transport = internal global %struct.xprt_class { %struct.list_head { %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_bc_tcp_transport, i32 0, i32 0), %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_bc_tcp_transport, i32 0, i32 0) }, i32 -2147483642, %struct.rpc_xprt* (%struct.xprt_create*)* @xs_setup_bc_tcp, %struct.module* @__this_module, [32 x i8] c"tcp NFSv4.1 backchannel\00\00\00\00\00\00\00\00\00" }, align 8
@__this_module = external global %struct.module, align 8
@xs_tcp_default_timeout = internal constant %struct.rpc_timeout { i64 15000, i64 15000, i64 0, i32 2, i8 0 }, align 8
@bc_tcp_ops = internal global %struct.rpc_xprt_ops { void (%struct.rpc_xprt*, i64, i64)* null, i32 (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_reserve_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_release_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_alloc_slot, void (%struct.rpc_task*)* @xs_local_rpcbind, void (%struct.rpc_xprt*, i16)* null, void (%struct.rpc_xprt*, %struct.rpc_task*)* null, i8* (%struct.rpc_task*, i64)* @bc_malloc, void (i8*)* @bc_free, i32 (%struct.rpc_task*)* @bc_send_request, void (%struct.rpc_task*)* @xprt_set_retrans_timeout_def, void (%struct.rpc_xprt*, %struct.rpc_task*)* null, void (%struct.rpc_task*)* null, void (%struct.rpc_xprt*)* @bc_close, void (%struct.rpc_xprt*)* @bc_destroy, void (%struct.rpc_xprt*, %struct.seq_file*)* @xs_tcp_print_stats }, align 8
@.str.49.132 = private unnamed_addr constant [49 x i8] c"\01dRPC:       set up xprt to %s (port %s) via %s\0A\00", align 1
@.str.27.136 = private unnamed_addr constant [5 x i8] c"%4hx\00", align 1
@.str.24 = private unnamed_addr constant [5 x i8] c"%08x\00", align 1
@.str.25.139 = private unnamed_addr constant [5 x i8] c"%pi6\00", align 1
@.str.13.140 = private unnamed_addr constant [22 x i8] c"net/sunrpc/xprtsock.c\00", align 1
@.str.77.143 = private unnamed_addr constant [67 x i8] c"\09xprt:\09tcp %u %lu %lu %lu %ld %lu %lu %lu %llu %llu %lu %llu %llu\0A\00", align 1
@.str.106 = private unnamed_addr constant [34 x i8] c"\01dsending request with xid: %08x\0A\00", align 1
@.str.107 = private unnamed_addr constant [34 x i8] c"\015Error sending entire callback!\0A\00", align 1
@bc_malloc.__warned = internal global i8 0, section ".data.unlikely", align 1
@xs_local_rpcbind.__warned = internal global i8 0, section ".data.unlikely", align 1
@rcu_read_unlock.__warned.151 = internal global i8 0, section ".data.unlikely", align 1
@rcu_read_lock.__warned.159 = internal global i8 0, section ".data.unlikely", align 1
@.str.10.162 = private unnamed_addr constant [47 x i8] c"\01dRPC:       xs_setup_xprt: address too large\0A\00", align 1
@.str.11.163 = private unnamed_addr constant [56 x i8] c"\01dRPC:       xs_setup_xprt: couldn't allocate rpc_xprt\0A\00", align 1
@xs_init_anyaddr.sin = internal constant %struct.sockaddr_in { i16 2, i16 0, %struct.atomic_t zeroinitializer, [8 x i8] zeroinitializer }, align 4
@xs_init_anyaddr.sin6 = internal constant { i16, i16, i32, { { [16 x i8] } }, i32 } { i16 10, i16 0, i32 0, { { [16 x i8] } } zeroinitializer, i32 0 }, align 4
@.str.12.164 = private unnamed_addr constant [37 x i8] c"\01dRPC:       %s: Bad address family\0A\00", align 1
@__func__.xs_init_anyaddr = private unnamed_addr constant [16 x i8] c"xs_init_anyaddr\00", align 1
@xs_tcp_ops = internal global %struct.rpc_xprt_ops { void (%struct.rpc_xprt*, i64, i64)* null, i32 (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_reserve_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_tcp_release_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_lock_and_alloc_slot, void (%struct.rpc_task*)* @rpcb_getport_async, void (%struct.rpc_xprt*, i16)* @xs_set_port, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_connect, i8* (%struct.rpc_task*, i64)* @rpc_malloc, void (i8*)* @rpc_free, i32 (%struct.rpc_task*)* @xs_tcp_send_request, void (%struct.rpc_task*)* @xprt_set_retrans_timeout_def, void (%struct.rpc_xprt*, %struct.rpc_task*)* null, void (%struct.rpc_task*)* null, void (%struct.rpc_xprt*)* @xs_tcp_close, void (%struct.rpc_xprt*)* @xs_destroy, void (%struct.rpc_xprt*, %struct.seq_file*)* @xs_tcp_print_stats }, align 8
@.str.42.165 = private unnamed_addr constant [38 x i8] c"(&(&transport->connect_worker)->work)\00", align 1
@xs_setup_tcp.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.44.167 = private unnamed_addr constant [39 x i8] c"(&(&transport->connect_worker)->timer)\00", align 1
@xs_setup_tcp.__key.71 = internal global %struct.lock_class_key zeroinitializer, align 1
@xs_setup_tcp.__key.73 = internal global %struct.lock_class_key zeroinitializer, align 1
@xs_setup_tcp.__key.74 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.50.169 = private unnamed_addr constant [50 x i8] c"\01dRPC:       set up xprt to %s (autobind) via %s\0A\00", align 1
@.str.57.174 = private unnamed_addr constant [63 x i8] c"\01dRPC:       worker connecting xprt %p via %s to %s (port %s)\0A\00", align 1
@.str.78.175 = private unnamed_addr constant [62 x i8] c"\01dRPC:       %p connect status %d connected %d sock state %d\0A\00", align 1
@.str.79 = private unnamed_addr constant [41 x i8] c"%s: connect returned unhandled error %d\0A\00", align 1
@__func__.xs_tcp_setup_socket = private unnamed_addr constant [20 x i8] c"xs_tcp_setup_socket\00", align 1
@.str.104 = private unnamed_addr constant [47 x i8] c"\01dRPC:       xs_tcp_state_change client %p...\0A\00", align 1
@.str.105 = private unnamed_addr constant [64 x i8] c"\01dRPC:       state %x conn %d dead %d zapped %d sk_shutdown %d\0A\00", align 1
@xs_tcp_fin_timeout = internal global i32 3750, section ".data..read_mostly", align 4
@.str.84.181 = private unnamed_addr constant [35 x i8] c"\01dRPC:       xs_tcp_data_ready...\0A\00", align 1
@.str.85.182 = private unnamed_addr constant [39 x i8] c"\01dRPC:       xs_tcp_data_recv started\0A\00", align 1
@.str.86.183 = private unnamed_addr constant [36 x i8] c"\01dRPC:       xs_tcp_data_recv done\0A\00", align 1
@.str.103 = private unnamed_addr constant [34 x i8] c"\01dRPC:       discarded %Zu bytes\0A\00", align 1
@.str.100 = private unnamed_addr constant [34 x i8] c"\014Callback slot table overflowed\0A\00", align 1
@.str.101 = private unnamed_addr constant [38 x i8] c"\01dRPC:       read callback  XID %08x\0A\00", align 1
@.str.102 = private unnamed_addr constant [43 x i8] c"\01dRPC:       add callback request to list\0A\00", align 1
@.str.97 = private unnamed_addr constant [41 x i8] c"\01dRPC:       XID %08x truncated request\0A\00", align 1
@.str.98 = private unnamed_addr constant [76 x i8] c"\01dRPC:       xprt = %p, tcp_copied = %lu, tcp_offset = %u, tcp_reclen = %u\0A\00", align 1
@.str.99 = private unnamed_addr constant [38 x i8] c"\01dRPC:       XID %08x read %Zd bytes\0A\00", align 1
@.str.95 = private unnamed_addr constant [34 x i8] c"\01dRPC:       read reply XID %08x\0A\00", align 1
@.str.96 = private unnamed_addr constant [42 x i8] c"\01dRPC:       XID %08x request not found!\0A\00", align 1
@.str.93.185 = private unnamed_addr constant [50 x i8] c"\01dRPC:       reading CALL/REPLY flag (%Zu bytes)\0A\00", align 1
@.str.94 = private unnamed_addr constant [43 x i8] c"\01dRPC:       invalid request message type\0A\00", align 1
@.str.89.186 = private unnamed_addr constant [38 x i8] c"\01dRPC:       reading XID (%Zu bytes)\0A\00", align 1
@.str.91.187 = private unnamed_addr constant [10 x i8] c"reply for\00", align 1
@.str.92.188 = private unnamed_addr constant [13 x i8] c"request with\00", align 1
@.str.90.189 = private unnamed_addr constant [34 x i8] c"\01dRPC:       reading %s XID %08x\0A\00", align 1
@.str.87.190 = private unnamed_addr constant [49 x i8] c"\01dRPC:       invalid TCP record fragment length\0A\00", align 1
@.str.88.191 = private unnamed_addr constant [55 x i8] c"\01dRPC:       reading TCP record fragment of length %d\0A\00", align 1
@.str.80.192 = private unnamed_addr constant [55 x i8] c"\01dRPC:       %s: TCP_CLOSEd and sk_shutdown set to %d\0A\00", align 1
@__func__.xs_tcp_reuse_connection = private unnamed_addr constant [24 x i8] c"xs_tcp_reuse_connection\00", align 1
@.str.81.193 = private unnamed_addr constant [61 x i8] c"\01dRPC:       %s: ESTABLISHED/SYN_SENT sk_shutdown set to %d\0A\00", align 1
@.str.82.194 = private unnamed_addr constant [50 x i8] c"\01dRPC:       disconnecting xprt %p to reuse port\0A\00", align 1
@.str.83.195 = private unnamed_addr constant [47 x i8] c"\01dRPC:       AF_UNSPEC connect return code %d\0A\00", align 1
@.str.58.196 = private unnamed_addr constant [53 x i8] c"\01dRPC:       can't create %d transport socket (%d).\0A\00", align 1
@.str.67 = private unnamed_addr constant [3 x i8] c"ok\00", align 1
@.str.65 = private unnamed_addr constant [34 x i8] c"\01dRPC:       %s %pI4:%u: %s (%d)\0A\00", align 1
@__func__.xs_bind = private unnamed_addr constant [8 x i8] c"xs_bind\00", align 1
@.str.68.199 = private unnamed_addr constant [34 x i8] c"\01dRPC:       %s %pI6:%u: %s (%d)\0A\00", align 1
@xs_reclassify_socket.__warned = internal global i8 0, section ".data.unlikely", align 1
@xs_reclassify_socket6.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@xs_reclassify_socket6.__key.62 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.63.203 = private unnamed_addr constant [19 x i8] c"slock-AF_INET6-RPC\00", align 1
@xs_slock_key = internal global [2 x %struct.lock_class_key] zeroinitializer, align 16
@.str.64.204 = private unnamed_addr constant [21 x i8] c"sk_lock-AF_INET6-RPC\00", align 1
@xs_key = internal global [2 x %struct.lock_class_key] zeroinitializer, align 16
@xs_reclassify_socket4.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@xs_reclassify_socket4.__key.59 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.60.205 = private unnamed_addr constant [18 x i8] c"slock-AF_INET-RPC\00", align 1
@.str.61.206 = private unnamed_addr constant [20 x i8] c"sk_lock-AF_INET-RPC\00", align 1
@xs_reclassify_socketu.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@xs_reclassify_socketu.__key.35 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.37.207 = private unnamed_addr constant [19 x i8] c"slock-AF_LOCAL-RPC\00", align 1
@.str.38.208 = private unnamed_addr constant [21 x i8] c"sk_lock-AF_LOCAL-RPC\00", align 1
@.str.55.209 = private unnamed_addr constant [33 x i8] c"\01dRPC:       xs_destroy xprt %p\0A\00", align 1
@.str.22.210 = private unnamed_addr constant [31 x i8] c"\01dRPC:       xs_close xprt %p\0A\00", align 1
@.str.18.211 = private unnamed_addr constant [13 x i8] c"packet data:\00", align 1
@.str.76.212 = private unnamed_addr constant [43 x i8] c"\01dRPC:       xs_tcp_send_request(%u) = %d\0A\00", align 1
@.str.20.213 = private unnamed_addr constant [53 x i8] c"\01dRPC:       sendmsg returned unrecognized error %d\0A\00", align 1
@.str.21.214 = private unnamed_addr constant [44 x i8] c"\01dRPC: %5u xmit incomplete (%u left of %u)\0A\00", align 1
@.str.52.217 = private unnamed_addr constant [57 x i8] c"\01dRPC:       xs_connect delayed xprt %p for %lu seconds\0A\00", align 1
@.str.53.218 = private unnamed_addr constant [43 x i8] c"\01dRPC:       xs_connect scheduled xprt %p\0A\00", align 1
@.str.51.219 = private unnamed_addr constant [45 x i8] c"\01dRPC:       setting port for xprt %p to %u\0A\00", align 1
@xs_udp_ops = internal global %struct.rpc_xprt_ops { void (%struct.rpc_xprt*, i64, i64)* @xs_udp_set_buffer_size, i32 (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_reserve_xprt_cong, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_release_xprt_cong, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_alloc_slot, void (%struct.rpc_task*)* @rpcb_getport_async, void (%struct.rpc_xprt*, i16)* @xs_set_port, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_connect, i8* (%struct.rpc_task*, i64)* @rpc_malloc, void (i8*)* @rpc_free, i32 (%struct.rpc_task*)* @xs_udp_send_request, void (%struct.rpc_task*)* @xprt_set_retrans_timeout_rtt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_udp_timer, void (%struct.rpc_task*)* @xprt_release_rqst_cong, void (%struct.rpc_xprt*)* @xs_close, void (%struct.rpc_xprt*)* @xs_destroy, void (%struct.rpc_xprt*, %struct.seq_file*)* @xs_udp_print_stats }, align 8
@xs_udp_default_timeout = internal constant %struct.rpc_timeout { i64 1250, i64 7500, i64 1250, i32 5, i8 0 }, align 8
@xs_setup_udp.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@xs_setup_udp.__key.43 = internal global %struct.lock_class_key zeroinitializer, align 1
@xs_setup_udp.__key.46 = internal global %struct.lock_class_key zeroinitializer, align 1
@xs_setup_udp.__key.47 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.69.223 = private unnamed_addr constant [35 x i8] c"\01dRPC:       xs_udp_data_ready...\0A\00", align 1
@.str.70.224 = private unnamed_addr constant [44 x i8] c"\01dRPC:       impossible RPC reply size %d!\0A\00", align 1
@.str.56.225 = private unnamed_addr constant [55 x i8] c"\09xprt:\09udp %u %lu %lu %lu %lu %llu %llu %lu %llu %llu\0A\00", align 1
@.str.54.226 = private unnamed_addr constant [43 x i8] c"\01dRPC:       xs_udp_send_request(%u) = %d\0A\00", align 1
@xs_local_ops = internal global %struct.rpc_xprt_ops { void (%struct.rpc_xprt*, i64, i64)* null, i32 (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_reserve_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_tcp_release_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_alloc_slot, void (%struct.rpc_task*)* @xs_local_rpcbind, void (%struct.rpc_xprt*, i16)* @xs_local_set_port, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_local_connect, i8* (%struct.rpc_task*, i64)* @rpc_malloc, void (i8*)* @rpc_free, i32 (%struct.rpc_task*)* @xs_local_send_request, void (%struct.rpc_task*)* @xprt_set_retrans_timeout_def, void (%struct.rpc_xprt*, %struct.rpc_task*)* null, void (%struct.rpc_task*)* null, void (%struct.rpc_xprt*)* @xs_close, void (%struct.rpc_xprt*)* @xs_local_destroy, void (%struct.rpc_xprt*, %struct.seq_file*)* @xs_local_print_stats }, align 8
@xs_local_default_timeout = internal constant %struct.rpc_timeout { i64 2500, i64 2500, i64 0, i32 2, i8 0 }, align 8
@.str.7.227 = private unnamed_addr constant [39 x i8] c"\01dRPC:       bad AF_LOCAL address: %s\0A\00", align 1
@.str.8.228 = private unnamed_addr constant [6 x i8] c"local\00", align 1
@.str.9.229 = private unnamed_addr constant [45 x i8] c"\01dRPC:       set up xprt to %s via AF_LOCAL\0A\00", align 1
@.str.28.230 = private unnamed_addr constant [59 x i8] c"\01dRPC:       can't create AF_LOCAL transport socket (%d).\0A\00", align 1
@.str.29.231 = private unnamed_addr constant [59 x i8] c"\01dRPC:       worker connecting xprt %p via AF_LOCAL to %s\0A\00", align 1
@.str.30.232 = private unnamed_addr constant [38 x i8] c"\01dRPC:       xprt %p connected to %s\0A\00", align 1
@.str.31.233 = private unnamed_addr constant [48 x i8] c"\01dRPC:       xprt %p: socket %s does not exist\0A\00", align 1
@.str.32.234 = private unnamed_addr constant [49 x i8] c"\01dRPC:       xprt %p: connection refused for %s\0A\00", align 1
@.str.33.235 = private unnamed_addr constant [45 x i8] c"\013%s: unhandled error (%d) connecting to %s\0A\00", align 1
@__func__.xs_local_setup_socket = private unnamed_addr constant [22 x i8] c"xs_local_setup_socket\00", align 1
@.str.39.236 = private unnamed_addr constant [20 x i8] c"\01dRPC:       %s...\0A\00", align 1
@__func__.xs_local_data_ready = private unnamed_addr constant [20 x i8] c"xs_local_data_ready\00", align 1
@.str.40.237 = private unnamed_addr constant [43 x i8] c"\01dRPC:       impossible RPC reply size %d\0A\00", align 1
@.str.41.238 = private unnamed_addr constant [34 x i8] c"\01dRPC:       sk_buff copy failed\0A\00", align 1
@.str.23.239 = private unnamed_addr constant [66 x i8] c"\09xprt:\09local %lu %lu %lu %ld %lu %lu %lu %llu %llu %lu %llu %llu\0A\00", align 1
@.str.19.240 = private unnamed_addr constant [26 x i8] c"\01dRPC:       %s(%u) = %d\0A\00", align 1
@__func__.xs_local_send_request = private unnamed_addr constant [22 x i8] c"xs_local_send_request\00", align 1
@xs_tunables_table = internal global [7 x %struct.ctl_table] [%struct.ctl_table { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.1.242, i32 0, i32 0), i8* bitcast (i32* @xprt_udp_slot_table_entries to i8*), i32 4, i16 420, %struct.ctl_table* null, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)* @proc_dointvec_minmax, %struct.ctl_table_poll* null, i8* bitcast (i32* @min_slot_table_size to i8*), i8* bitcast (i32* @max_slot_table_size to i8*) }, %struct.ctl_table { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.2.243, i32 0, i32 0), i8* bitcast (i32* @xprt_tcp_slot_table_entries to i8*), i32 4, i16 420, %struct.ctl_table* null, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)* @proc_dointvec_minmax, %struct.ctl_table_poll* null, i8* bitcast (i32* @min_slot_table_size to i8*), i8* bitcast (i32* @max_slot_table_size to i8*) }, %struct.ctl_table { i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.3.244, i32 0, i32 0), i8* bitcast (i32* @xprt_max_tcp_slot_table_entries to i8*), i32 4, i16 420, %struct.ctl_table* null, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)* @proc_dointvec_minmax, %struct.ctl_table_poll* null, i8* bitcast (i32* @min_slot_table_size to i8*), i8* bitcast (i32* @max_tcp_slot_table_limit to i8*) }, %struct.ctl_table { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.4.245, i32 0, i32 0), i8* bitcast (i32* @xprt_min_resvport to i8*), i32 4, i16 420, %struct.ctl_table* null, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)* @proc_dointvec_minmax, %struct.ctl_table_poll* null, i8* bitcast (i32* @xprt_min_resvport_limit to i8*), i8* bitcast (i32* @xprt_max_resvport_limit to i8*) }, %struct.ctl_table { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.5.246, i32 0, i32 0), i8* bitcast (i32* @xprt_max_resvport to i8*), i32 4, i16 420, %struct.ctl_table* null, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)* @proc_dointvec_minmax, %struct.ctl_table_poll* null, i8* bitcast (i32* @xprt_min_resvport_limit to i8*), i8* bitcast (i32* @xprt_max_resvport_limit to i8*) }, %struct.ctl_table { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.6.247, i32 0, i32 0), i8* bitcast (i32* @xs_tcp_fin_timeout to i8*), i32 4, i16 420, %struct.ctl_table* null, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)* @proc_dointvec_jiffies, %struct.ctl_table_poll* null, i8* null, i8* null }, %struct.ctl_table zeroinitializer], align 16
@.str.1.242 = private constant [23 x i8] c"udp_slot_table_entries\00", align 16
@min_slot_table_size = internal global i32 2, align 4
@max_slot_table_size = internal global i32 65536, align 4
@.str.2.243 = private constant [23 x i8] c"tcp_slot_table_entries\00", align 16
@.str.3.244 = private constant [27 x i8] c"tcp_max_slot_table_entries\00", align 16
@max_tcp_slot_table_limit = internal global i32 65536, align 4
@.str.4.245 = private constant [13 x i8] c"min_resvport\00", align 1
@xprt_min_resvport_limit = internal global i32 1, align 4
@xprt_max_resvport_limit = internal global i32 65535, align 4
@.str.5.246 = private constant [13 x i8] c"max_resvport\00", align 1
@.str.6.247 = private unnamed_addr constant [16 x i8] c"tcp_fin_timeout\00", align 1
@__tracepoint_rpc_call_status = global %struct.tracepoint { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__tpstrtab_rpc_call_status, i32 0, i32 0), %struct.arch_spinlock zeroinitializer, void ()* null, void ()* null, %struct.tracepoint_func* null }, section "__tracepoints", align 8
@__tpstrtab_rpc_call_status = internal constant [16 x i8] c"rpc_call_status\00", section "__tracepoints_strings", align 16
@__tracepoint_rpc_bind_status = global %struct.tracepoint { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__tpstrtab_rpc_bind_status, i32 0, i32 0), %struct.arch_spinlock zeroinitializer, void ()* null, void ()* null, %struct.tracepoint_func* null }, section "__tracepoints", align 8
@__tpstrtab_rpc_bind_status = internal constant [16 x i8] c"rpc_bind_status\00", section "__tracepoints_strings", align 16
@__tracepoint_rpc_connect_status = global %struct.tracepoint { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__tpstrtab_rpc_connect_status, i32 0, i32 0), %struct.arch_spinlock zeroinitializer, void ()* null, void ()* null, %struct.tracepoint_func* null }, section "__tracepoints", align 8
@__tpstrtab_rpc_connect_status = internal constant [19 x i8] c"rpc_connect_status\00", section "__tracepoints_strings", align 16
@__tracepoint_rpc_task_begin = global %struct.tracepoint { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__tpstrtab_rpc_task_begin, i32 0, i32 0), %struct.arch_spinlock zeroinitializer, void ()* null, void ()* null, %struct.tracepoint_func* null }, section "__tracepoints", align 8
@__tpstrtab_rpc_task_begin = internal constant [15 x i8] c"rpc_task_begin\00", section "__tracepoints_strings", align 1
@__tracepoint_rpc_task_run_action = global %struct.tracepoint { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__tpstrtab_rpc_task_run_action, i32 0, i32 0), %struct.arch_spinlock zeroinitializer, void ()* null, void ()* null, %struct.tracepoint_func* null }, section "__tracepoints", align 8
@__tpstrtab_rpc_task_run_action = internal constant [20 x i8] c"rpc_task_run_action\00", section "__tracepoints_strings", align 16
@__tracepoint_rpc_task_complete = global %struct.tracepoint { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__tpstrtab_rpc_task_complete, i32 0, i32 0), %struct.arch_spinlock zeroinitializer, void ()* null, void ()* null, %struct.tracepoint_func* null }, section "__tracepoints", align 8
@__tpstrtab_rpc_task_complete = internal constant [18 x i8] c"rpc_task_complete\00", section "__tracepoints_strings", align 16
@__tracepoint_rpc_task_sleep = global %struct.tracepoint { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__tpstrtab_rpc_task_sleep, i32 0, i32 0), %struct.arch_spinlock zeroinitializer, void ()* null, void ()* null, %struct.tracepoint_func* null }, section "__tracepoints", align 8
@__tpstrtab_rpc_task_sleep = internal constant [15 x i8] c"rpc_task_sleep\00", section "__tracepoints_strings", align 1
@__tracepoint_rpc_task_wakeup = global %struct.tracepoint { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__tpstrtab_rpc_task_wakeup, i32 0, i32 0), %struct.arch_spinlock zeroinitializer, void ()* null, void ()* null, %struct.tracepoint_func* null }, section "__tracepoints", align 8
@__tpstrtab_rpc_task_wakeup = internal constant [16 x i8] c"rpc_task_wakeup\00", section "__tracepoints_strings", align 16
@rpciod_workqueue = common global %struct.workqueue_struct* null, align 8
@__tracepoint_ptr_rpc_call_status = internal constant %struct.tracepoint* @__tracepoint_rpc_call_status, section "__tracepoints_ptrs", align 8
@__tracepoint_ptr_rpc_bind_status = internal constant %struct.tracepoint* @__tracepoint_rpc_bind_status, section "__tracepoints_ptrs", align 8
@__tracepoint_ptr_rpc_connect_status = internal constant %struct.tracepoint* @__tracepoint_rpc_connect_status, section "__tracepoints_ptrs", align 8
@__tracepoint_ptr_rpc_task_begin = internal constant %struct.tracepoint* @__tracepoint_rpc_task_begin, section "__tracepoints_ptrs", align 8
@__tracepoint_ptr_rpc_task_run_action = internal constant %struct.tracepoint* @__tracepoint_rpc_task_run_action, section "__tracepoints_ptrs", align 8
@__tracepoint_ptr_rpc_task_complete = internal constant %struct.tracepoint* @__tracepoint_rpc_task_complete, section "__tracepoints_ptrs", align 8
@__tracepoint_ptr_rpc_task_sleep = internal constant %struct.tracepoint* @__tracepoint_rpc_task_sleep, section "__tracepoints_ptrs", align 8
@__tracepoint_ptr_rpc_task_wakeup = internal constant %struct.tracepoint* @__tracepoint_rpc_task_wakeup, section "__tracepoints_ptrs", align 8
@event_class_rpc_task_status = internal global %struct.ftrace_event_class { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1368, i32 0, i32 0), i8* bitcast (void (i8*, %struct.rpc_task*)* @ftrace_raw_event_rpc_task_status to i8*), i8* bitcast (void (i8*, %struct.rpc_task*)* @perf_trace_rpc_task_status to i8*), i32 (%struct.ftrace_event_call*, i32, i8*)* @ftrace_event_reg, i32 (%struct.ftrace_event_call*)* @ftrace_define_fields_rpc_task_status, %struct.list_head* (%struct.ftrace_event_call*)* null, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.ftrace_event_class* @event_class_rpc_task_status to i8*), i64 48) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.ftrace_event_class* @event_class_rpc_task_status to i8*), i64 48) to %struct.list_head*) }, i32 (%struct.ftrace_event_call*)* @trace_event_raw_init }, section ".ref.data", align 8
@event_rpc_call_status = internal global %struct.ftrace_event_call { %struct.list_head zeroinitializer, %struct.ftrace_event_class* @event_class_rpc_task_status, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.1.379, i32 0, i32 0), %struct.trace_event { %struct.hlist_node zeroinitializer, %struct.list_head zeroinitializer, i32 0, %struct.trace_event_functions* @ftrace_event_type_funcs_rpc_task_status }, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @print_fmt_rpc_task_status, i32 0, i32 0), %struct.event_filter* null, %struct.list_head* null, i8* null, i8* null, i32 0, i32 0, %struct.hlist_head* null }, align 4
@__event_rpc_call_status = internal global %struct.ftrace_event_call* @event_rpc_call_status, section "_ftrace_events", align 8
@event_rpc_bind_status = internal global %struct.ftrace_event_call { %struct.list_head zeroinitializer, %struct.ftrace_event_class* @event_class_rpc_task_status, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2.378, i32 0, i32 0), %struct.trace_event { %struct.hlist_node zeroinitializer, %struct.list_head zeroinitializer, i32 0, %struct.trace_event_functions* @ftrace_event_type_funcs_rpc_task_status }, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @print_fmt_rpc_task_status, i32 0, i32 0), %struct.event_filter* null, %struct.list_head* null, i8* null, i8* null, i32 0, i32 0, %struct.hlist_head* null }, align 4
@__event_rpc_bind_status = internal global %struct.ftrace_event_call* @event_rpc_bind_status, section "_ftrace_events", align 8
@event_class_rpc_connect_status = internal global %struct.ftrace_event_class { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1368, i32 0, i32 0), i8* bitcast (void (i8*, %struct.rpc_task*, i32)* @ftrace_raw_event_rpc_connect_status to i8*), i8* bitcast (void (i8*, %struct.rpc_task*, i32)* @perf_trace_rpc_connect_status to i8*), i32 (%struct.ftrace_event_call*, i32, i8*)* @ftrace_event_reg, i32 (%struct.ftrace_event_call*)* @ftrace_define_fields_rpc_connect_status, %struct.list_head* (%struct.ftrace_event_call*)* null, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.ftrace_event_class* @event_class_rpc_connect_status to i8*), i64 48) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.ftrace_event_class* @event_class_rpc_connect_status to i8*), i64 48) to %struct.list_head*) }, i32 (%struct.ftrace_event_call*)* @trace_event_raw_init }, section ".ref.data", align 8
@event_rpc_connect_status = internal global %struct.ftrace_event_call { %struct.list_head zeroinitializer, %struct.ftrace_event_class* @event_class_rpc_connect_status, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.376, i32 0, i32 0), %struct.trace_event { %struct.hlist_node zeroinitializer, %struct.list_head zeroinitializer, i32 0, %struct.trace_event_functions* @ftrace_event_type_funcs_rpc_connect_status }, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @print_fmt_rpc_connect_status, i32 0, i32 0), %struct.event_filter* null, %struct.list_head* null, i8* null, i8* null, i32 0, i32 0, %struct.hlist_head* null }, align 4
@__event_rpc_connect_status = internal global %struct.ftrace_event_call* @event_rpc_connect_status, section "_ftrace_events", align 8
@event_class_rpc_task_running = internal global %struct.ftrace_event_class { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1368, i32 0, i32 0), i8* bitcast (void (i8*, %struct.rpc_clnt*, %struct.rpc_task*, i8*)* @ftrace_raw_event_rpc_task_running to i8*), i8* bitcast (void (i8*, %struct.rpc_clnt*, %struct.rpc_task*, i8*)* @perf_trace_rpc_task_running to i8*), i32 (%struct.ftrace_event_call*, i32, i8*)* @ftrace_event_reg, i32 (%struct.ftrace_event_call*)* @ftrace_define_fields_rpc_task_running, %struct.list_head* (%struct.ftrace_event_call*)* null, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.ftrace_event_class* @event_class_rpc_task_running to i8*), i64 48) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.ftrace_event_class* @event_class_rpc_task_running to i8*), i64 48) to %struct.list_head*) }, i32 (%struct.ftrace_event_call*)* @trace_event_raw_init }, section ".ref.data", align 8
@event_rpc_task_begin = internal global %struct.ftrace_event_call { %struct.list_head zeroinitializer, %struct.ftrace_event_class* @event_class_rpc_task_running, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.4.373, i32 0, i32 0), %struct.trace_event { %struct.hlist_node zeroinitializer, %struct.list_head zeroinitializer, i32 0, %struct.trace_event_functions* @ftrace_event_type_funcs_rpc_task_running }, i8* getelementptr inbounds ([134 x i8], [134 x i8]* @print_fmt_rpc_task_running, i32 0, i32 0), %struct.event_filter* null, %struct.list_head* null, i8* null, i8* null, i32 0, i32 0, %struct.hlist_head* null }, align 4
@__event_rpc_task_begin = internal global %struct.ftrace_event_call* @event_rpc_task_begin, section "_ftrace_events", align 8
@event_rpc_task_run_action = internal global %struct.ftrace_event_call { %struct.list_head zeroinitializer, %struct.ftrace_event_class* @event_class_rpc_task_running, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.5.372, i32 0, i32 0), %struct.trace_event { %struct.hlist_node zeroinitializer, %struct.list_head zeroinitializer, i32 0, %struct.trace_event_functions* @ftrace_event_type_funcs_rpc_task_running }, i8* getelementptr inbounds ([134 x i8], [134 x i8]* @print_fmt_rpc_task_running, i32 0, i32 0), %struct.event_filter* null, %struct.list_head* null, i8* null, i8* null, i32 0, i32 0, %struct.hlist_head* null }, align 4
@__event_rpc_task_run_action = internal global %struct.ftrace_event_call* @event_rpc_task_run_action, section "_ftrace_events", align 8
@event_rpc_task_complete = internal global %struct.ftrace_event_call { %struct.list_head zeroinitializer, %struct.ftrace_event_class* @event_class_rpc_task_running, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.6.370, i32 0, i32 0), %struct.trace_event { %struct.hlist_node zeroinitializer, %struct.list_head zeroinitializer, i32 0, %struct.trace_event_functions* @ftrace_event_type_funcs_rpc_task_running }, i8* getelementptr inbounds ([134 x i8], [134 x i8]* @print_fmt_rpc_task_running, i32 0, i32 0), %struct.event_filter* null, %struct.list_head* null, i8* null, i8* null, i32 0, i32 0, %struct.hlist_head* null }, align 4
@__event_rpc_task_complete = internal global %struct.ftrace_event_call* @event_rpc_task_complete, section "_ftrace_events", align 8
@event_class_rpc_task_queued = internal global %struct.ftrace_event_class { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1368, i32 0, i32 0), i8* bitcast (void (i8*, %struct.rpc_clnt*, %struct.rpc_task*, %struct.rpc_wait_queue*)* @ftrace_raw_event_rpc_task_queued to i8*), i8* bitcast (void (i8*, %struct.rpc_clnt*, %struct.rpc_task*, %struct.rpc_wait_queue*)* @perf_trace_rpc_task_queued to i8*), i32 (%struct.ftrace_event_call*, i32, i8*)* @ftrace_event_reg, i32 (%struct.ftrace_event_call*)* @ftrace_define_fields_rpc_task_queued, %struct.list_head* (%struct.ftrace_event_call*)* null, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.ftrace_event_class* @event_class_rpc_task_queued to i8*), i64 48) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.ftrace_event_class* @event_class_rpc_task_queued to i8*), i64 48) to %struct.list_head*) }, i32 (%struct.ftrace_event_call*)* @trace_event_raw_init }, section ".ref.data", align 8
@event_rpc_task_sleep = internal global %struct.ftrace_event_call { %struct.list_head zeroinitializer, %struct.ftrace_event_class* @event_class_rpc_task_queued, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.7.354, i32 0, i32 0), %struct.trace_event { %struct.hlist_node zeroinitializer, %struct.list_head zeroinitializer, i32 0, %struct.trace_event_functions* @ftrace_event_type_funcs_rpc_task_queued }, i8* getelementptr inbounds ([164 x i8], [164 x i8]* @print_fmt_rpc_task_queued, i32 0, i32 0), %struct.event_filter* null, %struct.list_head* null, i8* null, i8* null, i32 0, i32 0, %struct.hlist_head* null }, align 4
@__event_rpc_task_sleep = internal global %struct.ftrace_event_call* @event_rpc_task_sleep, section "_ftrace_events", align 8
@event_rpc_task_wakeup = internal global %struct.ftrace_event_call { %struct.list_head zeroinitializer, %struct.ftrace_event_class* @event_class_rpc_task_queued, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.8.352, i32 0, i32 0), %struct.trace_event { %struct.hlist_node zeroinitializer, %struct.list_head zeroinitializer, i32 0, %struct.trace_event_functions* @ftrace_event_type_funcs_rpc_task_queued }, i8* getelementptr inbounds ([164 x i8], [164 x i8]* @print_fmt_rpc_task_queued, i32 0, i32 0), %struct.event_filter* null, %struct.list_head* null, i8* null, i8* null, i32 0, i32 0, %struct.hlist_head* null }, align 4
@__event_rpc_task_wakeup = internal global %struct.ftrace_event_call* @event_rpc_task_wakeup, section "_ftrace_events", align 8
@__kcrctab_rpc_init_priority_wait_queue = internal constant i64 ptrtoint (i8** @__crc_rpc_init_priority_wait_queue to i64), section "___kcrctab_gpl+rpc_init_priority_wait_queue", align 8
@__ksymtab_rpc_init_priority_wait_queue = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_wait_queue*, i8*)* @rpc_init_priority_wait_queue to i64), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__kstrtab_rpc_init_priority_wait_queue, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_init_priority_wait_queue", align 8
@__kcrctab_rpc_init_wait_queue = internal constant i64 ptrtoint (i8** @__crc_rpc_init_wait_queue to i64), section "___kcrctab_gpl+rpc_init_wait_queue", align 8
@__ksymtab_rpc_init_wait_queue = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_wait_queue*, i8*)* @rpc_init_wait_queue to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_rpc_init_wait_queue, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_init_wait_queue", align 8
@__kcrctab_rpc_destroy_wait_queue = internal constant i64 ptrtoint (i8** @__crc_rpc_destroy_wait_queue to i64), section "___kcrctab_gpl+rpc_destroy_wait_queue", align 8
@__ksymtab_rpc_destroy_wait_queue = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_wait_queue*)* @rpc_destroy_wait_queue to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_rpc_destroy_wait_queue, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_destroy_wait_queue", align 8
@__kcrctab___rpc_wait_for_completion_task = internal constant i64 ptrtoint (i8** @__crc___rpc_wait_for_completion_task to i64), section "___kcrctab_gpl+__rpc_wait_for_completion_task", align 8
@__ksymtab___rpc_wait_for_completion_task = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rpc_task*, i32 (i8*)*)* @__rpc_wait_for_completion_task to i64), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__kstrtab___rpc_wait_for_completion_task, i32 0, i32 0) }, section "___ksymtab_gpl+__rpc_wait_for_completion_task", align 8
@__kcrctab_rpc_sleep_on = internal constant i64 ptrtoint (i8** @__crc_rpc_sleep_on to i64), section "___kcrctab_gpl+rpc_sleep_on", align 8
@__ksymtab_rpc_sleep_on = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_wait_queue*, %struct.rpc_task*, void (%struct.rpc_task*)*)* @rpc_sleep_on to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_rpc_sleep_on, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_sleep_on", align 8
@__kcrctab_rpc_sleep_on_priority = internal constant i64 ptrtoint (i8** @__crc_rpc_sleep_on_priority to i64), section "___kcrctab_gpl+rpc_sleep_on_priority", align 8
@__ksymtab_rpc_sleep_on_priority = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_wait_queue*, %struct.rpc_task*, void (%struct.rpc_task*)*, i32)* @rpc_sleep_on_priority to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_rpc_sleep_on_priority, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_sleep_on_priority", align 8
@__kcrctab_rpc_queue_empty = internal constant i64 ptrtoint (i8** @__crc_rpc_queue_empty to i64), section "___kcrctab_gpl+rpc_queue_empty", align 8
@__ksymtab_rpc_queue_empty = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rpc_wait_queue*)* @rpc_queue_empty to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_rpc_queue_empty, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_queue_empty", align 8
@__kcrctab_rpc_wake_up_queued_task = internal constant i64 ptrtoint (i8** @__crc_rpc_wake_up_queued_task to i64), section "___kcrctab_gpl+rpc_wake_up_queued_task", align 8
@__ksymtab_rpc_wake_up_queued_task = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_wait_queue*, %struct.rpc_task*)* @rpc_wake_up_queued_task to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_rpc_wake_up_queued_task, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_wake_up_queued_task", align 8
@__kcrctab_rpc_wake_up_first = internal constant i64 ptrtoint (i8** @__crc_rpc_wake_up_first to i64), section "___kcrctab_gpl+rpc_wake_up_first", align 8
@__ksymtab_rpc_wake_up_first = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_task* (%struct.rpc_wait_queue*, i1 (%struct.rpc_task*, i8*)*, i8*)* @rpc_wake_up_first to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_rpc_wake_up_first, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_wake_up_first", align 8
@__kcrctab_rpc_wake_up_next = internal constant i64 ptrtoint (i8** @__crc_rpc_wake_up_next to i64), section "___kcrctab_gpl+rpc_wake_up_next", align 8
@__ksymtab_rpc_wake_up_next = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_task* (%struct.rpc_wait_queue*)* @rpc_wake_up_next to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_rpc_wake_up_next, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_wake_up_next", align 8
@__kcrctab_rpc_wake_up = internal constant i64 ptrtoint (i8** @__crc_rpc_wake_up to i64), section "___kcrctab_gpl+rpc_wake_up", align 8
@__ksymtab_rpc_wake_up = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_wait_queue*)* @rpc_wake_up to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_rpc_wake_up, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_wake_up", align 8
@__kcrctab_rpc_wake_up_status = internal constant i64 ptrtoint (i8** @__crc_rpc_wake_up_status to i64), section "___kcrctab_gpl+rpc_wake_up_status", align 8
@__ksymtab_rpc_wake_up_status = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_wait_queue*, i32)* @rpc_wake_up_status to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_rpc_wake_up_status, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_wake_up_status", align 8
@__kcrctab_rpc_delay = internal constant i64 ptrtoint (i8** @__crc_rpc_delay to i64), section "___kcrctab_gpl+rpc_delay", align 8
@__ksymtab_rpc_delay = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_task*, i64)* @rpc_delay to i64), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__kstrtab_rpc_delay, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_delay", align 8
@__kcrctab_rpc_exit = internal constant i64 ptrtoint (i8** @__crc_rpc_exit to i64), section "___kcrctab_gpl+rpc_exit", align 8
@__ksymtab_rpc_exit = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_task*, i32)* @rpc_exit to i64), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__kstrtab_rpc_exit, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_exit", align 8
@__kcrctab_rpc_malloc = internal constant i64 ptrtoint (i8** @__crc_rpc_malloc to i64), section "___kcrctab_gpl+rpc_malloc", align 8
@__ksymtab_rpc_malloc = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (%struct.rpc_task*, i64)* @rpc_malloc to i64), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__kstrtab_rpc_malloc, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_malloc", align 8
@__kcrctab_rpc_free = internal constant i64 ptrtoint (i8** @__crc_rpc_free to i64), section "___kcrctab_gpl+rpc_free", align 8
@__ksymtab_rpc_free = internal constant %struct.kernel_symbol { i64 ptrtoint (void (i8*)* @rpc_free to i64), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__kstrtab_rpc_free, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_free", align 8
@__kcrctab_rpc_put_task = internal constant i64 ptrtoint (i8** @__crc_rpc_put_task to i64), section "___kcrctab_gpl+rpc_put_task", align 8
@__ksymtab_rpc_put_task = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_task*)* @rpc_put_task to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_rpc_put_task, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_put_task", align 8
@__kcrctab_rpc_put_task_async = internal constant i64 ptrtoint (i8** @__crc_rpc_put_task_async to i64), section "___kcrctab_gpl+rpc_put_task_async", align 8
@__ksymtab_rpc_put_task_async = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_task*)* @rpc_put_task_async to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_rpc_put_task_async, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_put_task_async", align 8
@__kstrtab_rpc_put_task_async = internal constant [19 x i8] c"rpc_put_task_async\00", section "__ksymtab_strings", align 1
@.str.53.258 = private unnamed_addr constant [19 x i8] c"(&task->u.tk_work)\00", align 1
@rpc_final_put_task.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.60.263 = private unnamed_addr constant [25 x i8] c"\01dRPC: %5u freeing task\0A\00", align 1
@rpc_task_mempool = internal global %struct.mempool_s* null, section ".data..read_mostly", align 8
@__crc_rpc_put_task_async = extern_weak global i8*, align 8
@__kstrtab_rpc_put_task = internal constant [13 x i8] c"rpc_put_task\00", section "__ksymtab_strings", align 1
@__crc_rpc_put_task = extern_weak global i8*, align 8
@__kstrtab_rpc_free = internal constant [9 x i8] c"rpc_free\00", section "__ksymtab_strings", align 1
@.str.12.268 = private unnamed_addr constant [47 x i8] c"\01dRPC:       freeing buffer of size %zu at %p\0A\00", align 1
@rpc_buffer_mempool = internal global %struct.mempool_s* null, section ".data..read_mostly", align 8
@__crc_rpc_free = extern_weak global i8*, align 8
@__kstrtab_rpc_malloc = internal constant [11 x i8] c"rpc_malloc\00", section "__ksymtab_strings", align 1
@.str.11.272 = private unnamed_addr constant [47 x i8] c"\01dRPC: %5u allocated buffer of size %zu at %p\0A\00", align 1
@__crc_rpc_malloc = extern_weak global i8*, align 8
@__kstrtab_rpc_exit = internal constant [9 x i8] c"rpc_exit\00", section "__ksymtab_strings", align 1
@.str.47.282 = private unnamed_addr constant [41 x i8] c"\01dRPC: %5u __rpc_wake_up_task (now %lu)\0A\00", align 1
@.str.48.283 = private unnamed_addr constant [43 x i8] c"\013RPC: Inactive task (%p) being woken up!\0A\00", align 1
@.str.49.284 = private unnamed_addr constant [38 x i8] c"\01dRPC:       __rpc_wake_up_task done\0A\00", align 1
@rpc_make_runnable.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.54.288 = private unnamed_addr constant [37 x i8] c"\01dRPC: %5u __rpc_execute flags=0x%x\0A\00", align 1
@__rpc_execute.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.9.289 = private unnamed_addr constant [19 x i8] c"net/sunrpc/sched.c\00", align 1
@.str.55.290 = private unnamed_addr constant [37 x i8] c"\01dRPC: %5u sync task going to sleep\0A\00", align 1
@.str.56.291 = private unnamed_addr constant [23 x i8] c"\01dRPC: %5u got signal\0A\00", align 1
@.str.57.293 = private unnamed_addr constant [31 x i8] c"\01dRPC: %5u sync task resuming\0A\00", align 1
@.str.58.294 = private unnamed_addr constant [33 x i8] c"\01dRPC: %5u return %d, status %d\0A\00", align 1
@.str.59.295 = private unnamed_addr constant [25 x i8] c"\01dRPC: %5u release task\0A\00", align 1
@rpc_release_task.__warned = internal global i8 0, section ".data.unlikely", align 1
@trace_rpc_task_complete.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.36.302 = private unnamed_addr constant [30 x i8] c"include/trace/events/sunrpc.h\00", align 1
@system_freezing_cnt = external global %struct.atomic_t, align 4
@trace_rpc_task_run_action.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.50.318 = private unnamed_addr constant [39 x i8] c"\01dRPC: %5u removed from queue %p \22%s\22\0A\00", align 1
@.str.52.319 = private unnamed_addr constant [8 x i8] c"unknown\00", align 1
@.str.51.321 = private unnamed_addr constant [28 x i8] c"\01dRPC: %5u disabling timer\0A\00", align 1
@trace_rpc_task_wakeup.__warned = internal global i8 0, section ".data.unlikely", align 1
@__crc_rpc_exit = extern_weak global i8*, align 8
@__kstrtab_rpc_delay = internal constant [10 x i8] c"rpc_delay\00", section "__ksymtab_strings", align 1
@delay_queue = internal global %struct.rpc_wait_queue zeroinitializer, align 8
@rpc_sleep_on.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.43.326 = private unnamed_addr constant [42 x i8] c"\01dRPC: %5u sleep_on(queue \22%s\22 time %lu)\0A\00", align 1
@__rpc_sleep_on_priority.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.46.327 = private unnamed_addr constant [37 x i8] c"\01dRPC: %5u setting alarm for %lu ms\0A\00", align 1
@__rpc_add_wait_queue.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.45.329 = private unnamed_addr constant [35 x i8] c"\01dRPC: %5u added to queue %p \22%s\22\0A\00", align 1
@trace_rpc_task_sleep.__warned = internal global i8 0, section ".data.unlikely", align 1
@__crc_rpc_delay = extern_weak global i8*, align 8
@__kstrtab_rpc_wake_up_status = internal constant [19 x i8] c"rpc_wake_up_status\00", section "__ksymtab_strings", align 1
@__crc_rpc_wake_up_status = extern_weak global i8*, align 8
@__kstrtab_rpc_wake_up = internal constant [12 x i8] c"rpc_wake_up\00", section "__ksymtab_strings", align 1
@__crc_rpc_wake_up = extern_weak global i8*, align 8
@__kstrtab_rpc_wake_up_next = internal constant [17 x i8] c"rpc_wake_up_next\00", section "__ksymtab_strings", align 1
@.str.10.338 = private unnamed_addr constant [37 x i8] c"\01dRPC:       wake_up_first(%p \22%s\22)\0A\00", align 1
@__crc_rpc_wake_up_next = extern_weak global i8*, align 8
@__kstrtab_rpc_wake_up_first = internal constant [18 x i8] c"rpc_wake_up_first\00", section "__ksymtab_strings", align 1
@__crc_rpc_wake_up_first = extern_weak global i8*, align 8
@__kstrtab_rpc_wake_up_queued_task = internal constant [24 x i8] c"rpc_wake_up_queued_task\00", section "__ksymtab_strings", align 1
@__crc_rpc_wake_up_queued_task = extern_weak global i8*, align 8
@__kstrtab_rpc_queue_empty = internal constant [16 x i8] c"rpc_queue_empty\00", section "__ksymtab_strings", align 1
@__crc_rpc_queue_empty = extern_weak global i8*, align 8
@__kstrtab_rpc_sleep_on_priority = internal constant [22 x i8] c"rpc_sleep_on_priority\00", section "__ksymtab_strings", align 1
@rpc_sleep_on_priority.__warned = internal global i8 0, section ".data.unlikely", align 1
@__crc_rpc_sleep_on_priority = extern_weak global i8*, align 8
@__kstrtab_rpc_sleep_on = internal constant [13 x i8] c"rpc_sleep_on\00", section "__ksymtab_strings", align 1
@__crc_rpc_sleep_on = extern_weak global i8*, align 8
@__kstrtab___rpc_wait_for_completion_task = internal constant [31 x i8] c"__rpc_wait_for_completion_task\00", section "__ksymtab_strings", align 1
@__crc___rpc_wait_for_completion_task = extern_weak global i8*, align 8
@__kstrtab_rpc_destroy_wait_queue = internal constant [23 x i8] c"rpc_destroy_wait_queue\00", section "__ksymtab_strings", align 1
@__crc_rpc_destroy_wait_queue = extern_weak global i8*, align 8
@__kstrtab_rpc_init_wait_queue = internal constant [20 x i8] c"rpc_init_wait_queue\00", section "__ksymtab_strings", align 1
@.str.38.345 = private unnamed_addr constant [23 x i8] c"&(&queue->lock)->rlock\00", align 1
@__rpc_init_priority_wait_queue.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.40.346 = private unnamed_addr constant [29 x i8] c"((&queue->timer_list.timer))\00", align 1
@__rpc_init_priority_wait_queue.__key.39 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.41.348 = private unnamed_addr constant [20 x i8] c"\01dRPC: %5u timeout\0A\00", align 1
@__crc_rpc_init_wait_queue = extern_weak global i8*, align 8
@__kstrtab_rpc_init_priority_wait_queue = internal constant [29 x i8] c"rpc_init_priority_wait_queue\00", section "__ksymtab_strings", align 1
@__crc_rpc_init_priority_wait_queue = extern_weak global i8*, align 8
@.str.8.352 = private unnamed_addr constant [16 x i8] c"rpc_task_wakeup\00", align 1
@ftrace_event_type_funcs_rpc_task_queued = internal global %struct.trace_event_functions { i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* @ftrace_raw_output_rpc_task_queued, i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* null, i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* null, i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* null }, align 8
@print_fmt_rpc_task_queued = internal constant [164 x i8] c"\22task:%p@%p flags=%4.4x state=%4.4lx status=%d timeout=%lu queue=%s\22, REC->task, REC->clnt, REC->flags, REC->runstate, REC->status, REC->timeout, __get_str(q_name)\00", align 16
@.str.35.353 = private unnamed_addr constant [68 x i8] c"task:%p@%p flags=%4.4x state=%4.4lx status=%d timeout=%lu queue=%s\0A\00", align 1
@.str.7.354 = private unnamed_addr constant [15 x i8] c"rpc_task_sleep\00", align 1
@.str.20.356 = private unnamed_addr constant [24 x i8] c"const struct rpc_clnt *\00", align 1
@.str.21.357 = private unnamed_addr constant [5 x i8] c"clnt\00", align 1
@.str.18.358 = private unnamed_addr constant [24 x i8] c"const struct rpc_task *\00", align 1
@.str.19.359 = private unnamed_addr constant [5 x i8] c"task\00", align 1
@.str.27.360 = private unnamed_addr constant [14 x i8] c"unsigned long\00", align 1
@.str.32.361 = private unnamed_addr constant [8 x i8] c"timeout\00", align 1
@.str.28.362 = private unnamed_addr constant [9 x i8] c"runstate\00", align 1
@.str.22.363 = private unnamed_addr constant [4 x i8] c"int\00", align 1
@.str.23.364 = private unnamed_addr constant [7 x i8] c"status\00", align 1
@.str.29.365 = private unnamed_addr constant [15 x i8] c"unsigned short\00", align 1
@.str.30.366 = private unnamed_addr constant [6 x i8] c"flags\00", align 1
@.str.33.367 = private unnamed_addr constant [18 x i8] c"__data_loc char[]\00", align 1
@.str.34.368 = private unnamed_addr constant [7 x i8] c"q_name\00", align 1
@perf_trace_rpc_task_queued.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.37.369 = private unnamed_addr constant [32 x i8] c"profile buffer not large enough\00", align 1
@this_cpu_off = external global i64, align 8
@.str.6.370 = private unnamed_addr constant [18 x i8] c"rpc_task_complete\00", align 1
@ftrace_event_type_funcs_rpc_task_running = internal global %struct.trace_event_functions { i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* @ftrace_raw_output_rpc_task_running, i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* null, i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* null, i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* null }, align 8
@print_fmt_rpc_task_running = internal constant [134 x i8] c"\22task:%p@%p flags=%4.4x state=%4.4lx status=%d action=%pf\22, REC->task, REC->clnt, REC->flags, REC->runstate, REC->status, REC->action\00", align 16
@.str.31.371 = private unnamed_addr constant [58 x i8] c"task:%p@%p flags=%4.4x state=%4.4lx status=%d action=%pf\0A\00", align 1
@.str.5.372 = private unnamed_addr constant [20 x i8] c"rpc_task_run_action\00", align 1
@.str.4.373 = private unnamed_addr constant [15 x i8] c"rpc_task_begin\00", align 1
@.str.25.374 = private unnamed_addr constant [13 x i8] c"const void *\00", align 1
@.str.26.375 = private unnamed_addr constant [7 x i8] c"action\00", align 1
@perf_trace_rpc_task_running.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.3.376 = private unnamed_addr constant [19 x i8] c"rpc_connect_status\00", align 1
@ftrace_event_type_funcs_rpc_connect_status = internal global %struct.trace_event_functions { i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* @ftrace_raw_output_rpc_connect_status, i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* null, i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* null, i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* null }, align 8
@print_fmt_rpc_connect_status = internal constant [59 x i8] c"\22task:%p@%p, status %d\22, REC->task, REC->clnt, REC->status\00", align 16
@.str.24.377 = private unnamed_addr constant [23 x i8] c"task:%p@%p, status %d\0A\00", align 1
@perf_trace_rpc_connect_status.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.2.378 = private unnamed_addr constant [16 x i8] c"rpc_bind_status\00", align 1
@ftrace_event_type_funcs_rpc_task_status = internal global %struct.trace_event_functions { i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* @ftrace_raw_output_rpc_task_status, i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* null, i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* null, i32 (%struct.trace_iterator*, i32, %struct.trace_event*)* null }, align 8
@print_fmt_rpc_task_status = internal constant [59 x i8] c"\22task:%p@%p, status %d\22, REC->task, REC->clnt, REC->status\00", align 16
@.str.1.379 = private unnamed_addr constant [16 x i8] c"rpc_call_status\00", align 1
@perf_trace_rpc_task_status.__warned = internal global i8 0, section ".data.unlikely", align 1
@rpc_task_set_debuginfo.rpc_pid = internal global %struct.atomic_t zeroinitializer, align 4
@trace_rpc_task_begin.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.13.387 = private unnamed_addr constant [32 x i8] c"\01dRPC:       allocated task %p\0A\00", align 1
@.str.61.389 = private unnamed_addr constant [47 x i8] c"\01dRPC:       new task initialized, procpid %u\0A\00", align 1
@rpc_task_slabp = internal global %struct.kmem_cache* null, section ".data..read_mostly", align 8
@rpc_buffer_slabp = internal global %struct.kmem_cache* null, section ".data..read_mostly", align 8
@.str.62.394 = private unnamed_addr constant [42 x i8] c"\01dRPC:       destroying workqueue rpciod\0A\00", align 1
@.str.14.395 = private unnamed_addr constant [7 x i8] c"delayq\00", align 1
@.str.15.396 = private unnamed_addr constant [10 x i8] c"rpc_tasks\00", align 1
@.str.16.397 = private unnamed_addr constant [12 x i8] c"rpc_buffers\00", align 1
@.str.63.398 = private unnamed_addr constant [40 x i8] c"\01dRPC:       creating workqueue rpciod\0A\00", align 1
@.str.64.399 = private unnamed_addr constant [7 x i8] c"rpciod\00", align 1
@rpciod_start.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@__param_auth_hashtable_size = internal constant %struct.kernel_param { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__param_str_auth_hashtable_size, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_hashtbl_sz, i16 420, i16 -1, %union.anon.57 { i8* bitcast (i32* @auth_hashbits to i8*) } }, section "__param", align 8
@__UNIQUE_ID_auth_hashtable_sizetype80 = internal constant [40 x i8] c"parmtype=auth_hashtable_size:hashtbl_sz\00", section ".modinfo", align 1
@__UNIQUE_ID_auth_hashtable_size81 = internal constant [61 x i8] c"parm=auth_hashtable_size:RPC credential cache hashtable size\00", section ".modinfo", align 1
@__kcrctab_rpcauth_register = internal constant i64 ptrtoint (i8** @__crc_rpcauth_register to i64), section "___kcrctab_gpl+rpcauth_register", align 8
@__ksymtab_rpcauth_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rpc_authops*)* @rpcauth_register to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_rpcauth_register, i32 0, i32 0) }, section "___ksymtab_gpl+rpcauth_register", align 8
@__kcrctab_rpcauth_unregister = internal constant i64 ptrtoint (i8** @__crc_rpcauth_unregister to i64), section "___kcrctab_gpl+rpcauth_unregister", align 8
@__ksymtab_rpcauth_unregister = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rpc_authops*)* @rpcauth_unregister to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_rpcauth_unregister, i32 0, i32 0) }, section "___ksymtab_gpl+rpcauth_unregister", align 8
@__kcrctab_rpcauth_get_pseudoflavor = internal constant i64 ptrtoint (i8** @__crc_rpcauth_get_pseudoflavor to i64), section "___kcrctab_gpl+rpcauth_get_pseudoflavor", align 8
@__ksymtab_rpcauth_get_pseudoflavor = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, %struct.rpcsec_gss_info*)* @rpcauth_get_pseudoflavor to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_rpcauth_get_pseudoflavor, i32 0, i32 0) }, section "___ksymtab_gpl+rpcauth_get_pseudoflavor", align 8
@__kcrctab_rpcauth_get_gssinfo = internal constant i64 ptrtoint (i8** @__crc_rpcauth_get_gssinfo to i64), section "___kcrctab_gpl+rpcauth_get_gssinfo", align 8
@__ksymtab_rpcauth_get_gssinfo = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, %struct.rpcsec_gss_info*)* @rpcauth_get_gssinfo to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_rpcauth_get_gssinfo, i32 0, i32 0) }, section "___ksymtab_gpl+rpcauth_get_gssinfo", align 8
@__kcrctab_rpcauth_list_flavors = internal constant i64 ptrtoint (i8** @__crc_rpcauth_list_flavors to i64), section "___kcrctab_gpl+rpcauth_list_flavors", align 8
@__ksymtab_rpcauth_list_flavors = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32*, i32)* @rpcauth_list_flavors to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_rpcauth_list_flavors, i32 0, i32 0) }, section "___ksymtab_gpl+rpcauth_list_flavors", align 8
@__kcrctab_rpcauth_create = internal constant i64 ptrtoint (i8** @__crc_rpcauth_create to i64), section "___kcrctab_gpl+rpcauth_create", align 8
@__ksymtab_rpcauth_create = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_auth* (i32, %struct.rpc_clnt*)* @rpcauth_create to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_rpcauth_create, i32 0, i32 0) }, section "___ksymtab_gpl+rpcauth_create", align 8
@__kcrctab_rpcauth_init_credcache = internal constant i64 ptrtoint (i8** @__crc_rpcauth_init_credcache to i64), section "___kcrctab_gpl+rpcauth_init_credcache", align 8
@__ksymtab_rpcauth_init_credcache = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rpc_auth*)* @rpcauth_init_credcache to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_rpcauth_init_credcache, i32 0, i32 0) }, section "___ksymtab_gpl+rpcauth_init_credcache", align 8
@__kcrctab_rpcauth_destroy_credcache = internal constant i64 ptrtoint (i8** @__crc_rpcauth_destroy_credcache to i64), section "___kcrctab_gpl+rpcauth_destroy_credcache", align 8
@__ksymtab_rpcauth_destroy_credcache = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_auth*)* @rpcauth_destroy_credcache to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_rpcauth_destroy_credcache, i32 0, i32 0) }, section "___ksymtab_gpl+rpcauth_destroy_credcache", align 8
@__kcrctab_rpcauth_lookup_credcache = internal constant i64 ptrtoint (i8** @__crc_rpcauth_lookup_credcache to i64), section "___kcrctab_gpl+rpcauth_lookup_credcache", align 8
@__ksymtab_rpcauth_lookup_credcache = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)* @rpcauth_lookup_credcache to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_rpcauth_lookup_credcache, i32 0, i32 0) }, section "___ksymtab_gpl+rpcauth_lookup_credcache", align 8
@__kcrctab_rpcauth_init_cred = internal constant i64 ptrtoint (i8** @__crc_rpcauth_init_cred to i64), section "___kcrctab_gpl+rpcauth_init_cred", align 8
@__ksymtab_rpcauth_init_cred = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_cred*, %struct.auth_cred*, %struct.rpc_auth*, %struct.rpc_credops*)* @rpcauth_init_cred to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_rpcauth_init_cred, i32 0, i32 0) }, section "___ksymtab_gpl+rpcauth_init_cred", align 8
@__kcrctab_rpcauth_generic_bind_cred = internal constant i64 ptrtoint (i8** @__crc_rpcauth_generic_bind_cred to i64), section "___kcrctab_gpl+rpcauth_generic_bind_cred", align 8
@__ksymtab_rpcauth_generic_bind_cred = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_cred* (%struct.rpc_task*, %struct.rpc_cred*, i32)* @rpcauth_generic_bind_cred to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_rpcauth_generic_bind_cred, i32 0, i32 0) }, section "___ksymtab_gpl+rpcauth_generic_bind_cred", align 8
@__kcrctab_put_rpccred = internal constant i64 ptrtoint (i8** @__crc_put_rpccred to i64), section "___kcrctab_gpl+put_rpccred", align 8
@__ksymtab_put_rpccred = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_cred*)* @put_rpccred to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_put_rpccred, i32 0, i32 0) }, section "___ksymtab_gpl+put_rpccred", align 8
@__kstrtab_put_rpccred = internal constant [12 x i8] c"put_rpccred\00", section "__ksymtab_strings", align 1
@rpc_credcache_lock = internal global %struct.spinlock { %union.anon.11 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.17.413, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@number_cred_unused = internal global i64 0, align 8
@cred_unused = internal global %struct.list_head { %struct.list_head* @cred_unused, %struct.list_head* @cred_unused }, align 8
@.str.17.413 = private unnamed_addr constant [19 x i8] c"rpc_credcache_lock\00", align 1
@__crc_put_rpccred = extern_weak global i8*, align 8
@__kstrtab_rpcauth_generic_bind_cred = internal constant [26 x i8] c"rpcauth_generic_bind_cred\00", section "__ksymtab_strings", align 1
@.str.8.414 = private unnamed_addr constant [31 x i8] c"\01dRPC: %5u holding %s cred %p\0A\00", align 1
@__crc_rpcauth_generic_bind_cred = extern_weak global i8*, align 8
@__kstrtab_rpcauth_init_cred = internal constant [18 x i8] c"rpcauth_init_cred\00", section "__ksymtab_strings", align 1
@__crc_rpcauth_init_cred = extern_weak global i8*, align 8
@__kstrtab_rpcauth_lookup_credcache = internal constant [25 x i8] c"rpcauth_lookup_credcache\00", section "__ksymtab_strings", align 1
@init_user_ns = external global %struct.user_namespace, align 1
@rpcauth_lookup_credcache.__warned = internal global i8 0, section ".data.unlikely", align 1
@rpcauth_lookup_credcache.__warned.5 = internal global i8 0, section ".data.unlikely", align 1
@rcu_read_unlock.__warned.424 = internal global i8 0, section ".data.unlikely", align 1
@rcu_read_lock.__warned.432 = internal global i8 0, section ".data.unlikely", align 1
@__crc_rpcauth_lookup_credcache = extern_weak global i8*, align 8
@__kstrtab_rpcauth_destroy_credcache = internal constant [26 x i8] c"rpcauth_destroy_credcache\00", section "__ksymtab_strings", align 1
@__crc_rpcauth_destroy_credcache = extern_weak global i8*, align 8
@__kstrtab_rpcauth_init_credcache = internal constant [23 x i8] c"rpcauth_init_credcache\00", section "__ksymtab_strings", align 1
@auth_hashbits = internal global i32 4, align 4
@.str.2.436 = private unnamed_addr constant [21 x i8] c"&(&new->lock)->rlock\00", align 1
@rpcauth_init_credcache.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@__crc_rpcauth_init_credcache = extern_weak global i8*, align 8
@__kstrtab_rpcauth_create = internal constant [15 x i8] c"rpcauth_create\00", section "__ksymtab_strings", align 1
@auth_flavors = internal global [8 x %struct.rpc_authops*] [%struct.rpc_authops* bitcast ({ %struct.module*, i32, i8*, %struct.rpc_auth.2960* (%struct.rpc_clnt.2966*, i32)*, void (%struct.rpc_auth.2960*)*, %struct.rpc_cred.2963* (%struct.rpc_auth.2960*, %struct.auth_cred*, i32)*, %struct.rpc_cred.2963* (%struct.rpc_auth.2960*, %struct.auth_cred*, i32)*, i32 (%struct.rpc_auth.2960*)*, void (%struct.rpc_auth.2960*)*, i32 (i32*, i32)*, i32 (%struct.rpcsec_gss_info*)*, i32 (i32, %struct.rpcsec_gss_info*)* }* @authnull_ops to %struct.rpc_authops*), %struct.rpc_authops* bitcast ({ %struct.module*, i32, i8*, %struct.rpc_auth.2989* (%struct.rpc_clnt.2994*, i32)*, void (%struct.rpc_auth.2989*)*, %struct.rpc_cred.2995* (%struct.rpc_auth.2989*, %struct.auth_cred*, i32)*, %struct.rpc_cred.2995* (%struct.rpc_auth.2989*, %struct.auth_cred*, i32)*, i32 (%struct.rpc_auth.2989*)*, void (%struct.rpc_auth.2989*)*, i32 (i32*, i32)*, i32 (%struct.rpcsec_gss_info*)*, i32 (i32, %struct.rpcsec_gss_info*)* }* @authunix_ops to %struct.rpc_authops*), %struct.rpc_authops* null, %struct.rpc_authops* null, %struct.rpc_authops* null, %struct.rpc_authops* null, %struct.rpc_authops* null, %struct.rpc_authops* null], align 16
@.str.439 = private unnamed_addr constant [12 x i8] c"rpc-auth-%u\00", align 1
@rpc_authflavor_lock = internal global %struct.spinlock { %union.anon.11 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.16.442, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@.str.16.442 = private unnamed_addr constant [20 x i8] c"rpc_authflavor_lock\00", align 1
@__crc_rpcauth_create = extern_weak global i8*, align 8
@__kstrtab_rpcauth_list_flavors = internal constant [21 x i8] c"rpcauth_list_flavors\00", section "__ksymtab_strings", align 1
@.str.1.443 = private unnamed_addr constant [28 x i8] c"\01dRPC:       %s returns %d\0A\00", align 1
@__func__.rpcauth_list_flavors = private unnamed_addr constant [21 x i8] c"rpcauth_list_flavors\00", align 1
@__crc_rpcauth_list_flavors = extern_weak global i8*, align 8
@__kstrtab_rpcauth_get_gssinfo = internal constant [20 x i8] c"rpcauth_get_gssinfo\00", section "__ksymtab_strings", align 1
@__crc_rpcauth_get_gssinfo = extern_weak global i8*, align 8
@__kstrtab_rpcauth_get_pseudoflavor = internal constant [25 x i8] c"rpcauth_get_pseudoflavor\00", section "__ksymtab_strings", align 1
@__crc_rpcauth_get_pseudoflavor = extern_weak global i8*, align 8
@__kstrtab_rpcauth_unregister = internal constant [19 x i8] c"rpcauth_unregister\00", section "__ksymtab_strings", align 1
@__crc_rpcauth_unregister = extern_weak global i8*, align 8
@__kstrtab_rpcauth_register = internal constant [17 x i8] c"rpcauth_register\00", section "__ksymtab_strings", align 1
@__crc_rpcauth_register = extern_weak global i8*, align 8
@__param_str_auth_hashtable_size = internal constant [20 x i8] c"auth_hashtable_size\00", align 16
@param_ops_hashtbl_sz = internal global %struct.kernel_param_ops { i32 (i8*, %struct.kernel_param*)* @param_set_hashtbl_sz, i32 (i8*, %struct.kernel_param*)* @param_get_hashtbl_sz, void (i8*)* null }, align 8
@.str.7.447 = private unnamed_addr constant [33 x i8] c"\01dRPC:       looking up %s cred\0A\00", align 1
@.str.9.450 = private unnamed_addr constant [34 x i8] c"\01dRPC: %5u marshaling %s cred %p\0A\00", align 1
@.str.10.453 = private unnamed_addr constant [34 x i8] c"\01dRPC: %5u validating %s cred %p\0A\00", align 1
@.str.11.456 = private unnamed_addr constant [46 x i8] c"\01dRPC: %5u using %s cred %p to wrap rpc data\0A\00", align 1
@.str.12.459 = private unnamed_addr constant [48 x i8] c"\01dRPC: %5u using %s cred %p to unwrap rpc data\0A\00", align 1
@.str.13.462 = private unnamed_addr constant [34 x i8] c"\01dRPC: %5u refreshing %s cred %p\0A\00", align 1
@.str.21.464 = private unnamed_addr constant [31 x i8] c"\01dRPC: %5u looking up %s cred\0A\00", align 1
@.str.14.467 = private unnamed_addr constant [36 x i8] c"\01dRPC: %5u invalidating %s cred %p\0A\00", align 1
@rpc_cred_shrinker = internal global %struct.shrinker { i32 (%struct.shrinker*, %struct.device_dma_parameters*)* @rpcauth_cache_shrinker, i32 2, i64 0, %struct.list_head zeroinitializer, %struct.pgprot zeroinitializer }, align 8
@sysctl_vfs_cache_pressure = external global i32, align 4
@authnull_ops = constant { %struct.module*, i32, i8*, %struct.rpc_auth.2960* (%struct.rpc_clnt.2966*, i32)*, void (%struct.rpc_auth.2960*)*, %struct.rpc_cred.2963* (%struct.rpc_auth.2960*, %struct.auth_cred*, i32)*, %struct.rpc_cred.2963* (%struct.rpc_auth.2960*, %struct.auth_cred*, i32)*, i32 (%struct.rpc_auth.2960*)*, void (%struct.rpc_auth.2960*)*, i32 (i32*, i32)*, i32 (%struct.rpcsec_gss_info*)*, i32 (i32, %struct.rpcsec_gss_info*)* } { %struct.module* @__this_module, i32 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.472, i32 0, i32 0), %struct.rpc_auth.2960* (%struct.rpc_clnt.2966*, i32)* @nul_create, void (%struct.rpc_auth.2960*)* @nul_destroy, %struct.rpc_cred.2963* (%struct.rpc_auth.2960*, %struct.auth_cred*, i32)* @nul_lookup_cred, %struct.rpc_cred.2963* (%struct.rpc_auth.2960*, %struct.auth_cred*, i32)* null, i32 (%struct.rpc_auth.2960*)* null, void (%struct.rpc_auth.2960*)* null, i32 (i32*, i32)* null, i32 (%struct.rpcsec_gss_info*)* null, i32 (i32, %struct.rpcsec_gss_info*)* null }, align 8
@.str.472 = private unnamed_addr constant [5 x i8] c"NULL\00", align 1
@null_cred = internal global %struct.rpc_cred.2963 { %struct.hlist_node zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rpc_cred.2963* @null_cred to i8*), i64 16) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rpc_cred.2963* @null_cred to i8*), i64 16) to %struct.list_head*) }, %struct.callback_head zeroinitializer, %struct.rpc_auth.2960* @null_auth, %struct.rpc_credops.2985* @null_credops, i64 256550128, i64 0, i64 2, %struct.atomic_t { i32 1 }, i32 0 }, align 8
@null_auth = internal global %struct.rpc_auth.2960 { i32 4, i32 2, i32 0, i32 0, %struct.rpc_authops.2961* bitcast ({ %struct.module*, i32, i8*, %struct.rpc_auth.2960* (%struct.rpc_clnt.2966*, i32)*, void (%struct.rpc_auth.2960*)*, %struct.rpc_cred.2963* (%struct.rpc_auth.2960*, %struct.auth_cred*, i32)*, %struct.rpc_cred.2963* (%struct.rpc_auth.2960*, %struct.auth_cred*, i32)*, i32 (%struct.rpc_auth.2960*)*, void (%struct.rpc_auth.2960*)*, i32 (i32*, i32)*, i32 (%struct.rpcsec_gss_info*)*, i32 (i32, %struct.rpcsec_gss_info*)* }* @authnull_ops to %struct.rpc_authops.2961*), i32 0, %struct.atomic_t zeroinitializer, %struct.rpc_cred_cache* null }, align 8
@null_credops = internal constant %struct.rpc_credops.2985 { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1.475, i32 0, i32 0), i32 (%struct.rpc_auth.2960*, %struct.rpc_cred.2963*)* null, void (%struct.rpc_cred.2963*)* @nul_destroy_cred, i32 (%struct.auth_cred*, %struct.rpc_cred.2963*, i32)* @nul_match, %struct.rpc_cred.2963* (%struct.rpc_task.2977*, %struct.rpc_cred.2963*, i32)* bitcast (%struct.rpc_cred* (%struct.rpc_task*, %struct.rpc_cred*, i32)* @rpcauth_generic_bind_cred to %struct.rpc_cred.2963* (%struct.rpc_task.2977*, %struct.rpc_cred.2963*, i32)*), i32* (%struct.rpc_task.2977*, i32*)* @nul_marshal, i32 (%struct.rpc_task.2977*)* @nul_refresh, i32* (%struct.rpc_task.2977*, i32*)* @nul_validate, i32 (%struct.rpc_task.2977*, void (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)* null, i32 (%struct.rpc_task.2977*, i32 (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)* null }, align 8
@.str.1.475 = private unnamed_addr constant [10 x i8] c"AUTH_NULL\00", align 1
@.str.3.478 = private unnamed_addr constant [24 x i8] c"RPC: bad verf size: %u\0A\00", align 1
@authunix_ops = constant { %struct.module*, i32, i8*, %struct.rpc_auth.2989* (%struct.rpc_clnt.2994*, i32)*, void (%struct.rpc_auth.2989*)*, %struct.rpc_cred.2995* (%struct.rpc_auth.2989*, %struct.auth_cred*, i32)*, %struct.rpc_cred.2995* (%struct.rpc_auth.2989*, %struct.auth_cred*, i32)*, i32 (%struct.rpc_auth.2989*)*, void (%struct.rpc_auth.2989*)*, i32 (i32*, i32)*, i32 (%struct.rpcsec_gss_info*)*, i32 (i32, %struct.rpcsec_gss_info*)* } { %struct.module* @__this_module, i32 1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.483, i32 0, i32 0), %struct.rpc_auth.2989* (%struct.rpc_clnt.2994*, i32)* @unx_create, void (%struct.rpc_auth.2989*)* @unx_destroy, %struct.rpc_cred.2995* (%struct.rpc_auth.2989*, %struct.auth_cred*, i32)* @unx_lookup_cred, %struct.rpc_cred.2995* (%struct.rpc_auth.2989*, %struct.auth_cred*, i32)* @unx_create_cred, i32 (%struct.rpc_auth.2989*)* null, void (%struct.rpc_auth.2989*)* null, i32 (i32*, i32)* null, i32 (%struct.rpcsec_gss_info*)* null, i32 (i32, %struct.rpcsec_gss_info*)* null }, align 8
@.str.483 = private unnamed_addr constant [5 x i8] c"UNIX\00", align 1
@.str.3.485 = private unnamed_addr constant [53 x i8] c"\01dRPC:       allocating UNIX cred for uid %d gid %d\0A\00", align 1
@unix_credops = internal constant %struct.rpc_credops.3486 { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.4.488, i32 0, i32 0), i32 (%struct.rpc_auth.2989*, %struct.rpc_cred.2995*)* null, void (%struct.rpc_cred.2995*)* @unx_destroy_cred, i32 (%struct.auth_cred*, %struct.rpc_cred.2995*, i32)* @unx_match, %struct.rpc_cred.2995* (%struct.rpc_task.3476*, %struct.rpc_cred.2995*, i32)* bitcast (%struct.rpc_cred* (%struct.rpc_task*, %struct.rpc_cred*, i32)* @rpcauth_generic_bind_cred to %struct.rpc_cred.2995* (%struct.rpc_task.3476*, %struct.rpc_cred.2995*, i32)*), i32* (%struct.rpc_task.3476*, i32*)* @unx_marshal, i32 (%struct.rpc_task.3476*)* @unx_refresh, i32* (%struct.rpc_task.3476*, i32*)* @unx_validate, i32 (%struct.rpc_task.3476*, void (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)* null, i32 (%struct.rpc_task.3476*, i32 (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)* null }, align 8
@.str.4.488 = private unnamed_addr constant [10 x i8] c"AUTH_UNIX\00", align 1
@.str.6.490 = private unnamed_addr constant [26 x i8] c"RPC: bad verf flavor: %u\0A\00", align 1
@.str.7.491 = private unnamed_addr constant [26 x i8] c"RPC: giant verf size: %u\0A\00", align 1
@.str.5.495 = private unnamed_addr constant [31 x i8] c"\01dRPC:       unx_free_cred %p\0A\00", align 1
@.str.2.496 = private unnamed_addr constant [47 x i8] c"\01dRPC:       destroying UNIX authenticator %p\0A\00", align 1
@.str.1.497 = private unnamed_addr constant [56 x i8] c"\01dRPC:       creating UNIX authenticator for client %p\0A\00", align 1
@unix_auth = internal global %struct.rpc_auth.2989 { i32 29, i32 2, i32 0, i32 0, %struct.rpc_authops.2990* bitcast ({ %struct.module*, i32, i8*, %struct.rpc_auth.2989* (%struct.rpc_clnt.2994*, i32)*, void (%struct.rpc_auth.2989*)*, %struct.rpc_cred.2995* (%struct.rpc_auth.2989*, %struct.auth_cred*, i32)*, %struct.rpc_cred.2995* (%struct.rpc_auth.2989*, %struct.auth_cred*, i32)*, i32 (%struct.rpc_auth.2989*)*, void (%struct.rpc_auth.2989*)*, i32 (i32*, i32)*, i32 (%struct.rpcsec_gss_info*)*, i32 (i32, %struct.rpcsec_gss_info*)* }* @authunix_ops to %struct.rpc_authops.2990*), i32 1, %struct.atomic_t zeroinitializer, %struct.rpc_cred_cache* null }, align 8
@__kcrctab_rpc_lookup_cred = internal constant i64 ptrtoint (i8** @__crc_rpc_lookup_cred to i64), section "___kcrctab_gpl+rpc_lookup_cred", align 8
@__ksymtab_rpc_lookup_cred = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_cred* ()* @rpc_lookup_cred to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_rpc_lookup_cred, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_lookup_cred", align 8
@__kcrctab_rpc_lookup_machine_cred = internal constant i64 ptrtoint (i8** @__crc_rpc_lookup_machine_cred to i64), section "___kcrctab_gpl+rpc_lookup_machine_cred", align 8
@__ksymtab_rpc_lookup_machine_cred = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_cred* (i8*)* @rpc_lookup_machine_cred to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_rpc_lookup_machine_cred, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_lookup_machine_cred", align 8
@__kstrtab_rpc_lookup_machine_cred = internal constant [24 x i8] c"rpc_lookup_machine_cred\00", section "__ksymtab_strings", align 1
@.str.504 = private unnamed_addr constant [53 x i8] c"\01dRPC:       looking up machine cred for service %s\0A\00", align 1
@generic_auth = internal global %struct.rpc_auth { i32 0, i32 0, i32 0, i32 0, %struct.rpc_authops* @generic_auth_ops, i32 0, %struct.atomic_t zeroinitializer, %struct.rpc_cred_cache* null }, align 8
@generic_auth_ops = internal constant %struct.rpc_authops { %struct.module* @__this_module, i32 0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1.505, i32 0, i32 0), %struct.rpc_auth* (%struct.rpc_clnt*, i32)* null, void (%struct.rpc_auth*)* null, %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)* @generic_lookup_cred, %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)* @generic_create_cred, i32 (%struct.rpc_auth*)* null, void (%struct.rpc_auth*)* null, i32 (i32*, i32)* null, i32 (%struct.rpcsec_gss_info*)* null, i32 (i32, %struct.rpcsec_gss_info*)* null }, align 8
@.str.1.505 = private unnamed_addr constant [8 x i8] c"Generic\00", align 1
@generic_credops = internal constant %struct.rpc_credops { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.5.517, i32 0, i32 0), i32 (%struct.rpc_auth*, %struct.rpc_cred*)* null, void (%struct.rpc_cred*)* @generic_destroy_cred, i32 (%struct.auth_cred*, %struct.rpc_cred*, i32)* @generic_match, %struct.rpc_cred* (%struct.rpc_task*, %struct.rpc_cred*, i32)* @generic_bind_cred, i32* (%struct.rpc_task*, i32*)* null, i32 (%struct.rpc_task*)* null, i32* (%struct.rpc_task*, i32*)* null, i32 (%struct.rpc_task*, void (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)* null, i32 (%struct.rpc_task*, i32 (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)* null }, align 8
@.str.3.509 = private unnamed_addr constant [8 x i8] c"machine\00", align 1
@.str.4.510 = private unnamed_addr constant [8 x i8] c"generic\00", align 1
@.str.2.513 = private unnamed_addr constant [53 x i8] c"\01dRPC:       allocated %s cred %p for uid %d gid %d\0A\00", align 1
@.str.5.517 = private unnamed_addr constant [13 x i8] c"Generic cred\00", align 1
@.str.6.520 = private unnamed_addr constant [35 x i8] c"\01dRPC:       generic_free_cred %p\0A\00", align 1
@__crc_rpc_lookup_machine_cred = extern_weak global i8*, align 8
@__kstrtab_rpc_lookup_cred = internal constant [16 x i8] c"rpc_lookup_cred\00", section "__ksymtab_strings", align 1
@__crc_rpc_lookup_cred = extern_weak global i8*, align 8
@__param_pool_mode = internal constant %struct.kernel_param { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__param_str_pool_mode, i32 0, i32 0), %struct.kernel_param_ops* @__param_ops_pool_mode, i16 420, i16 -1, %union.anon.57 { i8* getelementptr (i8, i8* bitcast (%struct.svc_pool_map* @svc_pool_map to i8*), i64 4) } }, section "__param", align 8
@__kcrctab_svc_rpcb_setup = internal constant i64 ptrtoint (i8** @__crc_svc_rpcb_setup to i64), section "___kcrctab_gpl+svc_rpcb_setup", align 8
@__ksymtab_svc_rpcb_setup = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.svc_serv*, %struct.net*)* @svc_rpcb_setup to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_svc_rpcb_setup, i32 0, i32 0) }, section "___ksymtab_gpl+svc_rpcb_setup", align 8
@__kcrctab_svc_rpcb_cleanup = internal constant i64 ptrtoint (i8** @__crc_svc_rpcb_cleanup to i64), section "___kcrctab_gpl+svc_rpcb_cleanup", align 8
@__ksymtab_svc_rpcb_cleanup = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.svc_serv*, %struct.net*)* @svc_rpcb_cleanup to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_svc_rpcb_cleanup, i32 0, i32 0) }, section "___ksymtab_gpl+svc_rpcb_cleanup", align 8
@__kcrctab_svc_bind = internal constant i64 ptrtoint (i8** @__crc_svc_bind to i64), section "___kcrctab_gpl+svc_bind", align 8
@__ksymtab_svc_bind = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.svc_serv*, %struct.net*)* @svc_bind to i64), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__kstrtab_svc_bind, i32 0, i32 0) }, section "___ksymtab_gpl+svc_bind", align 8
@__kcrctab_svc_create = internal constant i64 ptrtoint (i8** @__crc_svc_create to i64), section "___kcrctab_gpl+svc_create", align 8
@__ksymtab_svc_create = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.svc_serv* (%struct.svc_program*, i32, void (%struct.svc_serv*, %struct.net*)*)* @svc_create to i64), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__kstrtab_svc_create, i32 0, i32 0) }, section "___ksymtab_gpl+svc_create", align 8
@__kcrctab_svc_create_pooled = internal constant i64 ptrtoint (i8** @__crc_svc_create_pooled to i64), section "___kcrctab_gpl+svc_create_pooled", align 8
@__ksymtab_svc_create_pooled = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.svc_serv* (%struct.svc_program*, i32, void (%struct.svc_serv*, %struct.net*)*, i32 (i8*)*, %struct.module*)* @svc_create_pooled to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_svc_create_pooled, i32 0, i32 0) }, section "___ksymtab_gpl+svc_create_pooled", align 8
@__kcrctab_svc_shutdown_net = internal constant i64 ptrtoint (i8** @__crc_svc_shutdown_net to i64), section "___kcrctab_gpl+svc_shutdown_net", align 8
@__ksymtab_svc_shutdown_net = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.svc_serv*, %struct.net*)* @svc_shutdown_net to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_svc_shutdown_net, i32 0, i32 0) }, section "___ksymtab_gpl+svc_shutdown_net", align 8
@__kcrctab_svc_destroy = internal constant i64 ptrtoint (i8** @__crc_svc_destroy to i64), section "___kcrctab_gpl+svc_destroy", align 8
@__ksymtab_svc_destroy = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.svc_serv*)* @svc_destroy to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_svc_destroy, i32 0, i32 0) }, section "___ksymtab_gpl+svc_destroy", align 8
@__kcrctab_svc_prepare_thread = internal constant i64 ptrtoint (i8** @__crc_svc_prepare_thread to i64), section "___kcrctab_gpl+svc_prepare_thread", align 8
@__ksymtab_svc_prepare_thread = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.svc_rqst* (%struct.svc_serv*, %struct.svc_pool*, i32)* @svc_prepare_thread to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_svc_prepare_thread, i32 0, i32 0) }, section "___ksymtab_gpl+svc_prepare_thread", align 8
@__kcrctab_svc_set_num_threads = internal constant i64 ptrtoint (i8** @__crc_svc_set_num_threads to i64), section "___kcrctab_gpl+svc_set_num_threads", align 8
@__ksymtab_svc_set_num_threads = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.svc_serv*, %struct.svc_pool*, i32)* @svc_set_num_threads to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_svc_set_num_threads, i32 0, i32 0) }, section "___ksymtab_gpl+svc_set_num_threads", align 8
@__kcrctab_svc_exit_thread = internal constant i64 ptrtoint (i8** @__crc_svc_exit_thread to i64), section "___kcrctab_gpl+svc_exit_thread", align 8
@__ksymtab_svc_exit_thread = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.svc_rqst*)* @svc_exit_thread to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_svc_exit_thread, i32 0, i32 0) }, section "___ksymtab_gpl+svc_exit_thread", align 8
@__kcrctab_svc_process = internal constant i64 ptrtoint (i8** @__crc_svc_process to i64), section "___kcrctab_gpl+svc_process", align 8
@__ksymtab_svc_process = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.svc_rqst*)* @svc_process to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_svc_process, i32 0, i32 0) }, section "___ksymtab_gpl+svc_process", align 8
@__kcrctab_bc_svc_process = internal constant i64 ptrtoint (i8** @__crc_bc_svc_process to i64), section "___kcrctab_gpl+bc_svc_process", align 8
@__ksymtab_bc_svc_process = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.svc_serv*, %struct.rpc_rqst*, %struct.svc_rqst*)* @bc_svc_process to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_bc_svc_process, i32 0, i32 0) }, section "___ksymtab_gpl+bc_svc_process", align 8
@__kcrctab_svc_max_payload = internal constant i64 ptrtoint (i8** @__crc_svc_max_payload to i64), section "___kcrctab_gpl+svc_max_payload", align 8
@__ksymtab_svc_max_payload = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.svc_rqst*)* @svc_max_payload to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_svc_max_payload, i32 0, i32 0) }, section "___ksymtab_gpl+svc_max_payload", align 8
@__kstrtab_svc_max_payload = internal constant [16 x i8] c"svc_max_payload\00", section "__ksymtab_strings", align 1
@__crc_svc_max_payload = extern_weak global i8*, align 8
@__kstrtab_bc_svc_process = internal constant [15 x i8] c"bc_svc_process\00", section "__ksymtab_strings", align 1
@.str.10.527 = private unnamed_addr constant [38 x i8] c"\013No support for Non-TCP transports!\0A\00", align 1
@.str.2.528 = private unnamed_addr constant [17 x i8] c"net/sunrpc/svc.c\00", align 1
@.str.31.530 = private unnamed_addr constant [31 x i8] c"\01dsvc: failed to encode reply\0A\00", align 1
@.str.32.531 = private unnamed_addr constant [27 x i8] c"\01dsvc: calling dispatcher\0A\00", align 1
@.str.33.532 = private unnamed_addr constant [27 x i8] c"\01dsvc: svc_process dropit\0A\00", align 1
@.str.34.533 = private unnamed_addr constant [33 x i8] c"short len %Zd, dropping request\0A\00", align 1
@.str.35.535 = private unnamed_addr constant [35 x i8] c"\01dsvc: authentication failed (%d)\0A\00", align 1
@.str.36.536 = private unnamed_addr constant [27 x i8] c"\01dsvc: unknown program %d\0A\00", align 1
@.str.37.537 = private unnamed_addr constant [38 x i8] c"unknown version (%d for prog %d, %s)\0A\00", align 1
@.str.38.538 = private unnamed_addr constant [24 x i8] c"unknown procedure (%d)\0A\00", align 1
@.str.39.539 = private unnamed_addr constant [23 x i8] c"failed to decode args\0A\00", align 1
@.str.30.541 = private unnamed_addr constant [15 x i8] c"\01dsvc: %s: %pV\00", align 1
@__crc_bc_svc_process = extern_weak global i8*, align 8
@__kstrtab_svc_process = internal constant [12 x i8] c"svc_process\00", section "__ksymtab_strings", align 1
@.str.9.543 = private unnamed_addr constant [36 x i8] c"bad direction %d, dropping request\0A\00", align 1
@__crc_svc_process = extern_weak global i8*, align 8
@__kstrtab_svc_exit_thread = internal constant [16 x i8] c"svc_exit_thread\00", section "__ksymtab_strings", align 1
@.str.546 = private unnamed_addr constant [28 x i8] c"\01dsvc: svc_destroy(%s, %d)\0A\00", align 1
@.str.1.547 = private unnamed_addr constant [38 x i8] c"svc_destroy: no threads for serv=%p!\0A\00", align 1
@svc_pool_map_mutex = internal global %struct.mutex { %struct.atomic_t { i32 1 }, %struct.spinlock { %union.anon.11 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.15.549, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @svc_pool_map_mutex to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @svc_pool_map_mutex to i8*), i64 80) to %struct.list_head*) }, %struct.task_struct* null, i8* null, i8* bitcast (%struct.mutex* @svc_pool_map_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.16.550, i32 0, i32 0), i32 0, i64 0 } }, align 8
@svc_pool_map = internal global %struct.svc_pool_map zeroinitializer, align 8
@.str.15.549 = private unnamed_addr constant [29 x i8] c"svc_pool_map_mutex.wait_lock\00", align 1
@.str.16.550 = private unnamed_addr constant [19 x i8] c"svc_pool_map_mutex\00", align 1
@__crc_svc_exit_thread = extern_weak global i8*, align 8
@__kstrtab_svc_set_num_threads = internal constant [20 x i8] c"svc_set_num_threads\00", section "__ksymtab_strings", align 1
@svc_pool_map_set_cpumask.__warned = internal global i8 0, section ".data.unlikely", align 1
@cpu_bit_bitmap = external constant [65 x [64 x i64]], align 16
@.str.3.555 = private unnamed_addr constant [16 x i8] c"&rqstp->rq_wait\00", align 1
@svc_prepare_thread.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@svc_init_buffer.__warned = internal global i8 0, section ".data.unlikely", align 1
@node_data = external global [0 x %struct.pglist_data*], align 8
@numa_node = external global i32, align 4
@__crc_svc_set_num_threads = extern_weak global i8*, align 8
@__kstrtab_svc_prepare_thread = internal constant [19 x i8] c"svc_prepare_thread\00", section "__ksymtab_strings", align 1
@__crc_svc_prepare_thread = extern_weak global i8*, align 8
@__kstrtab_svc_destroy = internal constant [12 x i8] c"svc_destroy\00", section "__ksymtab_strings", align 1
@__crc_svc_destroy = extern_weak global i8*, align 8
@__kstrtab_svc_shutdown_net = internal constant [17 x i8] c"svc_shutdown_net\00", section "__ksymtab_strings", align 1
@__crc_svc_shutdown_net = extern_weak global i8*, align 8
@__kstrtab_svc_create_pooled = internal constant [18 x i8] c"svc_create_pooled\00", section "__ksymtab_strings", align 1
@.str.18.559 = private unnamed_addr constant [22 x i8] c"(&serv->sv_temptimer)\00", align 1
@__svc_create.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.20.561 = private unnamed_addr constant [25 x i8] c"&(&serv->sv_lock)->rlock\00", align 1
@__svc_create.__key.19 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.21.563 = private unnamed_addr constant [36 x i8] c"\01dsvc: initialising pool %u for %s\0A\00", align 1
@.str.23.564 = private unnamed_addr constant [25 x i8] c"&(&pool->sp_lock)->rlock\00", align 1
@__svc_create.__key.22 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.28.566 = private unnamed_addr constant [39 x i8] c"\01dsvc: attempting to unregister %sv%u\0A\00", align 1
@.str.29.570 = private unnamed_addr constant [28 x i8] c"\01dsvc: %s(%sv%u), error %d\0A\00", align 1
@__func__.__svc_unregister = private unnamed_addr constant [17 x i8] c"__svc_unregister\00", align 1
@nr_node_ids = external global i32, align 4
@node_states = external global [5 x %struct.tcp_mib], align 16
@nr_cpu_ids = external global i32, align 4
@cpu_online_mask = external constant %struct.cpumask*, align 8
@cpumask_check.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.24.574 = private unnamed_addr constant [24 x i8] c"include/linux/cpumask.h\00", align 1
@nr_online_nodes = external global i32, align 4
@__crc_svc_create_pooled = extern_weak global i8*, align 8
@__kstrtab_svc_create = internal constant [11 x i8] c"svc_create\00", section "__ksymtab_strings", align 1
@__crc_svc_create = extern_weak global i8*, align 8
@__kstrtab_svc_bind = internal constant [9 x i8] c"svc_bind\00", section "__ksymtab_strings", align 1
@__crc_svc_bind = extern_weak global i8*, align 8
@__kstrtab_svc_rpcb_cleanup = internal constant [17 x i8] c"svc_rpcb_cleanup\00", section "__ksymtab_strings", align 1
@__crc_svc_rpcb_cleanup = extern_weak global i8*, align 8
@__kstrtab_svc_rpcb_setup = internal constant [15 x i8] c"svc_rpcb_setup\00", section "__ksymtab_strings", align 1
@__crc_svc_rpcb_setup = extern_weak global i8*, align 8
@__param_str_pool_mode = internal constant [10 x i8] c"pool_mode\00", align 1
@__param_ops_pool_mode = internal global %struct.kernel_param_ops { i32 (i8*, %struct.kernel_param*)* @param_set_pool_mode, i32 (i8*, %struct.kernel_param*)* @param_get_pool_mode, void (i8*)* null }, align 8
@.str.11.575 = private unnamed_addr constant [5 x i8] c"auto\00", align 1
@.str.12.576 = private unnamed_addr constant [7 x i8] c"global\00", align 1
@.str.13.577 = private unnamed_addr constant [7 x i8] c"percpu\00", align 1
@.str.14.578 = private unnamed_addr constant [8 x i8] c"pernode\00", align 1
@svc_register.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.7.582 = private unnamed_addr constant [27 x i8] c" (but not telling portmap)\00", align 1
@.str.4.583 = private unnamed_addr constant [42 x i8] c"\01dsvc: svc_register(%sv%d, %s, %u, %u)%s\0A\00", align 1
@.str.25.584 = private unnamed_addr constant [57 x i8] c"\014svc: failed to register %sv%u RPC service (errno %d).\0A\00", align 1
@.str.26.586 = private unnamed_addr constant [5 x i8] c"udp6\00", align 1
@.str.27.587 = private unnamed_addr constant [5 x i8] c"tcp6\00", align 1
@__kcrctab_svc_sock_update_bufs = internal constant i64 ptrtoint (i8** @__crc_svc_sock_update_bufs to i64), section "___kcrctab_gpl+svc_sock_update_bufs", align 8
@__ksymtab_svc_sock_update_bufs = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.svc_serv*)* @svc_sock_update_bufs to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_svc_sock_update_bufs, i32 0, i32 0) }, section "___ksymtab_gpl+svc_sock_update_bufs", align 8
@__kcrctab_svc_addsock = internal constant i64 ptrtoint (i8** @__crc_svc_addsock to i64), section "___kcrctab_gpl+svc_addsock", align 8
@__ksymtab_svc_addsock = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.svc_serv*, i32, i8*, i64)* @svc_addsock to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_svc_addsock, i32 0, i32 0) }, section "___ksymtab_gpl+svc_addsock", align 8
@__kstrtab_svc_addsock = internal constant [12 x i8] c"svc_addsock\00", section "__ksymtab_strings", align 1
@.str.47.591 = private unnamed_addr constant [4 x i8] c"udp\00", align 1
@.str.592 = private unnamed_addr constant [4 x i8] c"tcp\00", align 1
@.str.67.593 = private unnamed_addr constant [17 x i8] c"ipv4 %s %pI4 %d\0A\00", align 1
@.str.68.594 = private unnamed_addr constant [17 x i8] c"ipv6 %s %pI6 %d\0A\00", align 1
@.str.69.595 = private unnamed_addr constant [14 x i8] c"*unknown-%d*\0A\00", align 1
@.str.55.596 = private unnamed_addr constant [28 x i8] c"\01dsvc: svc_setup_socket %p\0A\00", align 1
@.str.56.601 = private unnamed_addr constant [46 x i8] c"\01dsvc: svc_setup_socket created %p (inet %p)\0A\00", align 1
@svc_tcp_class = internal global %struct.svc_xprt_class { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.592, i32 0, i32 0), %struct.module* @__this_module, %struct.svc_xprt_ops* @svc_tcp_ops, %struct.list_head zeroinitializer, i32 1048576 }, align 8
@.str.61.603 = private unnamed_addr constant [39 x i8] c"\01dsetting up TCP socket for listening\0A\00", align 1
@.str.62.604 = private unnamed_addr constant [37 x i8] c"\01dsetting up TCP socket for reading\0A\00", align 1
@.str.59.610 = private unnamed_addr constant [48 x i8] c"\01dsvc: socket %p(inet %p), write_space busy=%d\0A\00", align 1
@.str.60.612 = private unnamed_addr constant [47 x i8] c"\01dRPC svc_write_space: someone sleeping on %p\0A\00", align 1
@sk_sleep.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.66.615 = private unnamed_addr constant [43 x i8] c"\01dsvc: socket %p TCP data ready (svsk %p)\0A\00", align 1
@.str.65.616 = private unnamed_addr constant [60 x i8] c"\01dsvc: socket %p TCP (connected) state change %d (svsk %p)\0A\00", align 1
@.str.64.617 = private unnamed_addr constant [30 x i8] c"svc: socket %p: no user data\0A\00", align 1
@.str.63.618 = private unnamed_addr constant [47 x i8] c"\01dsvc: socket %p TCP (listen) state change %d\0A\00", align 1
@svc_tcp_ops = internal global %struct.svc_xprt_ops { %struct.svc_xprt* (%struct.svc_serv*, %struct.net*, %struct.sockaddr*, i32, i32)* @svc_tcp_create, %struct.svc_xprt* (%struct.svc_xprt*)* @svc_tcp_accept, i32 (%struct.svc_xprt*)* @svc_tcp_has_wspace, i32 (%struct.svc_rqst*)* @svc_tcp_recvfrom, void (%struct.svc_rqst*)* @svc_tcp_prep_reply_hdr, i32 (%struct.svc_rqst*)* @svc_tcp_sendto, void (%struct.svc_rqst*)* @svc_release_skb, void (%struct.svc_xprt*)* @svc_tcp_sock_detach, void (%struct.svc_xprt*)* @svc_sock_free }, align 8
@.str.46.619 = private unnamed_addr constant [26 x i8] c"\01dsvc: svc_sock_free(%p)\0A\00", align 1
@.str.42.620 = private unnamed_addr constant [32 x i8] c"\01dsvc: svc_tcp_sock_detach(%p)\0A\00", align 1
@.str.7.621 = private unnamed_addr constant [21 x i8] c"net/sunrpc/svcsock.c\00", align 1
@.str.43.622 = private unnamed_addr constant [28 x i8] c"\01dsvc: svc_sock_detach(%p)\0A\00", align 1
@.str.41.623 = private unnamed_addr constant [37 x i8] c"\01dsvc: service %p, releasing skb %p\0A\00", align 1
@.str.38.625 = private unnamed_addr constant [10 x i8] c"got error\00", align 1
@.str.39.626 = private unnamed_addr constant [10 x i8] c"sent only\00", align 1
@.str.37.627 = private unnamed_addr constant [71 x i8] c"\015rpc-srv/tcp: %s: %s %d when sending %d bytes - shutting down socket\0A\00", align 1
@.str.40.630 = private unnamed_addr constant [58 x i8] c"\01dsvc: socket %p sendto([%p %Zu... ], %d) = %d (addr %s)\0A\00", align 1
@.str.24.633 = private unnamed_addr constant [45 x i8] c"\01dsvc: tcp_recv %p data %d conn %d close %d\0A\00", align 1
@.str.25.634 = private unnamed_addr constant [41 x i8] c"\01dsvc: incomplete TCP record (%d of %d)\0A\00", align 1
@.str.26.635 = private unnamed_addr constant [32 x i8] c"\01dRPC: TCP recvfrom got EAGAIN\0A\00", align 1
@.str.27.636 = private unnamed_addr constant [34 x i8] c"\015%s: recvfrom returned errno %d\0A\00", align 1
@.str.36.637 = private unnamed_addr constant [68 x i8] c"\015%s: Got unrecognized reply: calldir 0x%x xpt_bc_xprt %p xid %08x\0A\00", align 1
@__func__.receive_cb_reply = private unnamed_addr constant [17 x i8] c"receive_cb_reply\00", align 1
@.str.34.638 = private unnamed_addr constant [6 x i8] c"final\00", align 1
@.str.35.639 = private unnamed_addr constant [9 x i8] c"nonfinal\00", align 1
@.str.33.640 = private unnamed_addr constant [33 x i8] c"\01dsvc: TCP %s record (%d bytes)\0A\00", align 1
@.str.32.641 = private unnamed_addr constant [41 x i8] c"\01dsvc: socket %p recvfrom(%p, %Zu) = %d\0A\00", align 1
@.str.28.643 = private unnamed_addr constant [62 x i8] c"\01dsvc: short recvfrom while reading record length (%d of %d)\0A\00", align 1
@.str.29.644 = private unnamed_addr constant [29 x i8] c"\01dsvc: TCP record, %d bytes\0A\00", align 1
@.str.30.645 = private unnamed_addr constant [31 x i8] c"\015RPC: fragment too large: %d\0A\00", align 1
@.str.31.646 = private unnamed_addr constant [31 x i8] c"\01dRPC: TCP recv_record got %d\0A\00", align 1
@.str.17.648 = private unnamed_addr constant [30 x i8] c"\01dsvc: tcp_accept %p sock %p\0A\00", align 1
@.str.18.649 = private unnamed_addr constant [24 x i8] c"\014%s: no more sockets!\0A\00", align 1
@.str.19.650 = private unnamed_addr constant [31 x i8] c"\014%s: accept failed (err %d)!\0A\00", align 1
@.str.20.651 = private unnamed_addr constant [33 x i8] c"\014%s: peername failed (err %d)!\0A\00", align 1
@.str.21.652 = private unnamed_addr constant [44 x i8] c"\01d\014%s: connect from unprivileged port: %s\0A\00", align 1
@.str.22.653 = private unnamed_addr constant [23 x i8] c"\01d%s: connect from %s\0A\00", align 1
@.str.23.654 = private unnamed_addr constant [47 x i8] c"\01dsvc_tcp_accept: kernel_getsockname error %d\0A\00", align 1
@.str.1.658 = private unnamed_addr constant [38 x i8] c"\01dsvc: svc_create_socket(%s, %d, %s)\0A\00", align 1
@.str.2.659 = private unnamed_addr constant [43 x i8] c"\014svc: only UDP and TCP sockets supported\0A\00", align 1
@.str.3.660 = private unnamed_addr constant [37 x i8] c"\01dsvc: svc_create_socket error = %d\0A\00", align 1
@svc_reclassify_socket.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.8.661 = private unnamed_addr constant [16 x i8] c"&sk->sk_lock.wq\00", align 1
@svc_reclassify_socket.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.10.663 = private unnamed_addr constant [31 x i8] c"&(&(sk)->sk_lock.slock)->rlock\00", align 1
@svc_reclassify_socket.__key.9 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.11.664 = private unnamed_addr constant [19 x i8] c"slock-AF_INET-NFSD\00", align 1
@svc_slock_key = internal global [2 x %struct.lock_class_key] zeroinitializer, align 16
@.str.12.665 = private unnamed_addr constant [30 x i8] c"sk_xprt.xpt_lock-AF_INET-NFSD\00", align 1
@svc_key = internal global [2 x %struct.lock_class_key] zeroinitializer, align 16
@svc_reclassify_socket.__key.13 = internal global %struct.lock_class_key zeroinitializer, align 1
@svc_reclassify_socket.__key.14 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.15.666 = private unnamed_addr constant [20 x i8] c"slock-AF_INET6-NFSD\00", align 1
@.str.16.667 = private unnamed_addr constant [31 x i8] c"sk_xprt.xpt_lock-AF_INET6-NFSD\00", align 1
@svc_udp_class = internal global %struct.svc_xprt_class { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.47.591, i32 0, i32 0), %struct.module* @__this_module, %struct.svc_xprt_ops* @svc_udp_ops, %struct.list_head zeroinitializer, i32 32768 }, align 8
@.str.57.668 = private unnamed_addr constant [38 x i8] c"\01dsvc: kernel_setsockopt returned %d\0A\00", align 1
@.str.58.669 = private unnamed_addr constant [46 x i8] c"\01dsvc: socket %p(inet %p), count=%d, busy=%d\0A\00", align 1
@svc_udp_ops = internal global %struct.svc_xprt_ops { %struct.svc_xprt* (%struct.svc_serv*, %struct.net*, %struct.sockaddr*, i32, i32)* @svc_udp_create, %struct.svc_xprt* (%struct.svc_xprt*)* @svc_udp_accept, i32 (%struct.svc_xprt*)* @svc_udp_has_wspace, i32 (%struct.svc_rqst*)* @svc_udp_recvfrom, void (%struct.svc_rqst*)* @svc_udp_prep_reply_hdr, i32 (%struct.svc_rqst*)* @svc_udp_sendto, void (%struct.svc_rqst*)* @svc_release_skb, void (%struct.svc_xprt*)* @svc_sock_detach, void (%struct.svc_xprt*)* @svc_sock_free }, align 8
@.str.48.671 = private unnamed_addr constant [35 x i8] c"\01dsvc: recvfrom returned error %d\0A\00", align 1
@.str.49.672 = private unnamed_addr constant [76 x i8] c"\014svc: received unknown control message %d/%d; dropping RPC reply datagram\0A\00", align 1
@__tracepoint_kfree_skb = external global %struct.tracepoint, align 8
@trace_kfree_skb.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.51.676 = private unnamed_addr constant [27 x i8] c"include/trace/events/skb.h\00", align 1
@.str.52.682 = private unnamed_addr constant [60 x i8] c"/diffkemp/kernel/linux-3.10/arch/x86/include/asm/paravirt.h\00", align 1
@.str.50.684 = private unnamed_addr constant [32 x i8] c"include/linux/sunrpc/svc_xprt.h\00", align 1
@__crc_svc_addsock = extern_weak global i8*, align 8
@__kstrtab_svc_sock_update_bufs = internal constant [21 x i8] c"svc_sock_update_bufs\00", section "__ksymtab_strings", align 1
@__crc_svc_sock_update_bufs = extern_weak global i8*, align 8
@svc_tcp_bc_class = internal global %struct.svc_xprt_class { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.53.691, i32 0, i32 0), %struct.module* @__this_module, %struct.svc_xprt_ops* @svc_tcp_bc_ops, %struct.list_head zeroinitializer, i32 1048576 }, align 8
@.str.53.691 = private unnamed_addr constant [7 x i8] c"tcp-bc\00", align 1
@svc_tcp_bc_ops = internal global %struct.svc_xprt_ops { %struct.svc_xprt* (%struct.svc_serv*, %struct.net*, %struct.sockaddr*, i32, i32)* @svc_bc_tcp_create, %struct.svc_xprt* (%struct.svc_xprt*)* null, i32 (%struct.svc_xprt*)* null, i32 (%struct.svc_rqst*)* null, void (%struct.svc_rqst*)* @svc_tcp_prep_reply_hdr, i32 (%struct.svc_rqst*)* null, void (%struct.svc_rqst*)* null, void (%struct.svc_xprt*)* @svc_bc_tcp_sock_detach, void (%struct.svc_xprt*)* @svc_bc_sock_free }, align 8
@.str.54.692 = private unnamed_addr constant [58 x i8] c"\014svc: only TCP sockets supported on shared back channel\0A\00", align 1
@__kcrctab_svc_authenticate = internal constant i64 ptrtoint (i8** @__crc_svc_authenticate to i64), section "___kcrctab_gpl+svc_authenticate", align 8
@__ksymtab_svc_authenticate = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.svc_rqst.5096*, i32*)* @svc_authenticate to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_svc_authenticate, i32 0, i32 0) }, section "___ksymtab_gpl+svc_authenticate", align 8
@__kcrctab_svc_set_client = internal constant i64 ptrtoint (i8** @__crc_svc_set_client to i64), section "___kcrctab_gpl+svc_set_client", align 8
@__ksymtab_svc_set_client = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.svc_rqst.5096*)* @svc_set_client to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_svc_set_client, i32 0, i32 0) }, section "___ksymtab_gpl+svc_set_client", align 8
@__kcrctab_svc_auth_register = internal constant i64 ptrtoint (i8** @__crc_svc_auth_register to i64), section "___kcrctab_gpl+svc_auth_register", align 8
@__ksymtab_svc_auth_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, %struct.auth_ops.5094*)* @svc_auth_register to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_svc_auth_register, i32 0, i32 0) }, section "___ksymtab_gpl+svc_auth_register", align 8
@__kcrctab_svc_auth_unregister = internal constant i64 ptrtoint (i8** @__crc_svc_auth_unregister to i64), section "___kcrctab_gpl+svc_auth_unregister", align 8
@__ksymtab_svc_auth_unregister = internal constant %struct.kernel_symbol { i64 ptrtoint (void (i32)* @svc_auth_unregister to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_svc_auth_unregister, i32 0, i32 0) }, section "___ksymtab_gpl+svc_auth_unregister", align 8
@__kcrctab_auth_domain_put = internal constant i64 ptrtoint (i8** @__crc_auth_domain_put to i64), section "___kcrctab_gpl+auth_domain_put", align 8
@__ksymtab_auth_domain_put = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.auth_domain.5097*)* @auth_domain_put to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_auth_domain_put, i32 0, i32 0) }, section "___ksymtab_gpl+auth_domain_put", align 8
@__kcrctab_auth_domain_lookup = internal constant i64 ptrtoint (i8** @__crc_auth_domain_lookup to i64), section "___kcrctab_gpl+auth_domain_lookup", align 8
@__ksymtab_auth_domain_lookup = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.auth_domain.5097* (i8*, %struct.auth_domain.5097*)* @auth_domain_lookup to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_auth_domain_lookup, i32 0, i32 0) }, section "___ksymtab_gpl+auth_domain_lookup", align 8
@__kcrctab_auth_domain_find = internal constant i64 ptrtoint (i8** @__crc_auth_domain_find to i64), section "___kcrctab_gpl+auth_domain_find", align 8
@__ksymtab_auth_domain_find = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.auth_domain.5097* (i8*)* @auth_domain_find to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_auth_domain_find, i32 0, i32 0) }, section "___ksymtab_gpl+auth_domain_find", align 8
@__kstrtab_auth_domain_find = internal constant [17 x i8] c"auth_domain_find\00", section "__ksymtab_strings", align 1
@auth_domain_table = internal global [64 x %struct.hlist_head] zeroinitializer, align 16
@auth_domain_lock = internal global %struct.spinlock { %union.anon.11 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2.698, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@kref_get.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.2.698 = private unnamed_addr constant [17 x i8] c"auth_domain_lock\00", align 1
@__crc_auth_domain_find = extern_weak global i8*, align 8
@__kstrtab_auth_domain_lookup = internal constant [19 x i8] c"auth_domain_lookup\00", section "__ksymtab_strings", align 1
@__crc_auth_domain_lookup = extern_weak global i8*, align 8
@__kstrtab_auth_domain_put = internal constant [16 x i8] c"auth_domain_put\00", section "__ksymtab_strings", align 1
@__crc_auth_domain_put = extern_weak global i8*, align 8
@__kstrtab_svc_auth_unregister = internal constant [20 x i8] c"svc_auth_unregister\00", section "__ksymtab_strings", align 1
@authtab_lock = internal global %struct.spinlock { %union.anon.11 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.1.701, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@authtab = internal global [8 x %struct.auth_ops.5094*] [%struct.auth_ops.5094* bitcast (%struct.auth_ops.5257* @svcauth_null to %struct.auth_ops.5094*), %struct.auth_ops.5094* bitcast (%struct.auth_ops.5257* @svcauth_unix to %struct.auth_ops.5094*), %struct.auth_ops.5094* null, %struct.auth_ops.5094* null, %struct.auth_ops.5094* null, %struct.auth_ops.5094* null, %struct.auth_ops.5094* null, %struct.auth_ops.5094* null], align 16
@.str.1.701 = private unnamed_addr constant [13 x i8] c"authtab_lock\00", align 1
@__crc_svc_auth_unregister = extern_weak global i8*, align 8
@__kstrtab_svc_auth_register = internal constant [18 x i8] c"svc_auth_register\00", section "__ksymtab_strings", align 1
@__crc_svc_auth_register = extern_weak global i8*, align 8
@__kstrtab_svc_set_client = internal constant [15 x i8] c"svc_set_client\00", section "__ksymtab_strings", align 1
@__crc_svc_set_client = extern_weak global i8*, align 8
@__kstrtab_svc_authenticate = internal constant [17 x i8] c"svc_authenticate\00", section "__ksymtab_strings", align 1
@.str.705 = private unnamed_addr constant [30 x i8] c"\01dsvc: svc_authenticate (%d)\0A\00", align 1
@__crc_svc_authenticate = extern_weak global i8*, align 8
@svcauth_unix = global %struct.auth_ops.5257 { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2.712, i32 0, i32 0), %struct.module* @__this_module, i32 1, i32 (%struct.svc_rqst.5259*, i32*)* @svcauth_unix_accept, i32 (%struct.svc_rqst.5259*)* @svcauth_unix_release, void (%struct.auth_domain.5260*)* @svcauth_unix_domain_release, i32 (%struct.svc_rqst.5259*)* @svcauth_unix_set_client }, align 8
@.str.2.712 = private unnamed_addr constant [5 x i8] c"unix\00", align 1
@.str.714 = private unnamed_addr constant [26 x i8] c"net/sunrpc/svcauth_unix.c\00", align 1
@kref_get.__warned.730 = internal global i8 0, section ".data.unlikely", align 1
@net_generic.__warned.733 = internal global i8 0, section ".data.unlikely", align 1
@rcu_read_unlock.__warned.738 = internal global i8 0, section ".data.unlikely", align 1
@rcu_read_lock.__warned.746 = internal global i8 0, section ".data.unlikely", align 1
@svcauth_null = global %struct.auth_ops.5257 { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1.755, i32 0, i32 0), %struct.module* @__this_module, i32 0, i32 (%struct.svc_rqst.5259*, i32*)* @svcauth_null_accept, i32 (%struct.svc_rqst.5259*)* @svcauth_null_release, void (%struct.auth_domain.5260*)* null, i32 (%struct.svc_rqst.5259*)* @svcauth_unix_set_client }, align 8
@.str.1.755 = private unnamed_addr constant [5 x i8] c"null\00", align 1
@.str.15.756 = private unnamed_addr constant [22 x i8] c"\01dsvc: bad null cred\0A\00", align 1
@.str.16.757 = private unnamed_addr constant [22 x i8] c"\01dsvc: bad null verf\0A\00", align 1
@__kcrctab_unix_domain_find = internal constant i64 ptrtoint (i8** @__crc_unix_domain_find to i64), section "___kcrctab_gpl+unix_domain_find", align 8
@__ksymtab_unix_domain_find = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.auth_domain.5260* (i8*)* @unix_domain_find to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_unix_domain_find, i32 0, i32 0) }, section "___ksymtab_gpl+unix_domain_find", align 8
@__kcrctab_svcauth_unix_purge = internal constant i64 ptrtoint (i8** @__crc_svcauth_unix_purge to i64), section "___kcrctab_gpl+svcauth_unix_purge", align 8
@__ksymtab_svcauth_unix_purge = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.net*)* @svcauth_unix_purge to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_svcauth_unix_purge, i32 0, i32 0) }, section "___ksymtab_gpl+svcauth_unix_purge", align 8
@__kcrctab_svcauth_unix_set_client = internal constant i64 ptrtoint (i8** @__crc_svcauth_unix_set_client to i64), section "___kcrctab_gpl+svcauth_unix_set_client", align 8
@__ksymtab_svcauth_unix_set_client = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.svc_rqst.5259*)* @svcauth_unix_set_client to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_svcauth_unix_set_client, i32 0, i32 0) }, section "___ksymtab_gpl+svcauth_unix_set_client", align 8
@__kstrtab_svcauth_unix_set_client = internal constant [24 x i8] c"svcauth_unix_set_client\00", section "__ksymtab_strings", align 1
@__crc_svcauth_unix_set_client = extern_weak global i8*, align 8
@__kstrtab_svcauth_unix_purge = internal constant [19 x i8] c"svcauth_unix_purge\00", section "__ksymtab_strings", align 1
@__crc_svcauth_unix_purge = extern_weak global i8*, align 8
@__kstrtab_unix_domain_find = internal constant [17 x i8] c"unix_domain_find\00", section "__ksymtab_strings", align 1
@__crc_unix_domain_find = extern_weak global i8*, align 8
@unix_gid_cache_template = internal global %struct.cache_detail { %struct.module* @__this_module, i32 256, %struct.cache_head** null, %struct.rwlock_t zeroinitializer, %struct.atomic_t zeroinitializer, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.9.762, i32 0, i32 0), void (%struct.arch_spinlock*)* @unix_gid_put, i32 (%struct.cache_detail*, %struct.cache_head*)* null, void (%struct.cache_detail*, %struct.cache_head*, i8**, i32*)* @unix_gid_request, i32 (%struct.cache_detail*, i8*, i32)* @unix_gid_parse, i32 (%struct.seq_file*, %struct.cache_detail*, %struct.cache_head*)* @unix_gid_show, void (%struct.cache_detail*, i32)* null, %struct.cache_head* ()* @unix_gid_alloc, i32 (%struct.cache_head*, %struct.cache_head*)* @unix_gid_match, void (%struct.cache_head*, %struct.cache_head*)* @unix_gid_init, void (%struct.cache_head*, %struct.cache_head*)* @unix_gid_update, i64 0, %struct.list_head zeroinitializer, i64 0, i32 0, %struct.list_head zeroinitializer, %struct.atomic_t zeroinitializer, i64 0, i64 0, %union.anon.71 zeroinitializer, %struct.net* null }, align 8
@.str.9.762 = private unnamed_addr constant [14 x i8] c"auth.unix.gid\00", align 1
@.str.11.764 = private unnamed_addr constant [19 x i8] c"#uid cnt: gids...\0A\00", align 1
@.str.12.765 = private unnamed_addr constant [7 x i8] c"%u %d:\00", align 1
@.str.13.766 = private unnamed_addr constant [4 x i8] c" %d\00", align 1
@.str.14.767 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@overflowgid = external global i32, align 4
@overflowuid = external global i32, align 4
@.str.10.772 = private unnamed_addr constant [3 x i8] c"%u\00", align 1
@ip_map_cache_template = internal global %struct.cache_detail { %struct.module* @__this_module, i32 256, %struct.cache_head** null, %struct.rwlock_t zeroinitializer, %struct.atomic_t zeroinitializer, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.17.773, i32 0, i32 0), void (%struct.arch_spinlock*)* @ip_map_put, i32 (%struct.cache_detail*, %struct.cache_head*)* null, void (%struct.cache_detail*, %struct.cache_head*, i8**, i32*)* @ip_map_request, i32 (%struct.cache_detail*, i8*, i32)* @ip_map_parse, i32 (%struct.seq_file*, %struct.cache_detail*, %struct.cache_head*)* @ip_map_show, void (%struct.cache_detail*, i32)* null, %struct.cache_head* ()* @ip_map_alloc, i32 (%struct.cache_head*, %struct.cache_head*)* @ip_map_match, void (%struct.cache_head*, %struct.cache_head*)* @ip_map_init, void (%struct.cache_head*, %struct.cache_head*)* @update, i64 0, %struct.list_head zeroinitializer, i64 0, i32 0, %struct.list_head zeroinitializer, %struct.atomic_t zeroinitializer, i64 0, i64 0, %union.anon.71 zeroinitializer, %struct.net* null }, align 8
@.str.17.773 = private unnamed_addr constant [13 x i8] c"auth.unix.ip\00", align 1
@.str.21.774 = private unnamed_addr constant [18 x i8] c"#class IP domain\0A\00", align 1
@.str.20.775 = private unnamed_addr constant [12 x i8] c"-no-domain-\00", align 1
@.str.22.776 = private unnamed_addr constant [12 x i8] c"%s %pI4 %s\0A\00", align 1
@.str.23.777 = private unnamed_addr constant [12 x i8] c"%s %pI6 %s\0A\00", align 1
@.str.19.780 = private unnamed_addr constant [5 x i8] c"%pI6\00", align 1
@__kcrctab_rpc_ntop = internal constant i64 ptrtoint (i8** @__crc_rpc_ntop to i64), section "___kcrctab_gpl+rpc_ntop", align 8
@__ksymtab_rpc_ntop = internal constant %struct.kernel_symbol { i64 ptrtoint (i64 (%struct.sockaddr*, i8*, i64)* @rpc_ntop to i64), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__kstrtab_rpc_ntop, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_ntop", align 8
@__kcrctab_rpc_pton = internal constant i64 ptrtoint (i8** @__crc_rpc_pton to i64), section "___kcrctab_gpl+rpc_pton", align 8
@__ksymtab_rpc_pton = internal constant %struct.kernel_symbol { i64 ptrtoint (i64 (%struct.net*, i8*, i64, %struct.sockaddr*, i64)* @rpc_pton to i64), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__kstrtab_rpc_pton, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_pton", align 8
@__kcrctab_rpc_uaddr2sockaddr = internal constant i64 ptrtoint (i8** @__crc_rpc_uaddr2sockaddr to i64), section "___kcrctab_gpl+rpc_uaddr2sockaddr", align 8
@__ksymtab_rpc_uaddr2sockaddr = internal constant %struct.kernel_symbol { i64 ptrtoint (i64 (%struct.net*, i8*, i64, %struct.sockaddr*, i64)* @rpc_uaddr2sockaddr to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_rpc_uaddr2sockaddr, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_uaddr2sockaddr", align 8
@__kstrtab_rpc_uaddr2sockaddr = internal constant [19 x i8] c"rpc_uaddr2sockaddr\00", section "__ksymtab_strings", align 1
@__crc_rpc_uaddr2sockaddr = extern_weak global i8*, align 8
@__kstrtab_rpc_pton = internal constant [9 x i8] c"rpc_pton\00", section "__ksymtab_strings", align 1
@__crc_rpc_pton = extern_weak global i8*, align 8
@__kstrtab_rpc_ntop = internal constant [9 x i8] c"rpc_ntop\00", section "__ksymtab_strings", align 1
@.str.2.788 = private unnamed_addr constant [5 x i8] c"%c%u\00", align 1
@.str.3.789 = private unnamed_addr constant [3 x i8] c"::\00", align 1
@.str.4.790 = private unnamed_addr constant [4 x i8] c"::1\00", align 1
@.str.5.792 = private unnamed_addr constant [12 x i8] c"::ffff:%pI4\00", align 1
@.str.6.793 = private unnamed_addr constant [6 x i8] c"%pI6c\00", align 1
@.str.1.794 = private unnamed_addr constant [5 x i8] c"%pI4\00", align 1
@__crc_rpc_ntop = extern_weak global i8*, align 8
@.str.795 = private unnamed_addr constant [7 x i8] c".%u.%u\00", align 1
@__kcrctab_rpcb_getport_async = internal constant i64 ptrtoint (i8** @__crc_rpcb_getport_async to i64), section "___kcrctab_gpl+rpcb_getport_async", align 8
@__ksymtab_rpcb_getport_async = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_task*)* @rpcb_getport_async to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_rpcb_getport_async, i32 0, i32 0) }, section "___ksymtab_gpl+rpcb_getport_async", align 8
@__kstrtab_rpcb_getport_async = internal constant [19 x i8] c"rpcb_getport_async\00", section "__ksymtab_strings", align 1
@rpcb_getport_async.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.6.801 = private unnamed_addr constant [23 x i8] c"net/sunrpc/rpcb_clnt.c\00", align 1
@.str.8.804 = private unnamed_addr constant [31 x i8] c"\01dRPC: %5u %s(%s, %u, %u, %d)\0A\00", align 1
@__func__.rpcb_getport_async = private unnamed_addr constant [19 x i8] c"rpcb_getport_async\00", align 1
@.str.9.805 = private unnamed_addr constant [43 x i8] c"\01dRPC: %5u %s: waiting for another binder\0A\00", align 1
@.str.10.807 = private unnamed_addr constant [30 x i8] c"\01dRPC: %5u %s: already bound\0A\00", align 1
@.str.11.808 = private unnamed_addr constant [35 x i8] c"\01dRPC: %5u %s: bad address family\0A\00", align 1
@rpcb_next_version6 = internal constant [3 x %struct.rpcb_info] [%struct.rpcb_info { i32 4, %struct.rpc_procinfo* bitcast (i8* getelementptr (i8, i8* bitcast ([4 x %struct.rpc_procinfo]* @rpcb_procedures4 to i8*), i64 168) to %struct.rpc_procinfo*) }, %struct.rpcb_info { i32 3, %struct.rpc_procinfo* bitcast (i8* getelementptr (i8, i8* bitcast ([4 x %struct.rpc_procinfo]* @rpcb_procedures3 to i8*), i64 168) to %struct.rpc_procinfo*) }, %struct.rpcb_info zeroinitializer], align 16
@rpcb_next_version = internal constant [2 x %struct.rpcb_info] [%struct.rpcb_info { i32 2, %struct.rpc_procinfo* bitcast (i8* getelementptr (i8, i8* bitcast ([4 x %struct.rpc_procinfo]* @rpcb_procedures2 to i8*), i64 168) to %struct.rpc_procinfo*) }, %struct.rpcb_info zeroinitializer], align 16
@.str.12.809 = private unnamed_addr constant [51 x i8] c"\01dRPC: %5u %s: no more getport versions available\0A\00", align 1
@.str.13.810 = private unnamed_addr constant [42 x i8] c"\01dRPC: %5u %s: trying rpcbind version %u\0A\00", align 1
@.str.14.813 = private unnamed_addr constant [46 x i8] c"\01dRPC: %5u %s: rpcb_create failed, error %ld\0A\00", align 1
@.str.15.815 = private unnamed_addr constant [36 x i8] c"\01dRPC: %5u %s: no memory available\0A\00", align 1
@.str.16.817 = private unnamed_addr constant [36 x i8] c"\01dRPC: %5u %s: rpc_run_task failed\0A\00", align 1
@rpcb_getport_ops = internal constant %struct.rpc_call_ops { void (%struct.rpc_task*, i8*)* null, void (%struct.rpc_task*, i8*)* @rpcb_getport_done, void (%struct.rpc_task*, i8*)* null, void (i8*)* @rpcb_map_release }, align 8
@.str.42.820 = private unnamed_addr constant [50 x i8] c"\01dRPC: %5u rpcb_getport_done(status %d, port %u)\0A\00", align 1
@rpcb_program = internal constant %struct.rpc_program { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.21.824, i32 0, i32 0), i32 100000, i32 5, %struct.rpc_version** getelementptr inbounds ([5 x %struct.rpc_version*], [5 x %struct.rpc_version*]* @rpcb_version, i32 0, i32 0), %struct.rpc_stat* @rpcb_stats, i8* null }, align 8
@.str.21.824 = private unnamed_addr constant [8 x i8] c"rpcbind\00", align 1
@rpcb_version = internal global [5 x %struct.rpc_version*] [%struct.rpc_version* null, %struct.rpc_version* null, %struct.rpc_version* @rpcb_version2, %struct.rpc_version* @rpcb_version3, %struct.rpc_version* @rpcb_version4], align 16
@rpcb_stats = internal global %struct.rpc_stat zeroinitializer, align 8
@rpcb_version2 = internal constant %struct.rpc_version { i32 2, i32 4, %struct.rpc_procinfo* getelementptr inbounds ([4 x %struct.rpc_procinfo], [4 x %struct.rpc_procinfo]* @rpcb_procedures2, i32 0, i32 0) }, align 8
@rpcb_version3 = internal constant %struct.rpc_version { i32 3, i32 4, %struct.rpc_procinfo* getelementptr inbounds ([4 x %struct.rpc_procinfo], [4 x %struct.rpc_procinfo]* @rpcb_procedures3, i32 0, i32 0) }, align 8
@rpcb_version4 = internal constant %struct.rpc_version { i32 4, i32 4, %struct.rpc_procinfo* getelementptr inbounds ([4 x %struct.rpc_procinfo], [4 x %struct.rpc_procinfo]* @rpcb_procedures4, i32 0, i32 0) }, align 8
@rpcb_procedures4 = internal global [4 x %struct.rpc_procinfo] [%struct.rpc_procinfo zeroinitializer, %struct.rpc_procinfo { i32 1, void (i8*, %struct.xdr_stream*, i8*)* bitcast (void (%struct.rpc_rqst*, %struct.xdr_stream*, %struct.rpcbind_args*)* @rpcb_enc_getaddr to void (i8*, %struct.xdr_stream*, i8*)*), i32 (i8*, %struct.xdr_stream*, i8*)* bitcast (i32 (%struct.rpc_rqst*, %struct.xdr_stream*, i32*)* @rpcb_dec_set to i32 (i8*, %struct.xdr_stream*, i8*)*), i32 22, i32 1, i32 0, i32 0, i32 1, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.22.825, i32 0, i32 0) }, %struct.rpc_procinfo { i32 2, void (i8*, %struct.xdr_stream*, i8*)* bitcast (void (%struct.rpc_rqst*, %struct.xdr_stream*, %struct.rpcbind_args*)* @rpcb_enc_getaddr to void (i8*, %struct.xdr_stream*, i8*)*), i32 (i8*, %struct.xdr_stream*, i8*)* bitcast (i32 (%struct.rpc_rqst*, %struct.xdr_stream*, i32*)* @rpcb_dec_set to i32 (i8*, %struct.xdr_stream*, i8*)*), i32 22, i32 1, i32 0, i32 0, i32 2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.23.826, i32 0, i32 0) }, %struct.rpc_procinfo { i32 3, void (i8*, %struct.xdr_stream*, i8*)* bitcast (void (%struct.rpc_rqst*, %struct.xdr_stream*, %struct.rpcbind_args*)* @rpcb_enc_getaddr to void (i8*, %struct.xdr_stream*, i8*)*), i32 (i8*, %struct.xdr_stream*, i8*)* bitcast (i32 (%struct.rpc_rqst*, %struct.xdr_stream*, %struct.rpcbind_args*)* @rpcb_dec_getaddr to i32 (i8*, %struct.xdr_stream*, i8*)*), i32 22, i32 16, i32 0, i32 0, i32 3, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.24.827, i32 0, i32 0) }], align 16
@.str.22.825 = private unnamed_addr constant [4 x i8] c"SET\00", align 1
@.str.23.826 = private unnamed_addr constant [6 x i8] c"UNSET\00", align 1
@.str.24.827 = private unnamed_addr constant [8 x i8] c"GETADDR\00", align 1
@.str.29.828 = private unnamed_addr constant [47 x i8] c"\01dRPC: %5u RPCB reply: program not registered\0A\00", align 1
@.str.30.829 = private unnamed_addr constant [30 x i8] c"\01dRPC: %5u RPCB_%s reply: %s\0A\00", align 1
@.str.31.831 = private unnamed_addr constant [36 x i8] c"\01dRPC: %5u malformed RPCB_%s reply\0A\00", align 1
@.str.27.835 = private unnamed_addr constant [10 x i8] c"succeeded\00", align 1
@.str.28.836 = private unnamed_addr constant [7 x i8] c"failed\00", align 1
@.str.26.837 = private unnamed_addr constant [28 x i8] c"\01dRPC: %5u RPCB_%s call %s\0A\00", align 1
@.str.25.838 = private unnamed_addr constant [55 x i8] c"\01dRPC: %5u encoding RPCB_%s call (%u, %u, '%s', '%s')\0A\00", align 1
@encode_rpcb_string.__warned = internal global i8 0, section ".data.unlikely", align 1
@rpcb_procedures3 = internal global [4 x %struct.rpc_procinfo] [%struct.rpc_procinfo zeroinitializer, %struct.rpc_procinfo { i32 1, void (i8*, %struct.xdr_stream*, i8*)* bitcast (void (%struct.rpc_rqst*, %struct.xdr_stream*, %struct.rpcbind_args*)* @rpcb_enc_getaddr to void (i8*, %struct.xdr_stream*, i8*)*), i32 (i8*, %struct.xdr_stream*, i8*)* bitcast (i32 (%struct.rpc_rqst*, %struct.xdr_stream*, i32*)* @rpcb_dec_set to i32 (i8*, %struct.xdr_stream*, i8*)*), i32 22, i32 1, i32 0, i32 0, i32 1, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.22.825, i32 0, i32 0) }, %struct.rpc_procinfo { i32 2, void (i8*, %struct.xdr_stream*, i8*)* bitcast (void (%struct.rpc_rqst*, %struct.xdr_stream*, %struct.rpcbind_args*)* @rpcb_enc_getaddr to void (i8*, %struct.xdr_stream*, i8*)*), i32 (i8*, %struct.xdr_stream*, i8*)* bitcast (i32 (%struct.rpc_rqst*, %struct.xdr_stream*, i32*)* @rpcb_dec_set to i32 (i8*, %struct.xdr_stream*, i8*)*), i32 22, i32 1, i32 0, i32 0, i32 2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.23.826, i32 0, i32 0) }, %struct.rpc_procinfo { i32 3, void (i8*, %struct.xdr_stream*, i8*)* bitcast (void (%struct.rpc_rqst*, %struct.xdr_stream*, %struct.rpcbind_args*)* @rpcb_enc_getaddr to void (i8*, %struct.xdr_stream*, i8*)*), i32 (i8*, %struct.xdr_stream*, i8*)* bitcast (i32 (%struct.rpc_rqst*, %struct.xdr_stream*, %struct.rpcbind_args*)* @rpcb_dec_getaddr to i32 (i8*, %struct.xdr_stream*, i8*)*), i32 22, i32 16, i32 0, i32 0, i32 3, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.24.827, i32 0, i32 0) }], align 16
@rpcb_procedures2 = internal global [4 x %struct.rpc_procinfo] [%struct.rpc_procinfo zeroinitializer, %struct.rpc_procinfo { i32 1, void (i8*, %struct.xdr_stream*, i8*)* bitcast (void (%struct.rpc_rqst*, %struct.xdr_stream*, %struct.rpcbind_args*)* @rpcb_enc_mapping to void (i8*, %struct.xdr_stream*, i8*)*), i32 (i8*, %struct.xdr_stream*, i8*)* bitcast (i32 (%struct.rpc_rqst*, %struct.xdr_stream*, i32*)* @rpcb_dec_set to i32 (i8*, %struct.xdr_stream*, i8*)*), i32 4, i32 1, i32 0, i32 0, i32 1, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.22.825, i32 0, i32 0) }, %struct.rpc_procinfo { i32 2, void (i8*, %struct.xdr_stream*, i8*)* bitcast (void (%struct.rpc_rqst*, %struct.xdr_stream*, %struct.rpcbind_args*)* @rpcb_enc_mapping to void (i8*, %struct.xdr_stream*, i8*)*), i32 (i8*, %struct.xdr_stream*, i8*)* bitcast (i32 (%struct.rpc_rqst*, %struct.xdr_stream*, i32*)* @rpcb_dec_set to i32 (i8*, %struct.xdr_stream*, i8*)*), i32 4, i32 1, i32 0, i32 0, i32 2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.23.826, i32 0, i32 0) }, %struct.rpc_procinfo { i32 3, void (i8*, %struct.xdr_stream*, i8*)* bitcast (void (%struct.rpc_rqst*, %struct.xdr_stream*, %struct.rpcbind_args*)* @rpcb_enc_mapping to void (i8*, %struct.xdr_stream*, i8*)*), i32 (i8*, %struct.xdr_stream*, i8*)* bitcast (i32 (%struct.rpc_rqst*, %struct.xdr_stream*, %struct.rpcbind_args*)* @rpcb_dec_getport to i32 (i8*, %struct.xdr_stream*, i8*)*), i32 4, i32 1, i32 0, i32 0, i32 3, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.44.839, i32 0, i32 0) }], align 16
@.str.44.839 = private unnamed_addr constant [8 x i8] c"GETPORT\00", align 1
@.str.46.840 = private unnamed_addr constant [32 x i8] c"\01dRPC: %5u PMAP_%s result: %lu\0A\00", align 1
@.str.45.841 = private unnamed_addr constant [51 x i8] c"\01dRPC: %5u encoding PMAP_%s call (%u, %u, %d, %u)\0A\00", align 1
@rcu_read_unlock.__warned.843 = internal global i8 0, section ".data.unlikely", align 1
@rpcb_find_transport_owner.__warned = internal global i8 0, section ".data.unlikely", align 1
@rpcb_find_transport_owner.__warned.40 = internal global i8 0, section ".data.unlikely", align 1
@rcu_read_lock.__warned.851 = internal global i8 0, section ".data.unlikely", align 1
@__crc_rpcb_getport_async = extern_weak global i8*, align 8
@net_generic.__warned.858 = internal global i8 0, section ".data.unlikely", align 1
@rpcb_create_local.rpcb_create_local_mutex = internal global %struct.mutex { %struct.atomic_t { i32 1 }, %struct.spinlock { %union.anon.11 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.868, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @rpcb_create_local.rpcb_create_local_mutex to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @rpcb_create_local.rpcb_create_local_mutex to i8*), i64 80) to %struct.list_head*) }, %struct.task_struct* null, i8* null, i8* bitcast (%struct.mutex* @rpcb_create_local.rpcb_create_local_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.1.869, i32 0, i32 0), i32 0, i64 0 } }, align 8
@rpcb_create_local_net.rpcb_inaddr_loopback = internal constant %struct.sockaddr_in { i16 2, i16 28416, %struct.atomic_t { i32 16777343 }, [8 x i8] zeroinitializer }, align 4
@.str.18.862 = private unnamed_addr constant [10 x i8] c"localhost\00", align 1
@.str.34.863 = private unnamed_addr constant [65 x i8] c"\01dRPC:       failed to create local rpcbind client (errno %ld).\0A\00", align 1
@.str.20.864 = private unnamed_addr constant [78 x i8] c"\01dRPC:       failed to bind second program to rpcbind v4 client (errno %ld).\0A\00", align 1
@init_net = external global %struct.net, align 64
@.str.32.866 = private unnamed_addr constant [102 x i8] c"\01dRPC:       created new rpcb local clients (rpcb_local_clnt: %p, rpcb_local_clnt4: %p) for net %p%s\0A\00", align 1
@rpcb_create_local_unix.rpcb_localaddr_rpcbind = internal constant %struct.sockaddr_un { i16 1, [108 x i8] c"/var/run/rpcbind.sock\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, align 2
@.str.19.867 = private unnamed_addr constant [68 x i8] c"\01dRPC:       failed to create AF_LOCAL rpcbind client (errno %ld).\0A\00", align 1
@.str.868 = private unnamed_addr constant [34 x i8] c"rpcb_create_local_mutex.wait_lock\00", align 1
@.str.1.869 = private unnamed_addr constant [24 x i8] c"rpcb_create_local_mutex\00", align 1
@.str.4.872 = private unnamed_addr constant [3 x i8] c"un\00", align 1
@.str.2.873 = private unnamed_addr constant [64 x i8] c"\01dRPC:       %sregistering (%u, %u, %d, %u) with local rpcbind\0A\00", align 1
@.str.35.874 = private unnamed_addr constant [65 x i8] c"\01dRPC:       failed to contact local rpcbind server (errno %d).\0A\00", align 1
@.str.5.877 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.37.878 = private unnamed_addr constant [66 x i8] c"\01dRPC:       %sregistering [%u, %u, %s, '%s'] with local rpcbind\0A\00", align 1
@.str.36.879 = private unnamed_addr constant [62 x i8] c"\01dRPC:       unregistering [%u, %u, '%s'] with local rpcbind\0A\00", align 1
@__kcrctab_rpc_init_rtt = internal constant i64 ptrtoint (i8** @__crc_rpc_init_rtt to i64), section "___kcrctab_gpl+rpc_init_rtt", align 8
@__ksymtab_rpc_init_rtt = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_rtt*, i64)* @rpc_init_rtt to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_rpc_init_rtt, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_init_rtt", align 8
@__kcrctab_rpc_update_rtt = internal constant i64 ptrtoint (i8** @__crc_rpc_update_rtt to i64), section "___kcrctab_gpl+rpc_update_rtt", align 8
@__ksymtab_rpc_update_rtt = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_rtt*, i32, i64)* @rpc_update_rtt to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_rpc_update_rtt, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_update_rtt", align 8
@__kcrctab_rpc_calc_rto = internal constant i64 ptrtoint (i8** @__crc_rpc_calc_rto to i64), section "___kcrctab_gpl+rpc_calc_rto", align 8
@__ksymtab_rpc_calc_rto = internal constant %struct.kernel_symbol { i64 ptrtoint (i64 (%struct.rpc_rtt*, i32)* @rpc_calc_rto to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_rpc_calc_rto, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_calc_rto", align 8
@__kstrtab_rpc_calc_rto = internal constant [13 x i8] c"rpc_calc_rto\00", section "__ksymtab_strings", align 1
@__crc_rpc_calc_rto = extern_weak global i8*, align 8
@__kstrtab_rpc_update_rtt = internal constant [15 x i8] c"rpc_update_rtt\00", section "__ksymtab_strings", align 1
@__crc_rpc_update_rtt = extern_weak global i8*, align 8
@__kstrtab_rpc_init_rtt = internal constant [13 x i8] c"rpc_init_rtt\00", section "__ksymtab_strings", align 1
@__crc_rpc_init_rtt = extern_weak global i8*, align 8
@__kcrctab_xdr_encode_netobj = internal constant i64 ptrtoint (i8** @__crc_xdr_encode_netobj to i64), section "___kcrctab_gpl+xdr_encode_netobj", align 8
@__ksymtab_xdr_encode_netobj = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* (i32*, %struct.perf_raw_record*)* @xdr_encode_netobj to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_xdr_encode_netobj, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_encode_netobj", align 8
@__kcrctab_xdr_decode_netobj = internal constant i64 ptrtoint (i8** @__crc_xdr_decode_netobj to i64), section "___kcrctab_gpl+xdr_decode_netobj", align 8
@__ksymtab_xdr_decode_netobj = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* (i32*, %struct.perf_raw_record*)* @xdr_decode_netobj to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_xdr_decode_netobj, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_decode_netobj", align 8
@__kcrctab_xdr_encode_opaque_fixed = internal constant i64 ptrtoint (i8** @__crc_xdr_encode_opaque_fixed to i64), section "___kcrctab_gpl+xdr_encode_opaque_fixed", align 8
@__ksymtab_xdr_encode_opaque_fixed = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* (i32*, i8*, i32)* @xdr_encode_opaque_fixed to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_xdr_encode_opaque_fixed, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_encode_opaque_fixed", align 8
@__kcrctab_xdr_encode_opaque = internal constant i64 ptrtoint (i8** @__crc_xdr_encode_opaque to i64), section "___kcrctab_gpl+xdr_encode_opaque", align 8
@__ksymtab_xdr_encode_opaque = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* (i32*, i8*, i32)* @xdr_encode_opaque to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_xdr_encode_opaque, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_encode_opaque", align 8
@__kcrctab_xdr_encode_string = internal constant i64 ptrtoint (i8** @__crc_xdr_encode_string to i64), section "___kcrctab_gpl+xdr_encode_string", align 8
@__ksymtab_xdr_encode_string = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* (i32*, i8*)* @xdr_encode_string to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_xdr_encode_string, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_encode_string", align 8
@__kcrctab_xdr_decode_string_inplace = internal constant i64 ptrtoint (i8** @__crc_xdr_decode_string_inplace to i64), section "___kcrctab_gpl+xdr_decode_string_inplace", align 8
@__ksymtab_xdr_decode_string_inplace = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* (i32*, i8**, i32*, i32)* @xdr_decode_string_inplace to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_xdr_decode_string_inplace, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_decode_string_inplace", align 8
@__kcrctab_xdr_terminate_string = internal constant i64 ptrtoint (i8** @__crc_xdr_terminate_string to i64), section "___kcrctab_gpl+xdr_terminate_string", align 8
@__ksymtab_xdr_terminate_string = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.xdr_buf*, i32)* @xdr_terminate_string to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_xdr_terminate_string, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_terminate_string", align 8
@__kcrctab_xdr_inline_pages = internal constant i64 ptrtoint (i8** @__crc_xdr_inline_pages to i64), section "___kcrctab_gpl+xdr_inline_pages", align 8
@__ksymtab_xdr_inline_pages = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.xdr_buf*, i32, %struct.page**, i32, i32)* @xdr_inline_pages to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_xdr_inline_pages, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_inline_pages", align 8
@__kcrctab__copy_from_pages = internal constant i64 ptrtoint (i8** @__crc__copy_from_pages to i64), section "___kcrctab_gpl+_copy_from_pages", align 8
@__ksymtab__copy_from_pages = internal constant %struct.kernel_symbol { i64 ptrtoint (void (i8*, %struct.page**, i64, i64)* @_copy_from_pages to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab__copy_from_pages, i32 0, i32 0) }, section "___ksymtab_gpl+_copy_from_pages", align 8
@__kcrctab_xdr_shift_buf = internal constant i64 ptrtoint (i8** @__crc_xdr_shift_buf to i64), section "___kcrctab_gpl+xdr_shift_buf", align 8
@__ksymtab_xdr_shift_buf = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.xdr_buf*, i64)* @xdr_shift_buf to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_xdr_shift_buf, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_shift_buf", align 8
@__kcrctab_xdr_stream_pos = internal constant i64 ptrtoint (i8** @__crc_xdr_stream_pos to i64), section "___kcrctab_gpl+xdr_stream_pos", align 8
@__ksymtab_xdr_stream_pos = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.xdr_stream*)* @xdr_stream_pos to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_xdr_stream_pos, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_stream_pos", align 8
@__kcrctab_xdr_init_encode = internal constant i64 ptrtoint (i8** @__crc_xdr_init_encode to i64), section "___kcrctab_gpl+xdr_init_encode", align 8
@__ksymtab_xdr_init_encode = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.xdr_stream*, %struct.xdr_buf*, i32*)* @xdr_init_encode to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_xdr_init_encode, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_init_encode", align 8
@__kcrctab_xdr_reserve_space = internal constant i64 ptrtoint (i8** @__crc_xdr_reserve_space to i64), section "___kcrctab_gpl+xdr_reserve_space", align 8
@__ksymtab_xdr_reserve_space = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* (%struct.xdr_stream*, i64)* @xdr_reserve_space to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_xdr_reserve_space, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_reserve_space", align 8
@__kcrctab_xdr_write_pages = internal constant i64 ptrtoint (i8** @__crc_xdr_write_pages to i64), section "___kcrctab_gpl+xdr_write_pages", align 8
@__ksymtab_xdr_write_pages = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.xdr_stream*, %struct.page**, i32, i32)* @xdr_write_pages to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_xdr_write_pages, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_write_pages", align 8
@__kcrctab_xdr_init_decode = internal constant i64 ptrtoint (i8** @__crc_xdr_init_decode to i64), section "___kcrctab_gpl+xdr_init_decode", align 8
@__ksymtab_xdr_init_decode = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.xdr_stream*, %struct.xdr_buf*, i32*)* @xdr_init_decode to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_xdr_init_decode, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_init_decode", align 8
@__kcrctab_xdr_init_decode_pages = internal constant i64 ptrtoint (i8** @__crc_xdr_init_decode_pages to i64), section "___kcrctab_gpl+xdr_init_decode_pages", align 8
@__ksymtab_xdr_init_decode_pages = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.xdr_stream*, %struct.xdr_buf*, %struct.page**, i32)* @xdr_init_decode_pages to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_xdr_init_decode_pages, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_init_decode_pages", align 8
@__kcrctab_xdr_set_scratch_buffer = internal constant i64 ptrtoint (i8** @__crc_xdr_set_scratch_buffer to i64), section "___kcrctab_gpl+xdr_set_scratch_buffer", align 8
@__ksymtab_xdr_set_scratch_buffer = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.xdr_stream*, i8*, i64)* @xdr_set_scratch_buffer to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_xdr_set_scratch_buffer, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_set_scratch_buffer", align 8
@__kcrctab_xdr_inline_decode = internal constant i64 ptrtoint (i8** @__crc_xdr_inline_decode to i64), section "___kcrctab_gpl+xdr_inline_decode", align 8
@__ksymtab_xdr_inline_decode = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* (%struct.xdr_stream*, i64)* @xdr_inline_decode to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_xdr_inline_decode, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_inline_decode", align 8
@__kcrctab_xdr_read_pages = internal constant i64 ptrtoint (i8** @__crc_xdr_read_pages to i64), section "___kcrctab_gpl+xdr_read_pages", align 8
@__ksymtab_xdr_read_pages = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.xdr_stream*, i32)* @xdr_read_pages to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_xdr_read_pages, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_read_pages", align 8
@__kcrctab_xdr_enter_page = internal constant i64 ptrtoint (i8** @__crc_xdr_enter_page to i64), section "___kcrctab_gpl+xdr_enter_page", align 8
@__ksymtab_xdr_enter_page = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.xdr_stream*, i32)* @xdr_enter_page to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_xdr_enter_page, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_enter_page", align 8
@__kcrctab_xdr_buf_from_iov = internal constant i64 ptrtoint (i8** @__crc_xdr_buf_from_iov to i64), section "___kcrctab_gpl+xdr_buf_from_iov", align 8
@__ksymtab_xdr_buf_from_iov = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.iovec*, %struct.xdr_buf*)* @xdr_buf_from_iov to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_xdr_buf_from_iov, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_buf_from_iov", align 8
@__kcrctab_xdr_buf_subsegment = internal constant i64 ptrtoint (i8** @__crc_xdr_buf_subsegment to i64), section "___kcrctab_gpl+xdr_buf_subsegment", align 8
@__ksymtab_xdr_buf_subsegment = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.xdr_buf*, %struct.xdr_buf*, i32, i32)* @xdr_buf_subsegment to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_xdr_buf_subsegment, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_buf_subsegment", align 8
@__kcrctab_xdr_buf_trim = internal constant i64 ptrtoint (i8** @__crc_xdr_buf_trim to i64), section "___kcrctab_gpl+xdr_buf_trim", align 8
@__ksymtab_xdr_buf_trim = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.xdr_buf*, i32)* @xdr_buf_trim to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_xdr_buf_trim, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_buf_trim", align 8
@__kcrctab_read_bytes_from_xdr_buf = internal constant i64 ptrtoint (i8** @__crc_read_bytes_from_xdr_buf to i64), section "___kcrctab_gpl+read_bytes_from_xdr_buf", align 8
@__ksymtab_read_bytes_from_xdr_buf = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.xdr_buf*, i32, i8*, i32)* @read_bytes_from_xdr_buf to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_read_bytes_from_xdr_buf, i32 0, i32 0) }, section "___ksymtab_gpl+read_bytes_from_xdr_buf", align 8
@__kcrctab_write_bytes_to_xdr_buf = internal constant i64 ptrtoint (i8** @__crc_write_bytes_to_xdr_buf to i64), section "___kcrctab_gpl+write_bytes_to_xdr_buf", align 8
@__ksymtab_write_bytes_to_xdr_buf = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.xdr_buf*, i32, i8*, i32)* @write_bytes_to_xdr_buf to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_write_bytes_to_xdr_buf, i32 0, i32 0) }, section "___ksymtab_gpl+write_bytes_to_xdr_buf", align 8
@__kcrctab_xdr_decode_word = internal constant i64 ptrtoint (i8** @__crc_xdr_decode_word to i64), section "___kcrctab_gpl+xdr_decode_word", align 8
@__ksymtab_xdr_decode_word = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.xdr_buf*, i32, i32*)* @xdr_decode_word to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_xdr_decode_word, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_decode_word", align 8
@__kcrctab_xdr_encode_word = internal constant i64 ptrtoint (i8** @__crc_xdr_encode_word to i64), section "___kcrctab_gpl+xdr_encode_word", align 8
@__ksymtab_xdr_encode_word = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.xdr_buf*, i32, i32)* @xdr_encode_word to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_xdr_encode_word, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_encode_word", align 8
@__kcrctab_xdr_buf_read_netobj = internal constant i64 ptrtoint (i8** @__crc_xdr_buf_read_netobj to i64), section "___kcrctab_gpl+xdr_buf_read_netobj", align 8
@__ksymtab_xdr_buf_read_netobj = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.xdr_buf*, %struct.perf_raw_record*, i32)* @xdr_buf_read_netobj to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_xdr_buf_read_netobj, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_buf_read_netobj", align 8
@__kcrctab_xdr_decode_array2 = internal constant i64 ptrtoint (i8** @__crc_xdr_decode_array2 to i64), section "___kcrctab_gpl+xdr_decode_array2", align 8
@__ksymtab_xdr_decode_array2 = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.xdr_buf*, i32, %struct.xdr_array2_desc*)* @xdr_decode_array2 to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_xdr_decode_array2, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_decode_array2", align 8
@__kcrctab_xdr_encode_array2 = internal constant i64 ptrtoint (i8** @__crc_xdr_encode_array2 to i64), section "___kcrctab_gpl+xdr_encode_array2", align 8
@__ksymtab_xdr_encode_array2 = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.xdr_buf*, i32, %struct.xdr_array2_desc*)* @xdr_encode_array2 to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_xdr_encode_array2, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_encode_array2", align 8
@__kcrctab_xdr_process_buf = internal constant i64 ptrtoint (i8** @__crc_xdr_process_buf to i64), section "___kcrctab_gpl+xdr_process_buf", align 8
@__ksymtab_xdr_process_buf = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.xdr_buf*, i32, i32, i32 (%struct.scatterlist*, i8*)*, i8*)* @xdr_process_buf to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_xdr_process_buf, i32 0, i32 0) }, section "___ksymtab_gpl+xdr_process_buf", align 8
@__kstrtab_xdr_process_buf = internal constant [16 x i8] c"xdr_process_buf\00", section "__ksymtab_strings", align 1
@.str.2.888 = private unnamed_addr constant [28 x i8] c"include/linux/scatterlist.h\00", align 1
@__crc_xdr_process_buf = extern_weak global i8*, align 8
@__kstrtab_xdr_encode_array2 = internal constant [18 x i8] c"xdr_encode_array2\00", section "__ksymtab_strings", align 1
@__crc_xdr_encode_array2 = extern_weak global i8*, align 8
@__kstrtab_xdr_decode_array2 = internal constant [18 x i8] c"xdr_decode_array2\00", section "__ksymtab_strings", align 1
@__crc_xdr_decode_array2 = extern_weak global i8*, align 8
@__kstrtab_xdr_buf_read_netobj = internal constant [20 x i8] c"xdr_buf_read_netobj\00", section "__ksymtab_strings", align 1
@__crc_xdr_buf_read_netobj = extern_weak global i8*, align 8
@__kstrtab_xdr_encode_word = internal constant [16 x i8] c"xdr_encode_word\00", section "__ksymtab_strings", align 1
@__crc_xdr_encode_word = extern_weak global i8*, align 8
@__kstrtab_xdr_decode_word = internal constant [16 x i8] c"xdr_decode_word\00", section "__ksymtab_strings", align 1
@__crc_xdr_decode_word = extern_weak global i8*, align 8
@__kstrtab_write_bytes_to_xdr_buf = internal constant [23 x i8] c"write_bytes_to_xdr_buf\00", section "__ksymtab_strings", align 1
@__crc_write_bytes_to_xdr_buf = extern_weak global i8*, align 8
@__kstrtab_read_bytes_from_xdr_buf = internal constant [24 x i8] c"read_bytes_from_xdr_buf\00", section "__ksymtab_strings", align 1
@__crc_read_bytes_from_xdr_buf = extern_weak global i8*, align 8
@__kstrtab_xdr_buf_trim = internal constant [13 x i8] c"xdr_buf_trim\00", section "__ksymtab_strings", align 1
@__crc_xdr_buf_trim = extern_weak global i8*, align 8
@__kstrtab_xdr_buf_subsegment = internal constant [19 x i8] c"xdr_buf_subsegment\00", section "__ksymtab_strings", align 1
@__crc_xdr_buf_subsegment = extern_weak global i8*, align 8
@__kstrtab_xdr_buf_from_iov = internal constant [17 x i8] c"xdr_buf_from_iov\00", section "__ksymtab_strings", align 1
@empty_iov = internal global %struct.iovec zeroinitializer, align 8
@__crc_xdr_buf_from_iov = extern_weak global i8*, align 8
@__kstrtab_xdr_enter_page = internal constant [15 x i8] c"xdr_enter_page\00", section "__ksymtab_strings", align 1
@.str.899 = private unnamed_addr constant [17 x i8] c"net/sunrpc/xdr.c\00", align 1
@xdr_shrink_bufhead.__warned = internal global i8 0, section ".data.unlikely", align 1
@__crc_xdr_enter_page = extern_weak global i8*, align 8
@__kstrtab_xdr_read_pages = internal constant [15 x i8] c"xdr_read_pages\00", section "__ksymtab_strings", align 1
@__crc_xdr_read_pages = extern_weak global i8*, align 8
@__kstrtab_xdr_inline_decode = internal constant [18 x i8] c"xdr_inline_decode\00", section "__ksymtab_strings", align 1
@__crc_xdr_inline_decode = extern_weak global i8*, align 8
@__kstrtab_xdr_set_scratch_buffer = internal constant [23 x i8] c"xdr_set_scratch_buffer\00", section "__ksymtab_strings", align 1
@__crc_xdr_set_scratch_buffer = extern_weak global i8*, align 8
@__kstrtab_xdr_init_decode_pages = internal constant [22 x i8] c"xdr_init_decode_pages\00", section "__ksymtab_strings", align 1
@__crc_xdr_init_decode_pages = extern_weak global i8*, align 8
@__kstrtab_xdr_init_decode = internal constant [16 x i8] c"xdr_init_decode\00", section "__ksymtab_strings", align 1
@__crc_xdr_init_decode = extern_weak global i8*, align 8
@__kstrtab_xdr_write_pages = internal constant [16 x i8] c"xdr_write_pages\00", section "__ksymtab_strings", align 1
@__crc_xdr_write_pages = extern_weak global i8*, align 8
@__kstrtab_xdr_reserve_space = internal constant [18 x i8] c"xdr_reserve_space\00", section "__ksymtab_strings", align 1
@__crc_xdr_reserve_space = extern_weak global i8*, align 8
@__kstrtab_xdr_init_encode = internal constant [16 x i8] c"xdr_init_encode\00", section "__ksymtab_strings", align 1
@__crc_xdr_init_encode = extern_weak global i8*, align 8
@__kstrtab_xdr_stream_pos = internal constant [15 x i8] c"xdr_stream_pos\00", section "__ksymtab_strings", align 1
@__crc_xdr_stream_pos = extern_weak global i8*, align 8
@__kstrtab_xdr_shift_buf = internal constant [14 x i8] c"xdr_shift_buf\00", section "__ksymtab_strings", align 1
@__crc_xdr_shift_buf = extern_weak global i8*, align 8
@__kstrtab__copy_from_pages = internal constant [17 x i8] c"_copy_from_pages\00", section "__ksymtab_strings", align 1
@__crc__copy_from_pages = extern_weak global i8*, align 8
@__kstrtab_xdr_inline_pages = internal constant [17 x i8] c"xdr_inline_pages\00", section "__ksymtab_strings", align 1
@__crc_xdr_inline_pages = extern_weak global i8*, align 8
@__kstrtab_xdr_terminate_string = internal constant [21 x i8] c"xdr_terminate_string\00", section "__ksymtab_strings", align 1
@__crc_xdr_terminate_string = extern_weak global i8*, align 8
@__kstrtab_xdr_decode_string_inplace = internal constant [26 x i8] c"xdr_decode_string_inplace\00", section "__ksymtab_strings", align 1
@__crc_xdr_decode_string_inplace = extern_weak global i8*, align 8
@__kstrtab_xdr_encode_string = internal constant [18 x i8] c"xdr_encode_string\00", section "__ksymtab_strings", align 1
@__crc_xdr_encode_string = extern_weak global i8*, align 8
@__kstrtab_xdr_encode_opaque = internal constant [18 x i8] c"xdr_encode_opaque\00", section "__ksymtab_strings", align 1
@__crc_xdr_encode_opaque = extern_weak global i8*, align 8
@__kstrtab_xdr_encode_opaque_fixed = internal constant [24 x i8] c"xdr_encode_opaque_fixed\00", section "__ksymtab_strings", align 1
@__crc_xdr_encode_opaque_fixed = extern_weak global i8*, align 8
@__kstrtab_xdr_decode_netobj = internal constant [18 x i8] c"xdr_decode_netobj\00", section "__ksymtab_strings", align 1
@__crc_xdr_decode_netobj = extern_weak global i8*, align 8
@__kstrtab_xdr_encode_netobj = internal constant [18 x i8] c"xdr_encode_netobj\00", section "__ksymtab_strings", align 1
@__crc_xdr_encode_netobj = extern_weak global i8*, align 8
@sunrpc_net_id = common global i32 0, align 4
@__kcrctab_sunrpc_net_id = internal constant i64 ptrtoint (i8** @__crc_sunrpc_net_id to i64), section "___kcrctab_gpl+sunrpc_net_id", align 8
@__ksymtab_sunrpc_net_id = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* @sunrpc_net_id to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_sunrpc_net_id, i32 0, i32 0) }, section "___ksymtab_gpl+sunrpc_net_id", align 8
@__UNIQUE_ID_license125 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__kstrtab_sunrpc_net_id = internal constant [14 x i8] c"sunrpc_net_id\00", section "__ksymtab_strings", align 1
@__crc_sunrpc_net_id = extern_weak global i8*, align 8
@sunrpc_net_ops = internal global %struct.pernet_operations { %struct.list_head zeroinitializer, i32 (%struct.net*)* @sunrpc_init_net, void (%struct.net*)* @sunrpc_exit_net, void (%struct.list_head*)* null, i32* @sunrpc_net_id, i64 696 }, align 8
@.str.917 = private unnamed_addr constant [31 x i8] c"&(&sn->rpc_client_lock)->rlock\00", align 1
@sunrpc_init_net.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.2.918 = private unnamed_addr constant [30 x i8] c"&(&sn->rpcb_clnt_lock)->rlock\00", align 1
@sunrpc_init_net.__key.1 = internal global %struct.lock_class_key zeroinitializer, align 1
@net_generic.__warned.920 = internal global i8 0, section ".data.unlikely", align 1
@rcu_read_unlock.__warned.925 = internal global i8 0, section ".data.unlikely", align 1
@rcu_read_lock.__warned.933 = internal global i8 0, section ".data.unlikely", align 1
@cache_file_operations_pipefs = constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @no_llseek, i64 (%struct.file*, i8*, i64, i64*)* @cache_read_pipefs, i64 (%struct.file*, i8*, i64, i64*)* @cache_write_pipefs, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @cache_poll_pipefs, i64 (%struct.file*, i32, i64)* @cache_ioctl_pipefs, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @cache_open_pipefs, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @cache_release_pipefs, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@queue_lock = internal global %struct.spinlock { %union.anon.11 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.11.938, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@.str.11.938 = private unnamed_addr constant [11 x i8] c"queue_lock\00", align 1
@queue_wait = internal global %struct.__wait_queue_head { %struct.spinlock { %union.anon.11 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.12.942, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.__wait_queue_head* @queue_wait to i8*), i64 72) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.__wait_queue_head* @queue_wait to i8*), i64 72) to %struct.list_head*) } }, align 8
@.str.12.942 = private unnamed_addr constant [16 x i8] c"queue_wait.lock\00", align 1
@queue_io_mutex = internal global %struct.mutex { %struct.atomic_t { i32 1 }, %struct.spinlock { %union.anon.11 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.26.945, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @queue_io_mutex to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @queue_io_mutex to i8*), i64 80) to %struct.list_head*) }, %struct.task_struct* null, i8* null, i8* bitcast (%struct.mutex* @queue_io_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.27.946, i32 0, i32 0), i32 0, i64 0 } }, align 8
@cache_slow_downcall.write_buf = internal global [8192 x i8] zeroinitializer, align 16
@.str.26.945 = private unnamed_addr constant [25 x i8] c"queue_io_mutex.wait_lock\00", align 1
@.str.27.946 = private unnamed_addr constant [15 x i8] c"queue_io_mutex\00", align 1
@.str.25.949 = private unnamed_addr constant [24 x i8] c"include/linux/highmem.h\00", align 1
@cache_read.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.3.952 = private unnamed_addr constant [19 x i8] c"net/sunrpc/cache.c\00", align 1
@cache_read.__warned.24 = internal global i8 0, section ".data.unlikely", align 1
@content_file_operations_pipefs = constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @seq_lseek, i64 (%struct.file*, i8*, i64, i64*)* @seq_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @content_open_pipefs, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @content_release_pipefs, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@cache_content_op = internal constant %struct.seq_operations { i8* (%struct.seq_file*, i64*)* @c_start, void (%struct.seq_file*, i8*)* @c_stop, i8* (%struct.seq_file*, i8*, i64*)* @c_next, i32 (%struct.seq_file*, i8*)* @c_show }, align 8
@.str.28.960 = private unnamed_addr constant [34 x i8] c"# expiry=%ld refcnt=%d flags=%lx\0A\00", align 1
@.str.29.964 = private unnamed_addr constant [3 x i8] c"# \00", align 1
@.str.965 = private unnamed_addr constant [47 x i8] c"\01dRPC:       Want update, refage=%ld, age=%ld\0A\00", align 1
@cache_defer_cnt = internal global i32 0, align 4
@cache_defer_lock = internal global %struct.spinlock { %union.anon.11 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.10.973, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@cache_defer_list = internal global %struct.list_head { %struct.list_head* @cache_defer_list, %struct.list_head* @cache_defer_list }, align 8
@.str.10.973 = private unnamed_addr constant [17 x i8] c"cache_defer_lock\00", align 1
@cache_defer_hash = internal global [256 x %struct.hlist_head] zeroinitializer, align 16
@.str.9.975 = private unnamed_addr constant [9 x i8] c"&x->wait\00", align 1
@init_completion.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@kref_get.__warned.981 = internal global i8 0, section ".data.unlikely", align 1
@cache_flush_operations_pipefs = constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @no_llseek, i64 (%struct.file*, i8*, i64, i64*)* @read_flush_pipefs, i64 (%struct.file*, i8*, i64, i64*)* @write_flush_pipefs, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @open_flush_pipefs, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @release_flush_pipefs, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@cache_list_lock = internal global %struct.spinlock { %union.anon.11 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.8.985, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@current_detail = internal global %struct.cache_detail* null, align 8
@current_index = internal global i32 0, align 4
@cache_list = internal global %struct.list_head { %struct.list_head* @cache_list, %struct.list_head* @cache_list }, align 8
@.str.8.985 = private unnamed_addr constant [16 x i8] c"cache_list_lock\00", align 1
@.str.21.989 = private unnamed_addr constant [5 x i8] c"%lu\0A\00", align 1
@__kcrctab_sunrpc_cache_lookup = internal constant i64 ptrtoint (i8** @__crc_sunrpc_cache_lookup to i64), section "___kcrctab_gpl+sunrpc_cache_lookup", align 8
@__ksymtab_sunrpc_cache_lookup = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.cache_head* (%struct.cache_detail*, %struct.cache_head*, i32)* @sunrpc_cache_lookup to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_sunrpc_cache_lookup, i32 0, i32 0) }, section "___ksymtab_gpl+sunrpc_cache_lookup", align 8
@__kcrctab_sunrpc_cache_update = internal constant i64 ptrtoint (i8** @__crc_sunrpc_cache_update to i64), section "___kcrctab_gpl+sunrpc_cache_update", align 8
@__ksymtab_sunrpc_cache_update = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.cache_head* (%struct.cache_detail*, %struct.cache_head*, %struct.cache_head*, i32)* @sunrpc_cache_update to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_sunrpc_cache_update, i32 0, i32 0) }, section "___ksymtab_gpl+sunrpc_cache_update", align 8
@__kcrctab_cache_check = internal constant i64 ptrtoint (i8** @__crc_cache_check to i64), section "___kcrctab_gpl+cache_check", align 8
@__ksymtab_cache_check = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.cache_detail*, %struct.cache_head*, %struct.cache_req*)* @cache_check to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_cache_check, i32 0, i32 0) }, section "___ksymtab_gpl+cache_check", align 8
@__kcrctab_sunrpc_init_cache_detail = internal constant i64 ptrtoint (i8** @__crc_sunrpc_init_cache_detail to i64), section "___kcrctab_gpl+sunrpc_init_cache_detail", align 8
@__ksymtab_sunrpc_init_cache_detail = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.cache_detail*)* @sunrpc_init_cache_detail to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_sunrpc_init_cache_detail, i32 0, i32 0) }, section "___ksymtab_gpl+sunrpc_init_cache_detail", align 8
@__kcrctab_sunrpc_destroy_cache_detail = internal constant i64 ptrtoint (i8** @__crc_sunrpc_destroy_cache_detail to i64), section "___kcrctab_gpl+sunrpc_destroy_cache_detail", align 8
@__ksymtab_sunrpc_destroy_cache_detail = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.cache_detail*)* @sunrpc_destroy_cache_detail to i64), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__kstrtab_sunrpc_destroy_cache_detail, i32 0, i32 0) }, section "___ksymtab_gpl+sunrpc_destroy_cache_detail", align 8
@__kcrctab_cache_flush = internal constant i64 ptrtoint (i8** @__crc_cache_flush to i64), section "___kcrctab_gpl+cache_flush", align 8
@__ksymtab_cache_flush = internal constant %struct.kernel_symbol { i64 ptrtoint (void ()* @cache_flush to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_cache_flush, i32 0, i32 0) }, section "___ksymtab_gpl+cache_flush", align 8
@__kcrctab_cache_purge = internal constant i64 ptrtoint (i8** @__crc_cache_purge to i64), section "___kcrctab_gpl+cache_purge", align 8
@__ksymtab_cache_purge = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.cache_detail*)* @cache_purge to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_cache_purge, i32 0, i32 0) }, section "___ksymtab_gpl+cache_purge", align 8
@__kcrctab_qword_add = internal constant i64 ptrtoint (i8** @__crc_qword_add to i64), section "___kcrctab_gpl+qword_add", align 8
@__ksymtab_qword_add = internal constant %struct.kernel_symbol { i64 ptrtoint (void (i8**, i32*, i8*)* @qword_add to i64), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__kstrtab_qword_add, i32 0, i32 0) }, section "___ksymtab_gpl+qword_add", align 8
@__kcrctab_qword_addhex = internal constant i64 ptrtoint (i8** @__crc_qword_addhex to i64), section "___kcrctab_gpl+qword_addhex", align 8
@__ksymtab_qword_addhex = internal constant %struct.kernel_symbol { i64 ptrtoint (void (i8**, i32*, i8*, i32)* @qword_addhex to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_qword_addhex, i32 0, i32 0) }, section "___ksymtab_gpl+qword_addhex", align 8
@__kcrctab_sunrpc_cache_pipe_upcall = internal constant i64 ptrtoint (i8** @__crc_sunrpc_cache_pipe_upcall to i64), section "___kcrctab_gpl+sunrpc_cache_pipe_upcall", align 8
@__ksymtab_sunrpc_cache_pipe_upcall = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.cache_detail*, %struct.cache_head*)* @sunrpc_cache_pipe_upcall to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_sunrpc_cache_pipe_upcall, i32 0, i32 0) }, section "___ksymtab_gpl+sunrpc_cache_pipe_upcall", align 8
@__kcrctab_qword_get = internal constant i64 ptrtoint (i8** @__crc_qword_get to i64), section "___kcrctab_gpl+qword_get", align 8
@__ksymtab_qword_get = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i8**, i8*, i32)* @qword_get to i64), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__kstrtab_qword_get, i32 0, i32 0) }, section "___ksymtab_gpl+qword_get", align 8
@__kcrctab_cache_register_net = internal constant i64 ptrtoint (i8** @__crc_cache_register_net to i64), section "___kcrctab_gpl+cache_register_net", align 8
@__ksymtab_cache_register_net = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.cache_detail*, %struct.net*)* @cache_register_net to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_cache_register_net, i32 0, i32 0) }, section "___ksymtab_gpl+cache_register_net", align 8
@__kcrctab_cache_unregister_net = internal constant i64 ptrtoint (i8** @__crc_cache_unregister_net to i64), section "___kcrctab_gpl+cache_unregister_net", align 8
@__ksymtab_cache_unregister_net = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.cache_detail*, %struct.net*)* @cache_unregister_net to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_cache_unregister_net, i32 0, i32 0) }, section "___ksymtab_gpl+cache_unregister_net", align 8
@__kcrctab_cache_create_net = internal constant i64 ptrtoint (i8** @__crc_cache_create_net to i64), section "___kcrctab_gpl+cache_create_net", align 8
@__ksymtab_cache_create_net = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.cache_detail* (%struct.cache_detail*, %struct.net*)* @cache_create_net to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_cache_create_net, i32 0, i32 0) }, section "___ksymtab_gpl+cache_create_net", align 8
@__kcrctab_cache_destroy_net = internal constant i64 ptrtoint (i8** @__crc_cache_destroy_net to i64), section "___kcrctab_gpl+cache_destroy_net", align 8
@__ksymtab_cache_destroy_net = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.cache_detail*, %struct.net*)* @cache_destroy_net to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_cache_destroy_net, i32 0, i32 0) }, section "___ksymtab_gpl+cache_destroy_net", align 8
@__kcrctab_sunrpc_cache_register_pipefs = internal constant i64 ptrtoint (i8** @__crc_sunrpc_cache_register_pipefs to i64), section "___kcrctab_gpl+sunrpc_cache_register_pipefs", align 8
@__ksymtab_sunrpc_cache_register_pipefs = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.dentry*, i8*, i16, %struct.cache_detail*)* @sunrpc_cache_register_pipefs to i64), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__kstrtab_sunrpc_cache_register_pipefs, i32 0, i32 0) }, section "___ksymtab_gpl+sunrpc_cache_register_pipefs", align 8
@__kcrctab_sunrpc_cache_unregister_pipefs = internal constant i64 ptrtoint (i8** @__crc_sunrpc_cache_unregister_pipefs to i64), section "___kcrctab_gpl+sunrpc_cache_unregister_pipefs", align 8
@__ksymtab_sunrpc_cache_unregister_pipefs = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.cache_detail*)* @sunrpc_cache_unregister_pipefs to i64), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__kstrtab_sunrpc_cache_unregister_pipefs, i32 0, i32 0) }, section "___ksymtab_gpl+sunrpc_cache_unregister_pipefs", align 8
@__kstrtab_sunrpc_cache_unregister_pipefs = internal constant [31 x i8] c"sunrpc_cache_unregister_pipefs\00", section "__ksymtab_strings", align 1
@__crc_sunrpc_cache_unregister_pipefs = extern_weak global i8*, align 8
@__kstrtab_sunrpc_cache_register_pipefs = internal constant [29 x i8] c"sunrpc_cache_register_pipefs\00", section "__ksymtab_strings", align 1
@__crc_sunrpc_cache_register_pipefs = extern_weak global i8*, align 8
@__kstrtab_cache_destroy_net = internal constant [18 x i8] c"cache_destroy_net\00", section "__ksymtab_strings", align 1
@__crc_cache_destroy_net = extern_weak global i8*, align 8
@__kstrtab_cache_create_net = internal constant [17 x i8] c"cache_create_net\00", section "__ksymtab_strings", align 1
@__crc_cache_create_net = extern_weak global i8*, align 8
@__kstrtab_cache_unregister_net = internal constant [21 x i8] c"cache_unregister_net\00", section "__ksymtab_strings", align 1
@.str.2.1003 = private unnamed_addr constant [39 x i8] c"\013nfsd: failed to unregister %s cache\0A\00", align 1
@cache_cleaner = internal global %struct.delayed_work zeroinitializer, align 8
@net_generic.__warned.1009 = internal global i8 0, section ".data.unlikely", align 1
@rcu_read_unlock.__warned.1014 = internal global i8 0, section ".data.unlikely", align 1
@rcu_read_lock.__warned.1022 = internal global i8 0, section ".data.unlikely", align 1
@__crc_cache_unregister_net = extern_weak global i8*, align 8
@__kstrtab_cache_register_net = internal constant [19 x i8] c"cache_register_net\00", section "__ksymtab_strings", align 1
@cache_flush_operations_procfs = internal constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @no_llseek, i64 (%struct.file*, i8*, i64, i64*)* @read_flush_procfs, i64 (%struct.file*, i8*, i64, i64*)* @write_flush_procfs, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @open_flush_procfs, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @release_flush_procfs, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@cache_file_operations_procfs = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @no_llseek, i64 (%struct.file*, i8*, i64, i64*)* @cache_read_procfs, i64 (%struct.file*, i8*, i64, i64*)* @cache_write_procfs, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @cache_poll_procfs, i64 (%struct.file*, i32, i64)* @cache_ioctl_procfs, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @cache_open_procfs, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @cache_release_procfs, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@content_file_operations_procfs = internal constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @seq_lseek, i64 (%struct.file*, i8*, i64, i64*)* @seq_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @content_open_procfs, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @content_release_procfs, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@.str.1.1026 = private unnamed_addr constant [15 x i8] c"&cd->hash_lock\00", align 1
@sunrpc_init_cache_detail.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@system_wq = external global %struct.workqueue_struct*, align 8
@__crc_cache_register_net = extern_weak global i8*, align 8
@__kstrtab_qword_get = internal constant [10 x i8] c"qword_get\00", section "__ksymtab_strings", align 1
@__crc_qword_get = extern_weak global i8*, align 8
@__kstrtab_sunrpc_cache_pipe_upcall = internal constant [25 x i8] c"sunrpc_cache_pipe_upcall\00", section "__ksymtab_strings", align 1
@__crc_sunrpc_cache_pipe_upcall = extern_weak global i8*, align 8
@__kstrtab_qword_addhex = internal constant [13 x i8] c"qword_addhex\00", section "__ksymtab_strings", align 1
@__crc_qword_addhex = extern_weak global i8*, align 8
@__kstrtab_qword_add = internal constant [10 x i8] c"qword_add\00", section "__ksymtab_strings", align 1
@__crc_qword_add = extern_weak global i8*, align 8
@__kstrtab_cache_purge = internal constant [12 x i8] c"cache_purge\00", section "__ksymtab_strings", align 1
@__crc_cache_purge = extern_weak global i8*, align 8
@__kstrtab_cache_flush = internal constant [12 x i8] c"cache_flush\00", section "__ksymtab_strings", align 1
@__crc_cache_flush = extern_weak global i8*, align 8
@__kstrtab_sunrpc_destroy_cache_detail = internal constant [28 x i8] c"sunrpc_destroy_cache_detail\00", section "__ksymtab_strings", align 1
@__crc_sunrpc_destroy_cache_detail = extern_weak global i8*, align 8
@__kstrtab_sunrpc_init_cache_detail = internal constant [25 x i8] c"sunrpc_init_cache_detail\00", section "__ksymtab_strings", align 1
@__crc_sunrpc_init_cache_detail = extern_weak global i8*, align 8
@__kstrtab_cache_check = internal constant [12 x i8] c"cache_check\00", section "__ksymtab_strings", align 1
@__crc_cache_check = extern_weak global i8*, align 8
@__kstrtab_sunrpc_cache_update = internal constant [20 x i8] c"sunrpc_cache_update\00", section "__ksymtab_strings", align 1
@__crc_sunrpc_cache_update = extern_weak global i8*, align 8
@__kstrtab_sunrpc_cache_lookup = internal constant [20 x i8] c"sunrpc_cache_lookup\00", section "__ksymtab_strings", align 1
@__crc_sunrpc_cache_lookup = extern_weak global i8*, align 8
@.str.4.1040 = private unnamed_addr constant [26 x i8] c"(&(&cache_cleaner)->work)\00", align 1
@cache_initialize.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.6.1041 = private unnamed_addr constant [27 x i8] c"(&(&cache_cleaner)->timer)\00", align 1
@cache_initialize.__key.5 = internal global %struct.lock_class_key zeroinitializer, align 1
@__kcrctab_rpc_pipefs_notifier_register = internal constant i64 ptrtoint (i8** @__crc_rpc_pipefs_notifier_register to i64), section "___kcrctab_gpl+rpc_pipefs_notifier_register", align 8
@__ksymtab_rpc_pipefs_notifier_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.notifier_block*)* @rpc_pipefs_notifier_register to i64), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__kstrtab_rpc_pipefs_notifier_register, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_pipefs_notifier_register", align 8
@__kcrctab_rpc_pipefs_notifier_unregister = internal constant i64 ptrtoint (i8** @__crc_rpc_pipefs_notifier_unregister to i64), section "___kcrctab_gpl+rpc_pipefs_notifier_unregister", align 8
@__ksymtab_rpc_pipefs_notifier_unregister = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.notifier_block*)* @rpc_pipefs_notifier_unregister to i64), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__kstrtab_rpc_pipefs_notifier_unregister, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_pipefs_notifier_unregister", align 8
@__kcrctab_rpc_pipe_generic_upcall = internal constant i64 ptrtoint (i8** @__crc_rpc_pipe_generic_upcall to i64), section "___kcrctab_gpl+rpc_pipe_generic_upcall", align 8
@__ksymtab_rpc_pipe_generic_upcall = internal constant %struct.kernel_symbol { i64 ptrtoint (i64 (%struct.file*, %struct.rpc_pipe_msg*, i8*, i64)* @rpc_pipe_generic_upcall to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_rpc_pipe_generic_upcall, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_pipe_generic_upcall", align 8
@__kcrctab_rpc_queue_upcall = internal constant i64 ptrtoint (i8** @__crc_rpc_queue_upcall to i64), section "___kcrctab_gpl+rpc_queue_upcall", align 8
@__ksymtab_rpc_queue_upcall = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rpc_pipe*, %struct.rpc_pipe_msg*)* @rpc_queue_upcall to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_rpc_queue_upcall, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_queue_upcall", align 8
@__kcrctab_rpc_destroy_pipe_data = internal constant i64 ptrtoint (i8** @__crc_rpc_destroy_pipe_data to i64), section "___kcrctab_gpl+rpc_destroy_pipe_data", align 8
@__ksymtab_rpc_destroy_pipe_data = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_pipe*)* @rpc_destroy_pipe_data to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_rpc_destroy_pipe_data, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_destroy_pipe_data", align 8
@__kcrctab_rpc_mkpipe_data = internal constant i64 ptrtoint (i8** @__crc_rpc_mkpipe_data to i64), section "___kcrctab_gpl+rpc_mkpipe_data", align 8
@__ksymtab_rpc_mkpipe_data = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_pipe* (%struct.rpc_pipe_ops*, i32)* @rpc_mkpipe_data to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_rpc_mkpipe_data, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_mkpipe_data", align 8
@__kcrctab_rpc_rmdir = internal constant i64 ptrtoint (i8** @__crc_rpc_rmdir to i64), section "___kcrctab_gpl+rpc_rmdir", align 8
@__ksymtab_rpc_rmdir = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.dentry*)* @rpc_rmdir to i64), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__kstrtab_rpc_rmdir, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_rmdir", align 8
@__kcrctab_rpc_mkpipe_dentry = internal constant i64 ptrtoint (i8** @__crc_rpc_mkpipe_dentry to i64), section "___kcrctab_gpl+rpc_mkpipe_dentry", align 8
@__ksymtab_rpc_mkpipe_dentry = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.dentry* (%struct.dentry*, i8*, i8*, %struct.rpc_pipe*)* @rpc_mkpipe_dentry to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_rpc_mkpipe_dentry, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_mkpipe_dentry", align 8
@__kcrctab_rpc_unlink = internal constant i64 ptrtoint (i8** @__crc_rpc_unlink to i64), section "___kcrctab_gpl+rpc_unlink", align 8
@__ksymtab_rpc_unlink = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.dentry*)* @rpc_unlink to i64), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__kstrtab_rpc_unlink, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_unlink", align 8
@__kcrctab_rpc_d_lookup_sb = internal constant i64 ptrtoint (i8** @__crc_rpc_d_lookup_sb to i64), section "___kcrctab_gpl+rpc_d_lookup_sb", align 8
@__ksymtab_rpc_d_lookup_sb = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.dentry* (%struct.super_block*, i8*)* @rpc_d_lookup_sb to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_rpc_d_lookup_sb, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_d_lookup_sb", align 8
@__kcrctab_rpc_get_sb_net = internal constant i64 ptrtoint (i8** @__crc_rpc_get_sb_net to i64), section "___kcrctab_gpl+rpc_get_sb_net", align 8
@__ksymtab_rpc_get_sb_net = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.super_block* (%struct.net*)* @rpc_get_sb_net to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_rpc_get_sb_net, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_get_sb_net", align 8
@__kcrctab_rpc_put_sb_net = internal constant i64 ptrtoint (i8** @__crc_rpc_put_sb_net to i64), section "___kcrctab_gpl+rpc_put_sb_net", align 8
@__ksymtab_rpc_put_sb_net = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.net*)* @rpc_put_sb_net to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_rpc_put_sb_net, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_put_sb_net", align 8
@__UNIQUE_ID_alias1182 = internal constant [20 x i8] c"alias=fs-rpc_pipefs\00", section ".modinfo", align 1
@__UNIQUE_ID_alias1183 = internal constant [17 x i8] c"alias=rpc_pipefs\00", section ".modinfo", align 1
@__kstrtab_rpc_put_sb_net = internal constant [15 x i8] c"rpc_put_sb_net\00", section "__ksymtab_strings", align 1
@.str.1.1046 = private unnamed_addr constant [22 x i8] c"net/sunrpc/rpc_pipe.c\00", align 1
@net_generic.__warned.1048 = internal global i8 0, section ".data.unlikely", align 1
@rcu_read_unlock.__warned.1053 = internal global i8 0, section ".data.unlikely", align 1
@rcu_read_lock.__warned.1061 = internal global i8 0, section ".data.unlikely", align 1
@__crc_rpc_put_sb_net = extern_weak global i8*, align 8
@__kstrtab_rpc_get_sb_net = internal constant [15 x i8] c"rpc_get_sb_net\00", section "__ksymtab_strings", align 1
@__crc_rpc_get_sb_net = extern_weak global i8*, align 8
@__kstrtab_rpc_d_lookup_sb = internal constant [16 x i8] c"rpc_d_lookup_sb\00", section "__ksymtab_strings", align 1
@__crc_rpc_d_lookup_sb = extern_weak global i8*, align 8
@__kstrtab_rpc_unlink = internal constant [11 x i8] c"rpc_unlink\00", section "__ksymtab_strings", align 1
@__crc_rpc_unlink = extern_weak global i8*, align 8
@__kstrtab_rpc_mkpipe_dentry = internal constant [18 x i8] c"rpc_mkpipe_dentry\00", section "__ksymtab_strings", align 1
@rpc_pipe_fops = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @no_llseek, i64 (%struct.file*, i8*, i64, i64*)* @rpc_pipe_read, i64 (%struct.file*, i8*, i64, i64*)* @rpc_pipe_write, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @rpc_pipe_poll, i64 (%struct.file*, i32, i64)* @rpc_pipe_ioctl, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @rpc_pipe_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @rpc_pipe_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@.str.1077 = private unnamed_addr constant [53 x i8] c"\014%s: %s() failed to create pipe %s/%s (errno = %d)\0A\00", align 1
@__func__.rpc_mkpipe_dentry = private unnamed_addr constant [18 x i8] c"rpc_mkpipe_dentry\00", align 1
@.str.11.1079 = private unnamed_addr constant [49 x i8] c"\014%s: %s failed to allocate inode for dentry %s\0A\00", align 1
@__func__.__rpc_create_common = private unnamed_addr constant [20 x i8] c"__rpc_create_common\00", align 1
@simple_dir_operations = external constant %struct.file_operations, align 8
@simple_dir_inode_operations = external constant %struct.inode_operations, align 64
@rpc_dentry_operations = internal constant %struct.dentry_operations { i32 (%struct.dentry*, i32)* null, i32 (%struct.dentry*, i32)* null, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)* null, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)* null, i32 (%struct.dentry*)* @rpc_delete_dentry, void (%struct.dentry*)* null, void (%struct.dentry*)* null, void (%struct.dentry*, %struct.inode*)* null, i8* (%struct.dentry*, i8*, i32)* null, %struct.vfsmount* (%struct.path*)* null, i32 (%struct.dentry*, i1)* null, [40 x i8] undef }, align 64
@__crc_rpc_mkpipe_dentry = extern_weak global i8*, align 8
@__kstrtab_rpc_rmdir = internal constant [10 x i8] c"rpc_rmdir\00", section "__ksymtab_strings", align 1
@__crc_rpc_rmdir = extern_weak global i8*, align 8
@__kstrtab_rpc_mkpipe_data = internal constant [16 x i8] c"rpc_mkpipe_data\00", section "__ksymtab_strings", align 1
@.str.6.1085 = private unnamed_addr constant [32 x i8] c"(&(&pipe->queue_timeout)->work)\00", align 1
@init_pipe.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.8.1086 = private unnamed_addr constant [33 x i8] c"(&(&pipe->queue_timeout)->timer)\00", align 1
@init_pipe.__key.7 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.10.1088 = private unnamed_addr constant [22 x i8] c"&(&pipe->lock)->rlock\00", align 1
@init_pipe.__key.9 = internal global %struct.lock_class_key zeroinitializer, align 1
@__crc_rpc_mkpipe_data = extern_weak global i8*, align 8
@__kstrtab_rpc_destroy_pipe_data = internal constant [22 x i8] c"rpc_destroy_pipe_data\00", section "__ksymtab_strings", align 1
@__crc_rpc_destroy_pipe_data = extern_weak global i8*, align 8
@__kstrtab_rpc_queue_upcall = internal constant [17 x i8] c"rpc_queue_upcall\00", section "__ksymtab_strings", align 1
@__crc_rpc_queue_upcall = extern_weak global i8*, align 8
@__kstrtab_rpc_pipe_generic_upcall = internal constant [24 x i8] c"rpc_pipe_generic_upcall\00", section "__ksymtab_strings", align 1
@__crc_rpc_pipe_generic_upcall = extern_weak global i8*, align 8
@__kstrtab_rpc_pipefs_notifier_unregister = internal constant [31 x i8] c"rpc_pipefs_notifier_unregister\00", section "__ksymtab_strings", align 1
@rpc_pipefs_notifier_list = internal global %struct.blocking_notifier_head { %struct.rw_semaphore { i64 0, %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.4.1095, i32 0, i32 0), i32 0, i64 0 } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.blocking_notifier_head* @rpc_pipefs_notifier_list to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.blocking_notifier_head* @rpc_pipefs_notifier_list to i8*), i64 80) to %struct.list_head*) }, %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.5.1096, i32 0, i32 0), i32 0, i64 0 } }, %struct.notifier_block* null }, align 8
@.str.4.1095 = private unnamed_addr constant [43 x i8] c"(rpc_pipefs_notifier_list).rwsem.wait_lock\00", align 1
@.str.5.1096 = private unnamed_addr constant [33 x i8] c"(rpc_pipefs_notifier_list).rwsem\00", align 1
@__crc_rpc_pipefs_notifier_unregister = extern_weak global i8*, align 8
@__kstrtab_rpc_pipefs_notifier_register = internal constant [29 x i8] c"rpc_pipefs_notifier_register\00", section "__ksymtab_strings", align 1
@__crc_rpc_pipefs_notifier_register = extern_weak global i8*, align 8
@authfiles = internal constant [1 x %struct.rpc_filelist] [%struct.rpc_filelist { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.13.1103, i32 0, i32 0), %struct.file_operations* @rpc_info_operations, i16 -32512 }], align 16
@.str.12.1102 = private unnamed_addr constant [42 x i8] c"\014%s: %s failed to populate directory %s\0A\00", align 1
@__func__.rpc_populate = private unnamed_addr constant [13 x i8] c"rpc_populate\00", align 1
@.str.13.1103 = private unnamed_addr constant [5 x i8] c"info\00", align 1
@rpc_info_operations = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @seq_lseek, i64 (%struct.file*, i8*, i64, i64*)* @seq_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @rpc_info_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @rpc_info_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@rpc_show_info.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.14.1108 = private unnamed_addr constant [16 x i8] c"RPC server: %s\0A\00", align 1
@.str.16.1109 = private unnamed_addr constant [29 x i8] c"service: %s (%d) version %d\0A\00", align 1
@.str.17.1110 = private unnamed_addr constant [13 x i8] c"address: %s\0A\00", align 1
@.str.18.1111 = private unnamed_addr constant [14 x i8] c"protocol: %s\0A\00", align 1
@.str.19.1112 = private unnamed_addr constant [10 x i8] c"port: %s\0A\00", align 1
@cache_pipefs_files = internal constant [3 x %struct.rpc_filelist] [%struct.rpc_filelist { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23.1117, i32 0, i32 0), %struct.file_operations* @cache_file_operations_pipefs, i16 -32384 }, %struct.rpc_filelist { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.24.1118, i32 0, i32 0), %struct.file_operations* @content_file_operations_pipefs, i16 -32512 }, %struct.rpc_filelist { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.25.1119, i32 0, i32 0), %struct.file_operations* @cache_flush_operations_pipefs, i16 -32384 }], align 16
@.str.23.1117 = private unnamed_addr constant [8 x i8] c"channel\00", align 1
@.str.24.1118 = private unnamed_addr constant [8 x i8] c"content\00", align 1
@.str.25.1119 = private unnamed_addr constant [6 x i8] c"flush\00", align 1
@.str.2.1124 = private unnamed_addr constant [20 x i8] c"&sn->pipefs_sb_lock\00", align 1
@rpc_pipefs_init_net.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.3.1127 = private unnamed_addr constant [16 x i8] c"rpc_inode_cache\00", align 1
@rpc_inode_cachep = internal global %struct.kmem_cache* null, section ".data..read_mostly", align 8
@rpc_pipe_fs_type = internal global %struct.file_system_type { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.28.1128, i32 0, i32 0), i32 0, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)* @rpc_mount, void (%struct.super_block*)* @rpc_kill_sb, %struct.module* @__this_module, %struct.file_system_type* null, %struct.hlist_head zeroinitializer, %struct.lock_class_key zeroinitializer, %struct.lock_class_key zeroinitializer, %struct.lock_class_key zeroinitializer, [3 x %struct.lock_class_key] zeroinitializer, %struct.lock_class_key zeroinitializer, %struct.lock_class_key zeroinitializer, %struct.lock_class_key zeroinitializer }, align 8
@.str.28.1128 = private unnamed_addr constant [11 x i8] c"rpc_pipefs\00", align 1
@.str.30.1129 = private unnamed_addr constant [12 x i8] c" (init_net)\00", align 1
@.str.31.1130 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.40.1131 = private unnamed_addr constant [62 x i8] c"\01dRPC:       sending pipefs UMOUNT notification for net %p%s\0A\00", align 1
@s_ops = internal constant %struct.super_operations { %struct.inode* (%struct.super_block*)* @rpc_alloc_inode, void (%struct.inode*)* @rpc_destroy_inode, void (%struct.inode*, i32)* null, i32 (%struct.inode*, %struct.writeback_control*)* null, i32 (%struct.inode*)* null, void (%struct.inode*)* null, void (%struct.super_block*)* null, i32 (%struct.super_block*, i32)* null, i32 (%struct.super_block*)* null, i32 (%struct.super_block*)* null, i32 (%struct.dentry*, %struct.kstatfs*)* @simple_statfs, i32 (%struct.super_block*, i32*, i8*)* null, void (%struct.super_block*)* null, i32 (%struct.seq_file*, %struct.dentry*)* null, i32 (%struct.seq_file*, %struct.dentry*)* null, i32 (%struct.seq_file*, %struct.dentry*)* null, i32 (%struct.seq_file*, %struct.dentry*)* null, i64 (%struct.super_block*, i32, i8*, i64, i64)* null, i64 (%struct.super_block*, i32, i8*, i64, i64)* null, i32 (%struct.super_block*, %struct.page*, i32)* null, i32 (%struct.super_block*)* null, void (%struct.super_block*, i32)* null }, align 8
@files = internal constant [8 x %struct.rpc_filelist] [%struct.rpc_filelist { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.32.1137, i32 0, i32 0), %struct.file_operations* null, i16 16749 }, %struct.rpc_filelist { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.33.1138, i32 0, i32 0), %struct.file_operations* null, i16 16749 }, %struct.rpc_filelist { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.34.1139, i32 0, i32 0), %struct.file_operations* null, i16 16749 }, %struct.rpc_filelist { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.35.1140, i32 0, i32 0), %struct.file_operations* null, i16 16749 }, %struct.rpc_filelist { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.36.1141, i32 0, i32 0), %struct.file_operations* null, i16 16749 }, %struct.rpc_filelist { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.37.1142, i32 0, i32 0), %struct.file_operations* null, i16 16749 }, %struct.rpc_filelist { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.38.1143, i32 0, i32 0), %struct.file_operations* null, i16 16749 }, %struct.rpc_filelist { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.39.1144, i32 0, i32 0), %struct.file_operations* null, i16 16749 }], align 16
@.str.29.1134 = private unnamed_addr constant [61 x i8] c"\01dRPC:       sending pipefs MOUNT notification for net %p%s\0A\00", align 1
@.str.32.1137 = private unnamed_addr constant [6 x i8] c"lockd\00", align 1
@.str.33.1138 = private unnamed_addr constant [6 x i8] c"mount\00", align 1
@.str.34.1139 = private unnamed_addr constant [4 x i8] c"nfs\00", align 1
@.str.35.1140 = private unnamed_addr constant [8 x i8] c"portmap\00", align 1
@.str.36.1141 = private unnamed_addr constant [6 x i8] c"statd\00", align 1
@.str.37.1142 = private unnamed_addr constant [9 x i8] c"nfsd4_cb\00", align 1
@.str.38.1143 = private unnamed_addr constant [6 x i8] c"cache\00", align 1
@.str.39.1144 = private unnamed_addr constant [5 x i8] c"nfsd\00", align 1
@.str.27.1145 = private unnamed_addr constant [13 x i8] c"&rpci->waitq\00", align 1
@init_once.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@__kcrctab_svc_reg_xprt_class = internal constant i64 ptrtoint (i8** @__crc_svc_reg_xprt_class to i64), section "___kcrctab_gpl+svc_reg_xprt_class", align 8
@__ksymtab_svc_reg_xprt_class = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.svc_xprt_class*)* @svc_reg_xprt_class to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_svc_reg_xprt_class, i32 0, i32 0) }, section "___ksymtab_gpl+svc_reg_xprt_class", align 8
@__kcrctab_svc_unreg_xprt_class = internal constant i64 ptrtoint (i8** @__crc_svc_unreg_xprt_class to i64), section "___kcrctab_gpl+svc_unreg_xprt_class", align 8
@__ksymtab_svc_unreg_xprt_class = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.svc_xprt_class*)* @svc_unreg_xprt_class to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_svc_unreg_xprt_class, i32 0, i32 0) }, section "___ksymtab_gpl+svc_unreg_xprt_class", align 8
@__kcrctab_svc_xprt_put = internal constant i64 ptrtoint (i8** @__crc_svc_xprt_put to i64), section "___kcrctab_gpl+svc_xprt_put", align 8
@__ksymtab_svc_xprt_put = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.svc_xprt*)* @svc_xprt_put to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_svc_xprt_put, i32 0, i32 0) }, section "___ksymtab_gpl+svc_xprt_put", align 8
@__kcrctab_svc_xprt_init = internal constant i64 ptrtoint (i8** @__crc_svc_xprt_init to i64), section "___kcrctab_gpl+svc_xprt_init", align 8
@__ksymtab_svc_xprt_init = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.net*, %struct.svc_xprt_class*, %struct.svc_xprt*, %struct.svc_serv*)* @svc_xprt_init to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_svc_xprt_init, i32 0, i32 0) }, section "___ksymtab_gpl+svc_xprt_init", align 8
@__kcrctab_svc_create_xprt = internal constant i64 ptrtoint (i8** @__crc_svc_create_xprt to i64), section "___kcrctab_gpl+svc_create_xprt", align 8
@__ksymtab_svc_create_xprt = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.svc_serv*, i8*, %struct.net*, i32, i16, i32)* @svc_create_xprt to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_svc_create_xprt, i32 0, i32 0) }, section "___ksymtab_gpl+svc_create_xprt", align 8
@__kcrctab_svc_xprt_copy_addrs = internal constant i64 ptrtoint (i8** @__crc_svc_xprt_copy_addrs to i64), section "___kcrctab_gpl+svc_xprt_copy_addrs", align 8
@__ksymtab_svc_xprt_copy_addrs = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.svc_rqst*, %struct.svc_xprt*)* @svc_xprt_copy_addrs to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_svc_xprt_copy_addrs, i32 0, i32 0) }, section "___ksymtab_gpl+svc_xprt_copy_addrs", align 8
@__kcrctab_svc_print_addr = internal constant i64 ptrtoint (i8** @__crc_svc_print_addr to i64), section "___kcrctab_gpl+svc_print_addr", align 8
@__ksymtab_svc_print_addr = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (%struct.svc_rqst*, i8*, i64)* @svc_print_addr to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_svc_print_addr, i32 0, i32 0) }, section "___ksymtab_gpl+svc_print_addr", align 8
@__kcrctab_svc_xprt_enqueue = internal constant i64 ptrtoint (i8** @__crc_svc_xprt_enqueue to i64), section "___kcrctab_gpl+svc_xprt_enqueue", align 8
@__ksymtab_svc_xprt_enqueue = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.svc_xprt*)* @svc_xprt_enqueue to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_svc_xprt_enqueue, i32 0, i32 0) }, section "___ksymtab_gpl+svc_xprt_enqueue", align 8
@__kcrctab_svc_reserve = internal constant i64 ptrtoint (i8** @__crc_svc_reserve to i64), section "___kcrctab_gpl+svc_reserve", align 8
@__ksymtab_svc_reserve = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.svc_rqst*, i32)* @svc_reserve to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_svc_reserve, i32 0, i32 0) }, section "___ksymtab_gpl+svc_reserve", align 8
@__kcrctab_svc_wake_up = internal constant i64 ptrtoint (i8** @__crc_svc_wake_up to i64), section "___kcrctab_gpl+svc_wake_up", align 8
@__ksymtab_svc_wake_up = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.svc_serv*)* @svc_wake_up to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_svc_wake_up, i32 0, i32 0) }, section "___ksymtab_gpl+svc_wake_up", align 8
@__kcrctab_svc_recv = internal constant i64 ptrtoint (i8** @__crc_svc_recv to i64), section "___kcrctab_gpl+svc_recv", align 8
@__ksymtab_svc_recv = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.svc_rqst*, i64)* @svc_recv to i64), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__kstrtab_svc_recv, i32 0, i32 0) }, section "___ksymtab_gpl+svc_recv", align 8
@__kcrctab_svc_drop = internal constant i64 ptrtoint (i8** @__crc_svc_drop to i64), section "___kcrctab_gpl+svc_drop", align 8
@__ksymtab_svc_drop = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.svc_rqst*)* @svc_drop to i64), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__kstrtab_svc_drop, i32 0, i32 0) }, section "___ksymtab_gpl+svc_drop", align 8
@__kcrctab_svc_close_xprt = internal constant i64 ptrtoint (i8** @__crc_svc_close_xprt to i64), section "___kcrctab_gpl+svc_close_xprt", align 8
@__ksymtab_svc_close_xprt = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.svc_xprt*)* @svc_close_xprt to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_svc_close_xprt, i32 0, i32 0) }, section "___ksymtab_gpl+svc_close_xprt", align 8
@__kcrctab_svc_find_xprt = internal constant i64 ptrtoint (i8** @__crc_svc_find_xprt to i64), section "___kcrctab_gpl+svc_find_xprt", align 8
@__ksymtab_svc_find_xprt = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.svc_xprt* (%struct.svc_serv*, i8*, %struct.net*, i16, i16)* @svc_find_xprt to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_svc_find_xprt, i32 0, i32 0) }, section "___ksymtab_gpl+svc_find_xprt", align 8
@__kcrctab_svc_xprt_names = internal constant i64 ptrtoint (i8** @__crc_svc_xprt_names to i64), section "___kcrctab_gpl+svc_xprt_names", align 8
@__ksymtab_svc_xprt_names = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.svc_serv*, i8*, i32)* @svc_xprt_names to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_svc_xprt_names, i32 0, i32 0) }, section "___ksymtab_gpl+svc_xprt_names", align 8
@__kcrctab_svc_pool_stats_open = internal constant i64 ptrtoint (i8** @__crc_svc_pool_stats_open to i64), section "___kcrctab+svc_pool_stats_open", align 8
@__ksymtab_svc_pool_stats_open = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.svc_serv*, %struct.file*)* @svc_pool_stats_open to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_svc_pool_stats_open, i32 0, i32 0) }, section "___ksymtab+svc_pool_stats_open", align 8
@__kstrtab_svc_pool_stats_open = internal constant [20 x i8] c"svc_pool_stats_open\00", section "__ksymtab_strings", align 1
@svc_pool_stats_seq_ops = internal constant %struct.seq_operations { i8* (%struct.seq_file*, i64*)* @svc_pool_stats_start, void (%struct.seq_file*, i8*)* @svc_pool_stats_stop, i8* (%struct.seq_file*, i8*, i64*)* @svc_pool_stats_next, i32 (%struct.seq_file*, i8*)* @svc_pool_stats_show }, align 8
@.str.45.1149 = private unnamed_addr constant [72 x i8] c"# pool packets-arrived sockets-enqueued threads-woken threads-timedout\0A\00", align 1
@.str.46.1150 = private unnamed_addr constant [20 x i8] c"%u %lu %lu %lu %lu\0A\00", align 1
@.str.44.1151 = private unnamed_addr constant [34 x i8] c"\01dsvc_pool_stats_next, *pos=%llu\0A\00", align 1
@.str.43.1152 = private unnamed_addr constant [34 x i8] c"\01dsvc_pool_stats_start, *pidx=%u\0A\00", align 1
@__crc_svc_pool_stats_open = extern_weak global i8*, align 8
@__kstrtab_svc_xprt_names = internal constant [15 x i8] c"svc_xprt_names\00", section "__ksymtab_strings", align 1
@.str.42.1155 = private unnamed_addr constant [7 x i8] c"%s %u\0A\00", align 1
@__crc_svc_xprt_names = extern_weak global i8*, align 8
@__kstrtab_svc_find_xprt = internal constant [14 x i8] c"svc_find_xprt\00", section "__ksymtab_strings", align 1
@kref_get.__warned.1159 = internal global i8 0, section ".data.unlikely", align 1
@.str.23.1160 = private unnamed_addr constant [21 x i8] c"include/linux/kref.h\00", align 1
@__crc_svc_find_xprt = extern_weak global i8*, align 8
@__kstrtab_svc_close_xprt = internal constant [15 x i8] c"svc_close_xprt\00", section "__ksymtab_strings", align 1
@.str.15.1165 = private unnamed_addr constant [22 x i8] c"net/sunrpc/svc_xprt.c\00", align 1
@.str.39.1166 = private unnamed_addr constant [28 x i8] c"\01dsvc: svc_delete_xprt(%p)\0A\00", align 1
@svc_delete_xprt.__warned = internal global i8 0, section ".data.unlikely", align 1
@__crc_svc_close_xprt = extern_weak global i8*, align 8
@__kstrtab_svc_drop = internal constant [9 x i8] c"svc_drop\00", section "__ksymtab_strings", align 1
@.str.21.1181 = private unnamed_addr constant [32 x i8] c"\01dsvc: xprt %p dropped request\0A\00", align 1
@.str.35.1182 = private unnamed_addr constant [39 x i8] c"\013RPC request reserved %d but used %d\0A\00", align 1
@cpu_number = external global i32, align 4
@.str.9.1188 = private unnamed_addr constant [59 x i8] c"\013svc_xprt_enqueue: threads and transports both waiting??\0A\00", align 1
@.str.10.1189 = private unnamed_addr constant [40 x i8] c"\01dsvc: transport %p busy, not enqueued\0A\00", align 1
@.str.11.1190 = private unnamed_addr constant [41 x i8] c"\01dsvc: transport %p served by daemon %p\0A\00", align 1
@.str.12.1191 = private unnamed_addr constant [44 x i8] c"\013svc_xprt_enqueue: server %p, rq_xprt=%p!\0A\00", align 1
@.str.13.1192 = private unnamed_addr constant [36 x i8] c"\01dsvc: transport %p put into queue\0A\00", align 1
@__crc_svc_drop = extern_weak global i8*, align 8
@__kstrtab_svc_recv = internal constant [9 x i8] c"svc_recv\00", section "__ksymtab_strings", align 1
@.str.18.1194 = private unnamed_addr constant [46 x i8] c"\01dsvc: server %p waiting for data (to = %ld)\0A\00", align 1
@.str.19.1195 = private unnamed_addr constant [45 x i8] c"\013svc_recv: service %p, transport not NULL!\0A\00", align 1
@.str.20.1197 = private unnamed_addr constant [44 x i8] c"\013svc_recv: service %p, wait queue active!\0A\00", align 1
@.str.40.1207 = private unnamed_addr constant [20 x i8] c"\01drevisit canceled\0A\00", align 1
@.str.41.1208 = private unnamed_addr constant [18 x i8] c"\01drevisit queued\0A\00", align 1
@.str.29.1210 = private unnamed_addr constant [29 x i8] c"\01dsvc_recv: found XPT_CLOSE\0A\00", align 1
@.str.30.1212 = private unnamed_addr constant [51 x i8] c"\01dsvc: server %p, pool %u, transport %p, inuse=%d\0A\00", align 1
@.str.31.1213 = private unnamed_addr constant [19 x i8] c"\01dsvc: got len=%d\0A\00", align 1
@svc_xprt_received.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.17.1214 = private unnamed_addr constant [24 x i8] c"((&serv->sv_temptimer))\00", align 1
@svc_add_new_temp_xprt.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@svc_conn_age_period = internal global i32 360, align 4
@.str.36.1215 = private unnamed_addr constant [22 x i8] c"\01dsvc_age_temp_xprts\0A\00", align 1
@.str.37.1216 = private unnamed_addr constant [28 x i8] c"\01dsvc_age_temp_xprts: busy\0A\00", align 1
@.str.38.1217 = private unnamed_addr constant [31 x i8] c"\01dqueuing xprt %p for closing\0A\00", align 1
@.str.33.1218 = private unnamed_addr constant [26 x i8] c"max number of connections\00", align 1
@.str.34.1219 = private unnamed_addr constant [18 x i8] c"number of threads\00", align 1
@.str.32.1220 = private unnamed_addr constant [61 x i8] c"\015%s: too many open connections, consider increasing the %s\0A\00", align 1
@.str.16.1222 = private unnamed_addr constant [31 x i8] c"\01dsvc: server %p, no data yet\0A\00", align 1
@.str.27.1223 = private unnamed_addr constant [40 x i8] c"\01dsvc: transport %p dequeued, inuse=%d\0A\00", align 1
@.str.28.1227 = private unnamed_addr constant [24 x i8] c"include/linux/freezer.h\00", align 1
@svc_alloc_arg.__warned = internal global i8 0, section ".data.unlikely", align 1
@__crc_svc_recv = extern_weak global i8*, align 8
@__kstrtab_svc_wake_up = internal constant [12 x i8] c"svc_wake_up\00", section "__ksymtab_strings", align 1
@.str.14.1231 = private unnamed_addr constant [28 x i8] c"\01dsvc: daemon %p woken up.\0A\00", align 1
@__crc_svc_wake_up = extern_weak global i8*, align 8
@__kstrtab_svc_reserve = internal constant [12 x i8] c"svc_reserve\00", section "__ksymtab_strings", align 1
@__crc_svc_reserve = extern_weak global i8*, align 8
@__kstrtab_svc_xprt_enqueue = internal constant [17 x i8] c"svc_xprt_enqueue\00", section "__ksymtab_strings", align 1
@__crc_svc_xprt_enqueue = extern_weak global i8*, align 8
@__kstrtab_svc_print_addr = internal constant [15 x i8] c"svc_print_addr\00", section "__ksymtab_strings", align 1
@.str.24.1235 = private unnamed_addr constant [14 x i8] c"%pI4, port=%u\00", align 1
@.str.25.1236 = private unnamed_addr constant [14 x i8] c"%pI6, port=%u\00", align 1
@.str.26.1237 = private unnamed_addr constant [25 x i8] c"unknown address type: %d\00", align 1
@__crc_svc_print_addr = extern_weak global i8*, align 8
@__kstrtab_svc_xprt_copy_addrs = internal constant [20 x i8] c"svc_xprt_copy_addrs\00", section "__ksymtab_strings", align 1
@__crc_svc_xprt_copy_addrs = extern_weak global i8*, align 8
@__kstrtab_svc_create_xprt = internal constant [16 x i8] c"svc_create_xprt\00", section "__ksymtab_strings", align 1
@.str.7.1240 = private unnamed_addr constant [34 x i8] c"\01dsvc: creating transport %s[%d]\0A\00", align 1
@svc_xprt_class_lock = internal global %struct.spinlock { %union.anon.11 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.22.1244, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@svc_xprt_class_list = internal global %struct.list_head { %struct.list_head* @svc_xprt_class_list, %struct.list_head* @svc_xprt_class_list }, align 8
@.str.8.1243 = private unnamed_addr constant [31 x i8] c"\01dsvc: transport %s not found\0A\00", align 1
@.str.22.1244 = private unnamed_addr constant [20 x i8] c"svc_xprt_class_lock\00", align 1
@__crc_svc_create_xprt = extern_weak global i8*, align 8
@__kstrtab_svc_xprt_init = internal constant [14 x i8] c"svc_xprt_init\00", section "__ksymtab_strings", align 1
@.str.3.1248 = private unnamed_addr constant [17 x i8] c"&xprt->xpt_mutex\00", align 1
@svc_xprt_init.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.5.1250 = private unnamed_addr constant [26 x i8] c"&(&xprt->xpt_lock)->rlock\00", align 1
@svc_xprt_init.__key.4 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.6.1251 = private unnamed_addr constant [15 x i8] c"xpt_bc_pending\00", align 1
@__crc_svc_xprt_init = extern_weak global i8*, align 8
@__kstrtab_svc_xprt_put = internal constant [13 x i8] c"svc_xprt_put\00", section "__ksymtab_strings", align 1
@__crc_svc_xprt_put = extern_weak global i8*, align 8
@__kstrtab_svc_unreg_xprt_class = internal constant [21 x i8] c"svc_unreg_xprt_class\00", section "__ksymtab_strings", align 1
@.str.1.1257 = private unnamed_addr constant [42 x i8] c"\01dsvc: Removing svc transport class '%s'\0A\00", align 1
@__crc_svc_unreg_xprt_class = extern_weak global i8*, align 8
@__kstrtab_svc_reg_xprt_class = internal constant [19 x i8] c"svc_reg_xprt_class\00", section "__ksymtab_strings", align 1
@.str.1260 = private unnamed_addr constant [40 x i8] c"\01dsvc: Adding svc transport class '%s'\0A\00", align 1
@__crc_svc_reg_xprt_class = extern_weak global i8*, align 8
@.str.2.1261 = private unnamed_addr constant [7 x i8] c"%s %d\0A\00", align 1
@__kcrctab_xprt_setup_backchannel = internal constant i64 ptrtoint (i8** @__crc_xprt_setup_backchannel to i64), section "___kcrctab_gpl+xprt_setup_backchannel", align 8
@__ksymtab_xprt_setup_backchannel = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rpc_xprt*, i32)* @xprt_setup_backchannel to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_xprt_setup_backchannel, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_setup_backchannel", align 8
@__kcrctab_xprt_destroy_backchannel = internal constant i64 ptrtoint (i8** @__crc_xprt_destroy_backchannel to i64), section "___kcrctab_gpl+xprt_destroy_backchannel", align 8
@__ksymtab_xprt_destroy_backchannel = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_xprt*, i32)* @xprt_destroy_backchannel to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_xprt_destroy_backchannel, i32 0, i32 0) }, section "___ksymtab_gpl+xprt_destroy_backchannel", align 8
@__kstrtab_xprt_destroy_backchannel = internal constant [25 x i8] c"xprt_destroy_backchannel\00", section "__ksymtab_strings", align 1
@.str.7.1267 = private unnamed_addr constant [45 x i8] c"\01dRPC:        destroy backchannel transport\0A\00", align 1
@.str.8.1269 = private unnamed_addr constant [22 x i8] c"\01dRPC:        req=%p\0A\00", align 1
@.str.10.1272 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@.str.11.1273 = private unnamed_addr constant [6 x i8] c"false\00", align 1
@.str.9.1274 = private unnamed_addr constant [42 x i8] c"\01dRPC:        backchannel list empty= %s\0A\00", align 1
@.str.17.1275 = private unnamed_addr constant [44 x i8] c"\01dRPC:        free allocations for req= %p\0A\00", align 1
@xprt_free_allocation.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.15.1277 = private unnamed_addr constant [30 x i8] c"net/sunrpc/backchannel_rqst.c\00", align 1
@__crc_xprt_destroy_backchannel = extern_weak global i8*, align 8
@__kstrtab_xprt_setup_backchannel = internal constant [23 x i8] c"xprt_setup_backchannel\00", section "__ksymtab_strings", align 1
@.str.1278 = private unnamed_addr constant [42 x i8] c"\01dRPC:       setup backchannel transport\0A\00", align 1
@.str.1.1281 = private unnamed_addr constant [32 x i8] c"\013Failed to create bc rpc_rqst\0A\00", align 1
@.str.2.1282 = private unnamed_addr constant [29 x i8] c"\01dRPC:       adding req= %p\0A\00", align 1
@.str.3.1285 = private unnamed_addr constant [36 x i8] c"\013Failed to create bc receive xbuf\0A\00", align 1
@.str.4.1287 = private unnamed_addr constant [32 x i8] c"\013Failed to create bc snd xbuf\0A\00", align 1
@.str.5.1288 = private unnamed_addr constant [47 x i8] c"\01dRPC:       setup backchannel transport done\0A\00", align 1
@.str.6.1289 = private unnamed_addr constant [49 x i8] c"\01dRPC:       setup backchannel transport failed\0A\00", align 1
@__crc_xprt_setup_backchannel = extern_weak global i8*, align 8
@.str.12.1294 = private unnamed_addr constant [45 x i8] c"\01dRPC:       allocate a backchannel request\0A\00", align 1
@.str.13.1298 = private unnamed_addr constant [33 x i8] c"\01dRPC:       backchannel req=%p\0A\00", align 1
@.str.14.1301 = private unnamed_addr constant [38 x i8] c"\01dRPC:       free backchannel req=%p\0A\00", align 1
@xprt_free_bc_request.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.16.1303 = private unnamed_addr constant [42 x i8] c"\01dRPC:       Last session removed req=%p\0A\00", align 1
@.str.1306 = private unnamed_addr constant [30 x i8] c"\01dRPC:       bc_send req= %p\0A\00", align 1
@nfs41_callback_ops = internal constant %struct.rpc_call_ops zeroinitializer, align 8
@bc_send.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.1.1310 = private unnamed_addr constant [20 x i8] c"net/sunrpc/bc_svc.c\00", align 1
@.str.2.1311 = private unnamed_addr constant [30 x i8] c"\01dRPC:       bc_send ret= %d\0A\00", align 1
@__kcrctab_svc_seq_show = internal constant i64 ptrtoint (i8** @__crc_svc_seq_show to i64), section "___kcrctab_gpl+svc_seq_show", align 8
@__ksymtab_svc_seq_show = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.seq_file*, %struct.svc_stat*)* @svc_seq_show to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_svc_seq_show, i32 0, i32 0) }, section "___ksymtab_gpl+svc_seq_show", align 8
@__kcrctab_rpc_alloc_iostats = internal constant i64 ptrtoint (i8** @__crc_rpc_alloc_iostats to i64), section "___kcrctab_gpl+rpc_alloc_iostats", align 8
@__ksymtab_rpc_alloc_iostats = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rpc_iostats* (%struct.rpc_clnt*)* @rpc_alloc_iostats to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_rpc_alloc_iostats, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_alloc_iostats", align 8
@__kcrctab_rpc_free_iostats = internal constant i64 ptrtoint (i8** @__crc_rpc_free_iostats to i64), section "___kcrctab_gpl+rpc_free_iostats", align 8
@__ksymtab_rpc_free_iostats = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_iostats*)* @rpc_free_iostats to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_rpc_free_iostats, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_free_iostats", align 8
@__kcrctab_rpc_count_iostats = internal constant i64 ptrtoint (i8** @__crc_rpc_count_iostats to i64), section "___kcrctab_gpl+rpc_count_iostats", align 8
@__ksymtab_rpc_count_iostats = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rpc_task*, %struct.rpc_iostats*)* @rpc_count_iostats to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_rpc_count_iostats, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_count_iostats", align 8
@__kcrctab_rpc_print_iostats = internal constant i64 ptrtoint (i8** @__crc_rpc_print_iostats to i64), section "___kcrctab_gpl+rpc_print_iostats", align 8
@__ksymtab_rpc_print_iostats = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.seq_file*, %struct.rpc_clnt*)* @rpc_print_iostats to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_rpc_print_iostats, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_print_iostats", align 8
@__kcrctab_rpc_proc_register = internal constant i64 ptrtoint (i8** @__crc_rpc_proc_register to i64), section "___kcrctab_gpl+rpc_proc_register", align 8
@__ksymtab_rpc_proc_register = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.proc_dir_entry* (%struct.net*, %struct.rpc_stat*)* @rpc_proc_register to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_rpc_proc_register, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_proc_register", align 8
@__kcrctab_rpc_proc_unregister = internal constant i64 ptrtoint (i8** @__crc_rpc_proc_unregister to i64), section "___kcrctab_gpl+rpc_proc_unregister", align 8
@__ksymtab_rpc_proc_unregister = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.net*, i8*)* @rpc_proc_unregister to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_rpc_proc_unregister, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_proc_unregister", align 8
@__kcrctab_svc_proc_register = internal constant i64 ptrtoint (i8** @__crc_svc_proc_register to i64), section "___kcrctab_gpl+svc_proc_register", align 8
@__ksymtab_svc_proc_register = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.proc_dir_entry* (%struct.net*, %struct.svc_stat*, %struct.file_operations*)* @svc_proc_register to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_svc_proc_register, i32 0, i32 0) }, section "___ksymtab_gpl+svc_proc_register", align 8
@__kcrctab_svc_proc_unregister = internal constant i64 ptrtoint (i8** @__crc_svc_proc_unregister to i64), section "___kcrctab_gpl+svc_proc_unregister", align 8
@__ksymtab_svc_proc_unregister = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.net*, i8*)* @svc_proc_unregister to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_svc_proc_unregister, i32 0, i32 0) }, section "___ksymtab_gpl+svc_proc_unregister", align 8
@__kstrtab_svc_proc_unregister = internal constant [20 x i8] c"svc_proc_unregister\00", section "__ksymtab_strings", align 1
@net_generic.__warned.1315 = internal global i8 0, section ".data.unlikely", align 1
@.str.23.1317 = private unnamed_addr constant [28 x i8] c"include/net/netns/generic.h\00", align 1
@.str.8.1318 = private unnamed_addr constant [41 x i8] c"suspicious rcu_dereference_check() usage\00", align 1
@rcu_read_unlock.__warned.1320 = internal global i8 0, section ".data.unlikely", align 1
@.str.14.1321 = private unnamed_addr constant [25 x i8] c"include/linux/rcupdate.h\00", align 1
@.str.16.1322 = private unnamed_addr constant [44 x i8] c"rcu_read_unlock() used illegally while idle\00", align 1
@rcu_read_lock.__warned.1328 = internal global i8 0, section ".data.unlikely", align 1
@.str.15.1329 = private unnamed_addr constant [42 x i8] c"rcu_read_lock() used illegally while idle\00", align 1
@__crc_svc_proc_unregister = extern_weak global i8*, align 8
@__kstrtab_svc_proc_register = internal constant [18 x i8] c"svc_proc_register\00", section "__ksymtab_strings", align 1
@.str.20.1330 = private unnamed_addr constant [43 x i8] c"\01dRPC:       registering /proc/net/rpc/%s\0A\00", align 1
@__crc_svc_proc_register = extern_weak global i8*, align 8
@__kstrtab_rpc_proc_unregister = internal constant [20 x i8] c"rpc_proc_unregister\00", section "__ksymtab_strings", align 1
@__crc_rpc_proc_unregister = extern_weak global i8*, align 8
@__kstrtab_rpc_proc_register = internal constant [18 x i8] c"rpc_proc_register\00", section "__ksymtab_strings", align 1
@rpc_proc_fops = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @seq_lseek, i64 (%struct.file*, i8*, i64, i64*)* @seq_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @rpc_proc_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @single_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@.str.1331 = private unnamed_addr constant [17 x i8] c"net %u %u %u %u\0A\00", align 1
@.str.21.1332 = private unnamed_addr constant [14 x i8] c"rpc %u %u %u\0A\00", align 1
@.str.22.1333 = private unnamed_addr constant [10 x i8] c"proc%u %u\00", align 1
@.str.3.1334 = private unnamed_addr constant [4 x i8] c" %u\00", align 1
@__crc_rpc_proc_register = extern_weak global i8*, align 8
@__kstrtab_rpc_print_iostats = internal constant [18 x i8] c"rpc_print_iostats\00", section "__ksymtab_strings", align 1
@.str.4.1335 = private unnamed_addr constant [27 x i8] c"\09RPC iostats version: %s  \00", align 1
@.str.5.1336 = private unnamed_addr constant [4 x i8] c"1.0\00", align 1
@.str.6.1337 = private unnamed_addr constant [17 x i8] c"p/v: %u/%u (%s)\0A\00", align 1
@rpc_print_iostats.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.7.1338 = private unnamed_addr constant [19 x i8] c"net/sunrpc/stats.c\00", align 1
@.str.9.1339 = private unnamed_addr constant [20 x i8] c"\09per-op statistics\0A\00", align 1
@.str.10.1340 = private unnamed_addr constant [33 x i8] c"%lu %lu %lu %Lu %Lu %Lu %Lu %Lu\0A\00", align 1
@.str.17.1341 = private unnamed_addr constant [8 x i8] c"\09%12s: \00", align 1
@.str.18.1342 = private unnamed_addr constant [16 x i8] c"\09        NULL: \00", align 1
@.str.19.1343 = private unnamed_addr constant [8 x i8] c"\09%12u: \00", align 1
@__crc_rpc_print_iostats = extern_weak global i8*, align 8
@__kstrtab_rpc_count_iostats = internal constant [18 x i8] c"rpc_count_iostats\00", section "__ksymtab_strings", align 1
@__crc_rpc_count_iostats = extern_weak global i8*, align 8
@__kstrtab_rpc_free_iostats = internal constant [17 x i8] c"rpc_free_iostats\00", section "__ksymtab_strings", align 1
@__crc_rpc_free_iostats = extern_weak global i8*, align 8
@__kstrtab_rpc_alloc_iostats = internal constant [18 x i8] c"rpc_alloc_iostats\00", section "__ksymtab_strings", align 1
@__crc_rpc_alloc_iostats = extern_weak global i8*, align 8
@__kstrtab_svc_seq_show = internal constant [13 x i8] c"svc_seq_show\00", section "__ksymtab_strings", align 1
@.str.1.1352 = private unnamed_addr constant [20 x i8] c"rpc %u %u %u %u %u\0A\00", align 1
@.str.2.1353 = private unnamed_addr constant [10 x i8] c"proc%d %u\00", align 1
@__crc_svc_seq_show = extern_weak global i8*, align 8
@.str.11.1356 = private unnamed_addr constant [40 x i8] c"\01dRPC:       registering /proc/net/rpc\0A\00", align 1
@.str.12.1357 = private unnamed_addr constant [4 x i8] c"rpc\00", align 1
@.str.13.1360 = private unnamed_addr constant [42 x i8] c"\01dRPC:       unregistering /proc/net/rpc\0A\00", align 1
@rpc_debug = common global i32 0, align 4
@nfs_debug = common global i32 0, align 4
@nfsd_debug = common global i32 0, align 4
@nlm_debug = common global i32 0, align 4
@__kcrctab_rpc_debug = internal constant i64 ptrtoint (i8** @__crc_rpc_debug to i64), section "___kcrctab_gpl+rpc_debug", align 8
@__ksymtab_rpc_debug = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* @rpc_debug to i64), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__kstrtab_rpc_debug, i32 0, i32 0) }, section "___ksymtab_gpl+rpc_debug", align 8
@__kcrctab_nfs_debug = internal constant i64 ptrtoint (i8** @__crc_nfs_debug to i64), section "___kcrctab_gpl+nfs_debug", align 8
@__ksymtab_nfs_debug = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* @nfs_debug to i64), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__kstrtab_nfs_debug, i32 0, i32 0) }, section "___ksymtab_gpl+nfs_debug", align 8
@__kcrctab_nfsd_debug = internal constant i64 ptrtoint (i8** @__crc_nfsd_debug to i64), section "___kcrctab_gpl+nfsd_debug", align 8
@__ksymtab_nfsd_debug = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* @nfsd_debug to i64), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__kstrtab_nfsd_debug, i32 0, i32 0) }, section "___ksymtab_gpl+nfsd_debug", align 8
@__kcrctab_nlm_debug = internal constant i64 ptrtoint (i8** @__crc_nlm_debug to i64), section "___kcrctab_gpl+nlm_debug", align 8
@__ksymtab_nlm_debug = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* @nlm_debug to i64), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__kstrtab_nlm_debug, i32 0, i32 0) }, section "___ksymtab_gpl+nlm_debug", align 8
@__kstrtab_nlm_debug = internal constant [10 x i8] c"nlm_debug\00", section "__ksymtab_strings", align 1
@__crc_nlm_debug = extern_weak global i8*, align 8
@__kstrtab_nfsd_debug = internal constant [11 x i8] c"nfsd_debug\00", section "__ksymtab_strings", align 1
@__crc_nfsd_debug = extern_weak global i8*, align 8
@__kstrtab_nfs_debug = internal constant [10 x i8] c"nfs_debug\00", section "__ksymtab_strings", align 1
@__crc_nfs_debug = extern_weak global i8*, align 8
@__kstrtab_rpc_debug = internal constant [10 x i8] c"rpc_debug\00", section "__ksymtab_strings", align 1
@__crc_rpc_debug = extern_weak global i8*, align 8
@sunrpc_table_header.1366 = internal global %struct.ctl_table_header* null, align 8
@sunrpc_table.1367 = internal global [2 x %struct.ctl_table] [%struct.ctl_table { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1368, i32 0, i32 0), i8* null, i32 0, i16 365, %struct.ctl_table* getelementptr inbounds ([6 x %struct.ctl_table], [6 x %struct.ctl_table]* @debug_table, i32 0, i32 0), i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)* null, %struct.ctl_table_poll* null, i8* null, i8* null }, %struct.ctl_table zeroinitializer], align 16
@.str.1368 = private unnamed_addr constant [7 x i8] c"sunrpc\00", align 1
@debug_table = internal global [6 x %struct.ctl_table] [%struct.ctl_table { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2.1369, i32 0, i32 0), i8* bitcast (i32* @rpc_debug to i8*), i32 4, i16 420, %struct.ctl_table* null, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)* @proc_dodebug, %struct.ctl_table_poll* null, i8* null, i8* null }, %struct.ctl_table { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.3.1370, i32 0, i32 0), i8* bitcast (i32* @nfs_debug to i8*), i32 4, i16 420, %struct.ctl_table* null, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)* @proc_dodebug, %struct.ctl_table_poll* null, i8* null, i8* null }, %struct.ctl_table { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.4.1371, i32 0, i32 0), i8* bitcast (i32* @nfsd_debug to i8*), i32 4, i16 420, %struct.ctl_table* null, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)* @proc_dodebug, %struct.ctl_table_poll* null, i8* null, i8* null }, %struct.ctl_table { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.5.1372, i32 0, i32 0), i8* bitcast (i32* @nlm_debug to i8*), i32 4, i16 420, %struct.ctl_table* null, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)* @proc_dodebug, %struct.ctl_table_poll* null, i8* null, i8* null }, %struct.ctl_table { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.6.1373, i32 0, i32 0), i8* null, i32 256, i16 292, %struct.ctl_table* null, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)* @proc_do_xprt, %struct.ctl_table_poll* null, i8* null, i8* null }, %struct.ctl_table zeroinitializer], align 16
@.str.2.1369 = private unnamed_addr constant [10 x i8] c"rpc_debug\00", align 1
@.str.3.1370 = private unnamed_addr constant [10 x i8] c"nfs_debug\00", align 1
@.str.4.1371 = private unnamed_addr constant [11 x i8] c"nfsd_debug\00", align 1
@.str.5.1372 = private unnamed_addr constant [10 x i8] c"nlm_debug\00", align 1
@.str.6.1373 = private unnamed_addr constant [11 x i8] c"transports\00", align 1
@_ctype = external constant [0 x i8], align 1
@.str.7.1376 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.8.1377 = private unnamed_addr constant [62 x i8] c"/diffkemp/kernel/linux-3.10/arch/x86/include/asm/uaccess_64.h\00", align 1
@.str.9.1378 = private unnamed_addr constant [27 x i8] c"Buffer overflow detected!\0A\00", align 1

@init_module = alias i32 (), i32 ()* @init_sunrpc
@cleanup_module = alias void (), void ()* @cleanup_sunrpc

; Function Attrs: nounwind uwtable
define %struct.rpc_task* @rpc_call_null(%struct.rpc_clnt* %clnt, %struct.rpc_cred* %cred, i32 %flags) #0 {
entry:
  %msg = alloca %struct.rpc_message, align 8
  %task_setup_data = alloca %struct.rpc_task_setup, align 8
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 0
  store %struct.rpc_procinfo* @rpcproc_null, %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !2
  %rpc_argp = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 1
  store i8* null, i8** %rpc_argp, align 8, !tbaa !7
  %rpc_resp = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 2
  store i8* null, i8** %rpc_resp, align 8, !tbaa !8
  %rpc_cred = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 3
  store %struct.rpc_cred* %cred, %struct.rpc_cred** %rpc_cred, align 8, !tbaa !9
  %task = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 0
  store %struct.rpc_task* null, %struct.rpc_task** %task, align 8, !tbaa !10
  %rpc_client = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 1
  store %struct.rpc_clnt* %clnt, %struct.rpc_clnt** %rpc_client, align 8, !tbaa !13
  %rpc_message = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 2
  store %struct.rpc_message* %msg, %struct.rpc_message** %rpc_message, align 8, !tbaa !14
  %callback_ops = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 3
  store %struct.rpc_call_ops* @rpc_default_ops, %struct.rpc_call_ops** %callback_ops, align 8, !tbaa !15
  %callback_data = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 4
  store i8* null, i8** %callback_data, align 8, !tbaa !16
  %workqueue = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 5
  store %struct.workqueue_struct* null, %struct.workqueue_struct** %workqueue, align 8, !tbaa !17
  %flags1 = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 6
  %conv = trunc i32 %flags to i16
  store i16 %conv, i16* %flags1, align 8, !tbaa !18
  %priority = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 7
  store i8 0, i8* %priority, align 2, !tbaa !19
  %call = call %struct.rpc_task* @rpc_run_task(%struct.rpc_task_setup* %task_setup_data)
  ret %struct.rpc_task* %call
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #1

; Function Attrs: nounwind uwtable
define %struct.rpc_task* @rpc_run_task(%struct.rpc_task_setup* %task_setup_data) #0 {
entry:
  %call = call %struct.rpc_task* @rpc_new_task(%struct.rpc_task_setup* %task_setup_data)
  %0 = bitcast %struct.rpc_task* %call to i8*
  %call1 = call i64 @IS_ERR(i8* %0)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %out, label %if.end

if.end:                                           ; preds = %entry
  %rpc_client = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 1
  %1 = load %struct.rpc_clnt*, %struct.rpc_clnt** %rpc_client, align 8, !tbaa !13
  call void @rpc_task_set_client(%struct.rpc_task* %call, %struct.rpc_clnt* %1)
  %rpc_message = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 2
  %2 = load %struct.rpc_message*, %struct.rpc_message** %rpc_message, align 8, !tbaa !14
  call void @rpc_task_set_rpc_message(%struct.rpc_task* %call, %struct.rpc_message* %2)
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %call, i32 0, i32 6
  %3 = load void (%struct.rpc_task*)*, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  %cmp = icmp eq void (%struct.rpc_task*)* %3, null
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  call void @rpc_call_start(%struct.rpc_task* %call)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %tk_count = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %call, i32 0, i32 0
  call void @atomic_inc(%struct.atomic_t* %tk_count)
  call void @rpc_execute(%struct.rpc_task* %call)
  br label %out

out:                                              ; preds = %if.end3, %entry
  ret %struct.rpc_task* %call
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: nounwind uwtable
define internal void @rpc_task_set_client(%struct.rpc_task* %task, %struct.rpc_clnt* %clnt) #0 {
entry:
  %cmp = icmp ne %struct.rpc_clnt* %clnt, null
  br i1 %cmp, label %if.then, label %if.end25

if.then:                                          ; preds = %entry
  call void @rpc_task_release_client(%struct.rpc_task* %task)
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  store %struct.rpc_clnt* %clnt, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %cl_count = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 0
  call void @atomic_inc(%struct.atomic_t* %cl_count)
  %cl_softrtry = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 13
  %bf.load = load i8, i8* %cl_softrtry, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %0 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv = zext i16 %0 to i32
  %or = or i32 %conv, 512
  %conv2 = trunc i32 %or to i16
  store i16 %conv2, i16* %tk_flags, align 8, !tbaa !27
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  %call = call i32 @sk_memalloc_socks()
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %if.then4, label %if.end23

if.then4:                                         ; preds = %if.end
  call void @rcu_read_lock()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 4
  %1 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call5 = call i32 @debug_lockdep_rcu_enabled()
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %land.lhs.true, label %do.end15

land.lhs.true:                                    ; preds = %if.then4
  %2 = load i8, i8* @rpc_task_set_client.__warned, align 1, !tbaa !29, !range !31
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %do.end15, label %land.lhs.true8

land.lhs.true8:                                   ; preds = %land.lhs.true
  %call9 = call i32 @rcu_read_lock_held()
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %do.end15, label %if.then11

if.then11:                                        ; preds = %land.lhs.true8
  store i8 1, i8* @rpc_task_set_client.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 753, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end15

do.end15:                                         ; preds = %if.then11, %land.lhs.true8, %land.lhs.true, %if.then4
  %swapper = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 20
  %3 = load i32, i32* %swapper, align 4, !tbaa !32
  %tobool16 = icmp ne i32 %3, 0
  br i1 %tobool16, label %if.then17, label %if.end22

if.then17:                                        ; preds = %do.end15
  %tk_flags18 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %4 = load i16, i16* %tk_flags18, align 8, !tbaa !27
  %conv19 = zext i16 %4 to i32
  %or20 = or i32 %conv19, 2
  %conv21 = trunc i32 %or20 to i16
  store i16 %conv21, i16* %tk_flags18, align 8, !tbaa !27
  br label %if.end22

if.end22:                                         ; preds = %if.then17, %do.end15
  call void @rcu_read_unlock()
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.end
  %cl_lock = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 3
  call void @spin_lock(%struct.spinlock* %cl_lock)
  %tk_task = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 1
  %cl_tasks = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 2
  call void @list_add_tail(%struct.list_head* %tk_task, %struct.list_head* %cl_tasks)
  %cl_lock24 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 3
  call void @spin_unlock(%struct.spinlock* %cl_lock24)
  br label %if.end25

if.end25:                                         ; preds = %if.end23, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_task_set_rpc_message(%struct.rpc_task* %task, %struct.rpc_message* %msg) #0 {
entry:
  %cmp = icmp ne %struct.rpc_message* %msg, null
  br i1 %cmp, label %if.then, label %if.end11

if.then:                                          ; preds = %entry
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 0
  %0 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !2
  %tk_msg = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_proc1 = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg, i32 0, i32 0
  store %struct.rpc_procinfo* %0, %struct.rpc_procinfo** %rpc_proc1, align 8, !tbaa !44
  %rpc_argp = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 1
  %1 = load i8*, i8** %rpc_argp, align 8, !tbaa !7
  %tk_msg2 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_argp3 = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg2, i32 0, i32 1
  store i8* %1, i8** %rpc_argp3, align 8, !tbaa !45
  %rpc_resp = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 2
  %2 = load i8*, i8** %rpc_resp, align 8, !tbaa !8
  %tk_msg4 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_resp5 = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg4, i32 0, i32 2
  store i8* %2, i8** %rpc_resp5, align 8, !tbaa !46
  %rpc_cred = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 3
  %3 = load %struct.rpc_cred*, %struct.rpc_cred** %rpc_cred, align 8, !tbaa !9
  %cmp6 = icmp ne %struct.rpc_cred* %3, null
  br i1 %cmp6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.then
  %rpc_cred8 = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 3
  %4 = load %struct.rpc_cred*, %struct.rpc_cred** %rpc_cred8, align 8, !tbaa !9
  %call = call %struct.rpc_cred* @get_rpccred(%struct.rpc_cred* %4)
  %tk_msg9 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_cred10 = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg9, i32 0, i32 3
  store %struct.rpc_cred* %call, %struct.rpc_cred** %rpc_cred10, align 8, !tbaa !47
  br label %if.end11

if.end11:                                         ; preds = %if.then7, %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_call_start(%struct.rpc_task* %task) #0 {
entry:
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_start, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !48
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @call_start(%struct.rpc_task* %task) #0 {
entry:
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %0 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  call void @rpc_proc_name(%struct.rpc_task* %task)
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tk_msg = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg, i32 0, i32 0
  %3 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !44
  %p_count = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %3, i32 0, i32 5
  %4 = load i32, i32* %p_count, align 8, !tbaa !50
  %inc = add i32 %4, 1
  store i32 %inc, i32* %p_count, align 8, !tbaa !50
  %cl_stats = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 11
  %5 = load %struct.rpc_stat*, %struct.rpc_stat** %cl_stats, align 8, !tbaa !52
  %rpccnt = getelementptr inbounds %struct.rpc_stat, %struct.rpc_stat* %5, i32 0, i32 6
  %6 = load i32, i32* %rpccnt, align 4, !tbaa !56
  %inc8 = add i32 %6, 1
  store i32 %inc8, i32* %rpccnt, align 4, !tbaa !56
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_reserve, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #3

; Function Attrs: nounwind uwtable
define internal void @rpc_proc_name(%struct.rpc_task* %task) #0 {
entry:
  %tk_msg = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg, i32 0, i32 0
  %0 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !44
  %tobool = icmp ne %struct.rpc_procinfo* %0, null
  br i1 %tobool, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  %p_name = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %0, i32 0, i32 8
  %1 = load i8*, i8** %p_name, align 8, !tbaa !58
  %tobool1 = icmp ne i8* %1, null
  br i1 %tobool1, label %if.then2, label %cleanup

if.then2:                                         ; preds = %if.then
  br label %cleanup

cleanup:                                          ; preds = %if.then2, %if.then, %entry
  ret void
}

declare i32 @printk(i8*, ...) #4

; Function Attrs: nounwind uwtable
define internal void @call_reserve(%struct.rpc_task* %task) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tk_status4 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status4, align 4, !tbaa !59
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_reserveresult, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  call void @xprt_reserve(%struct.rpc_task* %task)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @call_reserveresult(%struct.rpc_task* %task) #0 {
entry:
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %0 = load i32, i32* %tk_status, align 4, !tbaa !59
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tk_status5 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status5, align 4, !tbaa !59
  %cmp = icmp sge i32 %0, 0
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %3 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %tobool8 = icmp ne %struct.rpc_rqst* %3, null
  br i1 %cmp, label %if.then7, label %if.end12

if.then7:                                         ; preds = %do.end
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.then7
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_refresh, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  br label %cleanup.cont

if.end10:                                         ; preds = %if.then7
  %4 = call i32 (i8*, ...) @printk(i8* null)
  call void @rpc_exit(%struct.rpc_task* %task, i32 -5)
  br label %cleanup.cont

if.end12:                                         ; preds = %do.end
  br i1 %tobool8, label %if.then15, label %NodeBlock5

if.then15:                                        ; preds = %if.end12
  %5 = call i32 (i8*, ...) @printk(i8* null)
  call void @xprt_release(%struct.rpc_task* %task)
  br label %NodeBlock5

NodeBlock5:                                       ; preds = %if.then15, %if.end12
  %Pivot6 = icmp slt i32 %0, -11
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %0, -5
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %0, -5
  br i1 %SwitchLeaf4, label %sw.epilog, label %sw.default

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %0, -11
  br i1 %SwitchLeaf2, label %sw.bb18, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %0, -12
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  call void @rpc_delay(%struct.rpc_task* %task, i64 62)
  br label %sw.bb18

sw.bb18:                                          ; preds = %sw.bb, %LeafBlock1
  %tk_action19 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_retry_reserve, void (%struct.rpc_task*)** %tk_action19, align 8, !tbaa !20
  br label %cleanup.cont

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock3
  call void @rpc_exit(%struct.rpc_task* %task, i32 %0)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %sw.epilog, %sw.bb18, %if.end10, %if.then9
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @call_refresh(%struct.rpc_task* %task) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_refreshresult, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  %tk_status4 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status4, align 4, !tbaa !59
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %2 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %cl_stats = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %2, i32 0, i32 11
  %3 = load %struct.rpc_stat*, %struct.rpc_stat** %cl_stats, align 8, !tbaa !52
  %rpcauthrefresh = getelementptr inbounds %struct.rpc_stat, %struct.rpc_stat* %3, i32 0, i32 8
  %4 = load i32, i32* %rpcauthrefresh, align 4, !tbaa !61
  %inc = add i32 %4, 1
  store i32 %inc, i32* %rpcauthrefresh, align 4, !tbaa !61
  %call5 = call i32 @rpcauth_refreshcred(%struct.rpc_task* %task)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @call_retry_reserve(%struct.rpc_task* %task) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tk_status4 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status4, align 4, !tbaa !59
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_reserveresult, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  call void @xprt_retry_reserve(%struct.rpc_task* %task)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @call_refreshresult(%struct.rpc_task* %task) #0 {
entry:
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %0 = load i32, i32* %tk_status, align 4, !tbaa !59
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tk_status5 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status5, align 4, !tbaa !59
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_refresh, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  %Pivot10 = icmp slt i32 %0, -11
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %do.end
  %Pivot8 = icmp slt i32 %0, 0
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %0, 0
  br i1 %SwitchLeaf6, label %sw.bb, label %do.body39

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %0, -11
  br i1 %SwitchLeaf4, label %sw.bb12, label %do.body39

NodeBlock:                                        ; preds = %do.end
  %Pivot = icmp slt i32 %0, -110
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %0, -110
  br i1 %SwitchLeaf2, label %sw.bb11, label %do.body39

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %0, -127
  br i1 %SwitchLeaf, label %sw.bb12, label %do.body39

sw.bb:                                            ; preds = %LeafBlock5
  %call6 = call i32 @rpcauth_uptodatecred(%struct.rpc_task* %task)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %cleanup.cont

if.then8:                                         ; preds = %sw.bb
  %tk_action9 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_allocate, void (%struct.rpc_task*)** %tk_action9, align 8, !tbaa !20
  br label %cleanup.cont

sw.bb11:                                          ; preds = %LeafBlock1
  call void @rpc_delay(%struct.rpc_task* %task, i64 750)
  br label %sw.bb12

sw.bb12:                                          ; preds = %sw.bb11, %LeafBlock, %LeafBlock3
  %tk_cred_retry = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 20
  %bf.load = load i8, i8* %tk_cred_retry, align 2
  %bf.lshr = lshr i8 %bf.load, 4
  %bf.clear = and i8 %bf.lshr, 3
  %tobool13 = icmp ne i8 %bf.clear, 0
  br i1 %tobool13, label %if.end15, label %do.body39

if.end15:                                         ; preds = %sw.bb12
  %tk_cred_retry16 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 20
  %bf.load17 = load i8, i8* %tk_cred_retry16, align 2
  %bf.lshr18 = lshr i8 %bf.load17, 4
  %bf.clear19 = and i8 %bf.lshr18, 3
  %dec = add i8 %bf.clear19, -1
  %bf.load20 = load i8, i8* %tk_cred_retry16, align 2
  %bf.value = and i8 %dec, 3
  %bf.shl = shl i8 %bf.value, 4
  %bf.clear21 = and i8 %bf.load20, -49
  %bf.set = or i8 %bf.clear21, %bf.shl
  store i8 %bf.set, i8* %tk_cred_retry16, align 2
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and23 = and i32 %3, 2
  %tobool24 = icmp ne i32 %and23, 0
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot.ext28 = zext i1 %lnot27 to i32
  %conv29 = sext i32 %lnot.ext28 to i64
  %expval30 = call i64 @llvm.expect.i64(i64 %conv29, i64 0)
  %tobool31 = icmp ne i64 %expval30, 0
  br i1 %tobool31, label %if.then32, label %cleanup.cont

if.then32:                                        ; preds = %if.end15
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup.cont

do.body39:                                        ; preds = %sw.bb12, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  %status.0 = phi i32 [ -13, %sw.bb12 ], [ %0, %LeafBlock5 ], [ %0, %LeafBlock3 ], [ %0, %LeafBlock1 ], [ %0, %LeafBlock ]
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and40 = and i32 %5, 2
  %tobool41 = icmp ne i32 %and40, 0
  %lnot42 = xor i1 %tobool41, true
  %lnot44 = xor i1 %lnot42, true
  %lnot.ext45 = zext i1 %lnot44 to i32
  %conv46 = sext i32 %lnot.ext45 to i64
  %expval47 = call i64 @llvm.expect.i64(i64 %conv46, i64 0)
  %tobool48 = icmp ne i64 %expval47, 0
  br i1 %tobool48, label %if.then49, label %do.end55

if.then49:                                        ; preds = %do.body39
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end55

do.end55:                                         ; preds = %if.then49, %do.body39
  call void @rpc_exit(%struct.rpc_task* %task, i32 %status.0)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %do.end55, %if.then32, %if.end15, %if.then8, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @call_allocate(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_cred = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 4
  %1 = load %struct.rpc_cred*, %struct.rpc_cred** %rq_cred, align 8, !tbaa !62
  %cr_auth = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %1, i32 0, i32 3
  %2 = load %struct.rpc_auth*, %struct.rpc_auth** %cr_auth, align 8, !tbaa !65
  %au_cslack = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %2, i32 0, i32 0
  %3 = load i32, i32* %au_cslack, align 8, !tbaa !69
  %tk_rqstp1 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %4 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp1, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %4, i32 0, i32 0
  %5 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %tk_msg = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg, i32 0, i32 0
  %6 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !44
  %7 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %7, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %8 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tk_status5 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status5, align 4, !tbaa !59
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_bind, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  %rq_buffer = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %4, i32 0, i32 12
  %9 = load i32*, i32** %rq_buffer, align 8, !tbaa !72
  %tobool6 = icmp ne i32* %9, null
  br i1 %tobool6, label %cleanup.cont, label %if.end8

if.end8:                                          ; preds = %do.end
  %p_proc = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %6, i32 0, i32 0
  %10 = load i32, i32* %p_proc, align 8, !tbaa !73
  %cmp = icmp ne i32 %10, 0
  br i1 %cmp, label %do.body11, label %if.end55

do.body11:                                        ; preds = %if.end8
  %p_arglen = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %6, i32 0, i32 3
  %11 = load i32, i32* %p_arglen, align 8, !tbaa !74
  %cmp12 = icmp eq i32 %11, 0
  %lnot14 = xor i1 %cmp12, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  %expval19 = call i64 @llvm.expect.i64(i64 %conv18, i64 0)
  %tobool20 = icmp ne i64 %expval19, 0
  br i1 %tobool20, label %do.body22, label %do.end30

do.body22:                                        ; preds = %do.body11
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 1446, i64 12) #7, !srcloc !75
  br label %do.body23

do.body23:                                        ; preds = %do.body23, %do.body22
  br label %do.body23

do.end30:                                         ; preds = %do.body11
  %p_decode = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %6, i32 0, i32 2
  %12 = load i32 (i8*, %struct.xdr_stream*, i8*)*, i32 (i8*, %struct.xdr_stream*, i8*)** %p_decode, align 8, !tbaa !76
  %cmp31 = icmp ne i32 (i8*, %struct.xdr_stream*, i8*)* %12, null
  br i1 %cmp31, label %do.body34, label %if.end55

do.body34:                                        ; preds = %do.end30
  %p_replen = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %6, i32 0, i32 4
  %13 = load i32, i32* %p_replen, align 4, !tbaa !77
  %cmp35 = icmp eq i32 %13, 0
  %lnot37 = xor i1 %cmp35, true
  %lnot39 = xor i1 %lnot37, true
  %lnot.ext40 = zext i1 %lnot39 to i32
  %conv41 = sext i32 %lnot.ext40 to i64
  %expval42 = call i64 @llvm.expect.i64(i64 %conv41, i64 0)
  %tobool43 = icmp ne i64 %expval42, 0
  br i1 %tobool43, label %do.body45, label %if.end55

do.body45:                                        ; preds = %do.body34
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 1448, i64 12) #7, !srcloc !78
  br label %do.body46

do.body46:                                        ; preds = %do.body46, %do.body45
  br label %do.body46

if.end55:                                         ; preds = %do.body34, %do.end30, %if.end8
  %shl = shl i32 %3, 1
  %add = add i32 6, %shl
  %p_arglen56 = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %6, i32 0, i32 3
  %14 = load i32, i32* %p_arglen56, align 8, !tbaa !74
  %add57 = add i32 %add, %14
  %conv58 = zext i32 %add57 to i64
  %rq_callsize = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %4, i32 0, i32 13
  store i64 %conv58, i64* %rq_callsize, align 8, !tbaa !79
  %rq_callsize59 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %4, i32 0, i32 13
  %15 = load i64, i64* %rq_callsize59, align 8, !tbaa !79
  %shl60 = shl i64 %15, 2
  store i64 %shl60, i64* %rq_callsize59, align 8, !tbaa !79
  %add61 = add i32 4, %3
  %p_replen62 = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %6, i32 0, i32 4
  %16 = load i32, i32* %p_replen62, align 4, !tbaa !77
  %add63 = add i32 %add61, %16
  %conv64 = zext i32 %add63 to i64
  %rq_rcvsize = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %4, i32 0, i32 14
  store i64 %conv64, i64* %rq_rcvsize, align 8, !tbaa !80
  %rq_rcvsize65 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %4, i32 0, i32 14
  %17 = load i64, i64* %rq_rcvsize65, align 8, !tbaa !80
  %shl66 = shl i64 %17, 2
  store i64 %shl66, i64* %rq_rcvsize65, align 8, !tbaa !80
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %5, i32 0, i32 1
  %18 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %buf_alloc = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %18, i32 0, i32 7
  %19 = load i8* (%struct.rpc_task*, i64)*, i8* (%struct.rpc_task*, i64)** %buf_alloc, align 8, !tbaa !82
  %rq_callsize67 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %4, i32 0, i32 13
  %20 = load i64, i64* %rq_callsize67, align 8, !tbaa !79
  %rq_rcvsize68 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %4, i32 0, i32 14
  %21 = load i64, i64* %rq_rcvsize68, align 8, !tbaa !80
  %add69 = add i64 %20, %21
  %call70 = call i8* %19(%struct.rpc_task* %task, i64 %add69)
  %22 = bitcast i8* %call70 to i32*
  %rq_buffer71 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %4, i32 0, i32 12
  store i32* %22, i32** %rq_buffer71, align 8, !tbaa !72
  %rq_buffer72 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %4, i32 0, i32 12
  %23 = load i32*, i32** %rq_buffer72, align 8, !tbaa !72
  %cmp73 = icmp ne i32* %23, null
  br i1 %cmp73, label %cleanup.cont, label %do.body77

do.body77:                                        ; preds = %if.end55
  %24 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and78 = and i32 %24, 2
  %tobool79 = icmp ne i32 %and78, 0
  %lnot80 = xor i1 %tobool79, true
  %lnot82 = xor i1 %lnot80, true
  %lnot.ext83 = zext i1 %lnot82 to i32
  %conv84 = sext i32 %lnot.ext83 to i64
  %expval85 = call i64 @llvm.expect.i64(i64 %conv84, i64 0)
  %tobool86 = icmp ne i64 %expval85, 0
  br i1 %tobool86, label %if.then87, label %do.end93

if.then87:                                        ; preds = %do.body77
  %25 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end93

do.end93:                                         ; preds = %if.then87, %do.body77
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %26 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv94 = zext i16 %26 to i32
  %and95 = and i32 %conv94, 1
  %tobool96 = icmp ne i32 %and95, 0
  br i1 %tobool96, label %if.then100, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end93
  %27 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !84
  %call98 = call i32 @fatal_signal_pending(%struct.task_struct* %27)
  %tobool99 = icmp ne i32 %call98, 0
  br i1 %tobool99, label %if.end102, label %if.then100

if.then100:                                       ; preds = %lor.lhs.false, %do.end93
  %tk_action101 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_allocate, void (%struct.rpc_task*)** %tk_action101, align 8, !tbaa !20
  call void @rpc_delay(%struct.rpc_task* %task, i64 15)
  br label %cleanup.cont

if.end102:                                        ; preds = %lor.lhs.false
  call void @rpc_exit(%struct.rpc_task* %task, i32 -512)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end102, %if.then100, %if.end55, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @call_bind(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_connect, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  %call4 = call i32 @xprt_bound(%struct.rpc_xprt* %1)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.end8, label %if.then6

if.then6:                                         ; preds = %do.end
  %tk_action7 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_bind_status, void (%struct.rpc_task*)** %tk_action7, align 8, !tbaa !20
  %bind_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 22
  %4 = load i64, i64* %bind_timeout, align 8, !tbaa !85
  %tk_timeout = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  store i64 %4, i64* %tk_timeout, align 8, !tbaa !86
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 1
  %5 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %rpcbind = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %5, i32 0, i32 4
  %6 = load void (%struct.rpc_task*)*, void (%struct.rpc_task*)** %rpcbind, align 8, !tbaa !87
  call void %6(%struct.rpc_task* %task)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %do.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @fatal_signal_pending(%struct.task_struct* %p) #2 {
entry:
  %call = call i32 @signal_pending(%struct.task_struct* %p)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %call1 = call i32 @__fatal_signal_pending(%struct.task_struct* %p)
  %tobool2 = icmp ne i32 %call1, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %0 = phi i1 [ false, %entry ], [ %tobool2, %land.rhs ]
  %land.ext = zext i1 %0 to i32
  ret i32 %land.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @signal_pending(%struct.task_struct* %p) #2 {
entry:
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* %p, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__fatal_signal_pending(%struct.task_struct* %p) #2 {
entry:
  %pending = getelementptr inbounds %struct.task_struct, %struct.task_struct* %p, i32 0, i32 80
  %signal = getelementptr inbounds %struct.sigpending, %struct.sigpending* %pending, i32 0, i32 1
  %call = call i32 @sigismember(%struct.dma_attrs* %signal, i32 9)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @sigismember(%struct.dma_attrs* %set, i32 %_sig) #2 {
entry:
  %sub = sub nsw i32 %_sig, 1
  %conv = sext i32 %sub to i64
  %sig1 = getelementptr inbounds %struct.dma_attrs, %struct.dma_attrs* %set, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x i64], [1 x i64]* %sig1, i64 0, i64 0
  %0 = load i64, i64* %arrayidx, align 8, !tbaa !88
  %shr = lshr i64 %0, %conv
  %and = and i64 1, %shr
  %conv2 = trunc i64 %and to i32
  ret i32 %conv2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_tsk_thread_flag(%struct.task_struct* %tsk, i32 %flag) #2 {
entry:
  %stack = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i32 0, i32 1
  %0 = load i8*, i8** %stack, align 8, !tbaa !89
  %1 = bitcast i8* %0 to %struct.thread_info*
  %call = call i32 @test_ti_thread_flag(%struct.thread_info* %1, i32 %flag)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_ti_thread_flag(%struct.thread_info* %ti, i32 %flag) #2 {
entry:
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i32 0, i32 2
  %0 = bitcast i32* %flags to i64*
  %call = call i32 @variable_test_bit(i32 %flag, i64* %0)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @variable_test_bit(i32 %nr, i64* %addr) #2 {
entry:
  %0 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr) #7, !srcloc !119
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal void @call_connect(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %call = call i32 @xprt_connected(%struct.rpc_xprt* %1)
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_transmit, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  %call6 = call i32 @xprt_connected(%struct.rpc_xprt* %1)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %cleanup.cont, label %if.then8

if.then8:                                         ; preds = %do.end
  %tk_action9 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_connect_status, void (%struct.rpc_task*)** %tk_action9, align 8, !tbaa !20
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %4 = load i32, i32* %tk_status, align 4, !tbaa !59
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %cleanup.cont, label %if.end12

if.end12:                                         ; preds = %if.then8
  call void @xprt_connect(%struct.rpc_task* %task)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end12, %if.then8, %do.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_bound(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %0 = load volatile i64, i64* %state, align 8, !tbaa !88
  %and.i = and i64 16, %0
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  ret i32 %conv.i
}

; Function Attrs: nounwind uwtable
define internal void @call_bind_status(%struct.rpc_task* %task) #0 {
entry:
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %0 = load i32, i32* %tk_status, align 4, !tbaa !59
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %do.body, label %if.end7

do.body:                                          ; preds = %entry
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then3, label %do.end

if.then3:                                         ; preds = %do.body
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then3, %do.body
  %tk_status6 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status6, align 4, !tbaa !59
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_connect, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  br label %cleanup.cont

if.end7:                                          ; preds = %entry
  call void @trace_rpc_bind_status(%struct.rpc_task* %task)
  %tk_status8 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %3 = load i32, i32* %tk_status8, align 4, !tbaa !59
  %Pivot32 = icmp slt i32 %3, -96
  br i1 %Pivot32, label %NodeBlock13, label %NodeBlock29

NodeBlock29:                                      ; preds = %if.end7
  %Pivot30 = icmp slt i32 %3, -32
  br i1 %Pivot30, label %NodeBlock19, label %NodeBlock27

NodeBlock27:                                      ; preds = %NodeBlock29
  %Pivot28 = icmp slt i32 %3, -13
  br i1 %Pivot28, label %LeafBlock21, label %NodeBlock25

NodeBlock25:                                      ; preds = %NodeBlock27
  %Pivot26 = icmp slt i32 %3, -12
  br i1 %Pivot26, label %do.body27, label %LeafBlock23

LeafBlock23:                                      ; preds = %NodeBlock25
  %SwitchLeaf24 = icmp eq i32 %3, -12
  br i1 %SwitchLeaf24, label %do.body9, label %do.body138

LeafBlock21:                                      ; preds = %NodeBlock27
  %SwitchLeaf22 = icmp eq i32 %3, -32
  br i1 %SwitchLeaf22, label %do.body114, label %do.body138

NodeBlock19:                                      ; preds = %NodeBlock29
  %Pivot20 = icmp slt i32 %3, -93
  br i1 %Pivot20, label %LeafBlock15, label %LeafBlock17

LeafBlock17:                                      ; preds = %NodeBlock19
  %SwitchLeaf18 = icmp eq i32 %3, -93
  br i1 %SwitchLeaf18, label %do.body94, label %do.body138

LeafBlock15:                                      ; preds = %NodeBlock19
  %SwitchLeaf16 = icmp eq i32 %3, -96
  br i1 %SwitchLeaf16, label %do.body76, label %do.body138

NodeBlock13:                                      ; preds = %if.end7
  %Pivot14 = icmp slt i32 %3, -107
  br i1 %Pivot14, label %NodeBlock, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %3, -104
  br i1 %Pivot12, label %LeafBlock3, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %3, -101
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %3, -101
  br i1 %SwitchLeaf8, label %do.body114, label %do.body138

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %3, -104
  br i1 %SwitchLeaf6, label %do.body114, label %do.body138

LeafBlock3:                                       ; preds = %NodeBlock11
  %SwitchLeaf4 = icmp eq i32 %3, -107
  br i1 %SwitchLeaf4, label %do.body114, label %do.body138

NodeBlock:                                        ; preds = %NodeBlock13
  %Pivot = icmp slt i32 %3, -110
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %3, -110
  br i1 %SwitchLeaf2, label %do.body58, label %do.body138

LeafBlock:                                        ; preds = %NodeBlock
  %.off = add i32 %3, 113
  %SwitchLeaf = icmp ule i32 %.off, 2
  br i1 %SwitchLeaf, label %do.body114, label %do.body138

do.body9:                                         ; preds = %LeafBlock23
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and10 = and i32 %4, 2
  %tobool11 = icmp ne i32 %and10, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %if.then19, label %do.end25

if.then19:                                        ; preds = %do.body9
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end25

do.end25:                                         ; preds = %if.then19, %do.body9
  call void @rpc_delay(%struct.rpc_task* %task, i64 62)
  br label %retry_timeout

do.body27:                                        ; preds = %NodeBlock25
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and28 = and i32 %6, 2
  %tobool29 = icmp ne i32 %and28, 0
  %lnot30 = xor i1 %tobool29, true
  %lnot32 = xor i1 %lnot30, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %expval35 = call i64 @llvm.expect.i64(i64 %conv34, i64 0)
  %tobool36 = icmp ne i64 %expval35, 0
  br i1 %tobool36, label %if.then37, label %do.end43

if.then37:                                        ; preds = %do.body27
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end43

do.end43:                                         ; preds = %if.then37, %do.body27
  %tk_msg = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg, i32 0, i32 0
  %8 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !44
  %p_proc = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %8, i32 0, i32 0
  %9 = load i32, i32* %p_proc, align 8, !tbaa !73
  %cmp44 = icmp eq i32 %9, 0
  br i1 %cmp44, label %sw.epilog, label %if.end47

if.end47:                                         ; preds = %do.end43
  %tk_rebind_retry = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 20
  %bf.load = load i8, i8* %tk_rebind_retry, align 2
  %bf.lshr = lshr i8 %bf.load, 6
  %conv48 = zext i8 %bf.lshr to i32
  %cmp49 = icmp eq i32 %conv48, 0
  br i1 %cmp49, label %sw.epilog, label %if.end52

if.end52:                                         ; preds = %if.end47
  %tk_rebind_retry53 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 20
  %bf.load54 = load i8, i8* %tk_rebind_retry53, align 2
  %bf.lshr55 = lshr i8 %bf.load54, 6
  %dec = add i8 %bf.lshr55, -1
  %bf.load56 = load i8, i8* %tk_rebind_retry53, align 2
  %bf.value = and i8 %dec, 3
  %bf.shl = shl i8 %bf.value, 6
  %bf.clear = and i8 %bf.load56, 63
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, i8* %tk_rebind_retry53, align 2
  call void @rpc_delay(%struct.rpc_task* %task, i64 750)
  br label %retry_timeout

do.body58:                                        ; preds = %LeafBlock1
  %10 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and59 = and i32 %10, 2
  %tobool60 = icmp ne i32 %and59, 0
  %lnot61 = xor i1 %tobool60, true
  %lnot63 = xor i1 %lnot61, true
  %lnot.ext64 = zext i1 %lnot63 to i32
  %conv65 = sext i32 %lnot.ext64 to i64
  %expval66 = call i64 @llvm.expect.i64(i64 %conv65, i64 0)
  %tobool67 = icmp ne i64 %expval66, 0
  br i1 %tobool67, label %if.then68, label %retry_timeout

if.then68:                                        ; preds = %do.body58
  %11 = call i32 (i8*, ...) @printk(i8* null)
  br label %retry_timeout

do.body76:                                        ; preds = %LeafBlock15
  %12 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and77 = and i32 %12, 2
  %tobool78 = icmp ne i32 %and77, 0
  %lnot79 = xor i1 %tobool78, true
  %lnot81 = xor i1 %lnot79, true
  %lnot.ext82 = zext i1 %lnot81 to i32
  %conv83 = sext i32 %lnot.ext82 to i64
  %expval84 = call i64 @llvm.expect.i64(i64 %conv83, i64 0)
  %tobool85 = icmp ne i64 %expval84, 0
  br i1 %tobool85, label %if.then86, label %sw.epilog

if.then86:                                        ; preds = %do.body76
  %13 = call i32 (i8*, ...) @printk(i8* null)
  br label %sw.epilog

do.body94:                                        ; preds = %LeafBlock17
  %14 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and95 = and i32 %14, 2
  %tobool96 = icmp ne i32 %and95, 0
  %lnot97 = xor i1 %tobool96, true
  %lnot99 = xor i1 %lnot97, true
  %lnot.ext100 = zext i1 %lnot99 to i32
  %conv101 = sext i32 %lnot.ext100 to i64
  %expval102 = call i64 @llvm.expect.i64(i64 %conv101, i64 0)
  %tobool103 = icmp ne i64 %expval102, 0
  br i1 %tobool103, label %if.then104, label %do.end110

if.then104:                                       ; preds = %do.body94
  %15 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end110

do.end110:                                        ; preds = %if.then104, %do.body94
  %tk_status111 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status111, align 4, !tbaa !59
  %tk_action112 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_bind, void (%struct.rpc_task*)** %tk_action112, align 8, !tbaa !20
  br label %cleanup.cont

do.body114:                                       ; preds = %LeafBlock, %LeafBlock3, %LeafBlock5, %LeafBlock7, %LeafBlock21
  %16 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and115 = and i32 %16, 2
  %tobool116 = icmp ne i32 %and115, 0
  %lnot117 = xor i1 %tobool116, true
  %lnot119 = xor i1 %lnot117, true
  %lnot.ext120 = zext i1 %lnot119 to i32
  %conv121 = sext i32 %lnot.ext120 to i64
  %expval122 = call i64 @llvm.expect.i64(i64 %conv121, i64 0)
  %tobool123 = icmp ne i64 %expval122, 0
  br i1 %tobool123, label %if.then124, label %do.end131

if.then124:                                       ; preds = %do.body114
  %17 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end131

do.end131:                                        ; preds = %if.then124, %do.body114
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %18 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv132 = zext i16 %18 to i32
  %and133 = and i32 %conv132, 1024
  %tobool134 = icmp ne i32 %and133, 0
  br i1 %tobool134, label %if.end136, label %if.then135

if.then135:                                       ; preds = %do.end131
  call void @rpc_delay(%struct.rpc_task* %task, i64 1250)
  br label %retry_timeout

if.end136:                                        ; preds = %do.end131
  %tk_status137 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %19 = load i32, i32* %tk_status137, align 4, !tbaa !59
  br label %sw.epilog

do.body138:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5, %LeafBlock7, %LeafBlock15, %LeafBlock17, %LeafBlock21, %LeafBlock23
  %20 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and139 = and i32 %20, 2
  %tobool140 = icmp ne i32 %and139, 0
  %lnot141 = xor i1 %tobool140, true
  %lnot143 = xor i1 %lnot141, true
  %lnot.ext144 = zext i1 %lnot143 to i32
  %conv145 = sext i32 %lnot.ext144 to i64
  %expval146 = call i64 @llvm.expect.i64(i64 %conv145, i64 0)
  %tobool147 = icmp ne i64 %expval146, 0
  br i1 %tobool147, label %if.then148, label %sw.epilog

if.then148:                                       ; preds = %do.body138
  %21 = call i32 (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then148, %do.body138, %if.end136, %if.then86, %do.body76, %if.end47, %do.end43
  %status.0 = phi i32 [ %19, %if.end136 ], [ -95, %do.end43 ], [ -5, %if.end47 ], [ -5, %if.then86 ], [ -5, %do.body76 ], [ -5, %if.then148 ], [ -5, %do.body138 ]
  call void @rpc_exit(%struct.rpc_task* %task, i32 %status.0)
  br label %cleanup.cont

retry_timeout:                                    ; preds = %if.then135, %if.then68, %do.body58, %if.end52, %do.end25
  %tk_action156 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_timeout, void (%struct.rpc_task*)** %tk_action156, align 8, !tbaa !20
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %retry_timeout, %sw.epilog, %do.end110, %do.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @trace_rpc_bind_status(%struct.rpc_task* %task) #2 {
entry:
  %call.i = call i32 @atomic_read(%struct.atomic_t* getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_bind_status, i64 0, i32 1, i32 0)) #7
  %tobool.i = icmp ne i32 %call.i, 0
  %lnot.ext.i = zext i1 %tobool.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv.i, i64 0) #7
  %cmp.i = icmp sgt i64 %expval.i, 0
  %..i = select i1 %cmp.i, i1 true, i1 false
  br i1 %..i, label %do.body, label %if.end21

do.body:                                          ; preds = %entry
  call void @rcu_read_lock_sched_notrace()
  %0 = load volatile %struct.tracepoint_func*, %struct.tracepoint_func** getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_bind_status, i32 0, i32 4), align 8, !tbaa !28
  %call2 = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %land.lhs.true, label %do.end10

land.lhs.true:                                    ; preds = %do.body
  %1 = load i8, i8* @trace_rpc_bind_status.__warned, align 1, !tbaa !29, !range !31
  %tobool3 = trunc i8 %1 to i1
  br i1 %tobool3, label %do.end10, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %land.lhs.true
  %call5 = call i32 @rcu_read_lock_sched_held()
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %do.end10, label %if.then7

if.then7:                                         ; preds = %land.lhs.true4
  store i8 1, i8* @trace_rpc_bind_status.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.36.302, i32 0, i32 0), i32 42, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end10

do.end10:                                         ; preds = %if.then7, %land.lhs.true4, %land.lhs.true, %do.body
  %tobool11 = icmp ne %struct.tracepoint_func* %0, null
  br i1 %tobool11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %do.end10
  br label %do.body13

do.body13:                                        ; preds = %do.body13, %if.then12
  %it_func_ptr.0 = phi %struct.tracepoint_func* [ %0, %if.then12 ], [ %incdec.ptr, %do.body13 ]
  %func = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 0
  %2 = load i8*, i8** %func, align 8, !tbaa !120
  %data = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 1
  %3 = load i8*, i8** %data, align 8, !tbaa !122
  %4 = bitcast i8* %2 to void (i8*, %struct.rpc_task*)*
  call void %4(i8* %3, %struct.rpc_task* %task)
  %incdec.ptr = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 1
  %func15 = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %incdec.ptr, i32 0, i32 0
  %5 = load i8*, i8** %func15, align 8, !tbaa !120
  %tobool16 = icmp ne i8* %5, null
  br i1 %tobool16, label %do.body13, label %if.end18

if.end18:                                         ; preds = %do.body13, %do.end10
  call void @rcu_read_unlock_sched_notrace()
  br label %if.end21

if.end21:                                         ; preds = %if.end18, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @call_timeout(%struct.rpc_task* %task) #0 {
entry:
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %0 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %1 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %call = call i32 @xprt_adjust_timeout(%struct.rpc_rqst* %1)
  %cmp = icmp eq i32 %call, 0
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %cmp, label %do.body, label %do.body7

do.body:                                          ; preds = %entry
  br i1 %tobool2, label %if.then3, label %retry

if.then3:                                         ; preds = %do.body
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %retry

do.body7:                                         ; preds = %entry
  br i1 %tobool2, label %if.then17, label %do.end23

if.then17:                                        ; preds = %do.body7
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end23

do.end23:                                         ; preds = %if.then17, %do.body7
  %tk_timeouts = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 18
  %5 = load i16, i16* %tk_timeouts, align 2, !tbaa !123
  %inc = add i16 %5, 1
  store i16 %inc, i16* %tk_timeouts, align 2, !tbaa !123
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %6 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv24 = zext i16 %6 to i32
  %and25 = and i32 %conv24, 1024
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %do.end23
  call void @rpc_exit(%struct.rpc_task* %task, i32 -110)
  br label %cleanup.cont

if.end28:                                         ; preds = %do.end23
  %tk_flags29 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %7 = load i16, i16* %tk_flags29, align 8, !tbaa !27
  %conv30 = zext i16 %7 to i32
  %and31 = and i32 %conv30, 4608
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.then33, label %if.end58

if.then33:                                        ; preds = %if.end28
  %cl_chatty = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 13
  %bf.load = load i8, i8* %cl_chatty, align 8
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool34 = icmp ne i32 %bf.cast, 0
  br i1 %tobool34, label %if.then35, label %if.end51

if.then35:                                        ; preds = %if.then33
  call void @rcu_read_lock()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 4
  %8 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call37 = call i32 @debug_lockdep_rcu_enabled()
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %land.lhs.true, label %do.end49

land.lhs.true:                                    ; preds = %if.then35
  %9 = load i8, i8* @call_timeout.__warned, align 1, !tbaa !29, !range !31
  %tobool39 = trunc i8 %9 to i1
  br i1 %tobool39, label %do.end49, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true
  %call41 = call i32 @rcu_read_lock_held()
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %do.end49, label %if.then43

if.then43:                                        ; preds = %land.lhs.true40
  store i8 1, i8* @call_timeout.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 1927, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end49

do.end49:                                         ; preds = %if.then43, %land.lhs.true40, %land.lhs.true, %if.then35
  %10 = call i32 (i8*, ...) @printk(i8* null)
  call void @rcu_read_unlock()
  br label %if.end51

if.end51:                                         ; preds = %do.end49, %if.then33
  %tk_flags52 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %11 = load i16, i16* %tk_flags52, align 8, !tbaa !27
  %conv53 = zext i16 %11 to i32
  %and54 = and i32 %conv53, 4096
  %tobool55 = icmp ne i32 %and54, 0
  br i1 %tobool55, label %if.then56, label %if.else

if.then56:                                        ; preds = %if.end51
  call void @rpc_exit(%struct.rpc_task* %task, i32 -110)
  br label %cleanup.cont

if.else:                                          ; preds = %if.end51
  call void @rpc_exit(%struct.rpc_task* %task, i32 -5)
  br label %cleanup.cont

if.end58:                                         ; preds = %if.end28
  %tk_flags59 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %12 = load i16, i16* %tk_flags59, align 8, !tbaa !27
  %conv60 = zext i16 %12 to i32
  %and61 = and i32 %conv60, 32
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.end96, label %if.then63

if.then63:                                        ; preds = %if.end58
  %tk_flags64 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %13 = load i16, i16* %tk_flags64, align 8, !tbaa !27
  %conv65 = zext i16 %13 to i32
  %or = or i32 %conv65, 32
  %conv66 = trunc i32 %or to i16
  store i16 %conv66, i16* %tk_flags64, align 8, !tbaa !27
  %cl_chatty67 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 13
  %bf.load68 = load i8, i8* %cl_chatty67, align 8
  %bf.lshr69 = lshr i8 %bf.load68, 3
  %bf.clear70 = and i8 %bf.lshr69, 1
  %bf.cast71 = zext i8 %bf.clear70 to i32
  %tobool72 = icmp ne i32 %bf.cast71, 0
  br i1 %tobool72, label %if.then73, label %if.end96

if.then73:                                        ; preds = %if.then63
  call void @rcu_read_lock()
  %cl_xprt76 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 4
  %14 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt76, align 8, !tbaa !28
  %call78 = call i32 @debug_lockdep_rcu_enabled()
  %tobool79 = icmp ne i32 %call78, 0
  br i1 %tobool79, label %land.lhs.true80, label %do.end91

land.lhs.true80:                                  ; preds = %if.then73
  %15 = load i8, i8* @call_timeout.__warned.79, align 1, !tbaa !29, !range !31
  %tobool81 = trunc i8 %15 to i1
  br i1 %tobool81, label %do.end91, label %land.lhs.true82

land.lhs.true82:                                  ; preds = %land.lhs.true80
  %call83 = call i32 @rcu_read_lock_held()
  %tobool84 = icmp ne i32 %call83, 0
  br i1 %tobool84, label %do.end91, label %if.then85

if.then85:                                        ; preds = %land.lhs.true82
  store i8 1, i8* @call_timeout.__warned.79, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 1943, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end91

do.end91:                                         ; preds = %if.then85, %land.lhs.true82, %land.lhs.true80, %if.then73
  %16 = call i32 (i8*, ...) @printk(i8* null)
  call void @rcu_read_unlock()
  br label %if.end96

if.end96:                                         ; preds = %do.end91, %if.then63, %if.end58
  call void @rpc_force_rebind(%struct.rpc_clnt* %0)
  call void @rpcauth_invalcred(%struct.rpc_task* %task)
  br label %retry

retry:                                            ; preds = %if.end96, %if.then3, %do.body
  %cl_stats = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 11
  %17 = load %struct.rpc_stat*, %struct.rpc_stat** %cl_stats, align 8, !tbaa !52
  %rpcretrans = getelementptr inbounds %struct.rpc_stat, %struct.rpc_stat* %17, i32 0, i32 7
  %18 = load i32, i32* %rpcretrans, align 8, !tbaa !124
  %inc97 = add i32 %18, 1
  store i32 %inc97, i32* %rpcretrans, align 8, !tbaa !124
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_bind, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status, align 4, !tbaa !59
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %retry, %if.else, %if.then56, %if.then27
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock() #2 {
entry:
  call void @__rcu_read_lock()
  call void @rcu_lock_acquire(%struct.lockdep_map* @rcu_lock_map)
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_lock.__warned, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_lock.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 780, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.15.1329, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  ret void
}

declare i32 @debug_lockdep_rcu_enabled() #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rcu_read_lock_held() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call1 = call i32 @rcu_is_cpu_idle()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call zeroext i1 @rcu_lockdep_current_cpu_online()
  br i1 %call5, label %if.end7, label %return

if.end7:                                          ; preds = %if.end4
  %call8 = call i32 @lock_is_held(%struct.lockdep_map* @rcu_lock_map)
  br label %return

return:                                           ; preds = %if.end7, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call8, %if.end7 ], [ 1, %entry ], [ 0, %if.end ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

declare void @lockdep_rcu_suspicious(i8*, i32, i8*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_unlock() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_unlock.__warned, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_unlock.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 801, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.16.1322, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  call void @rcu_lock_release(%struct.lockdep_map* @rcu_lock_map)
  call void @__rcu_read_unlock()
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_force_rebind(%struct.rpc_clnt* %clnt) #0 {
entry:
  %cl_autobind = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 13
  %bf.load = load i8, i8* %cl_autobind, align 8
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.end10

if.then:                                          ; preds = %entry
  call void @rcu_read_lock()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 4
  %0 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %land.lhs.true, label %do.end9

land.lhs.true:                                    ; preds = %if.then
  %1 = load i8, i8* @rpc_force_rebind.__warned, align 1, !tbaa !29, !range !31
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %do.end9, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %land.lhs.true
  %call4 = call i32 @rcu_read_lock_held()
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %do.end9, label %if.then6

if.then6:                                         ; preds = %land.lhs.true3
  store i8 1, i8* @rpc_force_rebind.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 1223, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end9

do.end9:                                          ; preds = %if.then6, %land.lhs.true3, %land.lhs.true, %if.then
  call void @xprt_clear_bound(%struct.rpc_xprt* %0)
  call void @rcu_read_unlock()
  br label %if.end10

if.end10:                                         ; preds = %do.end9, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_clear_bound(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 4, i64* %state) #7, !srcloc !125
  ret void
}

declare i32 @rcu_is_cpu_idle() #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_release(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_release(%struct.lockdep_map* %map, i32 1, i64 ptrtoint (i8* blockaddress(@rcu_lock_release, %__here) to i64))
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_unlock() #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !126
  %call = call %struct.thread_info* @current_thread_info()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !130
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !131
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

declare void @lock_release(%struct.lockdep_map*, i32, i64) #4

declare zeroext i1 @rcu_lockdep_current_cpu_online() #4

declare i32 @lock_is_held(%struct.lockdep_map*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_lock() #2 {
entry:
  %call = call %struct.thread_info* @current_thread_info()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !132
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_acquire(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_acquire(%struct.lockdep_map* %map, i32 0, i32 0, i32 2, i32 1, %struct.lockdep_map* null, i64 ptrtoint (i8* blockaddress(@rcu_lock_acquire, %__here) to i64))
  ret void
}

declare void @lock_acquire(%struct.lockdep_map*, i32, i32, i32, i32, %struct.lockdep_map*, i64) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock_sched_notrace() #2 {
entry:
  %call = call %struct.thread_info* @current_thread_info()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !133
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rcu_read_lock_sched_held() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @rcu_is_cpu_idle()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call zeroext i1 @rcu_lockdep_current_cpu_online()
  br i1 %call5, label %if.end7, label %cleanup

if.end7:                                          ; preds = %if.end4
  %0 = load i32, i32* @debug_locks, align 4, !tbaa !49
  %tobool8 = icmp ne i32 %0, 0
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end7
  %call10 = call i32 @lock_is_held(%struct.lockdep_map* @rcu_sched_lock_map)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end7
  %lockdep_opinion.0 = phi i32 [ %call10, %if.then9 ], [ 0, %if.end7 ]
  %tobool12 = icmp ne i32 %lockdep_opinion.0, 0
  br i1 %tobool12, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end11
  %call13 = call %struct.thread_info* @current_thread_info()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call13, i32 0, i32 5
  %1 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %lor.end, label %do.body

do.body:                                          ; preds = %lor.lhs.false
  %call15 = call i64 @arch_local_save_flags()
  %call23 = call i32 @arch_irqs_disabled_flags(i64 %call15)
  %tobool24 = icmp ne i32 %call23, 0
  br label %lor.end

lor.end:                                          ; preds = %do.body, %lor.lhs.false, %if.end11
  %2 = phi i1 [ true, %lor.lhs.false ], [ true, %if.end11 ], [ %tobool24, %do.body ]
  %lor.ext = zext i1 %2 to i32
  br label %cleanup

cleanup:                                          ; preds = %lor.end, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %lor.ext, %lor.end ], [ 1, %entry ], [ 0, %if.end ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_unlock_sched_notrace() #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !134
  %call = call %struct.thread_info* @current_thread_info()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !135
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @arch_local_save_flags() #2 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), align 8, !tbaa !136
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.52.682, i32 0, i32 0), i32 824, i64 12) #7, !srcloc !139
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call i64 asm sideeffect "771:\0A\09call *${2:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${1:c}\0A  .byte 772b-771b\0A  .short ${3:c}\0A.popsection\0A", "={ax},i,i,i,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 44, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), i32 1) #7, !srcloc !140
  ret i64 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @arch_irqs_disabled_flags(i64 %flags) #2 {
entry:
  %and = and i64 %flags, 512
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !49
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_connected(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %0 = load volatile i64, i64* %state, align 8, !tbaa !88
  %and.i = and i64 2, %0
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  ret i32 %conv.i
}

; Function Attrs: nounwind uwtable
define internal void @call_transmit(%struct.rpc_task* %task) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_status, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  %tk_status4 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %2 = load i32, i32* %tk_status4, align 4, !tbaa !59
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %return, label %if.end7

if.end7:                                          ; preds = %do.end
  %call8 = call i32 @xprt_prepare_transmit(%struct.rpc_task* %task)
  %tk_status9 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 %call8, i32* %tk_status9, align 4, !tbaa !59
  %tk_status10 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %3 = load i32, i32* %tk_status10, align 4, !tbaa !59
  %cmp11 = icmp ne i32 %3, 0
  br i1 %cmp11, label %return, label %if.end14

if.end14:                                         ; preds = %if.end7
  %tk_action15 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_transmit_status, void (%struct.rpc_task*)** %tk_action15, align 8, !tbaa !20
  %call16 = call i32 @rpc_task_need_encode(%struct.rpc_task* %task)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.then18, label %if.end30

if.then18:                                        ; preds = %if.end14
  call void @rpc_xdr_encode(%struct.rpc_task* %task)
  %tk_status19 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %4 = load i32, i32* %tk_status19, align 4, !tbaa !59
  %cmp20 = icmp ne i32 %4, 0
  br i1 %cmp20, label %if.then22, label %if.end30

if.then22:                                        ; preds = %if.then18
  %tk_status23 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %5 = load i32, i32* %tk_status23, align 4, !tbaa !59
  %cmp24 = icmp eq i32 %5, -11
  br i1 %cmp24, label %if.then26, label %if.else

if.then26:                                        ; preds = %if.then22
  call void @rpc_delay(%struct.rpc_task* %task, i64 15)
  br label %return

if.else:                                          ; preds = %if.then22
  %tk_status27 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %6 = load i32, i32* %tk_status27, align 4, !tbaa !59
  call void @rpc_exit(%struct.rpc_task* %task, i32 %6)
  br label %return

if.end30:                                         ; preds = %if.then18, %if.end14
  call void @xprt_transmit(%struct.rpc_task* %task)
  %tk_status31 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %7 = load i32, i32* %tk_status31, align 4, !tbaa !59
  %cmp32 = icmp slt i32 %7, 0
  br i1 %cmp32, label %return, label %if.end35

if.end35:                                         ; preds = %if.end30
  call void @call_transmit_status(%struct.rpc_task* %task)
  %call36 = call i32 @rpc_reply_expected(%struct.rpc_task* %task)
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %return, label %if.end39

if.end39:                                         ; preds = %if.end35
  %tk_action40 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @rpc_exit_task, void (%struct.rpc_task*)** %tk_action40, align 8, !tbaa !20
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %8 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %8, i32 0, i32 0
  %9 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %pending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %9, i32 0, i32 12
  call void @rpc_wake_up_queued_task(%struct.rpc_wait_queue* %pending, %struct.rpc_task* %task)
  br label %return

return:                                           ; preds = %if.end39, %if.end35, %if.end30, %if.else, %if.then26, %if.end7, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @call_connect_status(%struct.rpc_task* %task) #0 {
entry:
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %0 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %1 = load i32, i32* %tk_status, align 4, !tbaa !59
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  call void @trace_rpc_connect_status(%struct.rpc_task* %task, i32 %1)
  %Pivot18 = icmp slt i32 %1, -101
  br i1 %Pivot18, label %NodeBlock5, label %NodeBlock15

NodeBlock15:                                      ; preds = %do.end
  %Pivot16 = icmp slt i32 %1, -11
  br i1 %Pivot16, label %LeafBlock7, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %1, 0
  br i1 %Pivot14, label %LeafBlock9, label %LeafBlock11

LeafBlock11:                                      ; preds = %NodeBlock13
  %SwitchLeaf12 = icmp eq i32 %1, 0
  br i1 %SwitchLeaf12, label %sw.bb11, label %sw.epilog

LeafBlock9:                                       ; preds = %NodeBlock13
  %SwitchLeaf10 = icmp eq i32 %1, -11
  br i1 %SwitchLeaf10, label %sw.bb11, label %sw.epilog

LeafBlock7:                                       ; preds = %NodeBlock15
  %SwitchLeaf8 = icmp eq i32 %1, -101
  br i1 %SwitchLeaf8, label %sw.bb5, label %sw.epilog

NodeBlock5:                                       ; preds = %do.end
  %Pivot6 = icmp slt i32 %1, -110
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %1, -104
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %1, -104
  br i1 %SwitchLeaf4, label %sw.bb5, label %sw.epilog

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %1, -110
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %1, -111
  br i1 %SwitchLeaf, label %sw.bb5, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock1
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_timeout, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  br label %cleanup.cont

sw.bb5:                                           ; preds = %LeafBlock, %LeafBlock3, %LeafBlock7
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %4 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv6 = zext i16 %4 to i32
  %and7 = and i32 %conv6, 1024
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %sw.epilog, label %sw.bb11

sw.bb11:                                          ; preds = %sw.bb5, %LeafBlock9, %LeafBlock11
  %tk_status12 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status12, align 4, !tbaa !59
  %cl_stats = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 11
  %5 = load %struct.rpc_stat*, %struct.rpc_stat** %cl_stats, align 8, !tbaa !52
  %netreconn = getelementptr inbounds %struct.rpc_stat, %struct.rpc_stat* %5, i32 0, i32 5
  %6 = load i32, i32* %netreconn, align 8, !tbaa !141
  %inc = add i32 %6, 1
  store i32 %inc, i32* %netreconn, align 8, !tbaa !141
  %tk_action13 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_transmit, void (%struct.rpc_task*)** %tk_action13, align 8, !tbaa !20
  br label %cleanup.cont

sw.epilog:                                        ; preds = %sw.bb5, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock7, %LeafBlock9, %LeafBlock11
  call void @rpc_exit(%struct.rpc_task* %task, i32 %1)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %sw.epilog, %sw.bb11, %sw.bb
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @trace_rpc_connect_status(%struct.rpc_task* %task, i32 %status) #2 {
entry:
  %call.i = call i32 @atomic_read(%struct.atomic_t* getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_connect_status, i64 0, i32 1, i32 0)) #7
  %tobool.i = icmp ne i32 %call.i, 0
  %lnot.ext.i = zext i1 %tobool.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv.i, i64 0) #7
  %cmp.i = icmp sgt i64 %expval.i, 0
  %..i = select i1 %cmp.i, i1 true, i1 false
  br i1 %..i, label %do.body, label %if.end21

do.body:                                          ; preds = %entry
  call void @rcu_read_lock_sched_notrace()
  %0 = load volatile %struct.tracepoint_func*, %struct.tracepoint_func** getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_connect_status, i32 0, i32 4), align 8, !tbaa !28
  %call2 = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %land.lhs.true, label %do.end10

land.lhs.true:                                    ; preds = %do.body
  %1 = load i8, i8* @trace_rpc_connect_status.__warned, align 1, !tbaa !29, !range !31
  %tobool3 = trunc i8 %1 to i1
  br i1 %tobool3, label %do.end10, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %land.lhs.true
  %call5 = call i32 @rcu_read_lock_sched_held()
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %do.end10, label %if.then7

if.then7:                                         ; preds = %land.lhs.true4
  store i8 1, i8* @trace_rpc_connect_status.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.36.302, i32 0, i32 0), i32 62, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end10

do.end10:                                         ; preds = %if.then7, %land.lhs.true4, %land.lhs.true, %do.body
  %tobool11 = icmp ne %struct.tracepoint_func* %0, null
  br i1 %tobool11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %do.end10
  br label %do.body13

do.body13:                                        ; preds = %do.body13, %if.then12
  %it_func_ptr.0 = phi %struct.tracepoint_func* [ %0, %if.then12 ], [ %incdec.ptr, %do.body13 ]
  %func = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 0
  %2 = load i8*, i8** %func, align 8, !tbaa !120
  %data = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 1
  %3 = load i8*, i8** %data, align 8, !tbaa !122
  %4 = bitcast i8* %2 to void (i8*, %struct.rpc_task*, i32)*
  call void %4(i8* %3, %struct.rpc_task* %task, i32 %status)
  %incdec.ptr = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 1
  %func15 = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %incdec.ptr, i32 0, i32 0
  %5 = load i8*, i8** %func15, align 8, !tbaa !120
  %tobool16 = icmp ne i8* %5, null
  br i1 %tobool16, label %do.body13, label %if.end18

if.end18:                                         ; preds = %do.body13, %do.end10
  call void @rcu_read_unlock_sched_notrace()
  br label %if.end21

if.end21:                                         ; preds = %if.end18, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @call_status(%struct.rpc_task* %task) #0 {
entry:
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %0 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %1 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_reply_bytes_recvd = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 16
  %2 = load i64, i64* %rq_reply_bytes_recvd, align 8, !tbaa !142
  %cmp = icmp ugt i64 %2, 0
  br i1 %cmp, label %land.lhs.true, label %do.body

land.lhs.true:                                    ; preds = %entry
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 23
  %3 = load i32, i32* %rq_bytes_sent, align 8, !tbaa !143
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %do.body, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %rq_reply_bytes_recvd1 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 16
  %4 = load i64, i64* %rq_reply_bytes_recvd1, align 8, !tbaa !142
  %conv = trunc i64 %4 to i32
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 %conv, i32* %tk_status, align 4, !tbaa !59
  br label %do.body

do.body:                                          ; preds = %if.then, %land.lhs.true, %entry
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %5, 2
  %tobool2 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then6, label %do.end

if.then6:                                         ; preds = %do.body
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then6, %do.body
  %tk_status10 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %7 = load i32, i32* %tk_status10, align 4, !tbaa !59
  %cmp11 = icmp sge i32 %7, 0
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %do.end
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_decode, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  br label %cleanup.cont

if.end14:                                         ; preds = %do.end
  call void @trace_rpc_call_status(%struct.rpc_task* %task)
  %tk_status15 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status15, align 4, !tbaa !59
  %Pivot28 = icmp slt i32 %7, -104
  br i1 %Pivot28, label %NodeBlock7, label %NodeBlock25

NodeBlock25:                                      ; preds = %if.end14
  %Pivot26 = icmp slt i32 %7, -32
  br i1 %Pivot26, label %NodeBlock13, label %NodeBlock23

NodeBlock23:                                      ; preds = %NodeBlock25
  %Pivot24 = icmp slt i32 %7, -11
  br i1 %Pivot24, label %LeafBlock15, label %NodeBlock21

NodeBlock21:                                      ; preds = %NodeBlock23
  %Pivot22 = icmp slt i32 %7, -5
  br i1 %Pivot22, label %LeafBlock17, label %LeafBlock19

LeafBlock19:                                      ; preds = %NodeBlock21
  %SwitchLeaf20 = icmp eq i32 %7, -5
  br i1 %SwitchLeaf20, label %sw.bb27, label %sw.default

LeafBlock17:                                      ; preds = %NodeBlock21
  %SwitchLeaf18 = icmp eq i32 %7, -11
  br i1 %SwitchLeaf18, label %sw.bb25, label %sw.default

LeafBlock15:                                      ; preds = %NodeBlock23
  %SwitchLeaf16 = icmp eq i32 %7, -32
  br i1 %SwitchLeaf16, label %sw.bb23, label %sw.default

NodeBlock13:                                      ; preds = %NodeBlock25
  %Pivot14 = icmp slt i32 %7, -101
  br i1 %Pivot14, label %LeafBlock9, label %LeafBlock11

LeafBlock11:                                      ; preds = %NodeBlock13
  %SwitchLeaf12 = icmp eq i32 %7, -101
  br i1 %SwitchLeaf12, label %sw.bb, label %sw.default

LeafBlock9:                                       ; preds = %NodeBlock13
  %SwitchLeaf10 = icmp eq i32 %7, -104
  br i1 %SwitchLeaf10, label %sw.bb22, label %sw.default

NodeBlock7:                                       ; preds = %if.end14
  %Pivot8 = icmp slt i32 %7, -110
  br i1 %Pivot8, label %NodeBlock, label %NodeBlock5

NodeBlock5:                                       ; preds = %NodeBlock7
  %Pivot6 = icmp slt i32 %7, -107
  br i1 %Pivot6, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock5
  %SwitchLeaf4 = icmp eq i32 %7, -107
  br i1 %SwitchLeaf4, label %sw.bb23, label %sw.default

LeafBlock1:                                       ; preds = %NodeBlock5
  %SwitchLeaf2 = icmp eq i32 %7, -110
  br i1 %SwitchLeaf2, label %sw.bb16, label %sw.default

NodeBlock:                                        ; preds = %NodeBlock7
  %Pivot = icmp slt i32 %7, -111
  br i1 %Pivot, label %LeafBlock, label %sw.bb22

LeafBlock:                                        ; preds = %NodeBlock
  %.off = add i32 %7, 113
  %SwitchLeaf = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock, %LeafBlock11
  call void @rpc_delay(%struct.rpc_task* %task, i64 750)
  br label %sw.bb16

sw.bb16:                                          ; preds = %sw.bb, %LeafBlock1
  %tk_action17 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_timeout, void (%struct.rpc_task*)** %tk_action17, align 8, !tbaa !20
  %tk_client18 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %8 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client18, align 8, !tbaa !26
  %cl_discrtry = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 13
  %bf.load = load i8, i8* %cl_discrtry, align 8
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool19 = icmp ne i32 %bf.cast, 0
  br i1 %tobool19, label %if.then20, label %cleanup.cont

if.then20:                                        ; preds = %sw.bb16
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 0
  %9 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %rq_connect_cookie = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 22
  %10 = load i32, i32* %rq_connect_cookie, align 4, !tbaa !144
  call void @xprt_conditional_disconnect(%struct.rpc_xprt* %9, i32 %10)
  br label %cleanup.cont

sw.bb22:                                          ; preds = %NodeBlock, %LeafBlock9
  call void @rpc_force_rebind(%struct.rpc_clnt* %0)
  call void @rpc_delay(%struct.rpc_task* %task, i64 750)
  br label %sw.bb23

sw.bb23:                                          ; preds = %sw.bb22, %LeafBlock3, %LeafBlock15
  %tk_action24 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_bind, void (%struct.rpc_task*)** %tk_action24, align 8, !tbaa !20
  br label %cleanup.cont

sw.bb25:                                          ; preds = %LeafBlock17
  %tk_action26 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_transmit, void (%struct.rpc_task*)** %tk_action26, align 8, !tbaa !20
  br label %cleanup.cont

sw.bb27:                                          ; preds = %LeafBlock19
  call void @rpc_exit(%struct.rpc_task* %task, i32 %7)
  br label %cleanup.cont

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock9, %LeafBlock11, %LeafBlock15, %LeafBlock17, %LeafBlock19
  %cl_chatty = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 13
  %bf.load28 = load i8, i8* %cl_chatty, align 8
  %bf.lshr29 = lshr i8 %bf.load28, 3
  %bf.clear30 = and i8 %bf.lshr29, 1
  %bf.cast31 = zext i8 %bf.clear30 to i32
  %tobool32 = icmp ne i32 %bf.cast31, 0
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %sw.default
  %11 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %sw.default
  call void @rpc_exit(%struct.rpc_task* %task, i32 %7)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end35, %sw.bb27, %sw.bb25, %sw.bb23, %if.then20, %sw.bb16, %if.then13
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @call_transmit_status(%struct.rpc_task* %task) #0 {
entry:
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_status, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %0 = load i32, i32* %tk_status, align 4, !tbaa !59
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @xprt_end_transmit(%struct.rpc_task* %task)
  call void @rpc_task_force_reencode(%struct.rpc_task* %task)
  br label %sw.epilog

if.end:                                           ; preds = %entry
  %tk_status1 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %1 = load i32, i32* %tk_status1, align 4, !tbaa !59
  %Pivot18 = icmp slt i32 %1, -101
  br i1 %Pivot18, label %NodeBlock5, label %NodeBlock15

NodeBlock15:                                      ; preds = %if.end
  %Pivot16 = icmp slt i32 %1, -32
  br i1 %Pivot16, label %LeafBlock7, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %1, -11
  br i1 %Pivot14, label %LeafBlock9, label %LeafBlock11

LeafBlock11:                                      ; preds = %NodeBlock13
  %SwitchLeaf12 = icmp eq i32 %1, -11
  br i1 %SwitchLeaf12, label %sw.epilog, label %do.body

LeafBlock9:                                       ; preds = %NodeBlock13
  %SwitchLeaf10 = icmp eq i32 %1, -32
  br i1 %SwitchLeaf10, label %sw.bb14, label %do.body

LeafBlock7:                                       ; preds = %NodeBlock15
  %SwitchLeaf8 = icmp eq i32 %1, -101
  br i1 %SwitchLeaf8, label %sw.bb, label %do.body

NodeBlock5:                                       ; preds = %if.end
  %Pivot6 = icmp slt i32 %1, -107
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %1, -104
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %1, -104
  br i1 %SwitchLeaf4, label %sw.bb14, label %do.body

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %1, -107
  br i1 %SwitchLeaf2, label %sw.bb14, label %do.body

LeafBlock:                                        ; preds = %NodeBlock5
  %.off = add i32 %1, 113
  %SwitchLeaf = icmp ule i32 %.off, 2
  br i1 %SwitchLeaf, label %sw.bb, label %do.body

do.body:                                          ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock7, %LeafBlock9, %LeafBlock11
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.end

if.then4:                                         ; preds = %do.body
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then4, %do.body
  call void @xprt_end_transmit(%struct.rpc_task* %task)
  call void @rpc_task_force_reencode(%struct.rpc_task* %task)
  br label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock, %LeafBlock7
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %4 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv8 = zext i16 %4 to i32
  %and9 = and i32 %conv8, 1024
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then11, label %sw.bb14

if.then11:                                        ; preds = %sw.bb
  call void @xprt_end_transmit(%struct.rpc_task* %task)
  %tk_status12 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %5 = load i32, i32* %tk_status12, align 4, !tbaa !59
  call void @rpc_exit(%struct.rpc_task* %task, i32 %5)
  br label %sw.epilog

sw.bb14:                                          ; preds = %sw.bb, %LeafBlock1, %LeafBlock3, %LeafBlock9
  call void @rpc_task_force_reencode(%struct.rpc_task* %task)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb14, %if.then11, %do.end, %LeafBlock11, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rpc_task_need_encode(%struct.rpc_task* %task) #2 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 7
  %1 = load i32, i32* %len, align 8, !tbaa !145
  %cmp = icmp eq i32 %1, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal void @rpc_xdr_encode(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %rq_buffer = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 12
  %3 = load i32*, i32** %rq_buffer, align 8, !tbaa !72
  %4 = bitcast i32* %3 to i8*
  %rq_callsize = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 13
  %5 = load i64, i64* %rq_callsize, align 8, !tbaa !79
  call void @rpc_xdr_buf_init(%struct.xdr_buf* %rq_snd_buf, i8* %4, i64 %5)
  %rq_rcv_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 2
  %rq_buffer4 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 12
  %6 = load i32*, i32** %rq_buffer4, align 8, !tbaa !72
  %7 = bitcast i32* %6 to i8*
  %rq_callsize5 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 13
  %8 = load i64, i64* %rq_callsize5, align 8, !tbaa !79
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 %8
  %rq_rcvsize = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 14
  %9 = load i64, i64* %rq_rcvsize, align 8, !tbaa !80
  call void @rpc_xdr_buf_init(%struct.xdr_buf* %rq_rcv_buf, i8* %add.ptr, i64 %9)
  %call6 = call i32* @rpc_encode_header(%struct.rpc_task* %task)
  %cmp = icmp eq i32* %call6, null
  br i1 %cmp, label %if.then8, label %if.end10

if.then8:                                         ; preds = %do.end
  %10 = call i32 (i8*, ...) @printk(i8* null)
  call void @rpc_exit(%struct.rpc_task* %task, i32 -5)
  br label %cleanup.cont

if.end10:                                         ; preds = %do.end
  %tk_msg = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg, i32 0, i32 0
  %11 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !44
  %p_encode = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %11, i32 0, i32 1
  %12 = load void (i8*, %struct.xdr_stream*, i8*)*, void (i8*, %struct.xdr_stream*, i8*)** %p_encode, align 8, !tbaa !146
  %cmp11 = icmp eq void (i8*, %struct.xdr_stream*, i8*)* %12, null
  br i1 %cmp11, label %cleanup.cont, label %if.end14

if.end14:                                         ; preds = %if.end10
  %13 = bitcast %struct.rpc_rqst* %0 to i8*
  %tk_msg15 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_argp = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg15, i32 0, i32 1
  %14 = load i8*, i8** %rpc_argp, align 8, !tbaa !45
  %call16 = call i32 @rpcauth_wrap_req(%struct.rpc_task* %task, void (i8*, %struct.xdr_stream*, i8*)* %12, i8* %13, i32* %call6, i8* %14)
  %tk_status17 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 %call16, i32* %tk_status17, align 4, !tbaa !59
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end14, %if.end10, %if.then8
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rpc_reply_expected(%struct.rpc_task* %task) #2 {
entry:
  %tk_msg = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg, i32 0, i32 0
  %0 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !44
  %cmp = icmp ne %struct.rpc_procinfo* %0, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %tk_msg1 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_proc2 = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg1, i32 0, i32 0
  %1 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %rpc_proc2, align 8, !tbaa !44
  %p_decode = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %1, i32 0, i32 2
  %2 = load i32 (i8*, %struct.xdr_stream*, i8*)*, i32 (i8*, %struct.xdr_stream*, i8*)** %p_decode, align 8, !tbaa !76
  %cmp3 = icmp ne i32 (i8*, %struct.xdr_stream*, i8*)* %2, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp3, %land.rhs ]
  %land.ext = zext i1 %3 to i32
  ret i32 %land.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rpc_xdr_buf_init(%struct.xdr_buf* %buf, i8* %start, i64 %len) #2 {
entry:
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  store i8* %start, i8** %iov_base, align 8, !tbaa !147
  %head1 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head1, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx2, i32 0, i32 1
  store i64 %len, i64* %iov_len, align 8, !tbaa !149
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arrayidx3 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_len4 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx3, i32 0, i32 1
  store i64 0, i64* %iov_len4, align 8, !tbaa !149
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  store i32 0, i32* %page_len, align 4, !tbaa !150
  %flags = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 5
  store i32 0, i32* %flags, align 8, !tbaa !151
  %len5 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  store i32 0, i32* %len5, align 8, !tbaa !152
  %conv = trunc i64 %len to i32
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 6
  store i32 %conv, i32* %buflen, align 4, !tbaa !153
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32* @rpc_encode_header(%struct.rpc_task* %task) #0 {
entry:
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %0 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %1 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 1
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  %2 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %3 = bitcast i8* %2 to i32*
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 0
  %4 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %call = call i32* @xprt_skip_transport_header(%struct.rpc_xprt* %4, i32* %3)
  %rq_xid = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 5
  %5 = load i32, i32* %rq_xid, align 8, !tbaa !154
  %incdec.ptr = getelementptr inbounds i32, i32* %call, i32 1
  store i32 %5, i32* %call, align 4, !tbaa !49
  %incdec.ptr1 = getelementptr inbounds i32, i32* %incdec.ptr, i32 1
  store i32 0, i32* %incdec.ptr, align 4, !tbaa !49
  %incdec.ptr2 = getelementptr inbounds i32, i32* %incdec.ptr1, i32 1
  store i32 33554432, i32* %incdec.ptr1, align 4, !tbaa !49
  %cl_prog = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 6
  %6 = load i32, i32* %cl_prog, align 8, !tbaa !155
  %call3 = call i32 @__fswab32(i32 %6) #3
  %incdec.ptr4 = getelementptr inbounds i32, i32* %incdec.ptr2, i32 1
  store i32 %call3, i32* %incdec.ptr2, align 4, !tbaa !49
  %cl_vers = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 7
  %7 = load i32, i32* %cl_vers, align 4, !tbaa !156
  %call5 = call i32 @__fswab32(i32 %7) #3
  %incdec.ptr6 = getelementptr inbounds i32, i32* %incdec.ptr4, i32 1
  store i32 %call5, i32* %incdec.ptr4, align 4, !tbaa !49
  %tk_msg = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg, i32 0, i32 0
  %8 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !44
  %p_proc = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %8, i32 0, i32 0
  %9 = load i32, i32* %p_proc, align 8, !tbaa !73
  %call7 = call i32 @__fswab32(i32 %9) #3
  %incdec.ptr8 = getelementptr inbounds i32, i32* %incdec.ptr6, i32 1
  store i32 %call7, i32* %incdec.ptr6, align 4, !tbaa !49
  %call9 = call i32* @rpcauth_marshcred(%struct.rpc_task* %task, i32* %incdec.ptr8)
  %rq_snd_buf10 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 1
  %head11 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf10, i32 0, i32 0
  %arrayidx12 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head11, i64 0, i64 0
  %call13 = call i32 @xdr_adjust_iovec(%struct.iovec* %arrayidx12, i32* %call9)
  %rq_snd_buf14 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 1
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf14, i32 0, i32 7
  store i32 %call13, i32* %len, align 8, !tbaa !145
  ret i32* %call9
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32* @xprt_skip_transport_header(%struct.rpc_xprt* %xprt, i32* %p) #2 {
entry:
  %tsh_size = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 9
  %0 = load i32, i32* %tsh_size, align 8, !tbaa !157
  %idx.ext = zext i32 %0 to i64
  %add.ptr = getelementptr inbounds i32, i32* %p, i64 %idx.ext
  ret i32* %add.ptr
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__fswab32(i32 %val) #5 {
entry:
  %call = call i32 @__arch_swab32(i32 %val) #3
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xdr_adjust_iovec(%struct.iovec* %iov, i32* %p) #2 {
entry:
  %0 = bitcast i32* %p to i8*
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  %1 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %sub.ptr.lhs.cast = ptrtoint i8* %0 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  store i64 %sub.ptr.sub, i64* %iov_len, align 8, !tbaa !149
  %conv = trunc i64 %sub.ptr.sub to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__arch_swab32(i32 %val) #5 {
entry:
  %0 = call i32 asm "bswapl $0", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %val) #3, !srcloc !158
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rpc_task_force_reencode(%struct.rpc_task* %task) #2 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 7
  store i32 0, i32* %len, align 8, !tbaa !145
  %tk_rqstp1 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %1 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp1, align 8, !tbaa !60
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 23
  store i32 0, i32* %rq_bytes_sent, align 8, !tbaa !143
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @call_decode(%struct.rpc_task* %task) #0 {
entry:
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %0 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %1 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %tk_msg = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg, i32 0, i32 0
  %2 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !44
  %p_decode = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %2, i32 0, i32 2
  %3 = load i32 (i8*, %struct.xdr_stream*, i8*)*, i32 (i8*, %struct.xdr_stream*, i8*)** %p_decode, align 8, !tbaa !76
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %4, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %6 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv4 = zext i16 %6 to i32
  %and5 = and i32 %conv4, 32
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.end30

if.then7:                                         ; preds = %do.end
  %cl_chatty = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 13
  %bf.load = load i8, i8* %cl_chatty, align 8
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool8 = icmp ne i32 %bf.cast, 0
  br i1 %tobool8, label %if.then9, label %if.end25

if.then9:                                         ; preds = %if.then7
  call void @rcu_read_lock()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 4
  %7 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call11 = call i32 @debug_lockdep_rcu_enabled()
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %land.lhs.true, label %do.end23

land.lhs.true:                                    ; preds = %if.then9
  %8 = load i8, i8* @call_decode.__warned, align 1, !tbaa !29, !range !31
  %tobool13 = trunc i8 %8 to i1
  br i1 %tobool13, label %do.end23, label %land.lhs.true14

land.lhs.true14:                                  ; preds = %land.lhs.true
  %call15 = call i32 @rcu_read_lock_held()
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %do.end23, label %if.then17

if.then17:                                        ; preds = %land.lhs.true14
  store i8 1, i8* @call_decode.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 1978, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end23

do.end23:                                         ; preds = %if.then17, %land.lhs.true14, %land.lhs.true, %if.then9
  %9 = call i32 (i8*, ...) @printk(i8* null)
  call void @rcu_read_unlock()
  br label %if.end25

if.end25:                                         ; preds = %do.end23, %if.then7
  %tk_flags26 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %10 = load i16, i16* %tk_flags26, align 8, !tbaa !27
  %conv27 = zext i16 %10 to i32
  %and28 = and i32 %conv27, -33
  %conv29 = trunc i32 %and28 to i16
  store i16 %conv29, i16* %tk_flags26, align 8, !tbaa !27
  br label %if.end30

if.end30:                                         ; preds = %if.end25, %do.end
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !159
  %rq_private_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 17
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf, i32 0, i32 7
  %11 = load i32, i32* %len, align 8, !tbaa !160
  %rq_rcv_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 2
  %len31 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_rcv_buf, i32 0, i32 7
  store i32 %11, i32* %len31, align 8, !tbaa !161
  %rq_rcv_buf32 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 2
  %12 = bitcast %struct.xdr_buf* %rq_rcv_buf32 to i8*
  %rq_private_buf33 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 17
  %13 = bitcast %struct.xdr_buf* %rq_private_buf33 to i8*
  %call34 = call i32 @memcmp(i8* %12, i8* %13, i64 64)
  %cmp = icmp ne i32 %call34, 0
  %lnot36 = xor i1 %cmp, true
  %lnot38 = xor i1 %lnot36, true
  %lnot.ext39 = zext i1 %lnot38 to i32
  %tobool40 = icmp ne i32 %lnot.ext39, 0
  %lnot41 = xor i1 %tobool40, true
  %lnot43 = xor i1 %lnot41, true
  %lnot.ext44 = zext i1 %lnot43 to i32
  %conv45 = sext i32 %lnot.ext44 to i64
  %expval46 = call i64 @llvm.expect.i64(i64 %conv45, i64 0)
  %tobool47 = icmp ne i64 %expval46, 0
  br i1 %tobool47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %if.end30
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 1993)
  br label %if.end49

if.end49:                                         ; preds = %if.then48, %if.end30
  %rq_rcv_buf58 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 2
  %len59 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_rcv_buf58, i32 0, i32 7
  %14 = load i32, i32* %len59, align 8, !tbaa !161
  %cmp60 = icmp ult i32 %14, 12
  br i1 %cmp60, label %if.then62, label %if.end87

if.then62:                                        ; preds = %if.end49
  %tk_flags63 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %15 = load i16, i16* %tk_flags63, align 8, !tbaa !27
  %conv64 = zext i16 %15 to i32
  %and65 = and i32 %conv64, 4608
  %tobool66 = icmp ne i32 %and65, 0
  br i1 %tobool66, label %do.body69, label %if.then67

if.then67:                                        ; preds = %if.then62
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_bind, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  %cl_stats = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 11
  %16 = load %struct.rpc_stat*, %struct.rpc_stat** %cl_stats, align 8, !tbaa !52
  %rpcretrans = getelementptr inbounds %struct.rpc_stat, %struct.rpc_stat* %16, i32 0, i32 7
  %17 = load i32, i32* %rpcretrans, align 8, !tbaa !124
  %inc = add i32 %17, 1
  store i32 %inc, i32* %rpcretrans, align 8, !tbaa !124
  br label %out_retry

do.body69:                                        ; preds = %if.then62
  %18 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and70 = and i32 %18, 2
  %tobool71 = icmp ne i32 %and70, 0
  %lnot72 = xor i1 %tobool71, true
  %lnot74 = xor i1 %lnot72, true
  %lnot.ext75 = zext i1 %lnot74 to i32
  %conv76 = sext i32 %lnot.ext75 to i64
  %expval77 = call i64 @llvm.expect.i64(i64 %conv76, i64 0)
  %tobool78 = icmp ne i64 %expval77, 0
  br i1 %tobool78, label %if.then79, label %do.end85

if.then79:                                        ; preds = %do.body69
  %19 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end85

do.end85:                                         ; preds = %if.then79, %do.body69
  %tk_action86 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_timeout, void (%struct.rpc_task*)** %tk_action86, align 8, !tbaa !20
  br label %out_retry

if.end87:                                         ; preds = %if.end49
  %call88 = call i32* @rpc_verify_header(%struct.rpc_task* %task)
  %20 = bitcast i32* %call88 to i8*
  %call89 = call i64 @IS_ERR(i8* %20)
  %tobool90 = icmp ne i64 %call89, 0
  br i1 %tobool90, label %if.then91, label %if.end97

if.then91:                                        ; preds = %if.end87
  %call92 = call i8* @ERR_PTR(i64 -11)
  %21 = bitcast i8* %call92 to i32*
  %cmp93 = icmp eq i32* %call88, %21
  br i1 %cmp93, label %out_retry, label %cleanup.cont

if.end97:                                         ; preds = %if.end87
  %tk_action98 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @rpc_exit_task, void (%struct.rpc_task*)** %tk_action98, align 8, !tbaa !20
  %tobool99 = icmp ne i32 (i8*, %struct.xdr_stream*, i8*)* %3, null
  br i1 %tobool99, label %if.then100, label %do.body105

if.then100:                                       ; preds = %if.end97
  %22 = bitcast %struct.rpc_rqst* %1 to i8*
  %tk_msg101 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_resp = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg101, i32 0, i32 2
  %23 = load i8*, i8** %rpc_resp, align 8, !tbaa !46
  %call102 = call i32 @rpcauth_unwrap_resp(%struct.rpc_task* %task, i32 (i8*, %struct.xdr_stream*, i8*)* %3, i8* %22, i32* %call88, i8* %23)
  %tk_status103 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 %call102, i32* %tk_status103, align 4, !tbaa !59
  br label %do.body105

do.body105:                                       ; preds = %if.then100, %if.end97
  %24 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and106 = and i32 %24, 2
  %tobool107 = icmp ne i32 %and106, 0
  %lnot108 = xor i1 %tobool107, true
  %lnot110 = xor i1 %lnot108, true
  %lnot.ext111 = zext i1 %lnot110 to i32
  %conv112 = sext i32 %lnot.ext111 to i64
  %expval113 = call i64 @llvm.expect.i64(i64 %conv112, i64 0)
  %tobool114 = icmp ne i64 %expval113, 0
  br i1 %tobool114, label %if.then115, label %cleanup.cont

if.then115:                                       ; preds = %do.body105
  %25 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup.cont

out_retry:                                        ; preds = %if.then91, %do.end85, %if.then67
  %tk_status123 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status123, align 4, !tbaa !59
  %tk_rqstp124 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %26 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp124, align 8, !tbaa !60
  %cmp125 = icmp eq %struct.rpc_rqst* %26, %1
  br i1 %cmp125, label %if.then127, label %cleanup.cont

if.then127:                                       ; preds = %out_retry
  %rq_rcv_buf128 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 2
  %len129 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_rcv_buf128, i32 0, i32 7
  store i32 0, i32* %len129, align 8, !tbaa !161
  %rq_reply_bytes_recvd = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 16
  store i64 0, i64* %rq_reply_bytes_recvd, align 8, !tbaa !142
  %tk_client130 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %27 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client130, align 8, !tbaa !26
  %cl_discrtry = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %27, i32 0, i32 13
  %bf.load131 = load i8, i8* %cl_discrtry, align 8
  %bf.lshr132 = lshr i8 %bf.load131, 1
  %bf.clear133 = and i8 %bf.lshr132, 1
  %bf.cast134 = zext i8 %bf.clear133 to i32
  %tobool135 = icmp ne i32 %bf.cast134, 0
  br i1 %tobool135, label %if.then136, label %cleanup.cont

if.then136:                                       ; preds = %if.then127
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 0
  %28 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %rq_connect_cookie = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 22
  %29 = load i32, i32* %rq_connect_cookie, align 4, !tbaa !144
  call void @xprt_conditional_disconnect(%struct.rpc_xprt* %28, i32 %29)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then136, %if.then127, %out_retry, %if.then115, %do.body105, %if.then91
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @trace_rpc_call_status(%struct.rpc_task* %task) #2 {
entry:
  %call.i = call i32 @atomic_read(%struct.atomic_t* getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_call_status, i64 0, i32 1, i32 0)) #7
  %tobool.i = icmp ne i32 %call.i, 0
  %lnot.ext.i = zext i1 %tobool.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv.i, i64 0) #7
  %cmp.i = icmp sgt i64 %expval.i, 0
  %..i = select i1 %cmp.i, i1 true, i1 false
  br i1 %..i, label %do.body, label %if.end21

do.body:                                          ; preds = %entry
  call void @rcu_read_lock_sched_notrace()
  %0 = load volatile %struct.tracepoint_func*, %struct.tracepoint_func** getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_call_status, i32 0, i32 4), align 8, !tbaa !28
  %call2 = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %land.lhs.true, label %do.end10

land.lhs.true:                                    ; preds = %do.body
  %1 = load i8, i8* @trace_rpc_call_status.__warned, align 1, !tbaa !29, !range !31
  %tobool3 = trunc i8 %1 to i1
  br i1 %tobool3, label %do.end10, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %land.lhs.true
  %call5 = call i32 @rcu_read_lock_sched_held()
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %do.end10, label %if.then7

if.then7:                                         ; preds = %land.lhs.true4
  store i8 1, i8* @trace_rpc_call_status.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.36.302, i32 0, i32 0), i32 36, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end10

do.end10:                                         ; preds = %if.then7, %land.lhs.true4, %land.lhs.true, %do.body
  %tobool11 = icmp ne %struct.tracepoint_func* %0, null
  br i1 %tobool11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %do.end10
  br label %do.body13

do.body13:                                        ; preds = %do.body13, %if.then12
  %it_func_ptr.0 = phi %struct.tracepoint_func* [ %0, %if.then12 ], [ %incdec.ptr, %do.body13 ]
  %func = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 0
  %2 = load i8*, i8** %func, align 8, !tbaa !120
  %data = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 1
  %3 = load i8*, i8** %data, align 8, !tbaa !122
  %4 = bitcast i8* %2 to void (i8*, %struct.rpc_task*)*
  call void %4(i8* %3, %struct.rpc_task* %task)
  %incdec.ptr = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 1
  %func15 = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %incdec.ptr, i32 0, i32 0
  %5 = load i8*, i8** %func15, align 8, !tbaa !120
  %tobool16 = icmp ne i8* %5, null
  br i1 %tobool16, label %do.body13, label %if.end18

if.end18:                                         ; preds = %do.body13, %do.end10
  call void @rcu_read_unlock_sched_notrace()
  br label %if.end21

if.end21:                                         ; preds = %if.end18, %entry
  ret void
}

declare i32 @memcmp(i8*, i8*, i64) #4

declare void @warn_slowpath_null(i8*, i32) #4

; Function Attrs: nounwind uwtable
define internal i32* @rpc_verify_header(%struct.rpc_task* %task) #0 {
entry:
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %0 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %1 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_rcv_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 2
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_rcv_buf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %tk_rqstp1 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %2 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp1, align 8, !tbaa !60
  %rq_rcv_buf2 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %2, i32 0, i32 2
  %len3 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_rcv_buf2, i32 0, i32 7
  %3 = load i32, i32* %len3, align 8, !tbaa !161
  %shr = lshr i32 %3, 2
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  %4 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %5 = bitcast i8* %4 to i32*
  %tk_rqstp4 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %6 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp4, align 8, !tbaa !60
  %rq_rcv_buf5 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %6, i32 0, i32 2
  %len6 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_rcv_buf5, i32 0, i32 7
  %7 = load i32, i32* %len6, align 8, !tbaa !161
  %and = and i32 %7, 3
  %cmp = icmp ne i32 %and, 0
  br i1 %cmp, label %do.body, label %if.end15

do.body:                                          ; preds = %entry
  %8 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and7 = and i32 %8, 2
  %tobool = icmp ne i32 %and7, 0
  %lnot = xor i1 %tobool, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %out_err

if.then10:                                        ; preds = %do.body
  %9 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_err

if.end15:                                         ; preds = %entry
  %sub = sub nsw i32 %shr, 3
  %cmp16 = icmp slt i32 %sub, 0
  br i1 %cmp16, label %do.body448, label %if.end19

if.end19:                                         ; preds = %if.end15
  %add.ptr = getelementptr inbounds i32, i32* %5, i64 1
  %incdec.ptr = getelementptr inbounds i32, i32* %add.ptr, i32 1
  %10 = load i32, i32* %add.ptr, align 4, !tbaa !49
  %call20 = call i32 @__fswab32(i32 %10) #3
  %cmp21 = icmp ne i32 %call20, 1
  br i1 %cmp21, label %do.body24, label %if.end41

do.body24:                                        ; preds = %if.end19
  %11 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and25 = and i32 %11, 2
  %tobool26 = icmp ne i32 %and25, 0
  %lnot27 = xor i1 %tobool26, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %if.then34, label %out_garbage

if.then34:                                        ; preds = %do.body24
  %12 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_garbage

if.end41:                                         ; preds = %if.end19
  %incdec.ptr42 = getelementptr inbounds i32, i32* %incdec.ptr, i32 1
  %13 = load i32, i32* %incdec.ptr, align 4, !tbaa !49
  %call43 = call i32 @__fswab32(i32 %13) #3
  %cmp44 = icmp ne i32 %call43, 0
  br i1 %cmp44, label %if.then46, label %if.end209

if.then46:                                        ; preds = %if.end41
  %dec = add nsw i32 %sub, -1
  %cmp47 = icmp slt i32 %dec, 0
  br i1 %cmp47, label %do.body448, label %if.end50

if.end50:                                         ; preds = %if.then46
  %incdec.ptr51 = getelementptr inbounds i32, i32* %incdec.ptr42, i32 1
  %14 = load i32, i32* %incdec.ptr42, align 4, !tbaa !49
  %call52 = call i32 @__fswab32(i32 %14) #3
  %Pivot = icmp slt i32 %call52, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end50
  %SwitchLeaf2 = icmp eq i32 %call52, 1
  br i1 %SwitchLeaf2, label %sw.epilog, label %do.body70

LeafBlock:                                        ; preds = %if.end50
  %SwitchLeaf = icmp eq i32 %call52, 0
  br i1 %SwitchLeaf, label %do.body53, label %do.body70

do.body53:                                        ; preds = %LeafBlock
  %15 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and54 = and i32 %15, 2
  %tobool55 = icmp ne i32 %and54, 0
  %lnot56 = xor i1 %tobool55, true
  %lnot58 = xor i1 %lnot56, true
  %lnot.ext59 = zext i1 %lnot58 to i32
  %conv60 = sext i32 %lnot.ext59 to i64
  %expval61 = call i64 @llvm.expect.i64(i64 %conv60, i64 0)
  %tobool62 = icmp ne i64 %expval61, 0
  br i1 %tobool62, label %if.then63, label %out_err

if.then63:                                        ; preds = %do.body53
  %16 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_err

do.body70:                                        ; preds = %LeafBlock, %LeafBlock1
  %17 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and71 = and i32 %17, 2
  %tobool72 = icmp ne i32 %and71, 0
  %lnot73 = xor i1 %tobool72, true
  %lnot75 = xor i1 %lnot73, true
  %lnot.ext76 = zext i1 %lnot75 to i32
  %conv77 = sext i32 %lnot.ext76 to i64
  %expval78 = call i64 @llvm.expect.i64(i64 %conv77, i64 0)
  %tobool79 = icmp ne i64 %expval78, 0
  br i1 %tobool79, label %if.then80, label %out_err

if.then80:                                        ; preds = %do.body70
  %18 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_err

sw.epilog:                                        ; preds = %LeafBlock1
  %dec87 = add nsw i32 %dec, -1
  %cmp88 = icmp slt i32 %dec87, 0
  br i1 %cmp88, label %do.body448, label %if.end91

if.end91:                                         ; preds = %sw.epilog
  %19 = load i32, i32* %incdec.ptr51, align 4, !tbaa !49
  %call93 = call i32 @__fswab32(i32 %19) #3
  %Pivot19 = icmp slt i32 %call93, 4
  br i1 %Pivot19, label %NodeBlock8, label %NodeBlock16

NodeBlock16:                                      ; preds = %if.end91
  %Pivot17 = icmp slt i32 %call93, 5
  br i1 %Pivot17, label %sw.bb94, label %NodeBlock14

NodeBlock14:                                      ; preds = %NodeBlock16
  %Pivot15 = icmp slt i32 %call93, 13
  br i1 %Pivot15, label %LeafBlock10, label %LeafBlock12

LeafBlock12:                                      ; preds = %NodeBlock14
  %call93.off = add i32 %call93, -13
  %SwitchLeaf13 = icmp ule i32 %call93.off, 1
  br i1 %SwitchLeaf13, label %sw.bb94, label %do.body174

LeafBlock10:                                      ; preds = %NodeBlock14
  %SwitchLeaf11 = icmp eq i32 %call93, 5
  br i1 %SwitchLeaf11, label %sw.bb157, label %do.body174

NodeBlock8:                                       ; preds = %if.end91
  %Pivot9 = icmp slt i32 %call93, 2
  br i1 %Pivot9, label %LeafBlock4, label %NodeBlock6

NodeBlock6:                                       ; preds = %NodeBlock8
  %Pivot7 = icmp slt i32 %call93, 3
  br i1 %Pivot7, label %sw.bb94, label %sw.bb122

LeafBlock4:                                       ; preds = %NodeBlock8
  %SwitchLeaf5 = icmp eq i32 %call93, 1
  br i1 %SwitchLeaf5, label %sw.bb122, label %do.body174

sw.bb94:                                          ; preds = %NodeBlock6, %LeafBlock12, %NodeBlock16
  %tk_cred_retry = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 20
  %bf.load = load i8, i8* %tk_cred_retry, align 2
  %bf.lshr = lshr i8 %bf.load, 4
  %bf.clear = and i8 %bf.lshr, 3
  %tobool95 = icmp ne i8 %bf.clear, 0
  br i1 %tobool95, label %if.end97, label %do.body192

if.end97:                                         ; preds = %sw.bb94
  %tk_cred_retry98 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 20
  %bf.load99 = load i8, i8* %tk_cred_retry98, align 2
  %bf.lshr100 = lshr i8 %bf.load99, 4
  %bf.clear101 = and i8 %bf.lshr100, 3
  %dec102 = add i8 %bf.clear101, -1
  %bf.load103 = load i8, i8* %tk_cred_retry98, align 2
  %bf.value = and i8 %dec102, 3
  %bf.shl = shl i8 %bf.value, 4
  %bf.clear104 = and i8 %bf.load103, -49
  %bf.set = or i8 %bf.clear104, %bf.shl
  store i8 %bf.set, i8* %tk_cred_retry98, align 2
  %20 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and106 = and i32 %20, 2
  %tobool107 = icmp ne i32 %and106, 0
  %lnot108 = xor i1 %tobool107, true
  %lnot110 = xor i1 %lnot108, true
  %lnot.ext111 = zext i1 %lnot110 to i32
  %conv112 = sext i32 %lnot.ext111 to i64
  %expval113 = call i64 @llvm.expect.i64(i64 %conv112, i64 0)
  %tobool114 = icmp ne i64 %expval113, 0
  br i1 %tobool114, label %if.then115, label %do.end121

if.then115:                                       ; preds = %if.end97
  %21 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end121

do.end121:                                        ; preds = %if.then115, %if.end97
  call void @rpcauth_invalcred(%struct.rpc_task* %task)
  call void @xprt_release(%struct.rpc_task* %task)
  br label %out_retry

sw.bb122:                                         ; preds = %LeafBlock4, %NodeBlock6
  %tk_garb_retry = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 20
  %bf.load123 = load i8, i8* %tk_garb_retry, align 2
  %bf.lshr124 = lshr i8 %bf.load123, 2
  %bf.clear125 = and i8 %bf.lshr124, 3
  %tobool126 = icmp ne i8 %bf.clear125, 0
  br i1 %tobool126, label %if.end128, label %do.body192

if.end128:                                        ; preds = %sw.bb122
  %tk_garb_retry129 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 20
  %bf.load130 = load i8, i8* %tk_garb_retry129, align 2
  %bf.lshr131 = lshr i8 %bf.load130, 2
  %bf.clear132 = and i8 %bf.lshr131, 3
  %dec133 = add i8 %bf.clear132, -1
  %bf.load134 = load i8, i8* %tk_garb_retry129, align 2
  %bf.value135 = and i8 %dec133, 3
  %bf.shl136 = shl i8 %bf.value135, 2
  %bf.clear137 = and i8 %bf.load134, -13
  %bf.set138 = or i8 %bf.clear137, %bf.shl136
  store i8 %bf.set138, i8* %tk_garb_retry129, align 2
  %22 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and140 = and i32 %22, 2
  %tobool141 = icmp ne i32 %and140, 0
  %lnot142 = xor i1 %tobool141, true
  %lnot144 = xor i1 %lnot142, true
  %lnot.ext145 = zext i1 %lnot144 to i32
  %conv146 = sext i32 %lnot.ext145 to i64
  %expval147 = call i64 @llvm.expect.i64(i64 %conv146, i64 0)
  %tobool148 = icmp ne i64 %expval147, 0
  br i1 %tobool148, label %if.then149, label %out_retry

if.then149:                                       ; preds = %if.end128
  %23 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_retry

sw.bb157:                                         ; preds = %LeafBlock10
  call void @rcu_read_lock()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 4
  %24 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call159 = call i32 @debug_lockdep_rcu_enabled()
  %tobool160 = icmp ne i32 %call159, 0
  br i1 %tobool160, label %land.lhs.true, label %do.end171

land.lhs.true:                                    ; preds = %sw.bb157
  %25 = load i8, i8* @rpc_verify_header.__warned, align 1, !tbaa !29, !range !31
  %tobool161 = trunc i8 %25 to i1
  br i1 %tobool161, label %do.end171, label %land.lhs.true162

land.lhs.true162:                                 ; preds = %land.lhs.true
  %call163 = call i32 @rcu_read_lock_held()
  %tobool164 = icmp ne i32 %call163, 0
  br i1 %tobool164, label %do.end171, label %if.then165

if.then165:                                       ; preds = %land.lhs.true162
  store i8 1, i8* @rpc_verify_header.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 2134, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end171

do.end171:                                        ; preds = %if.then165, %land.lhs.true162, %land.lhs.true, %sw.bb157
  %26 = call i32 (i8*, ...) @printk(i8* null)
  call void @rcu_read_unlock()
  br label %do.body192

do.body174:                                       ; preds = %LeafBlock4, %LeafBlock10, %LeafBlock12
  %27 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and175 = and i32 %27, 2
  %tobool176 = icmp ne i32 %and175, 0
  %lnot177 = xor i1 %tobool176, true
  %lnot179 = xor i1 %lnot177, true
  %lnot.ext180 = zext i1 %lnot179 to i32
  %conv181 = sext i32 %lnot.ext180 to i64
  %expval182 = call i64 @llvm.expect.i64(i64 %conv181, i64 0)
  %tobool183 = icmp ne i64 %expval182, 0
  br i1 %tobool183, label %if.then184, label %do.body192

if.then184:                                       ; preds = %do.body174
  %28 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.body192

do.body192:                                       ; preds = %if.then184, %do.body174, %do.end171, %sw.bb122, %sw.bb94
  %error.0 = phi i32 [ -13, %do.end171 ], [ -13, %sw.bb94 ], [ -13, %sw.bb122 ], [ -5, %if.then184 ], [ -5, %do.body174 ]
  %29 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and193 = and i32 %29, 2
  %tobool194 = icmp ne i32 %and193, 0
  %lnot195 = xor i1 %tobool194, true
  %lnot197 = xor i1 %lnot195, true
  %lnot.ext198 = zext i1 %lnot197 to i32
  %conv199 = sext i32 %lnot.ext198 to i64
  %expval200 = call i64 @llvm.expect.i64(i64 %conv199, i64 0)
  %tobool201 = icmp ne i64 %expval200, 0
  br i1 %tobool201, label %if.then202, label %out_err

if.then202:                                       ; preds = %do.body192
  %30 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_err

if.end209:                                        ; preds = %if.end41
  %call210 = call i32* @rpcauth_checkverf(%struct.rpc_task* %task, i32* %incdec.ptr42)
  %tobool211 = icmp ne i32* %call210, null
  br i1 %tobool211, label %if.end230, label %do.body213

do.body213:                                       ; preds = %if.end209
  %31 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and214 = and i32 %31, 2
  %tobool215 = icmp ne i32 %and214, 0
  %lnot216 = xor i1 %tobool215, true
  %lnot218 = xor i1 %lnot216, true
  %lnot.ext219 = zext i1 %lnot218 to i32
  %conv220 = sext i32 %lnot.ext219 to i64
  %expval221 = call i64 @llvm.expect.i64(i64 %conv220, i64 0)
  %tobool222 = icmp ne i64 %expval221, 0
  br i1 %tobool222, label %if.then223, label %out_garbage

if.then223:                                       ; preds = %do.body213
  %32 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_garbage

if.end230:                                        ; preds = %if.end209
  %iov_base231 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  %33 = load i8*, i8** %iov_base231, align 8, !tbaa !147
  %34 = bitcast i8* %33 to i32*
  %sub.ptr.lhs.cast = ptrtoint i32* %call210 to i64
  %sub.ptr.rhs.cast = ptrtoint i32* %34 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %sub232 = sub nsw i64 %sub.ptr.div, 1
  %conv233 = trunc i64 %sub232 to i32
  %cmp234 = icmp slt i32 %conv233, 0
  br i1 %cmp234, label %do.body448, label %if.end237

if.end237:                                        ; preds = %if.end230
  %incdec.ptr238 = getelementptr inbounds i32, i32* %call210, i32 1
  %35 = load i32, i32* %call210, align 4, !tbaa !49
  %call239 = call i32 @__fswab32(i32 %35) #3
  %Pivot32 = icmp slt i32 %call239, 2
  br i1 %Pivot32, label %NodeBlock23, label %NodeBlock29

NodeBlock29:                                      ; preds = %if.end237
  %Pivot30 = icmp slt i32 %call239, 3
  br i1 %Pivot30, label %do.body279, label %NodeBlock27

NodeBlock27:                                      ; preds = %NodeBlock29
  %Pivot28 = icmp slt i32 %call239, 4
  br i1 %Pivot28, label %do.body317, label %LeafBlock25

LeafBlock25:                                      ; preds = %NodeBlock27
  %SwitchLeaf26 = icmp eq i32 %call239, 4
  br i1 %SwitchLeaf26, label %do.body357, label %do.body375

NodeBlock23:                                      ; preds = %if.end237
  %Pivot24 = icmp slt i32 %call239, 1
  br i1 %Pivot24, label %LeafBlock21, label %do.body242

LeafBlock21:                                      ; preds = %NodeBlock23
  %SwitchLeaf22 = icmp eq i32 %call239, 0
  br i1 %SwitchLeaf22, label %cleanup, label %do.body375

do.body242:                                       ; preds = %NodeBlock23
  %36 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and243 = and i32 %36, 2
  %tobool244 = icmp ne i32 %and243, 0
  %lnot245 = xor i1 %tobool244, true
  %lnot247 = xor i1 %lnot245, true
  %lnot.ext248 = zext i1 %lnot247 to i32
  %conv249 = sext i32 %lnot.ext248 to i64
  %expval250 = call i64 @llvm.expect.i64(i64 %conv249, i64 0)
  %tobool251 = icmp ne i64 %expval250, 0
  br i1 %tobool251, label %if.then252, label %out_err

if.then252:                                       ; preds = %do.body242
  call void @rcu_read_lock()
  %cl_xprt256 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 4
  %37 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt256, align 8, !tbaa !28
  %call258 = call i32 @debug_lockdep_rcu_enabled()
  %tobool259 = icmp ne i32 %call258, 0
  br i1 %tobool259, label %land.lhs.true260, label %do.end271

land.lhs.true260:                                 ; preds = %if.then252
  %38 = load i8, i8* @rpc_verify_header.__warned.63, align 1, !tbaa !29, !range !31
  %tobool261 = trunc i8 %38 to i1
  br i1 %tobool261, label %do.end271, label %land.lhs.true262

land.lhs.true262:                                 ; preds = %land.lhs.true260
  %call263 = call i32 @rcu_read_lock_held()
  %tobool264 = icmp ne i32 %call263, 0
  br i1 %tobool264, label %do.end271, label %if.then265

if.then265:                                       ; preds = %land.lhs.true262
  store i8 1, i8* @rpc_verify_header.__warned.63, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 2161, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end271

do.end271:                                        ; preds = %if.then265, %land.lhs.true262, %land.lhs.true260, %if.then252
  %39 = call i32 (i8*, ...) @printk(i8* null)
  call void @rcu_read_unlock()
  br label %out_err

do.body279:                                       ; preds = %NodeBlock29
  %40 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and280 = and i32 %40, 2
  %tobool281 = icmp ne i32 %and280, 0
  %lnot282 = xor i1 %tobool281, true
  %lnot284 = xor i1 %lnot282, true
  %lnot.ext285 = zext i1 %lnot284 to i32
  %conv286 = sext i32 %lnot.ext285 to i64
  %expval287 = call i64 @llvm.expect.i64(i64 %conv286, i64 0)
  %tobool288 = icmp ne i64 %expval287, 0
  br i1 %tobool288, label %if.then289, label %out_err

if.then289:                                       ; preds = %do.body279
  call void @rcu_read_lock()
  %cl_xprt294 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 4
  %41 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt294, align 8, !tbaa !28
  %call296 = call i32 @debug_lockdep_rcu_enabled()
  %tobool297 = icmp ne i32 %call296, 0
  br i1 %tobool297, label %land.lhs.true298, label %do.end309

land.lhs.true298:                                 ; preds = %if.then289
  %42 = load i8, i8* @rpc_verify_header.__warned.65, align 1, !tbaa !29, !range !31
  %tobool299 = trunc i8 %42 to i1
  br i1 %tobool299, label %do.end309, label %land.lhs.true300

land.lhs.true300:                                 ; preds = %land.lhs.true298
  %call301 = call i32 @rcu_read_lock_held()
  %tobool302 = icmp ne i32 %call301, 0
  br i1 %tobool302, label %do.end309, label %if.then303

if.then303:                                       ; preds = %land.lhs.true300
  store i8 1, i8* @rpc_verify_header.__warned.65, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 2169, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end309

do.end309:                                        ; preds = %if.then303, %land.lhs.true300, %land.lhs.true298, %if.then289
  %43 = call i32 (i8*, ...) @printk(i8* null)
  call void @rcu_read_unlock()
  br label %out_err

do.body317:                                       ; preds = %NodeBlock27
  %44 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and318 = and i32 %44, 2
  %tobool319 = icmp ne i32 %and318, 0
  %lnot320 = xor i1 %tobool319, true
  %lnot322 = xor i1 %lnot320, true
  %lnot.ext323 = zext i1 %lnot322 to i32
  %conv324 = sext i32 %lnot.ext323 to i64
  %expval325 = call i64 @llvm.expect.i64(i64 %conv324, i64 0)
  %tobool326 = icmp ne i64 %expval325, 0
  br i1 %tobool326, label %if.then327, label %out_err

if.then327:                                       ; preds = %do.body317
  call void @rcu_read_lock()
  call void @rpc_proc_name(%struct.rpc_task* %task)
  %cl_xprt334 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 4
  %45 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt334, align 8, !tbaa !28
  %call336 = call i32 @debug_lockdep_rcu_enabled()
  %tobool337 = icmp ne i32 %call336, 0
  br i1 %tobool337, label %land.lhs.true338, label %do.end349

land.lhs.true338:                                 ; preds = %if.then327
  %46 = load i8, i8* @rpc_verify_header.__warned.67, align 1, !tbaa !29, !range !31
  %tobool339 = trunc i8 %46 to i1
  br i1 %tobool339, label %do.end349, label %land.lhs.true340

land.lhs.true340:                                 ; preds = %land.lhs.true338
  %call341 = call i32 @rcu_read_lock_held()
  %tobool342 = icmp ne i32 %call341, 0
  br i1 %tobool342, label %do.end349, label %if.then343

if.then343:                                       ; preds = %land.lhs.true340
  store i8 1, i8* @rpc_verify_header.__warned.67, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 2178, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end349

do.end349:                                        ; preds = %if.then343, %land.lhs.true340, %land.lhs.true338, %if.then327
  %47 = call i32 (i8*, ...) @printk(i8* null)
  call void @rcu_read_unlock()
  br label %out_err

do.body357:                                       ; preds = %LeafBlock25
  %48 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and358 = and i32 %48, 2
  %tobool359 = icmp ne i32 %and358, 0
  %lnot360 = xor i1 %tobool359, true
  %lnot362 = xor i1 %lnot360, true
  %lnot.ext363 = zext i1 %lnot362 to i32
  %conv364 = sext i32 %lnot.ext363 to i64
  %expval365 = call i64 @llvm.expect.i64(i64 %conv364, i64 0)
  %tobool366 = icmp ne i64 %expval365, 0
  br i1 %tobool366, label %if.then367, label %out_garbage

if.then367:                                       ; preds = %do.body357
  %49 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_garbage

do.body375:                                       ; preds = %LeafBlock21, %LeafBlock25
  %50 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and376 = and i32 %50, 2
  %tobool377 = icmp ne i32 %and376, 0
  %lnot378 = xor i1 %tobool377, true
  %lnot380 = xor i1 %lnot378, true
  %lnot.ext381 = zext i1 %lnot380 to i32
  %conv382 = sext i32 %lnot.ext381 to i64
  %expval383 = call i64 @llvm.expect.i64(i64 %conv382, i64 0)
  %tobool384 = icmp ne i64 %expval383, 0
  br i1 %tobool384, label %if.then385, label %out_garbage

if.then385:                                       ; preds = %do.body375
  %51 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_garbage

out_garbage:                                      ; preds = %if.then458, %do.body448, %if.then385, %do.body375, %if.then367, %do.body357, %if.then223, %do.body213, %if.then34, %do.body24
  %cl_stats = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 11
  %52 = load %struct.rpc_stat*, %struct.rpc_stat** %cl_stats, align 8, !tbaa !52
  %rpcgarbage = getelementptr inbounds %struct.rpc_stat, %struct.rpc_stat* %52, i32 0, i32 9
  %53 = load i32, i32* %rpcgarbage, align 8, !tbaa !162
  %inc = add i32 %53, 1
  store i32 %inc, i32* %rpcgarbage, align 8, !tbaa !162
  %tk_garb_retry393 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 20
  %bf.load394 = load i8, i8* %tk_garb_retry393, align 2
  %bf.lshr395 = lshr i8 %bf.load394, 2
  %bf.clear396 = and i8 %bf.lshr395, 3
  %tobool397 = icmp ne i8 %bf.clear396, 0
  br i1 %tobool397, label %if.then398, label %out_err

if.then398:                                       ; preds = %out_garbage
  %tk_garb_retry399 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 20
  %bf.load400 = load i8, i8* %tk_garb_retry399, align 2
  %bf.lshr401 = lshr i8 %bf.load400, 2
  %bf.clear402 = and i8 %bf.lshr401, 3
  %dec403 = add i8 %bf.clear402, -1
  %bf.load404 = load i8, i8* %tk_garb_retry399, align 2
  %bf.value405 = and i8 %dec403, 3
  %bf.shl406 = shl i8 %bf.value405, 2
  %bf.clear407 = and i8 %bf.load404, -13
  %bf.set408 = or i8 %bf.clear407, %bf.shl406
  store i8 %bf.set408, i8* %tk_garb_retry399, align 2
  %54 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and410 = and i32 %54, 2
  %tobool411 = icmp ne i32 %and410, 0
  %lnot412 = xor i1 %tobool411, true
  %lnot414 = xor i1 %lnot412, true
  %lnot.ext415 = zext i1 %lnot414 to i32
  %conv416 = sext i32 %lnot.ext415 to i64
  %expval417 = call i64 @llvm.expect.i64(i64 %conv416, i64 0)
  %tobool418 = icmp ne i64 %expval417, 0
  br i1 %tobool418, label %if.then419, label %out_retry

if.then419:                                       ; preds = %if.then398
  %55 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_retry

out_retry:                                        ; preds = %if.then419, %if.then398, %if.then149, %if.end128, %do.end121
  %call_bind.sink = phi void (%struct.rpc_task*)* [ @call_reserve, %do.end121 ], [ @call_bind, %if.then149 ], [ @call_bind, %if.end128 ], [ @call_bind, %if.then419 ], [ @call_bind, %if.then398 ]
  %tk_action426 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* %call_bind.sink, void (%struct.rpc_task*)** %tk_action426, align 8, !tbaa !20
  br label %cleanup.sink.split

out_err:                                          ; preds = %out_garbage, %do.end349, %do.body317, %do.end309, %do.body279, %do.end271, %do.body242, %if.then202, %do.body192, %if.then80, %do.body70, %if.then63, %do.body53, %if.then10, %do.body
  %error.1 = phi i32 [ -93, %if.then63 ], [ -93, %do.body53 ], [ %error.0, %if.then202 ], [ %error.0, %do.body192 ], [ -96, %do.end271 ], [ -96, %do.body242 ], [ -93, %do.end309 ], [ -93, %do.body279 ], [ -95, %do.end349 ], [ -95, %do.body317 ], [ -5, %out_garbage ], [ -5, %do.body70 ], [ -5, %if.then80 ], [ -5, %do.body ], [ -5, %if.then10 ]
  call void @rpc_exit(%struct.rpc_task* %task, i32 %error.1)
  %56 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and430 = and i32 %56, 2
  %tobool431 = icmp ne i32 %and430, 0
  %lnot432 = xor i1 %tobool431, true
  %lnot434 = xor i1 %lnot432, true
  %lnot.ext435 = zext i1 %lnot434 to i32
  %conv436 = sext i32 %lnot.ext435 to i64
  %expval437 = call i64 @llvm.expect.i64(i64 %conv436, i64 0)
  %tobool438 = icmp ne i64 %expval437, 0
  br i1 %tobool438, label %if.then439, label %do.end445

if.then439:                                       ; preds = %out_err
  %57 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end445

do.end445:                                        ; preds = %if.then439, %out_err
  %conv446 = sext i32 %error.1 to i64
  br label %cleanup.sink.split

do.body448:                                       ; preds = %if.end230, %sw.epilog, %if.then46, %if.end15
  %58 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and449 = and i32 %58, 2
  %tobool450 = icmp ne i32 %and449, 0
  %lnot451 = xor i1 %tobool450, true
  %lnot453 = xor i1 %lnot451, true
  %lnot.ext454 = zext i1 %lnot453 to i32
  %conv455 = sext i32 %lnot.ext454 to i64
  %expval456 = call i64 @llvm.expect.i64(i64 %conv455, i64 0)
  %tobool457 = icmp ne i64 %expval456, 0
  br i1 %tobool457, label %if.then458, label %out_garbage

if.then458:                                       ; preds = %do.body448
  %59 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_garbage

cleanup.sink.split:                               ; preds = %do.end445, %out_retry
  %conv446.sink = phi i64 [ %conv446, %do.end445 ], [ -11, %out_retry ]
  %call447 = call i8* @ERR_PTR(i64 %conv446.sink)
  %60 = bitcast i8* %call447 to i32*
  br label %cleanup

cleanup:                                          ; preds = %cleanup.sink.split, %LeafBlock21
  %retval.0 = phi i32* [ %incdec.ptr238, %LeafBlock21 ], [ %60, %cleanup.sink.split ]
  ret i32* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR(i64 %error) #2 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.rpc_cred* @get_rpccred(%struct.rpc_cred* %cred) #2 {
entry:
  %cr_count = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 8
  call void @atomic_inc(%struct.atomic_t* %cr_count)
  ret %struct.rpc_cred* %cred
}

; Function Attrs: nounwind uwtable
define void @rpc_task_release_client(%struct.rpc_task* %task) #0 {
entry:
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %0 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %cmp = icmp ne %struct.rpc_clnt* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %cl_lock = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 3
  call void @spin_lock(%struct.spinlock* %cl_lock)
  %tk_task = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 1
  call void @list_del(%struct.list_head* %tk_task)
  %cl_lock1 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 3
  call void @spin_unlock(%struct.spinlock* %cl_lock1)
  %tk_client2 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  store %struct.rpc_clnt* null, %struct.rpc_clnt** %tk_client2, align 8, !tbaa !26
  call void @rpc_release_client(%struct.rpc_clnt* %0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @sk_memalloc_socks() #2 {
entry:
  %call.i = call i32 @atomic_read(%struct.atomic_t* getelementptr inbounds (%struct.arch_spinlock, %struct.arch_spinlock* @memalloc_socks, i64 0, i32 0)) #7
  %tobool.i = icmp ne i32 %call.i, 0
  %lnot.ext.i = zext i1 %tobool.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv.i, i64 0) #7
  %cmp.i = icmp sgt i64 %expval.i, 0
  %..i = select i1 %cmp.i, i1 true, i1 false
  %conv = zext i1 %..i to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #2 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !163
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

declare void @_raw_spin_unlock(%struct.raw_spinlock*) #4 section ".spinlock.text"

declare void @__list_add(%struct.list_head*, %struct.list_head*, %struct.list_head*) #4

declare void @_raw_spin_lock(%struct.raw_spinlock*) #4 section ".spinlock.text"

declare void @list_del(%struct.list_head*) #4

; Function Attrs: nounwind uwtable
define void @rpc_release_client(%struct.rpc_clnt* %clnt) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %cl_tasks = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 2
  %call3 = call i32 @list_empty(%struct.list_head* %cl_tasks)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %do.end
  call void @__wake_up(%struct.__wait_queue_head* @destroy_wait, i32 3, i32 1, i8* null)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %do.end
  %cl_count = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 0
  %call7 = call i32 @atomic_dec_and_test(%struct.atomic_t* %cl_count)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end6
  call void @rpc_free_auth(%struct.rpc_clnt* %clnt)
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end6
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty(%struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_dec_and_test(%struct.atomic_t* %v) #2 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0; sete $1", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32* %counter) #7, !srcloc !165
  %0 = load i8, i8* %c, align 1, !tbaa !166
  %conv = zext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define internal void @rpc_free_auth(%struct.rpc_clnt* %clnt) #0 {
entry:
  %cl_auth = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 10
  %0 = load %struct.rpc_auth*, %struct.rpc_auth** %cl_auth, align 8, !tbaa !167
  %cmp = icmp eq %struct.rpc_auth* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @rpc_free_client(%struct.rpc_clnt* %clnt)
  br label %if.end5

if.end:                                           ; preds = %entry
  %cl_count = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 0
  call void @atomic_inc(%struct.atomic_t* %cl_count)
  %cl_auth1 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 10
  %1 = load %struct.rpc_auth*, %struct.rpc_auth** %cl_auth1, align 8, !tbaa !167
  call void @rpcauth_release(%struct.rpc_auth* %1)
  %cl_auth2 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 10
  store %struct.rpc_auth* null, %struct.rpc_auth** %cl_auth2, align 8, !tbaa !167
  %cl_count3 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 0
  %call = call i32 @atomic_dec_and_test(%struct.atomic_t* %cl_count3)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  call void @rpc_free_client(%struct.rpc_clnt* %clnt)
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_free_client(%struct.rpc_clnt* %clnt) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end16

if.then:                                          ; preds = %entry
  call void @rcu_read_lock()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 4
  %1 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool4 = icmp ne i32 %call, 0
  br i1 %tobool4, label %land.lhs.true, label %do.end12

land.lhs.true:                                    ; preds = %if.then
  %2 = load i8, i8* @rpc_free_client.__warned, align 1, !tbaa !29, !range !31
  %tobool5 = trunc i8 %2 to i1
  br i1 %tobool5, label %do.end12, label %land.lhs.true6

land.lhs.true6:                                   ; preds = %land.lhs.true
  %call7 = call i32 @rcu_read_lock_held()
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %do.end12, label %if.then9

if.then9:                                         ; preds = %land.lhs.true6
  store i8 1, i8* @rpc_free_client.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 637, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end12

do.end12:                                         ; preds = %if.then9, %land.lhs.true6, %land.lhs.true, %if.then
  %3 = call i32 (i8*, ...) @printk(i8* null)
  call void @rcu_read_unlock()
  br label %do.end16

do.end16:                                         ; preds = %do.end12, %entry
  %cl_parent = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 19
  %4 = load %struct.rpc_clnt*, %struct.rpc_clnt** %cl_parent, align 8, !tbaa !168
  %cmp = icmp ne %struct.rpc_clnt* %4, %clnt
  br i1 %cmp, label %if.then18, label %if.end20

if.then18:                                        ; preds = %do.end16
  %cl_parent19 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 19
  %5 = load %struct.rpc_clnt*, %struct.rpc_clnt** %cl_parent19, align 8, !tbaa !168
  call void @rpc_release_client(%struct.rpc_clnt* %5)
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %do.end16
  call void @rpc_unregister_client(%struct.rpc_clnt* %clnt)
  call void @rpc_clnt_remove_pipedir(%struct.rpc_clnt* %clnt)
  %cl_metrics = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 12
  %6 = load %struct.rpc_iostats*, %struct.rpc_iostats** %cl_metrics, align 8, !tbaa !169
  call void @rpc_free_iostats(%struct.rpc_iostats* %6)
  %cl_principal = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 23
  %7 = load i8*, i8** %cl_principal, align 8, !tbaa !170
  call void @kfree(i8* %7)
  %cl_metrics21 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 12
  store %struct.rpc_iostats* null, %struct.rpc_iostats** %cl_metrics21, align 8, !tbaa !169
  %cl_xprt23 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 4
  %8 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt23, align 8, !tbaa !28
  %call25 = call i32 @debug_lockdep_rcu_enabled()
  %tobool26 = icmp ne i32 %call25, 0
  br i1 %tobool26, label %land.lhs.true27, label %do.end38

land.lhs.true27:                                  ; preds = %if.end20
  %9 = load i8, i8* @rpc_free_client.__warned.24, align 1, !tbaa !29, !range !31
  %tobool28 = trunc i8 %9 to i1
  br i1 %tobool28, label %do.end38, label %land.lhs.true29

land.lhs.true29:                                  ; preds = %land.lhs.true27
  %call30 = call i32 @rcu_read_lock_held()
  br label %do.end38

do.end38:                                         ; preds = %land.lhs.true29, %land.lhs.true27, %if.end20
  call void @xprt_put(%struct.rpc_xprt* %8)
  call void @rpciod_down()
  %10 = bitcast %struct.rpc_clnt* %clnt to i8*
  call void @kfree(i8* %10)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_unregister_client(%struct.rpc_clnt* %clnt) #0 {
entry:
  %call = call %struct.net* @rpc_net_ns(%struct.rpc_clnt* %clnt)
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call1 = call i8* @net_generic(%struct.net* %call, i32 %0)
  %1 = bitcast i8* %call1 to %struct.sunrpc_net*
  %rpc_client_lock = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 8
  call void @spin_lock(%struct.spinlock* %rpc_client_lock)
  %cl_clients = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 1
  call void @list_del(%struct.list_head* %cl_clients)
  %rpc_client_lock2 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 8
  call void @spin_unlock(%struct.spinlock* %rpc_client_lock2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_clnt_remove_pipedir(%struct.rpc_clnt* %clnt) #0 {
entry:
  %call = call %struct.net* @rpc_net_ns(%struct.rpc_clnt* %clnt)
  %call1 = call %struct.super_block* @rpc_get_sb_net(%struct.net* %call)
  %tobool = icmp ne %struct.super_block* %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__rpc_clnt_remove_pipedir(%struct.rpc_clnt* %clnt)
  call void @rpc_put_sb_net(%struct.net* %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @kfree(i8*) #4

; Function Attrs: nounwind uwtable
define %struct.net* @rpc_net_ns(%struct.rpc_clnt* %clnt) #0 {
entry:
  call void @rcu_read_lock()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 4
  %0 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end7

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @rpc_net_ns.__warned, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %do.end7, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.end7, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rpc_net_ns.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 1173, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end7

do.end7:                                          ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %xprt_net = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 40
  %2 = load %struct.net*, %struct.net** %xprt_net, align 8, !tbaa !171
  call void @rcu_read_unlock()
  ret %struct.net* %2
}

; Function Attrs: nounwind uwtable
define internal void @__rpc_clnt_remove_pipedir(%struct.rpc_clnt* %clnt) #0 {
entry:
  %cl_dentry = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 18
  %0 = load %struct.dentry*, %struct.dentry** %cl_dentry, align 8, !tbaa !172
  %tobool = icmp ne %struct.dentry* %0, null
  br i1 %tobool, label %if.then, label %if.end10

if.then:                                          ; preds = %entry
  %cl_auth = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 10
  %1 = load %struct.rpc_auth*, %struct.rpc_auth** %cl_auth, align 8, !tbaa !167
  %tobool1 = icmp ne %struct.rpc_auth* %1, null
  br i1 %tobool1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %cl_auth2 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 10
  %2 = load %struct.rpc_auth*, %struct.rpc_auth** %cl_auth2, align 8, !tbaa !167
  %au_ops = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %2, i32 0, i32 4
  %3 = load %struct.rpc_authops*, %struct.rpc_authops** %au_ops, align 8, !tbaa !173
  %pipes_destroy = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %3, i32 0, i32 8
  %4 = load void (%struct.rpc_auth*)*, void (%struct.rpc_auth*)** %pipes_destroy, align 8, !tbaa !174
  %tobool3 = icmp ne void (%struct.rpc_auth*)* %4, null
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %land.lhs.true
  %cl_auth5 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 10
  %5 = load %struct.rpc_auth*, %struct.rpc_auth** %cl_auth5, align 8, !tbaa !167
  %au_ops6 = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %5, i32 0, i32 4
  %6 = load %struct.rpc_authops*, %struct.rpc_authops** %au_ops6, align 8, !tbaa !173
  %pipes_destroy7 = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %6, i32 0, i32 8
  %7 = load void (%struct.rpc_auth*)*, void (%struct.rpc_auth*)** %pipes_destroy7, align 8, !tbaa !174
  %cl_auth8 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 10
  %8 = load %struct.rpc_auth*, %struct.rpc_auth** %cl_auth8, align 8, !tbaa !167
  call void %7(%struct.rpc_auth* %8)
  br label %if.end

if.end:                                           ; preds = %if.then4, %land.lhs.true, %if.then
  %cl_dentry9 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 18
  %9 = load %struct.dentry*, %struct.dentry** %cl_dentry9, align 8, !tbaa !172
  %call = call i32 @rpc_remove_client_dir(%struct.dentry* %9)
  br label %if.end10

if.end10:                                         ; preds = %if.end, %entry
  %cl_dentry11 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 18
  store %struct.dentry* null, %struct.dentry** %cl_dentry11, align 8, !tbaa !172
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @net_generic(%struct.net* %net, i32 %id) #2 {
entry:
  call void @rcu_read_lock()
  %gen = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 37
  %0 = load volatile %struct.net_generic*, %struct.net_generic** %gen, align 16, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.body8

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @net_generic.__warned, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %do.body8, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.body8, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @net_generic.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 40, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.body8

do.body8:                                         ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %cmp = icmp eq i32 %id, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.body8
  %len = getelementptr inbounds %struct.net_generic, %struct.net_generic* %0, i32 0, i32 0
  %2 = load i32, i32* %len, align 8, !tbaa !176
  %cmp9 = icmp ugt i32 %id, %2
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %do.body8
  %3 = phi i1 [ true, %do.body8 ], [ %cmp9, %lor.rhs ]
  %lnot = xor i1 %3, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %do.body13, label %do.end21

do.body13:                                        ; preds = %lor.end
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 41, i64 12) #7, !srcloc !178
  br label %do.body14

do.body14:                                        ; preds = %do.body14, %do.body13
  br label %do.body14

do.end21:                                         ; preds = %lor.end
  %ptr22 = getelementptr inbounds %struct.net_generic, %struct.net_generic* %0, i32 0, i32 2
  %sub = sub nsw i32 %id, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [0 x i8*], [0 x i8*]* %ptr22, i64 0, i64 %idxprom
  %4 = load i8*, i8** %arrayidx, align 8, !tbaa !28
  call void @rcu_read_unlock()
  %tobool24 = icmp ne i8* %4, null
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %do.body35, label %do.end43

do.body35:                                        ; preds = %do.end21
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 45, i64 12) #7, !srcloc !179
  br label %do.body36

do.body36:                                        ; preds = %do.body36, %do.body35
  br label %do.body36

do.end43:                                         ; preds = %do.end21
  ret i8* %4
}

; Function Attrs: nounwind uwtable
define internal void @rpc_default_callback(%struct.rpc_task* %task, i8* %data) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpcproc_encode_null(i8* %rqstp, %struct.xdr_stream* %xdr, i8* %obj) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rpcproc_decode_null(i8* %rqstp, %struct.xdr_stream* %xdr, i8* %obj) #0 {
entry:
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @rpc_restart_call(%struct.rpc_task* %task) #0 {
entry:
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %0 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 256
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_start, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 1, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @rpc_restart_call_prepare(%struct.rpc_task* %task) #0 {
entry:
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %0 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 256
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_start, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  %tk_ops = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 7
  %1 = load %struct.rpc_call_ops*, %struct.rpc_call_ops** %tk_ops, align 8, !tbaa !180
  %rpc_call_prepare = getelementptr inbounds %struct.rpc_call_ops, %struct.rpc_call_ops* %1, i32 0, i32 0
  %2 = load void (%struct.rpc_task*, i8*)*, void (%struct.rpc_task*, i8*)** %rpc_call_prepare, align 8, !tbaa !181
  %cmp = icmp ne void (%struct.rpc_task*, i8*)* %2, null
  br i1 %cmp, label %if.then2, label %return

if.then2:                                         ; preds = %if.end
  %tk_action3 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @rpc_prepare_task, void (%struct.rpc_task*)** %tk_action3, align 8, !tbaa !20
  br label %return

return:                                           ; preds = %if.then2, %if.end, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ 1, %if.then2 ], [ 1, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i64 @rpc_get_timeout(%struct.rpc_clnt* %clnt) #0 {
entry:
  call void @rcu_read_lock()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 4
  %0 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end7

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @rpc_get_timeout.__warned, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %do.end7, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.end7, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rpc_get_timeout.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 1208, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end7

do.end7:                                          ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 2
  %2 = load %struct.rpc_timeout*, %struct.rpc_timeout** %timeout, align 8, !tbaa !183
  %to_initval = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %2, i32 0, i32 0
  %3 = load i64, i64* %to_initval, align 8, !tbaa !184
  call void @rcu_read_unlock()
  ret i64 %3
}

; Function Attrs: nounwind uwtable
define i64 @rpc_max_payload(%struct.rpc_clnt* %clnt) #0 {
entry:
  call void @rcu_read_lock()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 4
  %0 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end7

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @rpc_max_payload.__warned, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %do.end7, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.end7, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rpc_max_payload.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 1193, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end7

do.end7:                                          ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %max_payload = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 8
  %2 = load i64, i64* %max_payload, align 8, !tbaa !185
  call void @rcu_read_unlock()
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define i32 @rpc_protocol(%struct.rpc_clnt* %clnt) #0 {
entry:
  call void @rcu_read_lock()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 4
  %0 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end7

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @rpc_protocol.__warned, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %do.end7, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.end7, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rpc_protocol.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 1157, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end7

do.end7:                                          ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %prot = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 5
  %2 = load i32, i32* %prot, align 8, !tbaa !186
  call void @rcu_read_unlock()
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define void @rpc_setbufsize(%struct.rpc_clnt* %clnt, i32 %sndsize, i32 %rcvsize) #0 {
entry:
  call void @rcu_read_lock()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 4
  %0 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end7

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @rpc_setbufsize.__warned, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %do.end7, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.end7, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rpc_setbufsize.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 1140, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end7

do.end7:                                          ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 1
  %2 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %set_buffer_size = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %2, i32 0, i32 0
  %3 = load void (%struct.rpc_xprt*, i64, i64)*, void (%struct.rpc_xprt*, i64, i64)** %set_buffer_size, align 8, !tbaa !187
  %tobool8 = icmp ne void (%struct.rpc_xprt*, i64, i64)* %3, null
  br i1 %tobool8, label %if.then9, label %if.end13

if.then9:                                         ; preds = %do.end7
  %ops10 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 1
  %4 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops10, align 8, !tbaa !81
  %set_buffer_size11 = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %4, i32 0, i32 0
  %5 = load void (%struct.rpc_xprt*, i64, i64)*, void (%struct.rpc_xprt*, i64, i64)** %set_buffer_size11, align 8, !tbaa !187
  %conv = zext i32 %sndsize to i64
  %conv12 = zext i32 %rcvsize to i64
  call void %5(%struct.rpc_xprt* %0, i64 %conv, i64 %conv12)
  br label %if.end13

if.end13:                                         ; preds = %if.then9, %do.end7
  call void @rcu_read_unlock()
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @rpc_localaddr(%struct.rpc_clnt* %clnt, %struct.sockaddr* %buf, i64 %buflen) #0 {
entry:
  %address = alloca %struct.__kernel_sockaddr_storage, align 8
  %0 = bitcast %struct.__kernel_sockaddr_storage* %address to %struct.sockaddr*
  call void @rcu_read_lock()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 4
  %1 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end7

land.lhs.true:                                    ; preds = %entry
  %2 = load i8, i8* @rpc_localaddr.__warned, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %2 to i1
  br i1 %tobool1, label %do.end7, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.end7, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rpc_localaddr.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 1118, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end7

do.end7:                                          ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %addrlen = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 4
  %3 = load i64, i64* %addrlen, align 8, !tbaa !188
  %4 = bitcast %struct.sockaddr* %0 to i8*
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 3
  %5 = bitcast %struct.__kernel_sockaddr_storage* %addr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 %3, i32 2, i1 false)
  %xprt_net = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 40
  %6 = load %struct.net*, %struct.net** %xprt_net, align 8, !tbaa !171
  %call9 = call %struct.net* @get_net(%struct.net* %6)
  call void @rcu_read_unlock()
  call void @rpc_set_port(%struct.sockaddr* %0, i16 zeroext 0)
  %conv = trunc i64 %buflen to i32
  %call10 = call i32 @rpc_sockname(%struct.net* %call9, %struct.sockaddr* %0, i64 %3, %struct.sockaddr* %buf, i32 %conv)
  call void @put_net(%struct.net* %call9)
  %cmp = icmp ne i32 %call10, 0
  br i1 %cmp, label %if.then12, label %cleanup

if.then12:                                        ; preds = %do.end7
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %0, i32 0, i32 0
  %7 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv13 = zext i16 %7 to i32
  %call14 = call i32 @rpc_anyaddr(i32 %conv13, %struct.sockaddr* %buf, i64 %buflen)
  br label %cleanup

cleanup:                                          ; preds = %if.then12, %do.end7
  %retval.0 = phi i32 [ %call14, %if.then12 ], [ 0, %do.end7 ]
  ret i32 %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.net* @get_net(%struct.net* %net) #2 {
entry:
  %count = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 1
  call void @atomic_inc(%struct.atomic_t* %count)
  ret %struct.net* %net
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rpc_set_port(%struct.sockaddr* %sap, i16 zeroext %port) #2 {
entry:
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sap, i32 0, i32 0
  %0 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %0 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb3, label %sw.epilog

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %call = call zeroext i16 @__fswab16(i16 zeroext %port) #3
  %conv1 = zext i16 %call to i32
  %conv2 = trunc i32 %conv1 to i16
  %1 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %1, i32 0, i32 1
  store i16 %conv2, i16* %sin_port, align 2, !tbaa !191
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock1
  %call4 = call zeroext i16 @__fswab16(i16 zeroext %port) #3
  %conv5 = zext i16 %call4 to i32
  %conv6 = trunc i32 %conv5 to i16
  %2 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %2, i32 0, i32 1
  store i16 %conv6, i16* %sin6_port, align 2, !tbaa !194
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb3, %sw.bb, %LeafBlock, %LeafBlock1
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_sockname(%struct.net* %net, %struct.sockaddr* %sap, i64 %salen, %struct.sockaddr* %buf, i32 %buflen) #0 {
entry:
  %buflen.addr = alloca i32, align 4
  %sock = alloca %struct.socket*, align 8
  store i32 %buflen, i32* %buflen.addr, align 4, !tbaa !49
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sap, i32 0, i32 0
  %0 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %0 to i32
  %call = call i32 @__sock_create(%struct.net* %net, i32 %conv, i32 2, i32 17, %struct.socket** %sock, i32 1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %do.body, label %if.end7

do.body:                                          ; preds = %entry
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv3 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then5, label %out

if.then5:                                         ; preds = %do.body
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %out

if.end7:                                          ; preds = %entry
  %sa_family8 = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sap, i32 0, i32 0
  %3 = load i16, i16* %sa_family8, align 2, !tbaa !189
  %conv9 = zext i16 %3 to i32
  %Pivot = icmp slt i32 %conv9, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end7
  %SwitchLeaf2 = icmp eq i32 %conv9, 10
  br i1 %SwitchLeaf2, label %sw.bb11, label %out

LeafBlock:                                        ; preds = %if.end7
  %SwitchLeaf = icmp eq i32 %conv9, 2
  br i1 %SwitchLeaf, label %sw.bb, label %out

sw.bb:                                            ; preds = %LeafBlock
  %4 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  %call10 = call i32 @kernel_bind(%struct.socket* %4, %struct.sockaddr* bitcast (%struct.sockaddr_in* @rpc_inaddr_loopback to %struct.sockaddr*), i32 16)
  br label %sw.epilog

sw.bb11:                                          ; preds = %LeafBlock1
  %5 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  %call12 = call i32 @kernel_bind(%struct.socket* %5, %struct.sockaddr* bitcast ({ i16, i16, i32, { { [16 x i8] } }, i32 }* @rpc_in6addr_loopback to %struct.sockaddr*), i32 28)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb11, %sw.bb
  %err.0 = phi i32 [ %call10, %sw.bb ], [ %call12, %sw.bb11 ]
  %cmp13 = icmp slt i32 %err.0, 0
  br i1 %cmp13, label %do.body16, label %if.end31

do.body16:                                        ; preds = %sw.epilog
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and17 = and i32 %6, 2
  %tobool18 = icmp ne i32 %and17, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %if.then26, label %out_release

if.then26:                                        ; preds = %do.body16
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_release

if.end31:                                         ; preds = %sw.epilog
  %8 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  %conv32 = trunc i64 %salen to i32
  %call33 = call i32 @kernel_connect(%struct.socket* %8, %struct.sockaddr* %sap, i32 %conv32, i32 0)
  %cmp34 = icmp slt i32 %call33, 0
  br i1 %cmp34, label %do.body37, label %if.end52

do.body37:                                        ; preds = %if.end31
  %9 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and38 = and i32 %9, 2
  %tobool39 = icmp ne i32 %and38, 0
  %lnot40 = xor i1 %tobool39, true
  %lnot42 = xor i1 %lnot40, true
  %lnot.ext43 = zext i1 %lnot42 to i32
  %conv44 = sext i32 %lnot.ext43 to i64
  %expval45 = call i64 @llvm.expect.i64(i64 %conv44, i64 0)
  %tobool46 = icmp ne i64 %expval45, 0
  br i1 %tobool46, label %if.then47, label %out_release

if.then47:                                        ; preds = %do.body37
  %10 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_release

if.end52:                                         ; preds = %if.end31
  %11 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  %call53 = call i32 @kernel_getsockname(%struct.socket* %11, %struct.sockaddr* %buf, i32* %buflen.addr)
  %cmp54 = icmp slt i32 %call53, 0
  br i1 %cmp54, label %do.body57, label %if.end72

do.body57:                                        ; preds = %if.end52
  %12 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and58 = and i32 %12, 2
  %tobool59 = icmp ne i32 %and58, 0
  %lnot60 = xor i1 %tobool59, true
  %lnot62 = xor i1 %lnot60, true
  %lnot.ext63 = zext i1 %lnot62 to i32
  %conv64 = sext i32 %lnot.ext63 to i64
  %expval65 = call i64 @llvm.expect.i64(i64 %conv64, i64 0)
  %tobool66 = icmp ne i64 %expval65, 0
  br i1 %tobool66, label %if.then67, label %out_release

if.then67:                                        ; preds = %do.body57
  %13 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_release

if.end72:                                         ; preds = %if.end52
  %sa_family73 = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %buf, i32 0, i32 0
  %14 = load i16, i16* %sa_family73, align 2, !tbaa !189
  %conv74 = zext i16 %14 to i32
  %cmp75 = icmp eq i32 %conv74, 10
  br i1 %cmp75, label %if.then77, label %do.body79

if.then77:                                        ; preds = %if.end72
  %15 = bitcast %struct.sockaddr* %buf to %struct.sockaddr_in6*
  %sin6_scope_id = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %15, i32 0, i32 4
  store i32 0, i32* %sin6_scope_id, align 4, !tbaa !197
  br label %do.body79

do.body79:                                        ; preds = %if.then77, %if.end72
  %16 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and80 = and i32 %16, 2
  %tobool81 = icmp ne i32 %and80, 0
  %lnot82 = xor i1 %tobool81, true
  %lnot84 = xor i1 %lnot82, true
  %lnot.ext85 = zext i1 %lnot84 to i32
  %conv86 = sext i32 %lnot.ext85 to i64
  %expval87 = call i64 @llvm.expect.i64(i64 %conv86, i64 0)
  %tobool88 = icmp ne i64 %expval87, 0
  br i1 %tobool88, label %if.then89, label %out_release

if.then89:                                        ; preds = %do.body79
  %17 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_release

out_release:                                      ; preds = %if.then89, %do.body79, %if.then67, %do.body57, %if.then47, %do.body37, %if.then26, %do.body16
  %err.1 = phi i32 [ %err.0, %if.then26 ], [ %err.0, %do.body16 ], [ %call33, %if.then47 ], [ %call33, %do.body37 ], [ %call53, %if.then67 ], [ %call53, %do.body57 ], [ 0, %if.then89 ], [ 0, %do.body79 ]
  %18 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  call void @sock_release(%struct.socket* %18)
  br label %out

out:                                              ; preds = %out_release, %LeafBlock, %LeafBlock1, %if.then5, %do.body
  %err.2 = phi i32 [ %err.1, %out_release ], [ %call, %if.then5 ], [ %call, %do.body ], [ -97, %LeafBlock ], [ -97, %LeafBlock1 ]
  ret i32 %err.2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @put_net(%struct.net* %net) #2 {
entry:
  %count = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 1
  %call = call i32 @atomic_dec_and_test(%struct.atomic_t* %count)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__put_net(%struct.net* %net)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_anyaddr(i32 %family, %struct.sockaddr* %buf, i64 %buflen) #0 {
entry:
  %Pivot = icmp slt i32 %family, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %family, 10
  br i1 %SwitchLeaf2, label %sw.bb4, label %do.body

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %family, 2
  br i1 %SwitchLeaf, label %sw.bb, label %do.body

sw.bb:                                            ; preds = %LeafBlock
  %cmp = icmp ult i64 %buflen, 16
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %sw.bb
  %cmp1 = icmp uge i64 16, 64
  %0 = bitcast %struct.sockaddr* %buf to i8*
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %call = call i8* @__memcpy(i8* %0, i8* bitcast (%struct.sockaddr_in* @rpc_inaddr_loopback to i8*), i64 16)
  br label %do.body21

if.else:                                          ; preds = %if.end
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast (%struct.sockaddr_in* @rpc_inaddr_loopback to i8*), i64 16, i32 2, i1 false)
  br label %do.body21

sw.bb4:                                           ; preds = %LeafBlock1
  %cmp5 = icmp ult i64 %buflen, 28
  br i1 %cmp5, label %return, label %if.end7

if.end7:                                          ; preds = %sw.bb4
  %cmp10 = icmp uge i64 28, 64
  %1 = bitcast %struct.sockaddr* %buf to i8*
  br i1 %cmp10, label %if.then11, label %if.else13

if.then11:                                        ; preds = %if.end7
  %call12 = call i8* @__memcpy(i8* %1, i8* bitcast ({ i16, i16, i32, { { [16 x i8] } }, i32 }* @rpc_in6addr_loopback to i8*), i64 28)
  br label %do.body

if.else13:                                        ; preds = %if.end7
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* bitcast ({ i16, i16, i32, { { [16 x i8] } }, i32 }* @rpc_in6addr_loopback to i8*), i64 28, i32 2, i1 false)
  br label %do.body

do.body:                                          ; preds = %if.else13, %if.then11, %LeafBlock, %LeafBlock1
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot16 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot16 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool17 = icmp ne i64 %expval, 0
  br i1 %tobool17, label %if.then18, label %return

if.then18:                                        ; preds = %do.body
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %return

do.body21:                                        ; preds = %if.else, %if.then2
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and22 = and i32 %4, 2
  %tobool23 = icmp ne i32 %and22, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %return

if.then31:                                        ; preds = %do.body21
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %return

return:                                           ; preds = %if.then31, %do.body21, %if.then18, %do.body, %sw.bb4, %sw.bb
  %retval.0 = phi i32 [ -22, %sw.bb ], [ -22, %sw.bb4 ], [ -97, %do.body ], [ -97, %if.then18 ], [ 0, %do.body21 ], [ 0, %if.then31 ]
  ret i32 %retval.0
}

declare i8* @__memcpy(i8*, i8*, i64) #4

declare void @__put_net(%struct.net*) #4

declare i32 @__sock_create(%struct.net*, i32, i32, i32, %struct.socket**, i32) #4

declare i32 @kernel_bind(%struct.socket*, %struct.sockaddr*, i32) #4

declare i32 @kernel_connect(%struct.socket*, %struct.sockaddr*, i32, i32) #4

declare i32 @kernel_getsockname(%struct.socket*, %struct.sockaddr*, i32*) #4

declare void @sock_release(%struct.socket*) #4

; Function Attrs: inlinehint nounwind readnone uwtable
define internal zeroext i16 @__fswab16(i16 zeroext %val) #5 {
entry:
  %conv = zext i16 %val to i32
  %and = and i32 %conv, 255
  %shl = shl i32 %and, 8
  %conv1 = zext i16 %val to i32
  %and2 = and i32 %conv1, 65280
  %shr = ashr i32 %and2, 8
  %or = or i32 %shl, %shr
  %conv3 = trunc i32 %or to i16
  ret i16 %conv3
}

; Function Attrs: nounwind uwtable
define i8* @rpc_peeraddr2str(%struct.rpc_clnt* %clnt, i32 %format) #0 {
entry:
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 4
  %0 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end7

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @rpc_peeraddr2str.__warned, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %do.end7, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.end7, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rpc_peeraddr2str.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 976, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end7

do.end7:                                          ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 42
  %idxprom = zext i32 %format to i64
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 %idxprom
  %2 = load i8*, i8** %arrayidx, align 8, !tbaa !28
  %cmp = icmp ne i8* %2, null
  br i1 %cmp, label %if.then8, label %cleanup

if.then8:                                         ; preds = %do.end7
  %address_strings9 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 42
  %idxprom10 = zext i32 %format to i64
  %arrayidx11 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings9, i64 0, i64 %idxprom10
  %3 = load i8*, i8** %arrayidx11, align 8, !tbaa !28
  br label %cleanup

cleanup:                                          ; preds = %if.then8, %do.end7
  %retval.0 = phi i8* [ %3, %if.then8 ], [ getelementptr inbounds ([12 x i8], [12 x i8]* @.str.10, i32 0, i32 0), %do.end7 ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define i64 @rpc_peeraddr(%struct.rpc_clnt* %clnt, %struct.sockaddr* %buf, i64 %bufsize) #0 {
entry:
  call void @rcu_read_lock()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 4
  %0 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end7

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @rpc_peeraddr.__warned, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %do.end7, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.end7, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rpc_peeraddr.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 950, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end7

do.end7:                                          ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %addrlen = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 4
  %2 = load i64, i64* %addrlen, align 8, !tbaa !188
  %cmp = icmp ugt i64 %2, %bufsize
  %bufsize. = select i1 %cmp, i64 %bufsize, i64 %2
  %3 = bitcast %struct.sockaddr* %buf to i8*
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 3
  %4 = bitcast %struct.__kernel_sockaddr_storage* %addr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 %bufsize., i32 2, i1 false)
  call void @rcu_read_unlock()
  ret i64 %bufsize.
}

; Function Attrs: nounwind uwtable
define i32 @rpc_call_async(%struct.rpc_clnt* %clnt, %struct.rpc_message* %msg, i32 %flags, %struct.rpc_call_ops* %tk_ops, i8* %data) #0 {
entry:
  %task_setup_data = alloca %struct.rpc_task_setup, align 8
  %task1 = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 0
  store %struct.rpc_task* null, %struct.rpc_task** %task1, align 8, !tbaa !10
  %rpc_client = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 1
  store %struct.rpc_clnt* %clnt, %struct.rpc_clnt** %rpc_client, align 8, !tbaa !13
  %rpc_message = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 2
  store %struct.rpc_message* %msg, %struct.rpc_message** %rpc_message, align 8, !tbaa !14
  %callback_ops = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 3
  store %struct.rpc_call_ops* %tk_ops, %struct.rpc_call_ops** %callback_ops, align 8, !tbaa !15
  %callback_data = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 4
  store i8* %data, i8** %callback_data, align 8, !tbaa !16
  %workqueue = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 5
  store %struct.workqueue_struct* null, %struct.workqueue_struct** %workqueue, align 8, !tbaa !17
  %flags2 = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 6
  %or = or i32 %flags, 1
  %conv = trunc i32 %or to i16
  store i16 %conv, i16* %flags2, align 8, !tbaa !18
  %priority = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 7
  store i8 0, i8* %priority, align 2, !tbaa !19
  %call = call %struct.rpc_task* @rpc_run_task(%struct.rpc_task_setup* %task_setup_data)
  %0 = bitcast %struct.rpc_task* %call to i8*
  %call3 = call i64 @IS_ERR(i8* %0)
  %tobool = icmp ne i64 %call3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = bitcast %struct.rpc_task* %call to i8*
  %call4 = call i64 @PTR_ERR(i8* %1)
  %conv5 = trunc i64 %call4 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @rpc_put_task(%struct.rpc_task* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %conv5, %if.then ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define i32 @rpc_call_sync(%struct.rpc_clnt* %clnt, %struct.rpc_message* %msg, i32 %flags) #0 {
entry:
  %task_setup_data = alloca %struct.rpc_task_setup, align 8
  %task1 = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 0
  store %struct.rpc_task* null, %struct.rpc_task** %task1, align 8, !tbaa !10
  %rpc_client = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 1
  store %struct.rpc_clnt* %clnt, %struct.rpc_clnt** %rpc_client, align 8, !tbaa !13
  %rpc_message = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 2
  store %struct.rpc_message* %msg, %struct.rpc_message** %rpc_message, align 8, !tbaa !14
  %callback_ops = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 3
  store %struct.rpc_call_ops* @rpc_default_ops, %struct.rpc_call_ops** %callback_ops, align 8, !tbaa !15
  %callback_data = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 4
  store i8* null, i8** %callback_data, align 8, !tbaa !16
  %workqueue = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 5
  store %struct.workqueue_struct* null, %struct.workqueue_struct** %workqueue, align 8, !tbaa !17
  %flags2 = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 6
  %conv = trunc i32 %flags to i16
  store i16 %conv, i16* %flags2, align 8, !tbaa !18
  %priority = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 7
  store i8 0, i8* %priority, align 2, !tbaa !19
  %and = and i32 %flags, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv9, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then, label %if.end37

if.then:                                          ; preds = %entry
  %0 = load i8, i8* @rpc_call_sync.__warned, align 1, !tbaa !29, !range !31
  %tobool11 = trunc i8 %0 to i1
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %tobool18 = icmp ne i32 %lnot.ext17, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %if.then26, label %if.end

if.then26:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 839)
  br label %if.end

if.end:                                           ; preds = %if.then26, %if.then
  %tobool27 = icmp ne i32 %lnot.ext17, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.end
  store i8 1, i8* @rpc_call_sync.__warned, align 1, !tbaa !29
  br label %if.end37

if.end37:                                         ; preds = %if.then35, %if.end, %entry
  %and46 = and i32 %flags, 1
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %if.then48, label %if.end51

if.then48:                                        ; preds = %if.end37
  %callback_ops49 = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 3
  %1 = load %struct.rpc_call_ops*, %struct.rpc_call_ops** %callback_ops49, align 8, !tbaa !15
  %callback_data50 = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 4
  %2 = load i8*, i8** %callback_data50, align 8, !tbaa !16
  call void @rpc_release_calldata(%struct.rpc_call_ops* %1, i8* %2)
  br label %cleanup

if.end51:                                         ; preds = %if.end37
  %call = call %struct.rpc_task* @rpc_run_task(%struct.rpc_task_setup* %task_setup_data)
  %3 = bitcast %struct.rpc_task* %call to i8*
  %call52 = call i64 @IS_ERR(i8* %3)
  %tobool53 = icmp ne i64 %call52, 0
  br i1 %tobool53, label %if.then54, label %if.end57

if.then54:                                        ; preds = %if.end51
  %4 = bitcast %struct.rpc_task* %call to i8*
  %call55 = call i64 @PTR_ERR(i8* %4)
  %conv56 = trunc i64 %call55 to i32
  br label %cleanup

if.end57:                                         ; preds = %if.end51
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %call, i32 0, i32 16
  %5 = load i32, i32* %tk_status, align 4, !tbaa !59
  call void @rpc_put_task(%struct.rpc_task* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.end57, %if.then54, %if.then48
  %retval.0 = phi i32 [ -22, %if.then48 ], [ %conv56, %if.then54 ], [ %5, %if.end57 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @rpc_task_reset_client(%struct.rpc_task* %task, %struct.rpc_clnt* %clnt) #0 {
entry:
  call void @rpc_task_release_client(%struct.rpc_task* %task)
  call void @rpc_task_set_client(%struct.rpc_task* %task, %struct.rpc_clnt* %clnt)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.rpc_clnt* @rpc_bind_new_program(%struct.rpc_clnt* %old, %struct.rpc_program* %program, i32 %vers) #0 {
entry:
  %args = alloca %struct.rpc_create_args, align 8
  %net = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 0
  store %struct.net* null, %struct.net** %net, align 8, !tbaa !198
  %protocol = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 1
  store i32 0, i32* %protocol, align 8, !tbaa !200
  %address = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 2
  store %struct.sockaddr* null, %struct.sockaddr** %address, align 8, !tbaa !201
  %addrsize = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 3
  store i64 0, i64* %addrsize, align 8, !tbaa !202
  %saddress = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 4
  store %struct.sockaddr* null, %struct.sockaddr** %saddress, align 8, !tbaa !203
  %timeout = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 5
  store %struct.rpc_timeout* null, %struct.rpc_timeout** %timeout, align 8, !tbaa !204
  %servername = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 6
  store i8* null, i8** %servername, align 8, !tbaa !205
  %program1 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 7
  store %struct.rpc_program* %program, %struct.rpc_program** %program1, align 8, !tbaa !206
  %prognumber = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 8
  %number = getelementptr inbounds %struct.rpc_program, %struct.rpc_program* %program, i32 0, i32 1
  %0 = load i32, i32* %number, align 8, !tbaa !207
  store i32 %0, i32* %prognumber, align 8, !tbaa !209
  %version = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 9
  store i32 %vers, i32* %version, align 4, !tbaa !210
  %authflavor = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 10
  %cl_auth = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %old, i32 0, i32 10
  %1 = load %struct.rpc_auth*, %struct.rpc_auth** %cl_auth, align 8, !tbaa !167
  %au_flavor = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %1, i32 0, i32 5
  %2 = load i32, i32* %au_flavor, align 8, !tbaa !211
  store i32 %2, i32* %authflavor, align 8, !tbaa !212
  %flags = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 11
  store i64 0, i64* %flags, align 8, !tbaa !213
  %client_name = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 12
  %cl_principal = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %old, i32 0, i32 23
  %3 = load i8*, i8** %cl_principal, align 8, !tbaa !170
  store i8* %3, i8** %client_name, align 8, !tbaa !214
  %bc_xprt = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 13
  store %struct.svc_xprt* null, %struct.svc_xprt** %bc_xprt, align 8, !tbaa !215
  %call = call %struct.rpc_clnt* @__rpc_clone_client(%struct.rpc_create_args* %args, %struct.rpc_clnt* %old)
  %4 = bitcast %struct.rpc_clnt* %call to i8*
  %call2 = call i64 @IS_ERR(i8* %4)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %out, label %if.end

if.end:                                           ; preds = %entry
  %call3 = call i32 @rpc_ping(%struct.rpc_clnt* %call)
  %cmp = icmp ne i32 %call3, 0
  br i1 %cmp, label %if.then4, label %out

if.then4:                                         ; preds = %if.end
  call void @rpc_shutdown_client(%struct.rpc_clnt* %call)
  %conv = sext i32 %call3 to i64
  %call5 = call i8* @ERR_PTR(i64 %conv)
  %5 = bitcast i8* %call5 to %struct.rpc_clnt*
  br label %out

out:                                              ; preds = %if.then4, %if.end, %entry
  %clnt.1 = phi %struct.rpc_clnt* [ %call, %entry ], [ %5, %if.then4 ], [ %call, %if.end ]
  ret %struct.rpc_clnt* %clnt.1
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_clnt* @__rpc_clone_client(%struct.rpc_create_args* %args, %struct.rpc_clnt* %clnt) #0 {
entry:
  call void @rcu_read_lock()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 4
  %0 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end7

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @__rpc_clone_client.__warned, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %do.end7, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.end7, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @__rpc_clone_client.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 507, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end7

do.end7:                                          ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %call8 = call %struct.rpc_xprt* @xprt_get(%struct.rpc_xprt* %0)
  call void @rcu_read_unlock()
  %cmp = icmp eq %struct.rpc_xprt* %call8, null
  br i1 %cmp, label %do.body43, label %if.end10

if.end10:                                         ; preds = %do.end7
  %servername = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call8, i32 0, i32 41
  %2 = load i8*, i8** %servername, align 8, !tbaa !216
  %servername11 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 6
  store i8* %2, i8** %servername11, align 8, !tbaa !205
  %call12 = call %struct.rpc_clnt* @rpc_new_client(%struct.rpc_create_args* %args, %struct.rpc_xprt* %call8)
  %3 = bitcast %struct.rpc_clnt* %call12 to i8*
  %call13 = call i64 @IS_ERR(i8* %3)
  %tobool14 = icmp ne i64 %call13, 0
  br i1 %tobool14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end10
  %4 = bitcast %struct.rpc_clnt* %call12 to i8*
  %call16 = call i64 @PTR_ERR(i8* %4)
  %conv = trunc i64 %call16 to i32
  br label %do.body43

if.end17:                                         ; preds = %if.end10
  %cl_count = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 0
  call void @atomic_inc(%struct.atomic_t* %cl_count)
  %cl_parent = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %call12, i32 0, i32 19
  store %struct.rpc_clnt* %clnt, %struct.rpc_clnt** %cl_parent, align 8, !tbaa !168
  %cl_autobind = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %call12, i32 0, i32 13
  %bf.load = load i8, i8* %cl_autobind, align 8
  %bf.clear = and i8 %bf.load, -5
  store i8 %bf.clear, i8* %cl_autobind, align 8
  %cl_softrtry = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 13
  %bf.load18 = load i8, i8* %cl_softrtry, align 8
  %bf.clear19 = and i8 %bf.load18, 1
  %bf.cast = zext i8 %bf.clear19 to i32
  %cl_softrtry20 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %call12, i32 0, i32 13
  %5 = trunc i32 %bf.cast to i8
  %bf.load21 = load i8, i8* %cl_softrtry20, align 8
  %bf.value = and i8 %5, 1
  %bf.clear22 = and i8 %bf.load21, -2
  %bf.set = or i8 %bf.clear22, %bf.value
  store i8 %bf.set, i8* %cl_softrtry20, align 8
  %cl_discrtry = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 13
  %bf.load23 = load i8, i8* %cl_discrtry, align 8
  %bf.lshr = lshr i8 %bf.load23, 1
  %bf.clear24 = and i8 %bf.lshr, 1
  %bf.cast25 = zext i8 %bf.clear24 to i32
  %cl_discrtry26 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %call12, i32 0, i32 13
  %6 = trunc i32 %bf.cast25 to i8
  %bf.load27 = load i8, i8* %cl_discrtry26, align 8
  %bf.value28 = and i8 %6, 1
  %bf.shl = shl i8 %bf.value28, 1
  %bf.clear29 = and i8 %bf.load27, -3
  %bf.set30 = or i8 %bf.clear29, %bf.shl
  store i8 %bf.set30, i8* %cl_discrtry26, align 8
  %cl_chatty = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 13
  %bf.load32 = load i8, i8* %cl_chatty, align 8
  %bf.lshr33 = lshr i8 %bf.load32, 3
  %bf.clear34 = and i8 %bf.lshr33, 1
  %bf.cast35 = zext i8 %bf.clear34 to i32
  %cl_chatty36 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %call12, i32 0, i32 13
  %7 = trunc i32 %bf.cast35 to i8
  %bf.load37 = load i8, i8* %cl_chatty36, align 8
  %bf.value38 = and i8 %7, 1
  %bf.shl39 = shl i8 %bf.value38, 3
  %bf.clear40 = and i8 %bf.load37, -9
  %bf.set41 = or i8 %bf.clear40, %bf.shl39
  store i8 %bf.set41, i8* %cl_chatty36, align 8
  br label %cleanup

do.body43:                                        ; preds = %if.then15, %do.end7
  %err.0 = phi i32 [ %conv, %if.then15 ], [ -12, %do.end7 ]
  %8 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %8, 2
  %tobool44 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool44, true
  %lnot45 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot45 to i32
  %conv46 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv46, i64 0)
  %tobool47 = icmp ne i64 %expval, 0
  br i1 %tobool47, label %if.then48, label %do.end52

if.then48:                                        ; preds = %do.body43
  %9 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end52

do.end52:                                         ; preds = %if.then48, %do.body43
  %conv53 = sext i32 %err.0 to i64
  %call54 = call i8* @ERR_PTR(i64 %conv53)
  %10 = bitcast i8* %call54 to %struct.rpc_clnt*
  br label %cleanup

cleanup:                                          ; preds = %do.end52, %if.end17
  %retval.0 = phi %struct.rpc_clnt* [ %10, %do.end52 ], [ %call12, %if.end17 ]
  ret %struct.rpc_clnt* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_ping(%struct.rpc_clnt* %clnt) #0 {
entry:
  %msg = alloca %struct.rpc_message, align 8
  %0 = bitcast %struct.rpc_message* %msg to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast (%struct.rpc_message* @rpc_ping.msg to i8*), i64 32, i32 8, i1 false)
  %1 = load %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)*, %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)** getelementptr inbounds (%struct.rpc_authops, %struct.rpc_authops* bitcast ({ %struct.module*, i32, i8*, %struct.rpc_auth.2960* (%struct.rpc_clnt.2966*, i32)*, void (%struct.rpc_auth.2960*)*, %struct.rpc_cred.2963* (%struct.rpc_auth.2960*, %struct.auth_cred*, i32)*, %struct.rpc_cred.2963* (%struct.rpc_auth.2960*, %struct.auth_cred*, i32)*, i32 (%struct.rpc_auth.2960*)*, void (%struct.rpc_auth.2960*)*, i32 (i32*, i32)*, i32 (%struct.rpcsec_gss_info*)*, i32 (i32, %struct.rpcsec_gss_info*)* }* @authnull_ops to %struct.rpc_authops*), i32 0, i32 5), align 8, !tbaa !217
  %call = call %struct.rpc_cred* %1(%struct.rpc_auth* null, %struct.auth_cred* null, i32 0)
  %rpc_cred = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 3
  store %struct.rpc_cred* %call, %struct.rpc_cred** %rpc_cred, align 8, !tbaa !9
  %call1 = call i32 @rpc_call_sync(%struct.rpc_clnt* %clnt, %struct.rpc_message* %msg, i32 1536)
  %rpc_cred2 = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 3
  %2 = load %struct.rpc_cred*, %struct.rpc_cred** %rpc_cred2, align 8, !tbaa !9
  call void @put_rpccred(%struct.rpc_cred* %2)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define void @rpc_shutdown_client(%struct.rpc_clnt* %clnt) #0 {
entry:
  %__wait = alloca %struct.__wait_queue, align 8
  call void @__might_sleep(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 613, i32 0)
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then, label %do.end20

if.then:                                          ; preds = %entry
  call void @rcu_read_lock()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 4
  %1 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool7 = icmp ne i32 %call, 0
  br i1 %tobool7, label %land.lhs.true, label %do.end16

land.lhs.true:                                    ; preds = %if.then
  %2 = load i8, i8* @rpc_shutdown_client.__warned, align 1, !tbaa !29, !range !31
  %tobool8 = trunc i8 %2 to i1
  br i1 %tobool8, label %do.end16, label %land.lhs.true9

land.lhs.true9:                                   ; preds = %land.lhs.true
  %call10 = call i32 @rcu_read_lock_held()
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %do.end16, label %if.then12

if.then12:                                        ; preds = %land.lhs.true9
  store i8 1, i8* @rpc_shutdown_client.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 617, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end16

do.end16:                                         ; preds = %if.then12, %land.lhs.true9, %land.lhs.true, %if.then
  %3 = call i32 (i8*, ...) @printk(i8* null)
  call void @rcu_read_unlock()
  br label %do.end20

do.end20:                                         ; preds = %do.end16, %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end51, %do.end20
  %cl_tasks = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 2
  %call21 = call i32 @list_empty(%struct.list_head* %cl_tasks)
  %tobool22 = icmp ne i32 %call21, 0
  %lnot23 = xor i1 %tobool22, true
  br i1 %lnot23, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @rpc_killall_tasks(%struct.rpc_clnt* %clnt)
  %cl_tasks25 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 2
  %call26 = call i32 @list_empty(%struct.list_head* %cl_tasks25)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %if.end51, label %do.body29

do.body29:                                        ; preds = %while.body
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !218
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 1
  %4 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !84
  %5 = bitcast %struct.task_struct* %4 to i8*
  store i8* %5, i8** %private, align 8, !tbaa !220
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @autoremove_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !221
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  %task_list31 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list31, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  %task_list32 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list32, %struct.list_head** %prev, align 8, !tbaa !163
  br label %for.cond

for.cond:                                         ; preds = %if.end41, %do.body29
  %__ret.0 = phi i64 [ 250, %do.body29 ], [ %call38, %if.end41 ]
  call void @prepare_to_wait(%struct.__wait_queue_head* @destroy_wait, %struct.__wait_queue* %__wait, i32 2)
  %cl_tasks33 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 2
  %call34 = call i32 @list_empty(%struct.list_head* %cl_tasks33)
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %for.end, label %if.end37

if.end37:                                         ; preds = %for.cond
  %call38 = call i64 @schedule_timeout(i64 %__ret.0)
  %tobool39 = icmp ne i64 %call38, 0
  br i1 %tobool39, label %if.end41, label %for.end

if.end41:                                         ; preds = %if.end37
  br label %for.cond

for.end:                                          ; preds = %if.end37, %for.cond
  %__ret.1 = phi i64 [ %__ret.0, %for.cond ], [ %call38, %if.end37 ]
  %tobool42 = icmp ne i64 %__ret.1, 0
  br i1 %tobool42, label %if.end48, label %land.lhs.true43

land.lhs.true43:                                  ; preds = %for.end
  %cl_tasks44 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 2
  %call45 = call i32 @list_empty(%struct.list_head* %cl_tasks44)
  br label %if.end48

if.end48:                                         ; preds = %land.lhs.true43, %for.end
  call void @finish_wait(%struct.__wait_queue_head* @destroy_wait, %struct.__wait_queue* %__wait)
  br label %if.end51

if.end51:                                         ; preds = %if.end48, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  call void @rpc_release_client(%struct.rpc_clnt* %clnt)
  ret void
}

declare void @__might_sleep(i8*, i32, i32) #4

; Function Attrs: nounwind uwtable
define void @rpc_killall_tasks(%struct.rpc_clnt* %clnt) #0 {
entry:
  %cl_tasks = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 2
  %call = call i32 @list_empty(%struct.list_head* %cl_tasks)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup.cont, label %do.body

do.body:                                          ; preds = %entry
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 2
  %tobool1 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.end

if.then4:                                         ; preds = %do.body
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then4, %do.body
  %cl_lock = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 3
  call void @spin_lock(%struct.spinlock* %cl_lock)
  %cl_tasks7 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %tk_task36.sink = phi %struct.list_head* [ %tk_task36, %for.inc ], [ %cl_tasks7, %do.end ]
  %next37 = getelementptr inbounds %struct.list_head, %struct.list_head* %tk_task36.sink, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next37, align 8, !tbaa !28
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr39 = getelementptr inbounds i8, i8* %3, i64 -8
  %4 = bitcast i8* %add.ptr39 to %struct.rpc_task*
  %tk_task = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %4, i32 0, i32 1
  %cl_tasks8 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 2
  %cmp = icmp ne %struct.list_head* %tk_task, %cl_tasks8
  br i1 %cmp, label %cond.true, label %for.end

cond.true:                                        ; preds = %for.cond
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %4, i32 0, i32 10
  %5 = load volatile i64, i64* %tk_runstate, align 8, !tbaa !88
  %and.i1 = and i64 4, %5
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool11 = icmp ne i32 %conv.i3, 0
  br i1 %tobool11, label %if.end16, label %for.inc

if.end16:                                         ; preds = %cond.true
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %4, i32 0, i32 17
  %6 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv17 = zext i16 %6 to i32
  %and18 = and i32 %conv17, 256
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %for.inc, label %if.then20

if.then20:                                        ; preds = %if.end16
  %tk_flags21 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %4, i32 0, i32 17
  %7 = load i16, i16* %tk_flags21, align 8, !tbaa !27
  %conv22 = zext i16 %7 to i32
  %or = or i32 %conv22, 256
  %conv23 = trunc i32 %or to i16
  store i16 %conv23, i16* %tk_flags21, align 8, !tbaa !27
  call void @rpc_exit(%struct.rpc_task* %4, i32 -5)
  %tk_runstate25 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %4, i32 0, i32 10
  %8 = load volatile i64, i64* %tk_runstate25, align 8, !tbaa !88
  %and.i = and i64 2, %8
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool27 = icmp ne i32 %conv.i, 0
  br i1 %tobool27, label %if.then32, label %for.inc

if.then32:                                        ; preds = %if.then20
  %tk_waitqueue = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %4, i32 0, i32 12
  %9 = load %struct.rpc_wait_queue*, %struct.rpc_wait_queue** %tk_waitqueue, align 8, !tbaa !222
  call void @rpc_wake_up_queued_task(%struct.rpc_wait_queue* %9, %struct.rpc_task* %4)
  br label %for.inc

for.inc:                                          ; preds = %if.then32, %if.then20, %if.end16, %cond.true
  %tk_task36 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %4, i32 0, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %cl_lock40 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 3
  call void @spin_unlock(%struct.spinlock* %cl_lock40)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %entry
  ret void
}

declare i32 @autoremove_wake_function(%struct.__wait_queue*, i32, i32, i8*) #4

declare void @prepare_to_wait(%struct.__wait_queue_head*, %struct.__wait_queue*, i32) #4

declare i64 @schedule_timeout(i64) #4

declare void @finish_wait(%struct.__wait_queue_head*, %struct.__wait_queue*) #4

; Function Attrs: nounwind uwtable
define internal %struct.rpc_clnt* @rpc_new_client(%struct.rpc_create_args* %args, %struct.rpc_xprt* %xprt) #0 {
entry:
  %program1 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 7
  %0 = load %struct.rpc_program*, %struct.rpc_program** %program1, align 8, !tbaa !206
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %call4 = call i32 @rpciod_up()
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %out_no_rpciod, label %if.end7

if.end7:                                          ; preds = %do.end
  %version8 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 9
  %3 = load i32, i32* %version8, align 4, !tbaa !210
  %nrvers = getelementptr inbounds %struct.rpc_program, %struct.rpc_program* %0, i32 0, i32 2
  %4 = load i32, i32* %nrvers, align 4, !tbaa !223
  %cmp = icmp uge i32 %3, %4
  br i1 %cmp, label %out_err, label %if.end11

if.end11:                                         ; preds = %if.end7
  %version12 = getelementptr inbounds %struct.rpc_program, %struct.rpc_program* %0, i32 0, i32 3
  %5 = load %struct.rpc_version**, %struct.rpc_version*** %version12, align 8, !tbaa !224
  %version13 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 9
  %6 = load i32, i32* %version13, align 4, !tbaa !210
  %idxprom = zext i32 %6 to i64
  %arrayidx = getelementptr inbounds %struct.rpc_version*, %struct.rpc_version** %5, i64 %idxprom
  %7 = load %struct.rpc_version*, %struct.rpc_version** %arrayidx, align 8, !tbaa !28
  %cmp14 = icmp eq %struct.rpc_version* %7, null
  br i1 %cmp14, label %out_err, label %if.end17

if.end17:                                         ; preds = %if.end11
  %call18 = call i8* @kzalloc(i64 416, i32 208)
  %8 = bitcast i8* %call18 to %struct.rpc_clnt*
  %tobool19 = icmp ne %struct.rpc_clnt* %8, null
  br i1 %tobool19, label %if.end21, label %out_err

if.end21:                                         ; preds = %if.end17
  %cl_parent = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 19
  store %struct.rpc_clnt* %8, %struct.rpc_clnt** %cl_parent, align 8, !tbaa !168
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !225
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 4
  store %struct.rpc_xprt* %xprt, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !226
  %procs = getelementptr inbounds %struct.rpc_version, %struct.rpc_version* %7, i32 0, i32 2
  %9 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %procs, align 8, !tbaa !227
  %cl_procinfo = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 5
  store %struct.rpc_procinfo* %9, %struct.rpc_procinfo** %cl_procinfo, align 8, !tbaa !229
  %nrprocs = getelementptr inbounds %struct.rpc_version, %struct.rpc_version* %7, i32 0, i32 1
  %10 = load i32, i32* %nrprocs, align 4, !tbaa !230
  %cl_maxproc = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 8
  store i32 %10, i32* %cl_maxproc, align 8, !tbaa !231
  %name25 = getelementptr inbounds %struct.rpc_program, %struct.rpc_program* %0, i32 0, i32 0
  %11 = load i8*, i8** %name25, align 8, !tbaa !232
  %cl_protname = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 9
  store i8* %11, i8** %cl_protname, align 8, !tbaa !233
  %prognumber = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 8
  %12 = load i32, i32* %prognumber, align 8, !tbaa !209
  %tobool26 = icmp ne i32 %12, 0
  br i1 %tobool26, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end21
  %number = getelementptr inbounds %struct.rpc_program, %struct.rpc_program* %0, i32 0, i32 1
  %13 = load i32, i32* %number, align 8, !tbaa !207
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %if.end21
  %cond = phi i32 [ %13, %cond.false ], [ %12, %if.end21 ]
  %cl_prog = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 6
  store i32 %cond, i32* %cl_prog, align 8, !tbaa !155
  %number27 = getelementptr inbounds %struct.rpc_version, %struct.rpc_version* %7, i32 0, i32 0
  %14 = load i32, i32* %number27, align 8, !tbaa !234
  %cl_vers = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 7
  store i32 %14, i32* %cl_vers, align 4, !tbaa !156
  %stats = getelementptr inbounds %struct.rpc_program, %struct.rpc_program* %0, i32 0, i32 4
  %15 = load %struct.rpc_stat*, %struct.rpc_stat** %stats, align 8, !tbaa !235
  %cl_stats = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 11
  store %struct.rpc_stat* %15, %struct.rpc_stat** %cl_stats, align 8, !tbaa !52
  %call28 = call %struct.rpc_iostats* @rpc_alloc_iostats(%struct.rpc_clnt* %8)
  %cl_metrics = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 12
  store %struct.rpc_iostats* %call28, %struct.rpc_iostats** %cl_metrics, align 8, !tbaa !169
  %cl_metrics29 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 12
  %16 = load %struct.rpc_iostats*, %struct.rpc_iostats** %cl_metrics29, align 8, !tbaa !169
  %cmp30 = icmp eq %struct.rpc_iostats* %16, null
  br i1 %cmp30, label %out_no_stats, label %if.end33

if.end33:                                         ; preds = %cond.end
  %cl_program = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 22
  store %struct.rpc_program* %0, %struct.rpc_program** %cl_program, align 8, !tbaa !236
  %cl_tasks = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 2
  call void @INIT_LIST_HEAD(%struct.list_head* %cl_tasks)
  call void @spinlock_check()
  %cl_lock37 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 3
  %17 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %cl_lock37, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %17 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.16, i32 0, i32 0), %struct.lock_class_key* @rpc_new_client.__key)
  %call42 = call i32 @xprt_bound(%struct.rpc_xprt* %xprt)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.end45, label %if.then44

if.then44:                                        ; preds = %if.end33
  %cl_autobind = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 13
  %bf.load = load i8, i8* %cl_autobind, align 8
  %bf.clear = and i8 %bf.load, -5
  %bf.set = or i8 %bf.clear, 4
  store i8 %bf.set, i8* %cl_autobind, align 8
  br label %if.end45

if.end45:                                         ; preds = %if.then44, %if.end33
  %timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 2
  %18 = load %struct.rpc_timeout*, %struct.rpc_timeout** %timeout, align 8, !tbaa !183
  %cl_timeout = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 15
  store %struct.rpc_timeout* %18, %struct.rpc_timeout** %cl_timeout, align 8, !tbaa !237
  %timeout46 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 5
  %19 = load %struct.rpc_timeout*, %struct.rpc_timeout** %timeout46, align 8, !tbaa !204
  %cmp47 = icmp ne %struct.rpc_timeout* %19, null
  br i1 %cmp47, label %if.then49, label %if.end60

if.then49:                                        ; preds = %if.end45
  %cmp50 = icmp uge i64 32, 64
  %cl_timeout_default = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 21
  %20 = bitcast %struct.rpc_timeout* %cl_timeout_default to i8*
  %timeout53 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 5
  %21 = load %struct.rpc_timeout*, %struct.rpc_timeout** %timeout53, align 8, !tbaa !204
  %22 = bitcast %struct.rpc_timeout* %21 to i8*
  br i1 %cmp50, label %if.then52, label %if.else

if.then52:                                        ; preds = %if.then49
  %call54 = call i8* @__memcpy(i8* %20, i8* %22, i64 32)
  br label %if.end57

if.else:                                          ; preds = %if.then49
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %20, i8* %22, i64 32, i32 8, i1 false)
  br label %if.end57

if.end57:                                         ; preds = %if.else, %if.then52
  %cl_timeout_default58 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 21
  %cl_timeout59 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 15
  store %struct.rpc_timeout* %cl_timeout_default58, %struct.rpc_timeout** %cl_timeout59, align 8, !tbaa !237
  br label %if.end60

if.end60:                                         ; preds = %if.end57, %if.end45
  %cl_rtt_default = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 20
  %cl_rtt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 14
  store %struct.rpc_rtt* %cl_rtt_default, %struct.rpc_rtt** %cl_rtt, align 8, !tbaa !238
  %cl_rtt_default61 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 20
  %cl_timeout62 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 15
  %23 = load %struct.rpc_timeout*, %struct.rpc_timeout** %cl_timeout62, align 8, !tbaa !237
  %to_initval = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %23, i32 0, i32 0
  %24 = load i64, i64* %to_initval, align 8, !tbaa !184
  call void @rpc_init_rtt(%struct.rpc_rtt* %cl_rtt_default61, i64 %24)
  %cl_principal = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 23
  store i8* null, i8** %cl_principal, align 8, !tbaa !170
  %client_name = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 12
  %25 = load i8*, i8** %client_name, align 8, !tbaa !214
  %tobool63 = icmp ne i8* %25, null
  br i1 %tobool63, label %if.then64, label %if.end72

if.then64:                                        ; preds = %if.end60
  %client_name65 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 12
  %26 = load i8*, i8** %client_name65, align 8, !tbaa !214
  %call66 = call i8* @kstrdup(i8* %26, i32 208)
  %cl_principal67 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 23
  store i8* %call66, i8** %cl_principal67, align 8, !tbaa !170
  %cl_principal68 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 23
  %27 = load i8*, i8** %cl_principal68, align 8, !tbaa !170
  %tobool69 = icmp ne i8* %27, null
  br i1 %tobool69, label %if.end72, label %out_no_principal

if.end72:                                         ; preds = %if.then64, %if.end60
  %cl_count = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 0
  call void @atomic_set(%struct.atomic_t* %cl_count, i32 1)
  %pipe_dir_name = getelementptr inbounds %struct.rpc_program, %struct.rpc_program* %0, i32 0, i32 5
  %28 = load i8*, i8** %pipe_dir_name, align 8, !tbaa !239
  %call73 = call i32 @rpc_setup_pipedir(%struct.rpc_clnt* %8, i8* %28)
  %cmp74 = icmp slt i32 %call73, 0
  br i1 %cmp74, label %out_no_path, label %if.end77

if.end77:                                         ; preds = %if.end72
  %authflavor = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 10
  %29 = load i32, i32* %authflavor, align 8, !tbaa !212
  %call78 = call %struct.rpc_auth* @rpcauth_create(i32 %29, %struct.rpc_clnt* %8)
  %30 = bitcast %struct.rpc_auth* %call78 to i8*
  %call79 = call i64 @IS_ERR(i8* %30)
  %tobool80 = icmp ne i64 %call79, 0
  br i1 %tobool80, label %do.body82, label %if.end100

do.body82:                                        ; preds = %if.end77
  %31 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and83 = and i32 %31, 2
  %tobool84 = icmp ne i32 %and83, 0
  %lnot85 = xor i1 %tobool84, true
  %lnot87 = xor i1 %lnot85, true
  %lnot.ext88 = zext i1 %lnot87 to i32
  %conv89 = sext i32 %lnot.ext88 to i64
  %expval90 = call i64 @llvm.expect.i64(i64 %conv89, i64 0)
  %tobool91 = icmp ne i64 %expval90, 0
  br i1 %tobool91, label %if.then92, label %do.end97

if.then92:                                        ; preds = %do.body82
  %32 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end97

do.end97:                                         ; preds = %if.then92, %do.body82
  %33 = bitcast %struct.rpc_auth* %call78 to i8*
  %call98 = call i64 @PTR_ERR(i8* %33)
  %conv99 = trunc i64 %call98 to i32
  call void @rpc_clnt_remove_pipedir(%struct.rpc_clnt* %8)
  br label %out_no_path

if.end100:                                        ; preds = %if.end77
  %call101 = call %struct.new_utsname* @utsname()
  %nodename = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call101, i32 0, i32 1
  %arraydecay = getelementptr inbounds [65 x i8], [65 x i8]* %nodename, i32 0, i32 0
  call void @rpc_clnt_set_nodename(%struct.rpc_clnt* %8, i8* %arraydecay)
  call void @rpc_register_client(%struct.rpc_clnt* %8)
  br label %cleanup

out_no_path:                                      ; preds = %do.end97, %if.end72
  %err.0 = phi i32 [ %conv99, %do.end97 ], [ %call73, %if.end72 ]
  %cl_principal102 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 23
  %34 = load i8*, i8** %cl_principal102, align 8, !tbaa !170
  call void @kfree(i8* %34)
  br label %out_no_principal

out_no_principal:                                 ; preds = %out_no_path, %if.then64
  %err.1 = phi i32 [ %err.0, %out_no_path ], [ -12, %if.then64 ]
  %cl_metrics103 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %8, i32 0, i32 12
  %35 = load %struct.rpc_iostats*, %struct.rpc_iostats** %cl_metrics103, align 8, !tbaa !169
  call void @rpc_free_iostats(%struct.rpc_iostats* %35)
  br label %out_no_stats

out_no_stats:                                     ; preds = %out_no_principal, %cond.end
  %err.2 = phi i32 [ %err.1, %out_no_principal ], [ -12, %cond.end ]
  %36 = bitcast %struct.rpc_clnt* %8 to i8*
  call void @kfree(i8* %36)
  br label %out_err

out_err:                                          ; preds = %out_no_stats, %if.end17, %if.end11, %if.end7
  %err.3 = phi i32 [ %err.2, %out_no_stats ], [ -22, %if.end7 ], [ -22, %if.end11 ], [ -12, %if.end17 ]
  call void @rpciod_down()
  br label %out_no_rpciod

out_no_rpciod:                                    ; preds = %out_err, %do.end
  %err.4 = phi i32 [ %err.3, %out_err ], [ %call4, %do.end ]
  call void @xprt_put(%struct.rpc_xprt* %xprt)
  %conv104 = sext i32 %err.4 to i64
  %call105 = call i8* @ERR_PTR(i64 %conv104)
  %37 = bitcast i8* %call105 to %struct.rpc_clnt*
  br label %cleanup

cleanup:                                          ; preds = %out_no_rpciod, %if.end100
  %retval.0 = phi %struct.rpc_clnt* [ %37, %out_no_rpciod ], [ %8, %if.end100 ]
  ret %struct.rpc_clnt* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #2 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #7
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !163
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spinlock_check() #2 {
entry:
  ret void
}

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #4

declare i8* @kstrdup(i8*, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set(%struct.atomic_t* %v, i32 %i) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !240
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_setup_pipedir(%struct.rpc_clnt* %clnt, i8* %dir_name) #0 {
entry:
  %call = call %struct.net* @rpc_net_ns(%struct.rpc_clnt* %clnt)
  %cl_dentry = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 18
  store %struct.dentry* null, %struct.dentry** %cl_dentry, align 8, !tbaa !172
  %cmp = icmp eq i8* %dir_name, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call %struct.super_block* @rpc_get_sb_net(%struct.net* %call)
  %tobool = icmp ne %struct.super_block* %call1, null
  br i1 %tobool, label %if.end3, label %cleanup

if.end3:                                          ; preds = %if.end
  %call4 = call %struct.dentry* @rpc_setup_pipedir_sb(%struct.super_block* %call1, %struct.rpc_clnt* %clnt, i8* %dir_name)
  call void @rpc_put_sb_net(%struct.net* %call)
  %0 = bitcast %struct.dentry* %call4 to i8*
  %call5 = call i64 @IS_ERR(i8* %0)
  %tobool6 = icmp ne i64 %call5, 0
  br i1 %tobool6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end3
  %1 = bitcast %struct.dentry* %call4 to i8*
  %call8 = call i64 @PTR_ERR(i8* %1)
  %conv = trunc i64 %call8 to i32
  br label %cleanup

if.end9:                                          ; preds = %if.end3
  %cl_dentry10 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 18
  store %struct.dentry* %call4, %struct.dentry** %cl_dentry10, align 8, !tbaa !172
  br label %cleanup

cleanup:                                          ; preds = %if.end9, %if.then7, %if.end, %entry
  %retval.0 = phi i32 [ %conv, %if.then7 ], [ 0, %if.end9 ], [ 0, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.new_utsname* @utsname() #2 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !84
  %nsproxy = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 74
  %1 = load %struct.nsproxy*, %struct.nsproxy** %nsproxy, align 8, !tbaa !241
  %uts_ns = getelementptr inbounds %struct.nsproxy, %struct.nsproxy* %1, i32 0, i32 1
  %2 = load %struct.uts_namespace*, %struct.uts_namespace** %uts_ns, align 8, !tbaa !242
  %name = getelementptr inbounds %struct.uts_namespace, %struct.uts_namespace* %2, i32 0, i32 1
  ret %struct.new_utsname* %name
}

; Function Attrs: nounwind uwtable
define internal void @rpc_clnt_set_nodename(%struct.rpc_clnt* %clnt, i8* %nodename) #0 {
entry:
  %call = call i64 @strlen(i8* %nodename)
  %conv = trunc i64 %call to i32
  %cl_nodelen = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 16
  store i32 %conv, i32* %cl_nodelen, align 8, !tbaa !244
  %cl_nodelen1 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 16
  %0 = load i32, i32* %cl_nodelen1, align 8, !tbaa !244
  %cmp = icmp sgt i32 %0, 32
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %cl_nodelen3 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 16
  store i32 32, i32* %cl_nodelen3, align 8, !tbaa !244
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %cl_nodelen4 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 16
  %1 = load i32, i32* %cl_nodelen4, align 8, !tbaa !244
  %conv5 = sext i32 %1 to i64
  %cl_nodename = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 17
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %cl_nodename, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arraydecay, i8* %nodename, i64 %conv5, i32 1, i1 false)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_register_client(%struct.rpc_clnt* %clnt) #0 {
entry:
  %call = call %struct.net* @rpc_net_ns(%struct.rpc_clnt* %clnt)
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call1 = call i8* @net_generic(%struct.net* %call, i32 %0)
  %1 = bitcast i8* %call1 to %struct.sunrpc_net*
  %rpc_client_lock = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 8
  call void @spin_lock(%struct.spinlock* %rpc_client_lock)
  %cl_clients = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 1
  %all_clients = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 7
  call void @list_add(%struct.list_head* %cl_clients, %struct.list_head* %all_clients)
  %rpc_client_lock2 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 8
  call void @spin_unlock(%struct.spinlock* %rpc_client_lock2)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add(%struct.list_head* %new, %struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

declare i64 @strlen(i8*) #4

; Function Attrs: nounwind uwtable
define internal %struct.dentry* @rpc_setup_pipedir_sb(%struct.super_block* %sb, %struct.rpc_clnt* %clnt, i8* %dir_name) #0 {
entry:
  %name = alloca [15 x i8], align 1
  %q = alloca %struct.qstr, align 8
  %0 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 0
  %1 = bitcast %struct.pgprot* %0 to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 8, i32 8, i1 false)
  %name1 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 1
  %arraydecay = getelementptr inbounds [15 x i8], [15 x i8]* %name, i32 0, i32 0
  store i8* %arraydecay, i8** %name1, align 8, !tbaa !245
  %call = call %struct.dentry* @rpc_d_lookup_sb(%struct.super_block* %sb, i8* %dir_name)
  %cmp = icmp eq %struct.dentry* %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %if.end18, %if.end
  %arraydecay3 = getelementptr inbounds [15 x i8], [15 x i8]* %name, i32 0, i32 0
  %3 = load i32, i32* @rpc_setup_pipedir_sb.clntid, align 4, !tbaa !49
  %inc = add i32 %3, 1
  store i32 %inc, i32* @rpc_setup_pipedir_sb.clntid, align 4, !tbaa !49
  %call4 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay3, i64 15, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.13, i32 0, i32 0), i32 %3)
  %4 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 0
  %5 = bitcast %struct.pgprot* %4 to %struct.exception_table_entry*
  %len = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %5, i32 0, i32 1
  store i32 %call4, i32* %len, align 4, !tbaa !166
  %arrayidx = getelementptr inbounds [15 x i8], [15 x i8]* %name, i64 0, i64 14
  store i8 0, i8* %arrayidx, align 1, !tbaa !166
  %name5 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 1
  %6 = load i8*, i8** %name5, align 8, !tbaa !245
  %7 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 0
  %8 = bitcast %struct.pgprot* %7 to %struct.exception_table_entry*
  %len6 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %8, i32 0, i32 1
  %9 = load i32, i32* %len6, align 4, !tbaa !166
  %call7 = call i32 @full_name_hash(i8* %6, i32 %9)
  %10 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 0
  %11 = bitcast %struct.pgprot* %10 to %struct.exception_table_entry*
  %hash = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %11, i32 0, i32 0
  store i32 %call7, i32* %hash, align 8, !tbaa !166
  %call8 = call %struct.dentry* @rpc_create_client_dir(%struct.dentry* %call, %struct.qstr* %q, %struct.rpc_clnt* %clnt)
  %12 = bitcast %struct.dentry* %call8 to i8*
  %call9 = call i64 @IS_ERR(i8* %12)
  %tobool = icmp ne i64 %call9, 0
  br i1 %tobool, label %if.end11, label %for.end

if.end11:                                         ; preds = %for.cond
  %13 = bitcast %struct.dentry* %call8 to i8*
  %call12 = call i64 @PTR_ERR(i8* %13)
  %conv = trunc i64 %call12 to i32
  %cmp13 = icmp ne i32 %conv, -17
  br i1 %cmp13, label %if.then15, label %if.end18

if.then15:                                        ; preds = %if.end11
  %14 = call i32 (i8*, ...) @printk(i8* null)
  br label %for.end

if.end18:                                         ; preds = %if.end11
  br label %for.cond

for.end:                                          ; preds = %if.then15, %for.cond
  call void @dput(%struct.dentry* %call)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then
  %retval.0 = phi %struct.dentry* [ %call, %if.then ], [ %call8, %for.end ]
  ret %struct.dentry* %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #1

declare i32 @snprintf(i8*, i64, i8*, ...) #4

declare i32 @full_name_hash(i8*, i32) #4

declare void @dput(%struct.dentry*) #4

declare i8* @__kmalloc(i64, i32) #4

; Function Attrs: nounwind uwtable
define %struct.rpc_clnt* @rpc_clone_client_set_auth(%struct.rpc_clnt* %clnt, i32 %flavor) #0 {
entry:
  %args = alloca %struct.rpc_create_args, align 8
  %net = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 0
  store %struct.net* null, %struct.net** %net, align 8, !tbaa !198
  %protocol = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 1
  store i32 0, i32* %protocol, align 8, !tbaa !200
  %address = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 2
  store %struct.sockaddr* null, %struct.sockaddr** %address, align 8, !tbaa !201
  %addrsize = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 3
  store i64 0, i64* %addrsize, align 8, !tbaa !202
  %saddress = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 4
  store %struct.sockaddr* null, %struct.sockaddr** %saddress, align 8, !tbaa !203
  %timeout = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 5
  store %struct.rpc_timeout* null, %struct.rpc_timeout** %timeout, align 8, !tbaa !204
  %servername = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 6
  store i8* null, i8** %servername, align 8, !tbaa !205
  %program = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 7
  %cl_program = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 22
  %0 = load %struct.rpc_program*, %struct.rpc_program** %cl_program, align 8, !tbaa !236
  store %struct.rpc_program* %0, %struct.rpc_program** %program, align 8, !tbaa !206
  %prognumber = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 8
  %cl_prog = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 6
  %1 = load i32, i32* %cl_prog, align 8, !tbaa !155
  store i32 %1, i32* %prognumber, align 8, !tbaa !209
  %version = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 9
  %cl_vers = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 7
  %2 = load i32, i32* %cl_vers, align 4, !tbaa !156
  store i32 %2, i32* %version, align 4, !tbaa !210
  %authflavor = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 10
  store i32 %flavor, i32* %authflavor, align 8, !tbaa !212
  %flags = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 11
  store i64 0, i64* %flags, align 8, !tbaa !213
  %client_name = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 12
  %cl_principal = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 23
  %3 = load i8*, i8** %cl_principal, align 8, !tbaa !170
  store i8* %3, i8** %client_name, align 8, !tbaa !214
  %bc_xprt = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 13
  store %struct.svc_xprt* null, %struct.svc_xprt** %bc_xprt, align 8, !tbaa !215
  %call = call %struct.rpc_clnt* @__rpc_clone_client(%struct.rpc_create_args* %args, %struct.rpc_clnt* %clnt)
  ret %struct.rpc_clnt* %call
}

; Function Attrs: nounwind uwtable
define %struct.rpc_clnt* @rpc_clone_client(%struct.rpc_clnt* %clnt) #0 {
entry:
  %args = alloca %struct.rpc_create_args, align 8
  %net = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 0
  store %struct.net* null, %struct.net** %net, align 8, !tbaa !198
  %protocol = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 1
  store i32 0, i32* %protocol, align 8, !tbaa !200
  %address = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 2
  store %struct.sockaddr* null, %struct.sockaddr** %address, align 8, !tbaa !201
  %addrsize = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 3
  store i64 0, i64* %addrsize, align 8, !tbaa !202
  %saddress = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 4
  store %struct.sockaddr* null, %struct.sockaddr** %saddress, align 8, !tbaa !203
  %timeout = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 5
  store %struct.rpc_timeout* null, %struct.rpc_timeout** %timeout, align 8, !tbaa !204
  %servername = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 6
  store i8* null, i8** %servername, align 8, !tbaa !205
  %program = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 7
  %cl_program = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 22
  %0 = load %struct.rpc_program*, %struct.rpc_program** %cl_program, align 8, !tbaa !236
  store %struct.rpc_program* %0, %struct.rpc_program** %program, align 8, !tbaa !206
  %prognumber = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 8
  %cl_prog = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 6
  %1 = load i32, i32* %cl_prog, align 8, !tbaa !155
  store i32 %1, i32* %prognumber, align 8, !tbaa !209
  %version = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 9
  %cl_vers = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 7
  %2 = load i32, i32* %cl_vers, align 4, !tbaa !156
  store i32 %2, i32* %version, align 4, !tbaa !210
  %authflavor = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 10
  %cl_auth = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 10
  %3 = load %struct.rpc_auth*, %struct.rpc_auth** %cl_auth, align 8, !tbaa !167
  %au_flavor = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %3, i32 0, i32 5
  %4 = load i32, i32* %au_flavor, align 8, !tbaa !211
  store i32 %4, i32* %authflavor, align 8, !tbaa !212
  %flags = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 11
  store i64 0, i64* %flags, align 8, !tbaa !213
  %client_name = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 12
  %cl_principal = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 23
  %5 = load i8*, i8** %cl_principal, align 8, !tbaa !170
  store i8* %5, i8** %client_name, align 8, !tbaa !214
  %bc_xprt = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 13
  store %struct.svc_xprt* null, %struct.svc_xprt** %bc_xprt, align 8, !tbaa !215
  %call = call %struct.rpc_clnt* @__rpc_clone_client(%struct.rpc_create_args* %args, %struct.rpc_clnt* %clnt)
  ret %struct.rpc_clnt* %call
}

; Function Attrs: nounwind uwtable
define %struct.rpc_clnt* @rpc_create(%struct.rpc_create_args* %args) #0 {
entry:
  %xprtargs = alloca %struct.xprt_create, align 8
  %servername4 = alloca [48 x i8], align 16
  %ident = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %xprtargs, i32 0, i32 0
  %protocol = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 1
  %0 = load i32, i32* %protocol, align 8, !tbaa !200
  store i32 %0, i32* %ident, align 8, !tbaa !247
  %net = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %xprtargs, i32 0, i32 1
  %net1 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 0
  %1 = load %struct.net*, %struct.net** %net1, align 8, !tbaa !198
  store %struct.net* %1, %struct.net** %net, align 8, !tbaa !249
  %srcaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %xprtargs, i32 0, i32 2
  %saddress = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 4
  %2 = load %struct.sockaddr*, %struct.sockaddr** %saddress, align 8, !tbaa !203
  store %struct.sockaddr* %2, %struct.sockaddr** %srcaddr, align 8, !tbaa !250
  %dstaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %xprtargs, i32 0, i32 3
  %address = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 2
  %3 = load %struct.sockaddr*, %struct.sockaddr** %address, align 8, !tbaa !201
  store %struct.sockaddr* %3, %struct.sockaddr** %dstaddr, align 8, !tbaa !251
  %addrlen = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %xprtargs, i32 0, i32 4
  %addrsize = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 3
  %4 = load i64, i64* %addrsize, align 8, !tbaa !202
  store i64 %4, i64* %addrlen, align 8, !tbaa !252
  %servername = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %xprtargs, i32 0, i32 5
  %servername2 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 6
  %5 = load i8*, i8** %servername2, align 8, !tbaa !205
  store i8* %5, i8** %servername, align 8, !tbaa !253
  %bc_xprt = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %xprtargs, i32 0, i32 6
  %bc_xprt3 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 13
  %6 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt3, align 8, !tbaa !215
  store %struct.svc_xprt* %6, %struct.svc_xprt** %bc_xprt, align 8, !tbaa !254
  %flags = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %xprtargs, i32 0, i32 7
  store i32 0, i32* %flags, align 8, !tbaa !255
  %flags5 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 11
  %7 = load i64, i64* %flags5, align 8, !tbaa !213
  %and = and i64 %7, 128
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %flags6 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %xprtargs, i32 0, i32 7
  %8 = load i32, i32* %flags6, align 8, !tbaa !255
  %or = or i32 %8, 1
  store i32 %or, i32* %flags6, align 8, !tbaa !255
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %flags7 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 11
  %9 = load i64, i64* %flags7, align 8, !tbaa !213
  %and8 = and i64 %9, 256
  %tobool9 = icmp ne i64 %and8, 0
  br i1 %tobool9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %if.end
  %flags11 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %xprtargs, i32 0, i32 7
  %10 = load i32, i32* %flags11, align 8, !tbaa !255
  %or12 = or i32 %10, 2
  store i32 %or12, i32* %flags11, align 8, !tbaa !255
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %if.end
  %servername14 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %xprtargs, i32 0, i32 5
  %11 = load i8*, i8** %servername14, align 8, !tbaa !253
  %cmp = icmp eq i8* %11, null
  br i1 %cmp, label %if.then15, label %if.end32

if.then15:                                        ; preds = %if.end13
  %address16 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 2
  %12 = load %struct.sockaddr*, %struct.sockaddr** %address16, align 8, !tbaa !201
  %13 = bitcast %struct.sockaddr* %12 to %struct.sockaddr_un*
  %address17 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 2
  %14 = load %struct.sockaddr*, %struct.sockaddr** %address17, align 8, !tbaa !201
  %15 = bitcast %struct.sockaddr* %14 to %struct.sockaddr_in*
  %address18 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 2
  %16 = load %struct.sockaddr*, %struct.sockaddr** %address18, align 8, !tbaa !201
  %17 = bitcast %struct.sockaddr* %16 to %struct.sockaddr_in6*
  %arrayidx = getelementptr inbounds [48 x i8], [48 x i8]* %servername4, i64 0, i64 0
  store i8 0, i8* %arrayidx, align 16, !tbaa !166
  %address19 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 2
  %18 = load %struct.sockaddr*, %struct.sockaddr** %address19, align 8, !tbaa !201
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %18, i32 0, i32 0
  %19 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %19 to i32
  %Pivot6 = icmp slt i32 %conv, 2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.then15
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf4, label %sw.bb24, label %sw.default

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf2, label %sw.bb21, label %sw.default

LeafBlock:                                        ; preds = %if.then15
  %SwitchLeaf = icmp eq i32 %conv, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %servername4, i32 0, i32 0
  %sun_path = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %13, i32 0, i32 1
  %arraydecay20 = getelementptr inbounds [108 x i8], [108 x i8]* %sun_path, i32 0, i32 0
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 48, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i8* %arraydecay20)
  br label %sw.epilog

sw.bb21:                                          ; preds = %LeafBlock1
  %arraydecay22 = getelementptr inbounds [48 x i8], [48 x i8]* %servername4, i32 0, i32 0
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %15, i32 0, i32 2
  %s_addr = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %sin_addr, i32 0, i32 0
  %call23 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay22, i64 48, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1.794, i32 0, i32 0), i32* %s_addr)
  br label %sw.epilog

sw.bb24:                                          ; preds = %LeafBlock3
  %arraydecay25 = getelementptr inbounds [48 x i8], [48 x i8]* %servername4, i32 0, i32 0
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %17, i32 0, i32 3
  %call26 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay25, i64 48, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19.780, i32 0, i32 0), %struct.in6_addr* %sin6_addr)
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  %call27 = call i8* @ERR_PTR(i64 -22)
  %20 = bitcast i8* %call27 to %struct.rpc_clnt*
  br label %LeafBlock8

sw.epilog:                                        ; preds = %sw.bb24, %sw.bb21, %sw.bb
  %arraydecay28 = getelementptr inbounds [48 x i8], [48 x i8]* %servername4, i32 0, i32 0
  %servername29 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %xprtargs, i32 0, i32 5
  store i8* %arraydecay28, i8** %servername29, align 8, !tbaa !253
  br label %LeafBlock8

LeafBlock8:                                       ; preds = %sw.epilog, %sw.default
  %cleanup.dest.slot.0 = phi i32 [ 0, %sw.epilog ], [ 1, %sw.default ]
  %retval.0 = phi %struct.rpc_clnt* [ undef, %sw.epilog ], [ %20, %sw.default ]
  %SwitchLeaf9 = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf9, label %if.end32, label %cleanup101

if.end32:                                         ; preds = %LeafBlock8, %if.end13
  %retval.1 = phi %struct.rpc_clnt* [ undef, %if.end13 ], [ %retval.0, %LeafBlock8 ]
  %call33 = call %struct.rpc_xprt* @xprt_create_transport(%struct.xprt_create* %xprtargs)
  %21 = bitcast %struct.rpc_xprt* %call33 to i8*
  %call34 = call i64 @IS_ERR(i8* %21)
  %tobool35 = icmp ne i64 %call34, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end32
  %22 = bitcast %struct.rpc_xprt* %call33 to %struct.rpc_clnt*
  br label %cleanup101

if.end37:                                         ; preds = %if.end32
  %resvport = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call33, i32 0, i32 19
  %bf.load = load i8, i8* %resvport, align 8
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %resvport, align 8
  %flags38 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 11
  %23 = load i64, i64* %flags38, align 8, !tbaa !213
  %and39 = and i64 %23, 8
  %tobool40 = icmp ne i64 %and39, 0
  br i1 %tobool40, label %if.then41, label %if.end45

if.then41:                                        ; preds = %if.end37
  %resvport42 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call33, i32 0, i32 19
  %bf.load43 = load i8, i8* %resvport42, align 8
  %bf.clear44 = and i8 %bf.load43, -2
  store i8 %bf.clear44, i8* %resvport42, align 8
  br label %if.end45

if.end45:                                         ; preds = %if.then41, %if.end37
  %call46 = call %struct.rpc_clnt* @rpc_new_client(%struct.rpc_create_args* %args, %struct.rpc_xprt* %call33)
  %24 = bitcast %struct.rpc_clnt* %call46 to i8*
  %call47 = call i64 @IS_ERR(i8* %24)
  %tobool48 = icmp ne i64 %call47, 0
  br i1 %tobool48, label %cleanup101, label %if.end50

if.end50:                                         ; preds = %if.end45
  %flags51 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 11
  %25 = load i64, i64* %flags51, align 8, !tbaa !213
  %and52 = and i64 %25, 16
  %tobool53 = icmp ne i64 %and52, 0
  br i1 %tobool53, label %if.end65, label %if.then54

if.then54:                                        ; preds = %if.end50
  %call55 = call i32 @rpc_ping(%struct.rpc_clnt* %call46)
  %cmp56 = icmp ne i32 %call55, 0
  br i1 %cmp56, label %if.then58, label %LeafBlock11

if.then58:                                        ; preds = %if.then54
  call void @rpc_shutdown_client(%struct.rpc_clnt* %call46)
  %conv59 = sext i32 %call55 to i64
  %call60 = call i8* @ERR_PTR(i64 %conv59)
  %26 = bitcast i8* %call60 to %struct.rpc_clnt*
  br label %LeafBlock11

LeafBlock11:                                      ; preds = %if.then58, %if.then54
  %cleanup.dest.slot.1 = phi i32 [ 1, %if.then58 ], [ 0, %if.then54 ]
  %retval.2 = phi %struct.rpc_clnt* [ %26, %if.then58 ], [ %retval.1, %if.then54 ]
  %SwitchLeaf12 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf12, label %if.end65, label %cleanup101

if.end65:                                         ; preds = %LeafBlock11, %if.end50
  %cl_softrtry = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %call46, i32 0, i32 13
  %bf.load66 = load i8, i8* %cl_softrtry, align 8
  %bf.clear67 = and i8 %bf.load66, -2
  %bf.set68 = or i8 %bf.clear67, 1
  store i8 %bf.set68, i8* %cl_softrtry, align 8
  %flags69 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 11
  %27 = load i64, i64* %flags69, align 8, !tbaa !213
  %and70 = and i64 %27, 1
  %tobool71 = icmp ne i64 %and70, 0
  br i1 %tobool71, label %if.then72, label %if.end76

if.then72:                                        ; preds = %if.end65
  %cl_softrtry73 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %call46, i32 0, i32 13
  %bf.load74 = load i8, i8* %cl_softrtry73, align 8
  %bf.clear75 = and i8 %bf.load74, -2
  store i8 %bf.clear75, i8* %cl_softrtry73, align 8
  br label %if.end76

if.end76:                                         ; preds = %if.then72, %if.end65
  %flags77 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 11
  %28 = load i64, i64* %flags77, align 8, !tbaa !213
  %and78 = and i64 %28, 4
  %tobool79 = icmp ne i64 %and78, 0
  br i1 %tobool79, label %if.then80, label %if.end84

if.then80:                                        ; preds = %if.end76
  %cl_autobind = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %call46, i32 0, i32 13
  %bf.load81 = load i8, i8* %cl_autobind, align 8
  %bf.clear82 = and i8 %bf.load81, -5
  %bf.set83 = or i8 %bf.clear82, 4
  store i8 %bf.set83, i8* %cl_autobind, align 8
  br label %if.end84

if.end84:                                         ; preds = %if.then80, %if.end76
  %flags85 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 11
  %29 = load i64, i64* %flags85, align 8, !tbaa !213
  %and86 = and i64 %29, 32
  %tobool87 = icmp ne i64 %and86, 0
  br i1 %tobool87, label %if.then88, label %if.end92

if.then88:                                        ; preds = %if.end84
  %cl_discrtry = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %call46, i32 0, i32 13
  %bf.load89 = load i8, i8* %cl_discrtry, align 8
  %bf.clear90 = and i8 %bf.load89, -3
  %bf.set91 = or i8 %bf.clear90, 2
  store i8 %bf.set91, i8* %cl_discrtry, align 8
  br label %if.end92

if.end92:                                         ; preds = %if.then88, %if.end84
  %flags93 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 11
  %30 = load i64, i64* %flags93, align 8, !tbaa !213
  %and94 = and i64 %30, 64
  %tobool95 = icmp ne i64 %and94, 0
  br i1 %tobool95, label %cleanup101, label %if.then96

if.then96:                                        ; preds = %if.end92
  %cl_chatty = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %call46, i32 0, i32 13
  %bf.load97 = load i8, i8* %cl_chatty, align 8
  %bf.clear98 = and i8 %bf.load97, -9
  %bf.set99 = or i8 %bf.clear98, 8
  store i8 %bf.set99, i8* %cl_chatty, align 8
  br label %cleanup101

cleanup101:                                       ; preds = %if.then96, %if.end92, %LeafBlock11, %if.end45, %if.then36, %LeafBlock8
  %retval.3 = phi %struct.rpc_clnt* [ %22, %if.then36 ], [ %call46, %if.end45 ], [ %call46, %if.then96 ], [ %call46, %if.end92 ], [ %retval.0, %LeafBlock8 ], [ %retval.2, %LeafBlock11 ]
  ret %struct.rpc_clnt* %retval.3
}

; Function Attrs: nounwind uwtable
define i32 @rpc_clients_notifier_register() #0 {
entry:
  %call = call i32 @rpc_pipefs_notifier_register(%struct.notifier_block* @rpc_clients_block)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_pipefs_event(%struct.notifier_block* %nb, i64 %event, i8* %ptr) #0 {
entry:
  %0 = bitcast i8* %ptr to %struct.super_block*
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %error.0 = phi i32 [ 0, %entry ], [ %call1, %if.end ]
  %s_fs_info = getelementptr inbounds %struct.super_block, %struct.super_block* %0, i32 0, i32 36
  %1 = load i8*, i8** %s_fs_info, align 16, !tbaa !256
  %2 = bitcast i8* %1 to %struct.net*
  %conv = trunc i64 %event to i32
  %call = call %struct.rpc_clnt* @rpc_get_client_for_event(%struct.net* %2, i32 %conv)
  %tobool = icmp ne %struct.rpc_clnt* %call, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call1 = call i32 @__rpc_pipefs_event(%struct.rpc_clnt* %call, i64 %event, %struct.super_block* %0)
  call void @rpc_release_client(%struct.rpc_clnt* %call)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %while.end, label %if.end

if.end:                                           ; preds = %while.body
  br label %while.cond

while.end:                                        ; preds = %while.body, %while.cond
  %error.1 = phi i32 [ %call1, %while.body ], [ %error.0, %while.cond ]
  ret i32 %error.1
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_clnt* @rpc_get_client_for_event(%struct.net* %net, i32 %event) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %rpc_client_lock = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 8
  call void @spin_lock(%struct.spinlock* %rpc_client_lock)
  %all_clients = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 7
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %cl_clients13.sink = phi %struct.list_head* [ %cl_clients13, %for.inc ], [ %all_clients, %entry ]
  %next14 = getelementptr inbounds %struct.list_head, %struct.list_head* %cl_clients13.sink, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next14, align 8, !tbaa !28
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr16 = getelementptr inbounds i8, i8* %3, i64 -8
  %4 = bitcast i8* %add.ptr16 to %struct.rpc_clnt*
  %cl_clients = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %4, i32 0, i32 1
  %all_clients1 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 7
  %cmp = icmp ne %struct.list_head* %cl_clients, %all_clients1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %cl_program = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %4, i32 0, i32 22
  %5 = load %struct.rpc_program*, %struct.rpc_program** %cl_program, align 8, !tbaa !236
  %pipe_dir_name = getelementptr inbounds %struct.rpc_program, %struct.rpc_program* %5, i32 0, i32 5
  %6 = load i8*, i8** %pipe_dir_name, align 8, !tbaa !239
  %cmp2 = icmp eq i8* %6, null
  br i1 %cmp2, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %conv = sext i32 %event to i64
  %call3 = call i32 @rpc_clnt_skip_event(%struct.rpc_clnt* %4, i64 %conv)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %for.inc, label %if.end5

if.end5:                                          ; preds = %if.end
  %cl_count = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %4, i32 0, i32 0
  %call6 = call i32 @atomic_add_unless(%struct.atomic_t* %cl_count, i32 1, i32 0)
  %cmp7 = icmp eq i32 %call6, 0
  br i1 %cmp7, label %for.inc, label %if.end10

if.end10:                                         ; preds = %if.end5
  %rpc_client_lock11 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 8
  call void @spin_unlock(%struct.spinlock* %rpc_client_lock11)
  br label %cleanup

for.inc:                                          ; preds = %if.end5, %if.end, %for.body
  %cl_clients13 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %4, i32 0, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %rpc_client_lock17 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 8
  call void @spin_unlock(%struct.spinlock* %rpc_client_lock17)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.end10
  %retval.0 = phi %struct.rpc_clnt* [ %4, %if.end10 ], [ null, %for.end ]
  ret %struct.rpc_clnt* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @__rpc_pipefs_event(%struct.rpc_clnt* %clnt, i64 %event, %struct.super_block* %sb) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %error.0 = phi i32 [ 0, %entry ], [ %error.1, %for.inc ]
  %clnt.addr.0 = phi %struct.rpc_clnt* [ %clnt, %entry ], [ %1, %for.inc ]
  %call = call i32 @rpc_clnt_skip_event(%struct.rpc_clnt* %clnt.addr.0, i64 %event)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.cond
  %call1 = call i32 @__rpc_clnt_handle_event(%struct.rpc_clnt* %clnt.addr.0, i64 %event, %struct.super_block* %sb)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.cond
  %error.1 = phi i32 [ %error.0, %for.cond ], [ %call1, %if.then ]
  %tobool2 = icmp ne i32 %error.1, 0
  br i1 %tobool2, label %for.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %cl_parent = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt.addr.0, i32 0, i32 19
  %0 = load %struct.rpc_clnt*, %struct.rpc_clnt** %cl_parent, align 8, !tbaa !168
  %cmp = icmp eq %struct.rpc_clnt* %clnt.addr.0, %0
  br i1 %cmp, label %for.end, label %for.inc

for.inc:                                          ; preds = %lor.lhs.false
  %cl_parent5 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt.addr.0, i32 0, i32 19
  %1 = load %struct.rpc_clnt*, %struct.rpc_clnt** %cl_parent5, align 8, !tbaa !168
  br label %for.cond

for.end:                                          ; preds = %lor.lhs.false, %if.end
  ret i32 %error.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rpc_clnt_skip_event(%struct.rpc_clnt* %clnt, i64 %event) #2 {
entry:
  switch i64 %event, label %if.end [
    i64 0, label %land.lhs.true
    i64 1, label %land.lhs.true2
  ]

land.lhs.true:                                    ; preds = %entry
  %cl_dentry = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 18
  %0 = load %struct.dentry*, %struct.dentry** %cl_dentry, align 8, !tbaa !172
  %tobool = icmp ne %struct.dentry* %0, null
  br i1 %tobool, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %cmp1 = icmp eq i64 %event, 1
  br i1 %cmp1, label %land.lhs.true2, label %if.end

land.lhs.true2:                                   ; preds = %lor.lhs.false, %entry
  %cl_dentry3 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 18
  %1 = load %struct.dentry*, %struct.dentry** %cl_dentry3, align 8, !tbaa !172
  %tobool4 = icmp ne %struct.dentry* %1, null
  br i1 %tobool4, label %if.end, label %return

if.end:                                           ; preds = %land.lhs.true2, %lor.lhs.false, %entry
  br label %return

return:                                           ; preds = %if.end, %land.lhs.true2, %land.lhs.true
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %land.lhs.true2 ], [ 1, %land.lhs.true ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @__rpc_clnt_handle_event(%struct.rpc_clnt* %clnt, i64 %event, %struct.super_block* %sb) #0 {
entry:
  %Pivot = icmp slt i64 %event, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i64 %event, 1
  br i1 %SwitchLeaf2, label %sw.bb17, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i64 %event, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %cl_program = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 22
  %0 = load %struct.rpc_program*, %struct.rpc_program** %cl_program, align 8, !tbaa !236
  %pipe_dir_name = getelementptr inbounds %struct.rpc_program, %struct.rpc_program* %0, i32 0, i32 5
  %1 = load i8*, i8** %pipe_dir_name, align 8, !tbaa !239
  %call = call %struct.dentry* @rpc_setup_pipedir_sb(%struct.super_block* %sb, %struct.rpc_clnt* %clnt, i8* %1)
  %tobool = icmp ne %struct.dentry* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %sw.bb
  %2 = bitcast %struct.dentry* %call to i8*
  %call1 = call i64 @IS_ERR(i8* %2)
  %tobool2 = icmp ne i64 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %3 = bitcast %struct.dentry* %call to i8*
  %call4 = call i64 @PTR_ERR(i8* %3)
  %conv = trunc i64 %call4 to i32
  br label %cleanup

if.end5:                                          ; preds = %if.end
  %cl_dentry = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 18
  store %struct.dentry* %call, %struct.dentry** %cl_dentry, align 8, !tbaa !172
  %cl_auth = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 10
  %4 = load %struct.rpc_auth*, %struct.rpc_auth** %cl_auth, align 8, !tbaa !167
  %au_ops = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %4, i32 0, i32 4
  %5 = load %struct.rpc_authops*, %struct.rpc_authops** %au_ops, align 8, !tbaa !173
  %pipes_create = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %5, i32 0, i32 7
  %6 = load i32 (%struct.rpc_auth*)*, i32 (%struct.rpc_auth*)** %pipes_create, align 8, !tbaa !264
  %tobool6 = icmp ne i32 (%struct.rpc_auth*)* %6, null
  br i1 %tobool6, label %if.then7, label %cleanup

if.then7:                                         ; preds = %if.end5
  %cl_auth8 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 10
  %7 = load %struct.rpc_auth*, %struct.rpc_auth** %cl_auth8, align 8, !tbaa !167
  %au_ops9 = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %7, i32 0, i32 4
  %8 = load %struct.rpc_authops*, %struct.rpc_authops** %au_ops9, align 8, !tbaa !173
  %pipes_create10 = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %8, i32 0, i32 7
  %9 = load i32 (%struct.rpc_auth*)*, i32 (%struct.rpc_auth*)** %pipes_create10, align 8, !tbaa !264
  %cl_auth11 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 10
  %10 = load %struct.rpc_auth*, %struct.rpc_auth** %cl_auth11, align 8, !tbaa !167
  %call12 = call i32 %9(%struct.rpc_auth* %10)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then14, label %cleanup

if.then14:                                        ; preds = %if.then7
  call void @__rpc_clnt_remove_pipedir(%struct.rpc_clnt* %clnt)
  br label %cleanup

sw.bb17:                                          ; preds = %LeafBlock1
  call void @__rpc_clnt_remove_pipedir(%struct.rpc_clnt* %clnt)
  br label %cleanup

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %11 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %sw.default, %sw.bb17, %if.then14, %if.then7, %if.end5, %if.then3, %sw.bb
  %retval.0 = phi i32 [ %conv, %if.then3 ], [ -524, %sw.default ], [ -2, %sw.bb ], [ 0, %sw.bb17 ], [ 0, %if.end5 ], [ %call12, %if.then14 ], [ %call12, %if.then7 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_unless(%struct.atomic_t* %v, i32 %a, i32 %u) #2 {
entry:
  %call = call i32 @__atomic_add_unless(%struct.atomic_t* %v, i32 %a, i32 %u)
  %cmp = icmp ne i32 %call, %u
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__atomic_add_unless(%struct.atomic_t* %v, i32 %a, i32 %u) #2 {
entry:
  %call = call i32 @atomic_read(%struct.atomic_t* %v)
  br label %for.cond

for.cond:                                         ; preds = %if.end13, %entry
  %c.0 = phi i32 [ %call, %entry ], [ %call2, %if.end13 ]
  %cmp = icmp eq i32 %c.0, %u
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %for.end, label %if.end

if.end:                                           ; preds = %for.cond
  %add = add nsw i32 %c.0, %a
  %call2 = call i32 @atomic_cmpxchg(%struct.atomic_t* %v, i32 %c.0, i32 %add)
  %cmp3 = icmp eq i32 %call2, %c.0
  %lnot5 = xor i1 %cmp3, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %expval10 = call i64 @llvm.expect.i64(i64 %conv9, i64 1)
  %tobool11 = icmp ne i64 %expval10, 0
  br i1 %tobool11, label %for.end, label %if.end13

if.end13:                                         ; preds = %if.end
  br label %for.cond

for.end:                                          ; preds = %if.end, %for.cond
  ret i32 %c.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_cmpxchg(%struct.atomic_t* %v, i32 %old, i32 %new) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; cmpxchgl $2,$1", "={ax},=*m,r,0,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %new, i32 %old, i32* %counter) #7, !srcloc !265
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define void @rpc_clients_notifier_unregister() #0 {
entry:
  call void @rpc_pipefs_notifier_unregister(%struct.notifier_block* @rpc_clients_block)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.rpc_task* @rpc_run_bc_task(%struct.rpc_rqst* %req, %struct.rpc_call_ops* %tk_ops) #0 {
entry:
  %task_setup_data = alloca %struct.rpc_task_setup, align 8
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 1
  %0 = bitcast %struct.rpc_task_setup* %task_setup_data to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 56, i32 8, i1 false)
  %callback_ops = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 3
  store %struct.rpc_call_ops* %tk_ops, %struct.rpc_call_ops** %callback_ops, align 8, !tbaa !15
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %call4 = call %struct.rpc_task* @rpc_new_task(%struct.rpc_task_setup* %task_setup_data)
  %3 = bitcast %struct.rpc_task* %call4 to i8*
  %call5 = call i64 @IS_ERR(i8* %3)
  %tobool6 = icmp ne i64 %call5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %do.end
  call void @xprt_free_bc_request(%struct.rpc_rqst* %req)
  br label %do.body66

if.end8:                                          ; preds = %do.end
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %call4, i32 0, i32 3
  store %struct.rpc_rqst* %req, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %4 = load i64, i64* %iov_len, align 8, !tbaa !149
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 4
  %5 = load i32, i32* %page_len, align 4, !tbaa !150
  %conv9 = zext i32 %5 to i64
  %add = add i64 %4, %conv9
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 1
  %arrayidx10 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_len11 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx10, i32 0, i32 1
  %6 = load i64, i64* %iov_len11, align 8, !tbaa !149
  %add12 = add i64 %add, %6
  %conv13 = trunc i64 %add12 to i32
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 7
  store i32 %conv13, i32* %len, align 8, !tbaa !152
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %call4, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_bc_transmit, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  %tk_count = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %call4, i32 0, i32 0
  call void @atomic_inc(%struct.atomic_t* %tk_count)
  %tk_count14 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %call4, i32 0, i32 0
  %call15 = call i32 @atomic_read(%struct.atomic_t* %tk_count14)
  %cmp = icmp ne i32 %call15, 2
  %lnot17 = xor i1 %cmp, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %tobool21 = icmp ne i32 %lnot.ext20, 0
  %lnot22 = xor i1 %tobool21, true
  %lnot24 = xor i1 %lnot22, true
  %lnot.ext25 = zext i1 %lnot24 to i32
  %conv26 = sext i32 %lnot.ext25 to i64
  %expval27 = call i64 @llvm.expect.i64(i64 %conv26, i64 0)
  %tobool28 = icmp ne i64 %expval27, 0
  br i1 %tobool28, label %if.then29, label %if.end57

if.then29:                                        ; preds = %if.end8
  %7 = load i8, i8* @rpc_run_bc_task.__warned, align 1, !tbaa !29, !range !31
  %tobool30 = trunc i8 %7 to i1
  %lnot31 = xor i1 %tobool30, true
  %lnot33 = xor i1 %lnot31, true
  %lnot35 = xor i1 %lnot33, true
  %lnot.ext36 = zext i1 %lnot35 to i32
  %tobool37 = icmp ne i32 %lnot.ext36, 0
  %lnot38 = xor i1 %tobool37, true
  %lnot40 = xor i1 %lnot38, true
  %lnot.ext41 = zext i1 %lnot40 to i32
  %conv42 = sext i32 %lnot.ext41 to i64
  %expval43 = call i64 @llvm.expect.i64(i64 %conv42, i64 0)
  %tobool44 = icmp ne i64 %expval43, 0
  br i1 %tobool44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.then29
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 920)
  br label %if.end46

if.end46:                                         ; preds = %if.then45, %if.then29
  %tobool47 = icmp ne i32 %lnot.ext36, 0
  %lnot48 = xor i1 %tobool47, true
  %lnot50 = xor i1 %lnot48, true
  %lnot.ext51 = zext i1 %lnot50 to i32
  %conv52 = sext i32 %lnot.ext51 to i64
  %expval53 = call i64 @llvm.expect.i64(i64 %conv52, i64 0)
  %tobool54 = icmp ne i64 %expval53, 0
  br i1 %tobool54, label %if.then55, label %if.end57

if.then55:                                        ; preds = %if.end46
  store i8 1, i8* @rpc_run_bc_task.__warned, align 1, !tbaa !29
  br label %if.end57

if.end57:                                         ; preds = %if.then55, %if.end46, %if.end8
  call void @rpc_execute(%struct.rpc_task* %call4)
  br label %do.body66

do.body66:                                        ; preds = %if.end57, %if.then7
  %8 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and67 = and i32 %8, 2
  %tobool68 = icmp ne i32 %and67, 0
  %lnot69 = xor i1 %tobool68, true
  %lnot71 = xor i1 %lnot69, true
  %lnot.ext72 = zext i1 %lnot71 to i32
  %conv73 = sext i32 %lnot.ext72 to i64
  %expval74 = call i64 @llvm.expect.i64(i64 %conv73, i64 0)
  %tobool75 = icmp ne i64 %expval74, 0
  br i1 %tobool75, label %if.then76, label %do.end80

if.then76:                                        ; preds = %do.body66
  %9 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end80

do.end80:                                         ; preds = %if.then76, %do.body66
  ret %struct.rpc_task* %call4
}

; Function Attrs: nounwind uwtable
define internal void @call_bc_transmit(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %call = call i32 @xprt_prepare_transmit(%struct.rpc_task* %task)
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 %call, i32* %tk_status, align 4, !tbaa !59
  %tk_status1 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %1 = load i32, i32* %tk_status1, align 4, !tbaa !59
  %cmp = icmp eq i32 %1, -11
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %tk_status2 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status2, align 4, !tbaa !59
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @call_bc_transmit, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  br label %cleanup.cont

if.end:                                           ; preds = %entry
  %tk_action3 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @rpc_exit_task, void (%struct.rpc_task*)** %tk_action3, align 8, !tbaa !20
  %tk_status4 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %2 = load i32, i32* %tk_status4, align 4, !tbaa !59
  %cmp5 = icmp slt i32 %2, 0
  br i1 %cmp5, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.end
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup.cont

if.end9:                                          ; preds = %if.end
  call void @xprt_transmit(%struct.rpc_task* %task)
  call void @xprt_end_transmit(%struct.rpc_task* %task)
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %4, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %if.then12, label %do.end

if.then12:                                        ; preds = %if.end9
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then12, %if.end9
  %tk_status17 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %6 = load i32, i32* %tk_status17, align 4, !tbaa !59
  %Pivot10 = icmp slt i32 %6, -101
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %do.end
  %Pivot8 = icmp slt i32 %6, 0
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %6, 0
  br i1 %SwitchLeaf6, label %sw.epilog, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %6, -101
  br i1 %SwitchLeaf4, label %sw.bb, label %sw.default

NodeBlock:                                        ; preds = %do.end
  %Pivot = icmp slt i32 %6, -110
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %6, -110
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %.off = add i32 %6, 113
  %SwitchLeaf = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  %7 = call i32 (i8*, ...) @printk(i8* null)
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %8 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %rq_connect_cookie = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 22
  %9 = load i32, i32* %rq_connect_cookie, align 4, !tbaa !144
  call void @xprt_conditional_disconnect(%struct.rpc_xprt* %8, i32 %9)
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  %tk_status20 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %10 = load i32, i32* %tk_status20, align 4, !tbaa !59
  %cmp21 = icmp eq i32 %10, -11
  %lnot23 = xor i1 %cmp21, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %tobool27 = icmp ne i32 %lnot.ext26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %if.end63

if.then35:                                        ; preds = %sw.default
  %11 = load i8, i8* @call_bc_transmit.__warned, align 1, !tbaa !29, !range !31
  %tobool36 = trunc i8 %11 to i1
  %lnot37 = xor i1 %tobool36, true
  %lnot39 = xor i1 %lnot37, true
  %lnot41 = xor i1 %lnot39, true
  %lnot.ext42 = zext i1 %lnot41 to i32
  %tobool43 = icmp ne i32 %lnot.ext42, 0
  %lnot44 = xor i1 %tobool43, true
  %lnot46 = xor i1 %lnot44, true
  %lnot.ext47 = zext i1 %lnot46 to i32
  %conv48 = sext i32 %lnot.ext47 to i64
  %expval49 = call i64 @llvm.expect.i64(i64 %conv48, i64 0)
  %tobool50 = icmp ne i64 %expval49, 0
  br i1 %tobool50, label %if.then51, label %if.end52

if.then51:                                        ; preds = %if.then35
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4, i32 0, i32 0), i32 1830)
  br label %if.end52

if.end52:                                         ; preds = %if.then51, %if.then35
  %tobool53 = icmp ne i32 %lnot.ext42, 0
  %lnot54 = xor i1 %tobool53, true
  %lnot56 = xor i1 %lnot54, true
  %lnot.ext57 = zext i1 %lnot56 to i32
  %conv58 = sext i32 %lnot.ext57 to i64
  %expval59 = call i64 @llvm.expect.i64(i64 %conv58, i64 0)
  %tobool60 = icmp ne i64 %expval59, 0
  br i1 %tobool60, label %if.then61, label %if.end63

if.then61:                                        ; preds = %if.end52
  store i8 1, i8* @call_bc_transmit.__warned, align 1, !tbaa !29
  br label %if.end63

if.end63:                                         ; preds = %if.then61, %if.end52, %sw.default
  %12 = call i32 (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end63, %sw.bb, %LeafBlock5
  %rq_xprt74 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %13 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt74, align 8, !tbaa !71
  %pending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %13, i32 0, i32 12
  call void @rpc_wake_up_queued_task(%struct.rpc_wait_queue* %pending, %struct.rpc_task* %task)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %sw.epilog, %if.then6, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_show_tasks(%struct.net* %net) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %rpc_client_lock = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 8
  call void @spin_lock(%struct.spinlock* %rpc_client_lock)
  %all_clients = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 7
  br label %for.cond

for.cond:                                         ; preds = %for.end, %entry
  %cl_clients18.sink = phi %struct.list_head* [ %cl_clients18, %for.end ], [ %all_clients, %entry ]
  %header.0 = phi i32 [ 0, %entry ], [ %header.1, %for.end ]
  %next19 = getelementptr inbounds %struct.list_head, %struct.list_head* %cl_clients18.sink, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next19, align 8, !tbaa !28
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr21 = getelementptr inbounds i8, i8* %3, i64 -8
  %4 = bitcast i8* %add.ptr21 to %struct.rpc_clnt*
  %cl_clients = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %4, i32 0, i32 1
  %all_clients1 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 7
  %cmp = icmp ne %struct.list_head* %cl_clients, %all_clients1
  br i1 %cmp, label %for.body, label %for.end22

for.body:                                         ; preds = %for.cond
  %cl_lock = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %4, i32 0, i32 3
  call void @spin_lock(%struct.spinlock* %cl_lock)
  %cl_tasks = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %4, i32 0, i32 2
  br label %for.cond6

for.cond6:                                        ; preds = %if.end, %for.body
  %tk_task11.sink = phi %struct.list_head* [ %tk_task11, %if.end ], [ %cl_tasks, %for.body ]
  %header.1 = phi i32 [ %header.0, %for.body ], [ %header.2, %if.end ]
  %next12 = getelementptr inbounds %struct.list_head, %struct.list_head* %tk_task11.sink, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next12, align 8, !tbaa !28
  %6 = bitcast %struct.list_head* %5 to i8*
  %add.ptr14 = getelementptr inbounds i8, i8* %6, i64 -8
  %7 = bitcast i8* %add.ptr14 to %struct.rpc_task*
  %tk_task = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %7, i32 0, i32 1
  %cl_tasks7 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %4, i32 0, i32 2
  %cmp8 = icmp ne %struct.list_head* %tk_task, %cl_tasks7
  br i1 %cmp8, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %tobool = icmp ne i32 %header.1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body9
  call void @rpc_show_header()
  %inc = add nsw i32 %header.1, 1
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body9
  %header.2 = phi i32 [ %header.1, %for.body9 ], [ %inc, %if.then ]
  call void @rpc_show_task(%struct.rpc_task* %7)
  %tk_task11 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %7, i32 0, i32 1
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %cl_lock15 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %4, i32 0, i32 3
  call void @spin_unlock(%struct.spinlock* %cl_lock15)
  %cl_clients18 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %4, i32 0, i32 1
  br label %for.cond

for.end22:                                        ; preds = %for.cond
  %rpc_client_lock23 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 8
  call void @spin_unlock(%struct.spinlock* %rpc_client_lock23)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_show_header() #0 {
entry:
  %0 = call i32 (i8*, ...) @printk(i8* null)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_show_task(%struct.rpc_task* %task) #0 {
entry:
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %0 = load volatile i64, i64* %tk_runstate, align 8, !tbaa !88
  %and.i = and i64 2, %0
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %tk_waitqueue = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 12
  %1 = load %struct.rpc_wait_queue*, %struct.rpc_wait_queue** %tk_waitqueue, align 8, !tbaa !222
  call void @rpc_qname(%struct.rpc_wait_queue* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @rpc_proc_name(%struct.rpc_task* %task)
  %2 = call i32 (i8*, ...) @printk(i8* null)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rpc_qname(%struct.rpc_wait_queue* %q) #2 {
entry:
  %tobool = icmp ne %struct.rpc_wait_queue* %q, null
  br i1 %tobool, label %land.lhs.true, label %cond.end

land.lhs.true:                                    ; preds = %entry
  %name = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %q, i32 0, i32 8
  %0 = load i8*, i8** %name, align 8, !tbaa !266
  %tobool1 = icmp ne i8* %0, null
  br i1 %tobool1, label %cond.true, label %cond.end

cond.true:                                        ; preds = %land.lhs.true
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @xprt_free(%struct.rpc_xprt* %xprt) #0 {
entry:
  %xprt_net = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 40
  %0 = load %struct.net*, %struct.net** %xprt_net, align 8, !tbaa !171
  call void @put_net.2(%struct.net* %0)
  call void @xprt_free_all_slots(%struct.rpc_xprt* %xprt)
  %1 = bitcast %struct.rpc_xprt* %xprt to i8*
  call void @kfree(i8* %1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @put_net.2(%struct.net* %net) #2 {
entry:
  %count = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 1
  %call = call i32 @atomic_dec_and_test.4(%struct.atomic_t* %count)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__put_net(%struct.net* %net)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xprt_free_all_slots(%struct.rpc_xprt* %xprt) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %free = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 14
  %call = call i32 @list_empty.3(%struct.list_head* %free)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %free1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 14
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %free1, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -184
  %2 = bitcast i8* %add.ptr to %struct.rpc_rqst*
  %rq_list = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %2, i32 0, i32 11
  call void @list_del(%struct.list_head* %rq_list)
  %3 = bitcast %struct.rpc_rqst* %2 to i8*
  call void @kfree(i8* %3)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty.3(%struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_dec_and_test.4(%struct.atomic_t* %v) #2 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0; sete $1", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32* %counter) #7, !srcloc !267
  %0 = load i8, i8* %c, align 1, !tbaa !166
  %conv = zext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define %struct.rpc_xprt* @xprt_alloc(%struct.net* %net, i64 %size, i32 %num_prealloc, i32 %max_alloc) #0 {
entry:
  %call = call i8* @kzalloc.5(i64 %size, i32 208)
  %0 = bitcast i8* %call to %struct.rpc_xprt*
  %cmp = icmp eq %struct.rpc_xprt* %0, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @xprt_init(%struct.rpc_xprt* %0, %struct.net* %net)
  br label %for.cond

for.cond:                                         ; preds = %if.end4, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %if.end4 ]
  %cmp1 = icmp ult i32 %i.0, %num_prealloc
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call2 = call i8* @kzalloc.5(i64 400, i32 208)
  %1 = bitcast i8* %call2 to %struct.rpc_rqst*
  %tobool = icmp ne %struct.rpc_rqst* %1, null
  br i1 %tobool, label %if.end4, label %for.end

if.end4:                                          ; preds = %for.body
  %rq_list = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 11
  %free = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 14
  call void @list_add.6(%struct.list_head* %rq_list, %struct.list_head* %free)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %cmp5 = icmp ult i32 %i.0, %num_prealloc
  br i1 %cmp5, label %out_free, label %if.end7

if.end7:                                          ; preds = %for.end
  %cmp8 = icmp ugt i32 %max_alloc, %num_prealloc
  %max_reqs = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 15
  %num_prealloc.sink = select i1 %cmp8, i32 %max_alloc, i32 %num_prealloc
  store i32 %num_prealloc.sink, i32* %max_reqs, align 8, !tbaa !268
  %min_reqs = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 16
  store i32 %num_prealloc, i32* %min_reqs, align 4, !tbaa !269
  %num_reqs = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 17
  call void @atomic_set.7(%struct.atomic_t* %num_reqs, i32 %num_prealloc)
  br label %cleanup

out_free:                                         ; preds = %for.end
  call void @xprt_free(%struct.rpc_xprt* %0)
  br label %cleanup

cleanup:                                          ; preds = %out_free, %if.end7, %entry
  %retval.0 = phi %struct.rpc_xprt* [ %0, %if.end7 ], [ null, %entry ], [ null, %out_free ]
  ret %struct.rpc_xprt* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.5(i64 %size, i32 %flags) #2 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #7
  ret i8* %call.i
}

; Function Attrs: nounwind uwtable
define internal void @xprt_init(%struct.rpc_xprt* %xprt, %struct.net* %net) #0 {
entry:
  %count = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 0
  call void @atomic_set.7(%struct.atomic_t* %count, i32 1)
  call void @spinlock_check.8()
  %transport_lock2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %transport_lock2, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.40.9, i32 0, i32 0), %struct.lock_class_key* @xprt_init.__key)
  call void @spinlock_check.8()
  %reserve_lock7 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 30
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reserve_lock7, i32 0, i32 0
  %rlock8 = bitcast %union.anon.11* %1 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock8, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.42.10, i32 0, i32 0), %struct.lock_class_key* @xprt_init.__key.41)
  %free = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 14
  call void @INIT_LIST_HEAD.11(%struct.list_head* %free)
  %recv = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  call void @INIT_LIST_HEAD.11(%struct.list_head* %recv)
  call void @spinlock_check.8()
  %bc_pa_lock14 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 36
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %bc_pa_lock14, i32 0, i32 0
  %rlock15 = bitcast %union.anon.11* %2 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock15, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.44.12, i32 0, i32 0), %struct.lock_class_key* @xprt_init.__key.43)
  %bc_pa_list = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 37
  call void @INIT_LIST_HEAD.11(%struct.list_head* %bc_pa_list)
  %3 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %last_used = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 27
  store i64 %3, i64* %last_used, align 8, !tbaa !270
  %cwnd = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 7
  store i64 256, i64* %cwnd, align 8, !tbaa !271
  %bind_index = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 21
  store i32 0, i32* %bind_index, align 8, !tbaa !272
  %binding = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 10
  call void @rpc_init_wait_queue(%struct.rpc_wait_queue* %binding, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.45.13, i32 0, i32 0))
  %pending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 12
  call void @rpc_init_wait_queue(%struct.rpc_wait_queue* %pending, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.46.14, i32 0, i32 0))
  %sending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 11
  call void @rpc_init_priority_wait_queue(%struct.rpc_wait_queue* %sending, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.47.15, i32 0, i32 0))
  %backlog = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 13
  call void @rpc_init_priority_wait_queue(%struct.rpc_wait_queue* %backlog, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.48.16, i32 0, i32 0))
  call void @xprt_init_xid(%struct.rpc_xprt* %xprt)
  %call18 = call %struct.net* @get_net.17(%struct.net* %net)
  %xprt_net = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 40
  store %struct.net* %call18, %struct.net** %xprt_net, align 8, !tbaa !171
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add.6(%struct.list_head* %new, %struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set.7(%struct.atomic_t* %v, i32 %i) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !240
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spinlock_check.8() #2 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.11(%struct.list_head* %list) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !163
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_init_xid(%struct.rpc_xprt* %xprt) #2 {
entry:
  %call = call i32 @prandom_u32()
  %xid = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 31
  store i32 %call, i32* %xid, align 8, !tbaa !273
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.net* @get_net.17(%struct.net* %net) #2 {
entry:
  %count = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 1
  call void @atomic_inc.18(%struct.atomic_t* %count)
  ret %struct.net* %net
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.18(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !274
  ret void
}

declare i32 @prandom_u32() #4

; Function Attrs: nounwind uwtable
define void @xprt_lock_and_alloc_slot(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  %call = call i32 @xprt_lock_write(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @xprt_alloc_slot(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task)
  call void @xprt_release_write(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_lock_write(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #2 {
entry:
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 1
  %0 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %reserve_xprt = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %0, i32 0, i32 1
  %1 = load i32 (%struct.rpc_xprt*, %struct.rpc_task*)*, i32 (%struct.rpc_xprt*, %struct.rpc_task*)** %reserve_xprt, align 8, !tbaa !275
  %call = call i32 %1(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task)
  %transport_lock2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock2)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define void @xprt_alloc_slot(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  %reserve_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 30
  call void @spin_lock.20(%struct.spinlock* %reserve_lock)
  %free = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 14
  %call = call i32 @list_empty.3(%struct.list_head* %free)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %free1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 14
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %free1, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !276
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -184
  %2 = bitcast i8* %add.ptr to %struct.rpc_rqst*
  %rq_list = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %2, i32 0, i32 11
  call void @list_del(%struct.list_head* %rq_list)
  br label %out_init_req

if.end:                                           ; preds = %entry
  %call2 = call %struct.rpc_rqst* @xprt_dynamic_alloc_slot(%struct.rpc_xprt* %xprt, i32 512)
  %3 = bitcast %struct.rpc_rqst* %call2 to i8*
  %call3 = call i64 @IS_ERR.21(i8* %3)
  %tobool4 = icmp ne i64 %call3, 0
  br i1 %tobool4, label %if.end6, label %out_init_req

if.end6:                                          ; preds = %if.end
  %4 = bitcast %struct.rpc_rqst* %call2 to i8*
  %call7 = call i64 @PTR_ERR.22(i8* %4)
  %Pivot = icmp slt i64 %call7, -11
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end6
  %SwitchLeaf2 = icmp eq i64 %call7, -11
  br i1 %SwitchLeaf2, label %sw.bb14, label %sw.epilog

LeafBlock:                                        ; preds = %if.end6
  %SwitchLeaf = icmp eq i64 %call7, -12
  br i1 %SwitchLeaf, label %do.body, label %sw.epilog

do.body:                                          ; preds = %LeafBlock
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %5, 1
  %tobool8 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool8, true
  %lnot9 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then11, label %sw.epilog

if.then11:                                        ; preds = %do.body
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.bb14:                                          ; preds = %LeafBlock1
  call void @xprt_add_backlog(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task)
  %7 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and16 = and i32 %7, 1
  %tobool17 = icmp ne i32 %and16, 0
  %lnot18 = xor i1 %tobool17, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  %expval23 = call i64 @llvm.expect.i64(i64 %conv22, i64 0)
  %tobool24 = icmp ne i64 %expval23, 0
  br i1 %tobool24, label %if.then25, label %sw.epilog

if.then25:                                        ; preds = %sw.bb14
  %8 = call i32 (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then25, %sw.bb14, %if.then11, %do.body, %LeafBlock, %LeafBlock1
  %.sink = phi i32 [ -11, %LeafBlock ], [ -11, %LeafBlock1 ], [ -11, %sw.bb14 ], [ -11, %if.then25 ], [ -12, %if.then11 ], [ -12, %do.body ]
  %tk_status30 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 %.sink, i32* %tk_status30, align 4, !tbaa !59
  %reserve_lock31 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 30
  call void @spin_unlock.25(%struct.spinlock* %reserve_lock31)
  br label %cleanup.cont

out_init_req:                                     ; preds = %if.end, %if.then
  %req.0 = phi %struct.rpc_rqst* [ %2, %if.then ], [ %call2, %if.end ]
  %tk_status32 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status32, align 4, !tbaa !59
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  store %struct.rpc_rqst* %req.0, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  call void @xprt_request_init(%struct.rpc_task* %task, %struct.rpc_xprt* %xprt)
  %reserve_lock33 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 30
  call void @spin_unlock.25(%struct.spinlock* %reserve_lock33)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %out_init_req, %sw.epilog
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_release_write(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #2 {
entry:
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 1
  %0 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %release_xprt = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %0, i32 0, i32 2
  %1 = load void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)** %release_xprt, align 8, !tbaa !277
  call void %1(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task)
  %transport_lock1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_bh(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_bh(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

declare void @_raw_spin_unlock_bh(%struct.raw_spinlock*) #4 section ".spinlock.text"

declare void @_raw_spin_lock_bh(%struct.raw_spinlock*) #4 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock.20(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_rqst* @xprt_dynamic_alloc_slot(%struct.rpc_xprt* %xprt, i32 %gfp_flags) #0 {
entry:
  %call = call i8* @ERR_PTR.29(i64 -11)
  %0 = bitcast i8* %call to %struct.rpc_rqst*
  %num_reqs = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 17
  %max_reqs = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 15
  %1 = load i32, i32* %max_reqs, align 8, !tbaa !268
  %call1 = call i32 @atomic_add_unless.30(%struct.atomic_t* %num_reqs, i32 1, i32 %1)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %out

if.end:                                           ; preds = %entry
  %call2 = call i8* @kzalloc.5(i64 400, i32 %gfp_flags)
  %2 = bitcast i8* %call2 to %struct.rpc_rqst*
  %cmp = icmp ne %struct.rpc_rqst* %2, null
  br i1 %cmp, label %out, label %if.end4

if.end4:                                          ; preds = %if.end
  %num_reqs5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 17
  call void @atomic_dec(%struct.atomic_t* %num_reqs5)
  %call6 = call i8* @ERR_PTR.29(i64 -12)
  %3 = bitcast i8* %call6 to %struct.rpc_rqst*
  br label %out

out:                                              ; preds = %if.end4, %if.end, %entry
  %req.0 = phi %struct.rpc_rqst* [ %3, %if.end4 ], [ %0, %entry ], [ %2, %if.end ]
  ret %struct.rpc_rqst* %req.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR.21(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR.22(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define internal void @xprt_add_backlog(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 9, i64* %state) #7, !srcloc !278
  %backlog = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 13
  call void @rpc_sleep_on(%struct.rpc_wait_queue* %backlog, %struct.rpc_task* %task, void (%struct.rpc_task*)* null)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock.25(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xprt_request_init(%struct.rpc_task* %task, %struct.rpc_xprt* %xprt) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_list = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 11
  call void @INIT_LIST_HEAD.11(%struct.list_head* %rq_list)
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %1 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %cl_timeout = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %1, i32 0, i32 15
  %2 = load %struct.rpc_timeout*, %struct.rpc_timeout** %cl_timeout, align 8, !tbaa !237
  %to_initval = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %2, i32 0, i32 0
  %3 = load i64, i64* %to_initval, align 8, !tbaa !184
  %rq_timeout = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 19
  store i64 %3, i64* %rq_timeout, align 8, !tbaa !279
  %rq_task = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 3
  store %struct.rpc_task* %task, %struct.rpc_task** %rq_task, align 8, !tbaa !280
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  store %struct.rpc_xprt* %xprt, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %rq_buffer = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 12
  store i32* null, i32** %rq_buffer, align 8, !tbaa !72
  %call = call i32 @xprt_alloc_xid(%struct.rpc_xprt* %xprt)
  %rq_xid = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 5
  store i32 %call, i32* %rq_xid, align 8, !tbaa !154
  %rq_release_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 10
  store void (%struct.rpc_rqst*)* null, void (%struct.rpc_rqst*)** %rq_release_snd_buf, align 8, !tbaa !281
  call void @xprt_reset_majortimeo(%struct.rpc_rqst* %0)
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %4, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_alloc_xid(%struct.rpc_xprt* %xprt) #2 {
entry:
  %xid = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 31
  %0 = load i32, i32* %xid, align 8, !tbaa !273
  %inc = add i32 %0, 1
  store i32 %inc, i32* %xid, align 8, !tbaa !273
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal void @xprt_reset_majortimeo(%struct.rpc_rqst* %req) #0 {
entry:
  %rq_task = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 3
  %0 = load %struct.rpc_task*, %struct.rpc_task** %rq_task, align 8, !tbaa !280
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %0, i32 0, i32 2
  %1 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %cl_timeout = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %1, i32 0, i32 15
  %2 = load %struct.rpc_timeout*, %struct.rpc_timeout** %cl_timeout, align 8, !tbaa !237
  %rq_timeout = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 19
  %3 = load i64, i64* %rq_timeout, align 8, !tbaa !279
  %rq_majortimeo = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 18
  store i64 %3, i64* %rq_majortimeo, align 8, !tbaa !282
  %to_exponential = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %2, i32 0, i32 4
  %4 = load i8, i8* %to_exponential, align 4, !tbaa !283
  %tobool = icmp ne i8 %4, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %to_retries = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %2, i32 0, i32 3
  %5 = load i32, i32* %to_retries, align 8, !tbaa !284
  %rq_majortimeo1 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 18
  %6 = load i64, i64* %rq_majortimeo1, align 8, !tbaa !282
  %sh_prom = zext i32 %5 to i64
  %shl = shl i64 %6, %sh_prom
  store i64 %shl, i64* %rq_majortimeo1, align 8, !tbaa !282
  br label %if.end

if.else:                                          ; preds = %entry
  %to_increment = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %2, i32 0, i32 2
  %7 = load i64, i64* %to_increment, align 8, !tbaa !285
  %to_retries2 = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %2, i32 0, i32 3
  %8 = load i32, i32* %to_retries2, align 8, !tbaa !284
  %conv = zext i32 %8 to i64
  %mul = mul i64 %7, %conv
  %rq_majortimeo3 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 18
  %9 = load i64, i64* %rq_majortimeo3, align 8, !tbaa !282
  %add = add i64 %9, %mul
  store i64 %add, i64* %rq_majortimeo3, align 8, !tbaa !282
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %rq_majortimeo4 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 18
  %10 = load i64, i64* %rq_majortimeo4, align 8, !tbaa !282
  %to_maxval = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %2, i32 0, i32 1
  %11 = load i64, i64* %to_maxval, align 8, !tbaa !286
  %cmp = icmp ugt i64 %10, %11
  br i1 %cmp, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %rq_majortimeo6 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 18
  %12 = load i64, i64* %rq_majortimeo6, align 8, !tbaa !282
  %cmp7 = icmp eq i64 %12, 0
  br i1 %cmp7, label %if.then9, label %if.end12

if.then9:                                         ; preds = %lor.lhs.false, %if.end
  %to_maxval10 = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %2, i32 0, i32 1
  %13 = load i64, i64* %to_maxval10, align 8, !tbaa !286
  %rq_majortimeo11 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 18
  store i64 %13, i64* %rq_majortimeo11, align 8, !tbaa !282
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %lor.lhs.false
  %14 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %rq_majortimeo13 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 18
  %15 = load i64, i64* %rq_majortimeo13, align 8, !tbaa !282
  %add14 = add i64 %15, %14
  store i64 %add14, i64* %rq_majortimeo13, align 8, !tbaa !282
  ret void
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal void @__fswab32.26() #5 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal void @__arch_swab32.28() #5 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR.29(i64 %error) #2 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_unless.30(%struct.atomic_t* %v, i32 %a, i32 %u) #2 {
entry:
  %call = call i32 @__atomic_add_unless.31(%struct.atomic_t* %v, i32 %a, i32 %u)
  %cmp = icmp ne i32 %call, %u
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_dec(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !287
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__atomic_add_unless.31(%struct.atomic_t* %v, i32 %a, i32 %u) #2 {
entry:
  %call = call i32 @atomic_read.32(%struct.atomic_t* %v)
  br label %for.cond

for.cond:                                         ; preds = %if.end13, %entry
  %c.0 = phi i32 [ %call, %entry ], [ %call2, %if.end13 ]
  %cmp = icmp eq i32 %c.0, %u
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %for.end, label %if.end

if.end:                                           ; preds = %for.cond
  %add = add nsw i32 %c.0, %a
  %call2 = call i32 @atomic_cmpxchg.33(%struct.atomic_t* %v, i32 %c.0, i32 %add)
  %cmp3 = icmp eq i32 %call2, %c.0
  %lnot5 = xor i1 %cmp3, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %expval10 = call i64 @llvm.expect.i64(i64 %conv9, i64 1)
  %tobool11 = icmp ne i64 %expval10, 0
  br i1 %tobool11, label %for.end, label %if.end13

if.end13:                                         ; preds = %if.end
  br label %for.cond

for.end:                                          ; preds = %if.end, %for.cond
  ret i32 %c.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read.32(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !49
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_cmpxchg.33(%struct.atomic_t* %v, i32 %old, i32 %new) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; cmpxchgl $2,$1", "={ax},=*m,r,0,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %new, i32 %old, i32* %counter) #7, !srcloc !288
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define void @xprt_complete_rqst(%struct.rpc_task* %task, i32 %copied) #0 {
entry:
  %.compoundliteral = alloca %struct.pgprot, align 8
  %coerce = alloca %struct.pgprot, align 8
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 39
  %recvs = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat, i32 0, i32 5
  %4 = load i64, i64* %recvs, align 8, !tbaa !289
  %inc = add i64 %4, 1
  store i64 %inc, i64* %recvs, align 8, !tbaa !289
  %rq_rtt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 20
  %tv64 = bitcast %struct.pgprot* %.compoundliteral to i64*
  %call5 = call i64 @ktime_get()
  %coerce.dive = getelementptr inbounds %struct.pgprot, %struct.pgprot* %coerce, i32 0, i32 0
  store i64 %call5, i64* %coerce.dive, align 8
  %tv646 = bitcast %struct.pgprot* %coerce to i64*
  %5 = load i64, i64* %tv646, align 8, !tbaa !166
  %rq_xtime = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 24
  %tv647 = bitcast %struct.pgprot* %rq_xtime to i64*
  %6 = load i64, i64* %tv647, align 8, !tbaa !166
  %sub = sub nsw i64 %5, %6
  store i64 %sub, i64* %tv64, align 8, !tbaa !166
  %7 = bitcast %struct.pgprot* %rq_rtt to i8*
  %8 = bitcast %struct.pgprot* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false), !tbaa.struct !290
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 1
  %9 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %timer = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %9, i32 0, i32 11
  %10 = load void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)** %timer, align 8, !tbaa !292
  %cmp = icmp ne void (%struct.rpc_xprt*, %struct.rpc_task*)* %10, null
  br i1 %cmp, label %if.then9, label %if.end10

if.then9:                                         ; preds = %do.end
  call void @xprt_update_rtt(%struct.rpc_task* %task)
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %do.end
  %rq_list = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 11
  call void @list_del_init(%struct.list_head* %rq_list)
  %rq_private_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 17
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf, i32 0, i32 7
  store i32 %copied, i32* %len, align 8, !tbaa !160
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !293
  %conv11 = sext i32 %copied to i64
  %rq_reply_bytes_recvd = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 16
  store i64 %conv11, i64* %rq_reply_bytes_recvd, align 8, !tbaa !142
  %pending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 12
  call void @rpc_wake_up_queued_task(%struct.rpc_wait_queue* %pending, %struct.rpc_task* %task)
  ret void
}

declare i64 @ktime_get() #4

; Function Attrs: nounwind uwtable
define internal void @xprt_update_rtt(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %1 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %cl_rtt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %1, i32 0, i32 14
  %2 = load %struct.rpc_rtt*, %struct.rpc_rtt** %cl_rtt, align 8, !tbaa !238
  %tk_msg = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg, i32 0, i32 0
  %3 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !44
  %p_timer = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %3, i32 0, i32 6
  %4 = load i32, i32* %p_timer, align 4, !tbaa !294
  %rq_rtt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 20
  %coerce.dive = getelementptr inbounds %struct.pgprot, %struct.pgprot* %rq_rtt, i32 0, i32 0
  %5 = load i64, i64* %coerce.dive, align 8
  %call = call i64 @ktime_to_us(i64 %5)
  %conv = trunc i64 %call to i32
  %call1 = call i64 @usecs_to_jiffies(i32 %conv)
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %rq_ntrans = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 25
  %6 = load i32, i32* %rq_ntrans, align 8, !tbaa !295
  %cmp = icmp eq i32 %6, 1
  br i1 %cmp, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  call void @rpc_update_rtt(%struct.rpc_rtt* %2, i32 %4, i64 %call1)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %rq_ntrans4 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 25
  %7 = load i32, i32* %rq_ntrans4, align 8, !tbaa !295
  %sub = sub nsw i32 %7, 1
  call void @rpc_set_timeo(%struct.rpc_rtt* %2, i32 %4, i32 %sub)
  br label %if.end5

if.end5:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init(%struct.list_head* %entry1) #2 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD.11(%struct.list_head* %entry1)
  ret void
}

declare void @__list_del_entry(%struct.list_head*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @ktime_to_us(i64 %kt.coerce) #2 {
entry:
  %kt = alloca %struct.pgprot, align 8
  %tv = alloca %struct.load_weight, align 8
  %coerce.dive = getelementptr inbounds %struct.pgprot, %struct.pgprot* %kt, i32 0, i32 0
  store i64 %kt.coerce, i64* %coerce.dive, align 8
  %tv64 = bitcast %struct.pgprot* %kt to i64*
  %0 = load i64, i64* %tv64, align 8, !tbaa !166
  %call = call { i64, i64 } @ns_to_timeval(i64 %0)
  %1 = bitcast %struct.load_weight* %tv to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = extractvalue { i64, i64 } %call, 0
  store i64 %3, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = extractvalue { i64, i64 } %call, 1
  store i64 %5, i64* %4, align 8
  %tv_sec = getelementptr inbounds %struct.load_weight, %struct.load_weight* %tv, i32 0, i32 0
  %6 = load i64, i64* %tv_sec, align 8, !tbaa !296
  %mul = mul nsw i64 %6, 1000000
  %tv_usec = getelementptr inbounds %struct.load_weight, %struct.load_weight* %tv, i32 0, i32 1
  %7 = load i64, i64* %tv_usec, align 8, !tbaa !298
  %add = add nsw i64 %mul, %7
  ret i64 %add
}

declare i64 @usecs_to_jiffies(i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @rpc_set_timeo(%struct.rpc_rtt* %rt, i32 %timer, i32 %ntimeo) #2 {
entry:
  %tobool = icmp ne i32 %timer, 0
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %ntimeouts = getelementptr inbounds %struct.rpc_rtt, %struct.rpc_rtt* %rt, i32 0, i32 3
  %sub = sub nsw i32 %timer, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [5 x i32], [5 x i32]* %ntimeouts, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !49
  %cmp = icmp slt i32 %ntimeo, %0
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %1 = load i32, i32* %arrayidx, align 4, !tbaa !49
  %cmp2 = icmp sgt i32 %1, 0
  br i1 %cmp2, label %if.then3, label %cleanup.cont

if.then3:                                         ; preds = %if.then1
  %2 = load i32, i32* %arrayidx, align 4, !tbaa !49
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* %arrayidx, align 4, !tbaa !49
  br label %cleanup.cont

if.else:                                          ; preds = %if.end
  %cmp5 = icmp sgt i32 %ntimeo, 8
  %.ntimeo = select i1 %cmp5, i32 8, i32 %ntimeo
  store i32 %.ntimeo, i32* %arrayidx, align 4, !tbaa !49
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.else, %if.then3, %if.then1, %entry
  ret void
}

declare { i64, i64 } @ns_to_timeval(i64) #4

; Function Attrs: nounwind uwtable
define %struct.rpc_rqst* @xprt_lookup_rqst(%struct.rpc_xprt* %xprt, i32 %xid) #0 {
entry:
  %recv = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %rq_list5.sink = phi %struct.list_head* [ %rq_list5, %for.inc ], [ %recv, %entry ]
  %next6 = getelementptr inbounds %struct.list_head, %struct.list_head* %rq_list5.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next6, align 8, !tbaa !28
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr8 = getelementptr inbounds i8, i8* %1, i64 -184
  %2 = bitcast i8* %add.ptr8 to %struct.rpc_rqst*
  %rq_list = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %2, i32 0, i32 11
  %recv2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %cmp = icmp ne %struct.list_head* %rq_list, %recv2
  br i1 %cmp, label %for.body, label %do.body

for.body:                                         ; preds = %for.cond
  %rq_xid = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %2, i32 0, i32 5
  %3 = load i32, i32* %rq_xid, align 8, !tbaa !154
  %cmp3 = icmp eq i32 %3, %xid
  br i1 %cmp3, label %cleanup, label %for.inc

for.inc:                                          ; preds = %for.body
  %rq_list5 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %2, i32 0, i32 11
  br label %for.cond

do.body:                                          ; preds = %for.cond
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %4, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot9 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then11, label %do.end

if.then11:                                        ; preds = %do.body
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then11, %do.body
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %bad_xids = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat, i32 0, i32 6
  %6 = load i64, i64* %bad_xids, align 8, !tbaa !299
  %inc = add i64 %6, 1
  store i64 %inc, i64* %bad_xids, align 8, !tbaa !299
  br label %cleanup

cleanup:                                          ; preds = %do.end, %for.body
  %retval.0 = phi %struct.rpc_rqst* [ null, %do.end ], [ %2, %for.body ]
  ret %struct.rpc_rqst* %retval.0
}

; Function Attrs: nounwind uwtable
define void @xprt_disconnect_done(%struct.rpc_xprt* %xprt) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  call void @xprt_clear_connected(%struct.rpc_xprt* %xprt)
  call void @xprt_wake_pending_tasks(%struct.rpc_xprt* %xprt, i32 -11)
  %transport_lock3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock3)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_clear_connected(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 1, i64* %state) #7, !srcloc !300
  ret void
}

; Function Attrs: nounwind uwtable
define void @xprt_wake_pending_tasks(%struct.rpc_xprt* %xprt, i32 %status) #0 {
entry:
  %cmp = icmp slt i32 %status, 0
  %pending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 12
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @rpc_wake_up_status(%struct.rpc_wait_queue* %pending, i32 %status)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @rpc_wake_up(%struct.rpc_wait_queue* %pending)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @xprt_set_retrans_timeout_rtt(%struct.rpc_task* %task) #0 {
entry:
  %tk_msg = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg, i32 0, i32 0
  %0 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !44
  %p_timer = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %0, i32 0, i32 6
  %1 = load i32, i32* %p_timer, align 4, !tbaa !294
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %2 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %cl_rtt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %2, i32 0, i32 14
  %3 = load %struct.rpc_rtt*, %struct.rpc_rtt** %cl_rtt, align 8, !tbaa !238
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %4 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %cl_timeout = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %2, i32 0, i32 15
  %5 = load %struct.rpc_timeout*, %struct.rpc_timeout** %cl_timeout, align 8, !tbaa !237
  %to_maxval = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %5, i32 0, i32 1
  %6 = load i64, i64* %to_maxval, align 8, !tbaa !286
  %call = call i64 @rpc_calc_rto(%struct.rpc_rtt* %3, i32 %1)
  %tk_timeout = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  store i64 %call, i64* %tk_timeout, align 8, !tbaa !86
  %call1 = call i32 @rpc_ntimeo(%struct.rpc_rtt* %3, i32 %1)
  %rq_retries = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %4, i32 0, i32 21
  %7 = load i32, i32* %rq_retries, align 8, !tbaa !301
  %add = add i32 %call1, %7
  %tk_timeout2 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  %8 = load i64, i64* %tk_timeout2, align 8, !tbaa !86
  %sh_prom = zext i32 %add to i64
  %shl = shl i64 %8, %sh_prom
  store i64 %shl, i64* %tk_timeout2, align 8, !tbaa !86
  %tk_timeout3 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  %9 = load i64, i64* %tk_timeout3, align 8, !tbaa !86
  %cmp = icmp ugt i64 %9, %6
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %tk_timeout4 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  %10 = load i64, i64* %tk_timeout4, align 8, !tbaa !86
  %cmp5 = icmp eq i64 %10, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %tk_timeout6 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  store i64 %6, i64* %tk_timeout6, align 8, !tbaa !86
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rpc_ntimeo(%struct.rpc_rtt* %rt, i32 %timer) #2 {
entry:
  %tobool = icmp ne i32 %timer, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %ntimeouts = getelementptr inbounds %struct.rpc_rtt, %struct.rpc_rtt* %rt, i32 0, i32 3
  %sub = sub nsw i32 %timer, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [5 x i32], [5 x i32]* %ntimeouts, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !49
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %0, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @xprt_set_retrans_timeout_def(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_timeout = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 19
  %1 = load i64, i64* %rq_timeout, align 8, !tbaa !279
  %tk_timeout = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  store i64 %1, i64* %tk_timeout, align 8, !tbaa !86
  ret void
}

; Function Attrs: nounwind uwtable
define void @xprt_write_space(%struct.rpc_xprt* %xprt) #0 {
entry:
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %snd_task = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  %0 = load %struct.rpc_task*, %struct.rpc_task** %snd_task, align 8, !tbaa !302
  %tobool = icmp ne %struct.rpc_task* %0, null
  br i1 %tobool, label %do.body, label %if.end6

do.body:                                          ; preds = %entry
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 1
  %tobool1 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.end

if.then4:                                         ; preds = %do.body
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then4, %do.body
  %pending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 12
  %snd_task5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  %3 = load %struct.rpc_task*, %struct.rpc_task** %snd_task5, align 8, !tbaa !302
  call void @rpc_wake_up_queued_task(%struct.rpc_wait_queue* %pending, %struct.rpc_task* %3)
  br label %if.end6

if.end6:                                          ; preds = %do.end, %entry
  %transport_lock7 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock7)
  ret void
}

; Function Attrs: nounwind uwtable
define void @xprt_wait_for_buffer_space(%struct.rpc_task* %task, void (%struct.rpc_task*)* %action) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %2 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv = zext i16 %2 to i32
  %and = and i32 %conv, 4608
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %rq_timeout = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 19
  %3 = load i64, i64* %rq_timeout, align 8, !tbaa !279
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi i64 [ %3, %cond.true ], [ 0, %entry ]
  %tk_timeout = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  store i64 %cond, i64* %tk_timeout, align 8, !tbaa !86
  %pending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 12
  call void @rpc_sleep_on(%struct.rpc_wait_queue* %pending, %struct.rpc_task* %task, void (%struct.rpc_task*)* %action)
  ret void
}

; Function Attrs: nounwind uwtable
define void @xprt_adjust_cwnd(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task, i32 %result) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %cwnd1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 7
  %1 = load i64, i64* %cwnd1, align 8, !tbaa !271
  %cmp = icmp sge i32 %result, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %cong = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 6
  %2 = load i64, i64* %cong, align 8, !tbaa !303
  %cmp2 = icmp ule i64 %1, %2
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %shr = lshr i64 %1, 1
  %add = add i64 65536, %shr
  %div = udiv i64 %add, %1
  %add3 = add i64 %1, %div
  %max_reqs = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 15
  %3 = load i32, i32* %max_reqs, align 8, !tbaa !268
  %shl = shl i32 %3, 8
  %conv = zext i32 %shl to i64
  %cmp4 = icmp ugt i64 %add3, %conv
  br i1 %cmp4, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %max_reqs7 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 15
  %4 = load i32, i32* %max_reqs7, align 8, !tbaa !268
  %shl8 = shl i32 %4, 8
  %conv9 = zext i32 %shl8 to i64
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then
  %cwnd.0 = phi i64 [ %conv9, %if.then6 ], [ %add3, %if.then ]
  call void @__xprt_lock_write_next_cong(%struct.rpc_xprt* %xprt)
  br label %do.body

if.else:                                          ; preds = %land.lhs.true, %entry
  %cmp10 = icmp eq i32 %result, -110
  br i1 %cmp10, label %if.then12, label %do.body

if.then12:                                        ; preds = %if.else
  %shr13 = lshr i64 %1, 1
  %cmp14 = icmp ult i64 %shr13, 256
  %.shr13 = select i1 %cmp14, i64 256, i64 %shr13
  br label %do.body

do.body:                                          ; preds = %if.then12, %if.else, %if.end
  %cwnd.3 = phi i64 [ %cwnd.0, %if.end ], [ %.shr13, %if.then12 ], [ %1, %if.else ]
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %5, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot20 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot20 to i32
  %conv21 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool22 = icmp ne i64 %expval, 0
  br i1 %tobool22, label %if.then23, label %do.end

if.then23:                                        ; preds = %do.body
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then23, %do.body
  %cwnd27 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 7
  store i64 %cwnd.3, i64* %cwnd27, align 8, !tbaa !271
  call void @__xprt_put_cong(%struct.rpc_xprt* %xprt, %struct.rpc_rqst* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__xprt_lock_write_next_cong(%struct.rpc_xprt* %xprt) #0 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @test_and_set_bit(i32 0, i64* %state)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cong = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 6
  %0 = load i64, i64* %cong, align 8, !tbaa !303
  %cwnd = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 7
  %1 = load i64, i64* %cwnd, align 8, !tbaa !271
  %cmp = icmp uge i64 %0, %1
  br i1 %cmp, label %out_unlock, label %if.end2

if.end2:                                          ; preds = %if.end
  %sending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 11
  %2 = bitcast %struct.rpc_xprt* %xprt to i8*
  %call3 = call %struct.rpc_task* @rpc_wake_up_first(%struct.rpc_wait_queue* %sending, i1 (%struct.rpc_task*, i8*)* @__xprt_lock_write_cong_func, i8* %2)
  %tobool4 = icmp ne %struct.rpc_task* %call3, null
  br i1 %tobool4, label %return, label %out_unlock

out_unlock:                                       ; preds = %if.end2, %if.end
  call void @xprt_clear_locked(%struct.rpc_xprt* %xprt)
  br label %return

return:                                           ; preds = %out_unlock, %if.end2, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__xprt_put_cong(%struct.rpc_xprt* %xprt, %struct.rpc_rqst* %req) #0 {
entry:
  %rq_cong = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 6
  %0 = load i32, i32* %rq_cong, align 4, !tbaa !304
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %rq_cong1 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 6
  store i32 0, i32* %rq_cong1, align 4, !tbaa !304
  %cong = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 6
  %1 = load i64, i64* %cong, align 8, !tbaa !303
  %sub = sub i64 %1, 256
  store i64 %sub, i64* %cong, align 8, !tbaa !303
  call void @__xprt_lock_write_next_cong(%struct.rpc_xprt* %xprt)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_and_set_bit(i32 %nr, i64* %addr) #2 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !305
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @__xprt_lock_write_cong_func(%struct.rpc_task* %task, i8* %data) #0 {
entry:
  %0 = bitcast i8* %data to %struct.rpc_xprt*
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %1 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %cmp = icmp eq %struct.rpc_rqst* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %snd_task = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 32
  store %struct.rpc_task* %task, %struct.rpc_task** %snd_task, align 8, !tbaa !302
  br label %cleanup

if.end:                                           ; preds = %entry
  %call = call i32 @__xprt_get_cong(%struct.rpc_xprt* %0, %struct.rpc_task* %task)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then1, label %cleanup

if.then1:                                         ; preds = %if.end
  %snd_task2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 32
  store %struct.rpc_task* %task, %struct.rpc_task** %snd_task2, align 8, !tbaa !302
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 23
  store i32 0, i32* %rq_bytes_sent, align 8, !tbaa !143
  %rq_ntrans = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 25
  %2 = load i32, i32* %rq_ntrans, align 8, !tbaa !295
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %rq_ntrans, align 8, !tbaa !295
  br label %cleanup

cleanup:                                          ; preds = %if.then1, %if.end, %if.then
  %retval.0 = phi i1 [ true, %if.then ], [ true, %if.then1 ], [ false, %if.end ]
  ret i1 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @xprt_clear_locked(%struct.rpc_xprt* %xprt) #0 {
entry:
  %snd_task = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  store %struct.rpc_task* null, %struct.rpc_task** %snd_task, align 8, !tbaa !302
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %0 = load volatile i64, i64* %state, align 8, !tbaa !88
  %and.i = and i64 8, %0
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !306
  %state4 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state4, i32 0, i64* %state4) #7, !srcloc !300
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !307
  br label %if.end

if.else:                                          ; preds = %entry
  %1 = load %struct.workqueue_struct*, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !28
  %task_cleanup = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 25
  call void @queue_work(%struct.workqueue_struct* %1, %struct.work_struct* %task_cleanup)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_work(%struct.workqueue_struct* %wq, %struct.work_struct* %work) #2 {
entry:
  %call = call zeroext i1 @queue_work_on(i32 4096, %struct.workqueue_struct* %wq, %struct.work_struct* %work)
  ret void
}

declare zeroext i1 @queue_work_on(i32, %struct.workqueue_struct*, %struct.work_struct*) #4

; Function Attrs: nounwind uwtable
define internal i32 @__xprt_get_cong(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_cong = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 6
  %1 = load i32, i32* %rq_cong, align 4, !tbaa !304
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %cleanup, label %do.body

do.body:                                          ; preds = %entry
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 1
  %tobool1 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.end

if.then4:                                         ; preds = %do.body
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then4, %do.body
  %cong7 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 6
  %4 = load i64, i64* %cong7, align 8, !tbaa !303
  %cwnd8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 7
  %5 = load i64, i64* %cwnd8, align 8, !tbaa !271
  %cmp = icmp uge i64 %4, %5
  br i1 %cmp, label %cleanup, label %if.end11

if.end11:                                         ; preds = %do.end
  %rq_cong12 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 6
  store i32 1, i32* %rq_cong12, align 4, !tbaa !304
  %cong13 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 6
  %6 = load i64, i64* %cong13, align 8, !tbaa !303
  %add = add i64 %6, 256
  store i64 %add, i64* %cong13, align 8, !tbaa !303
  br label %cleanup

cleanup:                                          ; preds = %if.end11, %do.end, %entry
  %retval.0 = phi i32 [ 1, %if.end11 ], [ 1, %entry ], [ 0, %do.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @xprt_release_rqst_cong(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  call void @__xprt_put_cong(%struct.rpc_xprt* %1, %struct.rpc_rqst* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define void @xprt_release_xprt_cong(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  %snd_task = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  %0 = load %struct.rpc_task*, %struct.rpc_task** %snd_task, align 8, !tbaa !302
  %cmp = icmp eq %struct.rpc_task* %0, %task
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @xprt_clear_locked(%struct.rpc_xprt* %xprt)
  call void @__xprt_lock_write_next_cong(%struct.rpc_xprt* %xprt)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @xprt_release_xprt(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  %snd_task = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  %0 = load %struct.rpc_task*, %struct.rpc_task** %snd_task, align 8, !tbaa !302
  %cmp = icmp eq %struct.rpc_task* %0, %task
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @xprt_clear_locked(%struct.rpc_xprt* %xprt)
  call void @__xprt_lock_write_next(%struct.rpc_xprt* %xprt)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__xprt_lock_write_next(%struct.rpc_xprt* %xprt) #0 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @test_and_set_bit(i32 0, i64* %state)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %sending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 11
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %call1 = call %struct.rpc_task* @rpc_wake_up_first(%struct.rpc_wait_queue* %sending, i1 (%struct.rpc_task*, i8*)* @__xprt_lock_write_func, i8* %0)
  %tobool2 = icmp ne %struct.rpc_task* %call1, null
  br i1 %tobool2, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  call void @xprt_clear_locked(%struct.rpc_xprt* %xprt)
  br label %return

return:                                           ; preds = %if.end4, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @__xprt_lock_write_func(%struct.rpc_task* %task, i8* %data) #0 {
entry:
  %0 = bitcast i8* %data to %struct.rpc_xprt*
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %1 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %snd_task = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 32
  store %struct.rpc_task* %task, %struct.rpc_task** %snd_task, align 8, !tbaa !302
  %tobool = icmp ne %struct.rpc_rqst* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 23
  store i32 0, i32* %rq_bytes_sent, align 8, !tbaa !143
  %rq_ntrans = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 25
  %2 = load i32, i32* %rq_ntrans, align 8, !tbaa !295
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %rq_ntrans, align 8, !tbaa !295
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i1 true
}

; Function Attrs: nounwind uwtable
define i32 @xprt_reserve_xprt_cong(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @test_and_set_bit(i32 0, i64* %state)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end2

if.then:                                          ; preds = %entry
  %snd_task = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  %1 = load %struct.rpc_task*, %struct.rpc_task** %snd_task, align 8, !tbaa !302
  %cmp = icmp eq %struct.rpc_task* %task, %1
  br i1 %cmp, label %cleanup, label %do.body

if.end2:                                          ; preds = %entry
  %cmp3 = icmp eq %struct.rpc_rqst* %0, null
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end2
  %snd_task5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  store %struct.rpc_task* %task, %struct.rpc_task** %snd_task5, align 8, !tbaa !302
  br label %cleanup

if.end6:                                          ; preds = %if.end2
  %call7 = call i32 @__xprt_get_cong(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end6
  %snd_task10 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  store %struct.rpc_task* %task, %struct.rpc_task** %snd_task10, align 8, !tbaa !302
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  store i32 0, i32* %rq_bytes_sent, align 8, !tbaa !143
  %rq_ntrans = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 25
  %2 = load i32, i32* %rq_ntrans, align 8, !tbaa !295
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %rq_ntrans, align 8, !tbaa !295
  br label %cleanup

if.end11:                                         ; preds = %if.end6
  call void @xprt_clear_locked(%struct.rpc_xprt* %xprt)
  br label %do.body

do.body:                                          ; preds = %if.end11, %if.then
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %3, 1
  %tobool12 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool12, true
  %lnot13 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot13 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool14 = icmp ne i64 %expval, 0
  br i1 %tobool14, label %if.then15, label %do.end

if.then15:                                        ; preds = %do.body
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then15, %do.body
  %tk_timeout = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  store i64 0, i64* %tk_timeout, align 8, !tbaa !86
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 -11, i32* %tk_status, align 4, !tbaa !59
  %cmp19 = icmp eq %struct.rpc_rqst* %0, null
  br i1 %cmp19, label %if.end27, label %if.else

if.else:                                          ; preds = %do.end
  %rq_ntrans22 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 25
  %5 = load i32, i32* %rq_ntrans22, align 8, !tbaa !295
  %tobool23 = icmp ne i32 %5, 0
  %. = select i1 %tobool23, i32 1, i32 0
  br label %if.end27

if.end27:                                         ; preds = %if.else, %do.end
  %priority.1 = phi i32 [ %., %if.else ], [ -1, %do.end ]
  %sending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 11
  call void @rpc_sleep_on_priority(%struct.rpc_wait_queue* %sending, %struct.rpc_task* %task, void (%struct.rpc_task*)* null, i32 %priority.1)
  br label %cleanup

cleanup:                                          ; preds = %if.end27, %if.then9, %if.then4, %if.then
  %retval.0 = phi i32 [ 0, %if.end27 ], [ 1, %if.then4 ], [ 1, %if.then9 ], [ 1, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @xprt_reserve_xprt(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @test_and_set_bit(i32 0, i64* %state)
  %tobool = icmp ne i32 %call, 0
  %snd_task = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  br i1 %tobool, label %if.then, label %if.end2

if.then:                                          ; preds = %entry
  %1 = load %struct.rpc_task*, %struct.rpc_task** %snd_task, align 8, !tbaa !302
  %cmp = icmp eq %struct.rpc_task* %task, %1
  br i1 %cmp, label %cleanup, label %do.body

if.end2:                                          ; preds = %entry
  store %struct.rpc_task* %task, %struct.rpc_task** %snd_task, align 8, !tbaa !302
  %cmp4 = icmp ne %struct.rpc_rqst* %0, null
  br i1 %cmp4, label %if.then5, label %cleanup

if.then5:                                         ; preds = %if.end2
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  store i32 0, i32* %rq_bytes_sent, align 8, !tbaa !143
  %rq_ntrans = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 25
  %2 = load i32, i32* %rq_ntrans, align 8, !tbaa !295
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %rq_ntrans, align 8, !tbaa !295
  br label %cleanup

do.body:                                          ; preds = %if.then
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %3, 1
  %tobool7 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool7, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %do.end

if.then10:                                        ; preds = %do.body
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then10, %do.body
  %tk_timeout = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  store i64 0, i64* %tk_timeout, align 8, !tbaa !86
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 -11, i32* %tk_status, align 4, !tbaa !59
  %cmp14 = icmp eq %struct.rpc_rqst* %0, null
  br i1 %cmp14, label %if.end22, label %if.else

if.else:                                          ; preds = %do.end
  %rq_ntrans17 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 25
  %5 = load i32, i32* %rq_ntrans17, align 8, !tbaa !295
  %tobool18 = icmp ne i32 %5, 0
  %. = select i1 %tobool18, i32 1, i32 0
  br label %if.end22

if.end22:                                         ; preds = %if.else, %do.end
  %priority.1 = phi i32 [ %., %if.else ], [ -1, %do.end ]
  %sending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 11
  call void @rpc_sleep_on_priority(%struct.rpc_wait_queue* %sending, %struct.rpc_task* %task, void (%struct.rpc_task*)* null, i32 %priority.1)
  br label %cleanup

cleanup:                                          ; preds = %if.end22, %if.then5, %if.end2, %if.then
  %retval.0 = phi i32 [ 0, %if.end22 ], [ 1, %if.then ], [ 1, %if.then5 ], [ 1, %if.end2 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @xprt_load_transport(i8* %transport_name) #0 {
entry:
  call void @spin_lock.20(%struct.spinlock* @xprt_list_lock)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @xprt_list, i32 0, i32 0), %entry ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !28
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr5 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr5 to %struct.xprt_class*
  %list = getelementptr inbounds %struct.xprt_class, %struct.xprt_class* %2, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, @xprt_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %name = getelementptr inbounds %struct.xprt_class, %struct.xprt_class* %2, i32 0, i32 4
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  %call = call i32 @strcmp(i8* %arraydecay, i8* %transport_name)
  %cmp1 = icmp eq i32 %call, 0
  br i1 %cmp1, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @spin_unlock.25(%struct.spinlock* @xprt_list_lock)
  br label %out

for.inc:                                          ; preds = %for.body
  %list3 = getelementptr inbounds %struct.xprt_class, %struct.xprt_class* %2, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list3, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @spin_unlock.25(%struct.spinlock* @xprt_list_lock)
  %call6 = call i32 (i1, i8*, ...) @__request_module(i1 zeroext true, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.2.42, i32 0, i32 0), i8* %transport_name)
  br label %out

out:                                              ; preds = %for.end, %if.then
  %result.0 = phi i32 [ 0, %if.then ], [ %call6, %for.end ]
  ret i32 %result.0
}

declare i32 @strcmp(i8*, i8*) #4

declare i32 @__request_module(i1 zeroext, i8*, ...) #4

; Function Attrs: nounwind uwtable
define i32 @xprt_unregister_transport(%struct.xprt_class* %transport) #0 {
entry:
  call void @spin_lock.20(%struct.spinlock* @xprt_list_lock)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @xprt_list, i32 0, i32 0), %entry ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !28
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr6 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr6 to %struct.xprt_class*
  %list = getelementptr inbounds %struct.xprt_class, %struct.xprt_class* %2, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, @xprt_list
  br i1 %cmp, label %for.body, label %out

for.body:                                         ; preds = %for.cond
  %cmp1 = icmp eq %struct.xprt_class* %2, %transport
  br i1 %cmp1, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %3 = call i32 (i8*, ...) @printk(i8* null)
  %list2 = getelementptr inbounds %struct.xprt_class, %struct.xprt_class* %transport, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %list2)
  br label %out

for.inc:                                          ; preds = %for.body
  %list4 = getelementptr inbounds %struct.xprt_class, %struct.xprt_class* %2, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list4, i32 0, i32 0
  br label %for.cond

out:                                              ; preds = %if.then, %for.cond
  %result.0 = phi i32 [ 0, %if.then ], [ -2, %for.cond ]
  call void @spin_unlock.25(%struct.spinlock* @xprt_list_lock)
  ret i32 %result.0
}

; Function Attrs: nounwind uwtable
define i32 @xprt_register_transport(%struct.xprt_class* %transport) #0 {
entry:
  call void @spin_lock.20(%struct.spinlock* @xprt_list_lock)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @xprt_list, i32 0, i32 0), %entry ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !28
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr6 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr6 to %struct.xprt_class*
  %list = getelementptr inbounds %struct.xprt_class, %struct.xprt_class* %2, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, @xprt_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ident = getelementptr inbounds %struct.xprt_class, %struct.xprt_class* %2, i32 0, i32 1
  %3 = load i32, i32* %ident, align 8, !tbaa !308
  %ident1 = getelementptr inbounds %struct.xprt_class, %struct.xprt_class* %transport, i32 0, i32 1
  %4 = load i32, i32* %ident1, align 8, !tbaa !308
  %cmp2 = icmp eq i32 %3, %4
  br i1 %cmp2, label %out, label %for.inc

for.inc:                                          ; preds = %for.body
  %list4 = getelementptr inbounds %struct.xprt_class, %struct.xprt_class* %2, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list4, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %list7 = getelementptr inbounds %struct.xprt_class, %struct.xprt_class* %transport, i32 0, i32 0
  call void @list_add_tail.45(%struct.list_head* %list7, %struct.list_head* @xprt_list)
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %out

out:                                              ; preds = %for.end, %for.body
  %result.0 = phi i32 [ 0, %for.end ], [ -17, %for.body ]
  call void @spin_unlock.25(%struct.spinlock* @xprt_list_lock)
  ret i32 %result.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.45(%struct.list_head* %new, %struct.list_head* %head) #2 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !163
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @xprt_adjust_timeout(%struct.rpc_rqst* %req) #0 {
entry:
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 0
  %0 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %rq_task = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 3
  %1 = load %struct.rpc_task*, %struct.rpc_task** %rq_task, align 8, !tbaa !280
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %1, i32 0, i32 2
  %2 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %cl_timeout = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %2, i32 0, i32 15
  %3 = load %struct.rpc_timeout*, %struct.rpc_timeout** %cl_timeout, align 8, !tbaa !237
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.lhs.true, label %if.else23

land.lhs.true:                                    ; preds = %entry
  %4 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %rq_majortimeo = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 18
  %5 = load i64, i64* %rq_majortimeo, align 8, !tbaa !282
  %sub = sub nsw i64 %4, %5
  %cmp8 = icmp slt i64 %sub, 0
  br i1 %cmp8, label %if.then, label %if.else23

if.then:                                          ; preds = %land.lhs.true
  %to_exponential = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %3, i32 0, i32 4
  %6 = load i8, i8* %to_exponential, align 4, !tbaa !283
  %tobool10 = icmp ne i8 %6, 0
  br i1 %tobool10, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.then
  %rq_timeout = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 19
  %7 = load i64, i64* %rq_timeout, align 8, !tbaa !279
  %shl = shl i64 %7, 1
  store i64 %shl, i64* %rq_timeout, align 8, !tbaa !279
  br label %if.end

if.else:                                          ; preds = %if.then
  %to_increment = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %3, i32 0, i32 2
  %8 = load i64, i64* %to_increment, align 8, !tbaa !285
  %rq_timeout12 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 19
  %9 = load i64, i64* %rq_timeout12, align 8, !tbaa !279
  %add = add i64 %9, %8
  store i64 %add, i64* %rq_timeout12, align 8, !tbaa !279
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then11
  %to_maxval = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %3, i32 0, i32 1
  %10 = load i64, i64* %to_maxval, align 8, !tbaa !286
  %tobool13 = icmp ne i64 %10, 0
  br i1 %tobool13, label %land.lhs.true14, label %if.end22

land.lhs.true14:                                  ; preds = %if.end
  %rq_timeout15 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 19
  %11 = load i64, i64* %rq_timeout15, align 8, !tbaa !279
  %to_maxval16 = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %3, i32 0, i32 1
  %12 = load i64, i64* %to_maxval16, align 8, !tbaa !286
  %cmp17 = icmp uge i64 %11, %12
  br i1 %cmp17, label %if.then19, label %if.end22

if.then19:                                        ; preds = %land.lhs.true14
  %to_maxval20 = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %3, i32 0, i32 1
  %13 = load i64, i64* %to_maxval20, align 8, !tbaa !286
  %rq_timeout21 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 19
  store i64 %13, i64* %rq_timeout21, align 8, !tbaa !279
  br label %if.end22

if.end22:                                         ; preds = %if.then19, %land.lhs.true14, %if.end
  %rq_retries = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 21
  %14 = load i32, i32* %rq_retries, align 8, !tbaa !301
  %inc = add i32 %14, 1
  store i32 %inc, i32* %rq_retries, align 8, !tbaa !301
  br label %if.end30

if.else23:                                        ; preds = %land.lhs.true, %entry
  %to_initval = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %3, i32 0, i32 0
  %15 = load i64, i64* %to_initval, align 8, !tbaa !184
  %rq_timeout24 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 19
  store i64 %15, i64* %rq_timeout24, align 8, !tbaa !279
  %rq_retries25 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 21
  store i32 0, i32* %rq_retries25, align 8, !tbaa !301
  call void @xprt_reset_majortimeo(%struct.rpc_rqst* %req)
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 29
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %rq_task26 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 3
  %16 = load %struct.rpc_task*, %struct.rpc_task** %rq_task26, align 8, !tbaa !280
  %tk_client27 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %16, i32 0, i32 2
  %17 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client27, align 8, !tbaa !26
  %cl_rtt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %17, i32 0, i32 14
  %18 = load %struct.rpc_rtt*, %struct.rpc_rtt** %cl_rtt, align 8, !tbaa !238
  %to_initval28 = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %3, i32 0, i32 0
  %19 = load i64, i64* %to_initval28, align 8, !tbaa !184
  call void @rpc_init_rtt(%struct.rpc_rtt* %18, i64 %19)
  %transport_lock29 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 29
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock29)
  br label %if.end30

if.end30:                                         ; preds = %if.else23, %if.end22
  %status.0 = phi i32 [ 0, %if.end22 ], [ -110, %if.else23 ]
  %rq_timeout31 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 19
  %20 = load i64, i64* %rq_timeout31, align 8, !tbaa !279
  %cmp32 = icmp eq i64 %20, 0
  br i1 %cmp32, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end30
  %21 = call i32 (i8*, ...) @printk(i8* null)
  %rq_timeout35 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 19
  store i64 1250, i64* %rq_timeout35, align 8, !tbaa !279
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.end30
  ret i32 %status.0
}

; Function Attrs: nounwind uwtable
define void @xprt_force_disconnect(%struct.rpc_xprt* %xprt) #0 {
entry:
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 3, i64* %state) #7, !srcloc !278
  %state1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @test_and_set_bit(i32 0, i64* %state1)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !28
  %task_cleanup = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 25
  call void @queue_work(%struct.workqueue_struct* %0, %struct.work_struct* %task_cleanup)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @xprt_wake_pending_tasks(%struct.rpc_xprt* %xprt, i32 -11)
  %transport_lock3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock3)
  ret void
}

; Function Attrs: nounwind uwtable
define void @xprt_conditional_disconnect(%struct.rpc_xprt* %xprt, i32 %cookie) #0 {
entry:
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %connect_cookie = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 24
  %0 = load i32, i32* %connect_cookie, align 8, !tbaa !310
  %cmp = icmp ne i32 %cookie, %0
  br i1 %cmp, label %out, label %cond.true

cond.true:                                        ; preds = %entry
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %1 = load volatile i64, i64* %state, align 8, !tbaa !88
  %and.i = and i64 64, %1
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %out, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.true
  %call4 = call i32 @xprt_connected.69(%struct.rpc_xprt* %xprt)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.end7, label %out

if.end7:                                          ; preds = %lor.lhs.false
  %state8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %state8, i32 3, i64* %state8) #7, !srcloc !278
  %state9 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call10 = call i32 @test_and_set_bit(i32 0, i64* %state9)
  %cmp11 = icmp eq i32 %call10, 0
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end7
  %2 = load %struct.workqueue_struct*, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !28
  %task_cleanup = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 25
  call void @queue_work(%struct.workqueue_struct* %2, %struct.work_struct* %task_cleanup)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end7
  call void @xprt_wake_pending_tasks(%struct.rpc_xprt* %xprt, i32 -11)
  br label %out

out:                                              ; preds = %if.end14, %lor.lhs.false, %cond.true, %entry
  %transport_lock15 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock15)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_connected.69(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %0 = load volatile i64, i64* %state, align 8, !tbaa !88
  %and.i = and i64 2, %0
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  ret i32 %conv.i
}

; Function Attrs: nounwind uwtable
define void @xprt_connect(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %call = call i32 @xprt_connected.69(%struct.rpc_xprt* %1)
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %call6 = call i32 @xprt_bound.75(%struct.rpc_xprt* %1)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %do.end
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 -11, i32* %tk_status, align 4, !tbaa !59
  br label %cleanup.cont

if.end9:                                          ; preds = %do.end
  %call10 = call i32 @xprt_lock_write(%struct.rpc_xprt* %1, %struct.rpc_task* %task)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end13, label %cleanup.cont

if.end13:                                         ; preds = %if.end9
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 18
  %call14 = call i32 @test_and_clear_bit(i32 3, i64* %state)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 1
  %4 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %close = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %4, i32 0, i32 13
  %5 = load void (%struct.rpc_xprt*)*, void (%struct.rpc_xprt*)** %close, align 8, !tbaa !311
  call void %5(%struct.rpc_xprt* %1)
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.end13
  %call18 = call i32 @xprt_connected.69(%struct.rpc_xprt* %1)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.then20, label %if.else

if.then20:                                        ; preds = %if.end17
  call void @xprt_release_write(%struct.rpc_xprt* %1, %struct.rpc_task* %task)
  br label %cleanup.cont

if.else:                                          ; preds = %if.end17
  %tk_rqstp21 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %6 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp21, align 8, !tbaa !60
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %6, i32 0, i32 23
  store i32 0, i32* %rq_bytes_sent, align 8, !tbaa !143
  %tk_rqstp22 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %7 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp22, align 8, !tbaa !60
  %rq_timeout = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %7, i32 0, i32 19
  %8 = load i64, i64* %rq_timeout, align 8, !tbaa !279
  %tk_timeout = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  store i64 %8, i64* %tk_timeout, align 8, !tbaa !86
  %pending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 12
  call void @rpc_sleep_on(%struct.rpc_wait_queue* %pending, %struct.rpc_task* %task, void (%struct.rpc_task*)* @xprt_connect_status)
  %state23 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 18
  %9 = load volatile i64, i64* %state23, align 8, !tbaa !88
  %and.i = and i64 64, %9
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool25 = icmp ne i32 %conv.i, 0
  br i1 %tobool25, label %cleanup.cont, label %if.end30

if.end30:                                         ; preds = %if.else
  %call31 = call i32 @xprt_test_and_set_connecting(%struct.rpc_xprt* %1)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %cleanup.cont, label %if.end34

if.end34:                                         ; preds = %if.end30
  %10 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 39
  %connect_start = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat, i32 0, i32 2
  store i64 %10, i64* %connect_start, align 8, !tbaa !312
  %ops35 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 1
  %11 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops35, align 8, !tbaa !81
  %connect = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %11, i32 0, i32 6
  %12 = load void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)** %connect, align 8, !tbaa !313
  call void %12(%struct.rpc_xprt* %1, %struct.rpc_task* %task)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end34, %if.end30, %if.else, %if.then20, %if.end9, %if.then8
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_bound.75(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %0 = load volatile i64, i64* %state, align 8, !tbaa !88
  %and.i = and i64 16, %0
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  ret i32 %conv.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_and_clear_bit(i32 %nr, i64* %addr) #2 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !314
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal void @xprt_connect_status(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %2 = load i32, i32* %tk_status, align 4, !tbaa !59
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 39
  %connect_count = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat, i32 0, i32 1
  %3 = load i64, i64* %connect_count, align 8, !tbaa !315
  %inc = add i64 %3, 1
  store i64 %inc, i64* %connect_count, align 8, !tbaa !315
  %4 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %stat1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 39
  %connect_start = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat1, i32 0, i32 2
  %5 = load i64, i64* %connect_start, align 8, !tbaa !312
  %sub = sub i64 %4, %5
  %stat2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 39
  %connect_time = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat2, i32 0, i32 3
  %6 = load i64, i64* %connect_time, align 8, !tbaa !316
  %add = add i64 %6, %sub
  store i64 %add, i64* %connect_time, align 8, !tbaa !316
  %7 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %7, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then5, label %cleanup.cont

if.then5:                                         ; preds = %if.then
  %8 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup.cont

if.end7:                                          ; preds = %entry
  %tk_status8 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %9 = load i32, i32* %tk_status8, align 4, !tbaa !59
  %Pivot = icmp slt i32 %9, -11
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end7
  %SwitchLeaf2 = icmp eq i32 %9, -11
  br i1 %SwitchLeaf2, label %do.body9, label %do.body44

LeafBlock:                                        ; preds = %if.end7
  %SwitchLeaf = icmp eq i32 %9, -110
  br i1 %SwitchLeaf, label %do.body27, label %do.body44

do.body9:                                         ; preds = %LeafBlock1
  %10 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and10 = and i32 %10, 1
  %tobool11 = icmp ne i32 %and10, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %if.then19, label %cleanup.cont

if.then19:                                        ; preds = %do.body9
  %11 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup.cont

do.body27:                                        ; preds = %LeafBlock
  %12 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and28 = and i32 %12, 1
  %tobool29 = icmp ne i32 %and28, 0
  %lnot30 = xor i1 %tobool29, true
  %lnot32 = xor i1 %lnot30, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %expval35 = call i64 @llvm.expect.i64(i64 %conv34, i64 0)
  %tobool36 = icmp ne i64 %expval35, 0
  br i1 %tobool36, label %if.then37, label %cleanup.cont

if.then37:                                        ; preds = %do.body27
  %13 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup.cont

do.body44:                                        ; preds = %LeafBlock, %LeafBlock1
  %14 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and45 = and i32 %14, 1
  %tobool46 = icmp ne i32 %and45, 0
  %lnot47 = xor i1 %tobool46, true
  %lnot49 = xor i1 %lnot47, true
  %lnot.ext50 = zext i1 %lnot49 to i32
  %conv51 = sext i32 %lnot.ext50 to i64
  %expval52 = call i64 @llvm.expect.i64(i64 %conv51, i64 0)
  %tobool53 = icmp ne i64 %expval52, 0
  br i1 %tobool53, label %if.then54, label %do.end62

if.then54:                                        ; preds = %do.body44
  %15 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end62

do.end62:                                         ; preds = %if.then54, %do.body44
  call void @xprt_release_write(%struct.rpc_xprt* %1, %struct.rpc_task* %task)
  %tk_status63 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 -5, i32* %tk_status63, align 4, !tbaa !59
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %do.end62, %if.then37, %do.body27, %if.then19, %do.body9, %if.then5, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_test_and_set_connecting(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @test_and_set_bit(i32 2, i64* %state)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @xprt_prepare_transmit(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 29
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %rq_reply_bytes_recvd = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 16
  %4 = load i64, i64* %rq_reply_bytes_recvd, align 8, !tbaa !142
  %tobool4 = icmp ne i64 %4, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %do.end
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  %5 = load i32, i32* %rq_bytes_sent, align 8, !tbaa !143
  %tobool5 = icmp ne i32 %5, 0
  br i1 %tobool5, label %if.end9, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %rq_reply_bytes_recvd7 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 16
  %6 = load i64, i64* %rq_reply_bytes_recvd7, align 8, !tbaa !142
  %conv8 = trunc i64 %6 to i32
  br label %out_unlock

if.end9:                                          ; preds = %land.lhs.true, %do.end
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 1
  %7 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %reserve_xprt = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %7, i32 0, i32 1
  %8 = load i32 (%struct.rpc_xprt*, %struct.rpc_task*)*, i32 (%struct.rpc_xprt*, %struct.rpc_task*)** %reserve_xprt, align 8, !tbaa !275
  %call10 = call i32 %8(%struct.rpc_xprt* %1, %struct.rpc_task* %task)
  %tobool11 = icmp ne i32 %call10, 0
  %. = select i1 %tobool11, i32 0, i32 -11
  br label %out_unlock

out_unlock:                                       ; preds = %if.end9, %if.then6
  %err.1 = phi i32 [ %., %if.end9 ], [ %conv8, %if.then6 ]
  %transport_lock14 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 29
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock14)
  ret i32 %err.1
}

; Function Attrs: nounwind uwtable
define void @xprt_end_transmit(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  call void @xprt_release_write(%struct.rpc_xprt* %1, %struct.rpc_task* %task)
  ret void
}

; Function Attrs: nounwind uwtable
define void @xprt_transmit(%struct.rpc_task* %task) #0 {
entry:
  %coerce = alloca %struct.pgprot, align 8
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %rq_reply_bytes_recvd = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 16
  %4 = load i64, i64* %rq_reply_bytes_recvd, align 8, !tbaa !142
  %tobool4 = icmp ne i64 %4, 0
  br i1 %tobool4, label %if.else21, label %if.then5

if.then5:                                         ; preds = %do.end
  %rq_list = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 11
  %call6 = call i32 @list_empty.3(%struct.list_head* %rq_list)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %if.then5
  %call8 = call i32 @rpc_reply_expected.88(%struct.rpc_task* %task)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end25

if.then10:                                        ; preds = %land.lhs.true
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 29
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %cmp = icmp uge i64 64, 64
  %rq_private_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 17
  %5 = bitcast %struct.xdr_buf* %rq_private_buf to i8*
  %rq_rcv_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 2
  %6 = bitcast %struct.xdr_buf* %rq_rcv_buf to i8*
  br i1 %cmp, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.then10
  %call13 = call i8* @__memcpy(i8* %5, i8* %6, i64 64)
  br label %if.end16

if.else:                                          ; preds = %if.then10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 64, i32 8, i1 false)
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then12
  %rq_list17 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 11
  %recv = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 38
  call void @list_add_tail.45(%struct.list_head* %rq_list17, %struct.list_head* %recv)
  %transport_lock18 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 29
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock18)
  call void @xprt_reset_majortimeo(%struct.rpc_rqst* %0)
  %timer = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 26
  %call19 = call i32 @del_timer_sync(%struct.timer_list* %timer)
  br label %if.end25

if.else21:                                        ; preds = %do.end
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  %7 = load i32, i32* %rq_bytes_sent, align 8, !tbaa !143
  %tobool22 = icmp ne i32 %7, 0
  br i1 %tobool22, label %if.end25, label %cleanup.cont

if.end25:                                         ; preds = %if.else21, %if.end16, %land.lhs.true, %if.then5
  %connect_cookie = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 24
  %8 = load i32, i32* %connect_cookie, align 8, !tbaa !310
  %rq_connect_cookie = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 22
  store i32 %8, i32* %rq_connect_cookie, align 4, !tbaa !144
  %rq_xtime = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 24
  %call26 = call i64 @ktime_get()
  %coerce.dive = getelementptr inbounds %struct.pgprot, %struct.pgprot* %coerce, i32 0, i32 0
  store i64 %call26, i64* %coerce.dive, align 8
  %9 = bitcast %struct.pgprot* %rq_xtime to i8*
  %10 = bitcast %struct.pgprot* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 8, i32 8, i1 false), !tbaa.struct !290
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 1
  %11 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %send_request = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %11, i32 0, i32 9
  %12 = load i32 (%struct.rpc_task*)*, i32 (%struct.rpc_task*)** %send_request, align 8, !tbaa !317
  %call27 = call i32 %12(%struct.rpc_task* %task)
  %cmp28 = icmp ne i32 %call27, 0
  br i1 %cmp28, label %if.then30, label %do.body32

if.then30:                                        ; preds = %if.end25
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 %call27, i32* %tk_status, align 4, !tbaa !59
  br label %cleanup.cont

do.body32:                                        ; preds = %if.end25
  %13 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and33 = and i32 %13, 1
  %tobool34 = icmp ne i32 %and33, 0
  %lnot35 = xor i1 %tobool34, true
  %lnot37 = xor i1 %lnot35, true
  %lnot.ext38 = zext i1 %lnot37 to i32
  %conv39 = sext i32 %lnot.ext38 to i64
  %expval40 = call i64 @llvm.expect.i64(i64 %conv39, i64 0)
  %tobool41 = icmp ne i64 %expval40, 0
  br i1 %tobool41, label %if.then42, label %do.end48

if.then42:                                        ; preds = %do.body32
  %14 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end48

do.end48:                                         ; preds = %if.then42, %do.body32
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %15 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv49 = zext i16 %15 to i32
  %or = or i32 %conv49, 2048
  %conv50 = trunc i32 %or to i16
  store i16 %conv50, i16* %tk_flags, align 8, !tbaa !27
  %transport_lock51 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 29
  call void @spin_lock_bh(%struct.spinlock* %transport_lock51)
  %ops52 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 1
  %16 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops52, align 8, !tbaa !81
  %set_retrans_timeout = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %16, i32 0, i32 10
  %17 = load void (%struct.rpc_task*)*, void (%struct.rpc_task*)** %set_retrans_timeout, align 8, !tbaa !318
  call void %17(%struct.rpc_task* %task)
  %num_reqs = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 17
  %call53 = call i32 @atomic_read.32(%struct.atomic_t* %num_reqs)
  %conv54 = sext i32 %call53 to i64
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 39
  %max_slots = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat, i32 0, i32 7
  %18 = load i64, i64* %max_slots, align 8, !tbaa !319
  %cmp55 = icmp ugt i64 %conv54, %18
  br i1 %cmp55, label %if.then57, label %if.end61

if.then57:                                        ; preds = %do.end48
  %conv58 = sext i32 %call53 to i64
  %stat59 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 39
  %max_slots60 = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat59, i32 0, i32 7
  store i64 %conv58, i64* %max_slots60, align 8, !tbaa !319
  br label %if.end61

if.end61:                                         ; preds = %if.then57, %do.end48
  %stat62 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 39
  %sends = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat62, i32 0, i32 4
  %19 = load i64, i64* %sends, align 8, !tbaa !320
  %inc = add i64 %19, 1
  store i64 %inc, i64* %sends, align 8, !tbaa !320
  %stat63 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 39
  %sends64 = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat63, i32 0, i32 4
  %20 = load i64, i64* %sends64, align 8, !tbaa !320
  %stat65 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 39
  %recvs = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat65, i32 0, i32 5
  %21 = load i64, i64* %recvs, align 8, !tbaa !289
  %sub = sub i64 %20, %21
  %stat66 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 39
  %req_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat66, i32 0, i32 8
  %22 = load i64, i64* %req_u, align 8, !tbaa !321
  %add = add i64 %22, %sub
  store i64 %add, i64* %req_u, align 8, !tbaa !321
  %backlog = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 13
  %qlen = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %backlog, i32 0, i32 6
  %23 = load i16, i16* %qlen, align 8, !tbaa !322
  %conv67 = zext i16 %23 to i64
  %stat68 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 39
  %bklog_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat68, i32 0, i32 9
  %24 = load i64, i64* %bklog_u, align 8, !tbaa !323
  %add69 = add i64 %24, %conv67
  store i64 %add69, i64* %bklog_u, align 8, !tbaa !323
  %sending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 11
  %qlen70 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %sending, i32 0, i32 6
  %25 = load i16, i16* %qlen70, align 8, !tbaa !324
  %conv71 = zext i16 %25 to i64
  %stat72 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 39
  %sending_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat72, i32 0, i32 10
  %26 = load i64, i64* %sending_u, align 8, !tbaa !325
  %add73 = add i64 %26, %conv71
  store i64 %add73, i64* %sending_u, align 8, !tbaa !325
  %pending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 12
  %qlen74 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %pending, i32 0, i32 6
  %27 = load i16, i16* %qlen74, align 8, !tbaa !326
  %conv75 = zext i16 %27 to i64
  %stat76 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 39
  %pending_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat76, i32 0, i32 11
  %28 = load i64, i64* %pending_u, align 8, !tbaa !327
  %add77 = add i64 %28, %conv75
  store i64 %add77, i64* %pending_u, align 8, !tbaa !327
  %call78 = call i32 @xprt_connected.69(%struct.rpc_xprt* %1)
  %tobool79 = icmp ne i32 %call78, 0
  br i1 %tobool79, label %if.else82, label %if.then80

if.then80:                                        ; preds = %if.end61
  %tk_status81 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 -107, i32* %tk_status81, align 4, !tbaa !59
  br label %if.end91

if.else82:                                        ; preds = %if.end61
  %rq_reply_bytes_recvd83 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 16
  %29 = load i64, i64* %rq_reply_bytes_recvd83, align 8, !tbaa !142
  %tobool84 = icmp ne i64 %29, 0
  br i1 %tobool84, label %if.end91, label %land.lhs.true85

land.lhs.true85:                                  ; preds = %if.else82
  %call86 = call i32 @rpc_reply_expected.88(%struct.rpc_task* %task)
  %tobool87 = icmp ne i32 %call86, 0
  br i1 %tobool87, label %if.then88, label %if.end91

if.then88:                                        ; preds = %land.lhs.true85
  %pending89 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 12
  call void @rpc_sleep_on(%struct.rpc_wait_queue* %pending89, %struct.rpc_task* %task, void (%struct.rpc_task*)* @xprt_timer)
  br label %if.end91

if.end91:                                         ; preds = %if.then88, %land.lhs.true85, %if.else82, %if.then80
  %transport_lock92 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 29
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock92)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end91, %if.then30, %if.else21
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rpc_reply_expected.88(%struct.rpc_task* %task) #2 {
entry:
  %tk_msg = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg, i32 0, i32 0
  %0 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !44
  %cmp = icmp ne %struct.rpc_procinfo* %0, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %tk_msg1 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_proc2 = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg1, i32 0, i32 0
  %1 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %rpc_proc2, align 8, !tbaa !44
  %p_decode = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %1, i32 0, i32 2
  %2 = load i32 (i8*, %struct.xdr_stream*, i8*)*, i32 (i8*, %struct.xdr_stream*, i8*)** %p_decode, align 8, !tbaa !76
  %cmp3 = icmp ne i32 (i8*, %struct.xdr_stream*, i8*)* %2, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp3, %land.rhs ]
  %land.ext = zext i1 %3 to i32
  ret i32 %land.ext
}

declare i32 @del_timer_sync(%struct.timer_list*) #4

; Function Attrs: nounwind uwtable
define internal void @xprt_timer(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %2 = load i32, i32* %tk_status, align 4, !tbaa !59
  %cmp = icmp ne i32 %2, -110
  br i1 %cmp, label %cleanup.cont, label %do.body

do.body:                                          ; preds = %entry
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %3, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then3, label %do.end

if.then3:                                         ; preds = %do.body
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then3, %do.body
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 29
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %rq_reply_bytes_recvd = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 16
  %5 = load i64, i64* %rq_reply_bytes_recvd, align 8, !tbaa !142
  %tobool6 = icmp ne i64 %5, 0
  br i1 %tobool6, label %if.else, label %if.then7

if.then7:                                         ; preds = %do.end
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 1
  %6 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %timer = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %6, i32 0, i32 11
  %7 = load void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)** %timer, align 8, !tbaa !292
  %tobool8 = icmp ne void (%struct.rpc_xprt*, %struct.rpc_task*)* %7, null
  br i1 %tobool8, label %if.then9, label %if.end14

if.then9:                                         ; preds = %if.then7
  %ops10 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 1
  %8 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops10, align 8, !tbaa !81
  %timer11 = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %8, i32 0, i32 11
  %9 = load void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)** %timer11, align 8, !tbaa !292
  call void %9(%struct.rpc_xprt* %1, %struct.rpc_task* %task)
  br label %if.end14

if.else:                                          ; preds = %do.end
  %tk_status13 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status13, align 4, !tbaa !59
  br label %if.end14

if.end14:                                         ; preds = %if.else, %if.then9, %if.then7
  %transport_lock15 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 29
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock15)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end14, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @xprt_reserve(%struct.rpc_task* %task) #0 {
entry:
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status, align 4, !tbaa !59
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %cmp = icmp ne %struct.rpc_rqst* %0, null
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %tk_timeout = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  store i64 0, i64* %tk_timeout, align 8, !tbaa !86
  %tk_status1 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 -11, i32* %tk_status1, align 4, !tbaa !59
  call void @rcu_read_lock.93()
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %1 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %1, i32 0, i32 4
  %2 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end10

land.lhs.true:                                    ; preds = %if.end
  %3 = load i8, i8* @xprt_reserve.__warned, align 1, !tbaa !29, !range !31
  %tobool2 = trunc i8 %3 to i1
  br i1 %tobool2, label %do.end10, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %land.lhs.true
  %call4 = call i32 @rcu_read_lock_held.94()
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %do.end10, label %if.then6

if.then6:                                         ; preds = %land.lhs.true3
  store i8 1, i8* @xprt_reserve.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.18.95, i32 0, i32 0), i32 1138, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end10

do.end10:                                         ; preds = %if.then6, %land.lhs.true3, %land.lhs.true, %if.end
  %call11 = call zeroext i1 @xprt_throttle_congested(%struct.rpc_xprt* %2, %struct.rpc_task* %task)
  br i1 %call11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %do.end10
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %2, i32 0, i32 1
  %4 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %alloc_slot = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %4, i32 0, i32 3
  %5 = load void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)** %alloc_slot, align 8, !tbaa !328
  call void %5(%struct.rpc_xprt* %2, %struct.rpc_task* %task)
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %do.end10
  call void @rcu_read_unlock.97()
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end13, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock.93() #2 {
entry:
  call void @__rcu_read_lock.104()
  call void @rcu_lock_acquire.105(%struct.lockdep_map* @rcu_lock_map)
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_lock.__warned.106, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_lock.__warned.106, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 780, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.15.1329, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rcu_read_lock_held.94() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call1 = call i32 @rcu_is_cpu_idle()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call zeroext i1 @rcu_lockdep_current_cpu_online()
  br i1 %call5, label %if.end7, label %return

if.end7:                                          ; preds = %if.end4
  %call8 = call i32 @lock_is_held(%struct.lockdep_map* @rcu_lock_map)
  br label %return

return:                                           ; preds = %if.end7, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call8, %if.end7 ], [ 1, %entry ], [ 0, %if.end ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @xprt_throttle_congested(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %0 = load volatile i64, i64* %state, align 8, !tbaa !88
  %and.i1 = and i64 512, %0
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool = icmp ne i32 %conv.i3, 0
  br i1 %tobool, label %if.end, label %out

if.end:                                           ; preds = %entry
  %reserve_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 30
  call void @spin_lock.20(%struct.spinlock* %reserve_lock)
  %state5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %1 = load volatile i64, i64* %state5, align 8, !tbaa !88
  %and.i = and i64 512, %1
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool7 = icmp ne i32 %conv.i, 0
  br i1 %tobool7, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end
  %backlog = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 13
  call void @rpc_sleep_on(%struct.rpc_wait_queue* %backlog, %struct.rpc_task* %task, void (%struct.rpc_task*)* null)
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end
  %ret.0 = phi i8 [ 1, %if.then12 ], [ 0, %if.end ]
  %reserve_lock14 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 30
  call void @spin_unlock.25(%struct.spinlock* %reserve_lock14)
  br label %out

out:                                              ; preds = %if.end13, %entry
  %ret.1 = phi i8 [ %ret.0, %if.end13 ], [ 0, %entry ]
  %tobool15 = trunc i8 %ret.1 to i1
  ret i1 %tobool15
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_unlock.97() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_unlock.__warned.98, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_unlock.__warned.98, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 801, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.16.1322, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  call void @rcu_lock_release.101(%struct.lockdep_map* @rcu_lock_map)
  call void @__rcu_read_unlock.102()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_release.101(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_release(%struct.lockdep_map* %map, i32 1, i64 ptrtoint (i8* blockaddress(@rcu_lock_release.101, %__here) to i64))
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_unlock.102() #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !329
  %call = call %struct.thread_info* @current_thread_info.103()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !330
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.103() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !331
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_lock.104() #2 {
entry:
  %call = call %struct.thread_info* @current_thread_info.103()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !332
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_acquire.105(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_acquire(%struct.lockdep_map* %map, i32 0, i32 0, i32 2, i32 1, %struct.lockdep_map* null, i64 ptrtoint (i8* blockaddress(@rcu_lock_acquire.105, %__here) to i64))
  ret void
}

; Function Attrs: nounwind uwtable
define void @xprt_retry_reserve(%struct.rpc_task* %task) #0 {
entry:
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status, align 4, !tbaa !59
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %cmp = icmp ne %struct.rpc_rqst* %0, null
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %tk_timeout = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  store i64 0, i64* %tk_timeout, align 8, !tbaa !86
  %tk_status1 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 -11, i32* %tk_status1, align 4, !tbaa !59
  call void @rcu_read_lock.93()
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %1 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %1, i32 0, i32 4
  %2 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end10

land.lhs.true:                                    ; preds = %if.end
  %3 = load i8, i8* @xprt_retry_reserve.__warned, align 1, !tbaa !29, !range !31
  %tobool2 = trunc i8 %3 to i1
  br i1 %tobool2, label %do.end10, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %land.lhs.true
  %call4 = call i32 @rcu_read_lock_held.94()
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %do.end10, label %if.then6

if.then6:                                         ; preds = %land.lhs.true3
  store i8 1, i8* @xprt_retry_reserve.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.18.95, i32 0, i32 0), i32 1164, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end10

do.end10:                                         ; preds = %if.then6, %land.lhs.true3, %land.lhs.true, %if.end
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %2, i32 0, i32 1
  %4 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %alloc_slot = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %4, i32 0, i32 3
  %5 = load void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)** %alloc_slot, align 8, !tbaa !328
  call void %5(%struct.rpc_xprt* %2, %struct.rpc_task* %task)
  call void @rcu_read_unlock.97()
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %do.end10, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @xprt_release(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %cmp = icmp eq %struct.rpc_rqst* %0, null
  br i1 %cmp, label %if.then, label %if.end16

if.then:                                          ; preds = %entry
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %1 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %tobool = icmp ne %struct.rpc_clnt* %1, null
  br i1 %tobool, label %if.then1, label %cleanup.cont

if.then1:                                         ; preds = %if.then
  call void @rcu_read_lock.93()
  %tk_client2 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %2 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client2, align 8, !tbaa !26
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %2, i32 0, i32 4
  %3 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %land.lhs.true, label %do.end11

land.lhs.true:                                    ; preds = %if.then1
  %4 = load i8, i8* @xprt_release.__warned, align 1, !tbaa !29, !range !31
  %tobool4 = trunc i8 %4 to i1
  br i1 %tobool4, label %do.end11, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call6 = call i32 @rcu_read_lock_held.94()
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %do.end11, label %if.then8

if.then8:                                         ; preds = %land.lhs.true5
  store i8 1, i8* @xprt_release.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.18.95, i32 0, i32 0), i32 1208, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end11

do.end11:                                         ; preds = %if.then8, %land.lhs.true5, %land.lhs.true, %if.then1
  %snd_task = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %3, i32 0, i32 32
  %5 = load %struct.rpc_task*, %struct.rpc_task** %snd_task, align 8, !tbaa !302
  %cmp12 = icmp eq %struct.rpc_task* %5, %task
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %do.end11
  call void @xprt_release_write(%struct.rpc_xprt* %3, %struct.rpc_task* %task)
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %do.end11
  call void @rcu_read_unlock.97()
  br label %cleanup.cont

if.end16:                                         ; preds = %entry
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %6 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %tk_ops = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 7
  %7 = load %struct.rpc_call_ops*, %struct.rpc_call_ops** %tk_ops, align 8, !tbaa !180
  %rpc_count_stats = getelementptr inbounds %struct.rpc_call_ops, %struct.rpc_call_ops* %7, i32 0, i32 2
  %8 = load void (%struct.rpc_task*, i8*)*, void (%struct.rpc_task*, i8*)** %rpc_count_stats, align 8, !tbaa !333
  %cmp17 = icmp ne void (%struct.rpc_task*, i8*)* %8, null
  br i1 %cmp17, label %if.then18, label %if.else

if.then18:                                        ; preds = %if.end16
  %tk_ops19 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 7
  %9 = load %struct.rpc_call_ops*, %struct.rpc_call_ops** %tk_ops19, align 8, !tbaa !180
  %rpc_count_stats20 = getelementptr inbounds %struct.rpc_call_ops, %struct.rpc_call_ops* %9, i32 0, i32 2
  %10 = load void (%struct.rpc_task*, i8*)*, void (%struct.rpc_task*, i8*)** %rpc_count_stats20, align 8, !tbaa !333
  %tk_calldata = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 8
  %11 = load i8*, i8** %tk_calldata, align 8, !tbaa !334
  call void %10(%struct.rpc_task* %task, i8* %11)
  br label %if.end26

if.else:                                          ; preds = %if.end16
  %tk_client21 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %12 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client21, align 8, !tbaa !26
  %tobool22 = icmp ne %struct.rpc_clnt* %12, null
  br i1 %tobool22, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.else
  %tk_client24 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %13 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client24, align 8, !tbaa !26
  %cl_metrics = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %13, i32 0, i32 12
  %14 = load %struct.rpc_iostats*, %struct.rpc_iostats** %cl_metrics, align 8, !tbaa !169
  call void @rpc_count_iostats(%struct.rpc_task* %task, %struct.rpc_iostats* %14)
  br label %if.end26

if.end26:                                         ; preds = %if.then23, %if.else, %if.then18
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %6, i32 0, i32 29
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %6, i32 0, i32 1
  %15 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %release_xprt = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %15, i32 0, i32 2
  %16 = load void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)** %release_xprt, align 8, !tbaa !277
  call void %16(%struct.rpc_xprt* %6, %struct.rpc_task* %task)
  %ops27 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %6, i32 0, i32 1
  %17 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops27, align 8, !tbaa !81
  %release_request = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %17, i32 0, i32 12
  %18 = load void (%struct.rpc_task*)*, void (%struct.rpc_task*)** %release_request, align 8, !tbaa !335
  %tobool28 = icmp ne void (%struct.rpc_task*)* %18, null
  br i1 %tobool28, label %if.then29, label %if.end32

if.then29:                                        ; preds = %if.end26
  %ops30 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %6, i32 0, i32 1
  %19 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops30, align 8, !tbaa !81
  %release_request31 = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %19, i32 0, i32 12
  %20 = load void (%struct.rpc_task*)*, void (%struct.rpc_task*)** %release_request31, align 8, !tbaa !335
  call void %20(%struct.rpc_task* %task)
  br label %if.end32

if.end32:                                         ; preds = %if.then29, %if.end26
  %rq_list = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 11
  %call33 = call i32 @list_empty.3(%struct.list_head* %rq_list)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.end37, label %if.then35

if.then35:                                        ; preds = %if.end32
  %rq_list36 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 11
  call void @list_del(%struct.list_head* %rq_list36)
  br label %if.end37

if.end37:                                         ; preds = %if.then35, %if.end32
  %21 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %last_used = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %6, i32 0, i32 27
  store i64 %21, i64* %last_used, align 8, !tbaa !270
  %recv = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %6, i32 0, i32 38
  %call38 = call i32 @list_empty.3(%struct.list_head* %recv)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %land.lhs.true40, label %if.end46

land.lhs.true40:                                  ; preds = %if.end37
  %call41 = call i32 @xprt_has_timer(%struct.rpc_xprt* %6)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %if.then43, label %if.end46

if.then43:                                        ; preds = %land.lhs.true40
  %timer = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %6, i32 0, i32 26
  %last_used44 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %6, i32 0, i32 27
  %22 = load i64, i64* %last_used44, align 8, !tbaa !270
  %idle_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %6, i32 0, i32 28
  %23 = load i64, i64* %idle_timeout, align 8, !tbaa !336
  %add = add i64 %22, %23
  %call45 = call i32 @mod_timer(%struct.timer_list* %timer, i64 %add)
  br label %if.end46

if.end46:                                         ; preds = %if.then43, %land.lhs.true40, %if.end37
  %transport_lock47 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %6, i32 0, i32 29
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock47)
  %rq_buffer = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 12
  %24 = load i32*, i32** %rq_buffer, align 8, !tbaa !72
  %tobool48 = icmp ne i32* %24, null
  br i1 %tobool48, label %if.then49, label %if.end52

if.then49:                                        ; preds = %if.end46
  %ops50 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %6, i32 0, i32 1
  %25 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops50, align 8, !tbaa !81
  %buf_free = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %25, i32 0, i32 8
  %26 = load void (i8*)*, void (i8*)** %buf_free, align 8, !tbaa !337
  %rq_buffer51 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 12
  %27 = load i32*, i32** %rq_buffer51, align 8, !tbaa !72
  %28 = bitcast i32* %27 to i8*
  call void %26(i8* %28)
  br label %if.end52

if.end52:                                         ; preds = %if.then49, %if.end46
  %rq_cred = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 4
  %29 = load %struct.rpc_cred*, %struct.rpc_cred** %rq_cred, align 8, !tbaa !62
  %cmp53 = icmp ne %struct.rpc_cred* %29, null
  br i1 %cmp53, label %if.then54, label %if.end56

if.then54:                                        ; preds = %if.end52
  %rq_cred55 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 4
  %30 = load %struct.rpc_cred*, %struct.rpc_cred** %rq_cred55, align 8, !tbaa !62
  call void @put_rpccred(%struct.rpc_cred* %30)
  br label %if.end56

if.end56:                                         ; preds = %if.then54, %if.end52
  %tk_rqstp57 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  store %struct.rpc_rqst* null, %struct.rpc_rqst** %tk_rqstp57, align 8, !tbaa !60
  %rq_release_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 10
  %31 = load void (%struct.rpc_rqst*)*, void (%struct.rpc_rqst*)** %rq_release_snd_buf, align 8, !tbaa !281
  %tobool58 = icmp ne void (%struct.rpc_rqst*)* %31, null
  br i1 %tobool58, label %if.then59, label %do.body62

if.then59:                                        ; preds = %if.end56
  %rq_release_snd_buf60 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 10
  %32 = load void (%struct.rpc_rqst*)*, void (%struct.rpc_rqst*)** %rq_release_snd_buf60, align 8, !tbaa !281
  call void %32(%struct.rpc_rqst* %0)
  br label %do.body62

do.body62:                                        ; preds = %if.then59, %if.end56
  %33 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %33, 1
  %tobool63 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool63, true
  %lnot64 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot64 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool65 = icmp ne i64 %expval, 0
  br i1 %tobool65, label %if.then66, label %do.end71

if.then66:                                        ; preds = %do.body62
  %34 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end71

do.end71:                                         ; preds = %if.then66, %do.body62
  %call72 = call i32 @bc_prealloc(%struct.rpc_rqst* %0)
  %tobool73 = icmp ne i32 %call72, 0
  %lnot74 = xor i1 %tobool73, true
  %lnot76 = xor i1 %lnot74, true
  %lnot78 = xor i1 %lnot76, true
  %lnot.ext79 = zext i1 %lnot78 to i32
  %conv80 = sext i32 %lnot.ext79 to i64
  %expval81 = call i64 @llvm.expect.i64(i64 %conv80, i64 1)
  %tobool82 = icmp ne i64 %expval81, 0
  br i1 %tobool82, label %if.then83, label %if.else84

if.then83:                                        ; preds = %do.end71
  call void @xprt_free_slot(%struct.rpc_xprt* %6, %struct.rpc_rqst* %0)
  br label %cleanup.cont

if.else84:                                        ; preds = %do.end71
  call void @xprt_free_bc_request(%struct.rpc_rqst* %0)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.else84, %if.then83, %if.end14, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_has_timer(%struct.rpc_xprt* %xprt) #2 {
entry:
  %idle_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 28
  %0 = load i64, i64* %idle_timeout, align 8, !tbaa !336
  %cmp = icmp ne i64 %0, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare i32 @mod_timer(%struct.timer_list*, i64) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @bc_prealloc(%struct.rpc_rqst* %req) #2 {
entry:
  %rq_bc_pa_state = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 27
  %0 = load volatile i64, i64* %rq_bc_pa_state, align 8, !tbaa !88
  %and.i = and i64 2, %0
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  ret i32 %conv.i
}

; Function Attrs: nounwind uwtable
define internal void @xprt_free_slot(%struct.rpc_xprt* %xprt, %struct.rpc_rqst* %req) #0 {
entry:
  %reserve_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 30
  call void @spin_lock.20(%struct.spinlock* %reserve_lock)
  %call = call zeroext i1 @xprt_dynamic_free_slot(%struct.rpc_xprt* %xprt, %struct.rpc_rqst* %req)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.rpc_rqst* %req to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 400, i32 8, i1 false)
  %rq_list = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 11
  %free = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 14
  call void @list_add.6(%struct.list_head* %rq_list, %struct.list_head* %free)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @xprt_wake_up_backlog(%struct.rpc_xprt* %xprt)
  %reserve_lock1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 30
  call void @spin_unlock.25(%struct.spinlock* %reserve_lock1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @xprt_dynamic_free_slot(%struct.rpc_xprt* %xprt, %struct.rpc_rqst* %req) #0 {
entry:
  %num_reqs = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 17
  %min_reqs = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 16
  %0 = load i32, i32* %min_reqs, align 4, !tbaa !269
  %call = call i32 @atomic_add_unless.30(%struct.atomic_t* %num_reqs, i32 -1, i32 %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %return

if.then:                                          ; preds = %entry
  %1 = bitcast %struct.rpc_rqst* %req to i8*
  call void @kfree(i8* %1)
  br label %return

return:                                           ; preds = %if.then, %entry
  %retval.0 = phi i1 [ true, %if.then ], [ false, %entry ]
  ret i1 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @xprt_wake_up_backlog(%struct.rpc_xprt* %xprt) #0 {
entry:
  %backlog = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 13
  %call = call %struct.rpc_task* @rpc_wake_up_next(%struct.rpc_wait_queue* %backlog)
  %cmp = icmp eq %struct.rpc_task* %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 9, i64* %state) #7, !srcloc !300
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.rpc_xprt* @xprt_create_transport(%struct.xprt_create* %args) #0 {
entry:
  %.compoundliteral = alloca %struct.pgprot, align 8
  call void @spin_lock.20(%struct.spinlock* @xprt_list_lock)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @xprt_list, i32 0, i32 0), %entry ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !28
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr6 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr6 to %struct.xprt_class*
  %list = getelementptr inbounds %struct.xprt_class, %struct.xprt_class* %2, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, @xprt_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ident = getelementptr inbounds %struct.xprt_class, %struct.xprt_class* %2, i32 0, i32 1
  %3 = load i32, i32* %ident, align 8, !tbaa !308
  %ident1 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 0
  %4 = load i32, i32* %ident1, align 8, !tbaa !247
  %cmp2 = icmp eq i32 %3, %4
  br i1 %cmp2, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @spin_unlock.25(%struct.spinlock* @xprt_list_lock)
  %setup = getelementptr inbounds %struct.xprt_class, %struct.xprt_class* %2, i32 0, i32 2
  %5 = load %struct.rpc_xprt* (%struct.xprt_create*)*, %struct.rpc_xprt* (%struct.xprt_create*)** %setup, align 8, !tbaa !338
  %call9 = call %struct.rpc_xprt* %5(%struct.xprt_create* %args)
  %6 = bitcast %struct.rpc_xprt* %call9 to i8*
  %call10 = call i64 @IS_ERR.21(i8* %6)
  %tobool = icmp ne i64 %call10, 0
  br i1 %tobool, label %do.body, label %if.end19

for.inc:                                          ; preds = %for.body
  %list4 = getelementptr inbounds %struct.xprt_class, %struct.xprt_class* %2, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list4, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @spin_unlock.25(%struct.spinlock* @xprt_list_lock)
  %7 = call i32 (i8*, ...) @printk(i8* null)
  %call8 = call i8* @ERR_PTR.29(i64 -5)
  %8 = bitcast i8* %call8 to %struct.rpc_xprt*
  br label %cleanup

do.body:                                          ; preds = %if.then
  %9 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %9, 1
  %tobool12 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool12, true
  %lnot13 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot13 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool14 = icmp ne i64 %expval, 0
  br i1 %tobool14, label %if.then15, label %cleanup

if.then15:                                        ; preds = %do.body
  %10 = bitcast %struct.rpc_xprt* %call9 to i8*
  %call16 = call i64 @PTR_ERR.22(i8* %10)
  %11 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end19:                                         ; preds = %if.then
  %flags = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 7
  %12 = load i32, i32* %flags, align 8, !tbaa !255
  %and20 = and i32 %12, 2
  %tobool21 = icmp ne i32 %and20, 0
  br i1 %tobool21, label %if.then22, label %do.body25

if.then22:                                        ; preds = %if.end19
  %idle_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call9, i32 0, i32 28
  store i64 0, i64* %idle_timeout, align 8, !tbaa !336
  br label %do.body25

do.body25:                                        ; preds = %if.then22, %if.end19
  %task_cleanup = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call9, i32 0, i32 25
  call void @__init_work(%struct.work_struct* %task_cleanup, i32 0)
  %task_cleanup26 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call9, i32 0, i32 25
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %task_cleanup26, i32 0, i32 0
  %counter = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !339
  %13 = bitcast %struct.pgprot* %data to i8*
  %14 = bitcast %struct.pgprot* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 8, i32 8, i1 false), !tbaa.struct !340
  %task_cleanup27 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call9, i32 0, i32 25
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %task_cleanup27, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.23.117, i32 0, i32 0), %struct.lock_class_key* @xprt_create_transport.__key, i32 0)
  %task_cleanup28 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call9, i32 0, i32 25
  %entry29 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %task_cleanup28, i32 0, i32 1
  call void @INIT_LIST_HEAD.11(%struct.list_head* %entry29)
  %task_cleanup31 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call9, i32 0, i32 25
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %task_cleanup31, i32 0, i32 2
  store void (%struct.work_struct*)* @xprt_autoclose, void (%struct.work_struct*)** %func, align 8, !tbaa !341
  %call38 = call i32 @xprt_has_timer(%struct.rpc_xprt* %call9)
  %tobool39 = icmp ne i32 %call38, 0
  %timer = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call9, i32 0, i32 26
  br i1 %tobool39, label %do.body42, label %do.body50

do.body42:                                        ; preds = %do.body25
  call void @init_timer_key(%struct.timer_list* %timer, i32 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.25.118, i32 0, i32 0), %struct.lock_class_key* @xprt_create_transport.__key.24)
  %timer45 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call9, i32 0, i32 26
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer45, i32 0, i32 3
  store void (i64)* @xprt_init_autodisconnect, void (i64)** %function, align 8, !tbaa !342
  %15 = ptrtoint %struct.rpc_xprt* %call9 to i64
  %timer46 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call9, i32 0, i32 26
  %data47 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer46, i32 0, i32 4
  store i64 %15, i64* %data47, align 8, !tbaa !343
  br label %if.end54

do.body50:                                        ; preds = %do.body25
  call void @init_timer_key(%struct.timer_list* %timer, i32 0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.27.119, i32 0, i32 0), %struct.lock_class_key* @xprt_create_transport.__key.26)
  br label %if.end54

if.end54:                                         ; preds = %do.body50, %do.body42
  %servername = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 5
  %16 = load i8*, i8** %servername, align 8, !tbaa !253
  %call55 = call i64 @strlen(i8* %16)
  %cmp56 = icmp ugt i64 %call55, 256
  br i1 %cmp56, label %if.then58, label %if.end60

if.then58:                                        ; preds = %if.end54
  call void @xprt_destroy(%struct.rpc_xprt* %call9)
  %call59 = call i8* @ERR_PTR.29(i64 -22)
  %17 = bitcast i8* %call59 to %struct.rpc_xprt*
  br label %cleanup

if.end60:                                         ; preds = %if.end54
  %servername61 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 5
  %18 = load i8*, i8** %servername61, align 8, !tbaa !253
  %call62 = call i8* @kstrdup(i8* %18, i32 208)
  %servername63 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call9, i32 0, i32 41
  store i8* %call62, i8** %servername63, align 8, !tbaa !216
  %servername64 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call9, i32 0, i32 41
  %19 = load i8*, i8** %servername64, align 8, !tbaa !216
  %cmp65 = icmp eq i8* %19, null
  br i1 %cmp65, label %if.then67, label %do.body70

if.then67:                                        ; preds = %if.end60
  call void @xprt_destroy(%struct.rpc_xprt* %call9)
  %call68 = call i8* @ERR_PTR.29(i64 -12)
  %20 = bitcast i8* %call68 to %struct.rpc_xprt*
  br label %cleanup

do.body70:                                        ; preds = %if.end60
  %21 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and71 = and i32 %21, 1
  %tobool72 = icmp ne i32 %and71, 0
  %lnot73 = xor i1 %tobool72, true
  %lnot75 = xor i1 %lnot73, true
  %lnot.ext76 = zext i1 %lnot75 to i32
  %conv77 = sext i32 %lnot.ext76 to i64
  %expval78 = call i64 @llvm.expect.i64(i64 %conv77, i64 0)
  %tobool79 = icmp ne i64 %expval78, 0
  br i1 %tobool79, label %if.then80, label %cleanup

if.then80:                                        ; preds = %do.body70
  %22 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then80, %do.body70, %if.then67, %if.then58, %if.then15, %do.body, %for.end
  %retval.0 = phi %struct.rpc_xprt* [ %17, %if.then58 ], [ %20, %if.then67 ], [ %8, %for.end ], [ %call9, %do.body70 ], [ %call9, %if.then80 ], [ %call9, %do.body ], [ %call9, %if.then15 ]
  ret %struct.rpc_xprt* %retval.0
}

declare void @__init_work(%struct.work_struct*, i32) #4

declare void @lockdep_init_map(%struct.lockdep_map*, i8*, %struct.lock_class_key*, i32) #4

; Function Attrs: nounwind uwtable
define internal void @xprt_autoclose(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -1528
  %1 = bitcast i8* %add.ptr to %struct.rpc_xprt*
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 1
  %2 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %close = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %2, i32 0, i32 13
  %3 = load void (%struct.rpc_xprt*)*, void (%struct.rpc_xprt*)** %close, align 8, !tbaa !311
  call void %3(%struct.rpc_xprt* %1)
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 3, i64* %state) #7, !srcloc !300
  call void @xprt_release_write(%struct.rpc_xprt* %1, %struct.rpc_task* null)
  ret void
}

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) #4

; Function Attrs: nounwind uwtable
define internal void @xprt_init_autodisconnect(i64 %data) #0 {
entry:
  %0 = inttoptr i64 %data to %struct.rpc_xprt*
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 29
  call void @spin_lock.20(%struct.spinlock* %transport_lock)
  %recv = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 38
  %call = call i32 @list_empty.3(%struct.list_head* %recv)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %out_abort

if.end:                                           ; preds = %entry
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 18
  %call1 = call i32 @test_and_set_bit(i32 0, i64* %state)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %out_abort, label %if.end4

if.end4:                                          ; preds = %if.end
  %transport_lock5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 29
  call void @spin_unlock.25(%struct.spinlock* %transport_lock5)
  %state6 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %state6, i32 8, i64* %state6) #7, !srcloc !278
  %1 = load %struct.workqueue_struct*, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !28
  %task_cleanup = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 25
  call void @queue_work(%struct.workqueue_struct* %1, %struct.work_struct* %task_cleanup)
  br label %cleanup.cont

out_abort:                                        ; preds = %if.end, %entry
  %transport_lock8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 29
  call void @spin_unlock.25(%struct.spinlock* %transport_lock8)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %out_abort, %if.end4
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xprt_destroy(%struct.rpc_xprt* %xprt) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %timer = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 26
  %call3 = call i32 @del_timer_sync(%struct.timer_list* %timer)
  %binding = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 10
  call void @rpc_destroy_wait_queue(%struct.rpc_wait_queue* %binding)
  %pending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 12
  call void @rpc_destroy_wait_queue(%struct.rpc_wait_queue* %pending)
  %sending = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 11
  call void @rpc_destroy_wait_queue(%struct.rpc_wait_queue* %sending)
  %backlog = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 13
  call void @rpc_destroy_wait_queue(%struct.rpc_wait_queue* %backlog)
  %task_cleanup = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 25
  %call4 = call zeroext i1 @cancel_work_sync(%struct.work_struct* %task_cleanup)
  %servername = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 41
  %2 = load i8*, i8** %servername, align 8, !tbaa !216
  call void @kfree(i8* %2)
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 1
  %3 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %destroy = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %3, i32 0, i32 14
  %4 = load void (%struct.rpc_xprt*)*, void (%struct.rpc_xprt*)** %destroy, align 8, !tbaa !344
  call void %4(%struct.rpc_xprt* %xprt)
  ret void
}

declare zeroext i1 @cancel_work_sync(%struct.work_struct*) #4

; Function Attrs: nounwind uwtable
define void @xprt_put(%struct.rpc_xprt* %xprt) #0 {
entry:
  %count = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 0
  %call = call i32 @atomic_dec_and_test.4(%struct.atomic_t* %count)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @xprt_destroy(%struct.rpc_xprt* %xprt)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.rpc_xprt* @xprt_get(%struct.rpc_xprt* %xprt) #0 {
entry:
  %count = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 0
  %call = call i32 @atomic_add_unless.30(%struct.atomic_t* %count, i32 1, i32 0)
  %tobool = icmp ne i32 %call, 0
  %xprt. = select i1 %tobool, %struct.rpc_xprt* %xprt, %struct.rpc_xprt* null
  ret %struct.rpc_xprt* %xprt.
}

; Function Attrs: nounwind uwtable
define i32 @csum_partial_copy_to_xdr(%struct.xdr_buf* %xdr, %struct.sk_buff* %skb) #0 {
entry:
  %desc = alloca %struct.xdr_skb_reader, align 8
  %skb1 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 0
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb1, align 8, !tbaa !345
  %offset = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  store i32 8, i32* %offset, align 8, !tbaa !347
  %len = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 8
  %0 = load i32, i32* %len, align 8, !tbaa !348
  %offset2 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  %1 = load i32, i32* %offset2, align 8, !tbaa !347
  %sub = sub i32 %0, %1
  %conv = zext i32 %sub to i64
  %count = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  store i64 %conv, i64* %count, align 8, !tbaa !350
  %call = call i32 @skb_csum_unnecessary(%struct.sk_buff* %skb)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %no_checksum, label %if.end

if.end:                                           ; preds = %entry
  %data = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 40
  %2 = load i8*, i8** %data, align 8, !tbaa !351
  %offset3 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  %3 = load i32, i32* %offset3, align 8, !tbaa !347
  %4 = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 12
  %csum = bitcast %struct.atomic_t* %4 to i32*
  %5 = load i32, i32* %csum, align 4, !tbaa !166
  %call4 = call i32 @csum_partial(i8* %2, i32 %3, i32 %5)
  %csum5 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 3
  store i32 %call4, i32* %csum5, align 8, !tbaa !352
  %call6 = call i64 @xdr_partial_copy_from_skb(%struct.xdr_buf* %xdr, i32 0, %struct.xdr_skb_reader* %desc, i64 (%struct.xdr_skb_reader*, i8*, i64)* @xdr_skb_read_and_csum_bits)
  %cmp = icmp slt i64 %call6, 0
  br i1 %cmp, label %cleanup, label %if.end9

if.end9:                                          ; preds = %if.end
  %offset10 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  %6 = load i32, i32* %offset10, align 8, !tbaa !347
  %len11 = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 8
  %7 = load i32, i32* %len11, align 8, !tbaa !348
  %cmp12 = icmp ne i32 %6, %7
  br i1 %cmp12, label %if.then14, label %if.end24

if.then14:                                        ; preds = %if.end9
  %offset15 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  %8 = load i32, i32* %offset15, align 8, !tbaa !347
  %len16 = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 8
  %9 = load i32, i32* %len16, align 8, !tbaa !348
  %offset17 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  %10 = load i32, i32* %offset17, align 8, !tbaa !347
  %sub18 = sub i32 %9, %10
  %call19 = call i32 @skb_checksum(%struct.sk_buff* %skb, i32 %8, i32 %sub18, i32 0)
  %csum20 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 3
  %11 = load i32, i32* %csum20, align 8, !tbaa !352
  %offset21 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  %12 = load i32, i32* %offset21, align 8, !tbaa !347
  %call22 = call i32 @csum_block_add(i32 %11, i32 %call19, i32 %12)
  %csum23 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 3
  store i32 %call22, i32* %csum23, align 8, !tbaa !352
  br label %if.end24

if.end24:                                         ; preds = %if.then14, %if.end9
  %count25 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %13 = load i64, i64* %count25, align 8, !tbaa !350
  %tobool26 = icmp ne i64 %13, 0
  br i1 %tobool26, label %cleanup, label %if.end28

if.end28:                                         ; preds = %if.end24
  %csum29 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 3
  %14 = load i32, i32* %csum29, align 8, !tbaa !352
  %call30 = call zeroext i16 @csum_fold(i32 %14)
  %tobool31 = icmp ne i16 %call30, 0
  br i1 %tobool31, label %cleanup, label %if.end33

if.end33:                                         ; preds = %if.end28
  %ip_summed = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 14
  %bf.load = load i16, i16* %ip_summed, align 4
  %bf.lshr = lshr i16 %bf.load, 2
  %bf.clear = and i16 %bf.lshr, 3
  %bf.cast = trunc i16 %bf.clear to i8
  %conv34 = zext i8 %bf.cast to i32
  %cmp35 = icmp eq i32 %conv34, 2
  %lnot = xor i1 %cmp35, true
  %lnot37 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot37 to i32
  %conv38 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv38, i64 0)
  %tobool39 = icmp ne i64 %expval, 0
  br i1 %tobool39, label %if.then40, label %cleanup

if.then40:                                        ; preds = %if.end33
  %dev = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 4
  %15 = load %struct.net_device*, %struct.net_device** %dev, align 8, !tbaa !353
  call void @netdev_rx_csum_fault(%struct.net_device* %15)
  br label %cleanup

no_checksum:                                      ; preds = %entry
  %call42 = call i64 @xdr_partial_copy_from_skb(%struct.xdr_buf* %xdr, i32 0, %struct.xdr_skb_reader* %desc, i64 (%struct.xdr_skb_reader*, i8*, i64)* @xdr_skb_read_bits)
  %cmp43 = icmp slt i64 %call42, 0
  br i1 %cmp43, label %cleanup, label %if.end46

if.end46:                                         ; preds = %no_checksum
  %count47 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %16 = load i64, i64* %count47, align 8, !tbaa !350
  %tobool48 = icmp ne i64 %16, 0
  %. = select i1 %tobool48, i32 -1, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end46, %no_checksum, %if.then40, %if.end33, %if.end28, %if.end24, %if.end
  %retval.0 = phi i32 [ -1, %if.end ], [ -1, %if.end24 ], [ -1, %if.end28 ], [ 0, %if.then40 ], [ 0, %if.end33 ], [ -1, %no_checksum ], [ %., %if.end46 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @skb_csum_unnecessary(%struct.sk_buff* %skb) #2 {
entry:
  %ip_summed = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 14
  %bf.load = load i16, i16* %ip_summed, align 4
  %bf.lshr = lshr i16 %bf.load, 2
  %bf.clear = and i16 %bf.lshr, 3
  %bf.cast = trunc i16 %bf.clear to i8
  %conv = zext i8 %bf.cast to i32
  %and = and i32 %conv, 1
  ret i32 %and
}

declare i32 @csum_partial(i8*, i32, i32) #4

; Function Attrs: nounwind uwtable
define internal i64 @xdr_skb_read_and_csum_bits(%struct.xdr_skb_reader* %desc, i8* %to, i64 %len) #0 {
entry:
  %count = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %0 = load i64, i64* %count, align 8, !tbaa !350
  %cmp = icmp ugt i64 %len, %0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %count1 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %1 = load i64, i64* %count1, align 8, !tbaa !350
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %len.addr.0 = phi i64 [ %1, %if.then ], [ %len, %entry ]
  %offset = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  %2 = load i32, i32* %offset, align 8, !tbaa !347
  %skb = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 0
  %3 = load %struct.sk_buff*, %struct.sk_buff** %skb, align 8, !tbaa !345
  %conv = trunc i64 %len.addr.0 to i32
  %call = call i32 @skb_copy_and_csum_bits(%struct.sk_buff* %3, i32 %2, i8* %to, i32 %conv, i32 0)
  %csum = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 3
  %4 = load i32, i32* %csum, align 8, !tbaa !352
  %call2 = call i32 @csum_block_add(i32 %4, i32 %call, i32 %2)
  %csum3 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 3
  store i32 %call2, i32* %csum3, align 8, !tbaa !352
  %count4 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %5 = load i64, i64* %count4, align 8, !tbaa !350
  %sub = sub i64 %5, %len.addr.0
  store i64 %sub, i64* %count4, align 8, !tbaa !350
  %offset5 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  %6 = load i32, i32* %offset5, align 8, !tbaa !347
  %conv6 = zext i32 %6 to i64
  %add = add i64 %conv6, %len.addr.0
  %conv7 = trunc i64 %add to i32
  store i32 %conv7, i32* %offset5, align 8, !tbaa !347
  ret i64 %len.addr.0
}

; Function Attrs: nounwind uwtable
define i64 @xdr_partial_copy_from_skb(%struct.xdr_buf* %xdr, i32 %base, %struct.xdr_skb_reader* %desc, i64 (%struct.xdr_skb_reader*, i8*, i64)* %copy_actor) #0 {
entry:
  %pages = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 2
  %0 = load %struct.page**, %struct.page*** %pages, align 8, !tbaa !354
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 4
  %1 = load i32, i32* %page_len, align 4, !tbaa !150
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %2 = load i64, i64* %iov_len, align 8, !tbaa !149
  %conv = trunc i64 %2 to i32
  %cmp = icmp ult i32 %base, %conv
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %sub = sub i32 %conv, %base
  %head2 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head2, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx3, i32 0, i32 0
  %3 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %idx.ext = zext i32 %base to i64
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 %idx.ext
  %conv4 = zext i32 %sub to i64
  %call = call i64 %copy_actor(%struct.xdr_skb_reader* %desc, i8* %add.ptr, i64 %conv4)
  %add = add i64 0, %call
  %conv5 = zext i32 %sub to i64
  %cmp6 = icmp ne i64 %call, %conv5
  br i1 %cmp6, label %cleanup135, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %count = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %4 = load i64, i64* %count, align 8, !tbaa !350
  %tobool = icmp ne i64 %4, 0
  br i1 %tobool, label %if.end10, label %cleanup135

if.else:                                          ; preds = %entry
  %sub9 = sub i32 %base, %conv
  br label %if.end10

if.end10:                                         ; preds = %if.else, %lor.lhs.false
  %len.0 = phi i32 [ %conv, %if.else ], [ %sub, %lor.lhs.false ]
  %copied.0 = phi i64 [ 0, %if.else ], [ %add, %lor.lhs.false ]
  %base.addr.0 = phi i32 [ %sub9, %if.else ], [ 0, %lor.lhs.false ]
  %cmp11 = icmp eq i32 %1, 0
  %lnot = xor i1 %cmp11, true
  %lnot13 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot13 to i32
  %conv14 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool15 = icmp ne i64 %expval, 0
  br i1 %tobool15, label %copy_tail, label %if.end17

if.end17:                                         ; preds = %if.end10
  %cmp18 = icmp uge i32 %base.addr.0, %1
  %lnot20 = xor i1 %cmp18, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %expval25 = call i64 @llvm.expect.i64(i64 %conv24, i64 0)
  %tobool26 = icmp ne i64 %expval25, 0
  br i1 %tobool26, label %if.then27, label %if.end29

if.then27:                                        ; preds = %if.end17
  %sub28 = sub i32 %base.addr.0, %1
  br label %copy_tail

if.end29:                                         ; preds = %if.end17
  %tobool30 = icmp ne i32 %base.addr.0, 0
  br i1 %tobool30, label %if.then33, label %lor.lhs.false31

lor.lhs.false31:                                  ; preds = %if.end29
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 3
  %5 = load i32, i32* %page_base, align 8, !tbaa !355
  %tobool32 = icmp ne i32 %5, 0
  br i1 %tobool32, label %if.then33, label %if.end41

if.then33:                                        ; preds = %lor.lhs.false31, %if.end29
  %sub34 = sub i32 %1, %base.addr.0
  %page_base35 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 3
  %6 = load i32, i32* %page_base35, align 8, !tbaa !355
  %add36 = add i32 %base.addr.0, %6
  %shr = lshr i32 %add36, 12
  %idx.ext37 = zext i32 %shr to i64
  %add.ptr38 = getelementptr inbounds %struct.page*, %struct.page** %0, i64 %idx.ext37
  %conv39 = zext i32 %add36 to i64
  %and = and i64 %conv39, 4095
  %conv40 = trunc i64 %and to i32
  br label %if.end41

if.end41:                                         ; preds = %if.then33, %lor.lhs.false31
  %pglen.0 = phi i32 [ %sub34, %if.then33 ], [ %1, %lor.lhs.false31 ]
  %ppage.0 = phi %struct.page** [ %add.ptr38, %if.then33 ], [ %0, %lor.lhs.false31 ]
  %base.addr.1 = phi i32 [ %conv40, %if.then33 ], [ %base.addr.0, %lor.lhs.false31 ]
  br label %do.body

do.body:                                          ; preds = %do.cond114, %if.end41
  %pglen.1 = phi i32 [ %pglen.0, %if.end41 ], [ %sub115, %do.cond114 ]
  %len.1 = phi i32 [ %len.0, %if.end41 ], [ %len.5, %do.cond114 ]
  %ppage.1 = phi %struct.page** [ %ppage.0, %if.end41 ], [ %ppage.2, %do.cond114 ]
  %copied.1 = phi i64 [ %copied.0, %if.end41 ], [ %copied.3, %do.cond114 ]
  %base.addr.2 = phi i32 [ %base.addr.1, %if.end41 ], [ %base.addr.4, %do.cond114 ]
  %7 = load %struct.page*, %struct.page** %ppage.1, align 8, !tbaa !28
  %cmp42 = icmp eq %struct.page* %7, null
  %lnot44 = xor i1 %cmp42, true
  %lnot46 = xor i1 %lnot44, true
  %lnot.ext47 = zext i1 %lnot46 to i32
  %conv48 = sext i32 %lnot.ext47 to i64
  %expval49 = call i64 @llvm.expect.i64(i64 %conv48, i64 0)
  %tobool50 = icmp ne i64 %expval49, 0
  br i1 %tobool50, label %if.then51, label %if.end68

if.then51:                                        ; preds = %do.body
  %call52 = call %struct.page* @alloc_pages(i32 32, i32 0)
  store %struct.page* %call52, %struct.page** %ppage.1, align 8, !tbaa !28
  %8 = load %struct.page*, %struct.page** %ppage.1, align 8, !tbaa !28
  %cmp53 = icmp eq %struct.page* %8, null
  %lnot55 = xor i1 %cmp53, true
  %lnot57 = xor i1 %lnot55, true
  %lnot.ext58 = zext i1 %lnot57 to i32
  %conv59 = sext i32 %lnot.ext58 to i64
  %expval60 = call i64 @llvm.expect.i64(i64 %conv59, i64 0)
  %tobool61 = icmp ne i64 %expval60, 0
  br i1 %tobool61, label %if.then62, label %if.end68

if.then62:                                        ; preds = %if.then51
  %cmp63 = icmp eq i64 %copied.1, 0
  %.copied.1 = select i1 %cmp63, i64 -12, i64 %copied.1
  br label %NodeBlock

if.end68:                                         ; preds = %if.then51, %do.body
  %9 = load %struct.page*, %struct.page** %ppage.1, align 8, !tbaa !28
  %call69 = call i8* @kmap_atomic(%struct.page* %9)
  %tobool70 = icmp ne i32 %base.addr.2, 0
  br i1 %tobool70, label %if.then71, label %if.else81

if.then71:                                        ; preds = %if.end68
  %sub72 = sub i32 4096, %base.addr.2
  %cmp73 = icmp ult i32 %pglen.1, %sub72
  %pglen.1.sub72 = select i1 %cmp73, i32 %pglen.1, i32 %sub72
  %idx.ext77 = zext i32 %base.addr.2 to i64
  %add.ptr78 = getelementptr inbounds i8, i8* %call69, i64 %idx.ext77
  br label %do.body91

if.else81:                                        ; preds = %if.end68
  %cmp82 = icmp ult i32 %pglen.1, 4096
  %pglen.1. = select i1 %cmp82, i32 %pglen.1, i32 4096
  br label %do.body91

do.body91:                                        ; preds = %if.else81, %if.then71
  %pglen.1.sub72.sink = phi i32 [ %pglen.1.sub72, %if.then71 ], [ %pglen.1., %if.else81 ]
  %add.ptr78.sink = phi i8* [ %add.ptr78, %if.then71 ], [ %call69, %if.else81 ]
  %base.addr.3 = phi i32 [ 0, %if.then71 ], [ %base.addr.2, %if.else81 ]
  %conv79 = zext i32 %pglen.1.sub72.sink to i64
  %call80 = call i64 %copy_actor(%struct.xdr_skb_reader* %desc, i8* %add.ptr78.sink, i64 %conv79)
  %tobool92 = trunc i8 0 to i1
  br i1 %tobool92, label %if.then93, label %do.body95

if.then93:                                        ; preds = %do.body91
  call void @__compiletime_assert_130()
  br label %do.body95

do.body95:                                        ; preds = %if.then93, %do.body91
  call void @__kunmap_atomic()
  %add105 = add i64 %copied.1, %call80
  %conv106 = zext i32 %pglen.1.sub72.sink to i64
  %cmp107 = icmp ne i64 %call80, %conv106
  br i1 %cmp107, label %NodeBlock, label %lor.lhs.false109

lor.lhs.false109:                                 ; preds = %do.body95
  %count110 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %10 = load i64, i64* %count110, align 8, !tbaa !350
  %tobool111 = icmp ne i64 %10, 0
  %incdec.ptr = getelementptr inbounds %struct.page*, %struct.page** %ppage.1, i32 1
  %incdec.ptr.ppage.1 = select i1 %tobool111, %struct.page** %incdec.ptr, %struct.page** %ppage.1
  %. = select i1 %tobool111, i32 0, i32 2
  br label %NodeBlock

NodeBlock:                                        ; preds = %lor.lhs.false109, %do.body95, %if.then62
  %len.5 = phi i32 [ %len.1, %if.then62 ], [ %pglen.1.sub72.sink, %do.body95 ], [ %pglen.1.sub72.sink, %lor.lhs.false109 ]
  %ppage.2 = phi %struct.page** [ %ppage.1, %if.then62 ], [ %ppage.1, %do.body95 ], [ %incdec.ptr.ppage.1, %lor.lhs.false109 ]
  %copied.3 = phi i64 [ %.copied.1, %if.then62 ], [ %add105, %do.body95 ], [ %add105, %lor.lhs.false109 ]
  %base.addr.4 = phi i32 [ %base.addr.2, %if.then62 ], [ %base.addr.3, %do.body95 ], [ %base.addr.3, %lor.lhs.false109 ]
  %cleanup.dest.slot.0 = phi i32 [ 2, %if.then62 ], [ 2, %do.body95 ], [ %., %lor.lhs.false109 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  ret i64 %copied.3

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %do.cond114, label %cleanup135

do.cond114:                                       ; preds = %LeafBlock
  %sub115 = sub i32 %pglen.1, %len.5
  %cmp116 = icmp ne i32 %sub115, 0
  br i1 %cmp116, label %do.body, label %copy_tail

copy_tail:                                        ; preds = %do.cond114, %if.then27, %if.end10
  %copied.4 = phi i64 [ %copied.0, %if.then27 ], [ %copied.0, %if.end10 ], [ %copied.3, %do.cond114 ]
  %base.addr.5 = phi i32 [ %sub28, %if.then27 ], [ %base.addr.0, %if.end10 ], [ %base.addr.4, %do.cond114 ]
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 1
  %arrayidx119 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_len120 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx119, i32 0, i32 1
  %11 = load i64, i64* %iov_len120, align 8, !tbaa !149
  %conv121 = trunc i64 %11 to i32
  %cmp122 = icmp ult i32 %base.addr.5, %conv121
  br i1 %cmp122, label %if.then124, label %cleanup135

if.then124:                                       ; preds = %copy_tail
  %tail125 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 1
  %arrayidx126 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail125, i64 0, i64 0
  %iov_base127 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx126, i32 0, i32 0
  %12 = load i8*, i8** %iov_base127, align 8, !tbaa !147
  %idx.ext128 = zext i32 %base.addr.5 to i64
  %add.ptr129 = getelementptr inbounds i8, i8* %12, i64 %idx.ext128
  %sub130 = sub i32 %conv121, %base.addr.5
  %conv131 = zext i32 %sub130 to i64
  %call132 = call i64 %copy_actor(%struct.xdr_skb_reader* %desc, i8* %add.ptr129, i64 %conv131)
  %add133 = add i64 %copied.4, %call132
  br label %cleanup135

cleanup135:                                       ; preds = %if.then124, %copy_tail, %LeafBlock, %lor.lhs.false, %if.then
  %retval.0 = phi i64 [ %add, %lor.lhs.false ], [ %add, %if.then ], [ %add133, %if.then124 ], [ %copied.4, %copy_tail ], [ undef, %LeafBlock ]
  ret i64 %retval.0
}

declare i32 @skb_checksum(%struct.sk_buff*, i32, i32, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @csum_block_add(i32 %csum, i32 %csum2, i32 %offset) #2 {
entry:
  %and = and i32 %offset, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %and1 = and i32 %csum2, 16711935
  %shl = shl i32 %and1, 8
  %shr = lshr i32 %csum2, 8
  %and2 = and i32 %shr, 16711935
  %add = add i32 %shl, %and2
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sum.0 = phi i32 [ %add, %if.then ], [ %csum2, %entry ]
  %call = call i32 @csum_add(i32 %csum, i32 %sum.0)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @csum_fold(i32 %sum) #2 {
entry:
  %shl = shl i32 %sum, 16
  %and = and i32 %sum, -65536
  %0 = call i32 asm "  addl $1,$0\0A  adcl $$0xffff,$0", "=r,r,0,~{dirflag},~{fpsr},~{flags}"(i32 %shl, i32 %and) #3, !srcloc !356
  %neg = xor i32 %0, -1
  %shr = lshr i32 %neg, 16
  %conv = trunc i32 %shr to i16
  ret i16 %conv
}

declare void @netdev_rx_csum_fault(%struct.net_device*) #4

; Function Attrs: nounwind uwtable
define i64 @xdr_skb_read_bits(%struct.xdr_skb_reader* %desc, i8* %to, i64 %len) #0 {
entry:
  %count = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %0 = load i64, i64* %count, align 8, !tbaa !350
  %cmp = icmp ugt i64 %len, %0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %count1 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %1 = load i64, i64* %count1, align 8, !tbaa !350
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %len.addr.0 = phi i64 [ %1, %if.then ], [ %len, %entry ]
  %skb = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 0
  %2 = load %struct.sk_buff*, %struct.sk_buff** %skb, align 8, !tbaa !345
  %offset = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  %3 = load i32, i32* %offset, align 8, !tbaa !347
  %conv = trunc i64 %len.addr.0 to i32
  %call = call i32 @skb_copy_bits(%struct.sk_buff* %2, i32 %3, i8* %to, i32 %conv)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv3 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %return, label %if.end6

if.end6:                                          ; preds = %if.end
  %count7 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %4 = load i64, i64* %count7, align 8, !tbaa !350
  %sub = sub i64 %4, %len.addr.0
  store i64 %sub, i64* %count7, align 8, !tbaa !350
  %offset8 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  %5 = load i32, i32* %offset8, align 8, !tbaa !347
  %conv9 = zext i32 %5 to i64
  %add = add i64 %conv9, %len.addr.0
  %conv10 = trunc i64 %add to i32
  store i32 %conv10, i32* %offset8, align 8, !tbaa !347
  br label %return

return:                                           ; preds = %if.end6, %if.end
  %retval.0 = phi i64 [ %len.addr.0, %if.end6 ], [ 0, %if.end ]
  ret i64 %retval.0
}

declare i32 @skb_copy_bits(%struct.sk_buff*, i32, i8*, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @csum_add(i32 %csum, i32 %addend) #2 {
entry:
  %add = add i32 %csum, %addend
  %cmp = icmp ult i32 %add, %addend
  %conv = zext i1 %cmp to i32
  %add1 = add i32 %add, %conv
  ret i32 %add1
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.page* @alloc_pages(i32 %gfp_mask, i32 %order) #2 {
entry:
  %call = call %struct.page* @alloc_pages_current(i32 %gfp_mask, i32 %order)
  ret %struct.page* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kmap_atomic(%struct.page* %page) #2 {
entry:
  call void @pagefault_disable()
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %page to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %0 = inttoptr i64 %add.i to i8*
  ret i8* %0
}

declare void @__compiletime_assert_130() #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @__kunmap_atomic() #2 {
entry:
  call void @pagefault_enable()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pagefault_enable() #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !357
  %call = call %struct.thread_info* @current_thread_info.127()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !358
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.127() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !359
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pagefault_disable() #2 {
entry:
  %call = call %struct.thread_info* @current_thread_info.127()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !360
  ret void
}

declare %struct.page* @alloc_pages_current(i32, i32) #4

declare i32 @skb_copy_and_csum_bits(%struct.sk_buff*, i32, i8*, i32, i32) #4

; Function Attrs: nounwind uwtable
define internal i32 @param_set_slot_table_size(i8* %val, %struct.kernel_param* %kp) #0 {
entry:
  %call = call i32 @param_set_uint_minmax(i8* %val, %struct.kernel_param* %kp, i32 2, i32 65536)
  ret i32 %call
}

declare i32 @param_get_uint(i8*, %struct.kernel_param*) #4

; Function Attrs: nounwind uwtable
define internal i32 @param_set_uint_minmax(i8* %val, %struct.kernel_param* %kp, i32 %min, i32 %max) #0 {
entry:
  %num = alloca i64, align 8
  %tobool = icmp ne i8* %val, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %val, i32 0, i64* %num)
  %cmp = icmp eq i32 %call, -22
  br i1 %cmp, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %0 = load i64, i64* %num, align 8, !tbaa !88
  %conv = zext i32 %min to i64
  %cmp1 = icmp ult i64 %0, %conv
  br i1 %cmp1, label %cleanup, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %1 = load i64, i64* %num, align 8, !tbaa !88
  %conv4 = zext i32 %max to i64
  %cmp5 = icmp ugt i64 %1, %conv4
  br i1 %cmp5, label %cleanup, label %if.end8

if.end8:                                          ; preds = %lor.lhs.false3
  %2 = load i64, i64* %num, align 8, !tbaa !88
  %conv9 = trunc i64 %2 to i32
  %3 = getelementptr inbounds %struct.kernel_param, %struct.kernel_param* %kp, i32 0, i32 4
  %arg = bitcast %union.anon.57* %3 to i8**
  %4 = load i8*, i8** %arg, align 8, !tbaa !166
  %5 = bitcast i8* %4 to i32*
  store i32 %conv9, i32* %5, align 4, !tbaa !49
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %lor.lhs.false3, %lor.lhs.false, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end8 ], [ -22, %entry ], [ -22, %lor.lhs.false3 ], [ -22, %lor.lhs.false ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul(i8* %s, i32 %base, i64* %res) #2 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

declare i32 @kstrtoull(i8*, i32, i64*) #4

; Function Attrs: nounwind uwtable
define internal i32 @param_set_max_slot_table_size(i8* %val, %struct.kernel_param* %kp) #0 {
entry:
  %call = call i32 @param_set_uint_minmax(i8* %val, %struct.kernel_param* %kp, i32 2, i32 65536)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @param_set_portnr(i8* %val, %struct.kernel_param* %kp) #0 {
entry:
  %call = call i32 @param_set_uint_minmax(i8* %val, %struct.kernel_param* %kp, i32 1, i32 65535)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @xs_swapper(%struct.rpc_xprt* %xprt, i32 %enable) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %tobool = icmp ne i32 %enable, 0
  %swapper = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 20
  %2 = load i32, i32* %swapper, align 4, !tbaa !32
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %inc = add i32 %2, 1
  store i32 %inc, i32* %swapper, align 4, !tbaa !32
  call void @xs_set_memalloc(%struct.rpc_xprt* %xprt)
  br label %if.end5

if.else:                                          ; preds = %entry
  %tobool2 = icmp ne i32 %2, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.else
  %swapper4 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 20
  %3 = load i32, i32* %swapper4, align 4, !tbaa !32
  %dec = add i32 %3, -1
  store i32 %dec, i32* %swapper4, align 4, !tbaa !32
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  %4 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !361
  call void @sk_clear_memalloc(%struct.sock* %4)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.else, %if.then
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @xs_set_memalloc(%struct.rpc_xprt* %xprt) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %swapper = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 20
  %2 = load i32, i32* %swapper, align 4, !tbaa !32
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  %3 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !361
  call void @sk_set_memalloc(%struct.sock* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @sk_clear_memalloc(%struct.sock*) #4

declare void @sk_set_memalloc(%struct.sock*) #4

; Function Attrs: nounwind uwtable
define i32 @init_socket_xprt() #0 {
entry:
  %0 = load %struct.ctl_table_header*, %struct.ctl_table_header** @sunrpc_table_header, align 8, !tbaa !28
  %tobool = icmp ne %struct.ctl_table_header* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call %struct.ctl_table_header* @register_sysctl_table(%struct.ctl_table* getelementptr inbounds ([2 x %struct.ctl_table], [2 x %struct.ctl_table]* @sunrpc_table, i32 0, i32 0))
  store %struct.ctl_table_header* %call, %struct.ctl_table_header** @sunrpc_table_header, align 8, !tbaa !28
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call1 = call i32 @xprt_register_transport(%struct.xprt_class* @xs_local_transport)
  %call2 = call i32 @xprt_register_transport(%struct.xprt_class* @xs_udp_transport)
  %call3 = call i32 @xprt_register_transport(%struct.xprt_class* @xs_tcp_transport)
  %call4 = call i32 @xprt_register_transport(%struct.xprt_class* @xs_bc_tcp_transport)
  ret i32 0
}

declare %struct.ctl_table_header* @register_sysctl_table(%struct.ctl_table*) #4

; Function Attrs: nounwind uwtable
define internal %struct.rpc_xprt* @xs_setup_bc_tcp(%struct.xprt_create* %args) #0 {
entry:
  %dstaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %0 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr, align 8, !tbaa !251
  %bc_xprt = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 6
  %1 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt, align 8, !tbaa !254
  %xpt_bc_xprt = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %1, i32 0, i32 19
  %2 = load %struct.rpc_xprt*, %struct.rpc_xprt** %xpt_bc_xprt, align 8, !tbaa !364
  %tobool = icmp ne %struct.rpc_xprt* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %bc_xprt1 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 6
  %3 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt1, align 8, !tbaa !254
  %xpt_bc_xprt2 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %3, i32 0, i32 19
  %4 = load %struct.rpc_xprt*, %struct.rpc_xprt** %xpt_bc_xprt2, align 8, !tbaa !364
  br label %cleanup

if.end:                                           ; preds = %entry
  %5 = load i32, i32* @xprt_tcp_slot_table_entries, align 4, !tbaa !49
  %6 = load i32, i32* @xprt_tcp_slot_table_entries, align 4, !tbaa !49
  %call = call %struct.rpc_xprt* @xs_setup_xprt(%struct.xprt_create* %args, i32 %5, i32 %6)
  %7 = bitcast %struct.rpc_xprt* %call to i8*
  %call3 = call i64 @IS_ERR.129(i8* %7)
  %tobool4 = icmp ne i64 %call3, 0
  br i1 %tobool4, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %8 = bitcast %struct.rpc_xprt* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 0
  %9 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %prot = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 5
  store i32 6, i32* %prot, align 8, !tbaa !186
  %tsh_size = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 9
  store i32 1, i32* %tsh_size, align 8, !tbaa !157
  %max_payload = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 8
  store i64 2147483647, i64* %max_payload, align 8, !tbaa !185
  %timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 2
  store %struct.rpc_timeout* @xs_tcp_default_timeout, %struct.rpc_timeout** %timeout, align 8, !tbaa !183
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  %bind_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 22
  store i64 0, i64* %bind_timeout, align 8, !tbaa !85
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 0, i64* %reestablish_timeout, align 8, !tbaa !367
  %idle_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 28
  store i64 0, i64* %idle_timeout, align 8, !tbaa !336
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 1
  store %struct.rpc_xprt_ops* @bc_tcp_ops, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %0, i32 0, i32 0
  %10 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %10 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end6
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb7, label %out_err

LeafBlock:                                        ; preds = %if.end6
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %out_err

sw.bb:                                            ; preds = %LeafBlock
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.592, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.592, i32 0, i32 0))
  br label %do.body

sw.bb7:                                           ; preds = %LeafBlock1
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.592, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27.587, i32 0, i32 0))
  br label %do.body

do.body:                                          ; preds = %sw.bb7, %sw.bb
  %11 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %11, 128
  %tobool9 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool9, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv11 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.then13, label %do.end

if.then13:                                        ; preds = %do.body
  %12 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then13, %do.body
  %call20 = call %struct.rpc_xprt* @xprt_get(%struct.rpc_xprt* %call)
  %bc_xprt21 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 6
  %13 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt21, align 8, !tbaa !254
  %xpt_bc_xprt22 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %13, i32 0, i32 19
  store %struct.rpc_xprt* %call, %struct.rpc_xprt** %xpt_bc_xprt22, align 8, !tbaa !364
  %bc_xprt23 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 6
  %14 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt23, align 8, !tbaa !254
  %bc_xprt24 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 33
  store %struct.svc_xprt* %14, %struct.svc_xprt** %bc_xprt24, align 8, !tbaa !368
  %bc_xprt26 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 6
  %15 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt26, align 8, !tbaa !254
  %16 = bitcast %struct.svc_xprt* %15 to i8*
  %add.ptr28 = getelementptr inbounds i8, i8* %16, i64 0
  %17 = bitcast i8* %add.ptr28 to %struct.svc_sock*
  %sk_sock = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %17, i32 0, i32 1
  %18 = load %struct.socket*, %struct.socket** %sk_sock, align 8, !tbaa !369
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %9, i32 0, i32 1
  store %struct.socket* %18, %struct.socket** %sock, align 8, !tbaa !371
  %sk_sk = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %17, i32 0, i32 2
  %19 = load %struct.sock*, %struct.sock** %sk_sk, align 8, !tbaa !372
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %9, i32 0, i32 2
  store %struct.sock* %19, %struct.sock** %inet, align 8, !tbaa !361
  call void @xprt_set_connected(%struct.rpc_xprt* %call)
  %call29 = call zeroext i1 @try_module_get(%struct.module* @__this_module)
  br i1 %call29, label %cleanup, label %if.end31

if.end31:                                         ; preds = %do.end
  call void @xprt_put(%struct.rpc_xprt* %call)
  br label %out_err

out_err:                                          ; preds = %if.end31, %LeafBlock, %LeafBlock1
  %.sink = phi i64 [ -22, %if.end31 ], [ -97, %LeafBlock ], [ -97, %LeafBlock1 ]
  %call32 = call i8* @ERR_PTR.133(i64 %.sink)
  %20 = bitcast i8* %call32 to %struct.rpc_xprt*
  call void @xprt_free(%struct.rpc_xprt* %call)
  br label %cleanup

cleanup:                                          ; preds = %out_err, %do.end, %if.end, %if.then
  %retval.0 = phi %struct.rpc_xprt* [ %4, %if.then ], [ %20, %out_err ], [ %call, %if.end ], [ %call, %do.end ]
  ret %struct.rpc_xprt* %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_xprt* @xs_setup_xprt(%struct.xprt_create* %args, i32 %slot_table_size, i32 %max_slot_table_size) #0 {
entry:
  %addrlen = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 4
  %0 = load i64, i64* %addrlen, align 8, !tbaa !252
  %cmp = icmp ugt i64 %0, 128
  br i1 %cmp, label %do.body, label %if.end5

do.body:                                          ; preds = %entry
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then3, label %do.end

if.then3:                                         ; preds = %do.body
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then3, %do.body
  %call4 = call i8* @ERR_PTR.133(i64 -9)
  %3 = bitcast i8* %call4 to %struct.rpc_xprt*
  br label %cleanup50

if.end5:                                          ; preds = %entry
  %net = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 1
  %4 = load %struct.net*, %struct.net** %net, align 8, !tbaa !249
  %call6 = call %struct.rpc_xprt* @xprt_alloc(%struct.net* %4, i64 2656, i32 %slot_table_size, i32 %max_slot_table_size)
  %cmp7 = icmp eq %struct.rpc_xprt* %call6, null
  br i1 %cmp7, label %do.body10, label %if.end26

do.body10:                                        ; preds = %if.end5
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and11 = and i32 %5, 128
  %tobool12 = icmp ne i32 %and11, 0
  %lnot13 = xor i1 %tobool12, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv17 = sext i32 %lnot.ext16 to i64
  %expval18 = call i64 @llvm.expect.i64(i64 %conv17, i64 0)
  %tobool19 = icmp ne i64 %expval18, 0
  br i1 %tobool19, label %if.then20, label %do.end24

if.then20:                                        ; preds = %do.body10
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end24

do.end24:                                         ; preds = %if.then20, %do.body10
  %call25 = call i8* @ERR_PTR.133(i64 -12)
  %7 = bitcast i8* %call25 to %struct.rpc_xprt*
  br label %cleanup50

if.end26:                                         ; preds = %if.end5
  %8 = bitcast %struct.rpc_xprt* %call6 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 0
  %9 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %addrlen27 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 4
  %10 = load i64, i64* %addrlen27, align 8, !tbaa !252
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call6, i32 0, i32 3
  %11 = bitcast %struct.__kernel_sockaddr_storage* %addr to i8*
  %dstaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %12 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr, align 8, !tbaa !251
  %13 = bitcast %struct.sockaddr* %12 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %13, i64 %10, i32 2, i1 false)
  %addrlen29 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 4
  %14 = load i64, i64* %addrlen29, align 8, !tbaa !252
  %addrlen30 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call6, i32 0, i32 4
  store i64 %14, i64* %addrlen30, align 8, !tbaa !188
  %srcaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 2
  %15 = load %struct.sockaddr*, %struct.sockaddr** %srcaddr, align 8, !tbaa !250
  %tobool31 = icmp ne %struct.sockaddr* %15, null
  br i1 %tobool31, label %if.then32, label %if.else

if.then32:                                        ; preds = %if.end26
  %addrlen34 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 4
  %16 = load i64, i64* %addrlen34, align 8, !tbaa !252
  %srcaddr36 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %9, i32 0, i32 11
  %17 = bitcast %struct.__kernel_sockaddr_storage* %srcaddr36 to i8*
  %srcaddr37 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 2
  %18 = load %struct.sockaddr*, %struct.sockaddr** %srcaddr37, align 8, !tbaa !250
  %19 = bitcast %struct.sockaddr* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %19, i64 %16, i32 2, i1 false)
  br label %cleanup50

if.else:                                          ; preds = %if.end26
  %dstaddr39 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %20 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr39, align 8, !tbaa !251
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %20, i32 0, i32 0
  %21 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv40 = zext i16 %21 to i32
  %srcaddr41 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %9, i32 0, i32 11
  %22 = bitcast %struct.__kernel_sockaddr_storage* %srcaddr41 to %struct.sockaddr*
  %call42 = call i32 @xs_init_anyaddr(i32 %conv40, %struct.sockaddr* %22)
  %cmp43 = icmp ne i32 %call42, 0
  br i1 %cmp43, label %if.then45, label %LeafBlock

if.then45:                                        ; preds = %if.else
  call void @xprt_free(%struct.rpc_xprt* %call6)
  %conv46 = sext i32 %call42 to i64
  %call47 = call i8* @ERR_PTR.133(i64 %conv46)
  %23 = bitcast i8* %call47 to %struct.rpc_xprt*
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.then45, %if.else
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then45 ], [ 0, %if.else ]
  %retval.0 = phi %struct.rpc_xprt* [ %23, %if.then45 ], [ undef, %if.else ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  %call6.retval.0 = select i1 %SwitchLeaf, %struct.rpc_xprt* %call6, %struct.rpc_xprt* %retval.0
  ret %struct.rpc_xprt* %call6.retval.0

cleanup50:                                        ; preds = %if.then32, %do.end24, %do.end
  %retval.1 = phi %struct.rpc_xprt* [ %3, %do.end ], [ %7, %do.end24 ], [ %call6, %if.then32 ]
  ret %struct.rpc_xprt* %retval.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR.129(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_set_bound(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @test_and_set_bit.161(i32 4, i64* %state)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_format_peer_addresses(%struct.rpc_xprt* %xprt, i8* %protocol, i8* %netid) #0 {
entry:
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 42
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 2
  store i8* %protocol, i8** %arrayidx, align 8, !tbaa !28
  %address_strings1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 42
  %arrayidx2 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings1, i64 0, i64 5
  store i8* %netid, i8** %arrayidx2, align 8, !tbaa !28
  call void @xs_format_common_peer_addresses(%struct.rpc_xprt* %xprt)
  call void @xs_format_common_peer_ports(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_set_connected(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 1, i64* %state) #7, !srcloc !373
  ret void
}

declare zeroext i1 @try_module_get(%struct.module*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR.133(i64 %error) #2 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal void @xs_format_common_peer_addresses(%struct.rpc_xprt* %xprt) #0 {
entry:
  %buf = alloca [128 x i8], align 16
  %call = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt)
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %call, i32 0, i32 0
  %0 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %0 to i32
  %Pivot6 = icmp slt i32 %conv, 2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf4, label %sw.bb17, label %do.body

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf2, label %sw.bb6, label %do.body

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 1
  br i1 %SwitchLeaf, label %sw.bb, label %do.body

sw.bb:                                            ; preds = %LeafBlock
  %call1 = call %struct.sockaddr_un* @xs_addr_un(%struct.rpc_xprt* %xprt)
  %arraydecay = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %sun_path = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %call1, i32 0, i32 1
  %arraydecay2 = getelementptr inbounds [108 x i8], [108 x i8]* %sun_path, i32 0, i32 0
  %call3 = call i64 @strlcpy(i8* %arraydecay, i8* %arraydecay2, i64 128)
  %arraydecay4 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call5 = call i8* @kstrdup(i8* %arraydecay4, i32 208)
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 42
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 0
  store i8* %call5, i8** %arrayidx, align 8, !tbaa !28
  br label %sw.epilog

sw.bb6:                                           ; preds = %LeafBlock1
  %arraydecay7 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call8 = call i64 @rpc_ntop(%struct.sockaddr* %call, i8* %arraydecay7, i64 128)
  %arraydecay9 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call10 = call i8* @kstrdup(i8* %arraydecay9, i32 208)
  %address_strings11 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 42
  %arrayidx12 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings11, i64 0, i64 0
  store i8* %call10, i8** %arrayidx12, align 8, !tbaa !28
  %call13 = call %struct.sockaddr_in* @xs_addr_in(%struct.rpc_xprt* %xprt)
  %arraydecay14 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %call13, i32 0, i32 2
  %s_addr = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %sin_addr, i32 0, i32 0
  %1 = load i32, i32* %s_addr, align 4, !tbaa !374
  %call15 = call i32 @__fswab32.138(i32 %1) #3
  %call16 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay14, i64 128, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.24, i32 0, i32 0), i32 %call15)
  br label %sw.epilog

sw.bb17:                                          ; preds = %LeafBlock3
  %arraydecay18 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call19 = call i64 @rpc_ntop(%struct.sockaddr* %call, i8* %arraydecay18, i64 128)
  %arraydecay20 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call21 = call i8* @kstrdup(i8* %arraydecay20, i32 208)
  %address_strings22 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 42
  %arrayidx23 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings22, i64 0, i64 0
  store i8* %call21, i8** %arrayidx23, align 8, !tbaa !28
  %call24 = call %struct.sockaddr_in6* @xs_addr_in6(%struct.rpc_xprt* %xprt)
  %arraydecay25 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %call24, i32 0, i32 3
  %call26 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay25, i64 128, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.25.139, i32 0, i32 0), %struct.in6_addr* %sin6_addr)
  br label %sw.epilog

do.body:                                          ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.13.140, i32 0, i32 0), i32 325, i64 12) #7, !srcloc !375
  br label %do.body27

do.body27:                                        ; preds = %do.body27, %do.body
  br label %do.body27

sw.epilog:                                        ; preds = %sw.bb17, %sw.bb6, %sw.bb
  %arraydecay30 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call31 = call i8* @kstrdup(i8* %arraydecay30, i32 208)
  %address_strings32 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 42
  %arrayidx33 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings32, i64 0, i64 3
  store i8* %call31, i8** %arrayidx33, align 8, !tbaa !28
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_format_common_peer_ports(%struct.rpc_xprt* %xprt) #0 {
entry:
  %buf = alloca [128 x i8], align 16
  %call = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt)
  %arraydecay = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call1 = call zeroext i16 @rpc_get_port(%struct.sockaddr* %call)
  %conv = zext i16 %call1 to i32
  %call2 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 128, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.10.772, i32 0, i32 0), i32 %conv)
  %arraydecay3 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call4 = call i8* @kstrdup(i8* %arraydecay3, i32 208)
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 42
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 1
  store i8* %call4, i8** %arrayidx, align 8, !tbaa !28
  %arraydecay5 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call6 = call zeroext i16 @rpc_get_port(%struct.sockaddr* %call)
  %conv7 = zext i16 %call6 to i32
  %call8 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay5, i64 128, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27.136, i32 0, i32 0), i32 %conv7)
  %arraydecay9 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call10 = call i8* @kstrdup(i8* %arraydecay9, i32 208)
  %address_strings11 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 42
  %arrayidx12 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings11, i64 0, i64 4
  store i8* %call10, i8** %arrayidx12, align 8, !tbaa !28
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt) #2 {
entry:
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 3
  %0 = bitcast %struct.__kernel_sockaddr_storage* %addr to %struct.sockaddr*
  ret %struct.sockaddr* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @rpc_get_port(%struct.sockaddr* %sap) #2 {
entry:
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sap, i32 0, i32 0
  %0 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %0 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb3, label %return

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %return

sw.bb:                                            ; preds = %LeafBlock
  %1 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %1, i32 0, i32 1
  %2 = load i16, i16* %sin_port, align 2, !tbaa !191
  %call = call zeroext i16 @__fswab16.137(i16 zeroext %2) #3
  %conv1 = zext i16 %call to i32
  %conv2 = trunc i32 %conv1 to i16
  br label %return

sw.bb3:                                           ; preds = %LeafBlock1
  %3 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %3, i32 0, i32 1
  %4 = load i16, i16* %sin6_port, align 2, !tbaa !194
  %call4 = call zeroext i16 @__fswab16.137(i16 zeroext %4) #3
  %conv5 = zext i16 %call4 to i32
  %conv6 = trunc i32 %conv5 to i16
  br label %return

return:                                           ; preds = %sw.bb3, %sw.bb, %LeafBlock, %LeafBlock1
  %retval.0 = phi i16 [ %conv2, %sw.bb ], [ %conv6, %sw.bb3 ], [ 0, %LeafBlock ], [ 0, %LeafBlock1 ]
  ret i16 %retval.0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal zeroext i16 @__fswab16.137(i16 zeroext %val) #5 {
entry:
  %conv = zext i16 %val to i32
  %and = and i32 %conv, 255
  %shl = shl i32 %and, 8
  %conv1 = zext i16 %val to i32
  %and2 = and i32 %conv1, 65280
  %shr = ashr i32 %and2, 8
  %or = or i32 %shl, %shr
  %conv3 = trunc i32 %or to i16
  ret i16 %conv3
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr_un* @xs_addr_un(%struct.rpc_xprt* %xprt) #2 {
entry:
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 3
  %0 = bitcast %struct.__kernel_sockaddr_storage* %addr to %struct.sockaddr_un*
  ret %struct.sockaddr_un* %0
}

declare i64 @strlcpy(i8*, i8*, i64) #4

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr_in* @xs_addr_in(%struct.rpc_xprt* %xprt) #2 {
entry:
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 3
  %0 = bitcast %struct.__kernel_sockaddr_storage* %addr to %struct.sockaddr_in*
  ret %struct.sockaddr_in* %0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__fswab32.138(i32 %val) #5 {
entry:
  %call = call i32 @__arch_swab32.141(i32 %val) #3
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr_in6* @xs_addr_in6(%struct.rpc_xprt* %xprt) #2 {
entry:
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 3
  %0 = bitcast %struct.__kernel_sockaddr_storage* %addr to %struct.sockaddr_in6*
  ret %struct.sockaddr_in6* %0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__arch_swab32.141(i32 %val) #5 {
entry:
  %0 = call i32 asm "bswapl $0", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %val) #3, !srcloc !376
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal void @xs_local_rpcbind(%struct.rpc_task* %task) #0 {
entry:
  call void @rcu_read_lock.147()
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %0 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 4
  %1 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end7

land.lhs.true:                                    ; preds = %entry
  %2 = load i8, i8* @xs_local_rpcbind.__warned, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %2 to i1
  br i1 %tobool1, label %do.end7, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held.148()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.end7, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @xs_local_rpcbind.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.13.140, i32 0, i32 0), i32 1741, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end7

do.end7:                                          ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  call void @xprt_set_bound(%struct.rpc_xprt* %1)
  call void @rcu_read_unlock.150()
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @bc_malloc(%struct.rpc_task* %task, i64 %size) #0 {
entry:
  %cmp = icmp ugt i64 %size, 4088
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  %0 = load i8, i8* @bc_malloc.__warned, align 1, !tbaa !29, !range !31
  %tobool7 = trunc i8 %0 to i1
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %tobool14 = icmp ne i32 %lnot.ext13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.13.140, i32 0, i32 0), i32 2365)
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then
  %tobool23 = icmp ne i32 %lnot.ext13, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end
  store i8 1, i8* @bc_malloc.__warned, align 1, !tbaa !29
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end, %entry
  %cmp42 = icmp ugt i64 %size, 4088
  br i1 %cmp42, label %cleanup, label %if.end45

if.end45:                                         ; preds = %if.end33
  %call = call %struct.page* @alloc_pages.145(i32 208, i32 0)
  %tobool46 = icmp ne %struct.page* %call, null
  br i1 %tobool46, label %if.end48, label %cleanup

if.end48:                                         ; preds = %if.end45
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %call to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %1 = inttoptr i64 %add.i to i8*
  %2 = bitcast i8* %1 to %struct.rpc_buffer*
  %len = getelementptr inbounds %struct.rpc_buffer, %struct.rpc_buffer* %2, i32 0, i32 0
  store i64 4096, i64* %len, align 8, !tbaa !88
  %data = getelementptr inbounds %struct.rpc_buffer, %struct.rpc_buffer* %2, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %data, i32 0, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end48, %if.end45, %if.end33
  %retval.0 = phi i8* [ %arraydecay, %if.end48 ], [ null, %if.end33 ], [ null, %if.end45 ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @bc_free(i8* %buffer) #0 {
entry:
  %tobool = icmp ne i8* %buffer, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %0 = bitcast i8* %buffer to [0 x i8]*
  %1 = bitcast [0 x i8]* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -8
  %2 = bitcast i8* %add.ptr to %struct.rpc_buffer*
  %3 = ptrtoint %struct.rpc_buffer* %2 to i64
  call void @free_pages(i64 %3, i32 0)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @bc_send_request(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %3 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %bc_xprt = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %3, i32 0, i32 33
  %4 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt, align 8, !tbaa !368
  %xpt_mutex = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %4, i32 0, i32 8
  %call4 = call i32 @mutex_trylock(%struct.mutex* %xpt_mutex)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %cond.true, label %if.then6

if.then6:                                         ; preds = %do.end
  %xpt_bc_pending = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %4, i32 0, i32 16
  call void @rpc_sleep_on(%struct.rpc_wait_queue* %xpt_bc_pending, %struct.rpc_task* %task, void (%struct.rpc_task*)* null)
  %xpt_mutex7 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %4, i32 0, i32 8
  %call8 = call i32 @mutex_trylock(%struct.mutex* %xpt_mutex7)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end11, label %cleanup

if.end11:                                         ; preds = %if.then6
  %xpt_bc_pending12 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %4, i32 0, i32 16
  call void @rpc_wake_up_queued_task(%struct.rpc_wait_queue* %xpt_bc_pending12, %struct.rpc_task* %task)
  br label %cond.true

cond.true:                                        ; preds = %if.end11, %do.end
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %4, i32 0, i32 5
  %5 = load volatile i64, i64* %xpt_flags, align 8, !tbaa !88
  %and.i = and i64 64, %5
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool15 = icmp ne i32 %conv.i, 0
  br i1 %tobool15, label %if.end21, label %if.else

if.else:                                          ; preds = %cond.true
  %call20 = call i32 @bc_sendto(%struct.rpc_rqst* %0)
  br label %if.end21

if.end21:                                         ; preds = %if.else, %cond.true
  %len.0 = phi i32 [ %call20, %if.else ], [ -107, %cond.true ]
  %xpt_mutex22 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %4, i32 0, i32 8
  call void @mutex_unlock(%struct.mutex* %xpt_mutex22)
  %cmp = icmp ugt i32 %len.0, 0
  %.len.0 = select i1 %cmp, i32 0, i32 %len.0
  br label %cleanup

cleanup:                                          ; preds = %if.end21, %if.then6
  %retval.0 = phi i32 [ %.len.0, %if.end21 ], [ -11, %if.then6 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @bc_close(%struct.rpc_xprt* %xprt) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @bc_destroy(%struct.rpc_xprt* %xprt) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_print_stats(%struct.rpc_xprt* %xprt, %struct.seq_file* %seq) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %call = call i32 @xprt_connected.142(%struct.rpc_xprt* %xprt)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %last_used = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 27
  %3 = load i64, i64* %last_used, align 8, !tbaa !270
  %sub = sub i64 %2, %3
  %div = sdiv i64 %sub, 250
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %idle_time.0 = phi i64 [ %div, %if.then ], [ 0, %entry ]
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 12
  %4 = load i16, i16* %srcport, align 8, !tbaa !377
  %conv = zext i16 %4 to i32
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %bind_count = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat, i32 0, i32 0
  %5 = load i64, i64* %bind_count, align 8, !tbaa !378
  %stat1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %connect_count = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat1, i32 0, i32 1
  %6 = load i64, i64* %connect_count, align 8, !tbaa !315
  %stat2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %connect_time = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat2, i32 0, i32 3
  %7 = load i64, i64* %connect_time, align 8, !tbaa !316
  %stat3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %sends = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat3, i32 0, i32 4
  %8 = load i64, i64* %sends, align 8, !tbaa !320
  %stat4 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %recvs = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat4, i32 0, i32 5
  %9 = load i64, i64* %recvs, align 8, !tbaa !289
  %stat5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %bad_xids = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat5, i32 0, i32 6
  %10 = load i64, i64* %bad_xids, align 8, !tbaa !299
  %stat6 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %req_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat6, i32 0, i32 8
  %11 = load i64, i64* %req_u, align 8, !tbaa !321
  %stat7 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %bklog_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat7, i32 0, i32 9
  %12 = load i64, i64* %bklog_u, align 8, !tbaa !323
  %stat8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %max_slots = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat8, i32 0, i32 7
  %13 = load i64, i64* %max_slots, align 8, !tbaa !319
  %stat9 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %sending_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat9, i32 0, i32 10
  %14 = load i64, i64* %sending_u, align 8, !tbaa !325
  %stat10 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %pending_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat10, i32 0, i32 11
  %15 = load i64, i64* %pending_u, align 8, !tbaa !327
  %call11 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.77.143, i32 0, i32 0), i32 %conv, i64 %5, i64 %6, i64 %7, i64 %idle_time.0, i64 %8, i64 %9, i64 %10, i64 %11, i64 %12, i64 %13, i64 %14, i64 %15)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_connected.142(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %0 = load volatile i64, i64* %state, align 8, !tbaa !88
  %and.i = and i64 2, %0
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  ret i32 %conv.i
}

declare i32 @seq_printf(%struct.seq_file*, i8*, ...) #4

declare i32 @mutex_trylock(%struct.mutex*) #4

; Function Attrs: nounwind uwtable
define internal i32 @bc_sendto(%struct.rpc_rqst* %req) #0 {
entry:
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 1
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 0
  %0 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %1 = bitcast %struct.rpc_xprt* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %sock1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %2, i32 0, i32 1
  %3 = load %struct.socket*, %struct.socket** %sock1, align 8, !tbaa !371
  call void @xs_encode_stream_record_marker(%struct.xdr_buf* %rq_snd_buf)
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 1
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  %4 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %5 = ptrtoint i8* %4 to i64
  %and = and i64 %5, 4095
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_base3 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx2, i32 0, i32 0
  %6 = load i8*, i8** %iov_base3, align 8, !tbaa !147
  %7 = ptrtoint i8* %6 to i64
  %and4 = and i64 %7, 4095
  %head5 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head5, i64 0, i64 0
  %iov_base7 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx6, i32 0, i32 0
  %8 = load i8*, i8** %iov_base7, align 8, !tbaa !147
  %9 = ptrtoint i8* %8 to i64
  %call = call i64 @__phys_addr(i64 %9)
  %shr = lshr i64 %call, 12
  %add.ptr8 = getelementptr inbounds %struct.page, %struct.page* inttoptr (i64 -24189255811072 to %struct.page*), i64 %shr
  %tail9 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 1
  %arrayidx10 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail9, i64 0, i64 0
  %iov_base11 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx10, i32 0, i32 0
  %10 = load i8*, i8** %iov_base11, align 8, !tbaa !147
  %11 = bitcast i8* %10 to %struct.page*
  %call12 = call i32 @svc_send_common(%struct.socket* %3, %struct.xdr_buf* %rq_snd_buf, %struct.page* %add.ptr8, i64 %and4, %struct.page* %11, i64 %and)
  %len13 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 7
  %12 = load i32, i32* %len13, align 8, !tbaa !152
  %cmp = icmp ne i32 %call12, %12
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %13 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %len.0 = phi i32 [ -11, %if.then ], [ %call12, %entry ]
  ret i32 %len.0
}

declare void @mutex_unlock(%struct.mutex*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_encode_stream_record_marker(%struct.xdr_buf* %buf) #2 {
entry:
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  %0 = load i32, i32* %len, align 8, !tbaa !152
  %conv = zext i32 %0 to i64
  %sub = sub i64 %conv, 4
  %conv1 = trunc i64 %sub to i32
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  %1 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %2 = bitcast i8* %1 to i32*
  %or = or i32 -2147483648, %conv1
  %call = call i32 @__fswab32.138(i32 %or) #3
  store i32 %call, i32* %2, align 4, !tbaa !49
  ret void
}

declare i64 @__phys_addr(i64) #4

declare void @free_pages(i64, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.page* @alloc_pages.145(i32 %gfp_mask, i32 %order) #2 {
entry:
  %call = call %struct.page* @alloc_pages_current(i32 %gfp_mask, i32 %order)
  ret %struct.page* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock.147() #2 {
entry:
  call void @__rcu_read_lock.157()
  call void @rcu_lock_acquire.158(%struct.lockdep_map* @rcu_lock_map)
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_lock.__warned.159, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_lock.__warned.159, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 780, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.15.1329, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rcu_read_lock_held.148() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call1 = call i32 @rcu_is_cpu_idle()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call zeroext i1 @rcu_lockdep_current_cpu_online()
  br i1 %call5, label %if.end7, label %return

if.end7:                                          ; preds = %if.end4
  %call8 = call i32 @lock_is_held(%struct.lockdep_map* @rcu_lock_map)
  br label %return

return:                                           ; preds = %if.end7, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call8, %if.end7 ], [ 1, %entry ], [ 0, %if.end ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_unlock.150() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_unlock.__warned.151, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_unlock.__warned.151, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 801, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.16.1322, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  call void @rcu_lock_release.154(%struct.lockdep_map* @rcu_lock_map)
  call void @__rcu_read_unlock.155()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_release.154(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_release(%struct.lockdep_map* %map, i32 1, i64 ptrtoint (i8* blockaddress(@rcu_lock_release.154, %__here) to i64))
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_unlock.155() #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !379
  %call = call %struct.thread_info* @current_thread_info.156()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !380
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.156() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !381
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_lock.157() #2 {
entry:
  %call = call %struct.thread_info* @current_thread_info.156()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !382
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_acquire.158(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_acquire(%struct.lockdep_map* %map, i32 0, i32 0, i32 2, i32 1, %struct.lockdep_map* null, i64 ptrtoint (i8* blockaddress(@rcu_lock_acquire.158, %__here) to i64))
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_and_set_bit.161(i32 %nr, i64* %addr) #2 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !383
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_init_anyaddr(i32 %family, %struct.sockaddr* %sap) #0 {
entry:
  %Pivot6 = icmp slt i32 %family, 2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %family, 10
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %family, 10
  br i1 %SwitchLeaf4, label %sw.bb1, label %do.body

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %family, 2
  br i1 %SwitchLeaf2, label %sw.bb, label %do.body

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %family, 1
  br i1 %SwitchLeaf, label %return, label %do.body

sw.bb:                                            ; preds = %LeafBlock1
  %cmp = icmp uge i64 16, 64
  %0 = bitcast %struct.sockaddr* %sap to i8*
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %call = call i8* @__memcpy(i8* %0, i8* bitcast (%struct.sockaddr_in* @xs_init_anyaddr.sin to i8*), i64 16)
  br label %return

if.else:                                          ; preds = %sw.bb
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast (%struct.sockaddr_in* @xs_init_anyaddr.sin to i8*), i64 16, i32 2, i1 false)
  br label %return

sw.bb1:                                           ; preds = %LeafBlock3
  %cmp4 = icmp uge i64 28, 64
  %1 = bitcast %struct.sockaddr* %sap to i8*
  br i1 %cmp4, label %if.then5, label %if.else7

if.then5:                                         ; preds = %sw.bb1
  %call6 = call i8* @__memcpy(i8* %1, i8* bitcast ({ i16, i16, i32, { { [16 x i8] } }, i32 }* @xs_init_anyaddr.sin6 to i8*), i64 28)
  br label %return

if.else7:                                         ; preds = %sw.bb1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* bitcast ({ i16, i16, i32, { { [16 x i8] } }, i32 }* @xs_init_anyaddr.sin6 to i8*), i64 28, i32 2, i1 false)
  br label %return

do.body:                                          ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %if.then12, label %return

if.then12:                                        ; preds = %do.body
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %return

return:                                           ; preds = %if.then12, %do.body, %if.else7, %if.then5, %if.else, %if.then, %LeafBlock
  %retval.0 = phi i32 [ -97, %do.body ], [ -97, %if.then12 ], [ 0, %if.then5 ], [ 0, %if.else7 ], [ 0, %if.then ], [ 0, %if.else ], [ 0, %LeafBlock ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_xprt* @xs_setup_tcp(%struct.xprt_create* %args) #0 {
entry:
  %.compoundliteral = alloca %struct.pgprot, align 8
  %.compoundliteral54 = alloca %struct.pgprot, align 8
  %dstaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %0 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr, align 8, !tbaa !251
  %1 = load i32, i32* @xprt_max_tcp_slot_table_entries, align 4, !tbaa !49
  %flags = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 7
  %2 = load i32, i32* %flags, align 8, !tbaa !255
  %and = and i32 %2, 1
  %tobool = icmp ne i32 %and, 0
  %. = select i1 %tobool, i32 65536, i32 %1
  %3 = load i32, i32* @xprt_tcp_slot_table_entries, align 4, !tbaa !49
  %call = call %struct.rpc_xprt* @xs_setup_xprt(%struct.xprt_create* %args, i32 %3, i32 %.)
  %4 = bitcast %struct.rpc_xprt* %call to i8*
  %call1 = call i64 @IS_ERR.129(i8* %4)
  %tobool2 = icmp ne i64 %call1, 0
  br i1 %tobool2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %entry
  %5 = bitcast %struct.rpc_xprt* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 0
  %6 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %prot = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 5
  store i32 6, i32* %prot, align 8, !tbaa !186
  %tsh_size = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 9
  store i32 1, i32* %tsh_size, align 8, !tbaa !157
  %max_payload = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 8
  store i64 2147483647, i64* %max_payload, align 8, !tbaa !185
  %bind_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 22
  store i64 15000, i64* %bind_timeout, align 8, !tbaa !85
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 750, i64* %reestablish_timeout, align 8, !tbaa !367
  %idle_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 28
  store i64 75000, i64* %idle_timeout, align 8, !tbaa !336
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 1
  store %struct.rpc_xprt_ops* @xs_tcp_ops, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 2
  store %struct.rpc_timeout* @xs_tcp_default_timeout, %struct.rpc_timeout** %timeout, align 8, !tbaa !183
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %0, i32 0, i32 0
  %7 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %7 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end4
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb40, label %out_err

LeafBlock:                                        ; preds = %if.end4
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %out_err

sw.bb:                                            ; preds = %LeafBlock
  %8 = bitcast %struct.sockaddr* %0 to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %8, i32 0, i32 1
  %9 = load i16, i16* %sin_port, align 2, !tbaa !191
  %conv5 = zext i16 %9 to i32
  %cmp = icmp ne i32 %conv5, 0
  br i1 %cmp, label %if.then7, label %do.body10

if.then7:                                         ; preds = %sw.bb
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  br label %do.body10

do.body10:                                        ; preds = %if.then7, %sw.bb
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work, i32 0)
  %connect_worker11 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work12 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker11, i32 0, i32 0
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work12, i32 0, i32 0
  %counter = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !339
  %10 = bitcast %struct.pgprot* %data to i8*
  %11 = bitcast %struct.pgprot* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 8, i32 8, i1 false), !tbaa.struct !340
  %connect_worker13 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work14 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker13, i32 0, i32 0
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work14, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.42.165, i32 0, i32 0), %struct.lock_class_key* @xs_setup_tcp.__key, i32 0)
  %connect_worker15 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work16 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker15, i32 0, i32 0
  %entry17 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work16, i32 0, i32 1
  call void @INIT_LIST_HEAD.166(%struct.list_head* %entry17)
  %connect_worker19 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work20 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker19, i32 0, i32 0
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work20, i32 0, i32 2
  store void (%struct.work_struct*)* @xs_tcp_setup_socket, void (%struct.work_struct*)** %func, align 8, !tbaa !341
  %connect_worker27 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %timer = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker27, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer, i32 2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.44.167, i32 0, i32 0), %struct.lock_class_key* @xs_setup_tcp.__key.71)
  %connect_worker30 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %timer31 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker30, i32 0, i32 1
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer31, i32 0, i32 3
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function, align 8, !tbaa !342
  %connect_worker32 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %12 = ptrtoint %struct.delayed_work* %connect_worker32 to i64
  %connect_worker33 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %timer34 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker33, i32 0, i32 1
  %data35 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer34, i32 0, i32 4
  store i64 %12, i64* %data35, align 8, !tbaa !343
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.592, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.592, i32 0, i32 0))
  br label %sw.epilog

sw.bb40:                                          ; preds = %LeafBlock1
  %13 = bitcast %struct.sockaddr* %0 to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %13, i32 0, i32 1
  %14 = load i16, i16* %sin6_port, align 2, !tbaa !194
  %conv41 = zext i16 %14 to i32
  %cmp42 = icmp ne i32 %conv41, 0
  br i1 %cmp42, label %if.then44, label %do.body48

if.then44:                                        ; preds = %sw.bb40
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  br label %do.body48

do.body48:                                        ; preds = %if.then44, %sw.bb40
  %connect_worker49 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work50 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker49, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work50, i32 0)
  %connect_worker51 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work52 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker51, i32 0, i32 0
  %data53 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work52, i32 0, i32 0
  %counter55 = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral54, i32 0, i32 0
  store i64 137438953408, i64* %counter55, align 8, !tbaa !339
  %15 = bitcast %struct.pgprot* %data53 to i8*
  %16 = bitcast %struct.pgprot* %.compoundliteral54 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 8, i32 8, i1 false), !tbaa.struct !340
  %connect_worker56 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work57 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker56, i32 0, i32 0
  %lockdep_map58 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work57, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map58, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.42.165, i32 0, i32 0), %struct.lock_class_key* @xs_setup_tcp.__key.73, i32 0)
  %connect_worker59 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work60 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker59, i32 0, i32 0
  %entry61 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work60, i32 0, i32 1
  call void @INIT_LIST_HEAD.166(%struct.list_head* %entry61)
  %connect_worker63 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work64 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker63, i32 0, i32 0
  %func65 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work64, i32 0, i32 2
  store void (%struct.work_struct*)* @xs_tcp_setup_socket, void (%struct.work_struct*)** %func65, align 8, !tbaa !341
  %connect_worker74 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %timer75 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker74, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer75, i32 2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.44.167, i32 0, i32 0), %struct.lock_class_key* @xs_setup_tcp.__key.74)
  %connect_worker78 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %timer79 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker78, i32 0, i32 1
  %function80 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer79, i32 0, i32 3
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function80, align 8, !tbaa !342
  %connect_worker81 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %17 = ptrtoint %struct.delayed_work* %connect_worker81 to i64
  %connect_worker82 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %timer83 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker82, i32 0, i32 1
  %data84 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer83, i32 0, i32 4
  store i64 %17, i64* %data84, align 8, !tbaa !343
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.592, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27.587, i32 0, i32 0))
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.body48, %do.body10
  %call90 = call i32 @xprt_bound.168(%struct.rpc_xprt* %call)
  %tobool91 = icmp ne i32 %call90, 0
  %18 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and94 = and i32 %18, 128
  %tobool95 = icmp ne i32 %and94, 0
  %lnot = xor i1 %tobool95, true
  %lnot96 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot96 to i32
  %conv97 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv97, i64 0)
  %tobool98 = icmp ne i64 %expval, 0
  br i1 %tobool91, label %do.body93, label %do.body108

do.body93:                                        ; preds = %sw.epilog
  br i1 %tobool98, label %if.then99, label %if.end127

if.then99:                                        ; preds = %do.body93
  %19 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end127

do.body108:                                       ; preds = %sw.epilog
  br i1 %tobool98, label %if.then118, label %if.end127

if.then118:                                       ; preds = %do.body108
  %20 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end127

if.end127:                                        ; preds = %if.then118, %do.body108, %if.then99, %do.body93
  %call128 = call zeroext i1 @try_module_get(%struct.module* @__this_module)
  br i1 %call128, label %cleanup, label %out_err

out_err:                                          ; preds = %if.end127, %LeafBlock, %LeafBlock1
  %.sink = phi i64 [ -22, %if.end127 ], [ -97, %LeafBlock ], [ -97, %LeafBlock1 ]
  %call131 = call i8* @ERR_PTR.133(i64 %.sink)
  %21 = bitcast i8* %call131 to %struct.rpc_xprt*
  call void @xprt_free(%struct.rpc_xprt* %call)
  br label %cleanup

cleanup:                                          ; preds = %out_err, %if.end127, %entry
  %retval.0 = phi %struct.rpc_xprt* [ %21, %out_err ], [ %call, %entry ], [ %call, %if.end127 ]
  ret %struct.rpc_xprt* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.166(%struct.list_head* %list) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !163
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_setup_socket(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -2256
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %sock1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  %2 = load %struct.socket*, %struct.socket** %sock1, align 8, !tbaa !371
  %xprt2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 0
  %3 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !384
  %flags = getelementptr inbounds %struct.task_struct, %struct.task_struct* %3, i32 0, i32 3
  %4 = load i32, i32* %flags, align 4, !tbaa !385
  %or = or i32 %4, 131072
  store i32 %or, i32* %flags, align 4, !tbaa !385
  %tobool = icmp ne %struct.socket* %2, null
  %state10 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt2, i32 0, i32 18
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state10, i32 7, i64* %state10) #7, !srcloc !386
  %call3 = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt2)
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %call3, i32 0, i32 0
  %5 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %5 to i32
  %call4 = call %struct.socket* @xs_create_sock(%struct.rpc_xprt* %xprt2, %struct.sock_xprt* %1, i32 %conv, i32 1, i32 6)
  %6 = bitcast %struct.socket* %call4 to i8*
  %call5 = call i64 @IS_ERR.129(i8* %6)
  %tobool6 = icmp ne i64 %call5, 0
  br i1 %tobool6, label %if.then7, label %do.body

if.then7:                                         ; preds = %if.then
  %7 = bitcast %struct.socket* %call4 to i8*
  %call8 = call i64 @PTR_ERR.172(i8* %7)
  %conv9 = trunc i64 %call8 to i32
  br label %out

if.else:                                          ; preds = %entry
  %call11 = call i32 @test_and_clear_bit.173(i32 7, i64* %state10)
  call void @xs_tcp_reuse_connection(%struct.sock_xprt* %1)
  %tobool12 = icmp ne i32 %call11, 0
  %. = select i1 %tobool12, i32 3, i32 0
  %Pivot = icmp slt i32 %., 3
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.else
  %SwitchLeaf2 = icmp eq i32 %., 3
  br i1 %SwitchLeaf2, label %out, label %cleanup.cont59

LeafBlock:                                        ; preds = %if.else
  %SwitchLeaf = icmp eq i32 %., 0
  br i1 %SwitchLeaf, label %do.body, label %cleanup.cont59

do.body:                                          ; preds = %LeafBlock, %if.then
  %sock.0 = phi %struct.socket* [ %call4, %if.then ], [ %2, %LeafBlock ]
  %8 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %8, 128
  %tobool16 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool16, true
  %lnot17 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot17 to i32
  %conv18 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv18, i64 0)
  %tobool19 = icmp ne i64 %expval, 0
  br i1 %tobool19, label %if.then20, label %do.end

if.then20:                                        ; preds = %do.body
  %9 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then20, %do.body
  %call27 = call i32 @xs_tcp_finish_connecting(%struct.rpc_xprt* %xprt2, %struct.socket* %sock.0)
  %10 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and29 = and i32 %10, 128
  %tobool30 = icmp ne i32 %and29, 0
  %lnot31 = xor i1 %tobool30, true
  %lnot33 = xor i1 %lnot31, true
  %lnot.ext34 = zext i1 %lnot33 to i32
  %conv35 = sext i32 %lnot.ext34 to i64
  %expval36 = call i64 @llvm.expect.i64(i64 %conv35, i64 0)
  %tobool37 = icmp ne i64 %expval36, 0
  br i1 %tobool37, label %if.then38, label %NodeBlock28

if.then38:                                        ; preds = %do.end
  %call39 = call i32 @xprt_connected.142(%struct.rpc_xprt* %xprt2)
  %sk = getelementptr inbounds %struct.socket, %struct.socket* %sock.0, i32 0, i32 5
  %11 = load %struct.sock*, %struct.sock** %sk, align 8, !tbaa !387
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %11, i32 0, i32 0
  %skc_state = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 4
  %12 = load volatile i8, i8* %skc_state, align 2, !tbaa !389
  %13 = call i32 (i8*, ...) @printk(i8* null)
  br label %NodeBlock28

NodeBlock28:                                      ; preds = %if.then38, %do.end
  %Pivot29 = icmp slt i32 %call27, -101
  br i1 %Pivot29, label %NodeBlock12, label %NodeBlock26

NodeBlock26:                                      ; preds = %NodeBlock28
  %Pivot27 = icmp slt i32 %call27, -22
  br i1 %Pivot27, label %NodeBlock18, label %NodeBlock24

NodeBlock24:                                      ; preds = %NodeBlock26
  %Pivot25 = icmp slt i32 %call27, 0
  br i1 %Pivot25, label %LeafBlock20, label %LeafBlock22

LeafBlock22:                                      ; preds = %NodeBlock24
  %SwitchLeaf23 = icmp eq i32 %call27, 0
  br i1 %SwitchLeaf23, label %sw.bb46, label %sw.default

LeafBlock20:                                      ; preds = %NodeBlock24
  %SwitchLeaf21 = icmp eq i32 %call27, -22
  br i1 %SwitchLeaf21, label %out, label %sw.default

NodeBlock18:                                      ; preds = %NodeBlock26
  %Pivot19 = icmp slt i32 %call27, -99
  br i1 %Pivot19, label %LeafBlock14, label %LeafBlock16

LeafBlock16:                                      ; preds = %NodeBlock18
  %SwitchLeaf17 = icmp eq i32 %call27, -99
  br i1 %SwitchLeaf17, label %sw.bb, label %sw.default

LeafBlock14:                                      ; preds = %NodeBlock18
  %SwitchLeaf15 = icmp eq i32 %call27, -101
  br i1 %SwitchLeaf15, label %out, label %sw.default

NodeBlock12:                                      ; preds = %NodeBlock28
  %Pivot13 = icmp slt i32 %call27, -111
  br i1 %Pivot13, label %LeafBlock4, label %NodeBlock10

NodeBlock10:                                      ; preds = %NodeBlock12
  %Pivot11 = icmp slt i32 %call27, -104
  br i1 %Pivot11, label %LeafBlock6, label %LeafBlock8

LeafBlock8:                                       ; preds = %NodeBlock10
  %SwitchLeaf9 = icmp eq i32 %call27, -104
  br i1 %SwitchLeaf9, label %out, label %sw.default

LeafBlock6:                                       ; preds = %NodeBlock10
  %SwitchLeaf7 = icmp eq i32 %call27, -111
  br i1 %SwitchLeaf7, label %out, label %sw.default

LeafBlock4:                                       ; preds = %NodeBlock12
  %.off = add i32 %call27, 115
  %SwitchLeaf5 = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf5, label %sw.bb46, label %sw.default

sw.default:                                       ; preds = %LeafBlock4, %LeafBlock6, %LeafBlock8, %LeafBlock14, %LeafBlock16, %LeafBlock20, %LeafBlock22
  %14 = call i32 (i8*, ...) @printk(i8* null)
  br label %sw.bb

sw.bb:                                            ; preds = %sw.default, %LeafBlock16
  call void @xs_tcp_force_close(%struct.rpc_xprt* %xprt2)
  br label %out

sw.bb46:                                          ; preds = %LeafBlock4, %LeafBlock22
  call void @xprt_clear_connecting(%struct.rpc_xprt* %xprt2)
  %15 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !384
  %flags48 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %15, i32 0, i32 3
  %16 = load i32, i32* %flags48, align 4, !tbaa !385
  %and49 = and i32 %16, -131073
  store i32 %and49, i32* %flags48, align 4, !tbaa !385
  br label %cleanup.cont59

out:                                              ; preds = %sw.bb, %LeafBlock6, %LeafBlock8, %LeafBlock14, %LeafBlock20, %LeafBlock1, %if.then7
  %status.0 = phi i32 [ %conv9, %if.then7 ], [ %call27, %LeafBlock20 ], [ %call27, %LeafBlock14 ], [ %call27, %LeafBlock8 ], [ %call27, %LeafBlock6 ], [ -11, %LeafBlock1 ], [ -11, %sw.bb ]
  call void @xprt_clear_connecting(%struct.rpc_xprt* %xprt2)
  call void @xprt_wake_pending_tasks(%struct.rpc_xprt* %xprt2, i32 %status.0)
  %17 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !384
  %flags52 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %17, i32 0, i32 3
  %18 = load i32, i32* %flags52, align 4, !tbaa !385
  %and53 = and i32 %18, -131073
  store i32 %and53, i32* %flags52, align 4, !tbaa !385
  br label %cleanup.cont59

cleanup.cont59:                                   ; preds = %out, %sw.bb46, %LeafBlock, %LeafBlock1
  ret void
}

declare void @delayed_work_timer_fn(i64) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_bound.168(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %0 = load volatile i64, i64* %state, align 8, !tbaa !88
  %and.i = and i64 16, %0
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  ret i32 %conv.i
}

; Function Attrs: nounwind uwtable
define internal %struct.socket* @xs_create_sock(%struct.rpc_xprt* %xprt, %struct.sock_xprt* %transport, i32 %family, i32 %type, i32 %protocol) #0 {
entry:
  %sock = alloca %struct.socket*, align 8
  %xprt_net = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 40
  %0 = load %struct.net*, %struct.net** %xprt_net, align 8, !tbaa !171
  %call = call i32 @__sock_create(%struct.net* %0, i32 %family, i32 %type, i32 %protocol, %struct.socket** %sock, i32 1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %do.body, label %if.end5

do.body:                                          ; preds = %entry
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then3, label %out

if.then3:                                         ; preds = %do.body
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %out

if.end5:                                          ; preds = %entry
  %3 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  call void @xs_reclassify_socket(i32 %family, %struct.socket* %3)
  %4 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  %call6 = call i32 @xs_bind(%struct.sock_xprt* %transport, %struct.socket* %4)
  %tobool7 = icmp ne i32 %call6, 0
  %5 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  br i1 %tobool7, label %if.then8, label %cleanup

if.then8:                                         ; preds = %if.end5
  call void @sock_release(%struct.socket* %5)
  br label %out

out:                                              ; preds = %if.then8, %if.then3, %do.body
  %err.0 = phi i32 [ %call6, %if.then8 ], [ %call, %if.then3 ], [ %call, %do.body ]
  %conv10 = sext i32 %err.0 to i64
  %call11 = call i8* @ERR_PTR.133(i64 %conv10)
  %6 = bitcast i8* %call11 to %struct.socket*
  br label %cleanup

cleanup:                                          ; preds = %out, %if.end5
  %retval.0 = phi %struct.socket* [ %6, %out ], [ %5, %if.end5 ]
  ret %struct.socket* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR.172(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_and_clear_bit.173(i32 %nr, i64* %addr) #2 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !396
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_reuse_connection(%struct.sock_xprt* %transport) #0 {
entry:
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 2
  %0 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !361
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 0
  %skc_state = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 4
  %1 = load volatile i8, i8* %skc_state, align 2, !tbaa !389
  %conv = zext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 7
  br i1 %cmp, label %land.lhs.true, label %if.end18

land.lhs.true:                                    ; preds = %entry
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 1
  %2 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !371
  %state2 = getelementptr inbounds %struct.socket, %struct.socket* %2, i32 0, i32 0
  %3 = load i32, i32* %state2, align 8, !tbaa !397
  %cmp3 = icmp eq i32 %3, 1
  br i1 %cmp3, label %if.then, label %if.end18

if.then:                                          ; preds = %land.lhs.true
  %inet5 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 2
  %4 = load %struct.sock*, %struct.sock** %inet5, align 8, !tbaa !361
  %sk_shutdown = getelementptr inbounds %struct.sock, %struct.sock* %4, i32 0, i32 20
  %bf.load = load i32, i32* %sk_shutdown, align 8
  %bf.clear = and i32 %bf.load, 3
  %cmp6 = icmp eq i32 %bf.clear, 0
  br i1 %cmp6, label %cleanup.cont, label %do.body

do.body:                                          ; preds = %if.then
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %5, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot9 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv10 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv10, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %do.body
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end18

if.end18:                                         ; preds = %if.then12, %do.body, %land.lhs.true, %entry
  %shl = shl i32 1, %conv
  %and19 = and i32 %shl, 6
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then21, label %if.end49

if.then21:                                        ; preds = %if.end18
  %inet22 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 2
  %7 = load %struct.sock*, %struct.sock** %inet22, align 8, !tbaa !361
  %sk_shutdown23 = getelementptr inbounds %struct.sock, %struct.sock* %7, i32 0, i32 20
  %bf.load24 = load i32, i32* %sk_shutdown23, align 8
  %bf.clear25 = and i32 %bf.load24, 3
  %cmp26 = icmp eq i32 %bf.clear25, 0
  br i1 %cmp26, label %cleanup.cont, label %do.body30

do.body30:                                        ; preds = %if.then21
  %8 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and31 = and i32 %8, 128
  %tobool32 = icmp ne i32 %and31, 0
  %lnot33 = xor i1 %tobool32, true
  %lnot35 = xor i1 %lnot33, true
  %lnot.ext36 = zext i1 %lnot35 to i32
  %conv37 = sext i32 %lnot.ext36 to i64
  %expval38 = call i64 @llvm.expect.i64(i64 %conv37, i64 0)
  %tobool39 = icmp ne i64 %expval38, 0
  br i1 %tobool39, label %if.then40, label %if.end49

if.then40:                                        ; preds = %do.body30
  %9 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end49

if.end49:                                         ; preds = %if.then40, %do.body30, %if.end18
  call void @xs_abort_connection(%struct.sock_xprt* %transport)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end49, %if.then21, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_tcp_finish_connecting(%struct.rpc_xprt* %xprt, %struct.socket* %sock) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  %2 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !361
  %tobool = icmp ne %struct.sock* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sk1 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %3 = load %struct.sock*, %struct.sock** %sk1, align 8, !tbaa !387
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 32
  call void @_raw_write_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  call void @xs_save_old_callbacks(%struct.sock_xprt* %1, %struct.sock* %3)
  %4 = bitcast %struct.rpc_xprt* %xprt to i8*
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 47
  store i8* %4, i8** %sk_user_data, align 8, !tbaa !398
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 57
  store void (%struct.sock*, i32)* @xs_tcp_data_ready, void (%struct.sock*, i32)** %sk_data_ready, align 8, !tbaa !399
  %sk_state_change = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 56
  store void (%struct.sock*)* @xs_tcp_state_change, void (%struct.sock*)** %sk_state_change, align 8, !tbaa !400
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 58
  store void (%struct.sock*)* @xs_tcp_write_space, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !401
  %sk_allocation = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 22
  store i32 32, i32* %sk_allocation, align 8, !tbaa !402
  %sk_userlocks = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 20
  %bf.load = load i32, i32* %sk_userlocks, align 8
  %bf.lshr = lshr i32 %bf.load, 4
  %bf.clear = and i32 %bf.lshr, 15
  %or = or i32 %bf.clear, 8
  %bf.load2 = load i32, i32* %sk_userlocks, align 8
  %bf.value = and i32 %or, 15
  %bf.shl = shl i32 %bf.value, 4
  %bf.clear3 = and i32 %bf.load2, -241
  %bf.set = or i32 %bf.clear3, %bf.shl
  store i32 %bf.set, i32* %sk_userlocks, align 8
  call void @sock_reset_flag(%struct.sock* %3, i32 4)
  %call = call %struct.tcp_sock* @tcp_sk(%struct.sock* %3)
  %linger2 = getelementptr inbounds %struct.tcp_sock, %struct.tcp_sock* %call, i32 0, i32 77
  store i32 0, i32* %linger2, align 8, !tbaa !403
  %call4 = call %struct.tcp_sock* @tcp_sk(%struct.sock* %3)
  %nonagle = getelementptr inbounds %struct.tcp_sock, %struct.tcp_sock* %call4, i32 0, i32 24
  %bf.load5 = load i8, i8* %nonagle, align 1
  %bf.clear6 = and i8 %bf.load5, 15
  %conv = zext i8 %bf.clear6 to i32
  %or7 = or i32 %conv, 1
  %conv8 = trunc i32 %or7 to i8
  %bf.load9 = load i8, i8* %nonagle, align 1
  %bf.value10 = and i8 %conv8, 15
  %bf.clear11 = and i8 %bf.load9, -16
  %bf.set12 = or i8 %bf.clear11, %bf.value10
  store i8 %bf.set12, i8* %nonagle, align 1
  call void @xprt_clear_connected.176(%struct.rpc_xprt* %xprt)
  %sock13 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  store %struct.socket* %sock, %struct.socket** %sock13, align 8, !tbaa !371
  %inet14 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  store %struct.sock* %3, %struct.sock** %inet14, align 8, !tbaa !361
  %sk_callback_lock15 = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 32
  call void @_raw_write_unlock_bh(%struct.rwlock_t* %sk_callback_lock15)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call16 = call i32 @xprt_bound.168(%struct.rpc_xprt* %xprt)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.end19, label %out

if.end19:                                         ; preds = %if.end
  call void @xs_set_memalloc(%struct.rpc_xprt* %xprt)
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %connect_count = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat, i32 0, i32 1
  %5 = load i64, i64* %connect_count, align 8, !tbaa !315
  %inc = add i64 %5, 1
  store i64 %inc, i64* %connect_count, align 8, !tbaa !315
  %6 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %stat20 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %connect_start = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat20, i32 0, i32 2
  store i64 %6, i64* %connect_start, align 8, !tbaa !312
  %call21 = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt)
  %addrlen = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 4
  %7 = load i64, i64* %addrlen, align 8, !tbaa !188
  %conv22 = trunc i64 %7 to i32
  %call23 = call i32 @kernel_connect(%struct.socket* %sock, %struct.sockaddr* %call21, i32 %conv22, i32 2048)
  %Pivot = icmp slt i32 %call23, 0
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end19
  %SwitchLeaf2 = icmp eq i32 %call23, 0
  br i1 %SwitchLeaf2, label %sw.bb, label %out

LeafBlock:                                        ; preds = %if.end19
  %SwitchLeaf = icmp eq i32 %call23, -115
  br i1 %SwitchLeaf, label %sw.bb, label %out

sw.bb:                                            ; preds = %LeafBlock, %LeafBlock1
  %connect_cookie = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 24
  %8 = load i32, i32* %connect_cookie, align 8, !tbaa !310
  %inc24 = add i32 %8, 1
  store i32 %inc24, i32* %connect_cookie, align 8, !tbaa !310
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  %9 = load i64, i64* %reestablish_timeout, align 8, !tbaa !367
  %cmp = icmp ult i64 %9, 750
  br i1 %cmp, label %if.then26, label %out

if.then26:                                        ; preds = %sw.bb
  %reestablish_timeout27 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  store i64 750, i64* %reestablish_timeout27, align 8, !tbaa !367
  br label %out

out:                                              ; preds = %if.then26, %sw.bb, %LeafBlock, %LeafBlock1, %if.end
  %ret.0 = phi i32 [ -107, %if.end ], [ %call23, %LeafBlock ], [ %call23, %LeafBlock1 ], [ %call23, %sw.bb ], [ %call23, %if.then26 ]
  ret i32 %ret.0
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_force_close(%struct.rpc_xprt* %xprt) #0 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 8, i64* %state) #7, !srcloc !373
  call void @xprt_force_disconnect(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_clear_connecting(%struct.rpc_xprt* %xprt) #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !417
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 2, i64* %state) #7, !srcloc !386
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !418
  ret void
}

declare void @_raw_write_lock_bh(%struct.rwlock_t*) #4 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal void @xs_save_old_callbacks(%struct.sock_xprt* %transport, %struct.sock* %sk) #0 {
entry:
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 57
  %0 = load void (%struct.sock*, i32)*, void (%struct.sock*, i32)** %sk_data_ready, align 8, !tbaa !399
  %old_data_ready = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 15
  store void (%struct.sock*, i32)* %0, void (%struct.sock*, i32)** %old_data_ready, align 8, !tbaa !419
  %sk_state_change = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 56
  %1 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_state_change, align 8, !tbaa !400
  %old_state_change = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 16
  store void (%struct.sock*)* %1, void (%struct.sock*)** %old_state_change, align 8, !tbaa !420
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 58
  %2 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !401
  %old_write_space = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 17
  store void (%struct.sock*)* %2, void (%struct.sock*)** %old_write_space, align 8, !tbaa !421
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_data_ready(%struct.sock* %sk, i32 %bytes) #0 {
entry:
  %rd_desc = alloca %struct.read_descriptor_t, align 8
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 32
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %call3 = call %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk)
  %tobool4 = icmp ne %struct.rpc_xprt* %call3, null
  br i1 %tobool4, label %if.end6, label %out

if.end6:                                          ; preds = %do.end
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call3, i32 0, i32 23
  %2 = load i64, i64* %reestablish_timeout, align 8, !tbaa !367
  %tobool7 = icmp ne i64 %2, 0
  br i1 %tobool7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end6
  %reestablish_timeout9 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call3, i32 0, i32 23
  store i64 0, i64* %reestablish_timeout9, align 8, !tbaa !367
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end6
  %3 = bitcast %struct.rpc_xprt* %call3 to i8*
  %arg = getelementptr inbounds %struct.read_descriptor_t, %struct.read_descriptor_t* %rd_desc, i32 0, i32 2
  %data = bitcast %union.anon.57* %arg to i8**
  store i8* %3, i8** %data, align 8, !tbaa !166
  br label %do.body11

do.body11:                                        ; preds = %do.body11, %if.end10
  %count = getelementptr inbounds %struct.read_descriptor_t, %struct.read_descriptor_t* %rd_desc, i32 0, i32 1
  store i64 65536, i64* %count, align 8, !tbaa !422
  %call12 = call i32 @tcp_read_sock(%struct.sock* %sk, %struct.read_descriptor_t* %rd_desc, i32 (%struct.read_descriptor_t*, %struct.sk_buff*, i32, i64)* @xs_tcp_data_recv)
  %cmp = icmp sgt i32 %call12, 0
  br i1 %cmp, label %do.body11, label %out

out:                                              ; preds = %do.body11, %do.end
  %sk_callback_lock16 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 32
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock16)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_state_change(%struct.sock* %sk) #0 {
entry:
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 32
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %call = call %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk)
  %tobool = icmp ne %struct.rpc_xprt* %call, null
  br i1 %tobool, label %do.body, label %out

do.body:                                          ; preds = %entry
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 128
  %tobool1 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.body7

if.then4:                                         ; preds = %do.body
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.body7

do.body7:                                         ; preds = %if.then4, %do.body
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and8 = and i32 %2, 128
  %tobool9 = icmp ne i32 %and8, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %if.then17, label %do.end27

if.then17:                                        ; preds = %do.body7
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_state = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 4
  %3 = load volatile i8, i8* %skc_state, align 2, !tbaa !389
  %call19 = call i32 @xprt_connected.142(%struct.rpc_xprt* %call)
  call void @sock_flag(%struct.sock* %sk, i32 0)
  call void @sock_flag(%struct.sock* %sk, i32 8)
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end27

do.end27:                                         ; preds = %if.then17, %do.body7
  %__sk_common28 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_state29 = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common28, i32 0, i32 4
  %5 = load volatile i8, i8* %skc_state29, align 2, !tbaa !389
  %conv30 = zext i8 %5 to i32
  %Pivot14 = icmp slt i32 %conv30, 8
  br i1 %Pivot14, label %NodeBlock3, label %NodeBlock11

NodeBlock11:                                      ; preds = %do.end27
  %Pivot12 = icmp slt i32 %conv30, 9
  br i1 %Pivot12, label %sw.bb40, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %conv30, 11
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %conv30, 11
  br i1 %SwitchLeaf8, label %sw.bb44, label %out

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %conv30, 9
  br i1 %SwitchLeaf6, label %sw.bb50, label %out

NodeBlock3:                                       ; preds = %do.end27
  %Pivot4 = icmp slt i32 %conv30, 4
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %conv30, 7
  br i1 %Pivot, label %LeafBlock1, label %sw.bb54

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv30, 4
  br i1 %SwitchLeaf2, label %sw.bb36, label %out

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %conv30, 1
  br i1 %SwitchLeaf, label %sw.bb, label %out

sw.bb:                                            ; preds = %LeafBlock
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 29
  call void @spin_lock.177(%struct.spinlock* %transport_lock)
  %call31 = call i32 @xprt_test_and_set_connected(%struct.rpc_xprt* %call)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %if.end34, label %if.then33

if.then33:                                        ; preds = %sw.bb
  %6 = bitcast %struct.rpc_xprt* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 0
  %7 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %7, i32 0, i32 6
  store i32 0, i32* %tcp_offset, align 4, !tbaa !424
  %tcp_reclen = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %7, i32 0, i32 7
  store i32 0, i32* %tcp_reclen, align 8, !tbaa !425
  %tcp_copied = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %7, i32 0, i32 8
  store i64 0, i64* %tcp_copied, align 8, !tbaa !426
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %7, i32 0, i32 9
  store i64 6, i64* %tcp_flags, align 8, !tbaa !427
  call void @xprt_wake_pending_tasks(%struct.rpc_xprt* %call, i32 -11)
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %sw.bb
  %transport_lock35 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 29
  call void @spin_unlock.178(%struct.spinlock* %transport_lock35)
  br label %out

sw.bb36:                                          ; preds = %LeafBlock1
  %connect_cookie = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 24
  %8 = load i32, i32* %connect_cookie, align 8, !tbaa !310
  %inc = add i32 %8, 1
  store i32 %inc, i32* %connect_cookie, align 8, !tbaa !310
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 0, i64* %reestablish_timeout, align 8, !tbaa !367
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 6, i64* %state) #7, !srcloc !373
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !428
  %state37 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state37, i32 1, i64* %state37) #7, !srcloc !386
  %state38 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state38, i32 3, i64* %state38) #7, !srcloc !386
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !429
  %9 = load i32, i32* @xs_tcp_fin_timeout, align 4, !tbaa !49
  %conv39 = zext i32 %9 to i64
  call void @xs_tcp_schedule_linger_timeout(%struct.rpc_xprt* %call, i64 %conv39)
  br label %out

sw.bb40:                                          ; preds = %NodeBlock11
  %connect_cookie41 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 24
  %10 = load i32, i32* %connect_cookie41, align 8, !tbaa !310
  %inc42 = add i32 %10, 1
  store i32 %inc42, i32* %connect_cookie41, align 8, !tbaa !310
  %state43 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state43, i32 1, i64* %state43) #7, !srcloc !386
  call void @xs_tcp_force_close(%struct.rpc_xprt* %call)
  br label %sw.bb44

sw.bb44:                                          ; preds = %sw.bb40, %LeafBlock7
  %reestablish_timeout45 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  %11 = load i64, i64* %reestablish_timeout45, align 8, !tbaa !367
  %cmp = icmp ult i64 %11, 750
  br i1 %cmp, label %if.then47, label %out

if.then47:                                        ; preds = %sw.bb44
  %reestablish_timeout48 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 750, i64* %reestablish_timeout48, align 8, !tbaa !367
  br label %out

sw.bb50:                                          ; preds = %LeafBlock5
  %state51 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %state51, i32 6, i64* %state51) #7, !srcloc !373
  %12 = load i32, i32* @xs_tcp_fin_timeout, align 4, !tbaa !49
  %conv52 = zext i32 %12 to i64
  call void @xs_tcp_schedule_linger_timeout(%struct.rpc_xprt* %call, i64 %conv52)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !430
  %state53 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state53, i32 1, i64* %state53) #7, !srcloc !386
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !431
  br label %out

sw.bb54:                                          ; preds = %NodeBlock
  call void @xs_tcp_cancel_linger_timeout(%struct.rpc_xprt* %call)
  call void @xs_sock_mark_closed(%struct.rpc_xprt* %call)
  br label %out

out:                                              ; preds = %sw.bb54, %sw.bb50, %if.then47, %sw.bb44, %sw.bb36, %if.end34, %LeafBlock, %LeafBlock1, %LeafBlock5, %LeafBlock7, %entry
  %sk_callback_lock55 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 32
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock55)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_write_space(%struct.sock* %sk) #0 {
entry:
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 32
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %call = call i32 @sk_stream_wspace(%struct.sock* %sk)
  %call1 = call i32 @sk_stream_min_wspace(%struct.sock* %sk)
  %cmp = icmp sge i32 %call, %call1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @xs_write_space(%struct.sock* %sk)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sk_callback_lock2 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 32
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock2)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sock_reset_flag(%struct.sock* %sk, i32 %flag) #2 {
entry:
  %sk_flags = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 12
  call void @__clear_bit(i32 %flag, i64* %sk_flags)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.tcp_sock* @tcp_sk(%struct.sock* %sk) #2 {
entry:
  %0 = bitcast %struct.sock* %sk to %struct.tcp_sock*
  ret %struct.tcp_sock* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_clear_connected.176(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 1, i64* %state) #7, !srcloc !386
  ret void
}

declare void @_raw_write_unlock_bh(%struct.rwlock_t*) #4 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @__clear_bit(i32 %nr, i64* %addr) #2 {
entry:
  call void asm sideeffect "btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !432
  ret void
}

declare void @_raw_read_lock_bh(%struct.rwlock_t*) #4 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @sk_stream_wspace(%struct.sock* %sk) #2 {
entry:
  %sk_sndbuf = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 18
  %0 = load i32, i32* %sk_sndbuf, align 8, !tbaa !433
  %sk_wmem_queued = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 21
  %1 = load i32, i32* %sk_wmem_queued, align 4, !tbaa !434
  %sub = sub nsw i32 %0, %1
  ret i32 %sub
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @sk_stream_min_wspace(%struct.sock* %sk) #2 {
entry:
  %sk_wmem_queued = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 21
  %0 = load i32, i32* %sk_wmem_queued, align 4, !tbaa !434
  %shr = ashr i32 %0, 1
  ret i32 %shr
}

; Function Attrs: nounwind uwtable
define internal void @xs_write_space(%struct.sock* %sk) #0 {
entry:
  %sk_socket = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 46
  %0 = load %struct.socket*, %struct.socket** %sk_socket, align 8, !tbaa !435
  %tobool = icmp ne %struct.socket* %0, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %0, i32 0, i32 2
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags, i32 2, i64* %flags) #7, !srcloc !386
  %call = call %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk)
  %tobool4 = icmp ne %struct.rpc_xprt* %call, null
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %conv11 = sext i32 %lnot.ext10 to i64
  %expval12 = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool13 = icmp ne i64 %expval12, 0
  br i1 %tobool13, label %cleanup.cont, label %if.end15

if.end15:                                         ; preds = %if.end
  %flags16 = getelementptr inbounds %struct.socket, %struct.socket* %0, i32 0, i32 2
  %call17 = call i32 @test_and_clear_bit.173(i32 0, i64* %flags16)
  %cmp = icmp eq i32 %call17, 0
  br i1 %cmp, label %cleanup.cont, label %if.end20

if.end20:                                         ; preds = %if.end15
  call void @xprt_write_space(%struct.rpc_xprt* %call)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end20, %if.end15, %if.end, %entry
  ret void
}

declare void @_raw_read_unlock_bh(%struct.rwlock_t*) #4 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk) #2 {
entry:
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 47
  %0 = load i8*, i8** %sk_user_data, align 8, !tbaa !398
  %1 = bitcast i8* %0 to %struct.rpc_xprt*
  ret %struct.rpc_xprt* %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sock_flag(%struct.sock* %sk, i32 %flag) #2 {
entry:
  %sk_flags = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 12
  call void @variable_test_bit.180(i32 %flag, i64* %sk_flags)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock.177(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_test_and_set_connected(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @test_and_set_bit.161(i32 1, i64* %state)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock.178(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_schedule_linger_timeout(%struct.rpc_xprt* %xprt, i64 %timeout) #0 {
entry:
  %call = call i32 @xprt_test_and_set_connecting.179(%struct.rpc_xprt* %xprt)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 7, i64* %state) #7, !srcloc !373
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %2 = load %struct.workqueue_struct*, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !28
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  call void @queue_delayed_work(%struct.workqueue_struct* %2, %struct.delayed_work* %connect_worker, i64 %timeout)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_cancel_linger_timeout(%struct.rpc_xprt* %xprt) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %2 = load volatile i64, i64* %state, align 8, !tbaa !88
  %and.i = and i64 128, %2
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %lor.lhs.false, label %cleanup.cont

lor.lhs.false:                                    ; preds = %entry
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  %call4 = call zeroext i1 @cancel_delayed_work(%struct.delayed_work* %connect_worker)
  br i1 %call4, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %lor.lhs.false
  %state5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state5, i32 7, i64* %state5) #7, !srcloc !386
  call void @xprt_clear_connecting(%struct.rpc_xprt* %xprt)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_sock_mark_closed(%struct.rpc_xprt* %xprt) #0 {
entry:
  call void @xs_sock_reset_connection_flags(%struct.rpc_xprt* %xprt)
  call void @xprt_disconnect_done(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_sock_reset_connection_flags(%struct.rpc_xprt* %xprt) #0 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !436
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 7, i64* %state) #7, !srcloc !386
  %state1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state1, i32 8, i64* %state1) #7, !srcloc !386
  %state2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state2, i32 3, i64* %state2) #7, !srcloc !386
  %state3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state3, i32 6, i64* %state3) #7, !srcloc !386
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !437
  ret void
}

declare zeroext i1 @cancel_delayed_work(%struct.delayed_work*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_test_and_set_connecting.179(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @test_and_set_bit.161(i32 2, i64* %state)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_delayed_work(%struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay) #2 {
entry:
  %call = call zeroext i1 @queue_delayed_work_on(i32 4096, %struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay)
  ret void
}

declare zeroext i1 @queue_delayed_work_on(i32, %struct.workqueue_struct*, %struct.delayed_work*, i64) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @variable_test_bit.180(i32 %nr, i64* %addr) #2 {
entry:
  %0 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr) #7, !srcloc !438
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_tcp_data_recv(%struct.read_descriptor_t* %rd_desc, %struct.sk_buff* %skb, i32 %offset, i64 %len) #0 {
entry:
  %desc = alloca %struct.xdr_skb_reader, align 8
  %arg = getelementptr inbounds %struct.read_descriptor_t, %struct.read_descriptor_t* %rd_desc, i32 0, i32 2
  %data = bitcast %union.anon.57* %arg to i8**
  %0 = load i8*, i8** %data, align 8, !tbaa !166
  %1 = bitcast i8* %0 to %struct.rpc_xprt*
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %skb1 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 0
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb1, align 8, !tbaa !345
  %offset2 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  store i32 %offset, i32* %offset2, align 8, !tbaa !347
  %count = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  store i64 %len, i64* %count, align 8, !tbaa !350
  %csum = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 3
  store i32 0, i32* %csum, align 8, !tbaa !352
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %4, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  br label %do.body5

do.body5:                                         ; preds = %do.cond25, %do.end
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 9
  %6 = load i64, i64* %tcp_flags, align 8, !tbaa !427
  %and6 = and i64 %6, 2
  %tobool7 = icmp ne i64 %and6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %do.body5
  call void @xs_tcp_read_fraghdr(%struct.rpc_xprt* %1, %struct.xdr_skb_reader* %desc)
  br label %do.cond25

if.end9:                                          ; preds = %do.body5
  %tcp_flags10 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 9
  %7 = load i64, i64* %tcp_flags10, align 8, !tbaa !427
  %and11 = and i64 %7, 4
  %tobool12 = icmp ne i64 %and11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  call void @xs_tcp_read_xid(%struct.sock_xprt* %3, %struct.xdr_skb_reader* %desc)
  br label %do.cond25

if.end14:                                         ; preds = %if.end9
  %tcp_flags15 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 9
  %8 = load i64, i64* %tcp_flags15, align 8, !tbaa !427
  %and16 = and i64 %8, 16
  %tobool17 = icmp ne i64 %and16, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end14
  call void @xs_tcp_read_calldir(%struct.sock_xprt* %3, %struct.xdr_skb_reader* %desc)
  br label %do.cond25

if.end19:                                         ; preds = %if.end14
  %tcp_flags20 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 9
  %9 = load i64, i64* %tcp_flags20, align 8, !tbaa !427
  %and21 = and i64 %9, 8
  %tobool22 = icmp ne i64 %and21, 0
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end19
  call void @xs_tcp_read_data(%struct.rpc_xprt* %1, %struct.xdr_skb_reader* %desc)
  br label %do.cond25

if.end24:                                         ; preds = %if.end19
  call void @xs_tcp_read_discard(%struct.sock_xprt* %3, %struct.xdr_skb_reader* %desc)
  br label %do.cond25

do.cond25:                                        ; preds = %if.end24, %if.then23, %if.then18, %if.then13, %if.then8
  %count26 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %10 = load i64, i64* %count26, align 8, !tbaa !350
  %tobool27 = icmp ne i64 %10, 0
  br i1 %tobool27, label %do.body5, label %do.body29

do.body29:                                        ; preds = %do.cond25
  %11 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and30 = and i32 %11, 128
  %tobool31 = icmp ne i32 %and30, 0
  %lnot32 = xor i1 %tobool31, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  %conv36 = sext i32 %lnot.ext35 to i64
  %expval37 = call i64 @llvm.expect.i64(i64 %conv36, i64 0)
  %tobool38 = icmp ne i64 %expval37, 0
  br i1 %tobool38, label %if.then39, label %do.end43

if.then39:                                        ; preds = %do.body29
  %12 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end43

do.end43:                                         ; preds = %if.then39, %do.body29
  %count44 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %13 = load i64, i64* %count44, align 8, !tbaa !350
  %sub = sub i64 %len, %13
  %conv45 = trunc i64 %sub to i32
  ret i32 %conv45
}

declare i32 @tcp_read_sock(%struct.sock*, %struct.read_descriptor_t*, i32 (%struct.read_descriptor_t*, %struct.sk_buff*, i32, i64)*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_tcp_read_fraghdr(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc) #2 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %tcp_fraghdr = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 3
  %2 = bitcast i32* %tcp_fraghdr to i8*
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %3 = load i32, i32* %tcp_offset, align 4, !tbaa !424
  %idx.ext = zext i32 %3 to i64
  %add.ptr1 = getelementptr inbounds i8, i8* %2, i64 %idx.ext
  %tcp_offset2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %4 = load i32, i32* %tcp_offset2, align 4, !tbaa !424
  %conv = zext i32 %4 to i64
  %sub = sub i64 4, %conv
  %call = call i64 @xdr_skb_read_bits(%struct.xdr_skb_reader* %desc, i8* %add.ptr1, i64 %sub)
  %tcp_offset3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %5 = load i32, i32* %tcp_offset3, align 4, !tbaa !424
  %conv4 = zext i32 %5 to i64
  %add = add i64 %conv4, %call
  %conv5 = trunc i64 %add to i32
  store i32 %conv5, i32* %tcp_offset3, align 4, !tbaa !424
  %cmp = icmp ne i64 %call, %sub
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %tcp_fraghdr7 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 3
  %6 = load i32, i32* %tcp_fraghdr7, align 8, !tbaa !439
  %call8 = call i32 @__fswab32.138(i32 %6) #3
  %tcp_reclen = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  store i32 %call8, i32* %tcp_reclen, align 8, !tbaa !425
  %tcp_reclen9 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %7 = load i32, i32* %tcp_reclen9, align 8, !tbaa !425
  %and = and i32 %7, -2147483648
  %tobool = icmp ne i32 %and, 0
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %8 = load i64, i64* %tcp_flags, align 8, !tbaa !427
  %and12 = and i64 %8, -2
  %or = or i64 %8, 1
  %and12.sink = select i1 %tobool, i64 %or, i64 %and12
  store i64 %and12.sink, i64* %tcp_flags, align 8, !tbaa !427
  %tcp_reclen14 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %9 = load i32, i32* %tcp_reclen14, align 8, !tbaa !425
  %and15 = and i32 %9, 2147483647
  store i32 %and15, i32* %tcp_reclen14, align 8, !tbaa !425
  %tcp_flags16 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %10 = load i64, i64* %tcp_flags16, align 8, !tbaa !427
  %and17 = and i64 %10, -3
  store i64 %and17, i64* %tcp_flags16, align 8, !tbaa !427
  %tcp_offset18 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  store i32 0, i32* %tcp_offset18, align 4, !tbaa !424
  %tcp_reclen19 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %11 = load i32, i32* %tcp_reclen19, align 8, !tbaa !425
  %cmp20 = icmp ult i32 %11, 8
  %lnot = xor i1 %cmp20, true
  %lnot22 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot22 to i32
  %conv23 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool24 = icmp ne i64 %expval, 0
  %12 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and26 = and i32 %12, 128
  %tobool27 = icmp ne i32 %and26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool24, label %do.body, label %do.body39

do.body:                                          ; preds = %if.end
  br i1 %tobool34, label %if.then35, label %do.end

if.then35:                                        ; preds = %do.body
  %13 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then35, %do.body
  call void @xs_tcp_force_close(%struct.rpc_xprt* %xprt)
  br label %cleanup.cont

do.body39:                                        ; preds = %if.end
  br i1 %tobool34, label %if.then49, label %cleanup.cont

if.then49:                                        ; preds = %do.body39
  %14 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then49, %do.body39, %do.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_tcp_read_xid(%struct.sock_xprt* %transport, %struct.xdr_skb_reader* %desc) #2 {
entry:
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %0 = load i32, i32* %tcp_offset, align 4, !tbaa !424
  %conv = zext i32 %0 to i64
  %sub = sub i64 4, %conv
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv2 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv2, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tcp_xid = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 4
  %3 = bitcast i32* %tcp_xid to i8*
  %tcp_offset4 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %4 = load i32, i32* %tcp_offset4, align 4, !tbaa !424
  %idx.ext = zext i32 %4 to i64
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 %idx.ext
  %call5 = call i64 @xdr_skb_read_bits(%struct.xdr_skb_reader* %desc, i8* %add.ptr, i64 %sub)
  %tcp_offset6 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %5 = load i32, i32* %tcp_offset6, align 4, !tbaa !424
  %conv7 = zext i32 %5 to i64
  %add = add i64 %conv7, %call5
  %conv8 = trunc i64 %add to i32
  store i32 %conv8, i32* %tcp_offset6, align 4, !tbaa !424
  %cmp = icmp ne i64 %call5, %sub
  br i1 %cmp, label %cleanup.cont, label %if.end11

if.end11:                                         ; preds = %do.end
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %6 = load i64, i64* %tcp_flags, align 8, !tbaa !427
  %and12 = and i64 %6, -5
  store i64 %and12, i64* %tcp_flags, align 8, !tbaa !427
  %tcp_flags13 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %7 = load i64, i64* %tcp_flags13, align 8, !tbaa !427
  %or = or i64 %7, 16
  store i64 %or, i64* %tcp_flags13, align 8, !tbaa !427
  %tcp_copied = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 8
  store i64 4, i64* %tcp_copied, align 8, !tbaa !426
  %8 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and15 = and i32 %8, 128
  %tobool16 = icmp ne i32 %and15, 0
  %lnot17 = xor i1 %tobool16, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool23 = icmp ne i64 %expval22, 0
  br i1 %tobool23, label %if.then24, label %do.end33

if.then24:                                        ; preds = %if.end11
  %9 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end33

do.end33:                                         ; preds = %if.then24, %if.end11
  call void @xs_tcp_check_fraghdr(%struct.sock_xprt* %transport)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %do.end33, %do.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_tcp_read_calldir(%struct.sock_xprt* %transport, %struct.xdr_skb_reader* %desc) #2 {
entry:
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %0 = load i32, i32* %tcp_offset, align 4, !tbaa !424
  %conv = zext i32 %0 to i64
  %sub = sub i64 %conv, 4
  %conv1 = trunc i64 %sub to i32
  %conv2 = zext i32 %conv1 to i64
  %sub3 = sub i64 4, %conv2
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv5, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tcp_calldir = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 5
  %3 = bitcast i32* %tcp_calldir to i8*
  %idx.ext = zext i32 %conv1 to i64
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 %idx.ext
  %call7 = call i64 @xdr_skb_read_bits(%struct.xdr_skb_reader* %desc, i8* %add.ptr, i64 %sub3)
  %tcp_offset8 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %4 = load i32, i32* %tcp_offset8, align 4, !tbaa !424
  %conv9 = zext i32 %4 to i64
  %add = add i64 %conv9, %call7
  %conv10 = trunc i64 %add to i32
  store i32 %conv10, i32* %tcp_offset8, align 4, !tbaa !424
  %cmp = icmp ne i64 %call7, %sub3
  br i1 %cmp, label %cleanup.cont, label %if.end13

if.end13:                                         ; preds = %do.end
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %5 = load i64, i64* %tcp_flags, align 8, !tbaa !427
  %and14 = and i64 %5, -17
  store i64 %and14, i64* %tcp_flags, align 8, !tbaa !427
  %tcp_calldir15 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 5
  %6 = load i32, i32* %tcp_calldir15, align 8, !tbaa !440
  %call16 = call i32 @__fswab32.138(i32 %6) #3
  %Pivot = icmp slt i32 %call16, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end13
  %SwitchLeaf2 = icmp eq i32 %call16, 1
  br i1 %SwitchLeaf2, label %sw.bb, label %do.body29

LeafBlock:                                        ; preds = %if.end13
  %SwitchLeaf = icmp eq i32 %call16, 0
  br i1 %SwitchLeaf, label %sw.bb22, label %do.body29

sw.bb:                                            ; preds = %LeafBlock1
  %tcp_flags17 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %7 = load i64, i64* %tcp_flags17, align 8, !tbaa !427
  %or = or i64 %7, 32
  store i64 %or, i64* %tcp_flags17, align 8, !tbaa !427
  %tcp_flags18 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %8 = load i64, i64* %tcp_flags18, align 8, !tbaa !427
  %or19 = or i64 %8, 8
  store i64 %or19, i64* %tcp_flags18, align 8, !tbaa !427
  %tcp_flags20 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %9 = load i64, i64* %tcp_flags20, align 8, !tbaa !427
  %or21 = or i64 %9, 64
  store i64 %or21, i64* %tcp_flags20, align 8, !tbaa !427
  br label %sw.epilog

sw.bb22:                                          ; preds = %LeafBlock
  %tcp_flags23 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %10 = load i64, i64* %tcp_flags23, align 8, !tbaa !427
  %or24 = or i64 %10, 32
  store i64 %or24, i64* %tcp_flags23, align 8, !tbaa !427
  %tcp_flags25 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %11 = load i64, i64* %tcp_flags25, align 8, !tbaa !427
  %or26 = or i64 %11, 8
  store i64 %or26, i64* %tcp_flags25, align 8, !tbaa !427
  %tcp_flags27 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %12 = load i64, i64* %tcp_flags27, align 8, !tbaa !427
  %and28 = and i64 %12, -65
  store i64 %and28, i64* %tcp_flags27, align 8, !tbaa !427
  br label %sw.epilog

do.body29:                                        ; preds = %LeafBlock, %LeafBlock1
  %13 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and30 = and i32 %13, 128
  %tobool31 = icmp ne i32 %and30, 0
  %lnot32 = xor i1 %tobool31, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  %conv36 = sext i32 %lnot.ext35 to i64
  %expval37 = call i64 @llvm.expect.i64(i64 %conv36, i64 0)
  %tobool38 = icmp ne i64 %expval37, 0
  br i1 %tobool38, label %if.then39, label %do.end43

if.then39:                                        ; preds = %do.body29
  %14 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end43

do.end43:                                         ; preds = %if.then39, %do.body29
  %xprt = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  call void @xs_tcp_force_close(%struct.rpc_xprt* %xprt)
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end43, %sw.bb22, %sw.bb
  call void @xs_tcp_check_fraghdr(%struct.sock_xprt* %transport)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %sw.epilog, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_read_data(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %call = call i32 @_xs_tcp_read_data(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @xs_tcp_check_fraghdr(%struct.sock_xprt* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %2 = load i64, i64* %tcp_flags, align 8, !tbaa !427
  %and = and i64 %2, -9
  store i64 %and, i64* %tcp_flags, align 8, !tbaa !427
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_tcp_read_discard(%struct.sock_xprt* %transport, %struct.xdr_skb_reader* %desc) #2 {
entry:
  %tcp_reclen = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 7
  %0 = load i32, i32* %tcp_reclen, align 8, !tbaa !425
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %1 = load i32, i32* %tcp_offset, align 4, !tbaa !424
  %sub = sub i32 %0, %1
  %conv = zext i32 %sub to i64
  %count = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %2 = load i64, i64* %count, align 8, !tbaa !350
  %cmp = icmp ugt i64 %conv, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %count2 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %3 = load i64, i64* %count2, align 8, !tbaa !350
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %len.0 = phi i64 [ %3, %if.then ], [ %conv, %entry ]
  %count3 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %4 = load i64, i64* %count3, align 8, !tbaa !350
  %sub4 = sub i64 %4, %len.0
  store i64 %sub4, i64* %count3, align 8, !tbaa !350
  %offset = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  %5 = load i32, i32* %offset, align 8, !tbaa !347
  %conv5 = zext i32 %5 to i64
  %add = add i64 %conv5, %len.0
  %conv6 = trunc i64 %add to i32
  store i32 %conv6, i32* %offset, align 8, !tbaa !347
  %tcp_offset7 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %6 = load i32, i32* %tcp_offset7, align 4, !tbaa !424
  %conv8 = zext i32 %6 to i64
  %add9 = add i64 %conv8, %len.0
  %conv10 = trunc i64 %add9 to i32
  store i32 %conv10, i32* %tcp_offset7, align 4, !tbaa !424
  %7 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %7, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv12 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv12, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  br i1 %tobool13, label %if.then14, label %do.end

if.then14:                                        ; preds = %if.end
  %8 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then14, %if.end
  call void @xs_tcp_check_fraghdr(%struct.sock_xprt* %transport)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_check_fraghdr(%struct.sock_xprt* %transport) #0 {
entry:
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %0 = load i32, i32* %tcp_offset, align 4, !tbaa !424
  %tcp_reclen = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 7
  %1 = load i32, i32* %tcp_reclen, align 8, !tbaa !425
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %2 = load i64, i64* %tcp_flags, align 8, !tbaa !427
  %or = or i64 %2, 2
  store i64 %or, i64* %tcp_flags, align 8, !tbaa !427
  %tcp_offset1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  store i32 0, i32* %tcp_offset1, align 4, !tbaa !424
  %tcp_flags2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %3 = load i64, i64* %tcp_flags2, align 8, !tbaa !427
  %and = and i64 %3, 1
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then3, label %if.end8

if.then3:                                         ; preds = %if.then
  %tcp_flags4 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %4 = load i64, i64* %tcp_flags4, align 8, !tbaa !427
  %and5 = and i64 %4, -9
  store i64 %and5, i64* %tcp_flags4, align 8, !tbaa !427
  %tcp_flags6 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %5 = load i64, i64* %tcp_flags6, align 8, !tbaa !427
  %or7 = or i64 %5, 4
  store i64 %or7, i64* %tcp_flags6, align 8, !tbaa !427
  %tcp_copied = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 8
  store i64 0, i64* %tcp_copied, align 8, !tbaa !426
  br label %if.end8

if.end8:                                          ; preds = %if.then3, %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @_xs_tcp_read_data(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc) #2 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %2 = load i64, i64* %tcp_flags, align 8, !tbaa !427
  %and = and i64 %2, 64
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call = call i32 @xs_tcp_read_reply(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call1 = call i32 @xs_tcp_read_callback(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call, %cond.true ], [ %call1, %cond.false ]
  ret i32 %cond
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xs_tcp_read_reply(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc) #2 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_lock.177(%struct.spinlock* %transport_lock)
  %tcp_xid4 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 4
  %4 = load i32, i32* %tcp_xid4, align 4, !tbaa !441
  %call5 = call %struct.rpc_rqst* @xprt_lookup_rqst(%struct.rpc_xprt* %xprt, i32 %4)
  %tobool6 = icmp ne %struct.rpc_rqst* %call5, null
  br i1 %tobool6, label %if.end26, label %do.body8

do.body8:                                         ; preds = %do.end
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and9 = and i32 %5, 128
  %tobool10 = icmp ne i32 %and9, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %if.then18, label %do.end24

if.then18:                                        ; preds = %do.body8
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end24

do.end24:                                         ; preds = %if.then18, %do.body8
  %transport_lock25 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_unlock.178(%struct.spinlock* %transport_lock25)
  br label %cleanup

if.end26:                                         ; preds = %do.end
  call void @xs_tcp_read_common(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc, %struct.rpc_rqst* %call5)
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %7 = load i64, i64* %tcp_flags, align 8, !tbaa !427
  %and27 = and i64 %7, 8
  %tobool28 = icmp ne i64 %and27, 0
  br i1 %tobool28, label %if.end31, label %if.then29

if.then29:                                        ; preds = %if.end26
  %rq_task = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call5, i32 0, i32 3
  %8 = load %struct.rpc_task*, %struct.rpc_task** %rq_task, align 8, !tbaa !280
  %tcp_copied = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %9 = load i64, i64* %tcp_copied, align 8, !tbaa !426
  %conv30 = trunc i64 %9 to i32
  call void @xprt_complete_rqst(%struct.rpc_task* %8, i32 %conv30)
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end26
  %transport_lock32 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_unlock.178(%struct.spinlock* %transport_lock32)
  br label %cleanup

cleanup:                                          ; preds = %if.end31, %do.end24
  %retval.0 = phi i32 [ 0, %if.end31 ], [ -1, %do.end24 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xs_tcp_read_callback(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc) #2 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %call = call %struct.rpc_rqst* @xprt_alloc_bc_request(%struct.rpc_xprt* %xprt)
  %cmp = icmp eq %struct.rpc_rqst* %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = call i32 (i8*, ...) @printk(i8* null)
  call void @xprt_force_disconnect(%struct.rpc_xprt* %xprt)
  br label %cleanup

if.end:                                           ; preds = %entry
  %tcp_xid = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 4
  %3 = load i32, i32* %tcp_xid, align 4, !tbaa !441
  %rq_xid = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call, i32 0, i32 5
  store i32 %3, i32* %rq_xid, align 8, !tbaa !154
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %4, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.end

if.then4:                                         ; preds = %if.end
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then4, %if.end
  call void @xs_tcp_read_common(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc, %struct.rpc_rqst* %call)
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %6 = load i64, i64* %tcp_flags, align 8, !tbaa !427
  %and9 = and i64 %6, 8
  %tobool10 = icmp ne i64 %and9, 0
  br i1 %tobool10, label %if.end29, label %if.then11

if.then11:                                        ; preds = %do.end
  %bc_serv12 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 34
  %7 = load %struct.svc_serv*, %struct.svc_serv** %bc_serv12, align 8, !tbaa !442
  %8 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and14 = and i32 %8, 128
  %tobool15 = icmp ne i32 %and14, 0
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot.ext19 = zext i1 %lnot18 to i32
  %conv20 = sext i32 %lnot.ext19 to i64
  %expval21 = call i64 @llvm.expect.i64(i64 %conv20, i64 0)
  %tobool22 = icmp ne i64 %expval21, 0
  br i1 %tobool22, label %if.then23, label %do.end27

if.then23:                                        ; preds = %if.then11
  %9 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end27

do.end27:                                         ; preds = %if.then23, %if.then11
  %sv_cb_lock = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %7, i32 0, i32 19
  call void @spin_lock.177(%struct.spinlock* %sv_cb_lock)
  %rq_bc_list = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call, i32 0, i32 26
  %sv_cb_list = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %7, i32 0, i32 18
  call void @list_add.184(%struct.list_head* %rq_bc_list, %struct.list_head* %sv_cb_list)
  %sv_cb_lock28 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %7, i32 0, i32 19
  call void @spin_unlock.178(%struct.spinlock* %sv_cb_lock28)
  %sv_cb_waitq = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %7, i32 0, i32 20
  call void @__wake_up(%struct.__wait_queue_head* %sv_cb_waitq, i32 3, i32 1, i8* null)
  br label %if.end29

if.end29:                                         ; preds = %do.end27, %do.end
  %tcp_copied = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %10 = load i64, i64* %tcp_copied, align 8, !tbaa !426
  %conv30 = trunc i64 %10 to i32
  %rq_private_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call, i32 0, i32 17
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf, i32 0, i32 7
  store i32 %conv30, i32* %len, align 8, !tbaa !160
  br label %cleanup

cleanup:                                          ; preds = %if.end29, %if.then
  %retval.0 = phi i32 [ -1, %if.then ], [ 0, %if.end29 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_tcp_read_common(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc, %struct.rpc_rqst* %req) #2 {
entry:
  %my_desc = alloca %struct.xdr_skb_reader, align 8
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %rq_private_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 17
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %2 = load i64, i64* %tcp_flags, align 8, !tbaa !427
  %and = and i64 %2, 32
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  %cmp = icmp uge i64 4, 64
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  %3 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %tcp_copied = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %4 = load i64, i64* %tcp_copied, align 8, !tbaa !426
  %add.ptr2 = getelementptr i8, i8* %3, i64 %4
  %tcp_calldir = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 5
  %5 = bitcast i32* %tcp_calldir to i8*
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.then
  %call = call i8* @__memcpy(i8* %add.ptr2, i8* %5, i64 4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr2, i8* %5, i64 4, i32 1, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then1
  %tcp_copied10 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %6 = load i64, i64* %tcp_copied10, align 8, !tbaa !426
  %add = add i64 %6, 4
  store i64 %add, i64* %tcp_copied10, align 8, !tbaa !426
  %tcp_flags11 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %7 = load i64, i64* %tcp_flags11, align 8, !tbaa !427
  %and12 = and i64 %7, -33
  store i64 %and12, i64* %tcp_flags11, align 8, !tbaa !427
  br label %if.end13

if.end13:                                         ; preds = %if.end, %entry
  %count = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %8 = load i64, i64* %count, align 8, !tbaa !350
  %tcp_reclen = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %9 = load i32, i32* %tcp_reclen, align 8, !tbaa !425
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %10 = load i32, i32* %tcp_offset, align 4, !tbaa !424
  %sub = sub i32 %9, %10
  %conv = zext i32 %sub to i64
  %cmp14 = icmp ugt i64 %8, %conv
  br i1 %cmp14, label %if.then16, label %if.else39

if.then16:                                        ; preds = %if.end13
  %tcp_reclen17 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %11 = load i32, i32* %tcp_reclen17, align 8, !tbaa !425
  %tcp_offset18 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %12 = load i32, i32* %tcp_offset18, align 4, !tbaa !424
  %sub19 = sub i32 %11, %12
  %conv20 = zext i32 %sub19 to i64
  %cmp23 = icmp uge i64 32, 64
  %13 = bitcast %struct.xdr_skb_reader* %my_desc to i8*
  %14 = bitcast %struct.xdr_skb_reader* %desc to i8*
  br i1 %cmp23, label %if.then25, label %if.else27

if.then25:                                        ; preds = %if.then16
  %call26 = call i8* @__memcpy(i8* %13, i8* %14, i64 32)
  br label %if.end28

if.else27:                                        ; preds = %if.then16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 32, i32 8, i1 false)
  br label %if.end28

if.end28:                                         ; preds = %if.else27, %if.then25
  %count30 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %my_desc, i32 0, i32 2
  store i64 %conv20, i64* %count30, align 8, !tbaa !350
  %tcp_copied31 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %15 = load i64, i64* %tcp_copied31, align 8, !tbaa !426
  %conv32 = trunc i64 %15 to i32
  %call33 = call i64 @xdr_partial_copy_from_skb(%struct.xdr_buf* %rq_private_buf, i32 %conv32, %struct.xdr_skb_reader* %my_desc, i64 (%struct.xdr_skb_reader*, i8*, i64)* @xdr_skb_read_bits)
  %count34 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %16 = load i64, i64* %count34, align 8, !tbaa !350
  %sub35 = sub i64 %16, %call33
  store i64 %sub35, i64* %count34, align 8, !tbaa !350
  %offset = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  %17 = load i32, i32* %offset, align 8, !tbaa !347
  %conv36 = zext i32 %17 to i64
  %add37 = add nsw i64 %conv36, %call33
  %conv38 = trunc i64 %add37 to i32
  store i32 %conv38, i32* %offset, align 8, !tbaa !347
  br label %if.end43

if.else39:                                        ; preds = %if.end13
  %tcp_copied40 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %18 = load i64, i64* %tcp_copied40, align 8, !tbaa !426
  %conv41 = trunc i64 %18 to i32
  %call42 = call i64 @xdr_partial_copy_from_skb(%struct.xdr_buf* %rq_private_buf, i32 %conv41, %struct.xdr_skb_reader* %desc, i64 (%struct.xdr_skb_reader*, i8*, i64)* @xdr_skb_read_bits)
  br label %if.end43

if.end43:                                         ; preds = %if.else39, %if.end28
  %len.0 = phi i64 [ %conv20, %if.end28 ], [ %8, %if.else39 ]
  %r.0 = phi i64 [ %call33, %if.end28 ], [ %call42, %if.else39 ]
  %cmp44 = icmp sgt i64 %r.0, 0
  br i1 %cmp44, label %if.then46, label %if.end53

if.then46:                                        ; preds = %if.end43
  %tcp_copied47 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %19 = load i64, i64* %tcp_copied47, align 8, !tbaa !426
  %add48 = add i64 %19, %r.0
  store i64 %add48, i64* %tcp_copied47, align 8, !tbaa !426
  %tcp_offset49 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %20 = load i32, i32* %tcp_offset49, align 4, !tbaa !424
  %conv50 = zext i32 %20 to i64
  %add51 = add nsw i64 %conv50, %r.0
  %conv52 = trunc i64 %add51 to i32
  store i32 %conv52, i32* %tcp_offset49, align 4, !tbaa !424
  br label %if.end53

if.end53:                                         ; preds = %if.then46, %if.end43
  %cmp54 = icmp ne i64 %r.0, %len.0
  br i1 %cmp54, label %if.then56, label %do.body87

if.then56:                                        ; preds = %if.end53
  %tcp_flags57 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %21 = load i64, i64* %tcp_flags57, align 8, !tbaa !427
  %and58 = and i64 %21, -9
  store i64 %and58, i64* %tcp_flags57, align 8, !tbaa !427
  %22 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and59 = and i32 %22, 128
  %tobool60 = icmp ne i32 %and59, 0
  %lnot = xor i1 %tobool60, true
  %lnot61 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot61 to i32
  %conv62 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv62, i64 0)
  %tobool63 = icmp ne i64 %expval, 0
  br i1 %tobool63, label %if.then64, label %do.body68

if.then64:                                        ; preds = %if.then56
  %23 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.body68

do.body68:                                        ; preds = %if.then64, %if.then56
  %24 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and69 = and i32 %24, 128
  %tobool70 = icmp ne i32 %and69, 0
  %lnot71 = xor i1 %tobool70, true
  %lnot73 = xor i1 %lnot71, true
  %lnot.ext74 = zext i1 %lnot73 to i32
  %conv75 = sext i32 %lnot.ext74 to i64
  %expval76 = call i64 @llvm.expect.i64(i64 %conv75, i64 0)
  %tobool77 = icmp ne i64 %expval76, 0
  br i1 %tobool77, label %if.then78, label %cleanup.cont

if.then78:                                        ; preds = %do.body68
  %25 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup.cont

do.body87:                                        ; preds = %if.end53
  %26 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and88 = and i32 %26, 128
  %tobool89 = icmp ne i32 %and88, 0
  %lnot90 = xor i1 %tobool89, true
  %lnot92 = xor i1 %lnot90, true
  %lnot.ext93 = zext i1 %lnot92 to i32
  %conv94 = sext i32 %lnot.ext93 to i64
  %expval95 = call i64 @llvm.expect.i64(i64 %conv94, i64 0)
  %tobool96 = icmp ne i64 %expval95, 0
  br i1 %tobool96, label %if.then97, label %do.body104

if.then97:                                        ; preds = %do.body87
  %27 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.body104

do.body104:                                       ; preds = %if.then97, %do.body87
  %28 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and105 = and i32 %28, 128
  %tobool106 = icmp ne i32 %and105, 0
  %lnot107 = xor i1 %tobool106, true
  %lnot109 = xor i1 %lnot107, true
  %lnot.ext110 = zext i1 %lnot109 to i32
  %conv111 = sext i32 %lnot.ext110 to i64
  %expval112 = call i64 @llvm.expect.i64(i64 %conv111, i64 0)
  %tobool113 = icmp ne i64 %expval112, 0
  br i1 %tobool113, label %if.then114, label %do.end121

if.then114:                                       ; preds = %do.body104
  %29 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end121

do.end121:                                        ; preds = %if.then114, %do.body104
  %tcp_copied122 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %30 = load i64, i64* %tcp_copied122, align 8, !tbaa !426
  %rq_private_buf123 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 17
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf123, i32 0, i32 6
  %31 = load i32, i32* %buflen, align 4, !tbaa !443
  %conv124 = zext i32 %31 to i64
  %cmp125 = icmp eq i64 %30, %conv124
  br i1 %cmp125, label %if.then127, label %if.else130

if.then127:                                       ; preds = %do.end121
  %tcp_flags128 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %32 = load i64, i64* %tcp_flags128, align 8, !tbaa !427
  %and129 = and i64 %32, -9
  store i64 %and129, i64* %tcp_flags128, align 8, !tbaa !427
  br label %cleanup.cont

if.else130:                                       ; preds = %do.end121
  %tcp_offset131 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %33 = load i32, i32* %tcp_offset131, align 4, !tbaa !424
  %tcp_reclen132 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %34 = load i32, i32* %tcp_reclen132, align 8, !tbaa !425
  %cmp133 = icmp eq i32 %33, %34
  br i1 %cmp133, label %if.then135, label %cleanup.cont

if.then135:                                       ; preds = %if.else130
  %tcp_flags136 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %35 = load i64, i64* %tcp_flags136, align 8, !tbaa !427
  %and137 = and i64 %35, 1
  %tobool138 = icmp ne i64 %and137, 0
  br i1 %tobool138, label %if.then139, label %cleanup.cont

if.then139:                                       ; preds = %if.then135
  %tcp_flags140 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %36 = load i64, i64* %tcp_flags140, align 8, !tbaa !427
  %and141 = and i64 %36, -9
  store i64 %and141, i64* %tcp_flags140, align 8, !tbaa !427
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then139, %if.then135, %if.else130, %if.then127, %if.then78, %do.body68
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add.184(%struct.list_head* %new, %struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_abort_connection(%struct.sock_xprt* %transport) #0 {
entry:
  %any = alloca %struct.sockaddr, align 2
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %2 = bitcast %struct.sockaddr* %any to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 16, i32 2, i1 false)
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %any, i32 0, i32 0
  store i16 0, i16* %sa_family, align 2, !tbaa !189
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 1
  %3 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !371
  %call3 = call i32 @kernel_connect(%struct.socket* %3, %struct.sockaddr* %any, i32 16, i32 0)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.body7, label %if.then5

if.then5:                                         ; preds = %do.end
  %xprt = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  call void @xs_sock_reset_connection_flags(%struct.rpc_xprt* %xprt)
  br label %do.body7

do.body7:                                         ; preds = %if.then5, %do.end
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and8 = and i32 %4, 128
  %tobool9 = icmp ne i32 %and8, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %if.then17, label %do.end21

if.then17:                                        ; preds = %do.body7
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end21

do.end21:                                         ; preds = %if.then17, %do.body7
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_reclassify_socket(i32 %family, %struct.socket* %sock) #2 {
entry:
  %sk = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %0 = load %struct.sock*, %struct.sock** %sk, align 8, !tbaa !387
  %sk_lock = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %owned = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock, i32 0, i32 1
  %1 = load i32, i32* %owned, align 8, !tbaa !444
  %tobool = icmp ne i32 %1, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool2 = icmp ne i32 %lnot.ext, 0
  %lnot3 = xor i1 %tobool2, true
  %lnot5 = xor i1 %lnot3, true
  %lnot.ext6 = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext6 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then, label %if.end34

if.then:                                          ; preds = %entry
  %2 = load i8, i8* @xs_reclassify_socket.__warned, align 1, !tbaa !29, !range !31
  %tobool8 = trunc i8 %2 to i1
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %tobool15 = icmp ne i32 %lnot.ext14, 0
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot.ext19 = zext i1 %lnot18 to i32
  %conv20 = sext i32 %lnot.ext19 to i64
  %expval21 = call i64 @llvm.expect.i64(i64 %conv20, i64 0)
  %tobool22 = icmp ne i64 %expval21, 0
  br i1 %tobool22, label %if.then23, label %if.end

if.then23:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.13.140, i32 0, i32 0), i32 1779)
  br label %if.end

if.end:                                           ; preds = %if.then23, %if.then
  %tobool24 = icmp ne i32 %lnot.ext14, 0
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot.ext28 = zext i1 %lnot27 to i32
  %conv29 = sext i32 %lnot.ext28 to i64
  %expval30 = call i64 @llvm.expect.i64(i64 %conv29, i64 0)
  %tobool31 = icmp ne i64 %expval30, 0
  br i1 %tobool31, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.end
  store i8 1, i8* @xs_reclassify_socket.__warned, align 1, !tbaa !29
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %if.end, %entry
  %sk43 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %3 = load %struct.sock*, %struct.sock** %sk43, align 8, !tbaa !387
  %sk_lock44 = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 1
  %owned45 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock44, i32 0, i32 1
  %4 = load i32, i32* %owned45, align 8, !tbaa !444
  %tobool46 = icmp ne i32 %4, 0
  br i1 %tobool46, label %sw.epilog, label %NodeBlock5

NodeBlock5:                                       ; preds = %if.end34
  %Pivot6 = icmp slt i32 %family, 2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %family, 10
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %family, 10
  br i1 %SwitchLeaf4, label %sw.bb50, label %sw.epilog

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %family, 2
  br i1 %SwitchLeaf2, label %sw.bb49, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %family, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  call void @xs_reclassify_socketu(%struct.socket* %sock)
  br label %sw.epilog

sw.bb49:                                          ; preds = %LeafBlock1
  call void @xs_reclassify_socket4(%struct.socket* %sock)
  br label %sw.epilog

sw.bb50:                                          ; preds = %LeafBlock3
  call void @xs_reclassify_socket6(%struct.socket* %sock)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb50, %sw.bb49, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3, %if.end34
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_bind(%struct.sock_xprt* %transport, %struct.socket* %sock) #0 {
entry:
  %myaddr = alloca %struct.__kernel_sockaddr_storage, align 8
  %call = call zeroext i16 @xs_get_srcport(%struct.sock_xprt* %transport)
  %xprt = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %addrlen = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 4
  %0 = load i64, i64* %addrlen, align 8, !tbaa !445
  %1 = bitcast %struct.__kernel_sockaddr_storage* %myaddr to i8*
  %srcaddr = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 11
  %2 = bitcast %struct.__kernel_sockaddr_storage* %srcaddr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 %0, i32 8, i1 false)
  br label %do.body

do.body:                                          ; preds = %if.end9, %entry
  %nloop.0 = phi i32 [ 0, %entry ], [ %inc.nloop.0, %if.end9 ]
  %port.0 = phi i16 [ %call, %entry ], [ %call10, %if.end9 ]
  %3 = bitcast %struct.__kernel_sockaddr_storage* %myaddr to %struct.sockaddr*
  call void @rpc_set_port.197(%struct.sockaddr* %3, i16 zeroext %port.0)
  %4 = bitcast %struct.__kernel_sockaddr_storage* %myaddr to %struct.sockaddr*
  %xprt1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %addrlen2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt1, i32 0, i32 4
  %5 = load i64, i64* %addrlen2, align 8, !tbaa !445
  %conv = trunc i64 %5 to i32
  %call3 = call i32 @kernel_bind(%struct.socket* %sock, %struct.sockaddr* %4, i32 %conv)
  %conv4 = zext i16 %port.0 to i32
  %cmp = icmp eq i32 %conv4, 0
  br i1 %cmp, label %do.end, label %if.end

if.end:                                           ; preds = %do.body
  %cmp6 = icmp eq i32 %call3, 0
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 12
  store i16 %port.0, i16* %srcport, align 8, !tbaa !377
  br label %do.end

if.end9:                                          ; preds = %if.end
  %call10 = call zeroext i16 @xs_next_srcport(%struct.sock_xprt* %transport, i16 zeroext %port.0)
  %conv11 = zext i16 %call10 to i32
  %conv12 = zext i16 %port.0 to i32
  %cmp13 = icmp sgt i32 %conv11, %conv12
  %inc = add nsw i32 %nloop.0, 1
  %inc.nloop.0 = select i1 %cmp13, i32 %inc, i32 %nloop.0
  %cmp17 = icmp eq i32 %call3, -98
  %cmp19 = icmp ne i32 %inc.nloop.0, 2
  %6 = select i1 %cmp17, i1 %cmp19, i1 false
  br i1 %6, label %do.body, label %do.end

do.end:                                           ; preds = %if.end9, %if.then8, %do.body
  %ss_family = getelementptr inbounds %struct.__kernel_sockaddr_storage, %struct.__kernel_sockaddr_storage* %myaddr, i32 0, i32 0
  %7 = load i16, i16* %ss_family, align 8, !tbaa !446
  %conv21 = zext i16 %7 to i32
  %cmp22 = icmp eq i32 %conv21, 2
  %8 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %8, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot26 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot26 to i32
  %conv27 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv27, i64 0)
  %tobool28 = icmp ne i64 %expval, 0
  br i1 %cmp22, label %do.body25, label %do.body36

do.body25:                                        ; preds = %do.end
  br i1 %tobool28, label %if.then29, label %if.end54

if.then29:                                        ; preds = %do.body25
  %9 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end54

do.body36:                                        ; preds = %do.end
  br i1 %tobool28, label %if.then46, label %if.end54

if.then46:                                        ; preds = %do.body36
  %10 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end54

if.end54:                                         ; preds = %if.then46, %do.body36, %if.then29, %do.body25
  ret i32 %call3
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @xs_get_srcport(%struct.sock_xprt* %transport) #0 {
entry:
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 12
  %0 = load i16, i16* %srcport, align 8, !tbaa !377
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %xprt = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %resvport = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 19
  %bf.load = load i8, i8* %resvport, align 8
  %bf.clear = and i8 %bf.load, 1
  %conv2 = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %conv2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %call = call zeroext i16 @xs_get_random_port()
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %port.0 = phi i16 [ %call, %if.then ], [ %0, %land.lhs.true ], [ %0, %entry ]
  ret i16 %port.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rpc_set_port.197(%struct.sockaddr* %sap, i16 zeroext %port) #2 {
entry:
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sap, i32 0, i32 0
  %0 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %0 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb3, label %sw.epilog

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %call = call zeroext i16 @__fswab16.137(i16 zeroext %port) #3
  %conv1 = zext i16 %call to i32
  %conv2 = trunc i32 %conv1 to i16
  %1 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %1, i32 0, i32 1
  store i16 %conv2, i16* %sin_port, align 2, !tbaa !191
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock1
  %call4 = call zeroext i16 @__fswab16.137(i16 zeroext %port) #3
  %conv5 = zext i16 %call4 to i32
  %conv6 = trunc i32 %conv5 to i16
  %2 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %2, i32 0, i32 1
  store i16 %conv6, i16* %sin6_port, align 2, !tbaa !194
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb3, %sw.bb, %LeafBlock, %LeafBlock1
  ret void
}

; Function Attrs: nounwind uwtable
declare zeroext i16 @xs_next_srcport(%struct.sock_xprt*, i16 zeroext) #0

; Function Attrs: nounwind uwtable
define internal zeroext i16 @xs_get_random_port() #0 {
entry:
  %0 = load i32, i32* @xprt_max_resvport, align 4, !tbaa !49
  %1 = load i32, i32* @xprt_min_resvport, align 4, !tbaa !49
  %sub = sub i32 %0, %1
  %conv = trunc i32 %sub to i16
  %call = call i32 @prandom_u32()
  %conv1 = trunc i32 %call to i16
  %conv2 = zext i16 %conv1 to i32
  %conv3 = zext i16 %conv to i32
  %rem = srem i32 %conv2, %conv3
  %conv4 = trunc i32 %rem to i16
  %conv5 = zext i16 %conv4 to i32
  %2 = load i32, i32* @xprt_min_resvport, align 4, !tbaa !49
  %add = add i32 %conv5, %2
  %conv6 = trunc i32 %add to i16
  ret i16 %conv6
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_reclassify_socketu(%struct.socket* %sock) #2 {
entry:
  %sk1 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %0 = load %struct.sock*, %struct.sock** %sk1, align 8, !tbaa !387
  %sk_lock = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %owned = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock, i32 0, i32 1
  store i32 0, i32* %owned, align 8, !tbaa !444
  %sk_lock3 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %wq = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock3, i32 0, i32 2
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wq, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.8.661, i32 0, i32 0), %struct.lock_class_key* @xs_reclassify_socketu.__key)
  call void @spinlock_check.201()
  %sk_lock7 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %slock8 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock7, i32 0, i32 0
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock8, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %1 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10.663, i32 0, i32 0), %struct.lock_class_key* @xs_reclassify_socketu.__key.35)
  %sk_lock13 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %2 = bitcast %struct.socket_lock_t* %sk_lock13 to i8*
  call void @debug_check_no_locks_freed(i8* %2, i64 216)
  %sk_lock14 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %slock15 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock14, i32 0, i32 0
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock15, i32 0, i32 0
  %4 = bitcast %union.anon.11* %3 to %struct.anon.2*
  %dep_map = getelementptr inbounds %struct.anon.2, %struct.anon.2* %4, i32 0, i32 1
  call void @lockdep_init_map(%struct.lockdep_map* %dep_map, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.37.207, i32 0, i32 0), %struct.lock_class_key* getelementptr inbounds ([2 x %struct.lock_class_key], [2 x %struct.lock_class_key]* @xs_slock_key, i64 0, i64 1), i32 0)
  %sk_lock16 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %dep_map17 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock16, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %dep_map17, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.38.208, i32 0, i32 0), %struct.lock_class_key* getelementptr inbounds ([2 x %struct.lock_class_key], [2 x %struct.lock_class_key]* @xs_key, i64 0, i64 1), i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_reclassify_socket4(%struct.socket* %sock) #2 {
entry:
  %sk1 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %0 = load %struct.sock*, %struct.sock** %sk1, align 8, !tbaa !387
  %sk_lock = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %owned = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock, i32 0, i32 1
  store i32 0, i32* %owned, align 8, !tbaa !444
  %sk_lock3 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %wq = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock3, i32 0, i32 2
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wq, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.8.661, i32 0, i32 0), %struct.lock_class_key* @xs_reclassify_socket4.__key)
  call void @spinlock_check.201()
  %sk_lock7 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %slock8 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock7, i32 0, i32 0
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock8, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %1 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10.663, i32 0, i32 0), %struct.lock_class_key* @xs_reclassify_socket4.__key.59)
  %sk_lock13 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %2 = bitcast %struct.socket_lock_t* %sk_lock13 to i8*
  call void @debug_check_no_locks_freed(i8* %2, i64 216)
  %sk_lock14 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %slock15 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock14, i32 0, i32 0
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock15, i32 0, i32 0
  %4 = bitcast %union.anon.11* %3 to %struct.anon.2*
  %dep_map = getelementptr inbounds %struct.anon.2, %struct.anon.2* %4, i32 0, i32 1
  call void @lockdep_init_map(%struct.lockdep_map* %dep_map, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.60.205, i32 0, i32 0), %struct.lock_class_key* getelementptr inbounds ([2 x %struct.lock_class_key], [2 x %struct.lock_class_key]* @xs_slock_key, i64 0, i64 0), i32 0)
  %sk_lock16 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %dep_map17 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock16, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %dep_map17, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.61.206, i32 0, i32 0), %struct.lock_class_key* getelementptr inbounds ([2 x %struct.lock_class_key], [2 x %struct.lock_class_key]* @xs_key, i64 0, i64 0), i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_reclassify_socket6(%struct.socket* %sock) #2 {
entry:
  %sk1 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %0 = load %struct.sock*, %struct.sock** %sk1, align 8, !tbaa !387
  %sk_lock = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %owned = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock, i32 0, i32 1
  store i32 0, i32* %owned, align 8, !tbaa !444
  %sk_lock3 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %wq = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock3, i32 0, i32 2
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wq, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.8.661, i32 0, i32 0), %struct.lock_class_key* @xs_reclassify_socket6.__key)
  call void @spinlock_check.201()
  %sk_lock7 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %slock8 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock7, i32 0, i32 0
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock8, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %1 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10.663, i32 0, i32 0), %struct.lock_class_key* @xs_reclassify_socket6.__key.62)
  %sk_lock13 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %2 = bitcast %struct.socket_lock_t* %sk_lock13 to i8*
  call void @debug_check_no_locks_freed(i8* %2, i64 216)
  %sk_lock14 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %slock15 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock14, i32 0, i32 0
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock15, i32 0, i32 0
  %4 = bitcast %union.anon.11* %3 to %struct.anon.2*
  %dep_map = getelementptr inbounds %struct.anon.2, %struct.anon.2* %4, i32 0, i32 1
  call void @lockdep_init_map(%struct.lockdep_map* %dep_map, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.63.203, i32 0, i32 0), %struct.lock_class_key* getelementptr inbounds ([2 x %struct.lock_class_key], [2 x %struct.lock_class_key]* @xs_slock_key, i64 0, i64 1), i32 0)
  %sk_lock16 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %dep_map17 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock16, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %dep_map17, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.64.204, i32 0, i32 0), %struct.lock_class_key* getelementptr inbounds ([2 x %struct.lock_class_key], [2 x %struct.lock_class_key]* @xs_key, i64 0, i64 1), i32 0)
  ret void
}

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @spinlock_check.201() #2 {
entry:
  ret void
}

declare void @debug_check_no_locks_freed(i8*, i64) #4

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_release_xprt(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  %snd_task = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  %0 = load %struct.rpc_task*, %struct.rpc_task** %snd_task, align 8, !tbaa !302
  %cmp = icmp ne %struct.rpc_task* %task, %0
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp eq %struct.rpc_task* %task, null
  br i1 %cmp1, label %out_release, label %if.end3

if.end3:                                          ; preds = %if.end
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %1 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %cmp4 = icmp eq %struct.rpc_rqst* %1, null
  br i1 %cmp4, label %out_release, label %if.end6

if.end6:                                          ; preds = %if.end3
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 23
  %2 = load i32, i32* %rq_bytes_sent, align 8, !tbaa !143
  %cmp7 = icmp eq i32 %2, 0
  br i1 %cmp7, label %out_release, label %if.end9

if.end9:                                          ; preds = %if.end6
  %rq_bytes_sent10 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 23
  %3 = load i32, i32* %rq_bytes_sent10, align 8, !tbaa !143
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 1
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 7
  %4 = load i32, i32* %len, align 8, !tbaa !145
  %cmp11 = icmp eq i32 %3, %4
  br i1 %cmp11, label %out_release, label %if.end13

if.end13:                                         ; preds = %if.end9
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 3, i64* %state) #7, !srcloc !373
  br label %out_release

out_release:                                      ; preds = %if.end13, %if.end9, %if.end6, %if.end3, %if.end
  call void @xprt_release_xprt(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %out_release, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_set_port(%struct.rpc_xprt* %xprt, i16 zeroext %port) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %call4 = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt)
  call void @rpc_set_port.197(%struct.sockaddr* %call4, i16 zeroext %port)
  call void @xs_update_peer_port(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_connect(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  %2 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !371
  %cmp = icmp ne %struct.socket* %2, null
  br i1 %cmp, label %land.lhs.true, label %do.body22

land.lhs.true:                                    ; preds = %entry
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %3 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv = zext i16 %3 to i32
  %and = and i32 %conv, 1024
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %do.body22, label %do.body

do.body:                                          ; preds = %land.lhs.true
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and1 = and i32 %4, 128
  %tobool2 = icmp ne i32 %and1, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then6, label %do.end

if.then6:                                         ; preds = %do.body
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then6, %do.body
  %6 = load %struct.workqueue_struct*, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !28
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  %reestablish_timeout7 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  %7 = load i64, i64* %reestablish_timeout7, align 8, !tbaa !367
  call void @queue_delayed_work(%struct.workqueue_struct* %6, %struct.delayed_work* %connect_worker, i64 %7)
  %reestablish_timeout9 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  %8 = load i64, i64* %reestablish_timeout9, align 8, !tbaa !367
  %shl = shl i64 %8, 1
  store i64 %shl, i64* %reestablish_timeout9, align 8, !tbaa !367
  %reestablish_timeout10 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  %9 = load i64, i64* %reestablish_timeout10, align 8, !tbaa !367
  %cmp11 = icmp ult i64 %9, 750
  br i1 %cmp11, label %if.then13, label %if.end15

if.then13:                                        ; preds = %do.end
  %reestablish_timeout14 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  store i64 750, i64* %reestablish_timeout14, align 8, !tbaa !367
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %do.end
  %reestablish_timeout16 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  %10 = load i64, i64* %reestablish_timeout16, align 8, !tbaa !367
  %cmp17 = icmp ugt i64 %10, 75000
  br i1 %cmp17, label %if.then19, label %if.end39

if.then19:                                        ; preds = %if.end15
  %reestablish_timeout20 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  store i64 75000, i64* %reestablish_timeout20, align 8, !tbaa !367
  br label %if.end39

do.body22:                                        ; preds = %land.lhs.true, %entry
  %11 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and23 = and i32 %11, 128
  %tobool24 = icmp ne i32 %and23, 0
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot.ext28 = zext i1 %lnot27 to i32
  %conv29 = sext i32 %lnot.ext28 to i64
  %expval30 = call i64 @llvm.expect.i64(i64 %conv29, i64 0)
  %tobool31 = icmp ne i64 %expval30, 0
  br i1 %tobool31, label %if.then32, label %do.end36

if.then32:                                        ; preds = %do.body22
  %12 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end36

do.end36:                                         ; preds = %if.then32, %do.body22
  %13 = load %struct.workqueue_struct*, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !28
  %connect_worker37 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  call void @queue_delayed_work(%struct.workqueue_struct* %13, %struct.delayed_work* %connect_worker37, i64 0)
  br label %if.end39

if.end39:                                         ; preds = %do.end36, %if.then19, %if.end15
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_tcp_send_request(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %rq_snd_buf1 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  call void @xs_encode_stream_record_marker(%struct.xdr_buf* %rq_snd_buf1)
  call void @xs_pktdump()
  br label %while.cond

while.cond:                                       ; preds = %if.then41, %entry
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %4 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !371
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  %5 = load i32, i32* %rq_bytes_sent, align 8, !tbaa !143
  %call = call i32 @xs_sendpages(%struct.socket* %4, %struct.sockaddr* null, i32 0, %struct.xdr_buf* %rq_snd_buf, i32 %5)
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %6, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %do.end

if.then:                                          ; preds = %while.cond
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %while.cond
  %cmp = icmp slt i32 %call, 0
  %lnot12 = xor i1 %cmp, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %NodeBlock17, label %if.end20

if.end20:                                         ; preds = %do.end
  %rq_bytes_sent21 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  %8 = load i32, i32* %rq_bytes_sent21, align 8, !tbaa !143
  %add = add i32 %8, %call
  store i32 %add, i32* %rq_bytes_sent21, align 8, !tbaa !143
  %conv22 = sext i32 %call to i64
  %rq_xmit_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 15
  %9 = load i64, i64* %rq_xmit_bytes_sent, align 8, !tbaa !447
  %add23 = add i64 %9, %conv22
  store i64 %add23, i64* %rq_xmit_bytes_sent, align 8, !tbaa !447
  %rq_bytes_sent24 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  %10 = load i32, i32* %rq_bytes_sent24, align 8, !tbaa !143
  %rq_snd_buf25 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %len26 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf25, i32 0, i32 7
  %11 = load i32, i32* %len26, align 8, !tbaa !145
  %cmp27 = icmp uge i32 %10, %11
  %lnot29 = xor i1 %cmp27, true
  %lnot31 = xor i1 %lnot29, true
  %lnot.ext32 = zext i1 %lnot31 to i32
  %conv33 = sext i32 %lnot.ext32 to i64
  %expval34 = call i64 @llvm.expect.i64(i64 %conv33, i64 1)
  %tobool35 = icmp ne i64 %expval34, 0
  br i1 %tobool35, label %if.then36, label %if.end38

if.then36:                                        ; preds = %if.end20
  %rq_bytes_sent37 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  store i32 0, i32* %rq_bytes_sent37, align 8, !tbaa !143
  br label %cleanup

if.end38:                                         ; preds = %if.end20
  %cmp39 = icmp ne i32 %call, 0
  br i1 %cmp39, label %if.then41, label %NodeBlock17

if.then41:                                        ; preds = %if.end38
  br label %while.cond

NodeBlock17:                                      ; preds = %if.end38, %do.end
  %status.0 = phi i32 [ %call, %do.end ], [ -11, %if.end38 ]
  %Pivot18 = icmp slt i32 %status.0, -88
  br i1 %Pivot18, label %NodeBlock5, label %NodeBlock15

NodeBlock15:                                      ; preds = %NodeBlock17
  %Pivot16 = icmp slt i32 %status.0, -32
  br i1 %Pivot16, label %LeafBlock7, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %status.0, -11
  br i1 %Pivot14, label %LeafBlock9, label %LeafBlock11

LeafBlock11:                                      ; preds = %NodeBlock13
  %SwitchLeaf12 = icmp eq i32 %status.0, -11
  br i1 %SwitchLeaf12, label %sw.bb43, label %do.body45

LeafBlock9:                                       ; preds = %NodeBlock13
  %SwitchLeaf10 = icmp eq i32 %status.0, -32
  br i1 %SwitchLeaf10, label %sw.bb62, label %do.body45

LeafBlock7:                                       ; preds = %NodeBlock15
  %SwitchLeaf8 = icmp eq i32 %status.0, -88
  br i1 %SwitchLeaf8, label %cleanup, label %do.body45

NodeBlock5:                                       ; preds = %NodeBlock17
  %Pivot6 = icmp slt i32 %status.0, -107
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %status.0, -104
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %status.0, -104
  br i1 %SwitchLeaf4, label %sw.bb61, label %do.body45

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %status.0, -107
  br i1 %SwitchLeaf2, label %sw.bb62, label %do.body45

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %status.0, -111
  br i1 %SwitchLeaf, label %sw.bb62, label %do.body45

sw.bb43:                                          ; preds = %LeafBlock11
  %call44 = call i32 @xs_nospace(%struct.rpc_task* %task)
  br label %cleanup

do.body45:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock7, %LeafBlock9, %LeafBlock11
  %12 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and46 = and i32 %12, 128
  %tobool47 = icmp ne i32 %and46, 0
  %lnot48 = xor i1 %tobool47, true
  %lnot50 = xor i1 %lnot48, true
  %lnot.ext51 = zext i1 %lnot50 to i32
  %conv52 = sext i32 %lnot.ext51 to i64
  %expval53 = call i64 @llvm.expect.i64(i64 %conv52, i64 0)
  %tobool54 = icmp ne i64 %expval53, 0
  br i1 %tobool54, label %if.then55, label %sw.bb61

if.then55:                                        ; preds = %do.body45
  %13 = call i32 (i8*, ...) @printk(i8* null)
  br label %sw.bb61

sw.bb61:                                          ; preds = %if.then55, %do.body45, %LeafBlock3
  call void @xs_tcp_shutdown(%struct.rpc_xprt* %1)
  br label %sw.bb62

sw.bb62:                                          ; preds = %sw.bb61, %LeafBlock, %LeafBlock1, %LeafBlock9
  %sock63 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %14 = load %struct.socket*, %struct.socket** %sock63, align 8, !tbaa !371
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %14, i32 0, i32 2
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags, i32 0, i64* %flags) #7, !srcloc !386
  br label %cleanup

cleanup:                                          ; preds = %sw.bb62, %sw.bb43, %LeafBlock7, %if.then36
  %retval.0 = phi i32 [ 0, %if.then36 ], [ %status.0, %sw.bb62 ], [ %call44, %sw.bb43 ], [ -107, %LeafBlock7 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_close(%struct.rpc_xprt* %xprt) #0 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @test_and_clear_bit.173(i32 8, i64* %state)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @xs_close(%struct.rpc_xprt* %xprt)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @xs_tcp_shutdown(%struct.rpc_xprt* %xprt)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_destroy(%struct.rpc_xprt* %xprt) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  %call3 = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* %connect_worker)
  call void @xs_local_destroy(%struct.rpc_xprt* %xprt)
  ret void
}

declare zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work*) #4

; Function Attrs: nounwind uwtable
define internal void @xs_local_destroy(%struct.rpc_xprt* %xprt) #0 {
entry:
  call void @xs_close(%struct.rpc_xprt* %xprt)
  call void @xs_free_peer_addresses(%struct.rpc_xprt* %xprt)
  call void @xprt_free(%struct.rpc_xprt* %xprt)
  call void @module_put(%struct.module* @__this_module)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_close(%struct.rpc_xprt* %xprt) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  call void @xs_reset_transport(%struct.sock_xprt* %1)
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  store i64 0, i64* %reestablish_timeout, align 8, !tbaa !367
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !448
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 7, i64* %state) #7, !srcloc !386
  %state3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state3, i32 3, i64* %state3) #7, !srcloc !386
  %state4 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state4, i32 6, i64* %state4) #7, !srcloc !386
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !449
  call void @xprt_disconnect_done(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_free_peer_addresses(%struct.rpc_xprt* %xprt) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp ult i32 %i.0, 6
  br i1 %cmp, label %NodeBlock, label %for.end

NodeBlock:                                        ; preds = %for.cond
  %Pivot = icmp slt i32 %i.0, 5
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %i.0, 5
  br i1 %SwitchLeaf2, label %for.inc, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %i.0, 2
  br i1 %SwitchLeaf, label %for.inc, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 42
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 %idxprom
  %0 = load i8*, i8** %arrayidx, align 8, !tbaa !28
  call void @kfree(i8* %0)
  br label %for.inc

for.inc:                                          ; preds = %sw.default, %LeafBlock, %LeafBlock1
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @module_put(%struct.module*) #4

; Function Attrs: nounwind uwtable
define internal void @xs_reset_transport(%struct.sock_xprt* %transport) #0 {
entry:
  %sock1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 1
  %0 = load %struct.socket*, %struct.socket** %sock1, align 8, !tbaa !371
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 2
  %1 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !361
  %cmp = icmp eq %struct.sock* %1, null
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 12
  store i16 0, i16* %srcport, align 8, !tbaa !377
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %1, i32 0, i32 32
  call void @_raw_write_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %inet2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 2
  store %struct.sock* null, %struct.sock** %inet2, align 8, !tbaa !361
  %sock3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 1
  store %struct.socket* null, %struct.socket** %sock3, align 8, !tbaa !371
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %1, i32 0, i32 47
  store i8* null, i8** %sk_user_data, align 8, !tbaa !398
  call void @xs_restore_old_callbacks(%struct.sock_xprt* %transport, %struct.sock* %1)
  %sk_callback_lock4 = getelementptr inbounds %struct.sock, %struct.sock* %1, i32 0, i32 32
  call void @_raw_write_unlock_bh(%struct.rwlock_t* %sk_callback_lock4)
  %sk_no_check = getelementptr inbounds %struct.sock, %struct.sock* %1, i32 0, i32 20
  %bf.load = load i32, i32* %sk_no_check, align 8
  %bf.clear = and i32 %bf.load, -13
  store i32 %bf.clear, i32* %sk_no_check, align 8
  call void @sock_release(%struct.socket* %0)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_restore_old_callbacks(%struct.sock_xprt* %transport, %struct.sock* %sk) #0 {
entry:
  %old_data_ready = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 15
  %0 = load void (%struct.sock*, i32)*, void (%struct.sock*, i32)** %old_data_ready, align 8, !tbaa !419
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 57
  store void (%struct.sock*, i32)* %0, void (%struct.sock*, i32)** %sk_data_ready, align 8, !tbaa !399
  %old_state_change = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 16
  %1 = load void (%struct.sock*)*, void (%struct.sock*)** %old_state_change, align 8, !tbaa !420
  %sk_state_change = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 56
  store void (%struct.sock*)* %1, void (%struct.sock*)** %sk_state_change, align 8, !tbaa !400
  %old_write_space = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 17
  %2 = load void (%struct.sock*)*, void (%struct.sock*)** %old_write_space, align 8, !tbaa !421
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 58
  store void (%struct.sock*)* %2, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !401
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_shutdown(%struct.rpc_xprt* %xprt) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %sock1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  %2 = load %struct.socket*, %struct.socket** %sock1, align 8, !tbaa !371
  %cmp = icmp ne %struct.socket* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @kernel_sock_shutdown(%struct.socket* %2, i32 1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare i32 @kernel_sock_shutdown(%struct.socket*, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_pktdump() #2 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_sendpages(%struct.socket* %sock, %struct.sockaddr* %addr, i32 %addrlen, %struct.xdr_buf* %xdr, i32 %base) #0 {
entry:
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 7
  %0 = load i32, i32* %len, align 8, !tbaa !152
  %sub = sub i32 %0, %base
  %tobool = icmp ne %struct.socket* %sock, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %cleanup83, label %if.end

if.end:                                           ; preds = %entry
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 2
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags, i32 0, i64* %flags) #7, !srcloc !386
  %cmp = icmp ne i32 %base, 0
  %.addrlen = select i1 %cmp, i32 0, i32 %addrlen
  %.addr = select i1 %cmp, %struct.sockaddr* null, %struct.sockaddr* %addr
  %conv7 = zext i32 %base to i64
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %1 = load i64, i64* %iov_len, align 8, !tbaa !149
  %cmp8 = icmp ult i64 %conv7, %1
  %cmp10 = icmp ne %struct.sockaddr* %.addr, null
  %or.cond = or i1 %cmp8, %cmp10
  %head14 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 0
  %arrayidx15 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head14, i64 0, i64 0
  %iov_len16 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx15, i32 0, i32 1
  %2 = load i64, i64* %iov_len16, align 8, !tbaa !149
  %conv17 = zext i32 %base to i64
  br i1 %or.cond, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %sub18 = sub i64 %2, %conv17
  %conv19 = trunc i64 %sub18 to i32
  %sub20 = sub i32 %sub, %conv19
  %head21 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 0
  %arrayidx22 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head21, i64 0, i64 0
  %cmp23 = icmp ne i32 %sub20, 0
  %conv24 = zext i1 %cmp23 to i32
  %call = call i32 @xs_send_kvec(%struct.socket* %sock, %struct.sockaddr* %.addr, i32 %.addrlen, %struct.iovec* %arrayidx22, i32 %base, i32 %conv24)
  %cmp25 = icmp eq i32 %sub20, 0
  %cmp28 = icmp ne i32 %call, %conv19
  %or.cond10 = or i1 %cmp25, %cmp28
  %add = add nsw i32 0, %call
  %base.addr.0 = select i1 %or.cond10, i32 %base, i32 0
  %sent.0 = select i1 %or.cond10, i32 0, i32 %add
  %cleanup.dest.slot.0 = select i1 %or.cond10, i32 2, i32 0
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.then12
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf2, label %out, label %cleanup83

LeafBlock:                                        ; preds = %if.then12
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end38, label %cleanup83

if.else:                                          ; preds = %if.end
  %sub36 = sub i64 %conv17, %2
  %conv37 = trunc i64 %sub36 to i32
  br label %if.end38

if.end38:                                         ; preds = %if.else, %LeafBlock
  %remainder.0 = phi i32 [ %sub, %if.else ], [ %sub20, %LeafBlock ]
  %base.addr.1 = phi i32 [ %conv37, %if.else ], [ %base.addr.0, %LeafBlock ]
  %sent.1 = phi i32 [ 0, %if.else ], [ %sent.0, %LeafBlock ]
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 4
  %3 = load i32, i32* %page_len, align 4, !tbaa !150
  %cmp39 = icmp ult i32 %base.addr.1, %3
  %page_len43 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 4
  %4 = load i32, i32* %page_len43, align 4, !tbaa !150
  br i1 %cmp39, label %if.then41, label %if.else60

if.then41:                                        ; preds = %if.end38
  %sub44 = sub i32 %4, %base.addr.1
  %sub45 = sub i32 %remainder.0, %sub44
  %cmp46 = icmp ne i32 %sub45, 0
  %conv47 = zext i1 %cmp46 to i32
  %call48 = call i32 @xs_send_pagedata(%struct.socket* %sock, %struct.xdr_buf* %xdr, i32 %base.addr.1, i32 %conv47)
  %cmp49 = icmp eq i32 %sub45, 0
  %cmp52 = icmp ne i32 %call48, %sub44
  %or.cond11 = or i1 %cmp49, %cmp52
  %add56 = add nsw i32 %sent.1, %call48
  %base.addr.2 = select i1 %or.cond11, i32 %base.addr.1, i32 0
  %sent.2 = select i1 %or.cond11, i32 %sent.1, i32 %add56
  %cleanup.dest.slot.1 = select i1 %or.cond11, i32 2, i32 0
  %Pivot9 = icmp slt i32 %cleanup.dest.slot.1, 2
  br i1 %Pivot9, label %LeafBlock4, label %LeafBlock6

LeafBlock6:                                       ; preds = %if.then41
  %SwitchLeaf7 = icmp eq i32 %cleanup.dest.slot.1, 2
  br i1 %SwitchLeaf7, label %out, label %cleanup83

LeafBlock4:                                       ; preds = %if.then41
  %SwitchLeaf5 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf5, label %if.end63, label %cleanup83

if.else60:                                        ; preds = %if.end38
  %sub62 = sub i32 %base.addr.1, %4
  br label %if.end63

if.end63:                                         ; preds = %if.else60, %LeafBlock4
  %base.addr.3 = phi i32 [ %sub62, %if.else60 ], [ %base.addr.2, %LeafBlock4 ]
  %sent.3 = phi i32 [ %sent.1, %if.else60 ], [ %sent.2, %LeafBlock4 ]
  %conv64 = zext i32 %base.addr.3 to i64
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 1
  %arrayidx65 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_len66 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx65, i32 0, i32 1
  %5 = load i64, i64* %iov_len66, align 8, !tbaa !149
  %cmp67 = icmp uge i64 %conv64, %5
  br i1 %cmp67, label %cleanup83, label %if.end70

if.end70:                                         ; preds = %if.end63
  %tail71 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 1
  %arrayidx72 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail71, i64 0, i64 0
  %call73 = call i32 @xs_send_kvec(%struct.socket* %sock, %struct.sockaddr* null, i32 0, %struct.iovec* %arrayidx72, i32 %base.addr.3, i32 0)
  br label %out

out:                                              ; preds = %if.end70, %LeafBlock6, %LeafBlock1
  %err.0 = phi i32 [ %call73, %if.end70 ], [ %call48, %LeafBlock6 ], [ %call, %LeafBlock1 ]
  %sent.4 = phi i32 [ %sent.3, %if.end70 ], [ %sent.2, %LeafBlock6 ], [ %sent.0, %LeafBlock1 ]
  %cmp74 = icmp eq i32 %sent.4, 0
  br i1 %cmp74, label %cleanup83, label %if.end77

if.end77:                                         ; preds = %out
  %cmp78 = icmp sgt i32 %err.0, 0
  %add81 = add nsw i32 %sent.4, %err.0
  %add81.sent.4 = select i1 %cmp78, i32 %add81, i32 %sent.4
  br label %cleanup83

cleanup83:                                        ; preds = %if.end77, %out, %if.end63, %LeafBlock4, %LeafBlock6, %LeafBlock, %LeafBlock1, %entry
  %retval.0 = phi i32 [ %add81.sent.4, %if.end77 ], [ -88, %entry ], [ %sent.3, %if.end63 ], [ %err.0, %out ], [ undef, %LeafBlock1 ], [ undef, %LeafBlock ], [ undef, %LeafBlock6 ], [ undef, %LeafBlock4 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_nospace(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %4, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 29
  call void @spin_lock_bh.215(%struct.spinlock* %transport_lock)
  %call6 = call i32 @xprt_connected.142(%struct.rpc_xprt* %1)
  %tobool7 = icmp ne i32 %call6, 0
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %6 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !371
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %6, i32 0, i32 2
  br i1 %tobool7, label %cond.true, label %if.else

cond.true:                                        ; preds = %do.end
  %7 = load volatile i64, i64* %flags, align 8, !tbaa !88
  %and.i = and i64 1, %7
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool10 = icmp ne i32 %conv.i, 0
  br i1 %tobool10, label %if.then15, label %if.end21

if.then15:                                        ; preds = %cond.true
  %sock16 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %8 = load %struct.socket*, %struct.socket** %sock16, align 8, !tbaa !371
  %flags17 = getelementptr inbounds %struct.socket, %struct.socket* %8, i32 0, i32 2
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags17, i32 2, i64* %flags17) #7, !srcloc !373
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 2
  %9 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !361
  %sk_write_pending = getelementptr inbounds %struct.sock, %struct.sock* %9, i32 0, i32 51
  %10 = load i32, i32* %sk_write_pending, align 4, !tbaa !450
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %sk_write_pending, align 4, !tbaa !450
  call void @xprt_wait_for_buffer_space(%struct.rpc_task* %task, void (%struct.rpc_task*)* @xs_nospace_callback)
  br label %if.end21

if.else:                                          ; preds = %do.end
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags, i32 0, i64* %flags) #7, !srcloc !386
  br label %if.end21

if.end21:                                         ; preds = %if.else, %if.then15, %cond.true
  %ret.0 = phi i32 [ -107, %if.else ], [ -11, %if.then15 ], [ -11, %cond.true ]
  %transport_lock22 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 29
  call void @spin_unlock_bh.216(%struct.spinlock* %transport_lock22)
  ret i32 %ret.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_bh.215(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_nospace_callback(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 2
  %4 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !361
  %sk_write_pending = getelementptr inbounds %struct.sock, %struct.sock* %4, i32 0, i32 51
  %5 = load i32, i32* %sk_write_pending, align 4, !tbaa !450
  %dec = add nsw i32 %5, -1
  store i32 %dec, i32* %sk_write_pending, align 4, !tbaa !450
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %6 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !371
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %6, i32 0, i32 2
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags, i32 0, i64* %flags) #7, !srcloc !386
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_bh.216(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_send_kvec(%struct.socket* %sock, %struct.sockaddr* %addr, i32 %addrlen, %struct.iovec* %vec, i32 %base, i32 %more) #0 {
entry:
  %msg = alloca %struct.msghdr, align 8
  %iov = alloca %struct.iovec, align 8
  %msg_name = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 0
  %0 = bitcast %struct.sockaddr* %addr to i8*
  store i8* %0, i8** %msg_name, align 8, !tbaa !451
  %msg_namelen = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 1
  store i32 %addrlen, i32* %msg_namelen, align 8, !tbaa !453
  %msg_iov = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 2
  store %struct.iovec* null, %struct.iovec** %msg_iov, align 8, !tbaa !454
  %msg_iovlen = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 3
  store i64 0, i64* %msg_iovlen, align 8, !tbaa !455
  %msg_control = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 4
  store i8* null, i8** %msg_control, align 8, !tbaa !456
  %msg_controllen = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 5
  store i64 0, i64* %msg_controllen, align 8, !tbaa !457
  %msg_flags = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 6
  %tobool = icmp ne i32 %more, 0
  %cond = select i1 %tobool, i32 32768, i32 0
  %or = or i32 16448, %cond
  store i32 %or, i32* %msg_flags, align 8, !tbaa !458
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  %iov_base1 = getelementptr inbounds %struct.iovec, %struct.iovec* %vec, i32 0, i32 0
  %1 = load i8*, i8** %iov_base1, align 8, !tbaa !147
  %idx.ext = zext i32 %base to i64
  %add.ptr = getelementptr i8, i8* %1, i64 %idx.ext
  store i8* %add.ptr, i8** %iov_base, align 8, !tbaa !147
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %iov_len2 = getelementptr inbounds %struct.iovec, %struct.iovec* %vec, i32 0, i32 1
  %2 = load i64, i64* %iov_len2, align 8, !tbaa !149
  %conv = zext i32 %base to i64
  %sub = sub i64 %2, %conv
  store i64 %sub, i64* %iov_len, align 8, !tbaa !149
  %iov_len3 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %3 = load i64, i64* %iov_len3, align 8, !tbaa !149
  %cmp = icmp ne i64 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %iov_len5 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %4 = load i64, i64* %iov_len5, align 8, !tbaa !149
  %call = call i32 @kernel_sendmsg(%struct.socket* %sock, %struct.msghdr* %msg, %struct.iovec* %iov, i64 1, i64 %4)
  br label %cleanup

if.end:                                           ; preds = %entry
  %call6 = call i32 @kernel_sendmsg(%struct.socket* %sock, %struct.msghdr* %msg, %struct.iovec* null, i64 0, i64 0)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %call6, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_send_pagedata(%struct.socket* %sock, %struct.xdr_buf* %xdr, i32 %base, i32 %more) #0 {
entry:
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 4
  %0 = load i32, i32* %page_len, align 4, !tbaa !150
  %sub = sub i32 %0, %base
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 3
  %1 = load i32, i32* %page_base, align 8, !tbaa !355
  %add = add i32 %base, %1
  %pages = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 2
  %2 = load %struct.page**, %struct.page*** %pages, align 8, !tbaa !354
  %shr = lshr i32 %add, 12
  %idx.ext = zext i32 %shr to i64
  %add.ptr = getelementptr inbounds %struct.page*, %struct.page** %2, i64 %idx.ext
  %conv = zext i32 %add to i64
  %and = and i64 %conv, 4095
  %conv1 = trunc i64 %and to i32
  br label %for.cond

for.cond:                                         ; preds = %cleanup.cont, %entry
  %remainder.0 = phi i32 [ %sub, %entry ], [ %sub6, %cleanup.cont ]
  %ppage.0 = phi %struct.page** [ %add.ptr, %entry ], [ %ppage.1, %cleanup.cont ]
  %sent.0 = phi i32 [ 0, %entry ], [ %sent.1, %cleanup.cont ]
  %base.addr.0 = phi i32 [ %conv1, %entry ], [ %base.addr.1, %cleanup.cont ]
  %conv2 = zext i32 %base.addr.0 to i64
  %sub3 = sub i64 4096, %conv2
  %conv4 = trunc i64 %sub3 to i32
  %cmp = icmp ult i32 %conv4, %remainder.0
  %conv4.remainder.0 = select i1 %cmp, i32 %conv4, i32 %remainder.0
  %sub6 = sub i32 %remainder.0, %conv4.remainder.0
  %cmp7 = icmp ne i32 %sub6, 0
  %tobool = icmp ne i32 %more, 0
  %or.cond = or i1 %cmp7, %tobool
  %or = or i32 16448, 32768
  %flags.0 = select i1 %or.cond, i32 %or, i32 16448
  %ops = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 6
  %3 = load %struct.proto_ops*, %struct.proto_ops** %ops, align 8, !tbaa !459
  %sendpage = getelementptr inbounds %struct.proto_ops, %struct.proto_ops* %3, i32 0, i32 20
  %4 = load i64 (%struct.socket*, %struct.page*, i32, i64, i32)*, i64 (%struct.socket*, %struct.page*, i32, i64, i32)** %sendpage, align 8, !tbaa !460
  %5 = load %struct.page*, %struct.page** %ppage.0, align 8, !tbaa !28
  %conv9 = zext i32 %conv4.remainder.0 to i64
  %call = call i64 %4(%struct.socket* %sock, %struct.page* %5, i32 %base.addr.0, i64 %conv9, i32 %flags.0)
  %conv10 = trunc i64 %call to i32
  %cmp11 = icmp eq i32 %sub6, 0
  %cmp14 = icmp ne i32 %conv10, %conv4.remainder.0
  %or.cond1 = or i1 %cmp11, %cmp14
  br i1 %or.cond1, label %LeafBlock, label %if.end17

if.end17:                                         ; preds = %for.cond
  %add18 = add nsw i32 %sent.0, %conv10
  %incdec.ptr = getelementptr inbounds %struct.page*, %struct.page** %ppage.0, i32 1
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end17, %for.cond
  %ppage.1 = phi %struct.page** [ %incdec.ptr, %if.end17 ], [ %ppage.0, %for.cond ]
  %sent.1 = phi i32 [ %add18, %if.end17 ], [ %sent.0, %for.cond ]
  %base.addr.1 = phi i32 [ 0, %if.end17 ], [ %base.addr.0, %for.cond ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end17 ], [ 2, %for.cond ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf, label %for.end, label %cleanup.cont

cleanup.cont:                                     ; preds = %LeafBlock
  br label %for.cond

for.end:                                          ; preds = %LeafBlock
  %cmp20 = icmp eq i32 %sent.1, 0
  br i1 %cmp20, label %cleanup29, label %if.end23

if.end23:                                         ; preds = %for.end
  %cmp24 = icmp sgt i32 %conv10, 0
  %add27 = add nsw i32 %sent.1, %conv10
  %add27.sent.1 = select i1 %cmp24, i32 %add27, i32 %sent.1
  br label %cleanup29

cleanup29:                                        ; preds = %if.end23, %for.end
  %retval.0 = phi i32 [ %add27.sent.1, %if.end23 ], [ %conv10, %for.end ]
  ret i32 %retval.0
}

declare i32 @kernel_sendmsg(%struct.socket*, %struct.msghdr*, %struct.iovec*, i64, i64) #4

; Function Attrs: nounwind uwtable
define internal void @xs_update_peer_port(%struct.rpc_xprt* %xprt) #0 {
entry:
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 42
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 4
  %0 = load i8*, i8** %arrayidx, align 8, !tbaa !28
  call void @kfree(i8* %0)
  %address_strings1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 42
  %arrayidx2 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings1, i64 0, i64 1
  %1 = load i8*, i8** %arrayidx2, align 8, !tbaa !28
  call void @kfree(i8* %1)
  call void @xs_format_common_peer_ports(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_xprt* @xs_setup_udp(%struct.xprt_create* %args) #0 {
entry:
  %.compoundliteral = alloca %struct.pgprot, align 8
  %.compoundliteral51 = alloca %struct.pgprot, align 8
  %dstaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %0 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr, align 8, !tbaa !251
  %1 = load i32, i32* @xprt_udp_slot_table_entries, align 4, !tbaa !49
  %2 = load i32, i32* @xprt_udp_slot_table_entries, align 4, !tbaa !49
  %call = call %struct.rpc_xprt* @xs_setup_xprt(%struct.xprt_create* %args, i32 %1, i32 %2)
  %3 = bitcast %struct.rpc_xprt* %call to i8*
  %call1 = call i64 @IS_ERR.129(i8* %3)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %4 = bitcast %struct.rpc_xprt* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %prot = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 5
  store i32 17, i32* %prot, align 8, !tbaa !186
  %tsh_size = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 9
  store i32 0, i32* %tsh_size, align 8, !tbaa !157
  %max_payload = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 8
  store i64 64128, i64* %max_payload, align 8, !tbaa !185
  %bind_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 22
  store i64 15000, i64* %bind_timeout, align 8, !tbaa !85
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 500, i64* %reestablish_timeout, align 8, !tbaa !367
  %idle_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 28
  store i64 75000, i64* %idle_timeout, align 8, !tbaa !336
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 1
  store %struct.rpc_xprt_ops* @xs_udp_ops, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 2
  store %struct.rpc_timeout* @xs_udp_default_timeout, %struct.rpc_timeout** %timeout, align 8, !tbaa !183
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %0, i32 0, i32 0
  %6 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %6 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb37, label %out_err

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %out_err

sw.bb:                                            ; preds = %LeafBlock
  %7 = bitcast %struct.sockaddr* %0 to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %7, i32 0, i32 1
  %8 = load i16, i16* %sin_port, align 2, !tbaa !191
  %conv2 = zext i16 %8 to i32
  %cmp = icmp ne i32 %conv2, 0
  br i1 %cmp, label %if.then4, label %do.body7

if.then4:                                         ; preds = %sw.bb
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  br label %do.body7

do.body7:                                         ; preds = %if.then4, %sw.bb
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work, i32 0)
  %connect_worker8 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work9 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker8, i32 0, i32 0
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work9, i32 0, i32 0
  %counter = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !339
  %9 = bitcast %struct.pgprot* %data to i8*
  %10 = bitcast %struct.pgprot* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 8, i32 8, i1 false), !tbaa.struct !340
  %connect_worker10 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work11 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker10, i32 0, i32 0
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work11, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.42.165, i32 0, i32 0), %struct.lock_class_key* @xs_setup_udp.__key, i32 0)
  %connect_worker12 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work13 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker12, i32 0, i32 0
  %entry14 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work13, i32 0, i32 1
  call void @INIT_LIST_HEAD.166(%struct.list_head* %entry14)
  %connect_worker16 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work17 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker16, i32 0, i32 0
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work17, i32 0, i32 2
  store void (%struct.work_struct*)* @xs_udp_setup_socket, void (%struct.work_struct*)** %func, align 8, !tbaa !341
  %connect_worker24 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %timer = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker24, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer, i32 2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.44.167, i32 0, i32 0), %struct.lock_class_key* @xs_setup_udp.__key.43)
  %connect_worker27 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %timer28 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker27, i32 0, i32 1
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer28, i32 0, i32 3
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function, align 8, !tbaa !342
  %connect_worker29 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %11 = ptrtoint %struct.delayed_work* %connect_worker29 to i64
  %connect_worker30 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %timer31 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker30, i32 0, i32 1
  %data32 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer31, i32 0, i32 4
  store i64 %11, i64* %data32, align 8, !tbaa !343
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.47.591, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.47.591, i32 0, i32 0))
  br label %sw.epilog

sw.bb37:                                          ; preds = %LeafBlock1
  %12 = bitcast %struct.sockaddr* %0 to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %12, i32 0, i32 1
  %13 = load i16, i16* %sin6_port, align 2, !tbaa !194
  %conv38 = zext i16 %13 to i32
  %cmp39 = icmp ne i32 %conv38, 0
  br i1 %cmp39, label %if.then41, label %do.body45

if.then41:                                        ; preds = %sw.bb37
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  br label %do.body45

do.body45:                                        ; preds = %if.then41, %sw.bb37
  %connect_worker46 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work47 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker46, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work47, i32 0)
  %connect_worker48 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work49 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker48, i32 0, i32 0
  %data50 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work49, i32 0, i32 0
  %counter52 = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral51, i32 0, i32 0
  store i64 137438953408, i64* %counter52, align 8, !tbaa !339
  %14 = bitcast %struct.pgprot* %data50 to i8*
  %15 = bitcast %struct.pgprot* %.compoundliteral51 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %15, i64 8, i32 8, i1 false), !tbaa.struct !340
  %connect_worker53 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work54 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker53, i32 0, i32 0
  %lockdep_map55 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work54, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map55, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.42.165, i32 0, i32 0), %struct.lock_class_key* @xs_setup_udp.__key.46, i32 0)
  %connect_worker56 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work57 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker56, i32 0, i32 0
  %entry58 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work57, i32 0, i32 1
  call void @INIT_LIST_HEAD.166(%struct.list_head* %entry58)
  %connect_worker60 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work61 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker60, i32 0, i32 0
  %func62 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work61, i32 0, i32 2
  store void (%struct.work_struct*)* @xs_udp_setup_socket, void (%struct.work_struct*)** %func62, align 8, !tbaa !341
  %connect_worker71 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %timer72 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker71, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer72, i32 2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.44.167, i32 0, i32 0), %struct.lock_class_key* @xs_setup_udp.__key.47)
  %connect_worker75 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %timer76 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker75, i32 0, i32 1
  %function77 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer76, i32 0, i32 3
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function77, align 8, !tbaa !342
  %connect_worker78 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %16 = ptrtoint %struct.delayed_work* %connect_worker78 to i64
  %connect_worker79 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %timer80 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker79, i32 0, i32 1
  %data81 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer80, i32 0, i32 4
  store i64 %16, i64* %data81, align 8, !tbaa !343
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.47.591, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.26.586, i32 0, i32 0))
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.body45, %do.body7
  %call87 = call i32 @xprt_bound.168(%struct.rpc_xprt* %call)
  %tobool88 = icmp ne i32 %call87, 0
  %17 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %17, 128
  %tobool91 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool91, true
  %lnot92 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot92 to i32
  %conv93 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv93, i64 0)
  %tobool94 = icmp ne i64 %expval, 0
  br i1 %tobool88, label %do.body90, label %do.body104

do.body90:                                        ; preds = %sw.epilog
  br i1 %tobool94, label %if.then95, label %if.end123

if.then95:                                        ; preds = %do.body90
  %18 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end123

do.body104:                                       ; preds = %sw.epilog
  br i1 %tobool94, label %if.then114, label %if.end123

if.then114:                                       ; preds = %do.body104
  %19 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end123

if.end123:                                        ; preds = %if.then114, %do.body104, %if.then95, %do.body90
  %call124 = call zeroext i1 @try_module_get(%struct.module* @__this_module)
  br i1 %call124, label %cleanup, label %out_err

out_err:                                          ; preds = %if.end123, %LeafBlock, %LeafBlock1
  %.sink = phi i64 [ -22, %if.end123 ], [ -97, %LeafBlock ], [ -97, %LeafBlock1 ]
  %call127 = call i8* @ERR_PTR.133(i64 %.sink)
  %20 = bitcast i8* %call127 to %struct.rpc_xprt*
  call void @xprt_free(%struct.rpc_xprt* %call)
  br label %cleanup

cleanup:                                          ; preds = %out_err, %if.end123, %entry
  %retval.0 = phi %struct.rpc_xprt* [ %20, %out_err ], [ %call, %entry ], [ %call, %if.end123 ]
  ret %struct.rpc_xprt* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_setup_socket(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -2256
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %xprt1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 0
  %2 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !384
  %flags = getelementptr inbounds %struct.task_struct, %struct.task_struct* %2, i32 0, i32 3
  %3 = load i32, i32* %flags, align 4, !tbaa !385
  %or = or i32 %3, 131072
  store i32 %or, i32* %flags, align 4, !tbaa !385
  call void @xs_reset_transport(%struct.sock_xprt* %1)
  %call3 = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt1)
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %call3, i32 0, i32 0
  %4 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %4 to i32
  %call4 = call %struct.socket* @xs_create_sock(%struct.rpc_xprt* %xprt1, %struct.sock_xprt* %1, i32 %conv, i32 2, i32 17)
  %5 = bitcast %struct.socket* %call4 to i8*
  %call5 = call i64 @IS_ERR.129(i8* %5)
  %tobool = icmp ne i64 %call5, 0
  br i1 %tobool, label %out, label %do.body

do.body:                                          ; preds = %entry
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %6, 128
  %tobool6 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool6, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv8 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %do.end

if.then10:                                        ; preds = %do.body
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then10, %do.body
  call void @xs_udp_finish_connecting(%struct.rpc_xprt* %xprt1, %struct.socket* %call4)
  br label %out

out:                                              ; preds = %do.end, %entry
  %status.0 = phi i32 [ 0, %do.end ], [ -5, %entry ]
  call void @xprt_clear_connecting(%struct.rpc_xprt* %xprt1)
  call void @xprt_wake_pending_tasks(%struct.rpc_xprt* %xprt1, i32 %status.0)
  %8 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !384
  %flags18 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %8, i32 0, i32 3
  %9 = load i32, i32* %flags18, align 4, !tbaa !385
  %and19 = and i32 %9, -131073
  store i32 %and19, i32* %flags18, align 4, !tbaa !385
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_finish_connecting(%struct.rpc_xprt* %xprt, %struct.socket* %sock) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  %2 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !361
  %tobool = icmp ne %struct.sock* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sk1 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %3 = load %struct.sock*, %struct.sock** %sk1, align 8, !tbaa !387
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 32
  call void @_raw_write_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  call void @xs_save_old_callbacks(%struct.sock_xprt* %1, %struct.sock* %3)
  %4 = bitcast %struct.rpc_xprt* %xprt to i8*
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 47
  store i8* %4, i8** %sk_user_data, align 8, !tbaa !398
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 57
  store void (%struct.sock*, i32)* @xs_udp_data_ready, void (%struct.sock*, i32)** %sk_data_ready, align 8, !tbaa !399
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 58
  store void (%struct.sock*)* @xs_udp_write_space, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !401
  %sk_no_check = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 20
  %bf.load = load i32, i32* %sk_no_check, align 8
  %bf.clear = and i32 %bf.load, -13
  %bf.set = or i32 %bf.clear, 8
  store i32 %bf.set, i32* %sk_no_check, align 8
  %sk_allocation = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 22
  store i32 32, i32* %sk_allocation, align 8, !tbaa !402
  call void @xprt_set_connected(%struct.rpc_xprt* %xprt)
  %sock2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  store %struct.socket* %sock, %struct.socket** %sock2, align 8, !tbaa !371
  %inet3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  store %struct.sock* %3, %struct.sock** %inet3, align 8, !tbaa !361
  call void @xs_set_memalloc(%struct.rpc_xprt* %xprt)
  %sk_callback_lock4 = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 32
  call void @_raw_write_unlock_bh(%struct.rwlock_t* %sk_callback_lock4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @xs_udp_do_set_buffer_size(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_data_ready(%struct.sock* %sk, i32 %len) #0 {
entry:
  %err = alloca i32, align 4
  %_xid = alloca i32, align 4
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 32
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %call3 = call %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk)
  %tobool4 = icmp ne %struct.rpc_xprt* %call3, null
  br i1 %tobool4, label %if.end6, label %out

if.end6:                                          ; preds = %do.end
  %call7 = call %struct.sk_buff* @skb_recv_datagram(%struct.sock* %sk, i32 0, i32 1, i32* %err)
  %cmp = icmp eq %struct.sk_buff* %call7, null
  br i1 %cmp, label %out, label %if.end10

if.end10:                                         ; preds = %if.end6
  %len11 = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %call7, i32 0, i32 8
  %2 = load i32, i32* %len11, align 8, !tbaa !348
  %conv12 = zext i32 %2 to i64
  %sub = sub i64 %conv12, 8
  %conv13 = trunc i64 %sub to i32
  %cmp14 = icmp slt i32 %conv13, 4
  br i1 %cmp14, label %do.body17, label %if.end32

do.body17:                                        ; preds = %if.end10
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and18 = and i32 %3, 128
  %tobool19 = icmp ne i32 %and18, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %expval25 = call i64 @llvm.expect.i64(i64 %conv24, i64 0)
  %tobool26 = icmp ne i64 %expval25, 0
  br i1 %tobool26, label %if.then27, label %dropit

if.then27:                                        ; preds = %do.body17
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %dropit

if.end32:                                         ; preds = %if.end10
  %5 = bitcast i32* %_xid to i8*
  %call33 = call i8* @skb_header_pointer(%struct.sk_buff* %call7, i32 8, i32 4, i8* %5)
  %6 = bitcast i8* %call33 to i32*
  %cmp34 = icmp eq i32* %6, null
  br i1 %cmp34, label %dropit, label %if.end37

if.end37:                                         ; preds = %if.end32
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call3, i32 0, i32 29
  call void @spin_lock.177(%struct.spinlock* %transport_lock)
  %7 = load i32, i32* %6, align 4, !tbaa !49
  %call38 = call %struct.rpc_rqst* @xprt_lookup_rqst(%struct.rpc_xprt* %call3, i32 %7)
  %tobool39 = icmp ne %struct.rpc_rqst* %call38, null
  br i1 %tobool39, label %if.end41, label %out_unlock

if.end41:                                         ; preds = %if.end37
  %rq_task = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call38, i32 0, i32 3
  %8 = load %struct.rpc_task*, %struct.rpc_task** %rq_task, align 8, !tbaa !280
  %rq_private_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call38, i32 0, i32 17
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf, i32 0, i32 6
  %9 = load i32, i32* %buflen, align 4, !tbaa !443
  %cmp42 = icmp sgt i32 %9, %conv13
  %conv13. = select i1 %cmp42, i32 %conv13, i32 %9
  %rq_private_buf46 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call38, i32 0, i32 17
  %call47 = call i32 @csum_partial_copy_to_xdr(%struct.xdr_buf* %rq_private_buf46, %struct.sk_buff* %call7)
  %tobool48 = icmp ne i32 %call47, 0
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_family = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 3
  %10 = load i16, i16* %skc_family, align 8, !tbaa !462
  %conv51 = zext i16 %10 to i32
  %cmp52 = icmp eq i32 %conv51, 2
  %call61 = call %struct.net* @sock_net(%struct.sock* %sk)
  %mib = getelementptr inbounds %struct.net, %struct.net* %call61, i32 0, i32 21
  br i1 %tobool48, label %do.body50, label %do.body92

do.body50:                                        ; preds = %if.end41
  br i1 %cmp52, label %do.body60, label %do.body75

do.body60:                                        ; preds = %do.body50
  %udp_statistics = getelementptr inbounds %struct.netns_mib, %struct.netns_mib* %mib, i32 0, i32 3
  %arrayidx = getelementptr inbounds [1 x %struct.udp_mib*], [1 x %struct.udp_mib*]* %udp_statistics, i64 0, i64 0
  %11 = load %struct.udp_mib*, %struct.udp_mib** %arrayidx, align 8, !tbaa !28
  %mibs = getelementptr inbounds %struct.udp_mib, %struct.udp_mib* %11, i32 0, i32 0
  %arrayidx62 = getelementptr inbounds [8 x i64], [8 x i64]* %mibs, i64 0, i64 3
  call void asm "incq %gs:${0:P}", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arrayidx62, i64* %arrayidx62) #7, !srcloc !463
  br label %out_unlock

do.body75:                                        ; preds = %do.body50
  %udp_stats_in6 = getelementptr inbounds %struct.netns_mib, %struct.netns_mib* %mib, i32 0, i32 8
  %arrayidx79 = getelementptr inbounds [1 x %struct.udp_mib*], [1 x %struct.udp_mib*]* %udp_stats_in6, i64 0, i64 0
  %12 = load %struct.udp_mib*, %struct.udp_mib** %arrayidx79, align 32, !tbaa !28
  %mibs80 = getelementptr inbounds %struct.udp_mib, %struct.udp_mib* %12, i32 0, i32 0
  %arrayidx81 = getelementptr inbounds [8 x i64], [8 x i64]* %mibs80, i64 0, i64 3
  call void asm "incq %gs:${0:P}", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arrayidx81, i64* %arrayidx81) #7, !srcloc !464
  br label %out_unlock

do.body92:                                        ; preds = %if.end41
  br i1 %cmp52, label %do.body105, label %do.body126

do.body105:                                       ; preds = %do.body92
  %udp_statistics109 = getelementptr inbounds %struct.netns_mib, %struct.netns_mib* %mib, i32 0, i32 3
  %arrayidx110 = getelementptr inbounds [1 x %struct.udp_mib*], [1 x %struct.udp_mib*]* %udp_statistics109, i64 0, i64 0
  %13 = load %struct.udp_mib*, %struct.udp_mib** %arrayidx110, align 8, !tbaa !28
  %mibs111 = getelementptr inbounds %struct.udp_mib, %struct.udp_mib* %13, i32 0, i32 0
  %arrayidx112 = getelementptr inbounds [8 x i64], [8 x i64]* %mibs111, i64 0, i64 1
  call void asm "incq %gs:${0:P}", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arrayidx112, i64* %arrayidx112) #7, !srcloc !465
  br label %do.end142

do.body126:                                       ; preds = %do.body92
  %udp_stats_in6130 = getelementptr inbounds %struct.netns_mib, %struct.netns_mib* %mib, i32 0, i32 8
  %arrayidx131 = getelementptr inbounds [1 x %struct.udp_mib*], [1 x %struct.udp_mib*]* %udp_stats_in6130, i64 0, i64 0
  %14 = load %struct.udp_mib*, %struct.udp_mib** %arrayidx131, align 32, !tbaa !28
  %mibs132 = getelementptr inbounds %struct.udp_mib, %struct.udp_mib* %14, i32 0, i32 0
  %arrayidx133 = getelementptr inbounds [8 x i64], [8 x i64]* %mibs132, i64 0, i64 1
  call void asm "incq %gs:${0:P}", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arrayidx133, i64* %arrayidx133) #7, !srcloc !466
  br label %do.end142

do.end142:                                        ; preds = %do.body126, %do.body105
  call void @xprt_adjust_cwnd(%struct.rpc_xprt* %call3, %struct.rpc_task* %8, i32 %conv13.)
  call void @xprt_complete_rqst(%struct.rpc_task* %8, i32 %conv13.)
  br label %out_unlock

out_unlock:                                       ; preds = %do.end142, %do.body75, %do.body60, %if.end37
  %transport_lock143 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call3, i32 0, i32 29
  call void @spin_unlock.178(%struct.spinlock* %transport_lock143)
  br label %dropit

dropit:                                           ; preds = %out_unlock, %if.end32, %if.then27, %do.body17
  call void @skb_free_datagram(%struct.sock* %sk, %struct.sk_buff* %call7)
  br label %out

out:                                              ; preds = %dropit, %if.end6, %do.end
  %sk_callback_lock144 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 32
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock144)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_write_space(%struct.sock* %sk) #0 {
entry:
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 32
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %call = call zeroext i1 @sock_writeable(%struct.sock* %sk)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @xs_write_space(%struct.sock* %sk)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sk_callback_lock1 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 32
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_do_set_buffer_size(%struct.rpc_xprt* %xprt) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  %2 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !361
  %rcvsize = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 13
  %3 = load i64, i64* %rcvsize, align 8, !tbaa !467
  %tobool = icmp ne i64 %3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %sk_userlocks = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 20
  %bf.load = load i32, i32* %sk_userlocks, align 8
  %bf.lshr = lshr i32 %bf.load, 4
  %bf.clear = and i32 %bf.lshr, 15
  %or = or i32 %bf.clear, 2
  %bf.load1 = load i32, i32* %sk_userlocks, align 8
  %bf.value = and i32 %or, 15
  %bf.shl = shl i32 %bf.value, 4
  %bf.clear2 = and i32 %bf.load1, -241
  %bf.set = or i32 %bf.clear2, %bf.shl
  store i32 %bf.set, i32* %sk_userlocks, align 8
  %rcvsize3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 13
  %4 = load i64, i64* %rcvsize3, align 8, !tbaa !467
  %max_reqs = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 15
  %5 = load i32, i32* %max_reqs, align 8, !tbaa !268
  %conv = zext i32 %5 to i64
  %mul = mul i64 %4, %conv
  %mul4 = mul i64 %mul, 2
  %conv5 = trunc i64 %mul4 to i32
  %sk_rcvbuf = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 7
  store i32 %conv5, i32* %sk_rcvbuf, align 4, !tbaa !468
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sndsize = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 14
  %6 = load i64, i64* %sndsize, align 8, !tbaa !469
  %tobool6 = icmp ne i64 %6, 0
  br i1 %tobool6, label %if.then7, label %if.end24

if.then7:                                         ; preds = %if.end
  %sk_userlocks8 = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 20
  %bf.load9 = load i32, i32* %sk_userlocks8, align 8
  %bf.lshr10 = lshr i32 %bf.load9, 4
  %bf.clear11 = and i32 %bf.lshr10, 15
  %or12 = or i32 %bf.clear11, 1
  %bf.load13 = load i32, i32* %sk_userlocks8, align 8
  %bf.value14 = and i32 %or12, 15
  %bf.shl15 = shl i32 %bf.value14, 4
  %bf.clear16 = and i32 %bf.load13, -241
  %bf.set17 = or i32 %bf.clear16, %bf.shl15
  store i32 %bf.set17, i32* %sk_userlocks8, align 8
  %sndsize18 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 14
  %7 = load i64, i64* %sndsize18, align 8, !tbaa !469
  %max_reqs19 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 15
  %8 = load i32, i32* %max_reqs19, align 8, !tbaa !268
  %conv20 = zext i32 %8 to i64
  %mul21 = mul i64 %7, %conv20
  %mul22 = mul i64 %mul21, 2
  %conv23 = trunc i64 %mul22 to i32
  %sk_sndbuf = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 18
  store i32 %conv23, i32* %sk_sndbuf, align 8, !tbaa !433
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 58
  %9 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !401
  call void %9(%struct.sock* %2)
  br label %if.end24

if.end24:                                         ; preds = %if.then7, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @sock_writeable(%struct.sock* %sk) #2 {
entry:
  %sk_wmem_alloc = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 16
  %call = call i32 @atomic_read.222(%struct.atomic_t* %sk_wmem_alloc)
  %sk_sndbuf = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 18
  %0 = load i32, i32* %sk_sndbuf, align 8, !tbaa !433
  %shr = ashr i32 %0, 1
  %cmp = icmp slt i32 %call, %shr
  ret i1 %cmp
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read.222(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !49
  ret i32 %0
}

declare %struct.sk_buff* @skb_recv_datagram(%struct.sock*, i32, i32, i32*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @skb_header_pointer(%struct.sk_buff* %skb, i32 %offset, i32 %len, i8* %buffer) #2 {
entry:
  %call = call i32 @skb_headlen(%struct.sk_buff* %skb)
  %sub = sub nsw i32 %call, %offset
  %cmp = icmp sge i32 %sub, %len
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %data = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 40
  %0 = load i8*, i8** %data, align 8, !tbaa !351
  %idx.ext = sext i32 %offset to i64
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 %idx.ext
  br label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @skb_copy_bits(%struct.sk_buff* %skb, i32 %offset, i8* %buffer, i32 %len)
  %cmp2 = icmp slt i32 %call1, 0
  %.buffer = select i1 %cmp2, i8* null, i8* %buffer
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %add.ptr, %if.then ], [ %.buffer, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.net* @sock_net(%struct.sock* %sk) #2 {
entry:
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_net = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 9
  %call = call %struct.net* @read_pnet(%struct.net** %skc_net)
  ret %struct.net* %call
}

declare void @skb_free_datagram(%struct.sock*, %struct.sk_buff*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.net* @read_pnet(%struct.net** %pnet) #2 {
entry:
  %0 = load %struct.net*, %struct.net** %pnet, align 8, !tbaa !28
  ret %struct.net* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @skb_headlen(%struct.sk_buff* %skb) #2 {
entry:
  %len = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 8
  %0 = load i32, i32* %len, align 8, !tbaa !348
  %data_len = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 9
  %1 = load i32, i32* %data_len, align 4, !tbaa !470
  %sub = sub i32 %0, %1
  ret i32 %sub
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_set_buffer_size(%struct.rpc_xprt* %xprt, i64 %sndsize, i64 %rcvsize) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %sndsize1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 14
  store i64 0, i64* %sndsize1, align 8, !tbaa !469
  %tobool = icmp ne i64 %sndsize, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %add = add i64 %sndsize, 1024
  %sndsize2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 14
  store i64 %add, i64* %sndsize2, align 8, !tbaa !469
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rcvsize3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 13
  store i64 0, i64* %rcvsize3, align 8, !tbaa !467
  %tobool4 = icmp ne i64 %rcvsize, 0
  br i1 %tobool4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end
  %add6 = add i64 %rcvsize, 1024
  %rcvsize7 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 13
  store i64 %add6, i64* %rcvsize7, align 8, !tbaa !467
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %if.end
  call void @xs_udp_do_set_buffer_size(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_udp_send_request(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  call void @xs_pktdump()
  %call = call i32 @xprt_bound.168(%struct.rpc_xprt* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %4 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !371
  %call5 = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %1)
  %addrlen = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 4
  %5 = load i64, i64* %addrlen, align 8, !tbaa !188
  %conv6 = trunc i64 %5 to i32
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  %6 = load i32, i32* %rq_bytes_sent, align 8, !tbaa !143
  %call7 = call i32 @xs_sendpages(%struct.socket* %4, %struct.sockaddr* %call5, i32 %conv6, %struct.xdr_buf* %rq_snd_buf, i32 %6)
  %7 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %7, 128
  %tobool8 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool8, true
  %lnot9 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv10 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv10, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %if.then12, label %do.end

if.then12:                                        ; preds = %if.end
  %8 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then12, %if.end
  %cmp = icmp sge i32 %call7, 0
  br i1 %cmp, label %if.then17, label %NodeBlock13

if.then17:                                        ; preds = %do.end
  %conv18 = sext i32 %call7 to i64
  %rq_xmit_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 15
  %9 = load i64, i64* %rq_xmit_bytes_sent, align 8, !tbaa !447
  %add = add i64 %9, %conv18
  store i64 %add, i64* %rq_xmit_bytes_sent, align 8, !tbaa !447
  %rq_snd_buf19 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %len20 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf19, i32 0, i32 7
  %10 = load i32, i32* %len20, align 8, !tbaa !145
  %cmp21 = icmp uge i32 %call7, %10
  br i1 %cmp21, label %cleanup, label %NodeBlock13

NodeBlock13:                                      ; preds = %if.then17, %do.end
  %status.0 = phi i32 [ %call7, %do.end ], [ -11, %if.then17 ]
  %Pivot14 = icmp slt i32 %status.0, -88
  br i1 %Pivot14, label %NodeBlock, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %status.0, -32
  br i1 %Pivot12, label %LeafBlock3, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %status.0, -11
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %status.0, -11
  br i1 %SwitchLeaf8, label %sw.bb26, label %do.body28

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %status.0, -32
  br i1 %SwitchLeaf6, label %sw.bb44, label %do.body28

LeafBlock3:                                       ; preds = %NodeBlock11
  %SwitchLeaf4 = icmp eq i32 %status.0, -88
  br i1 %SwitchLeaf4, label %cleanup, label %do.body28

NodeBlock:                                        ; preds = %NodeBlock13
  %Pivot = icmp slt i32 %status.0, -101
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %status.0, -101
  br i1 %SwitchLeaf2, label %sw.bb44, label %do.body28

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %status.0, -111
  br i1 %SwitchLeaf, label %sw.bb44, label %do.body28

sw.bb26:                                          ; preds = %LeafBlock7
  %call27 = call i32 @xs_nospace(%struct.rpc_task* %task)
  br label %cleanup

do.body28:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5, %LeafBlock7
  %11 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and29 = and i32 %11, 128
  %tobool30 = icmp ne i32 %and29, 0
  %lnot31 = xor i1 %tobool30, true
  %lnot33 = xor i1 %lnot31, true
  %lnot.ext34 = zext i1 %lnot33 to i32
  %conv35 = sext i32 %lnot.ext34 to i64
  %expval36 = call i64 @llvm.expect.i64(i64 %conv35, i64 0)
  %tobool37 = icmp ne i64 %expval36, 0
  br i1 %tobool37, label %if.then38, label %sw.bb44

if.then38:                                        ; preds = %do.body28
  %12 = call i32 (i8*, ...) @printk(i8* null)
  br label %sw.bb44

sw.bb44:                                          ; preds = %if.then38, %do.body28, %LeafBlock, %LeafBlock1, %LeafBlock5
  %sock45 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %13 = load %struct.socket*, %struct.socket** %sock45, align 8, !tbaa !371
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %13, i32 0, i32 2
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags, i32 0, i64* %flags) #7, !srcloc !386
  br label %cleanup

cleanup:                                          ; preds = %sw.bb44, %sw.bb26, %LeafBlock3, %if.then17, %entry
  %retval.0 = phi i32 [ -107, %entry ], [ 0, %if.then17 ], [ %status.0, %sw.bb44 ], [ %call27, %sw.bb26 ], [ -107, %LeafBlock3 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_timer(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  call void @xprt_adjust_cwnd(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task, i32 -110)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_print_stats(%struct.rpc_xprt* %xprt, %struct.seq_file* %seq) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 12
  %2 = load i16, i16* %srcport, align 8, !tbaa !377
  %conv = zext i16 %2 to i32
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %bind_count = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat, i32 0, i32 0
  %3 = load i64, i64* %bind_count, align 8, !tbaa !378
  %stat1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %sends = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat1, i32 0, i32 4
  %4 = load i64, i64* %sends, align 8, !tbaa !320
  %stat2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %recvs = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat2, i32 0, i32 5
  %5 = load i64, i64* %recvs, align 8, !tbaa !289
  %stat3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %bad_xids = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat3, i32 0, i32 6
  %6 = load i64, i64* %bad_xids, align 8, !tbaa !299
  %stat4 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %req_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat4, i32 0, i32 8
  %7 = load i64, i64* %req_u, align 8, !tbaa !321
  %stat5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %bklog_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat5, i32 0, i32 9
  %8 = load i64, i64* %bklog_u, align 8, !tbaa !323
  %stat6 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %max_slots = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat6, i32 0, i32 7
  %9 = load i64, i64* %max_slots, align 8, !tbaa !319
  %stat7 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %sending_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat7, i32 0, i32 10
  %10 = load i64, i64* %sending_u, align 8, !tbaa !325
  %stat8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %pending_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat8, i32 0, i32 11
  %11 = load i64, i64* %pending_u, align 8, !tbaa !327
  %call = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.56.225, i32 0, i32 0), i32 %conv, i64 %3, i64 %4, i64 %5, i64 %6, i64 %7, i64 %8, i64 %9, i64 %10, i64 %11)
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_xprt* @xs_setup_local(%struct.xprt_create* %args) #0 {
entry:
  %dstaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %0 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr, align 8, !tbaa !251
  %1 = bitcast %struct.sockaddr* %0 to %struct.sockaddr_un*
  %2 = load i32, i32* @xprt_tcp_slot_table_entries, align 4, !tbaa !49
  %3 = load i32, i32* @xprt_max_tcp_slot_table_entries, align 4, !tbaa !49
  %call = call %struct.rpc_xprt* @xs_setup_xprt(%struct.xprt_create* %args, i32 %2, i32 %3)
  %4 = bitcast %struct.rpc_xprt* %call to i8*
  %call1 = call i64 @IS_ERR.129(i8* %4)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %5 = bitcast %struct.rpc_xprt* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 0
  %6 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %prot = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 5
  store i32 0, i32* %prot, align 8, !tbaa !186
  %tsh_size = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 9
  store i32 1, i32* %tsh_size, align 8, !tbaa !157
  %max_payload = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 8
  store i64 2147483647, i64* %max_payload, align 8, !tbaa !185
  %bind_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 22
  store i64 15000, i64* %bind_timeout, align 8, !tbaa !85
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 750, i64* %reestablish_timeout, align 8, !tbaa !367
  %idle_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 28
  store i64 75000, i64* %idle_timeout, align 8, !tbaa !336
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 1
  store %struct.rpc_xprt_ops* @xs_local_ops, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 2
  store %struct.rpc_timeout* @xs_local_default_timeout, %struct.rpc_timeout** %timeout, align 8, !tbaa !183
  %sun_family = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %1, i32 0, i32 0
  %7 = load i16, i16* %sun_family, align 2, !tbaa !471
  %conv = zext i16 %7 to i32
  %SwitchLeaf = icmp eq i32 %conv, 1
  br i1 %SwitchLeaf, label %sw.bb, label %out_err.sink.split

sw.bb:                                            ; preds = %if.end
  %sun_path = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %1, i32 0, i32 1
  %arrayidx = getelementptr inbounds [108 x i8], [108 x i8]* %sun_path, i64 0, i64 0
  %8 = load i8, i8* %arrayidx, align 2, !tbaa !166
  %conv2 = sext i8 %8 to i32
  %cmp = icmp ne i32 %conv2, 47
  br i1 %cmp, label %do.body, label %if.end14

do.body:                                          ; preds = %sw.bb
  %9 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %9, 128
  %tobool5 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool5, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then9, label %out_err.sink.split

if.then9:                                         ; preds = %do.body
  %10 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_err.sink.split

if.end14:                                         ; preds = %sw.bb
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.8.228, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.8.228, i32 0, i32 0))
  %call15 = call i32 @xs_local_setup_socket(%struct.sock_xprt* %6)
  %conv16 = sext i32 %call15 to i64
  %call17 = call i8* @ERR_PTR.133(i64 %conv16)
  %11 = bitcast i8* %call17 to %struct.rpc_xprt*
  %tobool18 = icmp ne %struct.rpc_xprt* %11, null
  br i1 %tobool18, label %out_err, label %do.body22

do.body22:                                        ; preds = %if.end14
  %12 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and23 = and i32 %12, 128
  %tobool24 = icmp ne i32 %and23, 0
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot.ext28 = zext i1 %lnot27 to i32
  %conv29 = sext i32 %lnot.ext28 to i64
  %expval30 = call i64 @llvm.expect.i64(i64 %conv29, i64 0)
  %tobool31 = icmp ne i64 %expval30, 0
  br i1 %tobool31, label %if.then32, label %do.end37

if.then32:                                        ; preds = %do.body22
  %13 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end37

do.end37:                                         ; preds = %if.then32, %do.body22
  %call38 = call zeroext i1 @try_module_get(%struct.module* @__this_module)
  br i1 %call38, label %cleanup, label %out_err.sink.split

out_err.sink.split:                               ; preds = %do.end37, %if.then9, %do.body, %if.end
  %.sink = phi i64 [ -22, %do.end37 ], [ -22, %if.then9 ], [ -22, %do.body ], [ -97, %if.end ]
  %call41 = call i8* @ERR_PTR.133(i64 %.sink)
  %14 = bitcast i8* %call41 to %struct.rpc_xprt*
  br label %out_err

out_err:                                          ; preds = %out_err.sink.split, %if.end14
  %ret.0 = phi %struct.rpc_xprt* [ %11, %if.end14 ], [ %14, %out_err.sink.split ]
  call void @xprt_free(%struct.rpc_xprt* %call)
  br label %cleanup

cleanup:                                          ; preds = %out_err, %do.end37, %entry
  %retval.0 = phi %struct.rpc_xprt* [ %ret.0, %out_err ], [ %call, %entry ], [ %call, %do.end37 ]
  ret %struct.rpc_xprt* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_local_setup_socket(%struct.sock_xprt* %transport) #0 {
entry:
  %sock = alloca %struct.socket*, align 8
  %xprt1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !384
  %flags = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 3
  %1 = load i32, i32* %flags, align 4, !tbaa !385
  %or = or i32 %1, 131072
  store i32 %or, i32* %flags, align 4, !tbaa !385
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt1, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 7, i64* %state) #7, !srcloc !386
  %xprt_net = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt1, i32 0, i32 40
  %2 = load %struct.net*, %struct.net** %xprt_net, align 8, !tbaa !171
  %call2 = call i32 @__sock_create(%struct.net* %2, i32 1, i32 1, i32 0, %struct.socket** %sock, i32 1)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %do.body, label %if.end7

do.body:                                          ; preds = %entry
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %3, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then5, label %out

if.then5:                                         ; preds = %do.body
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %out

if.end7:                                          ; preds = %entry
  %5 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  call void @xs_reclassify_socketu(%struct.socket* %5)
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and9 = and i32 %6, 128
  %tobool10 = icmp ne i32 %and9, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %if.then18, label %do.end22

if.then18:                                        ; preds = %if.end7
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end22

do.end22:                                         ; preds = %if.then18, %if.end7
  %8 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  %call23 = call i32 @xs_local_finish_connecting(%struct.rpc_xprt* %xprt1, %struct.socket* %8)
  %Pivot6 = icmp slt i32 %call23, -2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %do.end22
  %Pivot = icmp slt i32 %call23, 0
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %call23, 0
  br i1 %SwitchLeaf4, label %do.body24, label %sw.default

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %call23, -2
  br i1 %SwitchLeaf2, label %do.body42, label %sw.default

LeafBlock:                                        ; preds = %do.end22
  %SwitchLeaf = icmp eq i32 %call23, -111
  br i1 %SwitchLeaf, label %do.body60, label %sw.default

do.body24:                                        ; preds = %LeafBlock3
  %9 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and25 = and i32 %9, 128
  %tobool26 = icmp ne i32 %and25, 0
  %lnot27 = xor i1 %tobool26, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %if.then34, label %do.end40

if.then34:                                        ; preds = %do.body24
  %10 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end40

do.end40:                                         ; preds = %if.then34, %do.body24
  call void @xprt_set_connected(%struct.rpc_xprt* %xprt1)
  br label %out

do.body42:                                        ; preds = %LeafBlock1
  %11 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and43 = and i32 %11, 128
  %tobool44 = icmp ne i32 %and43, 0
  %lnot45 = xor i1 %tobool44, true
  %lnot47 = xor i1 %lnot45, true
  %lnot.ext48 = zext i1 %lnot47 to i32
  %conv49 = sext i32 %lnot.ext48 to i64
  %expval50 = call i64 @llvm.expect.i64(i64 %conv49, i64 0)
  %tobool51 = icmp ne i64 %expval50, 0
  br i1 %tobool51, label %if.then52, label %out

if.then52:                                        ; preds = %do.body42
  %12 = call i32 (i8*, ...) @printk(i8* null)
  br label %out

do.body60:                                        ; preds = %LeafBlock
  %13 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and61 = and i32 %13, 128
  %tobool62 = icmp ne i32 %and61, 0
  %lnot63 = xor i1 %tobool62, true
  %lnot65 = xor i1 %lnot63, true
  %lnot.ext66 = zext i1 %lnot65 to i32
  %conv67 = sext i32 %lnot.ext66 to i64
  %expval68 = call i64 @llvm.expect.i64(i64 %conv67, i64 0)
  %tobool69 = icmp ne i64 %expval68, 0
  br i1 %tobool69, label %if.then70, label %out

if.then70:                                        ; preds = %do.body60
  %14 = call i32 (i8*, ...) @printk(i8* null)
  br label %out

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  %15 = call i32 (i8*, ...) @printk(i8* null)
  br label %out

out:                                              ; preds = %sw.default, %if.then70, %do.body60, %if.then52, %do.body42, %do.end40, %if.then5, %do.body
  %status.0 = phi i32 [ %call2, %if.then5 ], [ %call2, %do.body ], [ %call23, %do.body60 ], [ %call23, %if.then70 ], [ %call23, %do.body42 ], [ %call23, %if.then52 ], [ %call23, %sw.default ], [ %call23, %do.end40 ]
  call void @xprt_clear_connecting(%struct.rpc_xprt* %xprt1)
  call void @xprt_wake_pending_tasks(%struct.rpc_xprt* %xprt1, i32 %status.0)
  %16 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !384
  %flags82 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %16, i32 0, i32 3
  %17 = load i32, i32* %flags82, align 4, !tbaa !385
  %and83 = and i32 %17, -131073
  store i32 %and83, i32* %flags82, align 4, !tbaa !385
  ret i32 %status.0
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_local_finish_connecting(%struct.rpc_xprt* %xprt, %struct.socket* %sock) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  %2 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !361
  %tobool = icmp ne %struct.sock* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sk1 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %3 = load %struct.sock*, %struct.sock** %sk1, align 8, !tbaa !387
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 32
  call void @_raw_write_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  call void @xs_save_old_callbacks(%struct.sock_xprt* %1, %struct.sock* %3)
  %4 = bitcast %struct.rpc_xprt* %xprt to i8*
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 47
  store i8* %4, i8** %sk_user_data, align 8, !tbaa !398
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 57
  store void (%struct.sock*, i32)* @xs_local_data_ready, void (%struct.sock*, i32)** %sk_data_ready, align 8, !tbaa !399
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 58
  store void (%struct.sock*)* @xs_udp_write_space, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !401
  %sk_allocation = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 22
  store i32 32, i32* %sk_allocation, align 8, !tbaa !402
  call void @xprt_clear_connected.176(%struct.rpc_xprt* %xprt)
  %sock2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  store %struct.socket* %sock, %struct.socket** %sock2, align 8, !tbaa !371
  %inet3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  store %struct.sock* %3, %struct.sock** %inet3, align 8, !tbaa !361
  %sk_callback_lock4 = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 32
  call void @_raw_write_unlock_bh(%struct.rwlock_t* %sk_callback_lock4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %connect_count = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat, i32 0, i32 1
  %5 = load i64, i64* %connect_count, align 8, !tbaa !315
  %inc = add i64 %5, 1
  store i64 %inc, i64* %connect_count, align 8, !tbaa !315
  %6 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %stat5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %connect_start = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat5, i32 0, i32 2
  store i64 %6, i64* %connect_start, align 8, !tbaa !312
  %call = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt)
  %addrlen = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 4
  %7 = load i64, i64* %addrlen, align 8, !tbaa !188
  %conv = trunc i64 %7 to i32
  %call6 = call i32 @kernel_connect(%struct.socket* %sock, %struct.sockaddr* %call, i32 %conv, i32 0)
  ret i32 %call6
}

; Function Attrs: nounwind uwtable
define internal void @xs_local_data_ready(%struct.sock* %sk, i32 %len) #0 {
entry:
  %err = alloca i32, align 4
  %_xid = alloca i32, align 4
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 32
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %call3 = call %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk)
  %cmp = icmp eq %struct.rpc_xprt* %call3, null
  br i1 %cmp, label %out, label %if.end6

if.end6:                                          ; preds = %do.end
  %call7 = call %struct.sk_buff* @skb_recv_datagram(%struct.sock* %sk, i32 0, i32 1, i32* %err)
  %cmp8 = icmp eq %struct.sk_buff* %call7, null
  br i1 %cmp8, label %out, label %if.end11

if.end11:                                         ; preds = %if.end6
  %len12 = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %call7, i32 0, i32 8
  %2 = load i32, i32* %len12, align 8, !tbaa !348
  %conv13 = zext i32 %2 to i64
  %sub = sub i64 %conv13, 4
  %conv14 = trunc i64 %sub to i32
  %cmp15 = icmp slt i32 %conv14, 4
  br i1 %cmp15, label %do.body18, label %if.end33

do.body18:                                        ; preds = %if.end11
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and19 = and i32 %3, 128
  %tobool20 = icmp ne i32 %and19, 0
  %lnot21 = xor i1 %tobool20, true
  %lnot23 = xor i1 %lnot21, true
  %lnot.ext24 = zext i1 %lnot23 to i32
  %conv25 = sext i32 %lnot.ext24 to i64
  %expval26 = call i64 @llvm.expect.i64(i64 %conv25, i64 0)
  %tobool27 = icmp ne i64 %expval26, 0
  br i1 %tobool27, label %if.then28, label %dropit

if.then28:                                        ; preds = %do.body18
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %dropit

if.end33:                                         ; preds = %if.end11
  %5 = bitcast i32* %_xid to i8*
  %call34 = call i8* @skb_header_pointer(%struct.sk_buff* %call7, i32 4, i32 4, i8* %5)
  %6 = bitcast i8* %call34 to i32*
  %cmp35 = icmp eq i32* %6, null
  br i1 %cmp35, label %dropit, label %if.end38

if.end38:                                         ; preds = %if.end33
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call3, i32 0, i32 29
  call void @spin_lock.177(%struct.spinlock* %transport_lock)
  %7 = load i32, i32* %6, align 4, !tbaa !49
  %call39 = call %struct.rpc_rqst* @xprt_lookup_rqst(%struct.rpc_xprt* %call3, i32 %7)
  %tobool40 = icmp ne %struct.rpc_rqst* %call39, null
  br i1 %tobool40, label %if.end42, label %out_unlock

if.end42:                                         ; preds = %if.end38
  %rq_task = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call39, i32 0, i32 3
  %8 = load %struct.rpc_task*, %struct.rpc_task** %rq_task, align 8, !tbaa !280
  %rq_private_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call39, i32 0, i32 17
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf, i32 0, i32 6
  %9 = load i32, i32* %buflen, align 4, !tbaa !443
  %cmp43 = icmp sgt i32 %9, %conv14
  %conv14. = select i1 %cmp43, i32 %conv14, i32 %9
  %rq_private_buf47 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call39, i32 0, i32 17
  %call48 = call i32 @xs_local_copy_to_xdr(%struct.xdr_buf* %rq_private_buf47, %struct.sk_buff* %call7)
  %tobool49 = icmp ne i32 %call48, 0
  br i1 %tobool49, label %do.body51, label %if.end66

do.body51:                                        ; preds = %if.end42
  %10 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and52 = and i32 %10, 128
  %tobool53 = icmp ne i32 %and52, 0
  %lnot54 = xor i1 %tobool53, true
  %lnot56 = xor i1 %lnot54, true
  %lnot.ext57 = zext i1 %lnot56 to i32
  %conv58 = sext i32 %lnot.ext57 to i64
  %expval59 = call i64 @llvm.expect.i64(i64 %conv58, i64 0)
  %tobool60 = icmp ne i64 %expval59, 0
  br i1 %tobool60, label %if.then61, label %out_unlock

if.then61:                                        ; preds = %do.body51
  %11 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_unlock

if.end66:                                         ; preds = %if.end42
  call void @xprt_complete_rqst(%struct.rpc_task* %8, i32 %conv14.)
  br label %out_unlock

out_unlock:                                       ; preds = %if.end66, %if.then61, %do.body51, %if.end38
  %transport_lock67 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call3, i32 0, i32 29
  call void @spin_unlock.178(%struct.spinlock* %transport_lock67)
  br label %dropit

dropit:                                           ; preds = %out_unlock, %if.end33, %if.then28, %do.body18
  call void @skb_free_datagram(%struct.sock* %sk, %struct.sk_buff* %call7)
  br label %out

out:                                              ; preds = %dropit, %if.end6, %do.end
  %sk_callback_lock68 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 32
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock68)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_local_copy_to_xdr(%struct.xdr_buf* %xdr, %struct.sk_buff* %skb) #0 {
entry:
  %desc = alloca %struct.xdr_skb_reader, align 8
  %skb1 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 0
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb1, align 8, !tbaa !345
  %offset = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  store i32 4, i32* %offset, align 8, !tbaa !347
  %count = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %len = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 8
  %0 = load i32, i32* %len, align 8, !tbaa !348
  %conv = zext i32 %0 to i64
  %sub = sub i64 %conv, 4
  store i64 %sub, i64* %count, align 8, !tbaa !350
  %csum = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 3
  store i32 0, i32* %csum, align 8, !tbaa !352
  %call = call i64 @xdr_partial_copy_from_skb(%struct.xdr_buf* %xdr, i32 0, %struct.xdr_skb_reader* %desc, i64 (%struct.xdr_skb_reader*, i8*, i64)* @xdr_skb_read_bits)
  %cmp = icmp slt i64 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %count3 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %1 = load i64, i64* %count3, align 8, !tbaa !350
  %tobool = icmp ne i64 %1, 0
  %. = select i1 %tobool, i32 -1, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ -1, %entry ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @xs_local_set_port(%struct.rpc_xprt* %xprt, i16 zeroext %port) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_local_connect(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %2 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv = zext i16 %2 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @rpc_exit(%struct.rpc_task* %task, i32 -107)
  br label %cleanup.cont

if.end:                                           ; preds = %entry
  %call = call i32 @xs_local_setup_socket(%struct.sock_xprt* %1)
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %land.lhs.true, label %cleanup.cont

land.lhs.true:                                    ; preds = %if.end
  %tk_flags2 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %3 = load i16, i16* %tk_flags2, align 8, !tbaa !27
  %conv3 = zext i16 %3 to i32
  %and4 = and i32 %conv3, 1024
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %cleanup.cont, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %call7 = call i64 @msleep_interruptible(i32 15000)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then6, %land.lhs.true, %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_local_send_request(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %rq_snd_buf1 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  call void @xs_encode_stream_record_marker(%struct.xdr_buf* %rq_snd_buf1)
  call void @xs_pktdump()
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %4 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !371
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  %5 = load i32, i32* %rq_bytes_sent, align 8, !tbaa !143
  %call = call i32 @xs_sendpages(%struct.socket* %4, %struct.sockaddr* null, i32 0, %struct.xdr_buf* %rq_snd_buf, i32 %5)
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %6, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %cmp = icmp sge i32 %call, 0
  %lnot12 = xor i1 %cmp, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 1)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %if.then19, label %NodeBlock

if.then19:                                        ; preds = %do.end
  %rq_bytes_sent20 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  %8 = load i32, i32* %rq_bytes_sent20, align 8, !tbaa !143
  %add = add i32 %8, %call
  store i32 %add, i32* %rq_bytes_sent20, align 8, !tbaa !143
  %conv21 = sext i32 %call to i64
  %rq_xmit_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 15
  %9 = load i64, i64* %rq_xmit_bytes_sent, align 8, !tbaa !447
  %add22 = add i64 %9, %conv21
  store i64 %add22, i64* %rq_xmit_bytes_sent, align 8, !tbaa !447
  %rq_bytes_sent23 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  %10 = load i32, i32* %rq_bytes_sent23, align 8, !tbaa !143
  %rq_snd_buf24 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %len25 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf24, i32 0, i32 7
  %11 = load i32, i32* %len25, align 8, !tbaa !145
  %cmp26 = icmp uge i32 %10, %11
  %lnot28 = xor i1 %cmp26, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 1)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %NodeBlock

if.then35:                                        ; preds = %if.then19
  %rq_bytes_sent36 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  store i32 0, i32* %rq_bytes_sent36, align 8, !tbaa !143
  br label %cleanup

NodeBlock:                                        ; preds = %if.then19, %do.end
  %status.0 = phi i32 [ %call, %do.end ], [ -11, %if.then19 ]
  %Pivot = icmp slt i32 %status.0, -11
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %status.0, -11
  br i1 %SwitchLeaf2, label %sw.bb, label %do.body40

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %status.0, -32
  br i1 %SwitchLeaf, label %sw.bb56, label %do.body40

sw.bb:                                            ; preds = %LeafBlock1
  %call39 = call i32 @xs_nospace(%struct.rpc_task* %task)
  br label %cleanup

do.body40:                                        ; preds = %LeafBlock, %LeafBlock1
  %12 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and41 = and i32 %12, 128
  %tobool42 = icmp ne i32 %and41, 0
  %lnot43 = xor i1 %tobool42, true
  %lnot45 = xor i1 %lnot43, true
  %lnot.ext46 = zext i1 %lnot45 to i32
  %conv47 = sext i32 %lnot.ext46 to i64
  %expval48 = call i64 @llvm.expect.i64(i64 %conv47, i64 0)
  %tobool49 = icmp ne i64 %expval48, 0
  br i1 %tobool49, label %if.then50, label %sw.bb56

if.then50:                                        ; preds = %do.body40
  %13 = call i32 (i8*, ...) @printk(i8* null)
  br label %sw.bb56

sw.bb56:                                          ; preds = %if.then50, %do.body40, %LeafBlock
  call void @xs_close(%struct.rpc_xprt* %1)
  br label %cleanup

cleanup:                                          ; preds = %sw.bb56, %sw.bb, %if.then35
  %retval.0 = phi i32 [ 0, %if.then35 ], [ -107, %sw.bb56 ], [ %call39, %sw.bb ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @xs_local_print_stats(%struct.rpc_xprt* %xprt, %struct.seq_file* %seq) #0 {
entry:
  %call = call i32 @xprt_connected.142(%struct.rpc_xprt* %xprt)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %last_used = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 27
  %1 = load i64, i64* %last_used, align 8, !tbaa !270
  %sub = sub i64 %0, %1
  %div = sdiv i64 %sub, 250
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %idle_time.0 = phi i64 [ %div, %if.then ], [ 0, %entry ]
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %bind_count = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat, i32 0, i32 0
  %2 = load i64, i64* %bind_count, align 8, !tbaa !378
  %stat1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %connect_count = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat1, i32 0, i32 1
  %3 = load i64, i64* %connect_count, align 8, !tbaa !315
  %stat2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %connect_time = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat2, i32 0, i32 3
  %4 = load i64, i64* %connect_time, align 8, !tbaa !316
  %stat3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %sends = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat3, i32 0, i32 4
  %5 = load i64, i64* %sends, align 8, !tbaa !320
  %stat4 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %recvs = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat4, i32 0, i32 5
  %6 = load i64, i64* %recvs, align 8, !tbaa !289
  %stat5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %bad_xids = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat5, i32 0, i32 6
  %7 = load i64, i64* %bad_xids, align 8, !tbaa !299
  %stat6 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %req_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat6, i32 0, i32 8
  %8 = load i64, i64* %req_u, align 8, !tbaa !321
  %stat7 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %bklog_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat7, i32 0, i32 9
  %9 = load i64, i64* %bklog_u, align 8, !tbaa !323
  %stat8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %max_slots = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat8, i32 0, i32 7
  %10 = load i64, i64* %max_slots, align 8, !tbaa !319
  %stat9 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %sending_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat9, i32 0, i32 10
  %11 = load i64, i64* %sending_u, align 8, !tbaa !325
  %stat10 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %pending_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat10, i32 0, i32 11
  %12 = load i64, i64* %pending_u, align 8, !tbaa !327
  %call11 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.23.239, i32 0, i32 0), i64 %2, i64 %3, i64 %4, i64 %idle_time.0, i64 %5, i64 %6, i64 %7, i64 %8, i64 %9, i64 %10, i64 %11, i64 %12)
  ret void
}

declare i64 @msleep_interruptible(i32) #4

declare i32 @proc_dointvec_minmax(%struct.ctl_table*, i32, i8*, i64*, i64*) #4

declare i32 @proc_dointvec_jiffies(%struct.ctl_table*, i32, i8*, i64*, i64*) #4

; Function Attrs: nounwind uwtable
define void @cleanup_socket_xprt() #0 {
entry:
  %0 = load %struct.ctl_table_header*, %struct.ctl_table_header** @sunrpc_table_header, align 8, !tbaa !28
  %tobool = icmp ne %struct.ctl_table_header* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.ctl_table_header*, %struct.ctl_table_header** @sunrpc_table_header, align 8, !tbaa !28
  call void @unregister_sysctl_table(%struct.ctl_table_header* %1)
  store %struct.ctl_table_header* null, %struct.ctl_table_header** @sunrpc_table_header, align 8, !tbaa !28
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call = call i32 @xprt_unregister_transport(%struct.xprt_class* @xs_local_transport)
  %call1 = call i32 @xprt_unregister_transport(%struct.xprt_class* @xs_udp_transport)
  %call2 = call i32 @xprt_unregister_transport(%struct.xprt_class* @xs_tcp_transport)
  %call3 = call i32 @xprt_unregister_transport(%struct.xprt_class* @xs_bc_tcp_transport)
  ret void
}

declare void @unregister_sysctl_table(%struct.ctl_table_header*) #4

; Function Attrs: nounwind uwtable
define void @rpc_put_task_async(%struct.rpc_task* %task) #0 {
entry:
  %tk_workqueue = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 11
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** %tk_workqueue, align 8, !tbaa !473
  call void @rpc_do_put_task(%struct.rpc_task* %task, %struct.workqueue_struct* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_do_put_task(%struct.rpc_task* %task, %struct.workqueue_struct* %q) #0 {
entry:
  %tk_count = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 0
  %call = call i32 @atomic_dec_and_test.257(%struct.atomic_t* %tk_count)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @rpc_release_resources_task(%struct.rpc_task* %task)
  call void @rpc_final_put_task(%struct.rpc_task* %task, %struct.workqueue_struct* %q)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_dec_and_test.257(%struct.atomic_t* %v) #2 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0; sete $1", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32* %counter) #7, !srcloc !474
  %0 = load i8, i8* %c, align 1, !tbaa !166
  %conv = zext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define internal void @rpc_release_resources_task(%struct.rpc_task* %task) #0 {
entry:
  call void @xprt_release(%struct.rpc_task* %task)
  %tk_msg = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_cred = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg, i32 0, i32 3
  %0 = load %struct.rpc_cred*, %struct.rpc_cred** %rpc_cred, align 8, !tbaa !47
  %tobool = icmp ne %struct.rpc_cred* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %tk_msg1 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_cred2 = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg1, i32 0, i32 3
  %1 = load %struct.rpc_cred*, %struct.rpc_cred** %rpc_cred2, align 8, !tbaa !47
  call void @put_rpccred(%struct.rpc_cred* %1)
  %tk_msg3 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_cred4 = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg3, i32 0, i32 3
  store %struct.rpc_cred* null, %struct.rpc_cred** %rpc_cred4, align 8, !tbaa !47
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @rpc_task_release_client(%struct.rpc_task* %task)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_final_put_task(%struct.rpc_task* %task, %struct.workqueue_struct* %q) #0 {
entry:
  %.compoundliteral = alloca %struct.pgprot, align 8
  %cmp = icmp ne %struct.workqueue_struct* %q, null
  br i1 %cmp, label %do.body1, label %if.else

do.body1:                                         ; preds = %entry
  %u = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_work = bitcast %union.anon.69* %u to %struct.work_struct*
  call void @__init_work(%struct.work_struct* %tk_work, i32 0)
  %u2 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_work3 = bitcast %union.anon.69* %u2 to %struct.work_struct*
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %tk_work3, i32 0, i32 0
  %counter = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !339
  %0 = bitcast %struct.pgprot* %data to i8*
  %1 = bitcast %struct.pgprot* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 8, i32 8, i1 false), !tbaa.struct !340
  %u4 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_work5 = bitcast %union.anon.69* %u4 to %struct.work_struct*
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %tk_work5, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.53.258, i32 0, i32 0), %struct.lock_class_key* @rpc_final_put_task.__key, i32 0)
  %u6 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_work7 = bitcast %union.anon.69* %u6 to %struct.work_struct*
  %entry8 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %tk_work7, i32 0, i32 1
  call void @INIT_LIST_HEAD.259(%struct.list_head* %entry8)
  %u10 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_work11 = bitcast %union.anon.69* %u10 to %struct.work_struct*
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %tk_work11, i32 0, i32 2
  store void (%struct.work_struct*)* @rpc_async_release, void (%struct.work_struct*)** %func, align 8, !tbaa !166
  %u14 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_work15 = bitcast %union.anon.69* %u14 to %struct.work_struct*
  call void @queue_work.260(%struct.workqueue_struct* %q, %struct.work_struct* %tk_work15)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @rpc_free_task(%struct.rpc_task* %task)
  br label %if.end

if.end:                                           ; preds = %if.else, %do.body1
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.259(%struct.list_head* %list) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !163
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_async_release(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -136
  %1 = bitcast i8* %add.ptr to %struct.rpc_task*
  call void @rpc_free_task(%struct.rpc_task* %1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_work.260(%struct.workqueue_struct* %wq, %struct.work_struct* %work) #2 {
entry:
  %call = call zeroext i1 @queue_work_on(i32 4096, %struct.workqueue_struct* %wq, %struct.work_struct* %work)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_free_task(%struct.rpc_task* %task) #0 {
entry:
  %tk_flags1 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %0 = load i16, i16* %tk_flags1, align 8, !tbaa !27
  %tk_ops = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 7
  %1 = load %struct.rpc_call_ops*, %struct.rpc_call_ops** %tk_ops, align 8, !tbaa !180
  %tk_calldata = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 8
  %2 = load i8*, i8** %tk_calldata, align 8, !tbaa !334
  call void @rpc_release_calldata(%struct.rpc_call_ops* %1, i8* %2)
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %do.body, label %if.end9

do.body:                                          ; preds = %entry
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and2 = and i32 %3, 64
  %tobool3 = icmp ne i32 %and2, 0
  %lnot = xor i1 %tobool3, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv5, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then7, label %do.end

if.then7:                                         ; preds = %do.body
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then7, %do.body
  %5 = bitcast %struct.rpc_task* %task to i8*
  %6 = load %struct.mempool_s*, %struct.mempool_s** @rpc_task_mempool, align 8, !tbaa !28
  call void @mempool_free(i8* %5, %struct.mempool_s* %6)
  br label %if.end9

if.end9:                                          ; preds = %do.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_release_calldata(%struct.rpc_call_ops* %ops, i8* %calldata) #0 {
entry:
  %rpc_release = getelementptr inbounds %struct.rpc_call_ops, %struct.rpc_call_ops* %ops, i32 0, i32 3
  %0 = load void (i8*)*, void (i8*)** %rpc_release, align 8, !tbaa !475
  %cmp = icmp ne void (i8*)* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %rpc_release1 = getelementptr inbounds %struct.rpc_call_ops, %struct.rpc_call_ops* %ops, i32 0, i32 3
  %1 = load void (i8*)*, void (i8*)** %rpc_release1, align 8, !tbaa !475
  call void %1(i8* %calldata)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @mempool_free(i8*, %struct.mempool_s*) #4

; Function Attrs: nounwind uwtable
define void @rpc_put_task(%struct.rpc_task* %task) #0 {
entry:
  call void @rpc_do_put_task(%struct.rpc_task* %task, %struct.workqueue_struct* null)
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_free(i8* %buffer) #0 {
entry:
  %tobool = icmp ne i8* %buffer, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %0 = bitcast i8* %buffer to [0 x i8]*
  %1 = bitcast [0 x i8]* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -8
  %2 = bitcast i8* %add.ptr to %struct.rpc_buffer*
  %len = getelementptr inbounds %struct.rpc_buffer, %struct.rpc_buffer* %2, i32 0, i32 0
  %3 = load i64, i64* %len, align 8, !tbaa !88
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %4, 64
  %tobool1 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.end

if.then4:                                         ; preds = %if.end
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then4, %if.end
  %cmp = icmp ule i64 %3, 2048
  %6 = bitcast %struct.rpc_buffer* %2 to i8*
  br i1 %cmp, label %if.then7, label %if.else

if.then7:                                         ; preds = %do.end
  %7 = load %struct.mempool_s*, %struct.mempool_s** @rpc_buffer_mempool, align 8, !tbaa !28
  call void @mempool_free(i8* %6, %struct.mempool_s* %7)
  br label %cleanup.cont

if.else:                                          ; preds = %do.end
  call void @kfree(i8* %6)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.else, %if.then7, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @rpc_malloc(%struct.rpc_task* %task, i64 %size) #0 {
entry:
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %0 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 2
  %tobool = icmp ne i32 %and, 0
  %or = or i32 0, 8192
  %or. = select i1 %tobool, i32 %or, i32 0
  %add = add i64 %size, 8
  %cmp = icmp ule i64 %add, 2048
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %entry
  %1 = load %struct.mempool_s*, %struct.mempool_s** @rpc_buffer_mempool, align 8, !tbaa !28
  %call = call i8* @mempool_alloc(%struct.mempool_s* %1, i32 %or.)
  br label %if.end4

if.else:                                          ; preds = %entry
  %call.i = call i8* @__kmalloc(i64 %add, i32 %or.) #7
  br label %if.end4

if.end4:                                          ; preds = %if.else, %if.then2
  %call3.sink = phi i8* [ %call.i, %if.else ], [ %call, %if.then2 ]
  %2 = bitcast i8* %call3.sink to %struct.rpc_buffer*
  %tobool5 = icmp ne %struct.rpc_buffer* %2, null
  br i1 %tobool5, label %if.end7, label %cleanup

if.end7:                                          ; preds = %if.end4
  %len = getelementptr inbounds %struct.rpc_buffer, %struct.rpc_buffer* %2, i32 0, i32 0
  store i64 %add, i64* %len, align 8, !tbaa !88
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and8 = and i32 %3, 64
  %tobool9 = icmp ne i32 %and8, 0
  %lnot = xor i1 %tobool9, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv11 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.then13, label %do.end

if.then13:                                        ; preds = %if.end7
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then13, %if.end7
  %data = getelementptr inbounds %struct.rpc_buffer, %struct.rpc_buffer* %2, i32 0, i32 1
  %5 = bitcast [0 x i8]* %data to i8*
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.end4
  %retval.0 = phi i8* [ %5, %do.end ], [ null, %if.end4 ]
  ret i8* %retval.0
}

declare i8* @mempool_alloc(%struct.mempool_s*, i32) #4

; Function Attrs: nounwind uwtable
define void @rpc_exit(%struct.rpc_task* %task, i32 %status) #0 {
entry:
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 %status, i32* %tk_status, align 4, !tbaa !59
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @rpc_exit_task, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %0 = load volatile i64, i64* %tk_runstate, align 8, !tbaa !88
  %and.i = and i64 2, %0
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %tk_waitqueue = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 12
  %1 = load %struct.rpc_wait_queue*, %struct.rpc_wait_queue** %tk_waitqueue, align 8, !tbaa !222
  call void @rpc_wake_up_queued_task(%struct.rpc_wait_queue* %1, %struct.rpc_task* %task)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_exit_task(%struct.rpc_task* %task) #0 {
entry:
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* null, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  %tk_ops = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 7
  %0 = load %struct.rpc_call_ops*, %struct.rpc_call_ops** %tk_ops, align 8, !tbaa !180
  %rpc_call_done = getelementptr inbounds %struct.rpc_call_ops, %struct.rpc_call_ops* %0, i32 0, i32 1
  %1 = load void (%struct.rpc_task*, i8*)*, void (%struct.rpc_task*, i8*)** %rpc_call_done, align 8, !tbaa !476
  %cmp = icmp ne void (%struct.rpc_task*, i8*)* %1, null
  br i1 %cmp, label %if.then, label %if.end23

if.then:                                          ; preds = %entry
  %tk_ops1 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 7
  %2 = load %struct.rpc_call_ops*, %struct.rpc_call_ops** %tk_ops1, align 8, !tbaa !180
  %rpc_call_done2 = getelementptr inbounds %struct.rpc_call_ops, %struct.rpc_call_ops* %2, i32 0, i32 1
  %3 = load void (%struct.rpc_task*, i8*)*, void (%struct.rpc_task*, i8*)** %rpc_call_done2, align 8, !tbaa !476
  %tk_calldata = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 8
  %4 = load i8*, i8** %tk_calldata, align 8, !tbaa !334
  call void %3(%struct.rpc_task* %task, i8* %4)
  %tk_action3 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  %5 = load void (%struct.rpc_task*)*, void (%struct.rpc_task*)** %tk_action3, align 8, !tbaa !20
  %cmp4 = icmp ne void (%struct.rpc_task*)* %5, null
  br i1 %cmp4, label %if.then5, label %if.end23

if.then5:                                         ; preds = %if.then
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %6 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv = zext i16 %6 to i32
  %and = and i32 %conv, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %tobool7 = icmp ne i32 %lnot.ext, 0
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  %conv12 = sext i32 %lnot.ext11 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv12, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  br i1 %tobool13, label %if.then14, label %if.end

if.then14:                                        ; preds = %if.then5
  call void @warn_slowpath_null(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.9.289, i32 0, i32 0), i32 705)
  br label %if.end

if.end:                                           ; preds = %if.then14, %if.then5
  call void @xprt_release(%struct.rpc_task* %task)
  call void @rpc_reset_task_statistics(%struct.rpc_task* %task)
  br label %if.end23

if.end23:                                         ; preds = %if.end, %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_wake_up_queued_task(%struct.rpc_wait_queue* %queue, %struct.rpc_task* %task) #0 {
entry:
  %lock = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 0
  call void @spin_lock_bh.280(%struct.spinlock* %lock)
  call void @rpc_wake_up_task_queue_locked(%struct.rpc_wait_queue* %queue, %struct.rpc_task* %task)
  %lock1 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 0
  call void @spin_unlock_bh.281(%struct.spinlock* %lock1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_bh.280(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_wake_up_task_queue_locked(%struct.rpc_wait_queue* %queue, %struct.rpc_task* %task) #0 {
entry:
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %0 = load volatile i64, i64* %tk_runstate, align 8, !tbaa !88
  %and.i = and i64 2, %0
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !477
  %tk_waitqueue = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 12
  %1 = load %struct.rpc_wait_queue*, %struct.rpc_wait_queue** %tk_waitqueue, align 8, !tbaa !222
  %cmp = icmp eq %struct.rpc_wait_queue* %1, %queue
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.then
  call void @__rpc_do_wake_up_task(%struct.rpc_wait_queue* %queue, %struct.rpc_task* %task)
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_bh.281(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__rpc_do_wake_up_task(%struct.rpc_wait_queue* %queue, %struct.rpc_task* %task) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 64
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %cond.true

if.then:                                          ; preds = %entry
  %1 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %cond.true

cond.true:                                        ; preds = %if.then, %entry
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %3 = load volatile i64, i64* %tk_runstate, align 8, !tbaa !88
  %and.i = and i64 4, %3
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool5 = icmp ne i32 %conv.i, 0
  br i1 %tobool5, label %if.end11, label %if.then9

if.then9:                                         ; preds = %cond.true
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end25

if.end11:                                         ; preds = %cond.true
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %5 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  call void @trace_rpc_task_wakeup(%struct.rpc_clnt* %5, %struct.rpc_task* %task, %struct.rpc_wait_queue* %queue)
  call void @__rpc_remove_wait_queue(%struct.rpc_wait_queue* %queue, %struct.rpc_task* %task)
  call void @rpc_make_runnable(%struct.rpc_task* %task)
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and13 = and i32 %6, 64
  %tobool14 = icmp ne i32 %and13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %do.end25

if.then22:                                        ; preds = %if.end11
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end25

do.end25:                                         ; preds = %if.then22, %if.end11, %if.then9
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @trace_rpc_task_wakeup(%struct.rpc_clnt* %clnt, %struct.rpc_task* %task, %struct.rpc_wait_queue* %q) #2 {
entry:
  %call.i = call i32 @atomic_read.296(%struct.atomic_t* getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_task_wakeup, i64 0, i32 1, i32 0)) #7
  %tobool.i = icmp ne i32 %call.i, 0
  %lnot.ext.i = zext i1 %tobool.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv.i, i64 0) #7
  %cmp.i = icmp sgt i64 %expval.i, 0
  %..i = select i1 %cmp.i, i1 true, i1 false
  br i1 %..i, label %do.body, label %if.end21

do.body:                                          ; preds = %entry
  call void @rcu_read_lock_sched_notrace.300()
  %0 = load volatile %struct.tracepoint_func*, %struct.tracepoint_func** getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_task_wakeup, i32 0, i32 4), align 8, !tbaa !28
  %call2 = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %land.lhs.true, label %do.end10

land.lhs.true:                                    ; preds = %do.body
  %1 = load i8, i8* @trace_rpc_task_wakeup.__warned, align 1, !tbaa !29, !range !31
  %tobool3 = trunc i8 %1 to i1
  br i1 %tobool3, label %do.end10, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %land.lhs.true
  %call5 = call i32 @rcu_read_lock_sched_held.301()
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %do.end10, label %if.then7

if.then7:                                         ; preds = %land.lhs.true4
  store i8 1, i8* @trace_rpc_task_wakeup.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.36.302, i32 0, i32 0), i32 173, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end10

do.end10:                                         ; preds = %if.then7, %land.lhs.true4, %land.lhs.true, %do.body
  %tobool11 = icmp ne %struct.tracepoint_func* %0, null
  br i1 %tobool11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %do.end10
  br label %do.body13

do.body13:                                        ; preds = %do.body13, %if.then12
  %it_func_ptr.0 = phi %struct.tracepoint_func* [ %0, %if.then12 ], [ %incdec.ptr, %do.body13 ]
  %func = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 0
  %2 = load i8*, i8** %func, align 8, !tbaa !120
  %data = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 1
  %3 = load i8*, i8** %data, align 8, !tbaa !122
  %4 = bitcast i8* %2 to void (i8*, %struct.rpc_clnt*, %struct.rpc_task*, %struct.rpc_wait_queue*)*
  call void %4(i8* %3, %struct.rpc_clnt* %clnt, %struct.rpc_task* %task, %struct.rpc_wait_queue* %q)
  %incdec.ptr = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 1
  %func15 = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %incdec.ptr, i32 0, i32 0
  %5 = load i8*, i8** %func15, align 8, !tbaa !120
  %tobool16 = icmp ne i8* %5, null
  br i1 %tobool16, label %do.body13, label %if.end18

if.end18:                                         ; preds = %do.body13, %do.end10
  call void @rcu_read_unlock_sched_notrace.304()
  br label %if.end21

if.end21:                                         ; preds = %if.end18, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__rpc_remove_wait_queue(%struct.rpc_wait_queue* %queue, %struct.rpc_task* %task) #0 {
entry:
  call void @__rpc_disable_timer(%struct.rpc_wait_queue* %queue, %struct.rpc_task* %task)
  %maxpriority = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 3
  %0 = load i8, i8* %maxpriority, align 4, !tbaa !478
  %conv = zext i8 %0 to i32
  %cmp = icmp sgt i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__rpc_remove_wait_queue_priority(%struct.rpc_task* %task)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %u = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_wait = bitcast %union.anon.69* %u to %struct.rpc_wait*
  %list = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait, i32 0, i32 0
  call void @list_del(%struct.list_head* %list)
  %qlen = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 6
  %1 = load i16, i16* %qlen, align 8, !tbaa !479
  %dec = add i16 %1, -1
  store i16 %dec, i16* %qlen, align 8, !tbaa !479
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 64
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv3 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then5, label %do.end

if.then5:                                         ; preds = %if.end
  %call = call i8* @rpc_qname.317(%struct.rpc_wait_queue* %queue)
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then5, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_make_runnable(%struct.rpc_task* %task) #0 {
entry:
  %.compoundliteral = alloca %struct.pgprot, align 8
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %call = call i32 @test_and_set_bit.285(i32 0, i64* %tk_runstate)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %frombool = zext i1 %lnot to i8
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !480
  %tk_runstate1 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %tk_runstate1, i32 1, i64* %tk_runstate1) #7, !srcloc !481
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !482
  %tobool2 = trunc i8 %frombool to i1
  br i1 %tobool2, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %0 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 1
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %do.body6, label %if.else

do.body6:                                         ; preds = %if.end
  %u = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_work = bitcast %union.anon.69* %u to %struct.work_struct*
  call void @__init_work(%struct.work_struct* %tk_work, i32 0)
  %u7 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_work8 = bitcast %union.anon.69* %u7 to %struct.work_struct*
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %tk_work8, i32 0, i32 0
  %counter = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !339
  %1 = bitcast %struct.pgprot* %data to i8*
  %2 = bitcast %struct.pgprot* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 8, i32 8, i1 false), !tbaa.struct !340
  %u9 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_work10 = bitcast %union.anon.69* %u9 to %struct.work_struct*
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %tk_work10, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.53.258, i32 0, i32 0), %struct.lock_class_key* @rpc_make_runnable.__key, i32 0)
  %u11 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_work12 = bitcast %union.anon.69* %u11 to %struct.work_struct*
  %entry13 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %tk_work12, i32 0, i32 1
  call void @INIT_LIST_HEAD.259(%struct.list_head* %entry13)
  %u15 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_work16 = bitcast %union.anon.69* %u15 to %struct.work_struct*
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %tk_work16, i32 0, i32 2
  store void (%struct.work_struct*)* @rpc_async_schedule, void (%struct.work_struct*)** %func, align 8, !tbaa !166
  %3 = load %struct.workqueue_struct*, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !28
  %u23 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_work24 = bitcast %union.anon.69* %u23 to %struct.work_struct*
  call void @queue_work.260(%struct.workqueue_struct* %3, %struct.work_struct* %tk_work24)
  br label %cleanup.cont

if.else:                                          ; preds = %if.end
  %tk_runstate26 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %4 = bitcast i64* %tk_runstate26 to i8*
  call void @wake_up_bit(i8* %4, i32 1)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.else, %do.body6, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_and_set_bit.285(i32 %nr, i64* %addr) #2 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !483
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal void @rpc_async_schedule(%struct.work_struct* %work) #0 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !484
  %flags = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 3
  %1 = load i32, i32* %flags, align 4, !tbaa !385
  %or = or i32 %1, 131072
  store i32 %or, i32* %flags, align 4, !tbaa !385
  %2 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -136
  %3 = bitcast i8* %add.ptr to %struct.rpc_task*
  call void @__rpc_execute(%struct.rpc_task* %3)
  %4 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !484
  %flags2 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %4, i32 0, i32 3
  %5 = load i32, i32* %flags2, align 4, !tbaa !385
  %and = and i32 %5, -131073
  store i32 %and, i32* %flags2, align 4, !tbaa !385
  ret void
}

declare void @wake_up_bit(i8*, i32) #4

; Function Attrs: nounwind uwtable
define internal void @__rpc_execute(%struct.rpc_task* %task) #0 {
entry:
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %0 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 1
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and1 = and i32 %1, 64
  %tobool = icmp ne i32 %and1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv3 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %3 = load volatile i64, i64* %tk_runstate, align 8, !tbaa !88
  %and.i7 = and i64 2, %3
  %cmp.i8 = icmp ne i64 %and.i7, 0
  %conv.i9 = zext i1 %cmp.i8 to i32
  %tobool9 = icmp ne i32 %conv.i9, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %tobool14 = icmp ne i32 %lnot.ext13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %if.end50

if.then22:                                        ; preds = %do.end
  %4 = load i8, i8* @__rpc_execute.__warned, align 1, !tbaa !29, !range !31
  %tobool23 = trunc i8 %4 to i1
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot28 = xor i1 %lnot26, true
  %lnot.ext29 = zext i1 %lnot28 to i32
  %tobool30 = icmp ne i32 %lnot.ext29, 0
  %lnot31 = xor i1 %tobool30, true
  %lnot33 = xor i1 %lnot31, true
  %lnot.ext34 = zext i1 %lnot33 to i32
  %conv35 = sext i32 %lnot.ext34 to i64
  %expval36 = call i64 @llvm.expect.i64(i64 %conv35, i64 0)
  %tobool37 = icmp ne i64 %expval36, 0
  br i1 %tobool37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.then22
  call void @warn_slowpath_null(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.9.289, i32 0, i32 0), i32 740)
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %if.then22
  %tobool40 = icmp ne i32 %lnot.ext29, 0
  %lnot41 = xor i1 %tobool40, true
  %lnot43 = xor i1 %lnot41, true
  %lnot.ext44 = zext i1 %lnot43 to i32
  %conv45 = sext i32 %lnot.ext44 to i64
  %expval46 = call i64 @llvm.expect.i64(i64 %conv45, i64 0)
  %tobool47 = icmp ne i64 %expval46, 0
  br i1 %tobool47, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.end39
  store i8 1, i8* @__rpc_execute.__warned, align 1, !tbaa !29
  br label %if.end50

if.end50:                                         ; preds = %if.then48, %if.end39, %do.end
  %tk_runstate59 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %5 = load volatile i64, i64* %tk_runstate59, align 8, !tbaa !88
  %and.i4 = and i64 2, %5
  %cmp.i5 = icmp ne i64 %and.i4, 0
  %conv.i6 = zext i1 %cmp.i5 to i32
  %tobool61 = icmp ne i32 %conv.i6, 0
  br i1 %tobool61, label %cleanup.cont187, label %if.end66

if.end66:                                         ; preds = %if.end50
  br label %for.cond

for.cond:                                         ; preds = %for.cond.backedge, %if.end66
  %status.0 = phi i32 [ 0, %if.end66 ], [ %status.1, %for.cond.backedge ]
  %tk_callback = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 5
  %6 = load void (%struct.rpc_task*)*, void (%struct.rpc_task*)** %tk_callback, align 8, !tbaa !485
  %tk_callback67 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 5
  store void (%struct.rpc_task*)* null, void (%struct.rpc_task*)** %tk_callback67, align 8, !tbaa !485
  %cmp = icmp eq void (%struct.rpc_task*)* %6, null
  br i1 %cmp, label %if.then69, label %if.end74

if.then69:                                        ; preds = %for.cond
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  %7 = load void (%struct.rpc_task*)*, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  %cmp70 = icmp eq void (%struct.rpc_task*)* %7, null
  br i1 %cmp70, label %NodeBlock3, label %if.end74

if.end74:                                         ; preds = %if.then69, %for.cond
  %do_action.0 = phi void (%struct.rpc_task*)* [ %6, %for.cond ], [ %7, %if.then69 ]
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %8 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %tk_action75 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  %9 = load void (%struct.rpc_task*)*, void (%struct.rpc_task*)** %tk_action75, align 8, !tbaa !20
  %10 = bitcast void (%struct.rpc_task*)* %9 to i8*
  call void @trace_rpc_task_run_action(%struct.rpc_clnt* %8, %struct.rpc_task* %task, i8* %10)
  call void %do_action.0(%struct.rpc_task* %task)
  %tk_runstate77 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %11 = load volatile i64, i64* %tk_runstate77, align 8, !tbaa !88
  %and.i1 = and i64 2, %11
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool79 = icmp ne i32 %conv.i3, 0
  br i1 %tobool79, label %if.end85, label %NodeBlock3

if.end85:                                         ; preds = %if.end74
  %tk_waitqueue = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 12
  %12 = load %struct.rpc_wait_queue*, %struct.rpc_wait_queue** %tk_waitqueue, align 8, !tbaa !222
  %lock = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %12, i32 0, i32 0
  call void @spin_lock_bh.280(%struct.spinlock* %lock)
  %tk_runstate87 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %13 = load volatile i64, i64* %tk_runstate87, align 8, !tbaa !88
  %and.i = and i64 2, %13
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool89 = icmp ne i32 %conv.i, 0
  br i1 %tobool89, label %do.body97, label %if.then94

if.then94:                                        ; preds = %if.end85
  %lock95 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %12, i32 0, i32 0
  call void @spin_unlock_bh.281(%struct.spinlock* %lock95)
  br label %NodeBlock3

do.body97:                                        ; preds = %if.end85
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !486
  %tk_runstate98 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %tk_runstate98, i32 0, i64* %tk_runstate98) #7, !srcloc !481
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !487
  %lock101 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %12, i32 0, i32 0
  call void @spin_unlock_bh.281(%struct.spinlock* %lock101)
  %tobool102 = icmp ne i32 %and, 0
  br i1 %tobool102, label %NodeBlock3, label %do.body105

do.body105:                                       ; preds = %do.body97
  %14 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and106 = and i32 %14, 64
  %tobool107 = icmp ne i32 %and106, 0
  %lnot108 = xor i1 %tobool107, true
  %lnot110 = xor i1 %lnot108, true
  %lnot.ext111 = zext i1 %lnot110 to i32
  %conv112 = sext i32 %lnot.ext111 to i64
  %expval113 = call i64 @llvm.expect.i64(i64 %conv112, i64 0)
  %tobool114 = icmp ne i64 %expval113, 0
  br i1 %tobool114, label %if.then115, label %do.end121

if.then115:                                       ; preds = %do.body105
  %15 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end121

do.end121:                                        ; preds = %if.then115, %do.body105
  %tk_runstate122 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %16 = bitcast i64* %tk_runstate122 to i8*
  %call123 = call i32 @out_of_line_wait_on_bit(i8* %16, i32 1, i32 (i8*)* @rpc_wait_bit_killable, i32 130)
  %cmp124 = icmp eq i32 %call123, -512
  br i1 %cmp124, label %do.body127, label %if.end147

do.body127:                                       ; preds = %do.end121
  %17 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and128 = and i32 %17, 64
  %tobool129 = icmp ne i32 %and128, 0
  %lnot130 = xor i1 %tobool129, true
  %lnot132 = xor i1 %lnot130, true
  %lnot.ext133 = zext i1 %lnot132 to i32
  %conv134 = sext i32 %lnot.ext133 to i64
  %expval135 = call i64 @llvm.expect.i64(i64 %conv134, i64 0)
  %tobool136 = icmp ne i64 %expval135, 0
  br i1 %tobool136, label %if.then137, label %do.end143

if.then137:                                       ; preds = %do.body127
  %18 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end143

do.end143:                                        ; preds = %if.then137, %do.body127
  %tk_flags144 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %19 = load i16, i16* %tk_flags144, align 8, !tbaa !27
  %conv145 = zext i16 %19 to i32
  %or = or i32 %conv145, 256
  %conv146 = trunc i32 %or to i16
  store i16 %conv146, i16* %tk_flags144, align 8, !tbaa !27
  call void @rpc_exit(%struct.rpc_task* %task, i32 -512)
  br label %if.end147

if.end147:                                        ; preds = %do.end143, %do.end121
  %tk_runstate148 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %tk_runstate148, i32 0, i64* %tk_runstate148) #7, !srcloc !488
  %20 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and150 = and i32 %20, 64
  %tobool151 = icmp ne i32 %and150, 0
  %lnot152 = xor i1 %tobool151, true
  %lnot154 = xor i1 %lnot152, true
  %lnot.ext155 = zext i1 %lnot154 to i32
  %conv156 = sext i32 %lnot.ext155 to i64
  %expval157 = call i64 @llvm.expect.i64(i64 %conv156, i64 0)
  %tobool158 = icmp ne i64 %expval157, 0
  br i1 %tobool158, label %if.then159, label %NodeBlock3

if.then159:                                       ; preds = %if.end147
  %21 = call i32 (i8*, ...) @printk(i8* null)
  br label %NodeBlock3

NodeBlock3:                                       ; preds = %if.then159, %if.end147, %do.body97, %if.then94, %if.end74, %if.then69
  %status.1 = phi i32 [ %status.0, %if.then94 ], [ %status.0, %if.then69 ], [ %status.0, %if.end74 ], [ %status.0, %do.body97 ], [ %call123, %if.then159 ], [ %call123, %if.end147 ]
  %cleanup.dest.slot.0 = phi i32 [ 5, %if.then94 ], [ 4, %if.then69 ], [ 5, %if.end74 ], [ 1, %do.body97 ], [ 0, %if.then159 ], [ 0, %if.end147 ]
  %Pivot4 = icmp slt i32 %cleanup.dest.slot.0, 4
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 5
  br i1 %Pivot, label %do.body166, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 5
  br i1 %SwitchLeaf2, label %for.cond.backedge, label %cleanup.cont187

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.cond.backedge, label %cleanup.cont187

for.cond.backedge:                                ; preds = %LeafBlock, %LeafBlock1
  br label %for.cond

do.body166:                                       ; preds = %NodeBlock
  %22 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and167 = and i32 %22, 64
  %tobool168 = icmp ne i32 %and167, 0
  %lnot169 = xor i1 %tobool168, true
  %lnot171 = xor i1 %lnot169, true
  %lnot.ext172 = zext i1 %lnot171 to i32
  %conv173 = sext i32 %lnot.ext172 to i64
  %expval174 = call i64 @llvm.expect.i64(i64 %conv173, i64 0)
  %tobool175 = icmp ne i64 %expval174, 0
  br i1 %tobool175, label %if.then176, label %do.end182

if.then176:                                       ; preds = %do.body166
  %23 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end182

do.end182:                                        ; preds = %if.then176, %do.body166
  call void @rpc_release_task(%struct.rpc_task* %task)
  br label %cleanup.cont187

cleanup.cont187:                                  ; preds = %do.end182, %LeafBlock, %LeafBlock1, %if.end50
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @trace_rpc_task_run_action(%struct.rpc_clnt* %clnt, %struct.rpc_task* %task, i8* %action) #2 {
entry:
  %call.i = call i32 @atomic_read.296(%struct.atomic_t* getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_task_run_action, i64 0, i32 1, i32 0)) #7
  %tobool.i = icmp ne i32 %call.i, 0
  %lnot.ext.i = zext i1 %tobool.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv.i, i64 0) #7
  %cmp.i = icmp sgt i64 %expval.i, 0
  %..i = select i1 %cmp.i, i1 true, i1 false
  br i1 %..i, label %do.body, label %if.end21

do.body:                                          ; preds = %entry
  call void @rcu_read_lock_sched_notrace.300()
  %0 = load volatile %struct.tracepoint_func*, %struct.tracepoint_func** getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_task_run_action, i32 0, i32 4), align 8, !tbaa !28
  %call2 = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %land.lhs.true, label %do.end10

land.lhs.true:                                    ; preds = %do.body
  %1 = load i8, i8* @trace_rpc_task_run_action.__warned, align 1, !tbaa !29, !range !31
  %tobool3 = trunc i8 %1 to i1
  br i1 %tobool3, label %do.end10, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %land.lhs.true
  %call5 = call i32 @rcu_read_lock_sched_held.301()
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %do.end10, label %if.then7

if.then7:                                         ; preds = %land.lhs.true4
  store i8 1, i8* @trace_rpc_task_run_action.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.36.302, i32 0, i32 0), i32 112, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end10

do.end10:                                         ; preds = %if.then7, %land.lhs.true4, %land.lhs.true, %do.body
  %tobool11 = icmp ne %struct.tracepoint_func* %0, null
  br i1 %tobool11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %do.end10
  br label %do.body13

do.body13:                                        ; preds = %do.body13, %if.then12
  %it_func_ptr.0 = phi %struct.tracepoint_func* [ %0, %if.then12 ], [ %incdec.ptr, %do.body13 ]
  %func = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 0
  %2 = load i8*, i8** %func, align 8, !tbaa !120
  %data = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 1
  %3 = load i8*, i8** %data, align 8, !tbaa !122
  %4 = bitcast i8* %2 to void (i8*, %struct.rpc_clnt*, %struct.rpc_task*, i8*)*
  call void %4(i8* %3, %struct.rpc_clnt* %clnt, %struct.rpc_task* %task, i8* %action)
  %incdec.ptr = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 1
  %func15 = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %incdec.ptr, i32 0, i32 0
  %5 = load i8*, i8** %func15, align 8, !tbaa !120
  %tobool16 = icmp ne i8* %5, null
  br i1 %tobool16, label %do.body13, label %if.end18

if.end18:                                         ; preds = %do.body13, %do.end10
  call void @rcu_read_unlock_sched_notrace.304()
  br label %if.end21

if.end21:                                         ; preds = %if.end18, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_wait_bit_killable(i8* %word) #0 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !484
  %call1 = call i32 @fatal_signal_pending.309(%struct.task_struct* %0)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @freezer_do_not_count()
  call void @schedule()
  call void @freezer_count()
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -512, %entry ]
  ret i32 %retval.0
}

declare i32 @out_of_line_wait_on_bit(i8*, i32, i32 (i8*)*, i32) #4

; Function Attrs: nounwind uwtable
define internal void @rpc_release_task(%struct.rpc_task* %task) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 64
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %2 = load volatile i64, i64* %tk_runstate, align 8, !tbaa !88
  %and.i = and i64 2, %2
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool5 = icmp ne i32 %conv.i, 0
  %lnot6 = xor i1 %tobool5, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %tobool10 = icmp ne i32 %lnot.ext9, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %if.then18, label %if.end46

if.then18:                                        ; preds = %do.end
  %3 = load i8, i8* @rpc_release_task.__warned, align 1, !tbaa !29, !range !31
  %tobool19 = trunc i8 %3 to i1
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot24 = xor i1 %lnot22, true
  %lnot.ext25 = zext i1 %lnot24 to i32
  %tobool26 = icmp ne i32 %lnot.ext25, 0
  %lnot27 = xor i1 %tobool26, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.then18
  call void @warn_slowpath_null(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.9.289, i32 0, i32 0), i32 1044)
  br label %if.end35

if.end35:                                         ; preds = %if.then34, %if.then18
  %tobool36 = icmp ne i32 %lnot.ext25, 0
  %lnot37 = xor i1 %tobool36, true
  %lnot39 = xor i1 %lnot37, true
  %lnot.ext40 = zext i1 %lnot39 to i32
  %conv41 = sext i32 %lnot.ext40 to i64
  %expval42 = call i64 @llvm.expect.i64(i64 %conv41, i64 0)
  %tobool43 = icmp ne i64 %expval42, 0
  br i1 %tobool43, label %if.then44, label %if.end46

if.then44:                                        ; preds = %if.end35
  store i8 1, i8* @rpc_release_task.__warned, align 1, !tbaa !29
  br label %if.end46

if.end46:                                         ; preds = %if.then44, %if.end35, %do.end
  call void @rpc_release_resources_task(%struct.rpc_task* %task)
  %tk_count = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 0
  %call55 = call i32 @atomic_read.296(%struct.atomic_t* %tk_count)
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %4 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv56 = zext i16 %4 to i32
  %and57 = and i32 %conv56, 1
  %tobool58 = icmp ne i32 %and57, 0
  %lnot59 = xor i1 %tobool58, true
  %lnot.ext60 = zext i1 %lnot59 to i32
  %add = add nsw i32 1, %lnot.ext60
  %cmp = icmp ne i32 %call55, %add
  br i1 %cmp, label %if.then62, label %if.else

if.then62:                                        ; preds = %if.end46
  %call63 = call i32 @rpc_complete_task(%struct.rpc_task* %task)
  %tobool64 = icmp ne i32 %call63, 0
  br i1 %tobool64, label %if.end72, label %return

if.else:                                          ; preds = %if.end46
  %tk_count67 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 0
  %call68 = call i32 @atomic_dec_and_test.257(%struct.atomic_t* %tk_count67)
  %tobool69 = icmp ne i32 %call68, 0
  br i1 %tobool69, label %if.end72, label %return

if.end72:                                         ; preds = %if.else, %if.then62
  %tk_workqueue = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 11
  %5 = load %struct.workqueue_struct*, %struct.workqueue_struct** %tk_workqueue, align 8, !tbaa !473
  call void @rpc_final_put_task(%struct.rpc_task* %task, %struct.workqueue_struct* %5)
  br label %return

return:                                           ; preds = %if.end72, %if.else, %if.then62
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read.296(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !49
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_complete_task(%struct.rpc_task* %task) #0 {
entry:
  %k = alloca %struct.wait_bit_key, align 8
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %0 = bitcast i64* %tk_runstate to i8*
  %call = call %struct.__wait_queue_head* @bit_waitqueue(i8* %0, i32 2)
  %flags = getelementptr inbounds %struct.wait_bit_key, %struct.wait_bit_key* %k, i32 0, i32 0
  store i8* %0, i8** %flags, align 8, !tbaa !489
  %bit_nr = getelementptr inbounds %struct.wait_bit_key, %struct.wait_bit_key* %k, i32 0, i32 1
  store i32 2, i32* %bit_nr, align 8, !tbaa !491
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %1 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  call void @trace_rpc_task_complete(%struct.rpc_clnt* %1, %struct.rpc_task* %task, i8* null)
  %lock = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %call, i32 0, i32 0
  %call3 = call %struct.raw_spinlock* @spinlock_check.297(%struct.spinlock* %lock)
  %call4 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call3)
  %tk_runstate7 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %tk_runstate7, i32 2, i64* %tk_runstate7) #7, !srcloc !481
  %tk_count = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 0
  %call8 = call i32 @atomic_dec_and_test.257(%struct.atomic_t* %tk_count)
  %call9 = call i32 @waitqueue_active(%struct.__wait_queue_head* %call)
  %tobool = icmp ne i32 %call9, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.wait_bit_key* %k to i8*
  call void @__wake_up_locked_key(%struct.__wait_queue_head* %call, i32 3, i8* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %lock10 = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %call, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock10, i64 %call4)
  ret i32 %call8
}

declare %struct.__wait_queue_head* @bit_waitqueue(i8*, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @trace_rpc_task_complete(%struct.rpc_clnt* %clnt, %struct.rpc_task* %task, i8* %action) #2 {
entry:
  %call.i = call i32 @atomic_read.296(%struct.atomic_t* getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_task_complete, i64 0, i32 1, i32 0)) #7
  %tobool.i = icmp ne i32 %call.i, 0
  %lnot.ext.i = zext i1 %tobool.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv.i, i64 0) #7
  %cmp.i = icmp sgt i64 %expval.i, 0
  %..i = select i1 %cmp.i, i1 true, i1 false
  br i1 %..i, label %do.body, label %if.end21

do.body:                                          ; preds = %entry
  call void @rcu_read_lock_sched_notrace.300()
  %0 = load volatile %struct.tracepoint_func*, %struct.tracepoint_func** getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_task_complete, i32 0, i32 4), align 8, !tbaa !28
  %call2 = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %land.lhs.true, label %do.end10

land.lhs.true:                                    ; preds = %do.body
  %1 = load i8, i8* @trace_rpc_task_complete.__warned, align 1, !tbaa !29, !range !31
  %tobool3 = trunc i8 %1 to i1
  br i1 %tobool3, label %do.end10, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %land.lhs.true
  %call5 = call i32 @rcu_read_lock_sched_held.301()
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %do.end10, label %if.then7

if.then7:                                         ; preds = %land.lhs.true4
  store i8 1, i8* @trace_rpc_task_complete.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.36.302, i32 0, i32 0), i32 120, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end10

do.end10:                                         ; preds = %if.then7, %land.lhs.true4, %land.lhs.true, %do.body
  %tobool11 = icmp ne %struct.tracepoint_func* %0, null
  br i1 %tobool11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %do.end10
  br label %do.body13

do.body13:                                        ; preds = %do.body13, %if.then12
  %it_func_ptr.0 = phi %struct.tracepoint_func* [ %0, %if.then12 ], [ %incdec.ptr, %do.body13 ]
  %func = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 0
  %2 = load i8*, i8** %func, align 8, !tbaa !120
  %data = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 1
  %3 = load i8*, i8** %data, align 8, !tbaa !122
  %4 = bitcast i8* %2 to void (i8*, %struct.rpc_clnt*, %struct.rpc_task*, i8*)*
  call void %4(i8* %3, %struct.rpc_clnt* %clnt, %struct.rpc_task* %task, i8* %action)
  %incdec.ptr = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 1
  %func15 = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %incdec.ptr, i32 0, i32 0
  %5 = load i8*, i8** %func15, align 8, !tbaa !120
  %tobool16 = icmp ne i8* %5, null
  br i1 %tobool16, label %do.body13, label %if.end18

if.end18:                                         ; preds = %do.body13, %do.end10
  call void @rcu_read_unlock_sched_notrace.304()
  br label %if.end21

if.end21:                                         ; preds = %if.end18, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check.297(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #4 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @waitqueue_active(%struct.__wait_queue_head* %q) #2 {
entry:
  %task_list = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %q, i32 0, i32 1
  %call = call i32 @list_empty.298(%struct.list_head* %task_list)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

declare void @__wake_up_locked_key(%struct.__wait_queue_head*, i32, i8*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #4 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty.298(%struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock_sched_notrace.300() #2 {
entry:
  %call = call %struct.thread_info* @current_thread_info.305()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !492
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rcu_read_lock_sched_held.301() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @rcu_is_cpu_idle()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call zeroext i1 @rcu_lockdep_current_cpu_online()
  br i1 %call5, label %if.end7, label %cleanup

if.end7:                                          ; preds = %if.end4
  %0 = load i32, i32* @debug_locks, align 4, !tbaa !49
  %tobool8 = icmp ne i32 %0, 0
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end7
  %call10 = call i32 @lock_is_held(%struct.lockdep_map* @rcu_sched_lock_map)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end7
  %lockdep_opinion.0 = phi i32 [ %call10, %if.then9 ], [ 0, %if.end7 ]
  %tobool12 = icmp ne i32 %lockdep_opinion.0, 0
  br i1 %tobool12, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end11
  %call13 = call %struct.thread_info* @current_thread_info.305()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call13, i32 0, i32 5
  %1 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %lor.end, label %do.body

do.body:                                          ; preds = %lor.lhs.false
  %call15 = call i64 @arch_local_save_flags.306()
  %call23 = call i32 @arch_irqs_disabled_flags.307(i64 %call15)
  %tobool24 = icmp ne i32 %call23, 0
  br label %lor.end

lor.end:                                          ; preds = %do.body, %lor.lhs.false, %if.end11
  %2 = phi i1 [ true, %lor.lhs.false ], [ true, %if.end11 ], [ %tobool24, %do.body ]
  %lor.ext = zext i1 %2 to i32
  br label %cleanup

cleanup:                                          ; preds = %lor.end, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %lor.ext, %lor.end ], [ 1, %entry ], [ 0, %if.end ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_unlock_sched_notrace.304() #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !493
  %call = call %struct.thread_info* @current_thread_info.305()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !494
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.305() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !495
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @arch_local_save_flags.306() #2 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), align 8, !tbaa !136
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.52.682, i32 0, i32 0), i32 824, i64 12) #7, !srcloc !496
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call i64 asm sideeffect "771:\0A\09call *${2:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${1:c}\0A  .byte 772b-771b\0A  .short ${3:c}\0A.popsection\0A", "={ax},i,i,i,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 44, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), i32 1) #7, !srcloc !497
  ret i64 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @arch_irqs_disabled_flags.307(i64 %flags) #2 {
entry:
  %and = and i64 %flags, 512
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @fatal_signal_pending.309(%struct.task_struct* %p) #2 {
entry:
  %call = call i32 @signal_pending.311(%struct.task_struct* %p)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %call1 = call i32 @__fatal_signal_pending.312(%struct.task_struct* %p)
  %tobool2 = icmp ne i32 %call1, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %0 = phi i1 [ false, %entry ], [ %tobool2, %land.rhs ]
  %land.ext = zext i1 %0 to i32
  ret i32 %land.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @freezer_do_not_count() #2 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !484
  %flags = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 3
  %1 = load i32, i32* %flags, align 4, !tbaa !385
  %or = or i32 %1, 1073741824
  store i32 %or, i32* %flags, align 4, !tbaa !385
  ret void
}

declare void @schedule() #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @freezer_count() #2 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !484
  %flags = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 3
  %1 = load i32, i32* %flags, align 4, !tbaa !385
  %and = and i32 %1, -1073741825
  store i32 %and, i32* %flags, align 4, !tbaa !385
  call void asm sideeffect "mfence", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !498
  call void @try_to_freeze()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @try_to_freeze() #2 {
entry:
  call void @__might_sleep(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.28.1227, i32 0, i32 0), i32 51, i32 0)
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !484
  %call3 = call zeroext i1 @freezing(%struct.task_struct* %0)
  %lnot = xor i1 %call3, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call6 = call zeroext i1 @__refrigerator(i1 zeroext false)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @freezing(%struct.task_struct* %p) #2 {
entry:
  %call = call i32 @atomic_read.296(%struct.atomic_t* @system_freezing_cnt)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call4 = call zeroext i1 @freezing_slow_path(%struct.task_struct* %p)
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i1 [ %call4, %if.end ], [ false, %entry ]
  ret i1 %retval.0
}

declare zeroext i1 @__refrigerator(i1 zeroext) #4

declare zeroext i1 @freezing_slow_path(%struct.task_struct*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @signal_pending.311(%struct.task_struct* %p) #2 {
entry:
  %call = call i32 @test_tsk_thread_flag.314(%struct.task_struct* %p, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__fatal_signal_pending.312(%struct.task_struct* %p) #2 {
entry:
  %pending = getelementptr inbounds %struct.task_struct, %struct.task_struct* %p, i32 0, i32 80
  %signal = getelementptr inbounds %struct.sigpending, %struct.sigpending* %pending, i32 0, i32 1
  %call = call i32 @sigismember.313(%struct.dma_attrs* %signal, i32 9)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @sigismember.313(%struct.dma_attrs* %set, i32 %_sig) #2 {
entry:
  %sub = sub nsw i32 %_sig, 1
  %conv = sext i32 %sub to i64
  %sig1 = getelementptr inbounds %struct.dma_attrs, %struct.dma_attrs* %set, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x i64], [1 x i64]* %sig1, i64 0, i64 0
  %0 = load i64, i64* %arrayidx, align 8, !tbaa !88
  %shr = lshr i64 %0, %conv
  %and = and i64 1, %shr
  %conv2 = trunc i64 %and to i32
  ret i32 %conv2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_tsk_thread_flag.314(%struct.task_struct* %tsk, i32 %flag) #2 {
entry:
  %stack = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i32 0, i32 1
  %0 = load i8*, i8** %stack, align 8, !tbaa !89
  %1 = bitcast i8* %0 to %struct.thread_info*
  %call = call i32 @test_ti_thread_flag.315(%struct.thread_info* %1, i32 %flag)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_ti_thread_flag.315(%struct.thread_info* %ti, i32 %flag) #2 {
entry:
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i32 0, i32 2
  %0 = bitcast i32* %flags to i64*
  %call = call i32 @variable_test_bit.316(i32 %flag, i64* %0)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @variable_test_bit.316(i32 %nr, i64* %addr) #2 {
entry:
  %0 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr) #7, !srcloc !499
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal void @__rpc_disable_timer(%struct.rpc_wait_queue* %queue, %struct.rpc_task* %task) #0 {
entry:
  %tk_timeout = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  %0 = load i64, i64* %tk_timeout, align 8, !tbaa !86
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.end13, label %do.body

do.body:                                          ; preds = %entry
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 64
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then3, label %do.end

if.then3:                                         ; preds = %do.body
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then3, %do.body
  %tk_timeout6 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  store i64 0, i64* %tk_timeout6, align 8, !tbaa !86
  %u = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_wait = bitcast %union.anon.69* %u to %struct.rpc_wait*
  %timer_list = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait, i32 0, i32 2
  call void @list_del(%struct.list_head* %timer_list)
  %timer_list7 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 7
  %list = getelementptr inbounds %struct.rpc_timer, %struct.rpc_timer* %timer_list7, i32 0, i32 1
  %call8 = call i32 @list_empty.298(%struct.list_head* %list)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %do.end
  %timer_list11 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 7
  %timer = getelementptr inbounds %struct.rpc_timer, %struct.rpc_timer* %timer_list11, i32 0, i32 0
  %call12 = call i32 @del_timer(%struct.timer_list* %timer)
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %do.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__rpc_remove_wait_queue_priority(%struct.rpc_task* %task) #0 {
entry:
  %u = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_wait = bitcast %union.anon.69* %u to %struct.rpc_wait*
  %links = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait, i32 0, i32 1
  %call = call i32 @list_empty.298(%struct.list_head* %links)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %u1 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_wait2 = bitcast %union.anon.69* %u1 to %struct.rpc_wait*
  %links3 = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait2, i32 0, i32 1
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %links3, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !166
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -136
  %2 = bitcast i8* %add.ptr to %struct.rpc_task*
  %u4 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %2, i32 0, i32 13
  %tk_wait5 = bitcast %union.anon.69* %u4 to %struct.rpc_wait*
  %list = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait5, i32 0, i32 0
  %u6 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_wait7 = bitcast %union.anon.69* %u6 to %struct.rpc_wait*
  %list8 = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait7, i32 0, i32 0
  call void @list_move(%struct.list_head* %list, %struct.list_head* %list8)
  %u9 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_wait10 = bitcast %union.anon.69* %u9 to %struct.rpc_wait*
  %links11 = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait10, i32 0, i32 1
  %u12 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %2, i32 0, i32 13
  %tk_wait13 = bitcast %union.anon.69* %u12 to %struct.rpc_wait*
  %links14 = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait13, i32 0, i32 1
  call void @list_splice_init(%struct.list_head* %links11, %struct.list_head* %links14)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @rpc_qname.317(%struct.rpc_wait_queue* %q) #2 {
entry:
  %tobool = icmp ne %struct.rpc_wait_queue* %q, null
  br i1 %tobool, label %land.lhs.true, label %cond.end

land.lhs.true:                                    ; preds = %entry
  %name = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %q, i32 0, i32 8
  %0 = load i8*, i8** %name, align 8, !tbaa !266
  %tobool1 = icmp ne i8* %0, null
  br i1 %tobool1, label %cond.true, label %cond.end

cond.true:                                        ; preds = %land.lhs.true
  %name2 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %q, i32 0, i32 8
  %1 = load i8*, i8** %name2, align 8, !tbaa !266
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %land.lhs.true, %entry
  %cond = phi i8* [ %1, %cond.true ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.52.319, i32 0, i32 0), %land.lhs.true ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.52.319, i32 0, i32 0), %entry ]
  ret i8* %cond
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_move(%struct.list_head* %list, %struct.list_head* %head) #2 {
entry:
  call void @__list_del_entry(%struct.list_head* %list)
  call void @list_add.320(%struct.list_head* %list, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_splice_init(%struct.list_head* %list, %struct.list_head* %head) #2 {
entry:
  %call = call i32 @list_empty.298(%struct.list_head* %list)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  call void @__list_splice(%struct.list_head* %list, %struct.list_head* %head, %struct.list_head* %0)
  call void @INIT_LIST_HEAD.259(%struct.list_head* %list)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_splice(%struct.list_head* %list, %struct.list_head* %prev, %struct.list_head* %next) #2 {
entry:
  %next1 = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next1, align 8, !tbaa !164
  %prev2 = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  %1 = load %struct.list_head*, %struct.list_head** %prev2, align 8, !tbaa !163
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !163
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  store %struct.list_head* %0, %struct.list_head** %next4, align 8, !tbaa !164
  %next5 = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next5, align 8, !tbaa !164
  %prev6 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %1, %struct.list_head** %prev6, align 8, !tbaa !163
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add.320(%struct.list_head* %new, %struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

declare i32 @del_timer(%struct.timer_list*) #4

; Function Attrs: nounwind uwtable
define internal void @rpc_reset_task_statistics(%struct.rpc_task* %task) #0 {
entry:
  %tk_timeouts = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 18
  store i16 0, i16* %tk_timeouts, align 2, !tbaa !123
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %0 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, -2337
  %conv1 = trunc i32 %and to i16
  store i16 %conv1, i16* %tk_flags, align 8, !tbaa !27
  call void @rpc_init_task_statistics(%struct.rpc_task* %task)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_init_task_statistics(%struct.rpc_task* %task) #0 {
entry:
  %coerce = alloca %struct.pgprot, align 8
  %tk_garb_retry = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 20
  %bf.load = load i8, i8* %tk_garb_retry, align 2
  %bf.clear = and i8 %bf.load, -13
  %bf.set = or i8 %bf.clear, 8
  store i8 %bf.set, i8* %tk_garb_retry, align 2
  %tk_cred_retry = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 20
  %bf.load1 = load i8, i8* %tk_cred_retry, align 2
  %bf.clear2 = and i8 %bf.load1, -49
  %bf.set3 = or i8 %bf.clear2, 32
  store i8 %bf.set3, i8* %tk_cred_retry, align 2
  %tk_rebind_retry = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 20
  %bf.load4 = load i8, i8* %tk_rebind_retry, align 2
  %bf.clear5 = and i8 %bf.load4, 63
  %bf.set6 = or i8 %bf.clear5, -128
  store i8 %bf.set6, i8* %tk_rebind_retry, align 2
  %tk_start = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 14
  %call = call i64 @ktime_get()
  %coerce.dive = getelementptr inbounds %struct.pgprot, %struct.pgprot* %coerce, i32 0, i32 0
  store i64 %call, i64* %coerce.dive, align 8
  %0 = bitcast %struct.pgprot* %tk_start to i8*
  %1 = bitcast %struct.pgprot* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 8, i32 8, i1 false), !tbaa.struct !290
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_delay(%struct.rpc_task* %task, i64 %delay) #0 {
entry:
  %tk_timeout = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  store i64 %delay, i64* %tk_timeout, align 8, !tbaa !86
  call void @rpc_sleep_on(%struct.rpc_wait_queue* @delay_queue, %struct.rpc_task* %task, void (%struct.rpc_task*)* @__rpc_atrun)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__rpc_atrun(%struct.rpc_task* %task) #0 {
entry:
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 0, i32* %tk_status, align 4, !tbaa !59
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_sleep_on(%struct.rpc_wait_queue* %q, %struct.rpc_task* %task, void (%struct.rpc_task*)* %action) #0 {
entry:
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %0 = load volatile i64, i64* %tk_runstate, align 8, !tbaa !88
  %and.i1 = and i64 4, %0
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool = icmp ne i32 %conv.i3, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end35

if.then:                                          ; preds = %entry
  %1 = load i8, i8* @rpc_sleep_on.__warned, align 1, !tbaa !29, !range !31
  %tobool9 = trunc i8 %1 to i1
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %tobool16 = icmp ne i32 %lnot.ext15, 0
  %lnot17 = xor i1 %tobool16, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool23 = icmp ne i64 %expval22, 0
  br i1 %tobool23, label %if.then24, label %if.end

if.then24:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.9.289, i32 0, i32 0), i32 373)
  br label %if.end

if.end:                                           ; preds = %if.then24, %if.then
  %tobool25 = icmp ne i32 %lnot.ext15, 0
  %lnot26 = xor i1 %tobool25, true
  %lnot28 = xor i1 %lnot26, true
  %lnot.ext29 = zext i1 %lnot28 to i32
  %conv30 = sext i32 %lnot.ext29 to i64
  %expval31 = call i64 @llvm.expect.i64(i64 %conv30, i64 0)
  %tobool32 = icmp ne i64 %expval31, 0
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %if.end
  store i8 1, i8* @rpc_sleep_on.__warned, align 1, !tbaa !29
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %if.end, %entry
  %tk_runstate44 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %2 = load volatile i64, i64* %tk_runstate44, align 8, !tbaa !88
  %and.i = and i64 4, %2
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool46 = icmp ne i32 %conv.i, 0
  br i1 %tobool46, label %if.end51, label %if.then50

if.then50:                                        ; preds = %if.end35
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 -5, i32* %tk_status, align 4, !tbaa !59
  call void @rpc_put_task_async(%struct.rpc_task* %task)
  br label %return

if.end51:                                         ; preds = %if.end35
  %lock = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %q, i32 0, i32 0
  call void @spin_lock_bh.280(%struct.spinlock* %lock)
  %tk_priority = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 20
  %bf.load = load i8, i8* %tk_priority, align 2
  %bf.clear = and i8 %bf.load, 3
  call void @__rpc_sleep_on_priority(%struct.rpc_wait_queue* %q, %struct.rpc_task* %task, void (%struct.rpc_task*)* %action, i8 zeroext %bf.clear)
  %lock52 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %q, i32 0, i32 0
  call void @spin_unlock_bh.281(%struct.spinlock* %lock52)
  br label %return

return:                                           ; preds = %if.end51, %if.then50
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__rpc_sleep_on_priority(%struct.rpc_wait_queue* %q, %struct.rpc_task* %task, void (%struct.rpc_task*)* %action, i8 zeroext %queue_priority) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 64
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %call = call i8* @rpc_qname.317(%struct.rpc_wait_queue* %q)
  %1 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %3 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  call void @trace_rpc_task_sleep(%struct.rpc_clnt* %3, %struct.rpc_task* %task, %struct.rpc_wait_queue* %q)
  call void @__rpc_add_wait_queue(%struct.rpc_wait_queue* %q, %struct.rpc_task* %task, i8 zeroext %queue_priority)
  %tk_callback = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 5
  %4 = load void (%struct.rpc_task*)*, void (%struct.rpc_task*)** %tk_callback, align 8, !tbaa !485
  %cmp = icmp ne void (%struct.rpc_task*)* %4, null
  %lnot6 = xor i1 %cmp, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %tobool10 = icmp ne i32 %lnot.ext9, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %if.then18, label %if.end46

if.then18:                                        ; preds = %do.end
  %5 = load i8, i8* @__rpc_sleep_on_priority.__warned, align 1, !tbaa !29, !range !31
  %tobool19 = trunc i8 %5 to i1
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot24 = xor i1 %lnot22, true
  %lnot.ext25 = zext i1 %lnot24 to i32
  %tobool26 = icmp ne i32 %lnot.ext25, 0
  %lnot27 = xor i1 %tobool26, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.then18
  call void @warn_slowpath_null(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.9.289, i32 0, i32 0), i32 364)
  br label %if.end35

if.end35:                                         ; preds = %if.then34, %if.then18
  %tobool36 = icmp ne i32 %lnot.ext25, 0
  %lnot37 = xor i1 %tobool36, true
  %lnot39 = xor i1 %lnot37, true
  %lnot.ext40 = zext i1 %lnot39 to i32
  %conv41 = sext i32 %lnot.ext40 to i64
  %expval42 = call i64 @llvm.expect.i64(i64 %conv41, i64 0)
  %tobool43 = icmp ne i64 %expval42, 0
  br i1 %tobool43, label %if.then44, label %if.end46

if.then44:                                        ; preds = %if.end35
  store i8 1, i8* @__rpc_sleep_on_priority.__warned, align 1, !tbaa !29
  br label %if.end46

if.end46:                                         ; preds = %if.then44, %if.end35, %do.end
  %tk_callback55 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 5
  store void (%struct.rpc_task*)* %action, void (%struct.rpc_task*)** %tk_callback55, align 8, !tbaa !485
  call void @__rpc_add_timer(%struct.rpc_wait_queue* %q, %struct.rpc_task* %task)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @trace_rpc_task_sleep(%struct.rpc_clnt* %clnt, %struct.rpc_task* %task, %struct.rpc_wait_queue* %q) #2 {
entry:
  %call.i = call i32 @atomic_read.296(%struct.atomic_t* getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_task_sleep, i64 0, i32 1, i32 0)) #7
  %tobool.i = icmp ne i32 %call.i, 0
  %lnot.ext.i = zext i1 %tobool.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv.i, i64 0) #7
  %cmp.i = icmp sgt i64 %expval.i, 0
  %..i = select i1 %cmp.i, i1 true, i1 false
  br i1 %..i, label %do.body, label %if.end21

do.body:                                          ; preds = %entry
  call void @rcu_read_lock_sched_notrace.300()
  %0 = load volatile %struct.tracepoint_func*, %struct.tracepoint_func** getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_task_sleep, i32 0, i32 4), align 8, !tbaa !28
  %call2 = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %land.lhs.true, label %do.end10

land.lhs.true:                                    ; preds = %do.body
  %1 = load i8, i8* @trace_rpc_task_sleep.__warned, align 1, !tbaa !29, !range !31
  %tobool3 = trunc i8 %1 to i1
  br i1 %tobool3, label %do.end10, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %land.lhs.true
  %call5 = call i32 @rcu_read_lock_sched_held.301()
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %do.end10, label %if.then7

if.then7:                                         ; preds = %land.lhs.true4
  store i8 1, i8* @trace_rpc_task_sleep.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.36.302, i32 0, i32 0), i32 165, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end10

do.end10:                                         ; preds = %if.then7, %land.lhs.true4, %land.lhs.true, %do.body
  %tobool11 = icmp ne %struct.tracepoint_func* %0, null
  br i1 %tobool11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %do.end10
  br label %do.body13

do.body13:                                        ; preds = %do.body13, %if.then12
  %it_func_ptr.0 = phi %struct.tracepoint_func* [ %0, %if.then12 ], [ %incdec.ptr, %do.body13 ]
  %func = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 0
  %2 = load i8*, i8** %func, align 8, !tbaa !120
  %data = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 1
  %3 = load i8*, i8** %data, align 8, !tbaa !122
  %4 = bitcast i8* %2 to void (i8*, %struct.rpc_clnt*, %struct.rpc_task*, %struct.rpc_wait_queue*)*
  call void %4(i8* %3, %struct.rpc_clnt* %clnt, %struct.rpc_task* %task, %struct.rpc_wait_queue* %q)
  %incdec.ptr = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 1
  %func15 = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %incdec.ptr, i32 0, i32 0
  %5 = load i8*, i8** %func15, align 8, !tbaa !120
  %tobool16 = icmp ne i8* %5, null
  br i1 %tobool16, label %do.body13, label %if.end18

if.end18:                                         ; preds = %do.body13, %do.end10
  call void @rcu_read_unlock_sched_notrace.304()
  br label %if.end21

if.end21:                                         ; preds = %if.end18, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__rpc_add_wait_queue(%struct.rpc_wait_queue* %queue, %struct.rpc_task* %task, i8 zeroext %queue_priority) #0 {
entry:
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %0 = load volatile i64, i64* %tk_runstate, align 8, !tbaa !88
  %and.i1 = and i64 2, %0
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool = icmp ne i32 %conv.i3, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool2 = icmp ne i32 %lnot.ext, 0
  %lnot3 = xor i1 %tobool2, true
  %lnot5 = xor i1 %lnot3, true
  %lnot.ext6 = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext6 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then, label %if.end34

if.then:                                          ; preds = %entry
  %1 = load i8, i8* @__rpc_add_wait_queue.__warned, align 1, !tbaa !29, !range !31
  %tobool8 = trunc i8 %1 to i1
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %tobool15 = icmp ne i32 %lnot.ext14, 0
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot.ext19 = zext i1 %lnot18 to i32
  %conv20 = sext i32 %lnot.ext19 to i64
  %expval21 = call i64 @llvm.expect.i64(i64 %conv20, i64 0)
  %tobool22 = icmp ne i64 %expval21, 0
  br i1 %tobool22, label %if.then23, label %if.end

if.then23:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.9.289, i32 0, i32 0), i32 171)
  br label %if.end

if.end:                                           ; preds = %if.then23, %if.then
  %tobool24 = icmp ne i32 %lnot.ext14, 0
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot.ext28 = zext i1 %lnot27 to i32
  %conv29 = sext i32 %lnot.ext28 to i64
  %expval30 = call i64 @llvm.expect.i64(i64 %conv29, i64 0)
  %tobool31 = icmp ne i64 %expval30, 0
  br i1 %tobool31, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.end
  store i8 1, i8* @__rpc_add_wait_queue.__warned, align 1, !tbaa !29
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %if.end, %entry
  %tk_runstate43 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %2 = load volatile i64, i64* %tk_runstate43, align 8, !tbaa !88
  %and.i = and i64 2, %2
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool45 = icmp ne i32 %conv.i, 0
  br i1 %tobool45, label %do.end, label %if.end50

if.end50:                                         ; preds = %if.end34
  %maxpriority = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 3
  %3 = load i8, i8* %maxpriority, align 4, !tbaa !478
  %conv51 = zext i8 %3 to i32
  %cmp = icmp sgt i32 %conv51, 0
  br i1 %cmp, label %if.then53, label %if.else

if.then53:                                        ; preds = %if.end50
  call void @__rpc_add_wait_queue_priority(%struct.rpc_wait_queue* %queue, %struct.rpc_task* %task, i8 zeroext %queue_priority)
  br label %if.end64

if.else:                                          ; preds = %if.end50
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %4 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv54 = zext i16 %4 to i32
  %and = and i32 %conv54, 2
  %tobool55 = icmp ne i32 %and, 0
  %u = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_wait = bitcast %union.anon.69* %u to %struct.rpc_wait*
  %list = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait, i32 0, i32 0
  %tasks = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 1
  %arrayidx = getelementptr inbounds [4 x %struct.list_head], [4 x %struct.list_head]* %tasks, i64 0, i64 0
  br i1 %tobool55, label %if.then56, label %if.else57

if.then56:                                        ; preds = %if.else
  call void @list_add.320(%struct.list_head* %list, %struct.list_head* %arrayidx)
  br label %if.end64

if.else57:                                        ; preds = %if.else
  call void @list_add_tail.328(%struct.list_head* %list, %struct.list_head* %arrayidx)
  br label %if.end64

if.end64:                                         ; preds = %if.else57, %if.then56, %if.then53
  %tk_waitqueue = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 12
  store %struct.rpc_wait_queue* %queue, %struct.rpc_wait_queue** %tk_waitqueue, align 8, !tbaa !222
  %qlen = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 6
  %5 = load i16, i16* %qlen, align 8, !tbaa !479
  %inc = add i16 %5, 1
  store i16 %inc, i16* %qlen, align 8, !tbaa !479
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !500
  %tk_runstate65 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %tk_runstate65, i32 1, i64* %tk_runstate65) #7, !srcloc !488
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and66 = and i32 %6, 64
  %tobool67 = icmp ne i32 %and66, 0
  %lnot68 = xor i1 %tobool67, true
  %lnot70 = xor i1 %lnot68, true
  %lnot.ext71 = zext i1 %lnot70 to i32
  %conv72 = sext i32 %lnot.ext71 to i64
  %expval73 = call i64 @llvm.expect.i64(i64 %conv72, i64 0)
  %tobool74 = icmp ne i64 %expval73, 0
  br i1 %tobool74, label %if.then75, label %do.end

if.then75:                                        ; preds = %if.end64
  %call77 = call i8* @rpc_qname.317(%struct.rpc_wait_queue* %queue)
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then75, %if.end64, %if.end34
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__rpc_add_timer(%struct.rpc_wait_queue* %queue, %struct.rpc_task* %task) #0 {
entry:
  %tk_timeout = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  %0 = load i64, i64* %tk_timeout, align 8, !tbaa !86
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %do.body, label %return

do.body:                                          ; preds = %entry
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 64
  %tobool1 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.end

if.then4:                                         ; preds = %do.body
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then4, %do.body
  %3 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %tk_timeout8 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  %4 = load i64, i64* %tk_timeout8, align 8, !tbaa !86
  %add = add i64 %3, %4
  %u = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_wait = bitcast %union.anon.69* %u to %struct.rpc_wait*
  %expires = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait, i32 0, i32 3
  store i64 %add, i64* %expires, align 8, !tbaa !166
  %timer_list = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 7
  %list = getelementptr inbounds %struct.rpc_timer, %struct.rpc_timer* %timer_list, i32 0, i32 1
  %call9 = call i32 @list_empty.298(%struct.list_head* %list)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %tobool12 = icmp ne i32 1, 0
  br i1 %tobool12, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %lor.lhs.false
  %u20 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_wait21 = bitcast %union.anon.69* %u20 to %struct.rpc_wait*
  %expires22 = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait21, i32 0, i32 3
  %5 = load i64, i64* %expires22, align 8, !tbaa !166
  %timer_list23 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 7
  %expires24 = getelementptr inbounds %struct.rpc_timer, %struct.rpc_timer* %timer_list23, i32 0, i32 2
  %6 = load i64, i64* %expires24, align 8, !tbaa !501
  %sub = sub nsw i64 %5, %6
  %cmp25 = icmp slt i64 %sub, 0
  br i1 %cmp25, label %if.then27, label %if.end31

if.then27:                                        ; preds = %land.lhs.true, %do.end
  %u28 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_wait29 = bitcast %union.anon.69* %u28 to %struct.rpc_wait*
  %expires30 = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait29, i32 0, i32 3
  %7 = load i64, i64* %expires30, align 8, !tbaa !166
  call void @rpc_set_queue_timer(%struct.rpc_wait_queue* %queue, i64 %7)
  br label %if.end31

if.end31:                                         ; preds = %if.then27, %land.lhs.true, %lor.lhs.false
  %u32 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_wait33 = bitcast %union.anon.69* %u32 to %struct.rpc_wait*
  %timer_list34 = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait33, i32 0, i32 2
  %timer_list35 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 7
  %list36 = getelementptr inbounds %struct.rpc_timer, %struct.rpc_timer* %timer_list35, i32 0, i32 1
  call void @list_add.320(%struct.list_head* %timer_list34, %struct.list_head* %list36)
  br label %return

return:                                           ; preds = %if.end31, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_set_queue_timer(%struct.rpc_wait_queue* %queue, i64 %expires) #0 {
entry:
  %timer_list = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 7
  %expires1 = getelementptr inbounds %struct.rpc_timer, %struct.rpc_timer* %timer_list, i32 0, i32 2
  store i64 %expires, i64* %expires1, align 8, !tbaa !501
  %timer_list2 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 7
  %timer = getelementptr inbounds %struct.rpc_timer, %struct.rpc_timer* %timer_list2, i32 0, i32 0
  %call = call i32 @mod_timer(%struct.timer_list* %timer, i64 %expires)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__rpc_add_wait_queue_priority(%struct.rpc_wait_queue* %queue, %struct.rpc_task* %task, i8 zeroext %queue_priority) #0 {
entry:
  %u = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_wait = bitcast %union.anon.69* %u to %struct.rpc_wait*
  %links = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait, i32 0, i32 1
  call void @INIT_LIST_HEAD.259(%struct.list_head* %links)
  %conv = zext i8 %queue_priority to i32
  %maxpriority = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 3
  %0 = load i8, i8* %maxpriority, align 4, !tbaa !478
  %conv1 = zext i8 %0 to i32
  %cmp = icmp sgt i32 %conv, %conv1
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %maxpriority5 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 3
  %1 = load i8, i8* %maxpriority5, align 4, !tbaa !478
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %queue_priority.addr.0 = phi i8 [ %1, %if.then ], [ %queue_priority, %entry ]
  %conv6 = zext i8 %queue_priority.addr.0 to i32
  %priority = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 4
  %2 = load i8, i8* %priority, align 1, !tbaa !502
  %conv7 = zext i8 %2 to i32
  %cmp8 = icmp sgt i32 %conv6, %conv7
  br i1 %cmp8, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end
  %conv11 = zext i8 %queue_priority.addr.0 to i32
  call void @rpc_set_waitqueue_priority(%struct.rpc_wait_queue* %queue, i32 %conv11)
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end
  %tasks = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 1
  %idxprom = zext i8 %queue_priority.addr.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.list_head], [4 x %struct.list_head]* %tasks, i64 0, i64 %idxprom
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end12
  %list31.sink = phi %struct.list_head* [ %list31, %for.inc ], [ %arrayidx, %if.end12 ]
  %next32 = getelementptr inbounds %struct.list_head, %struct.list_head* %list31.sink, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next32, align 8, !tbaa !166
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr34 = getelementptr inbounds i8, i8* %4, i64 -136
  %5 = bitcast i8* %add.ptr34 to %struct.rpc_task*
  %u13 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %5, i32 0, i32 13
  %tk_wait14 = bitcast %union.anon.69* %u13 to %struct.rpc_wait*
  %list = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait14, i32 0, i32 0
  %cmp15 = icmp ne %struct.list_head* %list, %arrayidx
  br i1 %cmp15, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %tk_owner = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %5, i32 0, i32 15
  %6 = load i32, i32* %tk_owner, align 8, !tbaa !503
  %tk_owner17 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 15
  %7 = load i32, i32* %tk_owner17, align 8, !tbaa !503
  %cmp18 = icmp eq i32 %6, %7
  br i1 %cmp18, label %if.then20, label %for.inc

if.then20:                                        ; preds = %for.body
  %u21 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_wait22 = bitcast %union.anon.69* %u21 to %struct.rpc_wait*
  %list23 = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait22, i32 0, i32 0
  %u24 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %5, i32 0, i32 13
  %tk_wait25 = bitcast %union.anon.69* %u24 to %struct.rpc_wait*
  %links26 = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait25, i32 0, i32 1
  call void @list_add_tail.328(%struct.list_head* %list23, %struct.list_head* %links26)
  br label %cleanup.cont

for.inc:                                          ; preds = %for.body
  %u29 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %5, i32 0, i32 13
  %tk_wait30 = bitcast %union.anon.69* %u29 to %struct.rpc_wait*
  %list31 = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait30, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %u35 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %tk_wait36 = bitcast %union.anon.69* %u35 to %struct.rpc_wait*
  %list37 = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait36, i32 0, i32 0
  call void @list_add_tail.328(%struct.list_head* %list37, %struct.list_head* %arrayidx)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %if.then20
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.328(%struct.list_head* %new, %struct.list_head* %head) #2 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !163
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_set_waitqueue_priority(%struct.rpc_wait_queue* %queue, i32 %priority) #0 {
entry:
  %priority1 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 4
  %0 = load i8, i8* %priority1, align 1, !tbaa !502
  %conv = zext i8 %0 to i32
  %cmp = icmp ne i32 %conv, %priority
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @rpc_rotate_queue_owner(%struct.rpc_wait_queue* %queue)
  %conv3 = trunc i32 %priority to i8
  %priority4 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 4
  store i8 %conv3, i8* %priority4, align 1, !tbaa !502
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_rotate_queue_owner(%struct.rpc_wait_queue* %queue) #0 {
entry:
  %tasks = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 1
  %priority = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 4
  %0 = load i8, i8* %priority, align 1, !tbaa !502
  %idxprom = zext i8 %0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.list_head], [4 x %struct.list_head]* %tasks, i64 0, i64 %idxprom
  %call = call i32 @list_empty.298(%struct.list_head* %arrayidx)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end2, label %if.then

if.then:                                          ; preds = %entry
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %arrayidx, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -136
  %3 = bitcast i8* %add.ptr to %struct.rpc_task*
  %tk_owner = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %3, i32 0, i32 15
  %4 = load i32, i32* %tk_owner, align 8, !tbaa !503
  %owner = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 2
  %5 = load i32, i32* %owner, align 8, !tbaa !504
  %cmp = icmp eq i32 %4, %5
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.then
  %u = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %3, i32 0, i32 13
  %tk_wait = bitcast %union.anon.69* %u to %struct.rpc_wait*
  %list = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait, i32 0, i32 0
  call void @list_move_tail(%struct.list_head* %list, %struct.list_head* %arrayidx)
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_move_tail(%struct.list_head* %list, %struct.list_head* %head) #2 {
entry:
  call void @__list_del_entry(%struct.list_head* %list)
  call void @list_add_tail.328(%struct.list_head* %list, %struct.list_head* %head)
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_wake_up_status(%struct.rpc_wait_queue* %queue, i32 %status) #0 {
entry:
  %lock = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 0
  call void @spin_lock_bh.280(%struct.spinlock* %lock)
  %tasks = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 1
  %maxpriority = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 3
  %0 = load i8, i8* %maxpriority, align 4, !tbaa !478
  %idxprom = zext i8 %0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.list_head], [4 x %struct.list_head]* %tasks, i64 0, i64 %idxprom
  %tasks1 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 1
  %arrayidx2 = getelementptr inbounds [4 x %struct.list_head], [4 x %struct.list_head]* %tasks1, i64 0, i64 0
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %head.0 = phi %struct.list_head* [ %arrayidx, %entry ], [ %incdec.ptr, %if.end ]
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.cond
  %call = call i32 @list_empty.298(%struct.list_head* %head.0)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head.0, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -136
  %3 = bitcast i8* %add.ptr to %struct.rpc_task*
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %3, i32 0, i32 16
  store i32 %status, i32* %tk_status, align 4, !tbaa !59
  call void @rpc_wake_up_task_queue_locked(%struct.rpc_wait_queue* %queue, %struct.rpc_task* %3)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %cmp = icmp eq %struct.list_head* %head.0, %arrayidx2
  br i1 %cmp, label %for.end, label %if.end

if.end:                                           ; preds = %while.end
  %incdec.ptr = getelementptr inbounds %struct.list_head, %struct.list_head* %head.0, i32 -1
  br label %for.cond

for.end:                                          ; preds = %while.end
  %lock3 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 0
  call void @spin_unlock_bh.281(%struct.spinlock* %lock3)
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_wake_up(%struct.rpc_wait_queue* %queue) #0 {
entry:
  %lock = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 0
  call void @spin_lock_bh.280(%struct.spinlock* %lock)
  %tasks = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 1
  %maxpriority = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 3
  %0 = load i8, i8* %maxpriority, align 4, !tbaa !478
  %idxprom = zext i8 %0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.list_head], [4 x %struct.list_head]* %tasks, i64 0, i64 %idxprom
  %tasks1 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 1
  %arrayidx2 = getelementptr inbounds [4 x %struct.list_head], [4 x %struct.list_head]* %tasks1, i64 0, i64 0
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %head.0 = phi %struct.list_head* [ %arrayidx, %entry ], [ %incdec.ptr, %if.end ]
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.cond
  %call = call i32 @list_empty.298(%struct.list_head* %head.0)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head.0, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -136
  %3 = bitcast i8* %add.ptr to %struct.rpc_task*
  call void @rpc_wake_up_task_queue_locked(%struct.rpc_wait_queue* %queue, %struct.rpc_task* %3)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %cmp = icmp eq %struct.list_head* %head.0, %arrayidx2
  br i1 %cmp, label %for.end, label %if.end

if.end:                                           ; preds = %while.end
  %incdec.ptr = getelementptr inbounds %struct.list_head, %struct.list_head* %head.0, i32 -1
  br label %for.cond

for.end:                                          ; preds = %while.end
  %lock3 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 0
  call void @spin_unlock_bh.281(%struct.spinlock* %lock3)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.rpc_task* @rpc_wake_up_next(%struct.rpc_wait_queue* %queue) #0 {
entry:
  %call = call %struct.rpc_task* @rpc_wake_up_first(%struct.rpc_wait_queue* %queue, i1 (%struct.rpc_task*, i8*)* @rpc_wake_up_next_func, i8* null)
  ret %struct.rpc_task* %call
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @rpc_wake_up_next_func(%struct.rpc_task* %task, i8* %data) #0 {
entry:
  ret i1 true
}

; Function Attrs: nounwind uwtable
define %struct.rpc_task* @rpc_wake_up_first(%struct.rpc_wait_queue* %queue, i1 (%struct.rpc_task*, i8*)* %func, i8* %data) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 64
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %call = call i8* @rpc_qname.317(%struct.rpc_wait_queue* %queue)
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %lock = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 0
  call void @spin_lock_bh.280(%struct.spinlock* %lock)
  %call4 = call %struct.rpc_task* @__rpc_find_next_queued(%struct.rpc_wait_queue* %queue)
  %cmp = icmp ne %struct.rpc_task* %call4, null
  br i1 %cmp, label %if.then6, label %if.end10

if.then6:                                         ; preds = %do.end
  %call7 = call zeroext i1 %func(%struct.rpc_task* %call4, i8* %data)
  br i1 %call7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.then6
  call void @rpc_wake_up_task_queue_locked(%struct.rpc_wait_queue* %queue, %struct.rpc_task* %call4)
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.then6, %do.end
  %task.1 = phi %struct.rpc_task* [ %call4, %do.end ], [ %call4, %if.then8 ], [ null, %if.then6 ]
  %lock11 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 0
  call void @spin_unlock_bh.281(%struct.spinlock* %lock11)
  ret %struct.rpc_task* %task.1
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_task* @__rpc_find_next_queued(%struct.rpc_wait_queue* %queue) #0 {
entry:
  %maxpriority = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 3
  %0 = load i8, i8* %maxpriority, align 4, !tbaa !478
  %conv = zext i8 %0 to i32
  %cmp = icmp sgt i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call %struct.rpc_task* @__rpc_find_next_queued_priority(%struct.rpc_wait_queue* %queue)
  br label %return

if.end:                                           ; preds = %entry
  %tasks = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 1
  %arrayidx = getelementptr inbounds [4 x %struct.list_head], [4 x %struct.list_head]* %tasks, i64 0, i64 0
  %call2 = call i32 @list_empty.298(%struct.list_head* %arrayidx)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %return, label %if.then3

if.then3:                                         ; preds = %if.end
  %tasks4 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 1
  %arrayidx5 = getelementptr inbounds [4 x %struct.list_head], [4 x %struct.list_head]* %tasks4, i64 0, i64 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %arrayidx5, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -136
  %3 = bitcast i8* %add.ptr to %struct.rpc_task*
  br label %return

return:                                           ; preds = %if.then3, %if.end, %if.then
  %retval.0 = phi %struct.rpc_task* [ %call, %if.then ], [ %3, %if.then3 ], [ null, %if.end ]
  ret %struct.rpc_task* %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_task* @__rpc_find_next_queued_priority(%struct.rpc_wait_queue* %queue) #0 {
entry:
  %tasks = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 1
  %priority = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 4
  %0 = load i8, i8* %priority, align 1, !tbaa !502
  %idxprom = zext i8 %0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.list_head], [4 x %struct.list_head]* %tasks, i64 0, i64 %idxprom
  %call = call i32 @list_empty.298(%struct.list_head* %arrayidx)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end5, label %if.then

if.then:                                          ; preds = %entry
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %arrayidx, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -136
  %3 = bitcast i8* %add.ptr to %struct.rpc_task*
  %owner = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 2
  %4 = load i32, i32* %owner, align 8, !tbaa !504
  %tk_owner = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %3, i32 0, i32 15
  %5 = load i32, i32* %tk_owner, align 8, !tbaa !503
  %cmp = icmp eq i32 %4, %5
  br i1 %cmp, label %if.then1, label %new_owner

if.then1:                                         ; preds = %if.then
  %nr = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 5
  %6 = load i8, i8* %nr, align 2, !tbaa !505
  %dec = add i8 %6, -1
  store i8 %dec, i8* %nr, align 2, !tbaa !505
  %tobool2 = icmp ne i8 %dec, 0
  br i1 %tobool2, label %cleanup, label %if.end

if.end:                                           ; preds = %if.then1
  %u = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %3, i32 0, i32 13
  %tk_wait = bitcast %union.anon.69* %u to %struct.rpc_wait*
  %list = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait, i32 0, i32 0
  call void @list_move_tail(%struct.list_head* %list, %struct.list_head* %arrayidx)
  br label %new_owner

if.end5:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end5
  %q.0 = phi %struct.list_head* [ %arrayidx, %if.end5 ], [ %q.1, %do.cond ]
  %tasks6 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 1
  %arrayidx7 = getelementptr inbounds [4 x %struct.list_head], [4 x %struct.list_head]* %tasks6, i64 0, i64 0
  %cmp8 = icmp eq %struct.list_head* %q.0, %arrayidx7
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %do.body
  %tasks10 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 1
  %maxpriority = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 3
  %7 = load i8, i8* %maxpriority, align 4, !tbaa !478
  %idxprom11 = zext i8 %7 to i64
  %arrayidx12 = getelementptr inbounds [4 x %struct.list_head], [4 x %struct.list_head]* %tasks10, i64 0, i64 %idxprom11
  br label %if.end14

if.else:                                          ; preds = %do.body
  %add.ptr13 = getelementptr inbounds %struct.list_head, %struct.list_head* %q.0, i64 -1
  br label %if.end14

if.end14:                                         ; preds = %if.else, %if.then9
  %q.1 = phi %struct.list_head* [ %arrayidx12, %if.then9 ], [ %add.ptr13, %if.else ]
  %call15 = call i32 @list_empty.298(%struct.list_head* %q.1)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %do.cond, label %if.then17

if.then17:                                        ; preds = %if.end14
  %next19 = getelementptr inbounds %struct.list_head, %struct.list_head* %q.1, i32 0, i32 0
  %8 = load %struct.list_head*, %struct.list_head** %next19, align 8, !tbaa !164
  %9 = bitcast %struct.list_head* %8 to i8*
  %add.ptr21 = getelementptr inbounds i8, i8* %9, i64 -136
  %10 = bitcast i8* %add.ptr21 to %struct.rpc_task*
  %tasks28 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 1
  %arrayidx29 = getelementptr inbounds [4 x %struct.list_head], [4 x %struct.list_head]* %tasks28, i64 0, i64 0
  %sub.ptr.lhs.cast = ptrtoint %struct.list_head* %q.1 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.list_head* %arrayidx29 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %conv = trunc i64 %sub.ptr.div to i32
  call void @rpc_set_waitqueue_priority(%struct.rpc_wait_queue* %queue, i32 %conv)
  br label %new_owner

do.cond:                                          ; preds = %if.end14
  %tasks23 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 1
  %priority24 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 4
  %11 = load i8, i8* %priority24, align 1, !tbaa !502
  %idxprom25 = zext i8 %11 to i64
  %arrayidx26 = getelementptr inbounds [4 x %struct.list_head], [4 x %struct.list_head]* %tasks23, i64 0, i64 %idxprom25
  %cmp27 = icmp ne %struct.list_head* %q.1, %arrayidx26
  br i1 %cmp27, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  call void @rpc_reset_waitqueue_priority(%struct.rpc_wait_queue* %queue)
  br label %cleanup

new_owner:                                        ; preds = %if.then17, %if.end, %if.then
  %task.0 = phi %struct.rpc_task* [ %10, %if.then17 ], [ %3, %if.end ], [ %3, %if.then ]
  %tk_owner30 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task.0, i32 0, i32 15
  %12 = load i32, i32* %tk_owner30, align 8, !tbaa !503
  call void @rpc_set_waitqueue_owner(%struct.rpc_wait_queue* %queue, i32 %12)
  br label %cleanup

cleanup:                                          ; preds = %new_owner, %do.end, %if.then1
  %retval.0 = phi %struct.rpc_task* [ null, %do.end ], [ %task.0, %new_owner ], [ %3, %if.then1 ]
  ret %struct.rpc_task* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @rpc_reset_waitqueue_priority(%struct.rpc_wait_queue* %queue) #0 {
entry:
  %maxpriority = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 3
  %0 = load i8, i8* %maxpriority, align 4, !tbaa !478
  %conv = zext i8 %0 to i32
  call void @rpc_set_waitqueue_priority(%struct.rpc_wait_queue* %queue, i32 %conv)
  call void @rpc_set_waitqueue_owner(%struct.rpc_wait_queue* %queue, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_set_waitqueue_owner(%struct.rpc_wait_queue* %queue, i32 %pid) #0 {
entry:
  %owner = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 2
  store i32 %pid, i32* %owner, align 8, !tbaa !504
  %nr = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 5
  store i8 16, i8* %nr, align 2, !tbaa !505
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @rpc_queue_empty(%struct.rpc_wait_queue* %queue) #0 {
entry:
  %lock = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 0
  call void @spin_lock_bh.280(%struct.spinlock* %lock)
  %qlen = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 6
  %0 = load i16, i16* %qlen, align 8, !tbaa !479
  %conv = zext i16 %0 to i32
  %lock1 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 0
  call void @spin_unlock_bh.281(%struct.spinlock* %lock1)
  %cmp = icmp eq i32 %conv, 0
  %conv2 = zext i1 %cmp to i32
  ret i32 %conv2
}

; Function Attrs: nounwind uwtable
define void @rpc_sleep_on_priority(%struct.rpc_wait_queue* %q, %struct.rpc_task* %task, void (%struct.rpc_task*)* %action, i32 %priority) #0 {
entry:
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %0 = load volatile i64, i64* %tk_runstate, align 8, !tbaa !88
  %and.i1 = and i64 4, %0
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool = icmp ne i32 %conv.i3, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end35

if.then:                                          ; preds = %entry
  %1 = load i8, i8* @rpc_sleep_on_priority.__warned, align 1, !tbaa !29, !range !31
  %tobool9 = trunc i8 %1 to i1
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %tobool16 = icmp ne i32 %lnot.ext15, 0
  %lnot17 = xor i1 %tobool16, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool23 = icmp ne i64 %expval22, 0
  br i1 %tobool23, label %if.then24, label %if.end

if.then24:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.9.289, i32 0, i32 0), i32 393)
  br label %if.end

if.end:                                           ; preds = %if.then24, %if.then
  %tobool25 = icmp ne i32 %lnot.ext15, 0
  %lnot26 = xor i1 %tobool25, true
  %lnot28 = xor i1 %lnot26, true
  %lnot.ext29 = zext i1 %lnot28 to i32
  %conv30 = sext i32 %lnot.ext29 to i64
  %expval31 = call i64 @llvm.expect.i64(i64 %conv30, i64 0)
  %tobool32 = icmp ne i64 %expval31, 0
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %if.end
  store i8 1, i8* @rpc_sleep_on_priority.__warned, align 1, !tbaa !29
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %if.end, %entry
  %tk_runstate44 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %2 = load volatile i64, i64* %tk_runstate44, align 8, !tbaa !88
  %and.i = and i64 4, %2
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool46 = icmp ne i32 %conv.i, 0
  br i1 %tobool46, label %if.end51, label %if.then50

if.then50:                                        ; preds = %if.end35
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 -5, i32* %tk_status, align 4, !tbaa !59
  call void @rpc_put_task_async(%struct.rpc_task* %task)
  br label %return

if.end51:                                         ; preds = %if.end35
  %lock = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %q, i32 0, i32 0
  call void @spin_lock_bh.280(%struct.spinlock* %lock)
  %sub = sub nsw i32 %priority, -1
  %conv52 = trunc i32 %sub to i8
  call void @__rpc_sleep_on_priority(%struct.rpc_wait_queue* %q, %struct.rpc_task* %task, void (%struct.rpc_task*)* %action, i8 zeroext %conv52)
  %lock53 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %q, i32 0, i32 0
  call void @spin_unlock_bh.281(%struct.spinlock* %lock53)
  br label %return

return:                                           ; preds = %if.end51, %if.then50
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @__rpc_wait_for_completion_task(%struct.rpc_task* %task, i32 (i8*)* %action) #0 {
entry:
  %cmp = icmp eq i32 (i8*)* %action, null
  %rpc_wait_bit_killable.action = select i1 %cmp, i32 (i8*)* @rpc_wait_bit_killable, i32 (i8*)* %action
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %0 = bitcast i64* %tk_runstate to i8*
  %call = call i32 @out_of_line_wait_on_bit(i8* %0, i32 2, i32 (i8*)* %rpc_wait_bit_killable.action, i32 130)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define void @rpc_destroy_wait_queue(%struct.rpc_wait_queue* %queue) #0 {
entry:
  %timer_list = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 7
  %timer = getelementptr inbounds %struct.rpc_timer, %struct.rpc_timer* %timer_list, i32 0, i32 0
  %call = call i32 @del_timer_sync(%struct.timer_list* %timer)
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_init_wait_queue(%struct.rpc_wait_queue* %queue, i8* %qname) #0 {
entry:
  call void @__rpc_init_priority_wait_queue(%struct.rpc_wait_queue* %queue, i8* %qname, i8 zeroext 1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__rpc_init_priority_wait_queue(%struct.rpc_wait_queue* %queue, i8* %qname, i8 zeroext %nr_queues) #0 {
entry:
  %lock = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 0
  %call = call %struct.raw_spinlock* @spinlock_check.297(%struct.spinlock* %lock)
  %lock2 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 0
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock2, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.38.345, i32 0, i32 0), %struct.lock_class_key* @__rpc_init_priority_wait_queue.__key)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %tasks = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 1
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.list_head], [4 x %struct.list_head]* %tasks, i64 0, i64 %idxprom
  call void @INIT_LIST_HEAD.259(%struct.list_head* %arrayidx)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %conv6 = zext i8 %nr_queues to i32
  %sub = sub nsw i32 %conv6, 1
  %conv7 = trunc i32 %sub to i8
  %maxpriority = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 3
  store i8 %conv7, i8* %maxpriority, align 4, !tbaa !478
  call void @rpc_reset_waitqueue_priority(%struct.rpc_wait_queue* %queue)
  %qlen = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 6
  store i16 0, i16* %qlen, align 8, !tbaa !479
  %timer_list = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 7
  %timer = getelementptr inbounds %struct.rpc_timer, %struct.rpc_timer* %timer_list, i32 0, i32 0
  call void @init_timer_key(%struct.timer_list* %timer, i32 0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.40.346, i32 0, i32 0), %struct.lock_class_key* @__rpc_init_priority_wait_queue.__key.39)
  %timer_list12 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 7
  %timer13 = getelementptr inbounds %struct.rpc_timer, %struct.rpc_timer* %timer_list12, i32 0, i32 0
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer13, i32 0, i32 3
  store void (i64)* @__rpc_queue_timer_fn, void (i64)** %function, align 8, !tbaa !342
  %1 = ptrtoint %struct.rpc_wait_queue* %queue to i64
  %timer_list14 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 7
  %timer15 = getelementptr inbounds %struct.rpc_timer, %struct.rpc_timer* %timer_list14, i32 0, i32 0
  %data = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer15, i32 0, i32 4
  store i64 %1, i64* %data, align 8, !tbaa !343
  %timer_list18 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %queue, i32 0, i32 7
  %list = getelementptr inbounds %struct.rpc_timer, %struct.rpc_timer* %timer_list18, i32 0, i32 1
  call void @INIT_LIST_HEAD.259(%struct.list_head* %list)
  call void @rpc_assign_waitqueue_name(%struct.rpc_wait_queue* %queue, i8* %qname)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__rpc_queue_timer_fn(i64 %ptr) #0 {
entry:
  %0 = inttoptr i64 %ptr to %struct.rpc_wait_queue*
  %lock = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %0, i32 0, i32 0
  call void @spin_lock.347(%struct.spinlock* %lock)
  %1 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %timer_list = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %0, i32 0, i32 7
  %list = getelementptr inbounds %struct.rpc_timer, %struct.rpc_timer* %timer_list, i32 0, i32 1
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -168
  %4 = bitcast i8* %add.ptr to %struct.rpc_task*
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %.sink = phi %struct.rpc_task* [ %7, %for.inc ], [ %4, %entry ]
  %task.0 = phi %struct.rpc_task* [ %4, %entry ], [ %7, %for.inc ]
  %expires.0 = phi i64 [ %1, %entry ], [ %expires.2, %for.inc ]
  %u54 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %.sink, i32 0, i32 13
  %tk_wait55 = bitcast %union.anon.69* %u54 to %struct.rpc_wait*
  %timer_list56 = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait55, i32 0, i32 2
  %next57 = getelementptr inbounds %struct.list_head, %struct.list_head* %timer_list56, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next57, align 8, !tbaa !166
  %6 = bitcast %struct.list_head* %5 to i8*
  %add.ptr59 = getelementptr inbounds i8, i8* %6, i64 -168
  %7 = bitcast i8* %add.ptr59 to %struct.rpc_task*
  %u6 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task.0, i32 0, i32 13
  %tk_wait7 = bitcast %union.anon.69* %u6 to %struct.rpc_wait*
  %timer_list8 = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait7, i32 0, i32 2
  %timer_list9 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %0, i32 0, i32 7
  %list10 = getelementptr inbounds %struct.rpc_timer, %struct.rpc_timer* %timer_list9, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %timer_list8, %list10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %u11 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task.0, i32 0, i32 13
  %tk_wait12 = bitcast %union.anon.69* %u11 to %struct.rpc_wait*
  %expires13 = getelementptr inbounds %struct.rpc_wait, %struct.rpc_wait* %tk_wait12, i32 0, i32 3
  %8 = load i64, i64* %expires13, align 8, !tbaa !166
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %for.body
  %sub = sub nsw i64 %1, %8
  %cmp23 = icmp sge i64 %sub, 0
  br i1 %cmp23, label %do.body, label %if.end31

do.body:                                          ; preds = %land.lhs.true
  %9 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %9, 64
  %tobool25 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool25, true
  %lnot26 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot26 to i32
  %conv27 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv27, i64 0)
  %tobool28 = icmp ne i64 %expval, 0
  br i1 %tobool28, label %if.then29, label %do.end

if.then29:                                        ; preds = %do.body
  %10 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then29, %do.body
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task.0, i32 0, i32 16
  store i32 -110, i32* %tk_status, align 4, !tbaa !59
  call void @rpc_wake_up_task_queue_locked(%struct.rpc_wait_queue* %0, %struct.rpc_task* %task.0)
  br label %for.inc

if.end31:                                         ; preds = %land.lhs.true, %for.body
  %cmp32 = icmp eq i64 %expires.0, %1
  br i1 %cmp32, label %if.then51, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end31
  %tobool39 = icmp ne i32 1, 0
  br i1 %tobool39, label %land.lhs.true40, label %for.inc

land.lhs.true40:                                  ; preds = %lor.lhs.false
  %sub48 = sub nsw i64 %8, %expires.0
  %cmp49 = icmp slt i64 %sub48, 0
  br i1 %cmp49, label %if.then51, label %for.inc

if.then51:                                        ; preds = %land.lhs.true40, %if.end31
  br label %for.inc

for.inc:                                          ; preds = %if.then51, %land.lhs.true40, %lor.lhs.false, %do.end
  %expires.2 = phi i64 [ %expires.0, %do.end ], [ %8, %if.then51 ], [ %expires.0, %land.lhs.true40 ], [ %expires.0, %lor.lhs.false ]
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %timer_list60 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %0, i32 0, i32 7
  %list61 = getelementptr inbounds %struct.rpc_timer, %struct.rpc_timer* %timer_list60, i32 0, i32 1
  %call62 = call i32 @list_empty.298(%struct.list_head* %list61)
  %tobool63 = icmp ne i32 %call62, 0
  br i1 %tobool63, label %if.end65, label %if.then64

if.then64:                                        ; preds = %for.end
  call void @rpc_set_queue_timer(%struct.rpc_wait_queue* %0, i64 %expires.0)
  br label %if.end65

if.end65:                                         ; preds = %if.then64, %for.end
  %lock66 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %0, i32 0, i32 0
  call void @spin_unlock.349(%struct.spinlock* %lock66)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rpc_assign_waitqueue_name(%struct.rpc_wait_queue* %q, i8* %name) #2 {
entry:
  %name1 = getelementptr inbounds %struct.rpc_wait_queue, %struct.rpc_wait_queue* %q, i32 0, i32 8
  store i8* %name, i8** %name1, align 8, !tbaa !266
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock.347(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock.349(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_init_priority_wait_queue(%struct.rpc_wait_queue* %queue, i8* %qname) #0 {
entry:
  call void @__rpc_init_priority_wait_queue(%struct.rpc_wait_queue* %queue, i8* %qname, i8 zeroext 4)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ftrace_raw_output_rpc_task_queued(%struct.trace_iterator* %iter, i32 %flags, %struct.trace_event* %trace_event) #6 {
entry:
  %seq = getelementptr inbounds %struct.trace_iterator, %struct.trace_iterator* %iter, i32 0, i32 9
  %ent = getelementptr inbounds %struct.trace_iterator, %struct.trace_iterator* %iter, i32 0, i32 10
  %0 = load %struct.sock_filter*, %struct.sock_filter** %ent, align 8, !tbaa !506
  %1 = bitcast %struct.sock_filter* %0 to %struct.ftrace_raw_rpc_task_queued*
  %call = call i32 @ftrace_raw_output_prep(%struct.trace_iterator* %iter, %struct.trace_event* %trace_event)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %task = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %1, i32 0, i32 2
  %2 = load %struct.rpc_task*, %struct.rpc_task** %task, align 8, !tbaa !509
  %clnt = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %1, i32 0, i32 1
  %3 = load %struct.rpc_clnt*, %struct.rpc_clnt** %clnt, align 8, !tbaa !512
  %flags1 = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %1, i32 0, i32 6
  %4 = load i16, i16* %flags1, align 4, !tbaa !513
  %conv = zext i16 %4 to i32
  %runstate = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %1, i32 0, i32 4
  %5 = load i64, i64* %runstate, align 8, !tbaa !514
  %status = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %1, i32 0, i32 5
  %6 = load i32, i32* %status, align 8, !tbaa !515
  %timeout = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %1, i32 0, i32 3
  %7 = load i64, i64* %timeout, align 8, !tbaa !516
  %8 = bitcast %struct.ftrace_raw_rpc_task_queued* %1 to i8*
  %__data_loc_q_name = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %1, i32 0, i32 7
  %9 = load i32, i32* %__data_loc_q_name, align 8, !tbaa !517
  %and = and i32 %9, 65535
  %idx.ext = zext i32 %and to i64
  %add.ptr = getelementptr i8, i8* %8, i64 %idx.ext
  %call2 = call i32 (%struct.trace_seq*, i8*, ...) @trace_seq_printf(%struct.trace_seq* %seq, i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.35.353, i32 0, i32 0), %struct.rpc_task* %2, %struct.rpc_clnt* %3, i32 %conv, i64 %5, i32 %6, i64 %7, i8* %add.ptr)
  %tobool3 = icmp ne i32 %call2, 0
  %. = select i1 %tobool3, i32 1, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ %., %if.end ]
  ret i32 %retval.0
}

declare i32 @ftrace_raw_output_prep(%struct.trace_iterator*, %struct.trace_event*) #4

declare i32 @trace_seq_printf(%struct.trace_seq*, i8*, ...) #4

; Function Attrs: nounwind uwtable
define internal void @ftrace_raw_event_rpc_task_queued(i8* %__data, %struct.rpc_clnt* %clnt, %struct.rpc_task* %task, %struct.rpc_wait_queue* %q) #6 {
entry:
  %__data_offsets = alloca %struct.atomic_t, align 4
  %buffer = alloca %struct.ring_buffer*, align 8
  %0 = bitcast i8* %__data to %struct.ftrace_event_file*
  %event_call1 = getelementptr inbounds %struct.ftrace_event_file, %struct.ftrace_event_file* %0, i32 0, i32 1
  %1 = load %struct.ftrace_event_call*, %struct.ftrace_event_call** %event_call1, align 8, !tbaa !518
  %flags = getelementptr inbounds %struct.ftrace_event_file, %struct.ftrace_event_file* %0, i32 0, i32 5
  %2 = load volatile i64, i64* %flags, align 8, !tbaa !88
  %and.i = and i64 8, %2
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %cleanup, label %do.body6

do.body6:                                         ; preds = %entry
  %call7 = call i64 @arch_local_save_flags.306()
  %call10 = call %struct.thread_info* @current_thread_info.305()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call10, i32 0, i32 5
  %3 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %call11 = call i32 @ftrace_get_offsets_rpc_task_queued(%struct.atomic_t* %__data_offsets, %struct.rpc_wait_queue* %q)
  %event12 = getelementptr inbounds %struct.ftrace_event_call, %struct.ftrace_event_call* %1, i32 0, i32 3
  %type = getelementptr inbounds %struct.trace_event, %struct.trace_event* %event12, i32 0, i32 2
  %4 = load i32, i32* %type, align 8, !tbaa !520
  %conv13 = sext i32 %call11 to i64
  %add = add i64 56, %conv13
  %call14 = call %struct.ring_buffer_event* @trace_event_buffer_lock_reserve(%struct.ring_buffer** %buffer, %struct.ftrace_event_file* %0, i32 %4, i64 %add, i64 %call7, i32 %3)
  %tobool15 = icmp ne %struct.ring_buffer_event* %call14, null
  br i1 %tobool15, label %if.end17, label %cleanup

if.end17:                                         ; preds = %do.body6
  %call18 = call i8* @ring_buffer_event_data(%struct.ring_buffer_event* %call14)
  %5 = bitcast i8* %call18 to %struct.ftrace_raw_rpc_task_queued*
  %q_name = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %__data_offsets, i32 0, i32 0
  %6 = load i32, i32* %q_name, align 4, !tbaa !523
  %__data_loc_q_name = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %5, i32 0, i32 7
  store i32 %6, i32* %__data_loc_q_name, align 8, !tbaa !517
  %clnt19 = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %5, i32 0, i32 1
  store %struct.rpc_clnt* %clnt, %struct.rpc_clnt** %clnt19, align 8, !tbaa !512
  %task20 = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %5, i32 0, i32 2
  store %struct.rpc_task* %task, %struct.rpc_task** %task20, align 8, !tbaa !509
  %tk_timeout = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  %7 = load i64, i64* %tk_timeout, align 8, !tbaa !86
  %timeout = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %5, i32 0, i32 3
  store i64 %7, i64* %timeout, align 8, !tbaa !516
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %8 = load i64, i64* %tk_runstate, align 8, !tbaa !525
  %runstate = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %5, i32 0, i32 4
  store i64 %8, i64* %runstate, align 8, !tbaa !514
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %9 = load i32, i32* %tk_status, align 4, !tbaa !59
  %status = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %5, i32 0, i32 5
  store i32 %9, i32* %status, align 8, !tbaa !515
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %10 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %flags21 = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %5, i32 0, i32 6
  store i16 %10, i16* %flags21, align 4, !tbaa !513
  %11 = bitcast %struct.ftrace_raw_rpc_task_queued* %5 to i8*
  %__data_loc_q_name22 = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %5, i32 0, i32 7
  %12 = load i32, i32* %__data_loc_q_name22, align 8, !tbaa !517
  %and = and i32 %12, 65535
  %idx.ext = zext i32 %and to i64
  %add.ptr = getelementptr i8, i8* %11, i64 %idx.ext
  %call23 = call i8* @rpc_qname.317(%struct.rpc_wait_queue* %q)
  %call24 = call i8* @strcpy(i8* %add.ptr, i8* %call23)
  %13 = load %struct.ring_buffer*, %struct.ring_buffer** %buffer, align 8, !tbaa !28
  %14 = bitcast %struct.ftrace_raw_rpc_task_queued* %5 to i8*
  %call25 = call i32 @filter_current_check_discard(%struct.ring_buffer* %13, %struct.ftrace_event_call* %1, i8* %14, %struct.ring_buffer_event* %call14)
  %tobool26 = icmp ne i32 %call25, 0
  br i1 %tobool26, label %cleanup, label %if.then27

if.then27:                                        ; preds = %if.end17
  %15 = load %struct.ring_buffer*, %struct.ring_buffer** %buffer, align 8, !tbaa !28
  call void @trace_buffer_unlock_commit(%struct.ring_buffer* %15, %struct.ring_buffer_event* %call14, i64 %call7, i32 %3)
  br label %cleanup

cleanup:                                          ; preds = %if.then27, %if.end17, %do.body6, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @perf_trace_rpc_task_queued(i8* %__data, %struct.rpc_clnt* %clnt, %struct.rpc_task* %task, %struct.rpc_wait_queue* %q) #6 {
entry:
  %__data_offsets = alloca %struct.atomic_t, align 4
  %__regs = alloca %struct.pt_regs, align 8
  %rctx = alloca i32, align 4
  %0 = bitcast i8* %__data to %struct.ftrace_event_call*
  call void @perf_fetch_caller_regs(%struct.pt_regs* %__regs)
  %call = call i32 @ftrace_get_offsets_rpc_task_queued(%struct.atomic_t* %__data_offsets, %struct.rpc_wait_queue* %q)
  %conv = sext i32 %call to i64
  %add = add i64 %conv, 56
  %add2 = add i64 %add, 4
  %add3 = add i64 %add2, 7
  %and = and i64 %add3, -8
  %conv4 = trunc i64 %and to i32
  %conv5 = sext i32 %conv4 to i64
  %sub = sub i64 %conv5, 4
  %conv6 = trunc i64 %sub to i32
  %cmp = icmp sgt i32 %conv6, 2048
  %lnot = xor i1 %cmp, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot9 = xor i1 %tobool, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool14 = icmp ne i64 %expval, 0
  br i1 %tobool14, label %if.then, label %if.end41

if.then:                                          ; preds = %entry
  %1 = load i8, i8* @perf_trace_rpc_task_queued.__warned, align 1, !tbaa !29, !range !31
  %tobool15 = trunc i8 %1 to i1
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %tobool22 = icmp ne i32 %lnot.ext21, 0
  %lnot23 = xor i1 %tobool22, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %conv27 = sext i32 %lnot.ext26 to i64
  %expval28 = call i64 @llvm.expect.i64(i64 %conv27, i64 0)
  %tobool29 = icmp ne i64 %expval28, 0
  br i1 %tobool29, label %if.then30, label %if.end

if.then30:                                        ; preds = %if.then
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.36.302, i32 0, i32 0), i32 157, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.37.369, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then30, %if.then
  %tobool31 = icmp ne i32 %lnot.ext21, 0
  %lnot32 = xor i1 %tobool31, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  %conv36 = sext i32 %lnot.ext35 to i64
  %expval37 = call i64 @llvm.expect.i64(i64 %conv36, i64 0)
  %tobool38 = icmp ne i64 %expval37, 0
  br i1 %tobool38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %if.end
  store i8 1, i8* @perf_trace_rpc_task_queued.__warned, align 1, !tbaa !29
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %if.end, %entry
  %tobool43 = icmp ne i32 %lnot.ext, 0
  %lnot44 = xor i1 %tobool43, true
  %lnot46 = xor i1 %lnot44, true
  %lnot.ext47 = zext i1 %lnot46 to i32
  %conv48 = sext i32 %lnot.ext47 to i64
  %expval49 = call i64 @llvm.expect.i64(i64 %conv48, i64 0)
  %tobool50 = icmp ne i64 %expval49, 0
  br i1 %tobool50, label %cleanup, label %if.end52

if.end52:                                         ; preds = %if.end41
  %event = getelementptr inbounds %struct.ftrace_event_call, %struct.ftrace_event_call* %0, i32 0, i32 3
  %type = getelementptr inbounds %struct.trace_event, %struct.trace_event* %event, i32 0, i32 2
  %2 = load i32, i32* %type, align 8, !tbaa !520
  %conv53 = trunc i32 %2 to i16
  %call54 = call i8* @perf_trace_buf_prepare(i32 %conv6, i16 zeroext %conv53, %struct.pt_regs* %__regs, i32* %rctx)
  %3 = bitcast i8* %call54 to %struct.ftrace_raw_rpc_task_queued*
  %tobool55 = icmp ne %struct.ftrace_raw_rpc_task_queued* %3, null
  br i1 %tobool55, label %if.end57, label %cleanup

if.end57:                                         ; preds = %if.end52
  %q_name = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %__data_offsets, i32 0, i32 0
  %4 = load i32, i32* %q_name, align 4, !tbaa !523
  %__data_loc_q_name = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %3, i32 0, i32 7
  store i32 %4, i32* %__data_loc_q_name, align 8, !tbaa !517
  %clnt58 = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %3, i32 0, i32 1
  store %struct.rpc_clnt* %clnt, %struct.rpc_clnt** %clnt58, align 8, !tbaa !512
  %task59 = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %3, i32 0, i32 2
  store %struct.rpc_task* %task, %struct.rpc_task** %task59, align 8, !tbaa !509
  %tk_timeout = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 9
  %5 = load i64, i64* %tk_timeout, align 8, !tbaa !86
  %timeout = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %3, i32 0, i32 3
  store i64 %5, i64* %timeout, align 8, !tbaa !516
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %6 = load i64, i64* %tk_runstate, align 8, !tbaa !525
  %runstate = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %3, i32 0, i32 4
  store i64 %6, i64* %runstate, align 8, !tbaa !514
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %7 = load i32, i32* %tk_status, align 4, !tbaa !59
  %status = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %3, i32 0, i32 5
  store i32 %7, i32* %status, align 8, !tbaa !515
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %8 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %flags = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %3, i32 0, i32 6
  store i16 %8, i16* %flags, align 4, !tbaa !513
  %9 = bitcast %struct.ftrace_raw_rpc_task_queued* %3 to i8*
  %__data_loc_q_name60 = getelementptr inbounds %struct.ftrace_raw_rpc_task_queued, %struct.ftrace_raw_rpc_task_queued* %3, i32 0, i32 7
  %10 = load i32, i32* %__data_loc_q_name60, align 8, !tbaa !517
  %and61 = and i32 %10, 65535
  %idx.ext = zext i32 %and61 to i64
  %add.ptr = getelementptr i8, i8* %9, i64 %idx.ext
  %call62 = call i8* @rpc_qname.317(%struct.rpc_wait_queue* %q)
  %call63 = call i8* @strcpy(i8* %add.ptr, i8* %call62)
  %perf_events = getelementptr inbounds %struct.ftrace_event_call, %struct.ftrace_event_call* %0, i32 0, i32 11
  %11 = load %struct.hlist_head*, %struct.hlist_head** %perf_events, align 8, !tbaa !526
  %12 = call i64 asm sideeffect "add %gs:${1:P}, $0", "=r,*m,0,~{dirflag},~{fpsr},~{flags}"(i64* @this_cpu_off, %struct.hlist_head* %11) #7, !srcloc !527
  %13 = inttoptr i64 %12 to %struct.hlist_head*
  %14 = bitcast %struct.ftrace_raw_rpc_task_queued* %3 to i8*
  %15 = load i32, i32* %rctx, align 4, !tbaa !49
  %16 = bitcast %struct.hlist_head* %13 to i8*
  call void @perf_trace_buf_submit(i8* %14, i32 %conv6, i32 %15, i64 0, i64 1, %struct.pt_regs* %__regs, i8* %16, %struct.task_struct* null)
  br label %cleanup

cleanup:                                          ; preds = %if.end57, %if.end52, %if.end41
  ret void
}

declare i32 @ftrace_event_reg(%struct.ftrace_event_call*, i32, i8*) #4

; Function Attrs: nounwind uwtable
define internal i32 @ftrace_define_fields_rpc_task_queued(%struct.ftrace_event_call* %event_call) #6 section ".init.text" {
entry:
  %call = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.20.356, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.21.357, i32 0, i32 0), i32 8, i32 8, i32 zext (i1 icmp ult (%struct.rpc_clnt* inttoptr (i64 -1 to %struct.rpc_clnt*), %struct.rpc_clnt* inttoptr (i64 1 to %struct.rpc_clnt*)) to i32), i32 0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.18.358, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19.359, i32 0, i32 0), i32 16, i32 8, i32 zext (i1 icmp ult (%struct.rpc_task* inttoptr (i64 -1 to %struct.rpc_task*), %struct.rpc_task* inttoptr (i64 1 to %struct.rpc_task*)) to i32), i32 0)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.27.360, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.32.361, i32 0, i32 0), i32 24, i32 8, i32 0, i32 0)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end4
  %call9 = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.27.360, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.28.362, i32 0, i32 0), i32 32, i32 8, i32 0, i32 0)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %cleanup, label %if.end12

if.end12:                                         ; preds = %if.end8
  %call13 = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.22.363, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.23.364, i32 0, i32 0), i32 40, i32 4, i32 1, i32 0)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %cleanup, label %if.end16

if.end16:                                         ; preds = %if.end12
  %call17 = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.29.365, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.30.366, i32 0, i32 0), i32 44, i32 2, i32 0, i32 0)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %cleanup, label %if.end20

if.end20:                                         ; preds = %if.end16
  %call21 = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.33.367, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.34.368, i32 0, i32 0), i32 48, i32 4, i32 1, i32 0)
  br label %cleanup

cleanup:                                          ; preds = %if.end20, %if.end16, %if.end12, %if.end8, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call21, %if.end20 ], [ %call, %entry ], [ %call1, %if.end ], [ %call5, %if.end4 ], [ %call9, %if.end8 ], [ %call13, %if.end12 ], [ %call17, %if.end16 ]
  ret i32 %retval.0
}

declare i32 @trace_event_raw_init(%struct.ftrace_event_call*) #4

declare i32 @trace_define_field(%struct.ftrace_event_call*, i8*, i8*, i32, i32, i32, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @perf_fetch_caller_regs(%struct.pt_regs* %regs) #2 {
entry:
  %0 = bitcast %struct.pt_regs* %regs to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 168, i32 8, i1 false)
  %1 = call i8* @llvm.returnaddress(i32 0)
  %2 = ptrtoint i8* %1 to i64
  %ip = getelementptr inbounds %struct.pt_regs, %struct.pt_regs* %regs, i32 0, i32 16
  store i64 %2, i64* %ip, align 8, !tbaa !528
  %call = call i64 @caller_frame_pointer()
  %bp = getelementptr inbounds %struct.pt_regs, %struct.pt_regs* %regs, i32 0, i32 4
  store i64 %call, i64* %bp, align 8, !tbaa !530
  %cs = getelementptr inbounds %struct.pt_regs, %struct.pt_regs* %regs, i32 0, i32 17
  store i64 16, i64* %cs, align 8, !tbaa !531
  %flags = getelementptr inbounds %struct.pt_regs, %struct.pt_regs* %regs, i32 0, i32 18
  store i64 0, i64* %flags, align 8, !tbaa !532
  %sp = getelementptr inbounds %struct.pt_regs, %struct.pt_regs* %regs, i32 0, i32 19
  call void asm sideeffect " movq % rsp , $0\0A", "=*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %sp) #7, !srcloc !533
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @ftrace_get_offsets_rpc_task_queued(%struct.atomic_t* %__data_offsets, %struct.rpc_wait_queue* %q) #2 {
entry:
  %conv = sext i32 0 to i64
  %add = add i64 %conv, 52
  %conv2 = trunc i64 %add to i32
  %q_name = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %__data_offsets, i32 0, i32 0
  store i32 %conv2, i32* %q_name, align 4, !tbaa !523
  %call = call i8* @rpc_qname.317(%struct.rpc_wait_queue* %q)
  %call3 = call i64 @strlen(i8* %call)
  %add4 = add i64 %call3, 1
  %shl = shl i64 %add4, 16
  %q_name5 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %__data_offsets, i32 0, i32 0
  %0 = load i32, i32* %q_name5, align 4, !tbaa !523
  %conv6 = zext i32 %0 to i64
  %or = or i64 %conv6, %shl
  %conv7 = trunc i64 %or to i32
  store i32 %conv7, i32* %q_name5, align 4, !tbaa !523
  %call8 = call i8* @rpc_qname.317(%struct.rpc_wait_queue* %q)
  %call9 = call i64 @strlen(i8* %call8)
  %add10 = add i64 %call9, 1
  %mul = mul i64 %add10, 1
  %conv11 = sext i32 0 to i64
  %add12 = add i64 %conv11, %mul
  %conv13 = trunc i64 %add12 to i32
  ret i32 %conv13
}

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #4

declare i8* @perf_trace_buf_prepare(i32, i16 zeroext, %struct.pt_regs*, i32*) #4

declare i8* @strcpy(i8*, i8*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @perf_trace_buf_submit(i8* %raw_data, i32 %size, i32 %rctx, i64 %addr, i64 %count, %struct.pt_regs* %regs, i8* %head, %struct.task_struct* %task) #2 {
entry:
  %0 = bitcast i8* %head to %struct.hlist_head*
  call void @perf_tp_event(i64 %addr, i64 %count, i8* %raw_data, i32 %size, %struct.pt_regs* %regs, %struct.hlist_head* %0, i32 %rctx, %struct.task_struct* %task)
  ret void
}

declare void @perf_tp_event(i64, i64, i8*, i32, %struct.pt_regs*, %struct.hlist_head*, i32, %struct.task_struct*) #4

; Function Attrs: nounwind readnone
declare i8* @llvm.returnaddress(i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @caller_frame_pointer() #2 {
entry:
  %0 = call %struct.stack_frame* asm "movq %rbp, $0", "=r,~{dirflag},~{fpsr},~{flags}"() #3, !srcloc !534
  %next_frame = getelementptr inbounds %struct.stack_frame, %struct.stack_frame* %0, i32 0, i32 0
  %1 = load %struct.stack_frame*, %struct.stack_frame** %next_frame, align 8, !tbaa !535
  %2 = ptrtoint %struct.stack_frame* %1 to i64
  ret i64 %2
}

declare %struct.ring_buffer_event* @trace_event_buffer_lock_reserve(%struct.ring_buffer**, %struct.ftrace_event_file*, i32, i64, i64, i32) #4

declare i8* @ring_buffer_event_data(%struct.ring_buffer_event*) #4

declare i32 @filter_current_check_discard(%struct.ring_buffer*, %struct.ftrace_event_call*, i8*, %struct.ring_buffer_event*) #4

declare void @trace_buffer_unlock_commit(%struct.ring_buffer*, %struct.ring_buffer_event*, i64, i32) #4

; Function Attrs: nounwind uwtable
define internal i32 @ftrace_raw_output_rpc_task_running(%struct.trace_iterator* %iter, i32 %flags, %struct.trace_event* %trace_event) #6 {
entry:
  %seq = getelementptr inbounds %struct.trace_iterator, %struct.trace_iterator* %iter, i32 0, i32 9
  %ent = getelementptr inbounds %struct.trace_iterator, %struct.trace_iterator* %iter, i32 0, i32 10
  %0 = load %struct.sock_filter*, %struct.sock_filter** %ent, align 8, !tbaa !506
  %1 = bitcast %struct.sock_filter* %0 to %struct.ftrace_raw_rpc_task_running*
  %call = call i32 @ftrace_raw_output_prep(%struct.trace_iterator* %iter, %struct.trace_event* %trace_event)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %task = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %1, i32 0, i32 2
  %2 = load %struct.rpc_task*, %struct.rpc_task** %task, align 8, !tbaa !537
  %clnt = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %1, i32 0, i32 1
  %3 = load %struct.rpc_clnt*, %struct.rpc_clnt** %clnt, align 8, !tbaa !539
  %flags1 = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %1, i32 0, i32 6
  %4 = load i16, i16* %flags1, align 4, !tbaa !540
  %conv = zext i16 %4 to i32
  %runstate = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %1, i32 0, i32 4
  %5 = load i64, i64* %runstate, align 8, !tbaa !541
  %status = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %1, i32 0, i32 5
  %6 = load i32, i32* %status, align 8, !tbaa !542
  %action = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %1, i32 0, i32 3
  %7 = load i8*, i8** %action, align 8, !tbaa !543
  %call2 = call i32 (%struct.trace_seq*, i8*, ...) @trace_seq_printf(%struct.trace_seq* %seq, i8* getelementptr inbounds ([58 x i8], [58 x i8]* @.str.31.371, i32 0, i32 0), %struct.rpc_task* %2, %struct.rpc_clnt* %3, i32 %conv, i64 %5, i32 %6, i8* %7)
  %tobool3 = icmp ne i32 %call2, 0
  %. = select i1 %tobool3, i32 1, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @ftrace_raw_event_rpc_task_running(i8* %__data, %struct.rpc_clnt* %clnt, %struct.rpc_task* %task, i8* %action) #6 {
entry:
  %buffer = alloca %struct.ring_buffer*, align 8
  %0 = bitcast i8* %__data to %struct.ftrace_event_file*
  %event_call1 = getelementptr inbounds %struct.ftrace_event_file, %struct.ftrace_event_file* %0, i32 0, i32 1
  %1 = load %struct.ftrace_event_call*, %struct.ftrace_event_call** %event_call1, align 8, !tbaa !518
  %flags = getelementptr inbounds %struct.ftrace_event_file, %struct.ftrace_event_file* %0, i32 0, i32 5
  %2 = load volatile i64, i64* %flags, align 8, !tbaa !88
  %and.i = and i64 8, %2
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %cleanup, label %do.body6

do.body6:                                         ; preds = %entry
  %call7 = call i64 @arch_local_save_flags.306()
  %call10 = call %struct.thread_info* @current_thread_info.305()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call10, i32 0, i32 5
  %3 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %call11 = call i32 @ftrace_get_offsets_rpc_task_running()
  %event12 = getelementptr inbounds %struct.ftrace_event_call, %struct.ftrace_event_call* %1, i32 0, i32 3
  %type = getelementptr inbounds %struct.trace_event, %struct.trace_event* %event12, i32 0, i32 2
  %4 = load i32, i32* %type, align 8, !tbaa !520
  %conv13 = sext i32 %call11 to i64
  %add = add i64 48, %conv13
  %call14 = call %struct.ring_buffer_event* @trace_event_buffer_lock_reserve(%struct.ring_buffer** %buffer, %struct.ftrace_event_file* %0, i32 %4, i64 %add, i64 %call7, i32 %3)
  %tobool15 = icmp ne %struct.ring_buffer_event* %call14, null
  br i1 %tobool15, label %if.end17, label %cleanup

if.end17:                                         ; preds = %do.body6
  %call18 = call i8* @ring_buffer_event_data(%struct.ring_buffer_event* %call14)
  %5 = bitcast i8* %call18 to %struct.ftrace_raw_rpc_task_running*
  %clnt19 = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %5, i32 0, i32 1
  store %struct.rpc_clnt* %clnt, %struct.rpc_clnt** %clnt19, align 8, !tbaa !539
  %task20 = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %5, i32 0, i32 2
  store %struct.rpc_task* %task, %struct.rpc_task** %task20, align 8, !tbaa !537
  %action21 = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %5, i32 0, i32 3
  store i8* %action, i8** %action21, align 8, !tbaa !543
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %6 = load i64, i64* %tk_runstate, align 8, !tbaa !525
  %runstate = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %5, i32 0, i32 4
  store i64 %6, i64* %runstate, align 8, !tbaa !541
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %7 = load i32, i32* %tk_status, align 4, !tbaa !59
  %status = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %5, i32 0, i32 5
  store i32 %7, i32* %status, align 8, !tbaa !542
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %8 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %flags22 = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %5, i32 0, i32 6
  store i16 %8, i16* %flags22, align 4, !tbaa !540
  %9 = load %struct.ring_buffer*, %struct.ring_buffer** %buffer, align 8, !tbaa !28
  %10 = bitcast %struct.ftrace_raw_rpc_task_running* %5 to i8*
  %call23 = call i32 @filter_current_check_discard(%struct.ring_buffer* %9, %struct.ftrace_event_call* %1, i8* %10, %struct.ring_buffer_event* %call14)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %cleanup, label %if.then25

if.then25:                                        ; preds = %if.end17
  %11 = load %struct.ring_buffer*, %struct.ring_buffer** %buffer, align 8, !tbaa !28
  call void @trace_buffer_unlock_commit(%struct.ring_buffer* %11, %struct.ring_buffer_event* %call14, i64 %call7, i32 %3)
  br label %cleanup

cleanup:                                          ; preds = %if.then25, %if.end17, %do.body6, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @perf_trace_rpc_task_running(i8* %__data, %struct.rpc_clnt* %clnt, %struct.rpc_task* %task, i8* %action) #6 {
entry:
  %__regs = alloca %struct.pt_regs, align 8
  %rctx = alloca i32, align 4
  %0 = bitcast i8* %__data to %struct.ftrace_event_call*
  call void @perf_fetch_caller_regs(%struct.pt_regs* %__regs)
  %call = call i32 @ftrace_get_offsets_rpc_task_running()
  %conv = sext i32 %call to i64
  %add = add i64 %conv, 48
  %add2 = add i64 %add, 4
  %add3 = add i64 %add2, 7
  %and = and i64 %add3, -8
  %conv4 = trunc i64 %and to i32
  %conv5 = sext i32 %conv4 to i64
  %sub = sub i64 %conv5, 4
  %conv6 = trunc i64 %sub to i32
  %cmp = icmp sgt i32 %conv6, 2048
  %lnot = xor i1 %cmp, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot9 = xor i1 %tobool, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool14 = icmp ne i64 %expval, 0
  br i1 %tobool14, label %if.then, label %if.end41

if.then:                                          ; preds = %entry
  %1 = load i8, i8* @perf_trace_rpc_task_running.__warned, align 1, !tbaa !29, !range !31
  %tobool15 = trunc i8 %1 to i1
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %tobool22 = icmp ne i32 %lnot.ext21, 0
  %lnot23 = xor i1 %tobool22, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %conv27 = sext i32 %lnot.ext26 to i64
  %expval28 = call i64 @llvm.expect.i64(i64 %conv27, i64 0)
  %tobool29 = icmp ne i64 %expval28, 0
  br i1 %tobool29, label %if.then30, label %if.end

if.then30:                                        ; preds = %if.then
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.36.302, i32 0, i32 0), i32 96, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.37.369, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then30, %if.then
  %tobool31 = icmp ne i32 %lnot.ext21, 0
  %lnot32 = xor i1 %tobool31, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  %conv36 = sext i32 %lnot.ext35 to i64
  %expval37 = call i64 @llvm.expect.i64(i64 %conv36, i64 0)
  %tobool38 = icmp ne i64 %expval37, 0
  br i1 %tobool38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %if.end
  store i8 1, i8* @perf_trace_rpc_task_running.__warned, align 1, !tbaa !29
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %if.end, %entry
  %tobool43 = icmp ne i32 %lnot.ext, 0
  %lnot44 = xor i1 %tobool43, true
  %lnot46 = xor i1 %lnot44, true
  %lnot.ext47 = zext i1 %lnot46 to i32
  %conv48 = sext i32 %lnot.ext47 to i64
  %expval49 = call i64 @llvm.expect.i64(i64 %conv48, i64 0)
  %tobool50 = icmp ne i64 %expval49, 0
  br i1 %tobool50, label %cleanup, label %if.end52

if.end52:                                         ; preds = %if.end41
  %event = getelementptr inbounds %struct.ftrace_event_call, %struct.ftrace_event_call* %0, i32 0, i32 3
  %type = getelementptr inbounds %struct.trace_event, %struct.trace_event* %event, i32 0, i32 2
  %2 = load i32, i32* %type, align 8, !tbaa !520
  %conv53 = trunc i32 %2 to i16
  %call54 = call i8* @perf_trace_buf_prepare(i32 %conv6, i16 zeroext %conv53, %struct.pt_regs* %__regs, i32* %rctx)
  %3 = bitcast i8* %call54 to %struct.ftrace_raw_rpc_task_running*
  %tobool55 = icmp ne %struct.ftrace_raw_rpc_task_running* %3, null
  br i1 %tobool55, label %if.end57, label %cleanup

if.end57:                                         ; preds = %if.end52
  %clnt58 = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %3, i32 0, i32 1
  store %struct.rpc_clnt* %clnt, %struct.rpc_clnt** %clnt58, align 8, !tbaa !539
  %task59 = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %3, i32 0, i32 2
  store %struct.rpc_task* %task, %struct.rpc_task** %task59, align 8, !tbaa !537
  %action60 = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %3, i32 0, i32 3
  store i8* %action, i8** %action60, align 8, !tbaa !543
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  %4 = load i64, i64* %tk_runstate, align 8, !tbaa !525
  %runstate = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %3, i32 0, i32 4
  store i64 %4, i64* %runstate, align 8, !tbaa !541
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %5 = load i32, i32* %tk_status, align 4, !tbaa !59
  %status = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %3, i32 0, i32 5
  store i32 %5, i32* %status, align 8, !tbaa !542
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %6 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %flags = getelementptr inbounds %struct.ftrace_raw_rpc_task_running, %struct.ftrace_raw_rpc_task_running* %3, i32 0, i32 6
  store i16 %6, i16* %flags, align 4, !tbaa !540
  %perf_events = getelementptr inbounds %struct.ftrace_event_call, %struct.ftrace_event_call* %0, i32 0, i32 11
  %7 = load %struct.hlist_head*, %struct.hlist_head** %perf_events, align 8, !tbaa !526
  %8 = call i64 asm sideeffect "add %gs:${1:P}, $0", "=r,*m,0,~{dirflag},~{fpsr},~{flags}"(i64* @this_cpu_off, %struct.hlist_head* %7) #7, !srcloc !544
  %9 = inttoptr i64 %8 to %struct.hlist_head*
  %10 = bitcast %struct.ftrace_raw_rpc_task_running* %3 to i8*
  %11 = load i32, i32* %rctx, align 4, !tbaa !49
  %12 = bitcast %struct.hlist_head* %9 to i8*
  call void @perf_trace_buf_submit(i8* %10, i32 %conv6, i32 %11, i64 0, i64 1, %struct.pt_regs* %__regs, i8* %12, %struct.task_struct* null)
  br label %cleanup

cleanup:                                          ; preds = %if.end57, %if.end52, %if.end41
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ftrace_define_fields_rpc_task_running(%struct.ftrace_event_call* %event_call) #6 section ".init.text" {
entry:
  %call = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.20.356, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.21.357, i32 0, i32 0), i32 8, i32 8, i32 zext (i1 icmp ult (%struct.rpc_clnt* inttoptr (i64 -1 to %struct.rpc_clnt*), %struct.rpc_clnt* inttoptr (i64 1 to %struct.rpc_clnt*)) to i32), i32 0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.18.358, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19.359, i32 0, i32 0), i32 16, i32 8, i32 zext (i1 icmp ult (%struct.rpc_task* inttoptr (i64 -1 to %struct.rpc_task*), %struct.rpc_task* inttoptr (i64 1 to %struct.rpc_task*)) to i32), i32 0)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.25.374, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.26.375, i32 0, i32 0), i32 24, i32 8, i32 zext (i1 icmp ult (i8* inttoptr (i64 -1 to i8*), i8* inttoptr (i64 1 to i8*)) to i32), i32 0)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end4
  %call9 = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.27.360, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.28.362, i32 0, i32 0), i32 32, i32 8, i32 0, i32 0)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %cleanup, label %if.end12

if.end12:                                         ; preds = %if.end8
  %call13 = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.22.363, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.23.364, i32 0, i32 0), i32 40, i32 4, i32 1, i32 0)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %cleanup, label %if.end16

if.end16:                                         ; preds = %if.end12
  %call17 = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.29.365, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.30.366, i32 0, i32 0), i32 44, i32 2, i32 0, i32 0)
  br label %cleanup

cleanup:                                          ; preds = %if.end16, %if.end12, %if.end8, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ %call1, %if.end ], [ %call5, %if.end4 ], [ %call9, %if.end8 ], [ %call13, %if.end12 ], [ %call17, %if.end16 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @ftrace_get_offsets_rpc_task_running() #2 {
entry:
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @ftrace_raw_output_rpc_connect_status(%struct.trace_iterator* %iter, i32 %flags, %struct.trace_event* %trace_event) #6 {
entry:
  %seq = getelementptr inbounds %struct.trace_iterator, %struct.trace_iterator* %iter, i32 0, i32 9
  %ent = getelementptr inbounds %struct.trace_iterator, %struct.trace_iterator* %iter, i32 0, i32 10
  %0 = load %struct.sock_filter*, %struct.sock_filter** %ent, align 8, !tbaa !506
  %1 = bitcast %struct.sock_filter* %0 to %struct.ftrace_raw_rpc_connect_status*
  %call = call i32 @ftrace_raw_output_prep(%struct.trace_iterator* %iter, %struct.trace_event* %trace_event)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %task = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %1, i32 0, i32 1
  %2 = load %struct.rpc_task*, %struct.rpc_task** %task, align 8, !tbaa !545
  %clnt = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %1, i32 0, i32 2
  %3 = load %struct.rpc_clnt*, %struct.rpc_clnt** %clnt, align 8, !tbaa !547
  %status = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %1, i32 0, i32 3
  %4 = load i32, i32* %status, align 8, !tbaa !548
  %call1 = call i32 (%struct.trace_seq*, i8*, ...) @trace_seq_printf(%struct.trace_seq* %seq, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.24.377, i32 0, i32 0), %struct.rpc_task* %2, %struct.rpc_clnt* %3, i32 %4)
  %tobool2 = icmp ne i32 %call1, 0
  %. = select i1 %tobool2, i32 1, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @ftrace_raw_event_rpc_connect_status(i8* %__data, %struct.rpc_task* %task, i32 %status) #6 {
entry:
  %buffer = alloca %struct.ring_buffer*, align 8
  %0 = bitcast i8* %__data to %struct.ftrace_event_file*
  %event_call1 = getelementptr inbounds %struct.ftrace_event_file, %struct.ftrace_event_file* %0, i32 0, i32 1
  %1 = load %struct.ftrace_event_call*, %struct.ftrace_event_call** %event_call1, align 8, !tbaa !518
  %flags = getelementptr inbounds %struct.ftrace_event_file, %struct.ftrace_event_file* %0, i32 0, i32 5
  %2 = load volatile i64, i64* %flags, align 8, !tbaa !88
  %and.i = and i64 8, %2
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %cleanup, label %do.body6

do.body6:                                         ; preds = %entry
  %call7 = call i64 @arch_local_save_flags.306()
  %call10 = call %struct.thread_info* @current_thread_info.305()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call10, i32 0, i32 5
  %3 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %call11 = call i32 @ftrace_get_offsets_rpc_connect_status()
  %event12 = getelementptr inbounds %struct.ftrace_event_call, %struct.ftrace_event_call* %1, i32 0, i32 3
  %type = getelementptr inbounds %struct.trace_event, %struct.trace_event* %event12, i32 0, i32 2
  %4 = load i32, i32* %type, align 8, !tbaa !520
  %conv13 = sext i32 %call11 to i64
  %add = add i64 32, %conv13
  %call14 = call %struct.ring_buffer_event* @trace_event_buffer_lock_reserve(%struct.ring_buffer** %buffer, %struct.ftrace_event_file* %0, i32 %4, i64 %add, i64 %call7, i32 %3)
  %tobool15 = icmp ne %struct.ring_buffer_event* %call14, null
  br i1 %tobool15, label %if.end17, label %cleanup

if.end17:                                         ; preds = %do.body6
  %call18 = call i8* @ring_buffer_event_data(%struct.ring_buffer_event* %call14)
  %5 = bitcast i8* %call18 to %struct.ftrace_raw_rpc_connect_status*
  %task19 = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %5, i32 0, i32 1
  store %struct.rpc_task* %task, %struct.rpc_task** %task19, align 8, !tbaa !545
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %6 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %clnt = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %5, i32 0, i32 2
  store %struct.rpc_clnt* %6, %struct.rpc_clnt** %clnt, align 8, !tbaa !547
  %status20 = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %5, i32 0, i32 3
  store i32 %status, i32* %status20, align 8, !tbaa !548
  %7 = load %struct.ring_buffer*, %struct.ring_buffer** %buffer, align 8, !tbaa !28
  %8 = bitcast %struct.ftrace_raw_rpc_connect_status* %5 to i8*
  %call21 = call i32 @filter_current_check_discard(%struct.ring_buffer* %7, %struct.ftrace_event_call* %1, i8* %8, %struct.ring_buffer_event* %call14)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %cleanup, label %if.then23

if.then23:                                        ; preds = %if.end17
  %9 = load %struct.ring_buffer*, %struct.ring_buffer** %buffer, align 8, !tbaa !28
  call void @trace_buffer_unlock_commit(%struct.ring_buffer* %9, %struct.ring_buffer_event* %call14, i64 %call7, i32 %3)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %if.end17, %do.body6, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @perf_trace_rpc_connect_status(i8* %__data, %struct.rpc_task* %task, i32 %status) #6 {
entry:
  %__regs = alloca %struct.pt_regs, align 8
  %rctx = alloca i32, align 4
  %0 = bitcast i8* %__data to %struct.ftrace_event_call*
  call void @perf_fetch_caller_regs(%struct.pt_regs* %__regs)
  %call = call i32 @ftrace_get_offsets_rpc_connect_status()
  %conv = sext i32 %call to i64
  %add = add i64 %conv, 32
  %add2 = add i64 %add, 4
  %add3 = add i64 %add2, 7
  %and = and i64 %add3, -8
  %conv4 = trunc i64 %and to i32
  %conv5 = sext i32 %conv4 to i64
  %sub = sub i64 %conv5, 4
  %conv6 = trunc i64 %sub to i32
  %cmp = icmp sgt i32 %conv6, 2048
  %lnot = xor i1 %cmp, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot9 = xor i1 %tobool, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool14 = icmp ne i64 %expval, 0
  br i1 %tobool14, label %if.then, label %if.end41

if.then:                                          ; preds = %entry
  %1 = load i8, i8* @perf_trace_rpc_connect_status.__warned, align 1, !tbaa !29, !range !31
  %tobool15 = trunc i8 %1 to i1
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %tobool22 = icmp ne i32 %lnot.ext21, 0
  %lnot23 = xor i1 %tobool22, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %conv27 = sext i32 %lnot.ext26 to i64
  %expval28 = call i64 @llvm.expect.i64(i64 %conv27, i64 0)
  %tobool29 = icmp ne i64 %expval28, 0
  br i1 %tobool29, label %if.then30, label %if.end

if.then30:                                        ; preds = %if.then
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.36.302, i32 0, i32 0), i32 62, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.37.369, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then30, %if.then
  %tobool31 = icmp ne i32 %lnot.ext21, 0
  %lnot32 = xor i1 %tobool31, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  %conv36 = sext i32 %lnot.ext35 to i64
  %expval37 = call i64 @llvm.expect.i64(i64 %conv36, i64 0)
  %tobool38 = icmp ne i64 %expval37, 0
  br i1 %tobool38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %if.end
  store i8 1, i8* @perf_trace_rpc_connect_status.__warned, align 1, !tbaa !29
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %if.end, %entry
  %tobool43 = icmp ne i32 %lnot.ext, 0
  %lnot44 = xor i1 %tobool43, true
  %lnot46 = xor i1 %lnot44, true
  %lnot.ext47 = zext i1 %lnot46 to i32
  %conv48 = sext i32 %lnot.ext47 to i64
  %expval49 = call i64 @llvm.expect.i64(i64 %conv48, i64 0)
  %tobool50 = icmp ne i64 %expval49, 0
  br i1 %tobool50, label %cleanup, label %if.end52

if.end52:                                         ; preds = %if.end41
  %event = getelementptr inbounds %struct.ftrace_event_call, %struct.ftrace_event_call* %0, i32 0, i32 3
  %type = getelementptr inbounds %struct.trace_event, %struct.trace_event* %event, i32 0, i32 2
  %2 = load i32, i32* %type, align 8, !tbaa !520
  %conv53 = trunc i32 %2 to i16
  %call54 = call i8* @perf_trace_buf_prepare(i32 %conv6, i16 zeroext %conv53, %struct.pt_regs* %__regs, i32* %rctx)
  %3 = bitcast i8* %call54 to %struct.ftrace_raw_rpc_connect_status*
  %tobool55 = icmp ne %struct.ftrace_raw_rpc_connect_status* %3, null
  br i1 %tobool55, label %if.end57, label %cleanup

if.end57:                                         ; preds = %if.end52
  %task58 = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %3, i32 0, i32 1
  store %struct.rpc_task* %task, %struct.rpc_task** %task58, align 8, !tbaa !545
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %4 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %clnt = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %3, i32 0, i32 2
  store %struct.rpc_clnt* %4, %struct.rpc_clnt** %clnt, align 8, !tbaa !547
  %status59 = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %3, i32 0, i32 3
  store i32 %status, i32* %status59, align 8, !tbaa !548
  %perf_events = getelementptr inbounds %struct.ftrace_event_call, %struct.ftrace_event_call* %0, i32 0, i32 11
  %5 = load %struct.hlist_head*, %struct.hlist_head** %perf_events, align 8, !tbaa !526
  %6 = call i64 asm sideeffect "add %gs:${1:P}, $0", "=r,*m,0,~{dirflag},~{fpsr},~{flags}"(i64* @this_cpu_off, %struct.hlist_head* %5) #7, !srcloc !549
  %7 = inttoptr i64 %6 to %struct.hlist_head*
  %8 = bitcast %struct.ftrace_raw_rpc_connect_status* %3 to i8*
  %9 = load i32, i32* %rctx, align 4, !tbaa !49
  %10 = bitcast %struct.hlist_head* %7 to i8*
  call void @perf_trace_buf_submit(i8* %8, i32 %conv6, i32 %9, i64 0, i64 1, %struct.pt_regs* %__regs, i8* %10, %struct.task_struct* null)
  br label %cleanup

cleanup:                                          ; preds = %if.end57, %if.end52, %if.end41
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ftrace_define_fields_rpc_connect_status(%struct.ftrace_event_call* %event_call) #6 section ".init.text" {
entry:
  %call = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.18.358, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19.359, i32 0, i32 0), i32 8, i32 8, i32 zext (i1 icmp ult (%struct.rpc_task* inttoptr (i64 -1 to %struct.rpc_task*), %struct.rpc_task* inttoptr (i64 1 to %struct.rpc_task*)) to i32), i32 0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.20.356, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.21.357, i32 0, i32 0), i32 16, i32 8, i32 zext (i1 icmp ult (%struct.rpc_clnt* inttoptr (i64 -1 to %struct.rpc_clnt*), %struct.rpc_clnt* inttoptr (i64 1 to %struct.rpc_clnt*)) to i32), i32 0)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.22.363, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.23.364, i32 0, i32 0), i32 24, i32 4, i32 1, i32 0)
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ %call1, %if.end ], [ %call5, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @ftrace_get_offsets_rpc_connect_status() #2 {
entry:
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @ftrace_raw_output_rpc_task_status(%struct.trace_iterator* %iter, i32 %flags, %struct.trace_event* %trace_event) #6 {
entry:
  %seq = getelementptr inbounds %struct.trace_iterator, %struct.trace_iterator* %iter, i32 0, i32 9
  %ent = getelementptr inbounds %struct.trace_iterator, %struct.trace_iterator* %iter, i32 0, i32 10
  %0 = load %struct.sock_filter*, %struct.sock_filter** %ent, align 8, !tbaa !506
  %1 = bitcast %struct.sock_filter* %0 to %struct.ftrace_raw_rpc_connect_status*
  %call = call i32 @ftrace_raw_output_prep(%struct.trace_iterator* %iter, %struct.trace_event* %trace_event)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %task = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %1, i32 0, i32 1
  %2 = load %struct.rpc_task*, %struct.rpc_task** %task, align 8, !tbaa !550
  %clnt = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %1, i32 0, i32 2
  %3 = load %struct.rpc_clnt*, %struct.rpc_clnt** %clnt, align 8, !tbaa !552
  %status = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %1, i32 0, i32 3
  %4 = load i32, i32* %status, align 8, !tbaa !553
  %call1 = call i32 (%struct.trace_seq*, i8*, ...) @trace_seq_printf(%struct.trace_seq* %seq, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.24.377, i32 0, i32 0), %struct.rpc_task* %2, %struct.rpc_clnt* %3, i32 %4)
  %tobool2 = icmp ne i32 %call1, 0
  %. = select i1 %tobool2, i32 1, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @ftrace_raw_event_rpc_task_status(i8* %__data, %struct.rpc_task* %task) #6 {
entry:
  %buffer = alloca %struct.ring_buffer*, align 8
  %0 = bitcast i8* %__data to %struct.ftrace_event_file*
  %event_call1 = getelementptr inbounds %struct.ftrace_event_file, %struct.ftrace_event_file* %0, i32 0, i32 1
  %1 = load %struct.ftrace_event_call*, %struct.ftrace_event_call** %event_call1, align 8, !tbaa !518
  %flags = getelementptr inbounds %struct.ftrace_event_file, %struct.ftrace_event_file* %0, i32 0, i32 5
  %2 = load volatile i64, i64* %flags, align 8, !tbaa !88
  %and.i = and i64 8, %2
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %cleanup, label %do.body6

do.body6:                                         ; preds = %entry
  %call7 = call i64 @arch_local_save_flags.306()
  %call10 = call %struct.thread_info* @current_thread_info.305()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call10, i32 0, i32 5
  %3 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %call11 = call i32 @ftrace_get_offsets_rpc_task_status()
  %event12 = getelementptr inbounds %struct.ftrace_event_call, %struct.ftrace_event_call* %1, i32 0, i32 3
  %type = getelementptr inbounds %struct.trace_event, %struct.trace_event* %event12, i32 0, i32 2
  %4 = load i32, i32* %type, align 8, !tbaa !520
  %conv13 = sext i32 %call11 to i64
  %add = add i64 32, %conv13
  %call14 = call %struct.ring_buffer_event* @trace_event_buffer_lock_reserve(%struct.ring_buffer** %buffer, %struct.ftrace_event_file* %0, i32 %4, i64 %add, i64 %call7, i32 %3)
  %tobool15 = icmp ne %struct.ring_buffer_event* %call14, null
  br i1 %tobool15, label %if.end17, label %cleanup

if.end17:                                         ; preds = %do.body6
  %call18 = call i8* @ring_buffer_event_data(%struct.ring_buffer_event* %call14)
  %5 = bitcast i8* %call18 to %struct.ftrace_raw_rpc_connect_status*
  %task19 = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %5, i32 0, i32 1
  store %struct.rpc_task* %task, %struct.rpc_task** %task19, align 8, !tbaa !550
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %6 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %clnt = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %5, i32 0, i32 2
  store %struct.rpc_clnt* %6, %struct.rpc_clnt** %clnt, align 8, !tbaa !552
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %7 = load i32, i32* %tk_status, align 4, !tbaa !59
  %status = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %5, i32 0, i32 3
  store i32 %7, i32* %status, align 8, !tbaa !553
  %8 = load %struct.ring_buffer*, %struct.ring_buffer** %buffer, align 8, !tbaa !28
  %9 = bitcast %struct.ftrace_raw_rpc_connect_status* %5 to i8*
  %call20 = call i32 @filter_current_check_discard(%struct.ring_buffer* %8, %struct.ftrace_event_call* %1, i8* %9, %struct.ring_buffer_event* %call14)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %cleanup, label %if.then22

if.then22:                                        ; preds = %if.end17
  %10 = load %struct.ring_buffer*, %struct.ring_buffer** %buffer, align 8, !tbaa !28
  call void @trace_buffer_unlock_commit(%struct.ring_buffer* %10, %struct.ring_buffer_event* %call14, i64 %call7, i32 %3)
  br label %cleanup

cleanup:                                          ; preds = %if.then22, %if.end17, %do.body6, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @perf_trace_rpc_task_status(i8* %__data, %struct.rpc_task* %task) #6 {
entry:
  %__regs = alloca %struct.pt_regs, align 8
  %rctx = alloca i32, align 4
  %0 = bitcast i8* %__data to %struct.ftrace_event_call*
  call void @perf_fetch_caller_regs(%struct.pt_regs* %__regs)
  %call = call i32 @ftrace_get_offsets_rpc_task_status()
  %conv = sext i32 %call to i64
  %add = add i64 %conv, 32
  %add2 = add i64 %add, 4
  %add3 = add i64 %add2, 7
  %and = and i64 %add3, -8
  %conv4 = trunc i64 %and to i32
  %conv5 = sext i32 %conv4 to i64
  %sub = sub i64 %conv5, 4
  %conv6 = trunc i64 %sub to i32
  %cmp = icmp sgt i32 %conv6, 2048
  %lnot = xor i1 %cmp, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot9 = xor i1 %tobool, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool14 = icmp ne i64 %expval, 0
  br i1 %tobool14, label %if.then, label %if.end41

if.then:                                          ; preds = %entry
  %1 = load i8, i8* @perf_trace_rpc_task_status.__warned, align 1, !tbaa !29, !range !31
  %tobool15 = trunc i8 %1 to i1
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %tobool22 = icmp ne i32 %lnot.ext21, 0
  %lnot23 = xor i1 %tobool22, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %conv27 = sext i32 %lnot.ext26 to i64
  %expval28 = call i64 @llvm.expect.i64(i64 %conv27, i64 0)
  %tobool29 = icmp ne i64 %expval28, 0
  br i1 %tobool29, label %if.then30, label %if.end

if.then30:                                        ; preds = %if.then
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.36.302, i32 0, i32 0), i32 30, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.37.369, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then30, %if.then
  %tobool31 = icmp ne i32 %lnot.ext21, 0
  %lnot32 = xor i1 %tobool31, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  %conv36 = sext i32 %lnot.ext35 to i64
  %expval37 = call i64 @llvm.expect.i64(i64 %conv36, i64 0)
  %tobool38 = icmp ne i64 %expval37, 0
  br i1 %tobool38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %if.end
  store i8 1, i8* @perf_trace_rpc_task_status.__warned, align 1, !tbaa !29
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %if.end, %entry
  %tobool43 = icmp ne i32 %lnot.ext, 0
  %lnot44 = xor i1 %tobool43, true
  %lnot46 = xor i1 %lnot44, true
  %lnot.ext47 = zext i1 %lnot46 to i32
  %conv48 = sext i32 %lnot.ext47 to i64
  %expval49 = call i64 @llvm.expect.i64(i64 %conv48, i64 0)
  %tobool50 = icmp ne i64 %expval49, 0
  br i1 %tobool50, label %cleanup, label %if.end52

if.end52:                                         ; preds = %if.end41
  %event = getelementptr inbounds %struct.ftrace_event_call, %struct.ftrace_event_call* %0, i32 0, i32 3
  %type = getelementptr inbounds %struct.trace_event, %struct.trace_event* %event, i32 0, i32 2
  %2 = load i32, i32* %type, align 8, !tbaa !520
  %conv53 = trunc i32 %2 to i16
  %call54 = call i8* @perf_trace_buf_prepare(i32 %conv6, i16 zeroext %conv53, %struct.pt_regs* %__regs, i32* %rctx)
  %3 = bitcast i8* %call54 to %struct.ftrace_raw_rpc_connect_status*
  %tobool55 = icmp ne %struct.ftrace_raw_rpc_connect_status* %3, null
  br i1 %tobool55, label %if.end57, label %cleanup

if.end57:                                         ; preds = %if.end52
  %task58 = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %3, i32 0, i32 1
  store %struct.rpc_task* %task, %struct.rpc_task** %task58, align 8, !tbaa !550
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %4 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %clnt = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %3, i32 0, i32 2
  store %struct.rpc_clnt* %4, %struct.rpc_clnt** %clnt, align 8, !tbaa !552
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  %5 = load i32, i32* %tk_status, align 4, !tbaa !59
  %status = getelementptr inbounds %struct.ftrace_raw_rpc_connect_status, %struct.ftrace_raw_rpc_connect_status* %3, i32 0, i32 3
  store i32 %5, i32* %status, align 8, !tbaa !553
  %perf_events = getelementptr inbounds %struct.ftrace_event_call, %struct.ftrace_event_call* %0, i32 0, i32 11
  %6 = load %struct.hlist_head*, %struct.hlist_head** %perf_events, align 8, !tbaa !526
  %7 = call i64 asm sideeffect "add %gs:${1:P}, $0", "=r,*m,0,~{dirflag},~{fpsr},~{flags}"(i64* @this_cpu_off, %struct.hlist_head* %6) #7, !srcloc !554
  %8 = inttoptr i64 %7 to %struct.hlist_head*
  %9 = bitcast %struct.ftrace_raw_rpc_connect_status* %3 to i8*
  %10 = load i32, i32* %rctx, align 4, !tbaa !49
  %11 = bitcast %struct.hlist_head* %8 to i8*
  call void @perf_trace_buf_submit(i8* %9, i32 %conv6, i32 %10, i64 0, i64 1, %struct.pt_regs* %__regs, i8* %11, %struct.task_struct* null)
  br label %cleanup

cleanup:                                          ; preds = %if.end57, %if.end52, %if.end41
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ftrace_define_fields_rpc_task_status(%struct.ftrace_event_call* %event_call) #6 section ".init.text" {
entry:
  %call = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.18.358, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19.359, i32 0, i32 0), i32 8, i32 8, i32 zext (i1 icmp ult (%struct.rpc_task* inttoptr (i64 -1 to %struct.rpc_task*), %struct.rpc_task* inttoptr (i64 1 to %struct.rpc_task*)) to i32), i32 0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.20.356, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.21.357, i32 0, i32 0), i32 16, i32 8, i32 zext (i1 icmp ult (%struct.rpc_clnt* inttoptr (i64 -1 to %struct.rpc_clnt*), %struct.rpc_clnt* inttoptr (i64 1 to %struct.rpc_clnt*)) to i32), i32 0)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @trace_define_field(%struct.ftrace_event_call* %event_call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.22.363, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.23.364, i32 0, i32 0), i32 24, i32 4, i32 1, i32 0)
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ %call1, %if.end ], [ %call5, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @ftrace_get_offsets_rpc_task_status() #2 {
entry:
  ret i32 0
}

; Function Attrs: nounwind uwtable
define void @rpc_prepare_task(%struct.rpc_task* %task) #0 {
entry:
  %tk_ops = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 7
  %0 = load %struct.rpc_call_ops*, %struct.rpc_call_ops** %tk_ops, align 8, !tbaa !180
  %rpc_call_prepare = getelementptr inbounds %struct.rpc_call_ops, %struct.rpc_call_ops* %0, i32 0, i32 0
  %1 = load void (%struct.rpc_task*, i8*)*, void (%struct.rpc_task*, i8*)** %rpc_call_prepare, align 8, !tbaa !181
  %tk_calldata = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 8
  %2 = load i8*, i8** %tk_calldata, align 8, !tbaa !334
  call void %1(%struct.rpc_task* %task, i8* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_execute(%struct.rpc_task* %task) #0 {
entry:
  call void @rpc_set_active(%struct.rpc_task* %task)
  call void @rpc_make_runnable(%struct.rpc_task* %task)
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %0 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @__rpc_execute(%struct.rpc_task* %task)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_set_active(%struct.rpc_task* %task) #0 {
entry:
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %0 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  call void @trace_rpc_task_begin(%struct.rpc_clnt* %0, %struct.rpc_task* %task, i8* null)
  call void @rpc_task_set_debuginfo(%struct.rpc_task* %task)
  %tk_runstate = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %tk_runstate, i32 2, i64* %tk_runstate) #7, !srcloc !488
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @trace_rpc_task_begin(%struct.rpc_clnt* %clnt, %struct.rpc_task* %task, i8* %action) #2 {
entry:
  %call.i = call i32 @atomic_read.296(%struct.atomic_t* getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_task_begin, i64 0, i32 1, i32 0)) #7
  %tobool.i = icmp ne i32 %call.i, 0
  %lnot.ext.i = zext i1 %tobool.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv.i, i64 0) #7
  %cmp.i = icmp sgt i64 %expval.i, 0
  %..i = select i1 %cmp.i, i1 true, i1 false
  br i1 %..i, label %do.body, label %if.end21

do.body:                                          ; preds = %entry
  call void @rcu_read_lock_sched_notrace.300()
  %0 = load volatile %struct.tracepoint_func*, %struct.tracepoint_func** getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_task_begin, i32 0, i32 4), align 8, !tbaa !28
  %call2 = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %land.lhs.true, label %do.end10

land.lhs.true:                                    ; preds = %do.body
  %1 = load i8, i8* @trace_rpc_task_begin.__warned, align 1, !tbaa !29, !range !31
  %tobool3 = trunc i8 %1 to i1
  br i1 %tobool3, label %do.end10, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %land.lhs.true
  %call5 = call i32 @rcu_read_lock_sched_held.301()
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %do.end10, label %if.then7

if.then7:                                         ; preds = %land.lhs.true4
  store i8 1, i8* @trace_rpc_task_begin.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.36.302, i32 0, i32 0), i32 104, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end10

do.end10:                                         ; preds = %if.then7, %land.lhs.true4, %land.lhs.true, %do.body
  %tobool11 = icmp ne %struct.tracepoint_func* %0, null
  br i1 %tobool11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %do.end10
  br label %do.body13

do.body13:                                        ; preds = %do.body13, %if.then12
  %it_func_ptr.0 = phi %struct.tracepoint_func* [ %0, %if.then12 ], [ %incdec.ptr, %do.body13 ]
  %func = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 0
  %2 = load i8*, i8** %func, align 8, !tbaa !120
  %data = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 1
  %3 = load i8*, i8** %data, align 8, !tbaa !122
  %4 = bitcast i8* %2 to void (i8*, %struct.rpc_clnt*, %struct.rpc_task*, i8*)*
  call void %4(i8* %3, %struct.rpc_clnt* %clnt, %struct.rpc_task* %task, i8* %action)
  %incdec.ptr = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 1
  %func15 = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %incdec.ptr, i32 0, i32 0
  %5 = load i8*, i8** %func15, align 8, !tbaa !120
  %tobool16 = icmp ne i8* %5, null
  br i1 %tobool16, label %do.body13, label %if.end18

if.end18:                                         ; preds = %do.body13, %do.end10
  call void @rcu_read_unlock_sched_notrace.304()
  br label %if.end21

if.end21:                                         ; preds = %if.end18, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_task_set_debuginfo(%struct.rpc_task* %task) #0 {
entry:
  %call = call i32 @atomic_add_return(i32 1, %struct.atomic_t* @rpc_task_set_debuginfo.rpc_pid)
  %conv = trunc i32 %call to i16
  %tk_pid = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 19
  store i16 %conv, i16* %tk_pid, align 4, !tbaa !555
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_return(i32 %i, %struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #7, !srcloc !556
  %add = add nsw i32 %i, %0
  ret i32 %add
}

; Function Attrs: nounwind uwtable
define %struct.rpc_task* @rpc_new_task(%struct.rpc_task_setup* %setup_data) #0 {
entry:
  %task1 = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %setup_data, i32 0, i32 0
  %0 = load %struct.rpc_task*, %struct.rpc_task** %task1, align 8, !tbaa !10
  %cmp = icmp eq %struct.rpc_task* %0, null
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %call = call %struct.rpc_task* @rpc_alloc_task()
  %cmp2 = icmp eq %struct.rpc_task* %call, null
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.then
  %callback_ops = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %setup_data, i32 0, i32 3
  %1 = load %struct.rpc_call_ops*, %struct.rpc_call_ops** %callback_ops, align 8, !tbaa !15
  %callback_data = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %setup_data, i32 0, i32 4
  %2 = load i8*, i8** %callback_data, align 8, !tbaa !16
  call void @rpc_release_calldata(%struct.rpc_call_ops* %1, i8* %2)
  %call4 = call i8* @ERR_PTR.386(i64 -12)
  %3 = bitcast i8* %call4 to %struct.rpc_task*
  br label %cleanup

if.end5:                                          ; preds = %if.then, %entry
  %flags.0 = phi i16 [ 0, %entry ], [ 128, %if.then ]
  %task.0 = phi %struct.rpc_task* [ %0, %entry ], [ %call, %if.then ]
  call void @rpc_init_task(%struct.rpc_task* %task.0, %struct.rpc_task_setup* %setup_data)
  %conv = zext i16 %flags.0 to i32
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task.0, i32 0, i32 17
  %4 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv6 = zext i16 %4 to i32
  %or = or i32 %conv6, %conv
  %conv7 = trunc i32 %or to i16
  store i16 %conv7, i16* %tk_flags, align 8, !tbaa !27
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %5, 64
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %conv9 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv9, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then11, label %cleanup

if.then11:                                        ; preds = %if.end5
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then11, %if.end5, %if.then3
  %retval.0 = phi %struct.rpc_task* [ %3, %if.then3 ], [ %task.0, %if.then11 ], [ %task.0, %if.end5 ]
  ret %struct.rpc_task* %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_task* @rpc_alloc_task() #0 {
entry:
  %0 = load %struct.mempool_s*, %struct.mempool_s** @rpc_task_mempool, align 8, !tbaa !28
  %call = call i8* @mempool_alloc(%struct.mempool_s* %0, i32 16)
  %1 = bitcast i8* %call to %struct.rpc_task*
  ret %struct.rpc_task* %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR.386(i64 %error) #2 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal void @rpc_init_task(%struct.rpc_task* %task, %struct.rpc_task_setup* %task_setup_data) #0 {
entry:
  %0 = bitcast %struct.rpc_task* %task to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 240, i32 8, i1 false)
  %tk_count = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 0
  call void @atomic_set.388(%struct.atomic_t* %tk_count, i32 1)
  %flags = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 6
  %1 = load i16, i16* %flags, align 8, !tbaa !18
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  store i16 %1, i16* %tk_flags, align 8, !tbaa !27
  %callback_ops = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 3
  %2 = load %struct.rpc_call_ops*, %struct.rpc_call_ops** %callback_ops, align 8, !tbaa !15
  %tk_ops = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 7
  store %struct.rpc_call_ops* %2, %struct.rpc_call_ops** %tk_ops, align 8, !tbaa !180
  %callback_data = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 4
  %3 = load i8*, i8** %callback_data, align 8, !tbaa !16
  %tk_calldata = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 8
  store i8* %3, i8** %tk_calldata, align 8, !tbaa !334
  %tk_task = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 1
  call void @INIT_LIST_HEAD.259(%struct.list_head* %tk_task)
  %priority = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 7
  %4 = load i8, i8* %priority, align 2, !tbaa !19
  %conv = sext i8 %4 to i32
  %sub = sub nsw i32 %conv, -1
  %conv1 = trunc i32 %sub to i8
  %tk_priority = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 20
  %bf.load = load i8, i8* %tk_priority, align 2
  %bf.value = and i8 %conv1, 3
  %bf.clear = and i8 %bf.load, -4
  %bf.set = or i8 %bf.clear, %bf.value
  store i8 %bf.set, i8* %tk_priority, align 2
  %5 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !484
  %tgid = getelementptr inbounds %struct.task_struct, %struct.task_struct* %5, i32 0, i32 36
  %6 = load i32, i32* %tgid, align 4, !tbaa !557
  %tk_owner = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 15
  store i32 %6, i32* %tk_owner, align 8, !tbaa !503
  %workqueue = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 5
  %7 = load %struct.workqueue_struct*, %struct.workqueue_struct** %workqueue, align 8, !tbaa !17
  %tk_workqueue = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 11
  store %struct.workqueue_struct* %7, %struct.workqueue_struct** %tk_workqueue, align 8, !tbaa !473
  %tk_ops2 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 7
  %8 = load %struct.rpc_call_ops*, %struct.rpc_call_ops** %tk_ops2, align 8, !tbaa !180
  %rpc_call_prepare = getelementptr inbounds %struct.rpc_call_ops, %struct.rpc_call_ops* %8, i32 0, i32 0
  %9 = load void (%struct.rpc_task*, i8*)*, void (%struct.rpc_task*, i8*)** %rpc_call_prepare, align 8, !tbaa !181
  %cmp = icmp ne void (%struct.rpc_task*, i8*)* %9, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %tk_action = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 6
  store void (%struct.rpc_task*)* @rpc_prepare_task, void (%struct.rpc_task*)** %tk_action, align 8, !tbaa !20
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @rpc_init_task_statistics(%struct.rpc_task* %task)
  %10 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %10, 64
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv5, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then7, label %do.end

if.then7:                                         ; preds = %if.end
  call void @task_pid_nr()
  %11 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then7, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set.388(%struct.atomic_t* %v, i32 %i) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !240
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @task_pid_nr() #2 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @rpciod_up() #0 {
entry:
  %call = call zeroext i1 @try_module_get(%struct.module* @__this_module)
  %cond = select i1 %call, i32 0, i32 -22
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define void @rpciod_down() #0 {
entry:
  call void @module_put(%struct.module* @__this_module)
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_destroy_mempool() #0 {
entry:
  call void @rpciod_stop()
  %0 = load %struct.mempool_s*, %struct.mempool_s** @rpc_buffer_mempool, align 8, !tbaa !28
  %tobool = icmp ne %struct.mempool_s* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.mempool_s*, %struct.mempool_s** @rpc_buffer_mempool, align 8, !tbaa !28
  call void @mempool_destroy(%struct.mempool_s* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load %struct.mempool_s*, %struct.mempool_s** @rpc_task_mempool, align 8, !tbaa !28
  %tobool1 = icmp ne %struct.mempool_s* %2, null
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %3 = load %struct.mempool_s*, %struct.mempool_s** @rpc_task_mempool, align 8, !tbaa !28
  call void @mempool_destroy(%struct.mempool_s* %3)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %4 = load %struct.kmem_cache*, %struct.kmem_cache** @rpc_task_slabp, align 8, !tbaa !28
  %tobool4 = icmp ne %struct.kmem_cache* %4, null
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  %5 = load %struct.kmem_cache*, %struct.kmem_cache** @rpc_task_slabp, align 8, !tbaa !28
  call void @kmem_cache_destroy(%struct.kmem_cache* %5)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end3
  %6 = load %struct.kmem_cache*, %struct.kmem_cache** @rpc_buffer_slabp, align 8, !tbaa !28
  %tobool7 = icmp ne %struct.kmem_cache* %6, null
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %7 = load %struct.kmem_cache*, %struct.kmem_cache** @rpc_buffer_slabp, align 8, !tbaa !28
  call void @kmem_cache_destroy(%struct.kmem_cache* %7)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  call void @rpc_destroy_wait_queue(%struct.rpc_wait_queue* @delay_queue)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpciod_stop() #0 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !28
  %cmp = icmp eq %struct.workqueue_struct* %0, null
  br i1 %cmp, label %cleanup.cont, label %do.body

do.body:                                          ; preds = %entry
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 64
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then3, label %do.end

if.then3:                                         ; preds = %do.body
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then3, %do.body
  %3 = load %struct.workqueue_struct*, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !28
  store %struct.workqueue_struct* null, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !28
  call void @destroy_workqueue(%struct.workqueue_struct* %3)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %do.end, %entry
  ret void
}

declare void @mempool_destroy(%struct.mempool_s*) #4

declare void @kmem_cache_destroy(%struct.kmem_cache*) #4

declare void @destroy_workqueue(%struct.workqueue_struct*) #4

; Function Attrs: nounwind uwtable
define i32 @rpc_init_mempool() #0 {
entry:
  call void @rpc_init_wait_queue(%struct.rpc_wait_queue* @delay_queue, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.14.395, i32 0, i32 0))
  %call = call i32 @rpciod_start()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %err_nomem

if.end:                                           ; preds = %entry
  %call1 = call %struct.kmem_cache* @kmem_cache_create(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.15.396, i32 0, i32 0), i64 240, i64 0, i64 8192, void (i8*)* null)
  store %struct.kmem_cache* %call1, %struct.kmem_cache** @rpc_task_slabp, align 8, !tbaa !28
  %0 = load %struct.kmem_cache*, %struct.kmem_cache** @rpc_task_slabp, align 8, !tbaa !28
  %tobool2 = icmp ne %struct.kmem_cache* %0, null
  br i1 %tobool2, label %if.end4, label %err_nomem

if.end4:                                          ; preds = %if.end
  %call5 = call %struct.kmem_cache* @kmem_cache_create(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.16.397, i32 0, i32 0), i64 2048, i64 0, i64 8192, void (i8*)* null)
  store %struct.kmem_cache* %call5, %struct.kmem_cache** @rpc_buffer_slabp, align 8, !tbaa !28
  %1 = load %struct.kmem_cache*, %struct.kmem_cache** @rpc_buffer_slabp, align 8, !tbaa !28
  %tobool6 = icmp ne %struct.kmem_cache* %1, null
  br i1 %tobool6, label %if.end8, label %err_nomem

if.end8:                                          ; preds = %if.end4
  %2 = load %struct.kmem_cache*, %struct.kmem_cache** @rpc_task_slabp, align 8, !tbaa !28
  %call9 = call %struct.mempool_s* @mempool_create_slab_pool(i32 8, %struct.kmem_cache* %2)
  store %struct.mempool_s* %call9, %struct.mempool_s** @rpc_task_mempool, align 8, !tbaa !28
  %3 = load %struct.mempool_s*, %struct.mempool_s** @rpc_task_mempool, align 8, !tbaa !28
  %tobool10 = icmp ne %struct.mempool_s* %3, null
  br i1 %tobool10, label %if.end12, label %err_nomem

if.end12:                                         ; preds = %if.end8
  %4 = load %struct.kmem_cache*, %struct.kmem_cache** @rpc_buffer_slabp, align 8, !tbaa !28
  %call13 = call %struct.mempool_s* @mempool_create_slab_pool(i32 8, %struct.kmem_cache* %4)
  store %struct.mempool_s* %call13, %struct.mempool_s** @rpc_buffer_mempool, align 8, !tbaa !28
  %5 = load %struct.mempool_s*, %struct.mempool_s** @rpc_buffer_mempool, align 8, !tbaa !28
  %tobool14 = icmp ne %struct.mempool_s* %5, null
  br i1 %tobool14, label %return, label %err_nomem

err_nomem:                                        ; preds = %if.end12, %if.end8, %if.end4, %if.end, %entry
  call void @rpc_destroy_mempool()
  br label %return

return:                                           ; preds = %err_nomem, %if.end12
  %retval.0 = phi i32 [ -12, %err_nomem ], [ 0, %if.end12 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rpciod_start() #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 64
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %call3 = call %struct.workqueue_struct* (i8*, i32, i32, %struct.lock_class_key*, i8*, ...) @__alloc_workqueue_key(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.64.399, i32 0, i32 0), i32 8, i32 1, %struct.lock_class_key* @rpciod_start.__key, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.64.399, i32 0, i32 0))
  store %struct.workqueue_struct* %call3, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !28
  %2 = load %struct.workqueue_struct*, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !28
  %cmp = icmp ne %struct.workqueue_struct* %2, null
  %conv4 = zext i1 %cmp to i32
  ret i32 %conv4
}

declare %struct.kmem_cache* @kmem_cache_create(i8*, i64, i64, i64, void (i8*)*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.mempool_s* @mempool_create_slab_pool(i32 %min_nr, %struct.kmem_cache* %kc) #2 {
entry:
  %0 = bitcast %struct.kmem_cache* %kc to i8*
  %call = call %struct.mempool_s* @mempool_create(i32 %min_nr, i8* (i32, i8*)* @mempool_alloc_slab, void (i8*, i8*)* @mempool_free_slab, i8* %0)
  ret %struct.mempool_s* %call
}

declare i8* @mempool_alloc_slab(i32, i8*) #4

declare void @mempool_free_slab(i8*, i8*) #4

declare %struct.mempool_s* @mempool_create(i32, i8* (i32, i8*)*, void (i8*, i8*)*, i8*) #4

declare %struct.workqueue_struct* @__alloc_workqueue_key(i8*, i32, i32, %struct.lock_class_key*, i8*, ...) #4

; Function Attrs: nounwind uwtable
define void @put_rpccred(%struct.rpc_cred* %cred) #0 {
entry:
  %cr_flags = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 7
  %0 = load volatile i64, i64* %cr_flags, align 8, !tbaa !88
  %and.i4 = and i64 4, %0
  %cmp.i5 = icmp ne i64 %and.i4, 0
  %conv.i6 = zext i1 %cmp.i5 to i32
  %cmp = icmp eq i32 %conv.i6, 0
  %cr_count = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 8
  br i1 %cmp, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %call1 = call i32 @atomic_dec_and_test.404(%struct.atomic_t* %cr_count)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then2, label %return

if.then2:                                         ; preds = %if.then
  %cr_ops = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 4
  %1 = load %struct.rpc_credops*, %struct.rpc_credops** %cr_ops, align 8, !tbaa !558
  %crdestroy = getelementptr inbounds %struct.rpc_credops, %struct.rpc_credops* %1, i32 0, i32 2
  %2 = load void (%struct.rpc_cred*)*, void (%struct.rpc_cred*)** %crdestroy, align 8, !tbaa !559
  call void %2(%struct.rpc_cred* %cred)
  br label %return

if.end3:                                          ; preds = %entry
  %call5 = call i32 @_atomic_dec_and_lock(%struct.atomic_t* %cr_count, %struct.spinlock* @rpc_credcache_lock)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.end8, label %return

if.end8:                                          ; preds = %if.end3
  %cr_lru = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 1
  %call9 = call i32 @list_empty.405(%struct.list_head* %cr_lru)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %if.end8
  %3 = load i64, i64* @number_cred_unused, align 8, !tbaa !88
  %dec = add i64 %3, -1
  store i64 %dec, i64* @number_cred_unused, align 8, !tbaa !88
  %cr_lru12 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 1
  call void @list_del_init.406(%struct.list_head* %cr_lru12)
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end8
  %cr_flags14 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 7
  %4 = load volatile i64, i64* %cr_flags14, align 8, !tbaa !88
  %and.i1 = and i64 4, %4
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %cmp16 = icmp ne i32 %conv.i3, 0
  br i1 %cmp16, label %if.then17, label %if.end28

if.then17:                                        ; preds = %if.end13
  %cr_flags18 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 7
  %5 = load volatile i64, i64* %cr_flags18, align 8, !tbaa !88
  %and.i = and i64 2, %5
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %cmp20 = icmp ne i32 %conv.i, 0
  br i1 %cmp20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.then17
  %6 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %cr_expire = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 6
  store i64 %6, i64* %cr_expire, align 8, !tbaa !561
  %cr_lru22 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 1
  call void @list_add_tail.407(%struct.list_head* %cr_lru22, %struct.list_head* @cred_unused)
  %7 = load i64, i64* @number_cred_unused, align 8, !tbaa !88
  %inc = add i64 %7, 1
  store i64 %inc, i64* @number_cred_unused, align 8, !tbaa !88
  br label %out_nodestroy

if.end23:                                         ; preds = %if.then17
  %call24 = call i32 @rpcauth_unhash_cred(%struct.rpc_cred* %cred)
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %if.end28, label %out_nodestroy

if.end28:                                         ; preds = %if.end23, %if.end13
  call void @spin_unlock.408(%struct.spinlock* @rpc_credcache_lock)
  %cr_ops29 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 4
  %8 = load %struct.rpc_credops*, %struct.rpc_credops** %cr_ops29, align 8, !tbaa !558
  %crdestroy30 = getelementptr inbounds %struct.rpc_credops, %struct.rpc_credops* %8, i32 0, i32 2
  %9 = load void (%struct.rpc_cred*)*, void (%struct.rpc_cred*)** %crdestroy30, align 8, !tbaa !559
  call void %9(%struct.rpc_cred* %cred)
  br label %return

out_nodestroy:                                    ; preds = %if.end23, %if.then21
  call void @spin_unlock.408(%struct.spinlock* @rpc_credcache_lock)
  br label %return

return:                                           ; preds = %out_nodestroy, %if.end28, %if.end3, %if.then2, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_dec_and_test.404(%struct.atomic_t* %v) #2 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0; sete $1", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32* %counter) #7, !srcloc !562
  %0 = load i8, i8* %c, align 1, !tbaa !166
  %conv = zext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

declare i32 @_atomic_dec_and_lock(%struct.atomic_t*, %struct.spinlock*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty.405(%struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init.406(%struct.list_head* %entry1) #2 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD.412(%struct.list_head* %entry1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.407(%struct.list_head* %new, %struct.list_head* %head) #2 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !163
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rpcauth_unhash_cred(%struct.rpc_cred* %cred) #0 {
entry:
  %cr_auth = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 3
  %0 = load %struct.rpc_auth*, %struct.rpc_auth** %cr_auth, align 8, !tbaa !65
  %au_credcache = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %0, i32 0, i32 7
  %1 = load %struct.rpc_cred_cache*, %struct.rpc_cred_cache** %au_credcache, align 8, !tbaa !563
  %lock = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %1, i32 0, i32 2
  call void @spin_lock.409(%struct.spinlock* %lock)
  %cr_count = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 8
  %call = call i32 @atomic_read.410(%struct.atomic_t* %cr_count)
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @rpcauth_unhash_cred_locked(%struct.rpc_cred* %cred)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @spin_unlock.408(%struct.spinlock* %lock)
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock.408(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock.409(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read.410(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !49
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal void @rpcauth_unhash_cred_locked(%struct.rpc_cred* %cred) #0 {
entry:
  %cr_hash = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 0
  call void @hlist_del_rcu(%struct.hlist_node* %cr_hash)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !564
  %cr_flags = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 7
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %cr_flags, i32 2, i64* %cr_flags) #7, !srcloc !565
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @hlist_del_rcu(%struct.hlist_node* %n) #2 {
entry:
  call void @__hlist_del(%struct.hlist_node* %n)
  %pprev = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 1
  store %struct.hlist_node** bitcast (i8* getelementptr (i8, i8* inttoptr (i64 2097664 to i8*), i64 -2401263026318606336) to %struct.hlist_node**), %struct.hlist_node*** %pprev, align 8, !tbaa !566
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__hlist_del(%struct.hlist_node* %n) #2 {
entry:
  %next1 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 0
  %0 = load %struct.hlist_node*, %struct.hlist_node** %next1, align 8, !tbaa !567
  %pprev2 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 1
  %1 = load %struct.hlist_node**, %struct.hlist_node*** %pprev2, align 8, !tbaa !566
  store %struct.hlist_node* %0, %struct.hlist_node** %1, align 8, !tbaa !28
  %tobool = icmp ne %struct.hlist_node* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %pprev3 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %0, i32 0, i32 1
  store %struct.hlist_node** %1, %struct.hlist_node*** %pprev3, align 8, !tbaa !566
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.412(%struct.list_head* %list) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !163
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.rpc_cred* @rpcauth_generic_bind_cred(%struct.rpc_task* %task, %struct.rpc_cred* %cred, i32 %lookupflags) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %call4 = call %struct.rpc_cred* @get_rpccred.415(%struct.rpc_cred* %cred)
  ret %struct.rpc_cred* %call4
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.rpc_cred* @get_rpccred.415(%struct.rpc_cred* %cred) #2 {
entry:
  %cr_count = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 8
  call void @atomic_inc.416(%struct.atomic_t* %cr_count)
  ret %struct.rpc_cred* %cred
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.416(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !568
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpcauth_init_cred(%struct.rpc_cred* %cred, %struct.auth_cred* %acred, %struct.rpc_auth* %auth, %struct.rpc_credops* %ops) #0 {
entry:
  %cr_hash = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 0
  call void @INIT_HLIST_NODE(%struct.hlist_node* %cr_hash)
  %cr_lru = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 1
  call void @INIT_LIST_HEAD.412(%struct.list_head* %cr_lru)
  %cr_count = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 8
  call void @atomic_set.417(%struct.atomic_t* %cr_count, i32 1)
  %cr_auth = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 3
  store %struct.rpc_auth* %auth, %struct.rpc_auth** %cr_auth, align 8, !tbaa !65
  %cr_ops = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 4
  store %struct.rpc_credops* %ops, %struct.rpc_credops** %cr_ops, align 8, !tbaa !558
  %0 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %cr_expire = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 6
  store i64 %0, i64* %cr_expire, align 8, !tbaa !561
  %cr_magic = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 5
  store i64 256550128, i64* %cr_magic, align 8, !tbaa !569
  %uid = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 0
  %1 = load i32, i32* %uid, align 8, !tbaa !570
  %cr_uid = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 9
  store i32 %1, i32* %cr_uid, align 4, !tbaa !572
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_HLIST_NODE(%struct.hlist_node* %h) #2 {
entry:
  %next = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %h, i32 0, i32 0
  store %struct.hlist_node* null, %struct.hlist_node** %next, align 8, !tbaa !567
  %pprev = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %h, i32 0, i32 1
  store %struct.hlist_node** null, %struct.hlist_node*** %pprev, align 8, !tbaa !566
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set.417(%struct.atomic_t* %v, i32 %i) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !240
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.rpc_cred* @rpcauth_lookup_credcache(%struct.rpc_auth* %auth, %struct.auth_cred* %acred, i32 %flags) #0 {
entry:
  %free = alloca %struct.list_head, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %free, i32 0, i32 0
  store %struct.list_head* %free, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %free, i32 0, i32 1
  store %struct.list_head* %free, %struct.list_head** %prev, align 8, !tbaa !163
  %au_credcache = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %auth, i32 0, i32 7
  %0 = load %struct.rpc_cred_cache*, %struct.rpc_cred_cache** %au_credcache, align 8, !tbaa !563
  %uid = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 0
  %1 = load i32, i32* %uid, align 8, !tbaa !570
  %call = call i32 @from_kuid(i32 %1)
  %conv = zext i32 %call to i64
  %hashbits = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %0, i32 0, i32 1
  %2 = load i32, i32* %hashbits, align 8, !tbaa !573
  %shl.i = shl i64 %conv, 18
  %sub.i = sub i64 %conv, %shl.i
  %shl1.i = shl i64 %shl.i, 33
  %sub2.i = sub i64 %sub.i, %shl1.i
  %shl3.i = shl i64 %shl1.i, 3
  %add.i = add i64 %sub2.i, %shl3.i
  %shl4.i = shl i64 %shl3.i, 3
  %sub5.i = sub i64 %add.i, %shl4.i
  %shl6.i = shl i64 %shl4.i, 4
  %add7.i = add i64 %sub5.i, %shl6.i
  %shl8.i = shl i64 %shl6.i, 2
  %add9.i = add i64 %add7.i, %shl8.i
  %sub10.i = sub i32 64, %2
  %sh_prom.i = zext i32 %sub10.i to i64
  %shr.i = lshr i64 %add9.i, %sh_prom.i
  %conv3 = trunc i64 %shr.i to i32
  call void @rcu_read_lock.418()
  %hashtable = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %0, i32 0, i32 0
  %3 = load %struct.hlist_head*, %struct.hlist_head** %hashtable, align 8, !tbaa !575
  %idxprom = zext i32 %conv3 to i64
  %arrayidx = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %3, i64 %idxprom
  %first = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %arrayidx, i32 0, i32 0
  %4 = load volatile %struct.hlist_node*, %struct.hlist_node** %first, align 8, !tbaa !28
  %call4 = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %land.lhs.true, label %do.end11

land.lhs.true:                                    ; preds = %entry
  %5 = load i8, i8* @rpcauth_lookup_credcache.__warned, align 1, !tbaa !29, !range !31
  %tobool5 = trunc i8 %5 to i1
  br i1 %tobool5, label %do.end11, label %land.lhs.true6

land.lhs.true6:                                   ; preds = %land.lhs.true
  call void @rcu_read_lock_held.419()
  br label %do.end11

do.end11:                                         ; preds = %land.lhs.true6, %land.lhs.true, %entry
  br label %for.cond

for.cond:                                         ; preds = %do.end45, %do.end11
  %.sink = phi %struct.hlist_node* [ %11, %do.end45 ], [ %4, %do.end11 ]
  %tobool48 = icmp ne %struct.hlist_node* %.sink, null
  %6 = bitcast %struct.hlist_node* %.sink to i8*
  %add.ptr52 = getelementptr inbounds i8, i8* %6, i64 0
  %7 = bitcast i8* %add.ptr52 to %struct.rpc_cred*
  %cond55 = select i1 %tobool48, %struct.rpc_cred* %7, %struct.rpc_cred* null
  %tobool15 = icmp ne %struct.rpc_cred* %cond55, null
  br i1 %tobool15, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %cr_ops = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cond55, i32 0, i32 4
  %8 = load %struct.rpc_credops*, %struct.rpc_credops** %cr_ops, align 8, !tbaa !558
  %crmatch = getelementptr inbounds %struct.rpc_credops, %struct.rpc_credops* %8, i32 0, i32 3
  %9 = load i32 (%struct.auth_cred*, %struct.rpc_cred*, i32)*, i32 (%struct.auth_cred*, %struct.rpc_cred*, i32)** %crmatch, align 8, !tbaa !576
  %call16 = call i32 %9(%struct.auth_cred* %acred, %struct.rpc_cred* %cond55, i32 %flags)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.end19, label %for.inc

if.end19:                                         ; preds = %for.body
  %lock = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %0, i32 0, i32 2
  call void @spin_lock.409(%struct.spinlock* %lock)
  %cr_flags = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cond55, i32 0, i32 7
  %10 = load volatile i64, i64* %cr_flags, align 8, !tbaa !88
  %and.i1 = and i64 4, %10
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %cmp = icmp eq i32 %conv.i3, 0
  br i1 %cmp, label %if.then22, label %if.end24

if.then22:                                        ; preds = %if.end19
  %lock23 = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %0, i32 0, i32 2
  call void @spin_unlock.408(%struct.spinlock* %lock23)
  br label %for.inc

if.end24:                                         ; preds = %if.end19
  %call25 = call %struct.rpc_cred* @get_rpccred.415(%struct.rpc_cred* %cond55)
  %lock26 = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %0, i32 0, i32 2
  call void @spin_unlock.408(%struct.spinlock* %lock26)
  br label %for.end

for.inc:                                          ; preds = %if.then22, %for.body
  %cr_hash = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cond55, i32 0, i32 0
  %next29 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %cr_hash, i32 0, i32 0
  %11 = load volatile %struct.hlist_node*, %struct.hlist_node** %next29, align 8, !tbaa !28
  %call31 = call i32 @debug_lockdep_rcu_enabled()
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %land.lhs.true33, label %do.end45

land.lhs.true33:                                  ; preds = %for.inc
  %12 = load i8, i8* @rpcauth_lookup_credcache.__warned.5, align 1, !tbaa !29, !range !31
  %tobool34 = trunc i8 %12 to i1
  br i1 %tobool34, label %do.end45, label %land.lhs.true35

land.lhs.true35:                                  ; preds = %land.lhs.true33
  call void @rcu_read_lock_held.419()
  br label %do.end45

do.end45:                                         ; preds = %land.lhs.true35, %land.lhs.true33, %for.inc
  br label %for.cond

for.end:                                          ; preds = %if.end24, %for.cond
  %cred.0 = phi %struct.rpc_cred* [ %call25, %if.end24 ], [ null, %for.cond ]
  call void @rcu_read_unlock.420()
  %cmp56 = icmp ne %struct.rpc_cred* %cred.0, null
  br i1 %cmp56, label %cond.true114, label %if.end59

if.end59:                                         ; preds = %for.end
  %au_ops = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %auth, i32 0, i32 4
  %13 = load %struct.rpc_authops*, %struct.rpc_authops** %au_ops, align 8, !tbaa !173
  %crcreate = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %13, i32 0, i32 6
  %14 = load %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)*, %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)** %crcreate, align 8, !tbaa !577
  %call60 = call %struct.rpc_cred* %14(%struct.rpc_auth* %auth, %struct.auth_cred* %acred, i32 %flags)
  %15 = bitcast %struct.rpc_cred* %call60 to i8*
  %call61 = call i64 @IS_ERR.421(i8* %15)
  %tobool62 = icmp ne i64 %call61, 0
  br i1 %tobool62, label %out, label %if.end64

if.end64:                                         ; preds = %if.end59
  %lock65 = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %0, i32 0, i32 2
  call void @spin_lock.409(%struct.spinlock* %lock65)
  %hashtable67 = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %0, i32 0, i32 0
  %16 = load %struct.hlist_head*, %struct.hlist_head** %hashtable67, align 8, !tbaa !575
  %idxprom68 = zext i32 %conv3 to i64
  %arrayidx69 = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %16, i64 %idxprom68
  %first70 = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %arrayidx69, i32 0, i32 0
  br label %for.cond80

for.cond80:                                       ; preds = %for.inc90, %if.end64
  %next93.sink = phi %struct.hlist_node** [ %next93, %for.inc90 ], [ %first70, %if.end64 ]
  %17 = load %struct.hlist_node*, %struct.hlist_node** %next93.sink, align 8, !tbaa !28
  %tobool95 = icmp ne %struct.hlist_node* %17, null
  %18 = bitcast %struct.hlist_node* %17 to i8*
  %add.ptr99 = getelementptr inbounds i8, i8* %18, i64 0
  %19 = bitcast i8* %add.ptr99 to %struct.rpc_cred*
  %cond102 = select i1 %tobool95, %struct.rpc_cred* %19, %struct.rpc_cred* null
  %tobool81 = icmp ne %struct.rpc_cred* %cond102, null
  br i1 %tobool81, label %for.body82, label %for.end103

for.body82:                                       ; preds = %for.cond80
  %cr_ops83 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cond102, i32 0, i32 4
  %20 = load %struct.rpc_credops*, %struct.rpc_credops** %cr_ops83, align 8, !tbaa !558
  %crmatch84 = getelementptr inbounds %struct.rpc_credops, %struct.rpc_credops* %20, i32 0, i32 3
  %21 = load i32 (%struct.auth_cred*, %struct.rpc_cred*, i32)*, i32 (%struct.auth_cred*, %struct.rpc_cred*, i32)** %crmatch84, align 8, !tbaa !576
  %call85 = call i32 %21(%struct.auth_cred* %acred, %struct.rpc_cred* %cond102, i32 %flags)
  %tobool86 = icmp ne i32 %call85, 0
  br i1 %tobool86, label %if.end88, label %for.inc90

if.end88:                                         ; preds = %for.body82
  %call89 = call %struct.rpc_cred* @get_rpccred.415(%struct.rpc_cred* %cond102)
  br label %for.end103

for.inc90:                                        ; preds = %for.body82
  %cr_hash92 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cond102, i32 0, i32 0
  %next93 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %cr_hash92, i32 0, i32 0
  br label %for.cond80

for.end103:                                       ; preds = %if.end88, %for.cond80
  %cred.1 = phi %struct.rpc_cred* [ %call89, %if.end88 ], [ %cred.0, %for.cond80 ]
  %cmp104 = icmp eq %struct.rpc_cred* %cred.1, null
  br i1 %cmp104, label %if.then106, label %if.else

if.then106:                                       ; preds = %for.end103
  %cr_flags107 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %call60, i32 0, i32 7
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %cr_flags107, i32 2, i64* %cr_flags107) #7, !srcloc !578
  %cr_hash108 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %call60, i32 0, i32 0
  %hashtable109 = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %0, i32 0, i32 0
  %22 = load %struct.hlist_head*, %struct.hlist_head** %hashtable109, align 8, !tbaa !575
  %idxprom110 = zext i32 %conv3 to i64
  %arrayidx111 = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %22, i64 %idxprom110
  call void @hlist_add_head_rcu(%struct.hlist_node* %cr_hash108, %struct.hlist_head* %arrayidx111)
  br label %if.end112

if.else:                                          ; preds = %for.end103
  %cr_lru = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %call60, i32 0, i32 1
  call void @list_add_tail.407(%struct.list_head* %cr_lru, %struct.list_head* %free)
  br label %if.end112

if.end112:                                        ; preds = %if.else, %if.then106
  %cred.2 = phi %struct.rpc_cred* [ %call60, %if.then106 ], [ %cred.1, %if.else ]
  %lock113 = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %0, i32 0, i32 2
  call void @spin_unlock.408(%struct.spinlock* %lock113)
  br label %cond.true114

cond.true114:                                     ; preds = %if.end112, %for.end
  %cred.3 = phi %struct.rpc_cred* [ %cred.2, %if.end112 ], [ %cred.0, %for.end ]
  %cr_flags115 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred.3, i32 0, i32 7
  %23 = load volatile i64, i64* %cr_flags115, align 8, !tbaa !88
  %and.i = and i64 1, %23
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool117 = icmp ne i32 %conv.i, 0
  br i1 %tobool117, label %land.lhs.true122, label %if.end138

land.lhs.true122:                                 ; preds = %cond.true114
  %cr_ops123 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred.3, i32 0, i32 4
  %24 = load %struct.rpc_credops*, %struct.rpc_credops** %cr_ops123, align 8, !tbaa !558
  %cr_init = getelementptr inbounds %struct.rpc_credops, %struct.rpc_credops* %24, i32 0, i32 1
  %25 = load i32 (%struct.rpc_auth*, %struct.rpc_cred*)*, i32 (%struct.rpc_auth*, %struct.rpc_cred*)** %cr_init, align 8, !tbaa !579
  %cmp124 = icmp eq i32 (%struct.rpc_auth*, %struct.rpc_cred*)* %25, null
  %and = and i32 %flags, 1
  %tobool127 = icmp ne i32 %and, 0
  %or.cond = or i1 %cmp124, %tobool127
  br i1 %or.cond, label %if.end138, label %if.then128

if.then128:                                       ; preds = %land.lhs.true122
  %cr_ops129 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred.3, i32 0, i32 4
  %26 = load %struct.rpc_credops*, %struct.rpc_credops** %cr_ops129, align 8, !tbaa !558
  %cr_init130 = getelementptr inbounds %struct.rpc_credops, %struct.rpc_credops* %26, i32 0, i32 1
  %27 = load i32 (%struct.rpc_auth*, %struct.rpc_cred*)*, i32 (%struct.rpc_auth*, %struct.rpc_cred*)** %cr_init130, align 8, !tbaa !579
  %call131 = call i32 %27(%struct.rpc_auth* %auth, %struct.rpc_cred* %cred.3)
  %cmp132 = icmp slt i32 %call131, 0
  br i1 %cmp132, label %if.then134, label %if.end138

if.then134:                                       ; preds = %if.then128
  call void @put_rpccred(%struct.rpc_cred* %cred.3)
  %conv135 = sext i32 %call131 to i64
  %call136 = call i8* @ERR_PTR.423(i64 %conv135)
  %28 = bitcast i8* %call136 to %struct.rpc_cred*
  br label %if.end138

if.end138:                                        ; preds = %if.then134, %if.then128, %land.lhs.true122, %cond.true114
  %cred.5 = phi %struct.rpc_cred* [ %cred.3, %land.lhs.true122 ], [ %cred.3, %cond.true114 ], [ %28, %if.then134 ], [ %cred.3, %if.then128 ]
  call void @rpcauth_destroy_credlist(%struct.list_head* %free)
  br label %out

out:                                              ; preds = %if.end138, %if.end59
  %cred.6 = phi %struct.rpc_cred* [ %cred.5, %if.end138 ], [ %call60, %if.end59 ]
  ret %struct.rpc_cred* %cred.6
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @from_kuid(i32 %kuid) #2 {
entry:
  %call = call i32 @__kuid_val(i32 %kuid)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock.418() #2 {
entry:
  call void @__rcu_read_lock.430()
  call void @rcu_lock_acquire.431(%struct.lockdep_map* @rcu_lock_map)
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_lock.__warned.432, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_lock.__warned.432, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 780, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.15.1329, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock_held.419() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call1 = call i32 @rcu_is_cpu_idle()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call zeroext i1 @rcu_lockdep_current_cpu_online()
  br i1 %call5, label %if.end7, label %return

if.end7:                                          ; preds = %if.end4
  %call8 = call i32 @lock_is_held(%struct.lockdep_map* @rcu_lock_map)
  br label %return

return:                                           ; preds = %if.end7, %if.end4, %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_unlock.420() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_unlock.__warned.424, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_unlock.__warned.424, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 801, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.16.1322, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  call void @rcu_lock_release.427(%struct.lockdep_map* @rcu_lock_map)
  call void @__rcu_read_unlock.428()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR.421(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @hlist_add_head_rcu(%struct.hlist_node* %n, %struct.hlist_head* %h) #2 {
entry:
  %first1 = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %h, i32 0, i32 0
  %0 = load %struct.hlist_node*, %struct.hlist_node** %first1, align 8, !tbaa !580
  %next = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 0
  store %struct.hlist_node* %0, %struct.hlist_node** %next, align 8, !tbaa !567
  %first2 = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %h, i32 0, i32 0
  %pprev = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 1
  store %struct.hlist_node** %first2, %struct.hlist_node*** %pprev, align 8, !tbaa !566
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !581
  %first3 = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %h, i32 0, i32 0
  store %struct.hlist_node* %n, %struct.hlist_node** %first3, align 8, !tbaa !28
  %tobool = icmp ne %struct.hlist_node* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %next4 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 0
  %pprev5 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %0, i32 0, i32 1
  store %struct.hlist_node** %next4, %struct.hlist_node*** %pprev5, align 8, !tbaa !566
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR.423(i64 %error) #2 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rpcauth_destroy_credlist(%struct.list_head* %head) #2 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call i32 @list_empty.405(%struct.list_head* %head)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -16
  %2 = bitcast i8* %add.ptr to %struct.rpc_cred*
  %cr_lru = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %2, i32 0, i32 1
  call void @list_del_init.406(%struct.list_head* %cr_lru)
  call void @put_rpccred(%struct.rpc_cred* %2)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_release.427(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_release(%struct.lockdep_map* %map, i32 1, i64 ptrtoint (i8* blockaddress(@rcu_lock_release.427, %__here) to i64))
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_unlock.428() #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !582
  %call = call %struct.thread_info* @current_thread_info.429()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !583
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.429() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !584
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_lock.430() #2 {
entry:
  %call = call %struct.thread_info* @current_thread_info.429()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !585
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_acquire.431(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_acquire(%struct.lockdep_map* %map, i32 0, i32 0, i32 2, i32 1, %struct.lockdep_map* null, i64 ptrtoint (i8* blockaddress(@rcu_lock_acquire.431, %__here) to i64))
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__kuid_val(i32 %uid) #2 {
entry:
  ret i32 %uid
}

; Function Attrs: nounwind uwtable
define void @rpcauth_destroy_credcache(%struct.rpc_auth* %auth) #0 {
entry:
  %au_credcache = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %auth, i32 0, i32 7
  %0 = load %struct.rpc_cred_cache*, %struct.rpc_cred_cache** %au_credcache, align 8, !tbaa !563
  %tobool = icmp ne %struct.rpc_cred_cache* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %au_credcache1 = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %auth, i32 0, i32 7
  store %struct.rpc_cred_cache* null, %struct.rpc_cred_cache** %au_credcache1, align 8, !tbaa !563
  call void @rpcauth_clear_credcache(%struct.rpc_cred_cache* %0)
  %hashtable = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %0, i32 0, i32 0
  %1 = load %struct.hlist_head*, %struct.hlist_head** %hashtable, align 8, !tbaa !575
  %2 = bitcast %struct.hlist_head* %1 to i8*
  call void @kfree(i8* %2)
  %3 = bitcast %struct.rpc_cred_cache* %0 to i8*
  call void @kfree(i8* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpcauth_clear_credcache(%struct.rpc_cred_cache* %cache) #0 {
entry:
  %free = alloca %struct.list_head, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %free, i32 0, i32 0
  store %struct.list_head* %free, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %free, i32 0, i32 1
  store %struct.list_head* %free, %struct.list_head** %prev, align 8, !tbaa !163
  %hashbits = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %cache, i32 0, i32 1
  %0 = load i32, i32* %hashbits, align 8, !tbaa !573
  %shl = shl i32 1, %0
  call void @spin_lock.409(%struct.spinlock* @rpc_credcache_lock)
  %lock = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %cache, i32 0, i32 2
  call void @spin_lock.409(%struct.spinlock* %lock)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp ult i32 %i.0, %shl
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %hashtable = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %cache, i32 0, i32 0
  %1 = load %struct.hlist_head*, %struct.hlist_head** %hashtable, align 8, !tbaa !575
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %1, i64 %idxprom
  br label %while.cond

while.cond:                                       ; preds = %if.end, %for.body
  %call = call i32 @hlist_empty(%struct.hlist_head* %arrayidx)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %for.inc

while.body:                                       ; preds = %while.cond
  %first = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %arrayidx, i32 0, i32 0
  %2 = load %struct.hlist_node*, %struct.hlist_node** %first, align 8, !tbaa !580
  %3 = bitcast %struct.hlist_node* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.rpc_cred*
  %call1 = call %struct.rpc_cred* @get_rpccred.415(%struct.rpc_cred* %4)
  %cr_lru = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %4, i32 0, i32 1
  %call2 = call i32 @list_empty.405(%struct.list_head* %cr_lru)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  %cr_lru4 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %4, i32 0, i32 1
  call void @list_del(%struct.list_head* %cr_lru4)
  %5 = load i64, i64* @number_cred_unused, align 8, !tbaa !88
  %dec = add i64 %5, -1
  store i64 %dec, i64* @number_cred_unused, align 8, !tbaa !88
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %cr_lru5 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %4, i32 0, i32 1
  call void @list_add_tail.407(%struct.list_head* %cr_lru5, %struct.list_head* %free)
  call void @rpcauth_unhash_cred_locked(%struct.rpc_cred* %4)
  br label %while.cond

for.inc:                                          ; preds = %while.cond
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %lock6 = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %cache, i32 0, i32 2
  call void @spin_unlock.408(%struct.spinlock* %lock6)
  call void @spin_unlock.408(%struct.spinlock* @rpc_credcache_lock)
  call void @rpcauth_destroy_credlist(%struct.list_head* %free)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hlist_empty(%struct.hlist_head* %h) #2 {
entry:
  %first = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %h, i32 0, i32 0
  %0 = load %struct.hlist_node*, %struct.hlist_node** %first, align 8, !tbaa !580
  %tobool = icmp ne %struct.hlist_node* %0, null
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: nounwind uwtable
define i32 @rpcauth_init_credcache(%struct.rpc_auth* %auth) #0 {
entry:
  %call.i = call i8* @__kmalloc(i64 88, i32 208) #7
  %0 = bitcast i8* %call.i to %struct.rpc_cred_cache*
  %tobool = icmp ne %struct.rpc_cred_cache* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %1 = load i32, i32* @auth_hashbits, align 4, !tbaa !49
  %hashbits = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %0, i32 0, i32 1
  store i32 %1, i32* %hashbits, align 8, !tbaa !573
  %hashbits1 = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %0, i32 0, i32 1
  %2 = load i32, i32* %hashbits1, align 8, !tbaa !573
  %shl = shl i32 1, %2
  %conv = zext i32 %shl to i64
  %call2 = call i8* @kcalloc(i64 %conv, i64 8, i32 208)
  %3 = bitcast i8* %call2 to %struct.hlist_head*
  %hashtable = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %0, i32 0, i32 0
  store %struct.hlist_head* %3, %struct.hlist_head** %hashtable, align 8, !tbaa !575
  %hashtable3 = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %0, i32 0, i32 0
  %4 = load %struct.hlist_head*, %struct.hlist_head** %hashtable3, align 8, !tbaa !575
  %tobool4 = icmp ne %struct.hlist_head* %4, null
  br i1 %tobool4, label %do.body, label %out_nohashtbl

do.body:                                          ; preds = %if.end
  call void @spinlock_check.435()
  %lock9 = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %0, i32 0, i32 2
  %5 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock9, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %5 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.2.436, i32 0, i32 0), %struct.lock_class_key* @rpcauth_init_credcache.__key)
  %au_credcache = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %auth, i32 0, i32 7
  store %struct.rpc_cred_cache* %0, %struct.rpc_cred_cache** %au_credcache, align 8, !tbaa !563
  br label %cleanup

out_nohashtbl:                                    ; preds = %if.end
  %6 = bitcast %struct.rpc_cred_cache* %0 to i8*
  call void @kfree(i8* %6)
  br label %cleanup

cleanup:                                          ; preds = %out_nohashtbl, %do.body, %entry
  %retval.0 = phi i32 [ 0, %do.body ], [ -12, %entry ], [ -12, %out_nohashtbl ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kcalloc(i64 %n, i64 %size, i32 %flags) #2 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc_array(i64 %n, i64 %size, i32 %or)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spinlock_check.435() #2 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kmalloc_array(i64 %n, i64 %size, i32 %flags) #2 {
entry:
  %cmp = icmp ne i64 %size, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %div = udiv i64 -1, %size
  %cmp1 = icmp ugt i64 %n, %div
  br i1 %cmp1, label %return, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %mul = mul i64 %n, %size
  %call = call i8* @__kmalloc(i64 %mul, i32 %flags)
  br label %return

return:                                           ; preds = %if.end, %land.lhs.true
  %retval.0 = phi i8* [ %call, %if.end ], [ null, %land.lhs.true ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.rpc_auth* @rpcauth_create(i32 %pseudoflavor, %struct.rpc_clnt* %clnt) #0 {
entry:
  %call = call i32 @pseudoflavor_to_flavor(i32 %pseudoflavor)
  %call1 = call i8* @ERR_PTR.423(i64 -22)
  %0 = bitcast i8* %call1 to %struct.rpc_auth*
  %cmp = icmp uge i32 %call, 8
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %idxprom = zext i32 %call to i64
  %arrayidx = getelementptr inbounds [8 x %struct.rpc_authops*], [8 x %struct.rpc_authops*]* @auth_flavors, i64 0, i64 %idxprom
  %1 = load %struct.rpc_authops*, %struct.rpc_authops** %arrayidx, align 8, !tbaa !28
  %cmp2 = icmp eq %struct.rpc_authops* %1, null
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %call4 = call i32 (i1, i8*, ...) @__request_module(i1 zeroext true, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.439, i32 0, i32 0), i32 %call)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  call void @spin_lock.409(%struct.spinlock* @rpc_authflavor_lock)
  %idxprom6 = zext i32 %call to i64
  %arrayidx7 = getelementptr inbounds [8 x %struct.rpc_authops*], [8 x %struct.rpc_authops*]* @auth_flavors, i64 0, i64 %idxprom6
  %2 = load %struct.rpc_authops*, %struct.rpc_authops** %arrayidx7, align 8, !tbaa !28
  %cmp8 = icmp eq %struct.rpc_authops* %2, null
  br i1 %cmp8, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end5
  %owner = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %2, i32 0, i32 0
  %3 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !586
  %call9 = call zeroext i1 @try_module_get(%struct.module* %3)
  br i1 %call9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %lor.lhs.false, %if.end5
  call void @spin_unlock.408(%struct.spinlock* @rpc_authflavor_lock)
  br label %cleanup

if.end11:                                         ; preds = %lor.lhs.false
  call void @spin_unlock.408(%struct.spinlock* @rpc_authflavor_lock)
  %create = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %2, i32 0, i32 3
  %4 = load %struct.rpc_auth* (%struct.rpc_clnt*, i32)*, %struct.rpc_auth* (%struct.rpc_clnt*, i32)** %create, align 8, !tbaa !587
  %call12 = call %struct.rpc_auth* %4(%struct.rpc_clnt* %clnt, i32 %pseudoflavor)
  %owner13 = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %2, i32 0, i32 0
  %5 = load %struct.module*, %struct.module** %owner13, align 8, !tbaa !586
  call void @module_put(%struct.module* %5)
  %6 = bitcast %struct.rpc_auth* %call12 to i8*
  %call14 = call i64 @IS_ERR.421(i8* %6)
  %tobool = icmp ne i64 %call14, 0
  br i1 %tobool, label %cleanup, label %if.end16

if.end16:                                         ; preds = %if.end11
  %cl_auth = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 10
  %7 = load %struct.rpc_auth*, %struct.rpc_auth** %cl_auth, align 8, !tbaa !167
  %tobool17 = icmp ne %struct.rpc_auth* %7, null
  br i1 %tobool17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end16
  %cl_auth19 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 10
  %8 = load %struct.rpc_auth*, %struct.rpc_auth** %cl_auth19, align 8, !tbaa !167
  call void @rpcauth_release(%struct.rpc_auth* %8)
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end16
  %cl_auth21 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 10
  store %struct.rpc_auth* %call12, %struct.rpc_auth** %cl_auth21, align 8, !tbaa !167
  br label %cleanup

cleanup:                                          ; preds = %if.end20, %if.end11, %if.then10, %entry
  %retval.0 = phi %struct.rpc_auth* [ %call12, %if.end11 ], [ %0, %if.then10 ], [ %call12, %if.end20 ], [ %0, %entry ]
  ret %struct.rpc_auth* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @pseudoflavor_to_flavor(i32 %flavor) #0 {
entry:
  %cmp = icmp ugt i32 %flavor, 8
  %.flavor = select i1 %cmp, i32 6, i32 %flavor
  ret i32 %.flavor
}

; Function Attrs: nounwind uwtable
define void @rpcauth_release(%struct.rpc_auth* %auth) #0 {
entry:
  %au_count = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %auth, i32 0, i32 6
  %call = call i32 @atomic_dec_and_test.404(%struct.atomic_t* %au_count)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %au_ops = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %auth, i32 0, i32 4
  %0 = load %struct.rpc_authops*, %struct.rpc_authops** %au_ops, align 8, !tbaa !173
  %destroy = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %0, i32 0, i32 4
  %1 = load void (%struct.rpc_auth*)*, void (%struct.rpc_auth*)** %destroy, align 8, !tbaa !588
  call void %1(%struct.rpc_auth* %auth)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @rpcauth_list_flavors(i32* %array, i32 %size) #0 {
entry:
  %pseudos = alloca [4 x i32], align 16
  call void @spin_lock.409(%struct.spinlock* @rpc_authflavor_lock)
  br label %for.cond

for.cond:                                         ; preds = %for.inc29, %entry
  %result.0 = phi i32 [ 0, %entry ], [ %result.3, %for.inc29 ]
  %flavor.0 = phi i32 [ 0, %entry ], [ %inc30, %for.inc29 ]
  %cmp = icmp ult i32 %flavor.0, 8
  br i1 %cmp, label %for.body, label %for.end31

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %flavor.0 to i64
  %arrayidx = getelementptr inbounds [8 x %struct.rpc_authops*], [8 x %struct.rpc_authops*]* @auth_flavors, i64 0, i64 %idxprom
  %0 = load %struct.rpc_authops*, %struct.rpc_authops** %arrayidx, align 8, !tbaa !28
  %cmp1 = icmp sge i32 %result.0, %size
  br i1 %cmp1, label %cleanup, label %if.end

if.end:                                           ; preds = %for.body
  %cmp2 = icmp eq %struct.rpc_authops* %0, null
  br i1 %cmp2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %list_pseudoflavors = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %0, i32 0, i32 9
  %1 = load i32 (i32*, i32)*, i32 (i32*, i32)** %list_pseudoflavors, align 8, !tbaa !589
  %cmp5 = icmp eq i32 (i32*, i32)* %1, null
  br i1 %cmp5, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.end4
  %au_flavor = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %0, i32 0, i32 1
  %2 = load i32, i32* %au_flavor, align 8, !tbaa !590
  %inc = add nsw i32 %result.0, 1
  %idxprom7 = sext i32 %result.0 to i64
  %arrayidx8 = getelementptr inbounds i32, i32* %array, i64 %idxprom7
  store i32 %2, i32* %arrayidx8, align 4, !tbaa !49
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %list_pseudoflavors10 = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %0, i32 0, i32 9
  %3 = load i32 (i32*, i32)*, i32 (i32*, i32)** %list_pseudoflavors10, align 8, !tbaa !589
  %arraydecay = getelementptr inbounds [4 x i32], [4 x i32]* %pseudos, i32 0, i32 0
  %call = call i32 %3(i32* %arraydecay, i32 4)
  %cmp11 = icmp slt i32 %call, 0
  br i1 %cmp11, label %cleanup, label %if.end13

if.end13:                                         ; preds = %if.end9
  br label %for.cond14

for.cond14:                                       ; preds = %if.end19, %if.end13
  %result.1 = phi i32 [ %result.0, %if.end13 ], [ %inc22, %if.end19 ]
  %i.0 = phi i32 [ 0, %if.end13 ], [ %inc25, %if.end19 ]
  %cmp15 = icmp slt i32 %i.0, %call
  br i1 %cmp15, label %for.body16, label %cleanup

for.body16:                                       ; preds = %for.cond14
  %cmp17 = icmp sge i32 %result.1, %size
  br i1 %cmp17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %for.body16
  %idxprom20 = sext i32 %i.0 to i64
  %arrayidx21 = getelementptr inbounds [4 x i32], [4 x i32]* %pseudos, i64 0, i64 %idxprom20
  %4 = load i32, i32* %arrayidx21, align 4, !tbaa !49
  %inc22 = add nsw i32 %result.1, 1
  %idxprom23 = sext i32 %result.1 to i64
  %arrayidx24 = getelementptr inbounds i32, i32* %array, i64 %idxprom23
  store i32 %4, i32* %arrayidx24, align 4, !tbaa !49
  %inc25 = add nsw i32 %i.0, 1
  br label %for.cond14

cleanup:                                          ; preds = %for.body16, %for.cond14, %if.end9, %if.then6, %if.end, %for.body
  %result.3 = phi i32 [ %inc, %if.then6 ], [ -12, %for.body ], [ %result.0, %if.end ], [ %call, %if.end9 ], [ -12, %for.body16 ], [ %result.1, %for.cond14 ]
  %cleanup.dest.slot.0 = phi i32 [ 4, %if.then6 ], [ 2, %for.body ], [ 4, %if.end ], [ 2, %if.end9 ], [ 0, %for.cond14 ], [ 0, %for.body16 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 4
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 2
  %or.cond = and i1 %Pivot, %SwitchLeaf
  br i1 %or.cond, label %for.end31, label %for.inc29

for.inc29:                                        ; preds = %cleanup
  %inc30 = add i32 %flavor.0, 1
  br label %for.cond

for.end31:                                        ; preds = %cleanup, %for.cond
  %result.4 = phi i32 [ %result.0, %for.cond ], [ %result.3, %cleanup ]
  call void @spin_unlock.408(%struct.spinlock* @rpc_authflavor_lock)
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %5, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot32 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot32 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool33 = icmp ne i64 %expval, 0
  br i1 %tobool33, label %if.then34, label %do.end

if.then34:                                        ; preds = %for.end31
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then34, %for.end31
  ret i32 %result.4
}

; Function Attrs: nounwind uwtable
define i32 @rpcauth_get_gssinfo(i32 %pseudoflavor, %struct.rpcsec_gss_info* %info) #0 {
entry:
  %call = call i32 @pseudoflavor_to_flavor(i32 %pseudoflavor)
  %cmp = icmp uge i32 %call, 8
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %idxprom = zext i32 %call to i64
  %arrayidx = getelementptr inbounds [8 x %struct.rpc_authops*], [8 x %struct.rpc_authops*]* @auth_flavors, i64 0, i64 %idxprom
  %0 = load %struct.rpc_authops*, %struct.rpc_authops** %arrayidx, align 8, !tbaa !28
  %cmp1 = icmp eq %struct.rpc_authops* %0, null
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %call3 = call i32 (i1, i8*, ...) @__request_module(i1 zeroext true, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.439, i32 0, i32 0), i32 %call)
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  call void @spin_lock.409(%struct.spinlock* @rpc_authflavor_lock)
  %idxprom5 = zext i32 %call to i64
  %arrayidx6 = getelementptr inbounds [8 x %struct.rpc_authops*], [8 x %struct.rpc_authops*]* @auth_flavors, i64 0, i64 %idxprom5
  %1 = load %struct.rpc_authops*, %struct.rpc_authops** %arrayidx6, align 8, !tbaa !28
  %cmp7 = icmp eq %struct.rpc_authops* %1, null
  br i1 %cmp7, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end4
  %owner = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %1, i32 0, i32 0
  %2 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !586
  %call8 = call zeroext i1 @try_module_get(%struct.module* %2)
  br i1 %call8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %lor.lhs.false, %if.end4
  call void @spin_unlock.408(%struct.spinlock* @rpc_authflavor_lock)
  br label %cleanup

if.end10:                                         ; preds = %lor.lhs.false
  call void @spin_unlock.408(%struct.spinlock* @rpc_authflavor_lock)
  %flavor2info = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %1, i32 0, i32 11
  %3 = load i32 (i32, %struct.rpcsec_gss_info*)*, i32 (i32, %struct.rpcsec_gss_info*)** %flavor2info, align 8, !tbaa !591
  %cmp11 = icmp ne i32 (i32, %struct.rpcsec_gss_info*)* %3, null
  br i1 %cmp11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end10
  %flavor2info13 = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %1, i32 0, i32 11
  %4 = load i32 (i32, %struct.rpcsec_gss_info*)*, i32 (i32, %struct.rpcsec_gss_info*)** %flavor2info13, align 8, !tbaa !591
  %call14 = call i32 %4(i32 %pseudoflavor, %struct.rpcsec_gss_info* %info)
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.end10
  %result.0 = phi i32 [ %call14, %if.then12 ], [ -2, %if.end10 ]
  %owner16 = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %1, i32 0, i32 0
  %5 = load %struct.module*, %struct.module** %owner16, align 8, !tbaa !586
  call void @module_put(%struct.module* %5)
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.then9, %entry
  %retval.0 = phi i32 [ -2, %if.then9 ], [ %result.0, %if.end15 ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @rpcauth_get_pseudoflavor(i32 %flavor, %struct.rpcsec_gss_info* %info) #0 {
entry:
  %idxprom = zext i32 %flavor to i64
  %arrayidx = getelementptr inbounds [8 x %struct.rpc_authops*], [8 x %struct.rpc_authops*]* @auth_flavors, i64 0, i64 %idxprom
  %0 = load %struct.rpc_authops*, %struct.rpc_authops** %arrayidx, align 8, !tbaa !28
  %cmp = icmp eq %struct.rpc_authops* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i1, i8*, ...) @__request_module(i1 zeroext true, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.439, i32 0, i32 0), i32 %flavor)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @spin_lock.409(%struct.spinlock* @rpc_authflavor_lock)
  %idxprom1 = zext i32 %flavor to i64
  %arrayidx2 = getelementptr inbounds [8 x %struct.rpc_authops*], [8 x %struct.rpc_authops*]* @auth_flavors, i64 0, i64 %idxprom1
  %1 = load %struct.rpc_authops*, %struct.rpc_authops** %arrayidx2, align 8, !tbaa !28
  %cmp3 = icmp eq %struct.rpc_authops* %1, null
  br i1 %cmp3, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %owner = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %1, i32 0, i32 0
  %2 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !586
  %call4 = call zeroext i1 @try_module_get(%struct.module* %2)
  br i1 %call4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  call void @spin_unlock.408(%struct.spinlock* @rpc_authflavor_lock)
  br label %cleanup

if.end6:                                          ; preds = %lor.lhs.false
  call void @spin_unlock.408(%struct.spinlock* @rpc_authflavor_lock)
  %info2flavor = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %1, i32 0, i32 10
  %3 = load i32 (%struct.rpcsec_gss_info*)*, i32 (%struct.rpcsec_gss_info*)** %info2flavor, align 8, !tbaa !592
  %cmp7 = icmp ne i32 (%struct.rpcsec_gss_info*)* %3, null
  br i1 %cmp7, label %if.then8, label %if.end11

if.then8:                                         ; preds = %if.end6
  %info2flavor9 = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %1, i32 0, i32 10
  %4 = load i32 (%struct.rpcsec_gss_info*)*, i32 (%struct.rpcsec_gss_info*)** %info2flavor9, align 8, !tbaa !592
  %call10 = call i32 %4(%struct.rpcsec_gss_info* %info)
  br label %if.end11

if.end11:                                         ; preds = %if.then8, %if.end6
  %pseudoflavor.0 = phi i32 [ %call10, %if.then8 ], [ %flavor, %if.end6 ]
  %owner12 = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %1, i32 0, i32 0
  %5 = load %struct.module*, %struct.module** %owner12, align 8, !tbaa !586
  call void @module_put(%struct.module* %5)
  br label %cleanup

cleanup:                                          ; preds = %if.end11, %if.then5
  %retval.0 = phi i32 [ 8, %if.then5 ], [ %pseudoflavor.0, %if.end11 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @rpcauth_unregister(%struct.rpc_authops* %ops) #0 {
entry:
  %au_flavor = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %ops, i32 0, i32 1
  %0 = load i32, i32* %au_flavor, align 8, !tbaa !590
  %cmp = icmp uge i32 %0, 8
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @spin_lock.409(%struct.spinlock* @rpc_authflavor_lock)
  %idxprom = zext i32 %0 to i64
  %arrayidx = getelementptr inbounds [8 x %struct.rpc_authops*], [8 x %struct.rpc_authops*]* @auth_flavors, i64 0, i64 %idxprom
  %1 = load %struct.rpc_authops*, %struct.rpc_authops** %arrayidx, align 8, !tbaa !28
  %cmp1 = icmp eq %struct.rpc_authops* %1, %ops
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %idxprom3 = zext i32 %0 to i64
  %arrayidx4 = getelementptr inbounds [8 x %struct.rpc_authops*], [8 x %struct.rpc_authops*]* @auth_flavors, i64 0, i64 %idxprom3
  store %struct.rpc_authops* null, %struct.rpc_authops** %arrayidx4, align 8, !tbaa !28
  br label %if.end5

if.end5:                                          ; preds = %if.then2, %if.end
  %ret.0 = phi i32 [ 0, %if.then2 ], [ -1, %if.end ]
  call void @spin_unlock.408(%struct.spinlock* @rpc_authflavor_lock)
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %entry
  %retval.0 = phi i32 [ %ret.0, %if.end5 ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @rpcauth_register(%struct.rpc_authops* %ops) #0 {
entry:
  %au_flavor = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %ops, i32 0, i32 1
  %0 = load i32, i32* %au_flavor, align 8, !tbaa !590
  %cmp = icmp uge i32 %0, 8
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @spin_lock.409(%struct.spinlock* @rpc_authflavor_lock)
  %idxprom = zext i32 %0 to i64
  %arrayidx = getelementptr inbounds [8 x %struct.rpc_authops*], [8 x %struct.rpc_authops*]* @auth_flavors, i64 0, i64 %idxprom
  %1 = load %struct.rpc_authops*, %struct.rpc_authops** %arrayidx, align 8, !tbaa !28
  %cmp1 = icmp eq %struct.rpc_authops* %1, null
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %idxprom3 = zext i32 %0 to i64
  %arrayidx4 = getelementptr inbounds [8 x %struct.rpc_authops*], [8 x %struct.rpc_authops*]* @auth_flavors, i64 0, i64 %idxprom3
  store %struct.rpc_authops* %ops, %struct.rpc_authops** %arrayidx4, align 8, !tbaa !28
  br label %if.end5

if.end5:                                          ; preds = %if.then2, %if.end
  %ret.0 = phi i32 [ 0, %if.then2 ], [ -1, %if.end ]
  call void @spin_unlock.408(%struct.spinlock* @rpc_authflavor_lock)
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %entry
  %retval.0 = phi i32 [ %ret.0, %if.end5 ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @param_set_hashtbl_sz(i8* %val, %struct.kernel_param* %kp) #0 {
entry:
  %num = alloca i64, align 8
  %tobool = icmp ne i8* %val, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul.445(i8* %val, i32 0, i64* %num)
  %cmp = icmp eq i32 %call, -22
  br i1 %cmp, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %0 = load i64, i64* %num, align 8, !tbaa !88
  %conv = trunc i64 %0 to i32
  %call3 = call i32 @fls(i32 %conv)
  %1 = load i64, i64* %num, align 8, !tbaa !88
  %shl = shl i32 1, %call3
  %conv4 = zext i32 %shl to i64
  %cmp5 = icmp ugt i64 %1, %conv4
  %inc = add i32 %call3, 1
  %inc.call3 = select i1 %cmp5, i32 %inc, i32 %call3
  %cmp9 = icmp ugt i32 %inc.call3, 14
  %cmp11 = icmp ult i32 %inc.call3, 2
  %or.cond = or i1 %cmp9, %cmp11
  br i1 %or.cond, label %cleanup, label %if.end14

if.end14:                                         ; preds = %if.end2
  %2 = getelementptr inbounds %struct.kernel_param, %struct.kernel_param* %kp, i32 0, i32 4
  %arg = bitcast %union.anon.57* %2 to i8**
  %3 = load i8*, i8** %arg, align 8, !tbaa !166
  %4 = bitcast i8* %3 to i32*
  store i32 %inc.call3, i32* %4, align 4, !tbaa !49
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %if.end2, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end14 ], [ -22, %if.end2 ], [ -22, %if.end ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @param_get_hashtbl_sz(i8* %buffer, %struct.kernel_param* %kp) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  ret i32 %0
}

declare i32 @sprintf(i8*, i8*, ...) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul.445(i8* %s, i32 %base, i64* %res) #2 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @fls(i32 %x) #2 {
entry:
  %0 = call i32 asm "bsrl $1,$0", "=r,rm,0,~{dirflag},~{fpsr},~{flags}"(i32 %x, i32 -1) #9, !srcloc !593
  %add = add nsw i32 %0, 1
  ret i32 %add
}

; Function Attrs: nounwind uwtable
define %struct.rpc_cred* @rpcauth_lookupcred(%struct.rpc_auth* %auth, i32 %flags) #0 {
entry:
  %acred = alloca %struct.auth_cred, align 8
  %call = call i32 @debug_lockdep_rcu_enabled()
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !594
  %cred4 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 65
  %1 = load %struct.cred*, %struct.cred** %cred4, align 8, !tbaa !595
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 16
  %tobool6 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool6, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then9, label %do.end13

if.then9:                                         ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end13

do.end13:                                         ; preds = %if.then9, %entry
  %4 = bitcast %struct.auth_cred* %acred to i8*
  call void @llvm.memset.p0i8.i64(i8* %4, i8 0, i64 32, i32 8, i1 false)
  %fsuid = getelementptr inbounds %struct.cred, %struct.cred* %1, i32 0, i32 10
  %5 = load i32, i32* %fsuid, align 4, !tbaa !596
  %uid = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 0
  store i32 %5, i32* %uid, align 8, !tbaa !570
  %fsgid = getelementptr inbounds %struct.cred, %struct.cred* %1, i32 0, i32 11
  %6 = load i32, i32* %fsgid, align 8, !tbaa !599
  %gid = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 1
  store i32 %6, i32* %gid, align 4, !tbaa !600
  %group_info = getelementptr inbounds %struct.cred, %struct.cred* %1, i32 0, i32 25
  %7 = load %struct.group_info*, %struct.group_info** %group_info, align 8, !tbaa !601
  %call14 = call %struct.group_info* @get_group_info(%struct.group_info* %7)
  %group_info15 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 2
  store %struct.group_info* %call14, %struct.group_info** %group_info15, align 8, !tbaa !602
  %au_ops16 = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %auth, i32 0, i32 4
  %8 = load %struct.rpc_authops*, %struct.rpc_authops** %au_ops16, align 8, !tbaa !173
  %lookup_cred = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %8, i32 0, i32 5
  %9 = load %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)*, %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)** %lookup_cred, align 8, !tbaa !217
  %call17 = call %struct.rpc_cred* %9(%struct.rpc_auth* %auth, %struct.auth_cred* %acred, i32 %flags)
  %group_info19 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 2
  %10 = load %struct.group_info*, %struct.group_info** %group_info19, align 8, !tbaa !602
  %usage = getelementptr inbounds %struct.group_info, %struct.group_info* %10, i32 0, i32 0
  %call20 = call i32 @atomic_dec_and_test.404(%struct.atomic_t* %usage)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.then22, label %do.end26

if.then22:                                        ; preds = %do.end13
  %group_info23 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 2
  %11 = load %struct.group_info*, %struct.group_info** %group_info23, align 8, !tbaa !602
  call void @groups_free(%struct.group_info* %11)
  br label %do.end26

do.end26:                                         ; preds = %if.then22, %do.end13
  ret %struct.rpc_cred* %call17
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.group_info* @get_group_info(%struct.group_info* %gi) #2 {
entry:
  %usage = getelementptr inbounds %struct.group_info, %struct.group_info* %gi, i32 0, i32 0
  call void @atomic_inc.416(%struct.atomic_t* %usage)
  ret %struct.group_info* %gi
}

declare void @groups_free(%struct.group_info*) #4

; Function Attrs: nounwind uwtable
define i32* @rpcauth_marshcred(%struct.rpc_task* %task, i32* %p) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_cred = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 4
  %1 = load %struct.rpc_cred*, %struct.rpc_cred** %rq_cred, align 8, !tbaa !62
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %cr_ops = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %1, i32 0, i32 4
  %4 = load %struct.rpc_credops*, %struct.rpc_credops** %cr_ops, align 8, !tbaa !558
  %crmarshal = getelementptr inbounds %struct.rpc_credops, %struct.rpc_credops* %4, i32 0, i32 5
  %5 = load i32* (%struct.rpc_task*, i32*)*, i32* (%struct.rpc_task*, i32*)** %crmarshal, align 8, !tbaa !603
  %call4 = call i32* %5(%struct.rpc_task* %task, i32* %p)
  ret i32* %call4
}

; Function Attrs: nounwind uwtable
define i32* @rpcauth_checkverf(%struct.rpc_task* %task, i32* %p) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_cred = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 4
  %1 = load %struct.rpc_cred*, %struct.rpc_cred** %rq_cred, align 8, !tbaa !62
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %cr_ops = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %1, i32 0, i32 4
  %4 = load %struct.rpc_credops*, %struct.rpc_credops** %cr_ops, align 8, !tbaa !558
  %crvalidate = getelementptr inbounds %struct.rpc_credops, %struct.rpc_credops* %4, i32 0, i32 7
  %5 = load i32* (%struct.rpc_task*, i32*)*, i32* (%struct.rpc_task*, i32*)** %crvalidate, align 8, !tbaa !604
  %call4 = call i32* %5(%struct.rpc_task* %task, i32* %p)
  ret i32* %call4
}

; Function Attrs: nounwind uwtable
define i32 @rpcauth_wrap_req(%struct.rpc_task* %task, void (i8*, %struct.xdr_stream*, i8*)* %encode, i8* %rqstp, i32* %data, i8* %obj) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_cred = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 4
  %1 = load %struct.rpc_cred*, %struct.rpc_cred** %rq_cred, align 8, !tbaa !62
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %cr_ops4 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %1, i32 0, i32 4
  %4 = load %struct.rpc_credops*, %struct.rpc_credops** %cr_ops4, align 8, !tbaa !558
  %crwrap_req = getelementptr inbounds %struct.rpc_credops, %struct.rpc_credops* %4, i32 0, i32 8
  %5 = load i32 (%struct.rpc_task*, void (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)*, i32 (%struct.rpc_task*, void (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)** %crwrap_req, align 8, !tbaa !605
  %tobool5 = icmp ne i32 (%struct.rpc_task*, void (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)* %5, null
  br i1 %tobool5, label %if.then6, label %if.end10

if.then6:                                         ; preds = %do.end
  %cr_ops7 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %1, i32 0, i32 4
  %6 = load %struct.rpc_credops*, %struct.rpc_credops** %cr_ops7, align 8, !tbaa !558
  %crwrap_req8 = getelementptr inbounds %struct.rpc_credops, %struct.rpc_credops* %6, i32 0, i32 8
  %7 = load i32 (%struct.rpc_task*, void (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)*, i32 (%struct.rpc_task*, void (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)** %crwrap_req8, align 8, !tbaa !605
  %call9 = call i32 %7(%struct.rpc_task* %task, void (i8*, %struct.xdr_stream*, i8*)* %encode, i8* %rqstp, i32* %data, i8* %obj)
  br label %cleanup

if.end10:                                         ; preds = %do.end
  %8 = bitcast i8* %rqstp to %struct.rpc_rqst*
  call void @rpcauth_wrap_req_encode(void (i8*, %struct.xdr_stream*, i8*)* %encode, %struct.rpc_rqst* %8, i32* %data, i8* %obj)
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.then6
  %retval.0 = phi i32 [ %call9, %if.then6 ], [ 0, %if.end10 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @rpcauth_wrap_req_encode(void (i8*, %struct.xdr_stream*, i8*)* %encode, %struct.rpc_rqst* %rqstp, i32* %data, i8* %obj) #0 {
entry:
  %xdr = alloca %struct.xdr_stream, align 8
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %rqstp, i32 0, i32 1
  call void @xdr_init_encode(%struct.xdr_stream* %xdr, %struct.xdr_buf* %rq_snd_buf, i32* %data)
  %0 = bitcast %struct.rpc_rqst* %rqstp to i8*
  call void %encode(i8* %0, %struct.xdr_stream* %xdr, i8* %obj)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @rpcauth_unwrap_resp(%struct.rpc_task* %task, i32 (i8*, %struct.xdr_stream*, i8*)* %decode, i8* %rqstp, i32* %data, i8* %obj) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_cred = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 4
  %1 = load %struct.rpc_cred*, %struct.rpc_cred** %rq_cred, align 8, !tbaa !62
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %cr_ops4 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %1, i32 0, i32 4
  %4 = load %struct.rpc_credops*, %struct.rpc_credops** %cr_ops4, align 8, !tbaa !558
  %crunwrap_resp = getelementptr inbounds %struct.rpc_credops, %struct.rpc_credops* %4, i32 0, i32 9
  %5 = load i32 (%struct.rpc_task*, i32 (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)*, i32 (%struct.rpc_task*, i32 (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)** %crunwrap_resp, align 8, !tbaa !606
  %tobool5 = icmp ne i32 (%struct.rpc_task*, i32 (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)* %5, null
  br i1 %tobool5, label %if.then6, label %if.end10

if.then6:                                         ; preds = %do.end
  %cr_ops7 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %1, i32 0, i32 4
  %6 = load %struct.rpc_credops*, %struct.rpc_credops** %cr_ops7, align 8, !tbaa !558
  %crunwrap_resp8 = getelementptr inbounds %struct.rpc_credops, %struct.rpc_credops* %6, i32 0, i32 9
  %7 = load i32 (%struct.rpc_task*, i32 (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)*, i32 (%struct.rpc_task*, i32 (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)** %crunwrap_resp8, align 8, !tbaa !606
  %call9 = call i32 %7(%struct.rpc_task* %task, i32 (i8*, %struct.xdr_stream*, i8*)* %decode, i8* %rqstp, i32* %data, i8* %obj)
  br label %cleanup

if.end10:                                         ; preds = %do.end
  %8 = bitcast i8* %rqstp to %struct.rpc_rqst*
  %call11 = call i32 @rpcauth_unwrap_req_decode(i32 (i8*, %struct.xdr_stream*, i8*)* %decode, %struct.rpc_rqst* %8, i32* %data, i8* %obj)
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.then6
  %retval.0 = phi i32 [ %call9, %if.then6 ], [ %call11, %if.end10 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rpcauth_unwrap_req_decode(i32 (i8*, %struct.xdr_stream*, i8*)* %decode, %struct.rpc_rqst* %rqstp, i32* %data, i8* %obj) #0 {
entry:
  %xdr = alloca %struct.xdr_stream, align 8
  %rq_rcv_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %rqstp, i32 0, i32 2
  call void @xdr_init_decode(%struct.xdr_stream* %xdr, %struct.xdr_buf* %rq_rcv_buf, i32* %data)
  %0 = bitcast %struct.rpc_rqst* %rqstp to i8*
  %call = call i32 %decode(i8* %0, %struct.xdr_stream* %xdr, i8* %obj)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @rpcauth_refreshcred(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_cred = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 4
  %1 = load %struct.rpc_cred*, %struct.rpc_cred** %rq_cred, align 8, !tbaa !62
  %cmp = icmp eq %struct.rpc_cred* %1, null
  br i1 %cmp, label %if.then, label %do.body

if.then:                                          ; preds = %entry
  %tk_msg = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_cred = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg, i32 0, i32 3
  %2 = load %struct.rpc_cred*, %struct.rpc_cred** %rpc_cred, align 8, !tbaa !47
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %3 = load i16, i16* %tk_flags, align 8, !tbaa !27
  %conv = zext i16 %3 to i32
  %call = call i32 @rpcauth_bindcred(%struct.rpc_task* %task, %struct.rpc_cred* %2, i32 %conv)
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %out, label %if.end

if.end:                                           ; preds = %if.then
  %tk_rqstp4 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %4 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp4, align 8, !tbaa !60
  %rq_cred5 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %4, i32 0, i32 4
  %5 = load %struct.rpc_cred*, %struct.rpc_cred** %rq_cred5, align 8, !tbaa !62
  br label %do.body

do.body:                                          ; preds = %if.end, %entry
  %cred.0 = phi %struct.rpc_cred* [ %5, %if.end ], [ %1, %entry ]
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %6, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv8 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %do.end

if.then10:                                        ; preds = %do.body
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then10, %do.body
  %cr_ops = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred.0, i32 0, i32 4
  %8 = load %struct.rpc_credops*, %struct.rpc_credops** %cr_ops, align 8, !tbaa !558
  %crrefresh = getelementptr inbounds %struct.rpc_credops, %struct.rpc_credops* %8, i32 0, i32 6
  %9 = load i32 (%struct.rpc_task*)*, i32 (%struct.rpc_task*)** %crrefresh, align 8, !tbaa !607
  %call14 = call i32 %9(%struct.rpc_task* %task)
  br label %out

out:                                              ; preds = %do.end, %if.then
  %err.0 = phi i32 [ %call14, %do.end ], [ %call, %if.then ]
  %cmp15 = icmp slt i32 %err.0, 0
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %out
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 %err.0, i32* %tk_status, align 4, !tbaa !59
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %out
  ret i32 %err.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rpcauth_bindcred(%struct.rpc_task* %task, %struct.rpc_cred* %cred, i32 %flags) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %and = and i32 %flags, 1
  %tobool = icmp ne i32 %and, 0
  %or = or i32 0, 1
  %or. = select i1 %tobool, i32 %or, i32 0
  %cmp = icmp ne %struct.rpc_cred* %cred, null
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %entry
  %cr_ops = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 4
  %1 = load %struct.rpc_credops*, %struct.rpc_credops** %cr_ops, align 8, !tbaa !558
  %crbind = getelementptr inbounds %struct.rpc_credops, %struct.rpc_credops* %1, i32 0, i32 4
  %2 = load %struct.rpc_cred* (%struct.rpc_task*, %struct.rpc_cred*, i32)*, %struct.rpc_cred* (%struct.rpc_task*, %struct.rpc_cred*, i32)** %crbind, align 8, !tbaa !608
  %call = call %struct.rpc_cred* %2(%struct.rpc_task* %task, %struct.rpc_cred* %cred, i32 %or.)
  br label %if.end9

if.else:                                          ; preds = %entry
  %and2 = and i32 %flags, 64
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.else6

if.then4:                                         ; preds = %if.else
  %call5 = call %struct.rpc_cred* @rpcauth_bind_root_cred(%struct.rpc_task* %task, i32 %or.)
  br label %if.end9

if.else6:                                         ; preds = %if.else
  %call7 = call %struct.rpc_cred* @rpcauth_bind_new_cred(%struct.rpc_task* %task, i32 %or.)
  br label %if.end9

if.end9:                                          ; preds = %if.else6, %if.then4, %if.then1
  %new.1 = phi %struct.rpc_cred* [ %call, %if.then1 ], [ %call5, %if.then4 ], [ %call7, %if.else6 ]
  %3 = bitcast %struct.rpc_cred* %new.1 to i8*
  %call10 = call i64 @IS_ERR.421(i8* %3)
  %tobool11 = icmp ne i64 %call10, 0
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end9
  %4 = bitcast %struct.rpc_cred* %new.1 to i8*
  %call13 = call i64 @PTR_ERR.463(i8* %4)
  %conv = trunc i64 %call13 to i32
  br label %cleanup

if.end14:                                         ; preds = %if.end9
  %rq_cred = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 4
  %5 = load %struct.rpc_cred*, %struct.rpc_cred** %rq_cred, align 8, !tbaa !62
  %cmp15 = icmp ne %struct.rpc_cred* %5, null
  br i1 %cmp15, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end14
  %rq_cred18 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 4
  %6 = load %struct.rpc_cred*, %struct.rpc_cred** %rq_cred18, align 8, !tbaa !62
  call void @put_rpccred(%struct.rpc_cred* %6)
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end14
  %rq_cred20 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 4
  store %struct.rpc_cred* %new.1, %struct.rpc_cred** %rq_cred20, align 8, !tbaa !62
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.then12
  %retval.0 = phi i32 [ %conv, %if.then12 ], [ 0, %if.end19 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_cred* @rpcauth_bind_root_cred(%struct.rpc_task* %task, i32 %lookupflags) #0 {
entry:
  %acred = alloca %struct.auth_cred, align 8
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %0 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %cl_auth = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 10
  %1 = load %struct.rpc_auth*, %struct.rpc_auth** %cl_auth, align 8, !tbaa !167
  %2 = bitcast %struct.auth_cred* %acred to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 32, i32 8, i1 false)
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %3, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %au_ops6 = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %1, i32 0, i32 4
  %5 = load %struct.rpc_authops*, %struct.rpc_authops** %au_ops6, align 8, !tbaa !173
  %lookup_cred = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %5, i32 0, i32 5
  %6 = load %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)*, %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)** %lookup_cred, align 8, !tbaa !217
  %call7 = call %struct.rpc_cred* %6(%struct.rpc_auth* %1, %struct.auth_cred* %acred, i32 %lookupflags)
  ret %struct.rpc_cred* %call7
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_cred* @rpcauth_bind_new_cred(%struct.rpc_task* %task, i32 %lookupflags) #0 {
entry:
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %0 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %cl_auth = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 10
  %1 = load %struct.rpc_auth*, %struct.rpc_auth** %cl_auth, align 8, !tbaa !167
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %call4 = call %struct.rpc_cred* @rpcauth_lookupcred(%struct.rpc_auth* %1, i32 %lookupflags)
  ret %struct.rpc_cred* %call4
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR.463(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define void @rpcauth_invalcred(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_cred = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 4
  %1 = load %struct.rpc_cred*, %struct.rpc_cred** %rq_cred, align 8, !tbaa !62
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tobool4 = icmp ne %struct.rpc_cred* %1, null
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %do.end
  %cr_flags = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %1, i32 0, i32 7
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %cr_flags, i32 1, i64* %cr_flags) #7, !srcloc !565
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @rpcauth_uptodatecred(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %rq_cred = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 4
  %1 = load %struct.rpc_cred*, %struct.rpc_cred** %rq_cred, align 8, !tbaa !62
  %cmp = icmp eq %struct.rpc_cred* %1, null
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %cr_flags = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %1, i32 0, i32 7
  %2 = load volatile i64, i64* %cr_flags, align 8, !tbaa !88
  %and.i = and i64 2, %2
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %cmp1 = icmp ne i32 %conv.i, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  %lor.ext = zext i1 %3 to i32
  ret i32 %lor.ext
}

; Function Attrs: nounwind uwtable
define i32 @rpcauth_init_module() #6 section ".init.text" {
entry:
  %call = call i32 @rpc_init_authunix()
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @rpc_init_generic_auth()
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %out2, label %if.end4

if.end4:                                          ; preds = %if.end
  call void @register_shrinker(%struct.shrinker* @rpc_cred_shrinker)
  br label %cleanup

out2:                                             ; preds = %if.end
  call void @rpc_destroy_authunix()
  br label %cleanup

cleanup:                                          ; preds = %out2, %if.end4, %entry
  %retval.0 = phi i32 [ 0, %if.end4 ], [ %call1, %out2 ], [ %call, %entry ]
  ret i32 %retval.0
}

declare void @register_shrinker(%struct.shrinker*) #4

; Function Attrs: nounwind uwtable
define internal i32 @rpcauth_cache_shrinker(%struct.shrinker* %shrink, %struct.device_dma_parameters* %sc) #0 {
entry:
  %free = alloca %struct.list_head, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %free, i32 0, i32 0
  store %struct.list_head* %free, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %free, i32 0, i32 1
  store %struct.list_head* %free, %struct.list_head** %prev, align 8, !tbaa !163
  %nr_to_scan1 = getelementptr inbounds %struct.device_dma_parameters, %struct.device_dma_parameters* %sc, i32 0, i32 1
  %0 = load i64, i64* %nr_to_scan1, align 8, !tbaa !609
  %conv = trunc i64 %0 to i32
  %gfp_mask2 = getelementptr inbounds %struct.device_dma_parameters, %struct.device_dma_parameters* %sc, i32 0, i32 0
  %1 = load i32, i32* %gfp_mask2, align 8, !tbaa !611
  %and = and i32 %1, 208
  %cmp = icmp ne i32 %and, 208
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %cmp4 = icmp eq i32 %conv, 0
  %cond = select i1 %cmp4, i32 0, i32 -1
  br label %cleanup

if.end:                                           ; preds = %entry
  %call = call i32 @list_empty.405(%struct.list_head* @cred_unused)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end7

if.end7:                                          ; preds = %if.end
  call void @spin_lock.409(%struct.spinlock* @rpc_credcache_lock)
  %call8 = call i32 @rpcauth_prune_expired(%struct.list_head* %free, i32 %conv)
  call void @spin_unlock.408(%struct.spinlock* @rpc_credcache_lock)
  call void @rpcauth_destroy_credlist(%struct.list_head* %free)
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %if.end, %if.then
  %retval.0 = phi i32 [ %cond, %if.then ], [ %call8, %if.end7 ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rpcauth_prune_expired(%struct.list_head* %free, i32 %nr_to_scan) #0 {
entry:
  %0 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %sub = sub i64 %0, 15000
  %1 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.list_head, %struct.list_head* @cred_unused, i32 0, i32 0), align 8, !tbaa !164
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -16
  %3 = bitcast i8* %add.ptr to %struct.rpc_cred*
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %.sink = phi %struct.rpc_cred* [ %6, %for.inc ], [ %3, %entry ]
  %cred.0 = phi %struct.rpc_cred* [ %3, %entry ], [ %6, %for.inc ]
  %nr_to_scan.addr.0 = phi i32 [ %nr_to_scan, %entry ], [ %dec, %for.inc ]
  %cr_lru59 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %.sink, i32 0, i32 1
  %next60 = getelementptr inbounds %struct.list_head, %struct.list_head* %cr_lru59, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next60, align 8, !tbaa !612
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr62 = getelementptr inbounds i8, i8* %5, i64 -16
  %6 = bitcast i8* %add.ptr62 to %struct.rpc_cred*
  %cr_lru5 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred.0, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %cr_lru5, @cred_unused
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %dec = add nsw i32 %nr_to_scan.addr.0, -1
  %cmp6 = icmp eq i32 %nr_to_scan.addr.0, 0
  br i1 %cmp6, label %for.end, label %if.end

if.end:                                           ; preds = %for.body
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.lhs.true, label %if.end42

land.lhs.true:                                    ; preds = %if.end
  %cr_expire = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred.0, i32 0, i32 6
  %7 = load i64, i64* %cr_expire, align 8, !tbaa !561
  %sub16 = sub nsw i64 %7, %sub
  %cmp17 = icmp sge i64 %sub16, 0
  br i1 %cmp17, label %land.lhs.true19, label %if.end42

land.lhs.true19:                                  ; preds = %land.lhs.true
  %tobool25 = icmp ne i32 1, 0
  br i1 %tobool25, label %land.lhs.true26, label %if.end42

land.lhs.true26:                                  ; preds = %land.lhs.true19
  %8 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %cr_expire34 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred.0, i32 0, i32 6
  %9 = load i64, i64* %cr_expire34, align 8, !tbaa !561
  %sub35 = sub nsw i64 %8, %9
  %cmp36 = icmp sge i64 %sub35, 0
  br i1 %cmp36, label %land.lhs.true38, label %if.end42

land.lhs.true38:                                  ; preds = %land.lhs.true26
  %cr_flags = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred.0, i32 0, i32 7
  %10 = load volatile i64, i64* %cr_flags, align 8, !tbaa !88
  %and.i = and i64 4, %10
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %cmp39 = icmp ne i32 %conv.i, 0
  br i1 %cmp39, label %cleanup, label %if.end42

if.end42:                                         ; preds = %land.lhs.true38, %land.lhs.true26, %land.lhs.true19, %land.lhs.true, %if.end
  %cr_lru43 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred.0, i32 0, i32 1
  call void @list_del_init.406(%struct.list_head* %cr_lru43)
  %11 = load i64, i64* @number_cred_unused, align 8, !tbaa !88
  %dec44 = add i64 %11, -1
  store i64 %dec44, i64* @number_cred_unused, align 8, !tbaa !88
  %cr_count = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred.0, i32 0, i32 8
  %call45 = call i32 @atomic_read.410(%struct.atomic_t* %cr_count)
  %cmp46 = icmp ne i32 %call45, 0
  br i1 %cmp46, label %for.inc, label %if.end49

if.end49:                                         ; preds = %if.end42
  %cr_auth = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred.0, i32 0, i32 3
  %12 = load %struct.rpc_auth*, %struct.rpc_auth** %cr_auth, align 8, !tbaa !65
  %au_credcache = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %12, i32 0, i32 7
  %13 = load %struct.rpc_cred_cache*, %struct.rpc_cred_cache** %au_credcache, align 8, !tbaa !563
  %lock = getelementptr inbounds %struct.rpc_cred_cache, %struct.rpc_cred_cache* %13, i32 0, i32 2
  call void @spin_lock.409(%struct.spinlock* %lock)
  %cr_count50 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred.0, i32 0, i32 8
  %call51 = call i32 @atomic_read.410(%struct.atomic_t* %cr_count50)
  %cmp52 = icmp eq i32 %call51, 0
  br i1 %cmp52, label %if.then54, label %if.end57

if.then54:                                        ; preds = %if.end49
  %call55 = call %struct.rpc_cred* @get_rpccred.415(%struct.rpc_cred* %cred.0)
  %cr_lru56 = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred.0, i32 0, i32 1
  call void @list_add_tail.407(%struct.list_head* %cr_lru56, %struct.list_head* %free)
  call void @rpcauth_unhash_cred_locked(%struct.rpc_cred* %cred.0)
  br label %if.end57

if.end57:                                         ; preds = %if.then54, %if.end49
  call void @spin_unlock.408(%struct.spinlock* %lock)
  br label %for.inc

for.inc:                                          ; preds = %if.end57, %if.end42
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %14 = load i64, i64* @number_cred_unused, align 8, !tbaa !88
  %div = udiv i64 %14, 100
  %15 = load i32, i32* @sysctl_vfs_cache_pressure, align 4, !tbaa !49
  %conv63 = sext i32 %15 to i64
  %mul = mul i64 %div, %conv63
  %conv64 = trunc i64 %mul to i32
  br label %cleanup

cleanup:                                          ; preds = %for.end, %land.lhs.true38
  %retval.0 = phi i32 [ %conv64, %for.end ], [ 0, %land.lhs.true38 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @rpcauth_remove_module() #0 {
entry:
  call void @rpc_destroy_authunix()
  call void @rpc_destroy_generic_auth()
  call void @unregister_shrinker(%struct.shrinker* @rpc_cred_shrinker)
  ret void
}

declare void @unregister_shrinker(%struct.shrinker*) #4

; Function Attrs: nounwind uwtable
define internal %struct.rpc_auth.2960* @nul_create(%struct.rpc_clnt.2966* %clnt, i32 %flavor) #0 {
entry:
  call void @atomic_inc.474(%struct.atomic_t* getelementptr inbounds (%struct.rpc_auth.2960, %struct.rpc_auth.2960* @null_auth, i32 0, i32 6))
  ret %struct.rpc_auth.2960* @null_auth
}

; Function Attrs: nounwind uwtable
define internal void @nul_destroy(%struct.rpc_auth.2960* %auth) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_cred.2963* @nul_lookup_cred(%struct.rpc_auth.2960* %auth, %struct.auth_cred* %acred, i32 %flags) #0 {
entry:
  %call = call %struct.rpc_cred.2963* @get_rpccred.473(%struct.rpc_cred.2963* @null_cred)
  ret %struct.rpc_cred.2963* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.rpc_cred.2963* @get_rpccred.473(%struct.rpc_cred.2963* %cred) #2 {
entry:
  %cr_count = getelementptr inbounds %struct.rpc_cred.2963, %struct.rpc_cred.2963* %cred, i32 0, i32 8
  call void @atomic_inc.474(%struct.atomic_t* %cr_count)
  ret %struct.rpc_cred.2963* %cred
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.474(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !613
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @nul_destroy_cred(%struct.rpc_cred.2963* %cred) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @nul_match(%struct.auth_cred* %acred, %struct.rpc_cred.2963* %cred, i32 %taskflags) #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32* @nul_marshal(%struct.rpc_task.2977* %task, i32* %p) #0 {
entry:
  %incdec.ptr = getelementptr inbounds i32, i32* %p, i32 1
  store i32 0, i32* %p, align 4, !tbaa !49
  %incdec.ptr1 = getelementptr inbounds i32, i32* %incdec.ptr, i32 1
  store i32 0, i32* %incdec.ptr, align 4, !tbaa !49
  %incdec.ptr2 = getelementptr inbounds i32, i32* %incdec.ptr1, i32 1
  store i32 0, i32* %incdec.ptr1, align 4, !tbaa !49
  %incdec.ptr3 = getelementptr inbounds i32, i32* %incdec.ptr2, i32 1
  store i32 0, i32* %incdec.ptr2, align 4, !tbaa !49
  ret i32* %incdec.ptr3
}

; Function Attrs: nounwind uwtable
define internal i32 @nul_refresh(%struct.rpc_task.2977* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task.2977, %struct.rpc_task.2977* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst.2981*, %struct.rpc_rqst.2981** %tk_rqstp, align 8, !tbaa !60
  %rq_cred = getelementptr inbounds %struct.rpc_rqst.2981, %struct.rpc_rqst.2981* %0, i32 0, i32 4
  %1 = load %struct.rpc_cred.2963*, %struct.rpc_cred.2963** %rq_cred, align 8, !tbaa !62
  %cr_flags = getelementptr inbounds %struct.rpc_cred.2963, %struct.rpc_cred.2963* %1, i32 0, i32 7
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %cr_flags, i32 1, i64* %cr_flags) #7, !srcloc !614
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32* @nul_validate(%struct.rpc_task.2977* %task, i32* %p) #0 {
entry:
  %incdec.ptr = getelementptr inbounds i32, i32* %p, i32 1
  %0 = load i32, i32* %p, align 4, !tbaa !49
  %call = call i32 @__fswab32.476(i32 %0) #3
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  %incdec.ptr2 = getelementptr inbounds i32, i32* %incdec.ptr, i32 1
  %2 = load i32, i32* %incdec.ptr, align 4, !tbaa !49
  %call3 = call i32 @__fswab32.476(i32 %2) #3
  %cmp4 = icmp ne i32 %call3, 0
  br i1 %cmp4, label %if.then5, label %cleanup

if.then5:                                         ; preds = %if.end
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then5, %if.end, %if.then
  %retval.0 = phi i32* [ null, %if.then ], [ null, %if.then5 ], [ %incdec.ptr2, %if.end ]
  ret i32* %retval.0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__fswab32.476(i32 %val) #5 {
entry:
  %call = call i32 @__arch_swab32.479(i32 %val) #3
  ret i32 %call
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__arch_swab32.479(i32 %val) #5 {
entry:
  %0 = call i32 asm "bswapl $0", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %val) #3, !srcloc !615
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_auth.2989* @unx_create(%struct.rpc_clnt.2994* %clnt, i32 %flavor) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  call void @atomic_inc.498(%struct.atomic_t* getelementptr inbounds (%struct.rpc_auth.2989, %struct.rpc_auth.2989* @unix_auth, i32 0, i32 6))
  ret %struct.rpc_auth.2989* @unix_auth
}

; Function Attrs: nounwind uwtable
define internal void @unx_destroy(%struct.rpc_auth.2989* %auth) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %au_credcache = getelementptr inbounds %struct.rpc_auth.2989, %struct.rpc_auth.2989* %auth, i32 0, i32 7
  %2 = load %struct.rpc_cred_cache*, %struct.rpc_cred_cache** %au_credcache, align 8, !tbaa !563
  call void @rpcauth_clear_credcache(%struct.rpc_cred_cache* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_cred.2995* @unx_lookup_cred(%struct.rpc_auth.2989* %auth, %struct.auth_cred* %acred, i32 %flags) #0 {
entry:
  %call = call %struct.rpc_cred.2995* bitcast (%struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)* @rpcauth_lookup_credcache to %struct.rpc_cred.2995* (%struct.rpc_auth.2989*, %struct.auth_cred*, i32)*)(%struct.rpc_auth.2989* %auth, %struct.auth_cred* %acred, i32 %flags)
  ret %struct.rpc_cred.2995* %call
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_cred.2995* @unx_create_cred(%struct.rpc_auth.2989* %auth, %struct.auth_cred* %acred, i32 %flags) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %uid = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 0
  %1 = load i32, i32* %uid, align 8, !tbaa !570
  %2 = call i32 @from_kuid.484(i32 %1)
  %gid = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 1
  %3 = load i32, i32* %gid, align 4, !tbaa !600
  %4 = call i32 @from_kgid(i32 %3)
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %call.i = call i8* @__kmalloc(i64 168, i32 80) #7
  %6 = bitcast i8* %call.i to %struct.unx_cred*
  %tobool6 = icmp ne %struct.unx_cred* %6, null
  br i1 %tobool6, label %if.end9, label %if.then7

if.then7:                                         ; preds = %do.end
  %call8 = call i8* @ERR_PTR.487(i64 -12)
  %7 = bitcast i8* %call8 to %struct.rpc_cred.2995*
  br label %cleanup

if.end9:                                          ; preds = %do.end
  %uc_base = getelementptr inbounds %struct.unx_cred, %struct.unx_cred* %6, i32 0, i32 0
  call void bitcast (void (%struct.rpc_cred*, %struct.auth_cred*, %struct.rpc_auth*, %struct.rpc_credops*)* @rpcauth_init_cred to void (%struct.rpc_cred.2995*, %struct.auth_cred*, %struct.rpc_auth.2989*, %struct.rpc_credops.3486*)*)(%struct.rpc_cred.2995* %uc_base, %struct.auth_cred* %acred, %struct.rpc_auth.2989* %auth, %struct.rpc_credops.3486* @unix_credops)
  %uc_base10 = getelementptr inbounds %struct.unx_cred, %struct.unx_cred* %6, i32 0, i32 0
  %cr_flags = getelementptr inbounds %struct.rpc_cred.2995, %struct.rpc_cred.2995* %uc_base10, i32 0, i32 7
  store i64 2, i64* %cr_flags, align 8, !tbaa !616
  %group_info = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 2
  %8 = load %struct.group_info*, %struct.group_info** %group_info, align 8, !tbaa !602
  %cmp = icmp ne %struct.group_info* %8, null
  br i1 %cmp, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end9
  %group_info13 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 2
  %9 = load %struct.group_info*, %struct.group_info** %group_info13, align 8, !tbaa !602
  %ngroups = getelementptr inbounds %struct.group_info, %struct.group_info* %9, i32 0, i32 1
  %10 = load i32, i32* %ngroups, align 4, !tbaa !618
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end9
  %groups.0 = phi i32 [ %10, %if.then12 ], [ 0, %if.end9 ]
  %cmp15 = icmp ugt i32 %groups.0, 16
  %.groups.0 = select i1 %cmp15, i32 16, i32 %groups.0
  %gid19 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 1
  %11 = load i32, i32* %gid19, align 4, !tbaa !600
  %uc_gid = getelementptr inbounds %struct.unx_cred, %struct.unx_cred* %6, i32 0, i32 1
  store i32 %11, i32* %uc_gid, align 8, !tbaa !620
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end14
  %i.0 = phi i32 [ 0, %if.end14 ], [ %inc, %for.body ]
  %cmp20 = icmp ult i32 %i.0, %.groups.0
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %group_info22 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 2
  %12 = load %struct.group_info*, %struct.group_info** %group_info22, align 8, !tbaa !602
  %blocks = getelementptr inbounds %struct.group_info, %struct.group_info* %12, i32 0, i32 4
  %div = udiv i32 %i.0, 1024
  %idxprom = zext i32 %div to i64
  %arrayidx = getelementptr inbounds [0 x i32*], [0 x i32*]* %blocks, i64 0, i64 %idxprom
  %13 = load i32*, i32** %arrayidx, align 8, !tbaa !28
  %rem = urem i32 %i.0, 1024
  %idxprom23 = zext i32 %rem to i64
  %arrayidx24 = getelementptr inbounds i32, i32* %13, i64 %idxprom23
  %14 = load i32, i32* %arrayidx24, align 4, !tbaa !49
  %uc_gids = getelementptr inbounds %struct.unx_cred, %struct.unx_cred* %6, i32 0, i32 2
  %idxprom25 = zext i32 %i.0 to i64
  %arrayidx26 = getelementptr inbounds [16 x i32], [16 x i32]* %uc_gids, i64 0, i64 %idxprom25
  store i32 %14, i32* %arrayidx26, align 4, !tbaa !49
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %cmp27 = icmp ult i32 %i.0, 16
  br i1 %cmp27, label %if.then29, label %if.end33

if.then29:                                        ; preds = %for.end
  %uc_gids30 = getelementptr inbounds %struct.unx_cred, %struct.unx_cred* %6, i32 0, i32 2
  %idxprom31 = zext i32 %i.0 to i64
  %arrayidx32 = getelementptr inbounds [16 x i32], [16 x i32]* %uc_gids30, i64 0, i64 %idxprom31
  store i32 -1, i32* %arrayidx32, align 4, !tbaa !49
  br label %if.end33

if.end33:                                         ; preds = %if.then29, %for.end
  %uc_base34 = getelementptr inbounds %struct.unx_cred, %struct.unx_cred* %6, i32 0, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end33, %if.then7
  %retval.0 = phi %struct.rpc_cred.2995* [ %uc_base34, %if.end33 ], [ %7, %if.then7 ]
  ret %struct.rpc_cred.2995* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @from_kuid.484(i32 %kuid) #2 {
entry:
  %call = call i32 @__kuid_val.494(i32 %kuid)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @from_kgid(i32 %kgid) #2 {
entry:
  %call = call i32 @__kgid_val(i32 %kgid)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR.487(i64 %error) #2 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal void @unx_destroy_cred(%struct.rpc_cred.2995* %cred) #0 {
entry:
  %cr_rcu = getelementptr inbounds %struct.rpc_cred.2995, %struct.rpc_cred.2995* %cred, i32 0, i32 2
  call void @call_rcu_sched(%struct.callback_head* %cr_rcu, void (%struct.callback_head*)* @unx_free_cred_callback)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @unx_match(%struct.auth_cred* %acred, %struct.rpc_cred.2995* %rcred, i32 %flags) #0 {
entry:
  %0 = bitcast %struct.rpc_cred.2995* %rcred to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.unx_cred*
  %uc_base = getelementptr inbounds %struct.unx_cred, %struct.unx_cred* %1, i32 0, i32 0
  %cr_uid = getelementptr inbounds %struct.rpc_cred.2995, %struct.rpc_cred.2995* %uc_base, i32 0, i32 9
  %2 = load i32, i32* %cr_uid, align 4, !tbaa !621
  %uid = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 0
  %3 = load i32, i32* %uid, align 8, !tbaa !570
  %call = call zeroext i1 @uid_eq(i32 %2, i32 %3)
  br i1 %call, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %uc_gid = getelementptr inbounds %struct.unx_cred, %struct.unx_cred* %1, i32 0, i32 1
  %4 = load i32, i32* %uc_gid, align 8, !tbaa !620
  %gid = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 1
  %5 = load i32, i32* %gid, align 4, !tbaa !600
  %call1 = call zeroext i1 @gid_eq(i32 %4, i32 %5)
  br i1 %call1, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %group_info = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 2
  %6 = load %struct.group_info*, %struct.group_info** %group_info, align 8, !tbaa !602
  %cmp = icmp ne %struct.group_info* %6, null
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %group_info3 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 2
  %7 = load %struct.group_info*, %struct.group_info** %group_info3, align 8, !tbaa !602
  %ngroups = getelementptr inbounds %struct.group_info, %struct.group_info* %7, i32 0, i32 1
  %8 = load i32, i32* %ngroups, align 4, !tbaa !618
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %groups.0 = phi i32 [ %8, %if.then2 ], [ 0, %if.end ]
  %cmp5 = icmp ugt i32 %groups.0, 16
  %.groups.0 = select i1 %cmp5, i32 16, i32 %groups.0
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %i.0 = phi i32 [ 0, %if.end4 ], [ %inc, %for.inc ]
  %cmp8 = icmp ult i32 %i.0, %.groups.0
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %uc_gids = getelementptr inbounds %struct.unx_cred, %struct.unx_cred* %1, i32 0, i32 2
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i32], [16 x i32]* %uc_gids, i64 0, i64 %idxprom
  %9 = load i32, i32* %arrayidx, align 4, !tbaa !49
  %group_info9 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 2
  %10 = load %struct.group_info*, %struct.group_info** %group_info9, align 8, !tbaa !602
  %blocks = getelementptr inbounds %struct.group_info, %struct.group_info* %10, i32 0, i32 4
  %div = udiv i32 %i.0, 1024
  %idxprom10 = zext i32 %div to i64
  %arrayidx11 = getelementptr inbounds [0 x i32*], [0 x i32*]* %blocks, i64 0, i64 %idxprom10
  %11 = load i32*, i32** %arrayidx11, align 8, !tbaa !28
  %rem = urem i32 %i.0, 1024
  %idxprom12 = zext i32 %rem to i64
  %arrayidx13 = getelementptr inbounds i32, i32* %11, i64 %idxprom12
  %12 = load i32, i32* %arrayidx13, align 4, !tbaa !49
  %call14 = call zeroext i1 @gid_eq(i32 %9, i32 %12)
  br i1 %call14, label %for.inc, label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %cmp17 = icmp ult i32 %.groups.0, 16
  br i1 %cmp17, label %land.lhs.true, label %if.end23

land.lhs.true:                                    ; preds = %for.end
  %uc_gids18 = getelementptr inbounds %struct.unx_cred, %struct.unx_cred* %1, i32 0, i32 2
  %idxprom19 = zext i32 %.groups.0 to i64
  %arrayidx20 = getelementptr inbounds [16 x i32], [16 x i32]* %uc_gids18, i64 0, i64 %idxprom19
  %13 = load i32, i32* %arrayidx20, align 4, !tbaa !49
  %call21 = call zeroext i1 @gid_valid(i32 %13)
  br i1 %call21, label %cleanup, label %if.end23

if.end23:                                         ; preds = %land.lhs.true, %for.end
  br label %cleanup

cleanup:                                          ; preds = %if.end23, %land.lhs.true, %for.body, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ 1, %if.end23 ], [ 0, %lor.lhs.false ], [ 0, %entry ], [ 0, %for.body ], [ 0, %land.lhs.true ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32* @unx_marshal(%struct.rpc_task.3476* %task, i32* %p) #0 {
entry:
  %tk_client = getelementptr inbounds %struct.rpc_task.3476, %struct.rpc_task.3476* %task, i32 0, i32 2
  %0 = load %struct.rpc_clnt.2994*, %struct.rpc_clnt.2994** %tk_client, align 8, !tbaa !26
  %tk_rqstp = getelementptr inbounds %struct.rpc_task.3476, %struct.rpc_task.3476* %task, i32 0, i32 3
  %1 = load %struct.rpc_rqst.3481*, %struct.rpc_rqst.3481** %tk_rqstp, align 8, !tbaa !60
  %rq_cred = getelementptr inbounds %struct.rpc_rqst.3481, %struct.rpc_rqst.3481* %1, i32 0, i32 4
  %2 = load %struct.rpc_cred.2995*, %struct.rpc_cred.2995** %rq_cred, align 8, !tbaa !62
  %3 = bitcast %struct.rpc_cred.2995* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.unx_cred*
  %incdec.ptr = getelementptr inbounds i32, i32* %p, i32 1
  store i32 16777216, i32* %p, align 4, !tbaa !49
  %incdec.ptr1 = getelementptr inbounds i32, i32* %incdec.ptr, i32 1
  %5 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %div = udiv i64 %5, 250
  %conv = trunc i64 %div to i32
  %call = call i32 @__fswab32.489(i32 %conv) #3
  %incdec.ptr2 = getelementptr inbounds i32, i32* %incdec.ptr1, i32 1
  store i32 %call, i32* %incdec.ptr1, align 4, !tbaa !49
  %cl_nodename = getelementptr inbounds %struct.rpc_clnt.2994, %struct.rpc_clnt.2994* %0, i32 0, i32 17
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %cl_nodename, i32 0, i32 0
  %cl_nodelen = getelementptr inbounds %struct.rpc_clnt.2994, %struct.rpc_clnt.2994* %0, i32 0, i32 16
  %6 = load i32, i32* %cl_nodelen, align 8, !tbaa !244
  %call3 = call i32* @xdr_encode_array(i32* %incdec.ptr2, i8* %arraydecay, i32 %6)
  %uc_base = getelementptr inbounds %struct.unx_cred, %struct.unx_cred* %4, i32 0, i32 0
  %cr_uid = getelementptr inbounds %struct.rpc_cred.2995, %struct.rpc_cred.2995* %uc_base, i32 0, i32 9
  %7 = load i32, i32* %cr_uid, align 4, !tbaa !621
  %call4 = call i32 @from_kuid.484(i32 %7)
  %call5 = call i32 @__fswab32.489(i32 %call4) #3
  %incdec.ptr6 = getelementptr inbounds i32, i32* %call3, i32 1
  store i32 %call5, i32* %call3, align 4, !tbaa !49
  %uc_gid = getelementptr inbounds %struct.unx_cred, %struct.unx_cred* %4, i32 0, i32 1
  %8 = load i32, i32* %uc_gid, align 8, !tbaa !620
  %call7 = call i32 @from_kgid(i32 %8)
  %call8 = call i32 @__fswab32.489(i32 %call7) #3
  %incdec.ptr9 = getelementptr inbounds i32, i32* %incdec.ptr6, i32 1
  store i32 %call8, i32* %incdec.ptr6, align 4, !tbaa !49
  %incdec.ptr10 = getelementptr inbounds i32, i32* %incdec.ptr9, i32 1
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %p.addr.0 = phi i32* [ %incdec.ptr10, %entry ], [ %incdec.ptr19, %for.body ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 16
  br i1 %cmp, label %land.rhs, label %for.end

land.rhs:                                         ; preds = %for.cond
  %uc_gids = getelementptr inbounds %struct.unx_cred, %struct.unx_cred* %4, i32 0, i32 2
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i32], [16 x i32]* %uc_gids, i64 0, i64 %idxprom
  %9 = load i32, i32* %arrayidx, align 4, !tbaa !49
  %call12 = call zeroext i1 @gid_valid(i32 %9)
  br i1 %call12, label %for.body, label %for.end

for.body:                                         ; preds = %land.rhs
  %uc_gids14 = getelementptr inbounds %struct.unx_cred, %struct.unx_cred* %4, i32 0, i32 2
  %idxprom15 = sext i32 %i.0 to i64
  %arrayidx16 = getelementptr inbounds [16 x i32], [16 x i32]* %uc_gids14, i64 0, i64 %idxprom15
  %10 = load i32, i32* %arrayidx16, align 4, !tbaa !49
  %call17 = call i32 @from_kgid(i32 %10)
  %call18 = call i32 @__fswab32.489(i32 %call17) #3
  %incdec.ptr19 = getelementptr inbounds i32, i32* %p.addr.0, i32 1
  store i32 %call18, i32* %p.addr.0, align 4, !tbaa !49
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %land.rhs, %for.cond
  %sub.ptr.lhs.cast = ptrtoint i32* %p.addr.0 to i64
  %sub.ptr.rhs.cast = ptrtoint i32* %incdec.ptr9 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %sub = sub nsw i64 %sub.ptr.div, 1
  %conv20 = trunc i64 %sub to i32
  %call21 = call i32 @__fswab32.489(i32 %conv20) #3
  store i32 %call21, i32* %incdec.ptr9, align 4, !tbaa !49
  %sub.ptr.lhs.cast22 = ptrtoint i32* %p.addr.0 to i64
  %sub.ptr.rhs.cast23 = ptrtoint i32* %incdec.ptr to i64
  %sub.ptr.sub24 = sub i64 %sub.ptr.lhs.cast22, %sub.ptr.rhs.cast23
  %sub.ptr.div25 = sdiv exact i64 %sub.ptr.sub24, 4
  %sub26 = sub nsw i64 %sub.ptr.div25, 1
  %shl = shl i64 %sub26, 2
  %conv27 = trunc i64 %shl to i32
  %call28 = call i32 @__fswab32.489(i32 %conv27) #3
  store i32 %call28, i32* %incdec.ptr, align 4, !tbaa !49
  %incdec.ptr29 = getelementptr inbounds i32, i32* %p.addr.0, i32 1
  store i32 0, i32* %p.addr.0, align 4, !tbaa !49
  %incdec.ptr30 = getelementptr inbounds i32, i32* %incdec.ptr29, i32 1
  store i32 0, i32* %incdec.ptr29, align 4, !tbaa !49
  ret i32* %incdec.ptr30
}

; Function Attrs: nounwind uwtable
define internal i32 @unx_refresh(%struct.rpc_task.3476* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task.3476, %struct.rpc_task.3476* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst.3481*, %struct.rpc_rqst.3481** %tk_rqstp, align 8, !tbaa !60
  %rq_cred = getelementptr inbounds %struct.rpc_rqst.3481, %struct.rpc_rqst.3481* %0, i32 0, i32 4
  %1 = load %struct.rpc_cred.2995*, %struct.rpc_cred.2995** %rq_cred, align 8, !tbaa !62
  %cr_flags = getelementptr inbounds %struct.rpc_cred.2995, %struct.rpc_cred.2995* %1, i32 0, i32 7
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %cr_flags, i32 1, i64* %cr_flags) #7, !srcloc !622
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32* @unx_validate(%struct.rpc_task.3476* %task, i32* %p) #0 {
entry:
  %incdec.ptr = getelementptr inbounds i32, i32* %p, i32 1
  %0 = load i32, i32* %p, align 4, !tbaa !49
  %call = call i32 @__fswab32.489(i32 %0) #3
  %switch = icmp ult i32 %call, 3
  br i1 %switch, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  %incdec.ptr5 = getelementptr inbounds i32, i32* %incdec.ptr, i32 1
  %2 = load i32, i32* %incdec.ptr, align 4, !tbaa !49
  %call6 = call i32 @__fswab32.489(i32 %2) #3
  %cmp7 = icmp ugt i32 %call6, 400
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end10:                                         ; preds = %if.end
  %shr = lshr i32 %call6, 2
  %add = add i32 %shr, 2
  %tk_rqstp = getelementptr inbounds %struct.rpc_task.3476, %struct.rpc_task.3476* %task, i32 0, i32 3
  %4 = load %struct.rpc_rqst.3481*, %struct.rpc_rqst.3481** %tk_rqstp, align 8, !tbaa !60
  %rq_cred = getelementptr inbounds %struct.rpc_rqst.3481, %struct.rpc_rqst.3481* %4, i32 0, i32 4
  %5 = load %struct.rpc_cred.2995*, %struct.rpc_cred.2995** %rq_cred, align 8, !tbaa !62
  %cr_auth = getelementptr inbounds %struct.rpc_cred.2995, %struct.rpc_cred.2995* %5, i32 0, i32 3
  %6 = load %struct.rpc_auth.2989*, %struct.rpc_auth.2989** %cr_auth, align 8, !tbaa !65
  %au_rslack = getelementptr inbounds %struct.rpc_auth.2989, %struct.rpc_auth.2989* %6, i32 0, i32 1
  store i32 %add, i32* %au_rslack, align 4, !tbaa !623
  %shr11 = lshr i32 %call6, 2
  %idx.ext = zext i32 %shr11 to i64
  %add.ptr = getelementptr inbounds i32, i32* %incdec.ptr5, i64 %idx.ext
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.then8, %if.then
  %retval.0 = phi i32* [ null, %if.then ], [ null, %if.then8 ], [ %add.ptr, %if.end10 ]
  ret i32* %retval.0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__fswab32.489(i32 %val) #5 {
entry:
  %call = call i32 @__arch_swab32.492(i32 %val) #3
  ret i32 %call
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__arch_swab32.492(i32 %val) #5 {
entry:
  %0 = call i32 asm "bswapl $0", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %val) #3, !srcloc !624
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32* @xdr_encode_array(i32* %p, i8* %s, i32 %len) #2 {
entry:
  %call = call i32* @xdr_encode_opaque(i32* %p, i8* %s, i32 %len)
  ret i32* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @gid_valid(i32 %gid) #2 {
entry:
  %call = call zeroext i1 @gid_eq(i32 %gid, i32 -1)
  %lnot = xor i1 %call, true
  ret i1 %lnot
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @gid_eq(i32 %left, i32 %right) #2 {
entry:
  %call = call i32 @__kgid_val(i32 %left)
  %call1 = call i32 @__kgid_val(i32 %right)
  %cmp = icmp eq i32 %call, %call1
  ret i1 %cmp
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__kgid_val(i32 %gid) #2 {
entry:
  ret i32 %gid
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @uid_eq(i32 %left, i32 %right) #2 {
entry:
  %call = call i32 @__kuid_val.494(i32 %left)
  %call1 = call i32 @__kuid_val.494(i32 %right)
  %cmp = icmp eq i32 %call, %call1
  ret i1 %cmp
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__kuid_val.494(i32 %uid) #2 {
entry:
  ret i32 %uid
}

; Function Attrs: nounwind uwtable
define internal void @unx_free_cred_callback(%struct.callback_head* %head) #0 {
entry:
  %0 = bitcast %struct.callback_head* %head to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -32
  %1 = bitcast i8* %add.ptr to %struct.unx_cred*
  call void @unx_free_cred(%struct.unx_cred* %1)
  ret void
}

declare void @call_rcu_sched(%struct.callback_head*, void (%struct.callback_head*)*) #4

; Function Attrs: nounwind uwtable
define internal void @unx_free_cred(%struct.unx_cred* %unx_cred) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %2 = bitcast %struct.unx_cred* %unx_cred to i8*
  call void @kfree(i8* %2)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.498(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !625
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @rpc_init_authunix() #6 section ".init.text" {
entry:
  %call = call i32 bitcast (i32 (%struct.rpc_auth*)* @rpcauth_init_credcache to i32 (%struct.rpc_auth.2989*)*)(%struct.rpc_auth.2989* @unix_auth)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define void @rpc_destroy_authunix() #0 {
entry:
  call void bitcast (void (%struct.rpc_auth*)* @rpcauth_destroy_credcache to void (%struct.rpc_auth.2989*)*)(%struct.rpc_auth.2989* @unix_auth)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.rpc_cred* @rpc_lookup_machine_cred(i8* %service_name) #0 {
entry:
  %acred = alloca %struct.auth_cred, align 8
  %uid = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 0
  store i32 0, i32* %uid, align 8, !tbaa !570
  %gid = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 1
  store i32 0, i32* %gid, align 4, !tbaa !600
  %group_info = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 2
  store %struct.group_info* null, %struct.group_info** %group_info, align 8, !tbaa !602
  %principal = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 3
  store i8* %service_name, i8** %principal, align 8, !tbaa !626
  %machine_cred = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 4
  %bf.load = load i8, i8* %machine_cred, align 8
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %machine_cred, align 8
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %2 = load %struct.rpc_authops*, %struct.rpc_authops** getelementptr inbounds (%struct.rpc_auth, %struct.rpc_auth* @generic_auth, i32 0, i32 4), align 8, !tbaa !173
  %lookup_cred = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %2, i32 0, i32 5
  %3 = load %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)*, %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)** %lookup_cred, align 8, !tbaa !217
  %call3 = call %struct.rpc_cred* %3(%struct.rpc_auth* @generic_auth, %struct.auth_cred* %acred, i32 0)
  ret %struct.rpc_cred* %call3
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_cred* @generic_lookup_cred(%struct.rpc_auth* %auth, %struct.auth_cred* %acred, i32 %flags) #0 {
entry:
  %call = call %struct.rpc_cred* @rpcauth_lookup_credcache(%struct.rpc_auth* @generic_auth, %struct.auth_cred* %acred, i32 %flags)
  ret %struct.rpc_cred* %call
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_cred* @generic_create_cred(%struct.rpc_auth* %auth, %struct.auth_cred* %acred, i32 %flags) #0 {
entry:
  %call.i = call i8* @__kmalloc(i64 128, i32 208) #7
  %0 = bitcast i8* %call.i to %struct.generic_cred*
  %cmp = icmp eq %struct.generic_cred* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i8* @ERR_PTR.507(i64 -12)
  %1 = bitcast i8* %call1 to %struct.rpc_cred*
  br label %cleanup

if.end:                                           ; preds = %entry
  %gc_base = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %0, i32 0, i32 0
  call void @rpcauth_init_cred(%struct.rpc_cred* %gc_base, %struct.auth_cred* %acred, %struct.rpc_auth* @generic_auth, %struct.rpc_credops* @generic_credops)
  %gc_base2 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %0, i32 0, i32 0
  %cr_flags = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %gc_base2, i32 0, i32 7
  store i64 2, i64* %cr_flags, align 8, !tbaa !627
  %uid = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 0
  %2 = load i32, i32* %uid, align 8, !tbaa !570
  %acred3 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %0, i32 0, i32 1
  %uid4 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred3, i32 0, i32 0
  store i32 %2, i32* %uid4, align 8, !tbaa !629
  %gid = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 1
  %3 = load i32, i32* %gid, align 4, !tbaa !600
  %acred5 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %0, i32 0, i32 1
  %gid6 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred5, i32 0, i32 1
  store i32 %3, i32* %gid6, align 4, !tbaa !630
  %group_info = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 2
  %4 = load %struct.group_info*, %struct.group_info** %group_info, align 8, !tbaa !602
  %acred7 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %0, i32 0, i32 1
  %group_info8 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred7, i32 0, i32 2
  store %struct.group_info* %4, %struct.group_info** %group_info8, align 8, !tbaa !631
  %acred9 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %0, i32 0, i32 1
  %group_info10 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred9, i32 0, i32 2
  %5 = load %struct.group_info*, %struct.group_info** %group_info10, align 8, !tbaa !631
  %cmp11 = icmp ne %struct.group_info* %5, null
  br i1 %cmp11, label %if.then12, label %if.end16

if.then12:                                        ; preds = %if.end
  %acred13 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %0, i32 0, i32 1
  %group_info14 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred13, i32 0, i32 2
  %6 = load %struct.group_info*, %struct.group_info** %group_info14, align 8, !tbaa !631
  call void @get_group_info.508(%struct.group_info* %6)
  br label %if.end16

if.end16:                                         ; preds = %if.then12, %if.end
  %machine_cred = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 4
  %bf.load = load i8, i8* %machine_cred, align 8
  %bf.clear = and i8 %bf.load, 1
  %acred17 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %0, i32 0, i32 1
  %machine_cred18 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred17, i32 0, i32 4
  %bf.load19 = load i8, i8* %machine_cred18, align 8
  %bf.value = and i8 %bf.clear, 1
  %bf.clear20 = and i8 %bf.load19, -2
  %bf.set = or i8 %bf.clear20, %bf.value
  store i8 %bf.set, i8* %machine_cred18, align 8
  %principal = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 3
  %7 = load i8*, i8** %principal, align 8, !tbaa !626
  %acred21 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %0, i32 0, i32 1
  %principal22 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred21, i32 0, i32 3
  store i8* %7, i8** %principal22, align 8, !tbaa !632
  %8 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %8, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot23 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot23 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool24 = icmp ne i64 %expval, 0
  br i1 %tobool24, label %if.then25, label %do.end

if.then25:                                        ; preds = %if.end16
  %uid32 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 0
  %9 = load i32, i32* %uid32, align 8, !tbaa !570
  call void @from_kuid.511(i32 %9)
  %gid34 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 1
  %10 = load i32, i32* %gid34, align 4, !tbaa !600
  call void @from_kgid.512(i32 %10)
  %11 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then25, %if.end16
  %gc_base38 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %0, i32 0, i32 0
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  %retval.0 = phi %struct.rpc_cred* [ %1, %if.then ], [ %gc_base38, %do.end ]
  ret %struct.rpc_cred* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR.507(i64 %error) #2 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @get_group_info.508(%struct.group_info* %gi) #2 {
entry:
  %usage = getelementptr inbounds %struct.group_info, %struct.group_info* %gi, i32 0, i32 0
  call void @atomic_inc.516(%struct.atomic_t* %usage)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @from_kuid.511(i32 %kuid) #2 {
entry:
  %call = call i32 @__kuid_val.515(i32 %kuid)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @from_kgid.512(i32 %kgid) #2 {
entry:
  %call = call i32 @__kgid_val.514(i32 %kgid)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__kgid_val.514(i32 %gid) #2 {
entry:
  ret i32 %gid
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__kuid_val.515(i32 %uid) #2 {
entry:
  ret i32 %uid
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.516(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !633
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @generic_destroy_cred(%struct.rpc_cred* %cred) #0 {
entry:
  %cr_rcu = getelementptr inbounds %struct.rpc_cred, %struct.rpc_cred* %cred, i32 0, i32 2
  call void @call_rcu_sched(%struct.callback_head* %cr_rcu, void (%struct.callback_head*)* @generic_free_cred_callback)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @generic_match(%struct.auth_cred* %acred, %struct.rpc_cred* %cred, i32 %flags) #0 {
entry:
  %0 = bitcast %struct.rpc_cred* %cred to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.generic_cred*
  %machine_cred = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 4
  %bf.load = load i8, i8* %machine_cred, align 8
  %bf.clear = and i8 %bf.load, 1
  %tobool = icmp ne i8 %bf.clear, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @machine_cred_match(%struct.auth_cred* %acred, %struct.generic_cred* %1)
  br label %cleanup

if.end:                                           ; preds = %entry
  %acred1 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %1, i32 0, i32 1
  %uid = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred1, i32 0, i32 0
  %2 = load i32, i32* %uid, align 8, !tbaa !629
  %uid2 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 0
  %3 = load i32, i32* %uid2, align 8, !tbaa !570
  %call3 = call zeroext i1 @uid_eq.518(i32 %2, i32 %3)
  br i1 %call3, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end
  %acred4 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %1, i32 0, i32 1
  %gid = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred4, i32 0, i32 1
  %4 = load i32, i32* %gid, align 4, !tbaa !630
  %gid5 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 1
  %5 = load i32, i32* %gid5, align 4, !tbaa !600
  %call6 = call zeroext i1 @gid_eq.519(i32 %4, i32 %5)
  br i1 %call6, label %lor.lhs.false7, label %cleanup

lor.lhs.false7:                                   ; preds = %lor.lhs.false
  %acred8 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %1, i32 0, i32 1
  %machine_cred9 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred8, i32 0, i32 4
  %bf.load10 = load i8, i8* %machine_cred9, align 8
  %bf.clear11 = and i8 %bf.load10, 1
  %conv = zext i8 %bf.clear11 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %cleanup, label %if.end14

if.end14:                                         ; preds = %lor.lhs.false7
  %acred15 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %1, i32 0, i32 1
  %group_info = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred15, i32 0, i32 2
  %6 = load %struct.group_info*, %struct.group_info** %group_info, align 8, !tbaa !631
  %group_info16 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 2
  %7 = load %struct.group_info*, %struct.group_info** %group_info16, align 8, !tbaa !602
  %cmp17 = icmp eq %struct.group_info* %6, %7
  br i1 %cmp17, label %cleanup, label %if.end20

if.end20:                                         ; preds = %if.end14
  %acred21 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %1, i32 0, i32 1
  %group_info22 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred21, i32 0, i32 2
  %8 = load %struct.group_info*, %struct.group_info** %group_info22, align 8, !tbaa !631
  %ngroups = getelementptr inbounds %struct.group_info, %struct.group_info* %8, i32 0, i32 1
  %9 = load i32, i32* %ngroups, align 4, !tbaa !618
  %group_info23 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 2
  %10 = load %struct.group_info*, %struct.group_info** %group_info23, align 8, !tbaa !602
  %ngroups24 = getelementptr inbounds %struct.group_info, %struct.group_info* %10, i32 0, i32 1
  %11 = load i32, i32* %ngroups24, align 4, !tbaa !618
  %cmp25 = icmp ne i32 %9, %11
  br i1 %cmp25, label %cleanup, label %if.end28

if.end28:                                         ; preds = %if.end20
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end28
  %i.0 = phi i32 [ 0, %if.end28 ], [ %inc, %for.inc ]
  %acred29 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %1, i32 0, i32 1
  %group_info30 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred29, i32 0, i32 2
  %12 = load %struct.group_info*, %struct.group_info** %group_info30, align 8, !tbaa !631
  %ngroups31 = getelementptr inbounds %struct.group_info, %struct.group_info* %12, i32 0, i32 1
  %13 = load i32, i32* %ngroups31, align 4, !tbaa !618
  %cmp32 = icmp slt i32 %i.0, %13
  br i1 %cmp32, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %acred34 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %1, i32 0, i32 1
  %group_info35 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred34, i32 0, i32 2
  %14 = load %struct.group_info*, %struct.group_info** %group_info35, align 8, !tbaa !631
  %blocks = getelementptr inbounds %struct.group_info, %struct.group_info* %14, i32 0, i32 4
  %div = udiv i32 %i.0, 1024
  %idxprom = zext i32 %div to i64
  %arrayidx = getelementptr inbounds [0 x i32*], [0 x i32*]* %blocks, i64 0, i64 %idxprom
  %15 = load i32*, i32** %arrayidx, align 8, !tbaa !28
  %rem = urem i32 %i.0, 1024
  %idxprom36 = zext i32 %rem to i64
  %arrayidx37 = getelementptr inbounds i32, i32* %15, i64 %idxprom36
  %16 = load i32, i32* %arrayidx37, align 4, !tbaa !49
  %group_info38 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 2
  %17 = load %struct.group_info*, %struct.group_info** %group_info38, align 8, !tbaa !602
  %blocks39 = getelementptr inbounds %struct.group_info, %struct.group_info* %17, i32 0, i32 4
  %div40 = udiv i32 %i.0, 1024
  %idxprom41 = zext i32 %div40 to i64
  %arrayidx42 = getelementptr inbounds [0 x i32*], [0 x i32*]* %blocks39, i64 0, i64 %idxprom41
  %18 = load i32*, i32** %arrayidx42, align 8, !tbaa !28
  %rem43 = urem i32 %i.0, 1024
  %idxprom44 = zext i32 %rem43 to i64
  %arrayidx45 = getelementptr inbounds i32, i32* %18, i64 %idxprom44
  %19 = load i32, i32* %arrayidx45, align 4, !tbaa !49
  %call46 = call zeroext i1 @gid_eq.519(i32 %16, i32 %19)
  br i1 %call46, label %for.inc, label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.body, %for.cond, %if.end20, %if.end14, %lor.lhs.false7, %lor.lhs.false, %if.end, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ 1, %for.cond ], [ 1, %if.end14 ], [ 0, %for.body ], [ 0, %if.end20 ], [ 0, %if.end ], [ 0, %lor.lhs.false ], [ 0, %lor.lhs.false7 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_cred* @generic_bind_cred(%struct.rpc_task* %task, %struct.rpc_cred* %cred, i32 %lookupflags) #0 {
entry:
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %0 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %cl_auth = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 10
  %1 = load %struct.rpc_auth*, %struct.rpc_auth** %cl_auth, align 8, !tbaa !167
  %2 = bitcast %struct.rpc_cred* %cred to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.generic_cred*
  %acred1 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %3, i32 0, i32 1
  %au_ops = getelementptr inbounds %struct.rpc_auth, %struct.rpc_auth* %1, i32 0, i32 4
  %4 = load %struct.rpc_authops*, %struct.rpc_authops** %au_ops, align 8, !tbaa !173
  %lookup_cred = getelementptr inbounds %struct.rpc_authops, %struct.rpc_authops* %4, i32 0, i32 5
  %5 = load %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)*, %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)** %lookup_cred, align 8, !tbaa !217
  %call = call %struct.rpc_cred* %5(%struct.rpc_auth* %1, %struct.auth_cred* %acred1, i32 %lookupflags)
  ret %struct.rpc_cred* %call
}

; Function Attrs: nounwind uwtable
define internal i32 @machine_cred_match(%struct.auth_cred* %acred, %struct.generic_cred* %gcred) #0 {
entry:
  %acred1 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %gcred, i32 0, i32 1
  %machine_cred = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred1, i32 0, i32 4
  %bf.load = load i8, i8* %machine_cred, align 8
  %bf.clear = and i8 %bf.load, 1
  %tobool = icmp ne i8 %bf.clear, 0
  br i1 %tobool, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %entry
  %acred2 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %gcred, i32 0, i32 1
  %principal = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred2, i32 0, i32 3
  %0 = load i8*, i8** %principal, align 8, !tbaa !632
  %principal3 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 3
  %1 = load i8*, i8** %principal3, align 8, !tbaa !626
  %cmp = icmp ne i8* %0, %1
  br i1 %cmp, label %return, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  %acred5 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %gcred, i32 0, i32 1
  %uid = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred5, i32 0, i32 0
  %2 = load i32, i32* %uid, align 8, !tbaa !629
  %uid6 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 0
  %3 = load i32, i32* %uid6, align 8, !tbaa !570
  %call = call zeroext i1 @uid_eq.518(i32 %2, i32 %3)
  br i1 %call, label %lor.lhs.false7, label %return

lor.lhs.false7:                                   ; preds = %lor.lhs.false4
  %acred8 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %gcred, i32 0, i32 1
  %gid = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred8, i32 0, i32 1
  %4 = load i32, i32* %gid, align 4, !tbaa !630
  %gid9 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 1
  %5 = load i32, i32* %gid9, align 4, !tbaa !600
  %call10 = call zeroext i1 @gid_eq.519(i32 %4, i32 %5)
  %. = select i1 %call10, i32 1, i32 0
  ret i32 %.

return:                                           ; preds = %lor.lhs.false4, %lor.lhs.false, %entry
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @uid_eq.518(i32 %left, i32 %right) #2 {
entry:
  %call = call i32 @__kuid_val.515(i32 %left)
  %call1 = call i32 @__kuid_val.515(i32 %right)
  %cmp = icmp eq i32 %call, %call1
  ret i1 %cmp
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @gid_eq.519(i32 %left, i32 %right) #2 {
entry:
  %call = call i32 @__kgid_val.514(i32 %left)
  %call1 = call i32 @__kgid_val.514(i32 %right)
  %cmp = icmp eq i32 %call, %call1
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define internal void @generic_free_cred_callback(%struct.callback_head* %head) #0 {
entry:
  %0 = bitcast %struct.callback_head* %head to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -32
  %1 = bitcast i8* %add.ptr to %struct.rpc_cred*
  call void @generic_free_cred(%struct.rpc_cred* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @generic_free_cred(%struct.rpc_cred* %cred) #0 {
entry:
  %0 = bitcast %struct.rpc_cred* %cred to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.generic_cred*
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %acred = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %1, i32 0, i32 1
  %group_info = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred, i32 0, i32 2
  %4 = load %struct.group_info*, %struct.group_info** %group_info, align 8, !tbaa !631
  %cmp = icmp ne %struct.group_info* %4, null
  br i1 %cmp, label %do.body5, label %if.end16

do.body5:                                         ; preds = %do.end
  %acred6 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %1, i32 0, i32 1
  %group_info7 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred6, i32 0, i32 2
  %5 = load %struct.group_info*, %struct.group_info** %group_info7, align 8, !tbaa !631
  %usage = getelementptr inbounds %struct.group_info, %struct.group_info* %5, i32 0, i32 0
  %call8 = call i32 @atomic_dec_and_test.521(%struct.atomic_t* %usage)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end16

if.then10:                                        ; preds = %do.body5
  %acred11 = getelementptr inbounds %struct.generic_cred, %struct.generic_cred* %1, i32 0, i32 1
  %group_info12 = getelementptr inbounds %struct.auth_cred, %struct.auth_cred* %acred11, i32 0, i32 2
  %6 = load %struct.group_info*, %struct.group_info** %group_info12, align 8, !tbaa !631
  call void @groups_free(%struct.group_info* %6)
  br label %if.end16

if.end16:                                         ; preds = %if.then10, %do.body5, %do.end
  %7 = bitcast %struct.generic_cred* %1 to i8*
  call void @kfree(i8* %7)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_dec_and_test.521(%struct.atomic_t* %v) #2 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0; sete $1", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32* %counter) #7, !srcloc !634
  %0 = load i8, i8* %c, align 1, !tbaa !166
  %conv = zext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define %struct.rpc_cred* @rpc_lookup_cred() #0 {
entry:
  %call = call %struct.rpc_cred* @rpcauth_lookupcred(%struct.rpc_auth* @generic_auth, i32 0)
  ret %struct.rpc_cred* %call
}

; Function Attrs: nounwind uwtable
define i32 @rpc_init_generic_auth() #6 section ".init.text" {
entry:
  %call = call i32 @rpcauth_init_credcache(%struct.rpc_auth* @generic_auth)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define void @rpc_destroy_generic_auth() #0 {
entry:
  call void @rpcauth_destroy_credcache(%struct.rpc_auth* @generic_auth)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @svc_max_payload(%struct.svc_rqst* %rqstp) #0 {
entry:
  %rq_xprt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %0 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt, align 8, !tbaa !635
  %xpt_class = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %0, i32 0, i32 0
  %1 = load %struct.svc_xprt_class*, %struct.svc_xprt_class** %xpt_class, align 8, !tbaa !639
  %xcl_max_payload = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %1, i32 0, i32 4
  %2 = load i32, i32* %xcl_max_payload, align 8, !tbaa !640
  %rq_server = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 7
  %3 = load %struct.svc_serv*, %struct.svc_serv** %rq_server, align 8, !tbaa !642
  %sv_max_payload = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %3, i32 0, i32 5
  %4 = load i32, i32* %sv_max_payload, align 8, !tbaa !643
  %cmp = icmp ult i32 %4, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %rq_server1 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 7
  %5 = load %struct.svc_serv*, %struct.svc_serv** %rq_server1, align 8, !tbaa !642
  %sv_max_payload2 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %5, i32 0, i32 5
  %6 = load i32, i32* %sv_max_payload2, align 8, !tbaa !643
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %max.0 = phi i32 [ %6, %if.then ], [ %2, %entry ]
  ret i32 %max.0
}

; Function Attrs: nounwind uwtable
define i32 @bc_svc_process(%struct.svc_serv* %serv, %struct.rpc_rqst* %req, %struct.svc_rqst* %rqstp) #0 {
entry:
  %rq_arg = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %rq_res = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %head1 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head1, i64 0, i64 0
  %sv_bc_xprt = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 21
  %0 = load %struct.svc_xprt*, %struct.svc_xprt** %sv_bc_xprt, align 8, !tbaa !645
  %rq_xprt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  store %struct.svc_xprt* %0, %struct.svc_xprt** %rq_xprt, align 8, !tbaa !635
  %rq_xid = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 5
  %1 = load i32, i32* %rq_xid, align 8, !tbaa !154
  %rq_xid3 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 23
  store i32 %1, i32* %rq_xid3, align 8, !tbaa !646
  %rq_xprt4 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 0
  %2 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt4, align 8, !tbaa !71
  %prot = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %2, i32 0, i32 5
  %3 = load i32, i32* %prot, align 8, !tbaa !186
  %rq_prot = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 27
  store i32 %3, i32* %rq_prot, align 8, !tbaa !647
  %rq_server = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 7
  store %struct.svc_serv* %serv, %struct.svc_serv** %rq_server, align 8, !tbaa !642
  %rq_addrlen = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 4
  store i64 128, i64* %rq_addrlen, align 8, !tbaa !648
  %rq_addrlen5 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 4
  %4 = load i64, i64* %rq_addrlen5, align 8, !tbaa !648
  %rq_addr = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 3
  %5 = bitcast %struct.__kernel_sockaddr_storage* %rq_addr to i8*
  %rq_xprt6 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 0
  %6 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt6, align 8, !tbaa !71
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %6, i32 0, i32 3
  %7 = bitcast %struct.__kernel_sockaddr_storage* %addr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %7, i64 %4, i32 8, i1 false)
  %cmp = icmp uge i64 64, 64
  %rq_arg9 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %8 = bitcast %struct.xdr_buf* %rq_arg9 to i8*
  %rq_rcv_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 2
  %9 = bitcast %struct.xdr_buf* %rq_rcv_buf to i8*
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i8* @__memcpy(i8* %8, i8* %9, i64 64)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %9, i64 64, i32 8, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %cmp15 = icmp uge i64 64, 64
  %rq_res17 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %10 = bitcast %struct.xdr_buf* %rq_res17 to i8*
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 1
  %11 = bitcast %struct.xdr_buf* %rq_snd_buf to i8*
  br i1 %cmp15, label %if.then16, label %if.else19

if.then16:                                        ; preds = %if.end
  %call18 = call i8* @__memcpy(i8* %10, i8* %11, i64 64)
  br label %if.end22

if.else19:                                        ; preds = %if.end
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 64, i32 8, i1 false)
  br label %if.end22

if.end22:                                         ; preds = %if.else19, %if.then16
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx2, i32 0, i32 1
  store i64 0, i64* %iov_len, align 8, !tbaa !149
  %rq_prot24 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 27
  %12 = load i32, i32* %rq_prot24, align 8, !tbaa !647
  %cmp25 = icmp ne i32 %12, 6
  br i1 %cmp25, label %if.then26, label %if.end31

if.then26:                                        ; preds = %if.end22
  %13 = call i32 (i8*, ...) @printk(i8* null)
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2.528, i32 0, i32 0), i32 1360, i64 12) #7, !srcloc !649
  br label %do.body28

do.body28:                                        ; preds = %do.body28, %if.then26
  br label %do.body28

if.end31:                                         ; preds = %if.end22
  %call32 = call i32 @svc_getu32(%struct.iovec* %arrayidx)
  %call33 = call i32 @svc_getnl(%struct.iovec* %arrayidx)
  %call34 = call i32 @svc_process_common(%struct.svc_rqst* %rqstp, %struct.iovec* %arrayidx, %struct.iovec* %arrayidx2)
  %tobool = icmp ne i32 %call34, 0
  br i1 %tobool, label %if.then35, label %if.else49

if.then35:                                        ; preds = %if.end31
  %cmp38 = icmp uge i64 64, 64
  %rq_snd_buf40 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 1
  %14 = bitcast %struct.xdr_buf* %rq_snd_buf40 to i8*
  %rq_res41 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %15 = bitcast %struct.xdr_buf* %rq_res41 to i8*
  br i1 %cmp38, label %if.then39, label %if.else43

if.then39:                                        ; preds = %if.then35
  %call42 = call i8* @__memcpy(i8* %14, i8* %15, i64 64)
  br label %if.end46

if.else43:                                        ; preds = %if.then35
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %15, i64 64, i32 8, i1 false)
  br label %if.end46

if.end46:                                         ; preds = %if.else43, %if.then39
  %call48 = call i32 @bc_send(%struct.rpc_rqst* %req)
  br label %cleanup

if.else49:                                        ; preds = %if.end31
  call void @xprt_free_bc_request(%struct.rpc_rqst* %req)
  br label %cleanup

cleanup:                                          ; preds = %if.else49, %if.end46
  %retval.0 = phi i32 [ %call48, %if.end46 ], [ 0, %if.else49 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @svc_getu32(%struct.iovec* %iov) #2 {
entry:
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  %0 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %1 = bitcast i8* %0 to i32*
  %incdec.ptr = getelementptr inbounds i32, i32* %1, i32 1
  %2 = load i32, i32* %1, align 4, !tbaa !49
  %3 = bitcast i32* %incdec.ptr to i8*
  %iov_base1 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  store i8* %3, i8** %iov_base1, align 8, !tbaa !147
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %4 = load i64, i64* %iov_len, align 8, !tbaa !149
  %sub = sub i64 %4, 4
  store i64 %sub, i64* %iov_len, align 8, !tbaa !149
  ret i32 %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @svc_getnl(%struct.iovec* %iov) #2 {
entry:
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  %0 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %1 = bitcast i8* %0 to i32*
  %incdec.ptr = getelementptr inbounds i32, i32* %1, i32 1
  %2 = load i32, i32* %1, align 4, !tbaa !49
  %3 = bitcast i32* %incdec.ptr to i8*
  %iov_base1 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  store i8* %3, i8** %iov_base1, align 8, !tbaa !147
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %4 = load i64, i64* %iov_len, align 8, !tbaa !149
  %sub = sub i64 %4, 4
  store i64 %sub, i64* %iov_len, align 8, !tbaa !149
  %call = call i32 @__fswab32.534(i32 %2) #3
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_process_common(%struct.svc_rqst* %rqstp, %struct.iovec* %argv, %struct.iovec* %resv) #0 {
entry:
  %auth_stat = alloca i32, align 4
  %rq_server = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 7
  %0 = load %struct.svc_serv*, %struct.svc_serv** %rq_server, align 8, !tbaa !642
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %argv, i32 0, i32 1
  %1 = load i64, i64* %iov_len, align 8, !tbaa !149
  %cmp = icmp ult i64 %1, 24
  br i1 %cmp, label %err_short_len, label %if.end

if.end:                                           ; preds = %entry
  %rq_splice_ok = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 39
  store i32 1, i32* %rq_splice_ok, align 8, !tbaa !650
  %rq_usedeferral = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 14
  store i32 1, i32* %rq_usedeferral, align 8, !tbaa !651
  %rq_dropme = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 34
  store i8 0, i8* %rq_dropme, align 8, !tbaa !652
  %rq_xprt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %2 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt, align 8, !tbaa !635
  %xpt_ops = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 1
  %3 = load %struct.svc_xprt_ops*, %struct.svc_xprt_ops** %xpt_ops, align 8, !tbaa !653
  %xpo_prep_reply_hdr = getelementptr inbounds %struct.svc_xprt_ops, %struct.svc_xprt_ops* %3, i32 0, i32 4
  %4 = load void (%struct.svc_rqst*)*, void (%struct.svc_rqst*)** %xpo_prep_reply_hdr, align 8, !tbaa !654
  call void %4(%struct.svc_rqst* %rqstp)
  %rq_xid = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 23
  %5 = load i32, i32* %rq_xid, align 8, !tbaa !646
  call void @svc_putu32(%struct.iovec* %resv, i32 %5)
  %call = call i32 @svc_getnl(%struct.iovec* %argv)
  call void @svc_putnl(%struct.iovec* %resv, i32 1)
  %cmp1 = icmp ne i32 %call, 2
  br i1 %cmp1, label %err_bad_rpc, label %if.end3

if.end3:                                          ; preds = %if.end
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %resv, i32 0, i32 0
  %6 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %iov_len4 = getelementptr inbounds %struct.iovec, %struct.iovec* %resv, i32 0, i32 1
  %7 = load i64, i64* %iov_len4, align 8, !tbaa !149
  %add.ptr = getelementptr i8, i8* %6, i64 %7
  %8 = bitcast i8* %add.ptr to i32*
  call void @svc_putnl(%struct.iovec* %resv, i32 0)
  %call5 = call i32 @svc_getnl(%struct.iovec* %argv)
  %rq_prog = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 24
  store i32 %call5, i32* %rq_prog, align 4, !tbaa !656
  %call6 = call i32 @svc_getnl(%struct.iovec* %argv)
  %rq_vers = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 25
  store i32 %call6, i32* %rq_vers, align 8, !tbaa !657
  %call7 = call i32 @svc_getnl(%struct.iovec* %argv)
  %rq_proc = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 26
  store i32 %call7, i32* %rq_proc, align 4, !tbaa !658
  %sv_program8 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %pg_next.sink = phi %struct.svc_program** [ %pg_next, %for.inc ], [ %sv_program8, %if.end3 ]
  %9 = load %struct.svc_program*, %struct.svc_program** %pg_next.sink, align 8, !tbaa !28
  %tobool = icmp ne %struct.svc_program* %9, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %pg_prog = getelementptr inbounds %struct.svc_program, %struct.svc_program* %9, i32 0, i32 1
  %10 = load i32, i32* %pg_prog, align 8, !tbaa !659
  %cmp9 = icmp eq i32 %call5, %10
  br i1 %cmp9, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %pg_next = getelementptr inbounds %struct.svc_program, %struct.svc_program* %9, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %call12 = call i32 bitcast (i32 (%struct.svc_rqst.5096*, i32*)* @svc_authenticate to i32 (%struct.svc_rqst*, i32*)*)(%struct.svc_rqst* %rqstp, i32* %auth_stat)
  %cmp13 = icmp eq i32 %call12, 5
  %tobool14 = icmp ne %struct.svc_program* %9, null
  %or.cond = and i1 %cmp13, %tobool14
  br i1 %or.cond, label %if.then15, label %NodeBlock15

if.then15:                                        ; preds = %for.end
  store i32 16777216, i32* %auth_stat, align 4, !tbaa !49
  %pg_authenticate = getelementptr inbounds %struct.svc_program, %struct.svc_program* %9, i32 0, i32 9
  %11 = load i32 (%struct.svc_rqst*)*, i32 (%struct.svc_rqst*)** %pg_authenticate, align 8, !tbaa !661
  %call16 = call i32 %11(%struct.svc_rqst* %rqstp)
  br label %NodeBlock15

NodeBlock15:                                      ; preds = %if.then15, %for.end
  %auth_res.0 = phi i32 [ %call16, %if.then15 ], [ %call12, %for.end ]
  %Pivot16 = icmp slt i32 %auth_res.0, 6
  br i1 %Pivot16, label %NodeBlock3, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %auth_res.0, 8
  br i1 %Pivot14, label %NodeBlock5, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %auth_res.0, 10
  br i1 %Pivot12, label %LeafBlock7, label %LeafBlock9

LeafBlock9:                                       ; preds = %NodeBlock11
  %SwitchLeaf10 = icmp eq i32 %auth_res.0, 10
  br i1 %SwitchLeaf10, label %sendit, label %sw.epilog

LeafBlock7:                                       ; preds = %NodeBlock11
  %SwitchLeaf8 = icmp eq i32 %auth_res.0, 8
  br i1 %SwitchLeaf8, label %do.body168, label %sw.epilog

NodeBlock5:                                       ; preds = %NodeBlock13
  %Pivot6 = icmp slt i32 %auth_res.0, 7
  br i1 %Pivot6, label %dropit, label %cond.true

NodeBlock3:                                       ; preds = %NodeBlock15
  %Pivot4 = icmp slt i32 %auth_res.0, 2
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %auth_res.0, 5
  %SwitchLeaf2 = icmp eq i32 %auth_res.0, 2
  %or.cond17 = and i1 %Pivot, %SwitchLeaf2
  br i1 %or.cond17, label %err_bad, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %auth_res.0, 1
  br i1 %SwitchLeaf, label %err_garbage, label %sw.epilog

cond.true:                                        ; preds = %NodeBlock5
  %rq_xprt21 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %12 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt21, align 8, !tbaa !635
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %12, i32 0, i32 5
  %13 = load volatile i64, i64* %xpt_flags, align 8, !tbaa !88
  %and.i = and i64 16, %13
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool23 = icmp ne i32 %conv.i, 0
  br i1 %tobool23, label %if.then28, label %dropit

if.then28:                                        ; preds = %cond.true
  %rq_xprt29 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %14 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt29, align 8, !tbaa !635
  call void @svc_close_xprt(%struct.svc_xprt* %14)
  br label %dropit

sw.epilog:                                        ; preds = %LeafBlock, %NodeBlock, %LeafBlock7, %LeafBlock9
  %cmp33 = icmp eq %struct.svc_program* %9, null
  br i1 %cmp33, label %do.body188, label %if.end35

if.end35:                                         ; preds = %sw.epilog
  %pg_nvers = getelementptr inbounds %struct.svc_program, %struct.svc_program* %9, i32 0, i32 4
  %15 = load i32, i32* %pg_nvers, align 4, !tbaa !662
  %cmp36 = icmp uge i32 %call6, %15
  br i1 %cmp36, label %err_bad_vers, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end35
  %pg_vers = getelementptr inbounds %struct.svc_program, %struct.svc_program* %9, i32 0, i32 5
  %16 = load %struct.svc_version**, %struct.svc_version*** %pg_vers, align 8, !tbaa !663
  %idxprom = zext i32 %call6 to i64
  %arrayidx = getelementptr inbounds %struct.svc_version*, %struct.svc_version** %16, i64 %idxprom
  %17 = load %struct.svc_version*, %struct.svc_version** %arrayidx, align 8, !tbaa !28
  %tobool37 = icmp ne %struct.svc_version* %17, null
  br i1 %tobool37, label %if.end39, label %err_bad_vers

if.end39:                                         ; preds = %lor.lhs.false
  %vs_proc = getelementptr inbounds %struct.svc_version, %struct.svc_version* %17, i32 0, i32 2
  %18 = load %struct.svc_procedure*, %struct.svc_procedure** %vs_proc, align 8, !tbaa !664
  %idx.ext = zext i32 %call7 to i64
  %add.ptr40 = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %18, i64 %idx.ext
  %vs_nproc = getelementptr inbounds %struct.svc_version, %struct.svc_version* %17, i32 0, i32 1
  %19 = load i32, i32* %vs_nproc, align 4, !tbaa !666
  %cmp41 = icmp uge i32 %call7, %19
  br i1 %cmp41, label %err_bad_proc, label %lor.lhs.false42

lor.lhs.false42:                                  ; preds = %if.end39
  %pc_func = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %add.ptr40, i32 0, i32 0
  %20 = load i32 (%struct.svc_rqst*, i8*, i8*)*, i32 (%struct.svc_rqst*, i8*, i8*)** %pc_func, align 8, !tbaa !667
  %tobool43 = icmp ne i32 (%struct.svc_rqst*, i8*, i8*)* %20, null
  br i1 %tobool43, label %if.end45, label %err_bad_proc

if.end45:                                         ; preds = %lor.lhs.false42
  %rq_procinfo = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 9
  store %struct.svc_procedure* %add.ptr40, %struct.svc_procedure** %rq_procinfo, align 8, !tbaa !669
  %sv_stats = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 1
  %21 = load %struct.svc_stat*, %struct.svc_stat** %sv_stats, align 8, !tbaa !670
  %rpccnt = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %21, i32 0, i32 5
  %22 = load i32, i32* %rpccnt, align 8, !tbaa !671
  %inc = add i32 %22, 1
  store i32 %inc, i32* %rpccnt, align 8, !tbaa !671
  %iov_base46 = getelementptr inbounds %struct.iovec, %struct.iovec* %resv, i32 0, i32 0
  %23 = load i8*, i8** %iov_base46, align 8, !tbaa !147
  %iov_len47 = getelementptr inbounds %struct.iovec, %struct.iovec* %resv, i32 0, i32 1
  %24 = load i64, i64* %iov_len47, align 8, !tbaa !149
  %add.ptr48 = getelementptr i8, i8* %23, i64 %24
  %25 = bitcast i8* %add.ptr48 to i32*
  call void @svc_putnl(%struct.iovec* %resv, i32 0)
  %pc_count = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %add.ptr40, i32 0, i32 6
  %26 = load i32, i32* %pc_count, align 8, !tbaa !673
  %inc49 = add i32 %26, 1
  store i32 %inc49, i32* %pc_count, align 8, !tbaa !673
  %rq_argp = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 29
  %27 = load i8*, i8** %rq_argp, align 8, !tbaa !674
  %pc_argsize = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %add.ptr40, i32 0, i32 4
  %28 = load i32, i32* %pc_argsize, align 8, !tbaa !675
  %conv = zext i32 %28 to i64
  call void @llvm.memset.p0i8.i64(i8* %27, i8 0, i64 %conv, i32 1, i1 false)
  %rq_resp = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 30
  %29 = load i8*, i8** %rq_resp, align 8, !tbaa !676
  %pc_ressize = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %add.ptr40, i32 0, i32 5
  %30 = load i32, i32* %pc_ressize, align 4, !tbaa !677
  %conv50 = zext i32 %30 to i64
  call void @llvm.memset.p0i8.i64(i8* %29, i8 0, i64 %conv50, i32 1, i1 false)
  %pc_xdrressize = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %add.ptr40, i32 0, i32 8
  %31 = load i32, i32* %pc_xdrressize, align 8, !tbaa !678
  %tobool51 = icmp ne i32 %31, 0
  br i1 %tobool51, label %if.then52, label %if.end54

if.then52:                                        ; preds = %if.end45
  %pc_xdrressize53 = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %add.ptr40, i32 0, i32 8
  %32 = load i32, i32* %pc_xdrressize53, align 8, !tbaa !678
  %shl = shl i32 %32, 2
  call void @svc_reserve_auth(%struct.svc_rqst* %rqstp, i32 %shl)
  br label %if.end54

if.end54:                                         ; preds = %if.then52, %if.end45
  %vs_dispatch = getelementptr inbounds %struct.svc_version, %struct.svc_version* %17, i32 0, i32 5
  %33 = load i32 (%struct.svc_rqst*, i32*)*, i32 (%struct.svc_rqst*, i32*)** %vs_dispatch, align 8, !tbaa !679
  %tobool55 = icmp ne i32 (%struct.svc_rqst*, i32*)* %33, null
  br i1 %tobool55, label %do.body99, label %if.then56

if.then56:                                        ; preds = %if.end54
  %pc_decode = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %add.ptr40, i32 0, i32 1
  %34 = load i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)** %pc_decode, align 8, !tbaa !680
  %tobool57 = icmp ne i32 (i8*, i32*, i8*)* %34, null
  br i1 %tobool57, label %land.lhs.true58, label %if.end64

land.lhs.true58:                                  ; preds = %if.then56
  %35 = bitcast %struct.svc_rqst* %rqstp to i8*
  %iov_base59 = getelementptr inbounds %struct.iovec, %struct.iovec* %argv, i32 0, i32 0
  %36 = load i8*, i8** %iov_base59, align 8, !tbaa !147
  %37 = bitcast i8* %36 to i32*
  %rq_argp60 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 29
  %38 = load i8*, i8** %rq_argp60, align 8, !tbaa !674
  %call61 = call i32 %34(i8* %35, i32* %37, i8* %38)
  %tobool62 = icmp ne i32 %call61, 0
  br i1 %tobool62, label %if.end64, label %err_garbage

if.end64:                                         ; preds = %land.lhs.true58, %if.then56
  %pc_func65 = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %add.ptr40, i32 0, i32 0
  %39 = load i32 (%struct.svc_rqst*, i8*, i8*)*, i32 (%struct.svc_rqst*, i8*, i8*)** %pc_func65, align 8, !tbaa !667
  %rq_argp66 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 29
  %40 = load i8*, i8** %rq_argp66, align 8, !tbaa !674
  %rq_resp67 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 30
  %41 = load i8*, i8** %rq_resp67, align 8, !tbaa !676
  %call68 = call i32 %39(%struct.svc_rqst* %rqstp, i8* %40, i8* %41)
  store i32 %call68, i32* %25, align 4, !tbaa !49
  %rq_dropme69 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 34
  %42 = load i8, i8* %rq_dropme69, align 8, !tbaa !652, !range !31
  %tobool70 = trunc i8 %42 to i1
  br i1 %tobool70, label %if.then71, label %if.end78

if.then71:                                        ; preds = %if.end64
  %pc_release = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %add.ptr40, i32 0, i32 3
  %43 = load i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)** %pc_release, align 8, !tbaa !681
  %tobool72 = icmp ne i32 (i8*, i32*, i8*)* %43, null
  br i1 %tobool72, label %if.then73, label %dropit

if.then73:                                        ; preds = %if.then71
  %pc_release74 = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %add.ptr40, i32 0, i32 3
  %44 = load i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)** %pc_release74, align 8, !tbaa !681
  %45 = bitcast %struct.svc_rqst* %rqstp to i8*
  %rq_resp75 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 30
  %46 = load i8*, i8** %rq_resp75, align 8, !tbaa !676
  %call76 = call i32 %44(i8* %45, i32* null, i8* %46)
  br label %dropit

if.end78:                                         ; preds = %if.end64
  %47 = load i32, i32* %25, align 4, !tbaa !49
  %cmp79 = icmp eq i32 %47, 0
  br i1 %cmp79, label %land.lhs.true81, label %if.end126

land.lhs.true81:                                  ; preds = %if.end78
  %pc_encode = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %add.ptr40, i32 0, i32 2
  %48 = load i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)** %pc_encode, align 8, !tbaa !682
  %tobool82 = icmp ne i32 (i8*, i32*, i8*)* %48, null
  br i1 %tobool82, label %land.lhs.true83, label %if.end126

land.lhs.true83:                                  ; preds = %land.lhs.true81
  %49 = bitcast %struct.svc_rqst* %rqstp to i8*
  %iov_base84 = getelementptr inbounds %struct.iovec, %struct.iovec* %resv, i32 0, i32 0
  %50 = load i8*, i8** %iov_base84, align 8, !tbaa !147
  %iov_len85 = getelementptr inbounds %struct.iovec, %struct.iovec* %resv, i32 0, i32 1
  %51 = load i64, i64* %iov_len85, align 8, !tbaa !149
  %add.ptr86 = getelementptr i8, i8* %50, i64 %51
  %52 = bitcast i8* %add.ptr86 to i32*
  %rq_resp87 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 30
  %53 = load i8*, i8** %rq_resp87, align 8, !tbaa !676
  %call88 = call i32 %48(i8* %49, i32* %52, i8* %53)
  %tobool89 = icmp ne i32 %call88, 0
  br i1 %tobool89, label %if.end126, label %do.body

do.body:                                          ; preds = %land.lhs.true83
  %54 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %54, 512
  %tobool91 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool91, true
  %lnot92 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot92 to i32
  %conv93 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv93, i64 0)
  %tobool94 = icmp ne i64 %expval, 0
  br i1 %tobool94, label %if.then95, label %do.end

if.then95:                                        ; preds = %do.body
  %55 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then95, %do.body
  store i32 83886080, i32* %25, align 4, !tbaa !49
  br label %if.end126

do.body99:                                        ; preds = %if.end54
  %56 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and100 = and i32 %56, 512
  %tobool101 = icmp ne i32 %and100, 0
  %lnot102 = xor i1 %tobool101, true
  %lnot104 = xor i1 %lnot102, true
  %lnot.ext105 = zext i1 %lnot104 to i32
  %conv106 = sext i32 %lnot.ext105 to i64
  %expval107 = call i64 @llvm.expect.i64(i64 %conv106, i64 0)
  %tobool108 = icmp ne i64 %expval107, 0
  br i1 %tobool108, label %if.then109, label %do.end113

if.then109:                                       ; preds = %do.body99
  %57 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end113

do.end113:                                        ; preds = %if.then109, %do.body99
  %vs_dispatch114 = getelementptr inbounds %struct.svc_version, %struct.svc_version* %17, i32 0, i32 5
  %58 = load i32 (%struct.svc_rqst*, i32*)*, i32 (%struct.svc_rqst*, i32*)** %vs_dispatch114, align 8, !tbaa !679
  %call115 = call i32 %58(%struct.svc_rqst* %rqstp, i32* %25)
  %tobool116 = icmp ne i32 %call115, 0
  br i1 %tobool116, label %if.end126, label %if.then117

if.then117:                                       ; preds = %do.end113
  %pc_release118 = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %add.ptr40, i32 0, i32 3
  %59 = load i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)** %pc_release118, align 8, !tbaa !681
  %tobool119 = icmp ne i32 (i8*, i32*, i8*)* %59, null
  br i1 %tobool119, label %if.then120, label %dropit

if.then120:                                       ; preds = %if.then117
  %pc_release121 = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %add.ptr40, i32 0, i32 3
  %60 = load i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)** %pc_release121, align 8, !tbaa !681
  %61 = bitcast %struct.svc_rqst* %rqstp to i8*
  %rq_resp122 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 30
  %62 = load i8*, i8** %rq_resp122, align 8, !tbaa !676
  %call123 = call i32 %60(i8* %61, i32* null, i8* %62)
  br label %dropit

if.end126:                                        ; preds = %do.end113, %do.end, %land.lhs.true83, %land.lhs.true81, %if.end78
  %63 = load i32, i32* %25, align 4, !tbaa !49
  %cmp127 = icmp ne i32 %63, 0
  br i1 %cmp127, label %if.then129, label %if.end132

if.then129:                                       ; preds = %if.end126
  %64 = bitcast i32* %25 to i8*
  %iov_base130 = getelementptr inbounds %struct.iovec, %struct.iovec* %resv, i32 0, i32 0
  %65 = load i8*, i8** %iov_base130, align 8, !tbaa !147
  %sub.ptr.lhs.cast = ptrtoint i8* %64 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %65 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %add = add nsw i64 %sub.ptr.sub, 4
  %iov_len131 = getelementptr inbounds %struct.iovec, %struct.iovec* %resv, i32 0, i32 1
  store i64 %add, i64* %iov_len131, align 8, !tbaa !149
  br label %if.end132

if.end132:                                        ; preds = %if.then129, %if.end126
  %pc_release133 = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %add.ptr40, i32 0, i32 3
  %66 = load i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)** %pc_release133, align 8, !tbaa !681
  %tobool134 = icmp ne i32 (i8*, i32*, i8*)* %66, null
  br i1 %tobool134, label %if.then135, label %if.end139

if.then135:                                       ; preds = %if.end132
  %pc_release136 = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %add.ptr40, i32 0, i32 3
  %67 = load i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)** %pc_release136, align 8, !tbaa !681
  %68 = bitcast %struct.svc_rqst* %rqstp to i8*
  %rq_resp137 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 30
  %69 = load i8*, i8** %rq_resp137, align 8, !tbaa !676
  %call138 = call i32 %67(i8* %68, i32* null, i8* %69)
  br label %if.end139

if.end139:                                        ; preds = %if.then135, %if.end132
  %pc_encode140 = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %add.ptr40, i32 0, i32 2
  %70 = load i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)** %pc_encode140, align 8, !tbaa !682
  %cmp141 = icmp eq i32 (i8*, i32*, i8*)* %70, null
  br i1 %cmp141, label %dropit, label %sendit

sendit:                                           ; preds = %err_bad, %err_bad_proc, %err_bad_vers, %do.end202, %do.end183, %err_bad_rpc, %if.end139, %LeafBlock9
  %call145 = call i32 bitcast (i32 (%struct.svc_rqst.5096*)* @svc_authorise to i32 (%struct.svc_rqst*)*)(%struct.svc_rqst* %rqstp)
  %tobool146 = icmp ne i32 %call145, 0
  br i1 %tobool146, label %dropit, label %cleanup

dropit:                                           ; preds = %err_short_len, %sendit, %if.end139, %if.then120, %if.then117, %if.then73, %if.then71, %if.then28, %cond.true, %NodeBlock5
  %call149 = call i32 bitcast (i32 (%struct.svc_rqst.5096*)* @svc_authorise to i32 (%struct.svc_rqst*)*)(%struct.svc_rqst* %rqstp)
  %71 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and151 = and i32 %71, 512
  %tobool152 = icmp ne i32 %and151, 0
  %lnot153 = xor i1 %tobool152, true
  %lnot155 = xor i1 %lnot153, true
  %lnot.ext156 = zext i1 %lnot155 to i32
  %conv157 = sext i32 %lnot.ext156 to i64
  %expval158 = call i64 @llvm.expect.i64(i64 %conv157, i64 0)
  %tobool159 = icmp ne i64 %expval158, 0
  br i1 %tobool159, label %if.then160, label %cleanup

if.then160:                                       ; preds = %dropit
  %72 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

err_short_len:                                    ; preds = %entry
  %iov_len165 = getelementptr inbounds %struct.iovec, %struct.iovec* %argv, i32 0, i32 1
  %73 = load i64, i64* %iov_len165, align 8, !tbaa !149
  call void (%struct.svc_rqst*, i8*, ...) @svc_printk(%struct.svc_rqst* %rqstp, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34.533, i32 0, i32 0), i64 %73)
  br label %dropit

err_bad_rpc:                                      ; preds = %if.end
  %sv_stats166 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 1
  %74 = load %struct.svc_stat*, %struct.svc_stat** %sv_stats166, align 8, !tbaa !670
  %rpcbadfmt = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %74, i32 0, i32 6
  %75 = load i32, i32* %rpcbadfmt, align 4, !tbaa !683
  %inc167 = add i32 %75, 1
  store i32 %inc167, i32* %rpcbadfmt, align 4, !tbaa !683
  call void @svc_putnl(%struct.iovec* %resv, i32 1)
  call void @svc_putnl(%struct.iovec* %resv, i32 0)
  call void @svc_putnl(%struct.iovec* %resv, i32 2)
  call void @svc_putnl(%struct.iovec* %resv, i32 2)
  br label %sendit

do.body168:                                       ; preds = %LeafBlock7
  %76 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and169 = and i32 %76, 512
  %tobool170 = icmp ne i32 %and169, 0
  %lnot171 = xor i1 %tobool170, true
  %lnot173 = xor i1 %lnot171, true
  %lnot.ext174 = zext i1 %lnot173 to i32
  %conv175 = sext i32 %lnot.ext174 to i64
  %expval176 = call i64 @llvm.expect.i64(i64 %conv175, i64 0)
  %tobool177 = icmp ne i64 %expval176, 0
  br i1 %tobool177, label %if.then178, label %do.end183

if.then178:                                       ; preds = %do.body168
  %77 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end183

do.end183:                                        ; preds = %if.then178, %do.body168
  %sv_stats184 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 1
  %78 = load %struct.svc_stat*, %struct.svc_stat** %sv_stats184, align 8, !tbaa !670
  %rpcbadauth = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %78, i32 0, i32 7
  %79 = load i32, i32* %rpcbadauth, align 8, !tbaa !684
  %inc185 = add i32 %79, 1
  store i32 %inc185, i32* %rpcbadauth, align 8, !tbaa !684
  call void @xdr_ressize_check(%struct.svc_rqst* %rqstp, i32* %8)
  call void @svc_putnl(%struct.iovec* %resv, i32 1)
  call void @svc_putnl(%struct.iovec* %resv, i32 1)
  %80 = load i32, i32* %auth_stat, align 4, !tbaa !49
  %call187 = call i32 @__fswab32.534(i32 %80) #3
  call void @svc_putnl(%struct.iovec* %resv, i32 %call187)
  br label %sendit

do.body188:                                       ; preds = %sw.epilog
  %81 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and189 = and i32 %81, 512
  %tobool190 = icmp ne i32 %and189, 0
  %lnot191 = xor i1 %tobool190, true
  %lnot193 = xor i1 %lnot191, true
  %lnot.ext194 = zext i1 %lnot193 to i32
  %conv195 = sext i32 %lnot.ext194 to i64
  %expval196 = call i64 @llvm.expect.i64(i64 %conv195, i64 0)
  %tobool197 = icmp ne i64 %expval196, 0
  br i1 %tobool197, label %if.then198, label %do.end202

if.then198:                                       ; preds = %do.body188
  %82 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end202

do.end202:                                        ; preds = %if.then198, %do.body188
  %sv_stats203 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 1
  %83 = load %struct.svc_stat*, %struct.svc_stat** %sv_stats203, align 8, !tbaa !670
  %rpcbadfmt204 = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %83, i32 0, i32 6
  %84 = load i32, i32* %rpcbadfmt204, align 4, !tbaa !683
  %inc205 = add i32 %84, 1
  store i32 %inc205, i32* %rpcbadfmt204, align 4, !tbaa !683
  call void @svc_putnl(%struct.iovec* %resv, i32 1)
  br label %sendit

err_bad_vers:                                     ; preds = %lor.lhs.false, %if.end35
  %pg_name = getelementptr inbounds %struct.svc_program, %struct.svc_program* %9, i32 0, i32 6
  %85 = load i8*, i8** %pg_name, align 8, !tbaa !685
  call void (%struct.svc_rqst*, i8*, ...) @svc_printk(%struct.svc_rqst* %rqstp, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.37.537, i32 0, i32 0), i32 %call6, i32 %call5, i8* %85)
  %sv_stats206 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 1
  %86 = load %struct.svc_stat*, %struct.svc_stat** %sv_stats206, align 8, !tbaa !670
  %rpcbadfmt207 = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %86, i32 0, i32 6
  %87 = load i32, i32* %rpcbadfmt207, align 4, !tbaa !683
  %inc208 = add i32 %87, 1
  store i32 %inc208, i32* %rpcbadfmt207, align 4, !tbaa !683
  call void @svc_putnl(%struct.iovec* %resv, i32 2)
  %pg_lovers = getelementptr inbounds %struct.svc_program, %struct.svc_program* %9, i32 0, i32 2
  %88 = load i32, i32* %pg_lovers, align 4, !tbaa !686
  call void @svc_putnl(%struct.iovec* %resv, i32 %88)
  %pg_hivers = getelementptr inbounds %struct.svc_program, %struct.svc_program* %9, i32 0, i32 3
  %89 = load i32, i32* %pg_hivers, align 8, !tbaa !687
  call void @svc_putnl(%struct.iovec* %resv, i32 %89)
  br label %sendit

err_bad_proc:                                     ; preds = %lor.lhs.false42, %if.end39
  call void (%struct.svc_rqst*, i8*, ...) @svc_printk(%struct.svc_rqst* %rqstp, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.38.538, i32 0, i32 0), i32 %call7)
  %sv_stats209 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 1
  %90 = load %struct.svc_stat*, %struct.svc_stat** %sv_stats209, align 8, !tbaa !670
  %rpcbadfmt210 = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %90, i32 0, i32 6
  %91 = load i32, i32* %rpcbadfmt210, align 4, !tbaa !683
  %inc211 = add i32 %91, 1
  store i32 %inc211, i32* %rpcbadfmt210, align 4, !tbaa !683
  call void @svc_putnl(%struct.iovec* %resv, i32 3)
  br label %sendit

err_garbage:                                      ; preds = %land.lhs.true58, %LeafBlock
  call void (%struct.svc_rqst*, i8*, ...) @svc_printk(%struct.svc_rqst* %rqstp, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.39.539, i32 0, i32 0))
  br label %err_bad

err_bad:                                          ; preds = %err_garbage, %NodeBlock
  %rpc_stat.0 = phi i32 [ 67108864, %err_garbage ], [ 83886080, %NodeBlock ]
  %sv_stats212 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 1
  %92 = load %struct.svc_stat*, %struct.svc_stat** %sv_stats212, align 8, !tbaa !670
  %rpcbadfmt213 = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %92, i32 0, i32 6
  %93 = load i32, i32* %rpcbadfmt213, align 4, !tbaa !683
  %inc214 = add i32 %93, 1
  store i32 %inc214, i32* %rpcbadfmt213, align 4, !tbaa !683
  %call215 = call i32 @__fswab32.534(i32 %rpc_stat.0) #3
  call void @svc_putnl(%struct.iovec* %resv, i32 %call215)
  br label %sendit

cleanup:                                          ; preds = %if.then160, %dropit, %sendit
  %retval.0 = phi i32 [ 1, %sendit ], [ 0, %if.then160 ], [ 0, %dropit ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @svc_putu32(%struct.iovec* %iov, i32 %val) #2 {
entry:
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  %0 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %1 = load i64, i64* %iov_len, align 8, !tbaa !149
  %add.ptr = getelementptr i8, i8* %0, i64 %1
  %2 = bitcast i8* %add.ptr to i32*
  store i32 %val, i32* %2, align 4, !tbaa !49
  %iov_len1 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %3 = load i64, i64* %iov_len1, align 8, !tbaa !149
  %add = add i64 %3, 4
  store i64 %add, i64* %iov_len1, align 8, !tbaa !149
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @svc_putnl(%struct.iovec* %iov, i32 %val) #2 {
entry:
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  %0 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %1 = load i64, i64* %iov_len, align 8, !tbaa !149
  %add.ptr = getelementptr i8, i8* %0, i64 %1
  %2 = bitcast i8* %add.ptr to i32*
  %call = call i32 @__fswab32.534(i32 %val) #3
  store i32 %call, i32* %2, align 4, !tbaa !49
  %iov_len1 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %3 = load i64, i64* %iov_len1, align 8, !tbaa !149
  %add = add i64 %3, 4
  store i64 %add, i64* %iov_len1, align 8, !tbaa !149
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @svc_reserve_auth(%struct.svc_rqst* %rqstp, i32 %space) #2 {
entry:
  %rq_authop = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 10
  %0 = load %struct.auth_ops*, %struct.auth_ops** %rq_authop, align 8, !tbaa !688
  %flavour = getelementptr inbounds %struct.auth_ops, %struct.auth_ops* %0, i32 0, i32 2
  %1 = load i32, i32* %flavour, align 8, !tbaa !689
  %tobool = icmp ne i32 %1, 0
  %. = select i1 %tobool, i32 400, i32 0
  %add = add nsw i32 %space, %.
  call void @svc_reserve(%struct.svc_rqst* %rqstp, i32 %add)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_printk(%struct.svc_rqst* %rqstp, i8* %fmt, ...) #0 {
entry:
  %vaf = alloca %struct.va_format, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  %buf = alloca [63 x i8], align 16
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %fmt2 = getelementptr inbounds %struct.va_format, %struct.va_format* %vaf, i32 0, i32 0
  store i8* %fmt, i8** %fmt2, align 8, !tbaa !691
  %va = getelementptr inbounds %struct.va_format, %struct.va_format* %vaf, i32 0, i32 1
  store [1 x %struct.__va_list_tag]* %args, [1 x %struct.__va_list_tag]** %va, align 8, !tbaa !693
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 512
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %arraydecay5 = getelementptr inbounds [63 x i8], [63 x i8]* %buf, i32 0, i32 0
  %call = call i8* @svc_print_addr(%struct.svc_rqst* %rqstp, i8* %arraydecay5, i64 63)
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %arraydecay7 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay78 = bitcast %struct.__va_list_tag* %arraydecay7 to i8*
  call void @llvm.va_end(i8* %arraydecay78)
  ret void
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__fswab32.534(i32 %val) #5 {
entry:
  %call = call i32 @__arch_swab32.540(i32 %val) #3
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xdr_ressize_check(%struct.svc_rqst* %rqstp, i32* %p) #2 {
entry:
  %rq_res = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %0 = bitcast i32* %p to i8*
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  %1 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %sub.ptr.lhs.cast = ptrtoint i8* %0 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  store i64 %sub.ptr.sub, i64* %iov_len, align 8, !tbaa !149
  ret void
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__arch_swab32.540(i32 %val) #5 {
entry:
  %0 = call i32 asm "bswapl $0", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %val) #3, !srcloc !694
  ret i32 %0
}

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #7

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #7

; Function Attrs: nounwind uwtable
define i32 @svc_process(%struct.svc_rqst* %rqstp) #0 {
entry:
  %rq_arg = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %rq_res = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %head1 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head1, i64 0, i64 0
  %rq_server = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 7
  %0 = load %struct.svc_serv*, %struct.svc_serv** %rq_server, align 8, !tbaa !642
  %rq_respages = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 19
  %1 = load %struct.page**, %struct.page*** %rq_respages, align 8, !tbaa !695
  %arrayidx3 = getelementptr inbounds %struct.page*, %struct.page** %1, i64 1
  %rq_next_page = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 21
  store %struct.page** %arrayidx3, %struct.page*** %rq_next_page, align 8, !tbaa !696
  %rq_respages4 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 19
  %2 = load %struct.page**, %struct.page*** %rq_respages4, align 8, !tbaa !695
  %arrayidx5 = getelementptr inbounds %struct.page*, %struct.page** %2, i64 0
  %3 = load %struct.page*, %struct.page** %arrayidx5, align 8, !tbaa !28
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %3 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %4 = inttoptr i64 %add.i to i8*
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx2, i32 0, i32 0
  store i8* %4, i8** %iov_base, align 8, !tbaa !147
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx2, i32 0, i32 1
  store i64 0, i64* %iov_len, align 8, !tbaa !149
  %rq_respages6 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 19
  %5 = load %struct.page**, %struct.page*** %rq_respages6, align 8, !tbaa !695
  %add.ptr = getelementptr inbounds %struct.page*, %struct.page** %5, i64 1
  %rq_res7 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %pages = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res7, i32 0, i32 2
  store %struct.page** %add.ptr, %struct.page*** %pages, align 8, !tbaa !697
  %rq_res8 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res8, i32 0, i32 7
  store i32 0, i32* %len, align 8, !tbaa !698
  %rq_res9 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res9, i32 0, i32 3
  store i32 0, i32* %page_base, align 8, !tbaa !699
  %rq_res10 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res10, i32 0, i32 4
  store i32 0, i32* %page_len, align 4, !tbaa !700
  %rq_res11 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res11, i32 0, i32 6
  store i32 4096, i32* %buflen, align 4, !tbaa !701
  %rq_res12 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res12, i32 0, i32 1
  %arrayidx13 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_base14 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx13, i32 0, i32 0
  store i8* null, i8** %iov_base14, align 8, !tbaa !147
  %rq_res15 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %tail16 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res15, i32 0, i32 1
  %arrayidx17 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail16, i64 0, i64 0
  %iov_len18 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx17, i32 0, i32 1
  store i64 0, i64* %iov_len18, align 8, !tbaa !149
  %call19 = call i32 @svc_getu32(%struct.iovec* %arrayidx)
  %rq_xid = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 23
  store i32 %call19, i32* %rq_xid, align 8, !tbaa !646
  %call20 = call i32 @svc_getnl(%struct.iovec* %arrayidx)
  %cmp = icmp ne i32 %call20, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (%struct.svc_rqst*, i8*, ...) @svc_printk(%struct.svc_rqst* %rqstp, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.9.543, i32 0, i32 0), i32 %call20)
  %sv_stats = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 1
  %6 = load %struct.svc_stat*, %struct.svc_stat** %sv_stats, align 8, !tbaa !670
  %rpcbadfmt = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %6, i32 0, i32 6
  %7 = load i32, i32* %rpcbadfmt, align 4, !tbaa !683
  %inc = add i32 %7, 1
  store i32 %inc, i32* %rpcbadfmt, align 4, !tbaa !683
  call void @svc_drop(%struct.svc_rqst* %rqstp)
  br label %cleanup

if.end:                                           ; preds = %entry
  %call21 = call i32 @svc_process_common(%struct.svc_rqst* %rqstp, %struct.iovec* %arrayidx, %struct.iovec* %arrayidx2)
  %tobool = icmp ne i32 %call21, 0
  br i1 %tobool, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.end
  %call23 = call i32 @svc_send(%struct.svc_rqst* %rqstp)
  br label %cleanup

if.else:                                          ; preds = %if.end
  call void @svc_drop(%struct.svc_rqst* %rqstp)
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.then22, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ %call23, %if.then22 ], [ 0, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @svc_exit_thread(%struct.svc_rqst* %rqstp) #0 {
entry:
  %rq_server = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 7
  %0 = load %struct.svc_serv*, %struct.svc_serv** %rq_server, align 8, !tbaa !642
  %rq_pool = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 8
  %1 = load %struct.svc_pool*, %struct.svc_pool** %rq_pool, align 8, !tbaa !702
  call void @svc_release_buffer(%struct.svc_rqst* %rqstp)
  %rq_resp = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 30
  %2 = load i8*, i8** %rq_resp, align 8, !tbaa !676
  call void @kfree(i8* %2)
  %rq_argp = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 29
  %3 = load i8*, i8** %rq_argp, align 8, !tbaa !674
  call void @kfree(i8* %3)
  %rq_auth_data = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 31
  %4 = load i8*, i8** %rq_auth_data, align 8, !tbaa !703
  call void @kfree(i8* %4)
  %sp_lock = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %1, i32 0, i32 1
  call void @spin_lock_bh.544(%struct.spinlock* %sp_lock)
  %sp_nrthreads = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %1, i32 0, i32 4
  %5 = load i32, i32* %sp_nrthreads, align 16, !tbaa !704
  %dec = add i32 %5, -1
  store i32 %dec, i32* %sp_nrthreads, align 16, !tbaa !704
  %rq_all = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 1
  call void @list_del(%struct.list_head* %rq_all)
  %sp_lock1 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %1, i32 0, i32 1
  call void @spin_unlock_bh.545(%struct.spinlock* %sp_lock1)
  %6 = bitcast %struct.svc_rqst* %rqstp to i8*
  call void @kfree(i8* %6)
  %tobool = icmp ne %struct.svc_serv* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @svc_destroy(%struct.svc_serv* %0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_release_buffer(%struct.svc_rqst* %rqstp) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %conv = zext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 259
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %rq_pages = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages, i64 0, i64 %idxprom
  %0 = load %struct.page*, %struct.page** %arrayidx, align 8, !tbaa !28
  %tobool = icmp ne %struct.page* %0, null
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %rq_pages2 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %idxprom3 = zext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages2, i64 0, i64 %idxprom3
  %1 = load %struct.page*, %struct.page** %arrayidx4, align 8, !tbaa !28
  call void @put_page(%struct.page* %1)
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_bh.544(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_bh.545(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define void @svc_destroy(%struct.svc_serv* %serv) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 512
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %sv_nrthreads3 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 3
  %2 = load i32, i32* %sv_nrthreads3, align 8, !tbaa !707
  %tobool4 = icmp ne i32 %2, 0
  br i1 %tobool4, label %if.then5, label %if.else

if.then5:                                         ; preds = %do.end
  %sv_nrthreads6 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 3
  %3 = load i32, i32* %sv_nrthreads6, align 8, !tbaa !707
  %dec = add i32 %3, -1
  store i32 %dec, i32* %sv_nrthreads6, align 8, !tbaa !707
  %cmp = icmp ne i32 %dec, 0
  br i1 %cmp, label %if.then8, label %if.end11

if.then8:                                         ; preds = %if.then5
  call void @svc_sock_update_bufs(%struct.svc_serv* %serv)
  br label %return

if.else:                                          ; preds = %do.end
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.then5
  %sv_temptimer = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 11
  %call12 = call i32 @del_timer_sync(%struct.timer_list* %sv_temptimer)
  %sv_permsocks = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 8
  %call14 = call i32 @list_empty.548(%struct.list_head* %sv_permsocks)
  %tobool15 = icmp ne i32 %call14, 0
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  %expval23 = call i64 @llvm.expect.i64(i64 %conv22, i64 0)
  %tobool24 = icmp ne i64 %expval23, 0
  br i1 %tobool24, label %do.body26, label %do.body34

do.body26:                                        ; preds = %if.end11
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2.528, i32 0, i32 0), i32 550, i64 12) #7, !srcloc !708
  br label %do.body27

do.body27:                                        ; preds = %do.body27, %do.body26
  br label %do.body27

do.body34:                                        ; preds = %if.end11
  %sv_tempsocks = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 9
  %call35 = call i32 @list_empty.548(%struct.list_head* %sv_tempsocks)
  %tobool36 = icmp ne i32 %call35, 0
  %lnot37 = xor i1 %tobool36, true
  %lnot39 = xor i1 %lnot37, true
  %lnot41 = xor i1 %lnot39, true
  %lnot.ext42 = zext i1 %lnot41 to i32
  %conv43 = sext i32 %lnot.ext42 to i64
  %expval44 = call i64 @llvm.expect.i64(i64 %conv43, i64 0)
  %tobool45 = icmp ne i64 %expval44, 0
  br i1 %tobool45, label %do.body47, label %do.end55

do.body47:                                        ; preds = %do.body34
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2.528, i32 0, i32 0), i32 551, i64 12) #7, !srcloc !709
  br label %do.body48

do.body48:                                        ; preds = %do.body48, %do.body47
  br label %do.body48

do.end55:                                         ; preds = %do.body34
  %5 = bitcast %struct.svc_serv* %serv to i8*
  call void @cache_clean_deferred(i8* %5)
  %sv_function = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 17
  %6 = load i32 (i8*)*, i32 (i8*)** %sv_function, align 8, !tbaa !710
  %tobool56 = icmp ne i32 (i8*)* %6, null
  br i1 %tobool56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %do.end55
  call void @svc_pool_map_put()
  br label %if.end58

if.end58:                                         ; preds = %if.then57, %do.end55
  %sv_pools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 14
  %7 = load %struct.svc_pool*, %struct.svc_pool** %sv_pools, align 8, !tbaa !711
  %8 = bitcast %struct.svc_pool* %7 to i8*
  call void @kfree(i8* %8)
  %9 = bitcast %struct.svc_serv* %serv to i8*
  call void @kfree(i8* %9)
  br label %return

return:                                           ; preds = %if.end58, %if.then8
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty.548(%struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal void @svc_pool_map_put() #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @svc_pool_map_mutex, i32 0)
  %count = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 0
  %0 = load i32, i32* %count, align 8, !tbaa !712
  %dec = add nsw i32 %0, -1
  store i32 %dec, i32* %count, align 8, !tbaa !712
  %tobool = icmp ne i32 %dec, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %to_pool = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 4
  %1 = load i32*, i32** %to_pool, align 8, !tbaa !714
  %2 = bitcast i32* %1 to i8*
  call void @kfree(i8* %2)
  %to_pool1 = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 4
  store i32* null, i32** %to_pool1, align 8, !tbaa !714
  %pool_to = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 3
  %3 = load i32*, i32** %pool_to, align 8, !tbaa !715
  %4 = bitcast i32* %3 to i8*
  call void @kfree(i8* %4)
  %pool_to2 = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 3
  store i32* null, i32** %pool_to2, align 8, !tbaa !715
  %npools = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 2
  store i32 0, i32* %npools, align 8, !tbaa !716
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @mutex_unlock(%struct.mutex* @svc_pool_map_mutex)
  ret void
}

declare void @mutex_lock_nested(%struct.mutex*, i32) #4

declare void @put_page(%struct.page*) #4

; Function Attrs: nounwind uwtable
define i32 @svc_set_num_threads(%struct.svc_serv* %serv, %struct.svc_pool* %pool, i32 %nrservs) #0 {
entry:
  %state = alloca i32, align 4
  %sv_nrthreads = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 3
  %0 = load i32, i32* %sv_nrthreads, align 8, !tbaa !707
  %sub = sub i32 %0, 1
  store i32 %sub, i32* %state, align 4, !tbaa !49
  %cmp = icmp eq %struct.svc_pool* %pool, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %sv_nrthreads1 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 3
  %1 = load i32, i32* %sv_nrthreads1, align 8, !tbaa !707
  %sub2 = sub i32 %1, 1
  %sub3 = sub i32 %nrservs, %sub2
  br label %if.end

if.else:                                          ; preds = %entry
  %sp_lock = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %pool, i32 0, i32 1
  call void @spin_lock_bh.544(%struct.spinlock* %sp_lock)
  %sp_nrthreads = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %pool, i32 0, i32 4
  %2 = load i32, i32* %sp_nrthreads, align 16, !tbaa !704
  %sub4 = sub i32 %nrservs, %2
  %sp_lock5 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %pool, i32 0, i32 1
  call void @spin_unlock_bh.545(%struct.spinlock* %sp_lock5)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %nrservs.addr.0 = phi i32 [ %sub3, %if.then ], [ %sub4, %if.else ]
  br label %while.cond

while.cond:                                       ; preds = %if.end25, %if.end
  %nrservs.addr.1 = phi i32 [ %nrservs.addr.0, %if.end ], [ %dec, %if.end25 ]
  %task.0 = phi %struct.task_struct* [ undef, %if.end ], [ %call13, %if.end25 ]
  %cmp6 = icmp sgt i32 %nrservs.addr.1, 0
  br i1 %cmp6, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %dec = add nsw i32 %nrservs.addr.1, -1
  %call = call %struct.svc_pool* @choose_pool(%struct.svc_serv* %serv, %struct.svc_pool* %pool, i32* %state)
  %sp_id = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %call, i32 0, i32 0
  %3 = load i32, i32* %sp_id, align 64, !tbaa !717
  %call7 = call i32 @svc_pool_map_get_node(i32 %3)
  %call8 = call %struct.svc_rqst* @svc_prepare_thread(%struct.svc_serv* %serv, %struct.svc_pool* %call, i32 %call7)
  %4 = bitcast %struct.svc_rqst* %call8 to i8*
  %call9 = call i64 @IS_ERR.551(i8* %4)
  %tobool = icmp ne i64 %call9, 0
  br i1 %tobool, label %if.then10, label %if.end12

if.then10:                                        ; preds = %while.body
  %5 = bitcast %struct.svc_rqst* %call8 to i8*
  %call11 = call i64 @PTR_ERR.552(i8* %5)
  %conv = trunc i64 %call11 to i32
  br label %while.end

if.end12:                                         ; preds = %while.body
  %sv_module = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 16
  %6 = load %struct.module*, %struct.module** %sv_module, align 8, !tbaa !718
  call void @__module_get(%struct.module* %6)
  %sv_function = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 17
  %7 = load i32 (i8*)*, i32 (i8*)** %sv_function, align 8, !tbaa !710
  %8 = bitcast %struct.svc_rqst* %call8 to i8*
  %sv_name = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 12
  %9 = load i8*, i8** %sv_name, align 8, !tbaa !719
  %call13 = call %struct.task_struct* (i32 (i8*)*, i8*, i32, i8*, ...) @kthread_create_on_node(i32 (i8*)* %7, i8* %8, i32 %call7, i8* %9)
  %10 = bitcast %struct.task_struct* %call13 to i8*
  %call14 = call i64 @IS_ERR.551(i8* %10)
  %tobool15 = icmp ne i64 %call14, 0
  br i1 %tobool15, label %if.then16, label %if.end20

if.then16:                                        ; preds = %if.end12
  %11 = bitcast %struct.task_struct* %call13 to i8*
  %call17 = call i64 @PTR_ERR.552(i8* %11)
  %conv18 = trunc i64 %call17 to i32
  %sv_module19 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 16
  %12 = load %struct.module*, %struct.module** %sv_module19, align 8, !tbaa !718
  call void @module_put(%struct.module* %12)
  call void @svc_exit_thread(%struct.svc_rqst* %call8)
  br label %while.end

if.end20:                                         ; preds = %if.end12
  %rq_task = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %call8, i32 0, i32 41
  store %struct.task_struct* %call13, %struct.task_struct** %rq_task, align 8, !tbaa !720
  %sv_nrpools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 13
  %13 = load i32, i32* %sv_nrpools, align 8, !tbaa !721
  %cmp21 = icmp ugt i32 %13, 1
  br i1 %cmp21, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.end20
  %sp_id24 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %call, i32 0, i32 0
  %14 = load i32, i32* %sp_id24, align 64, !tbaa !717
  call void @svc_pool_map_set_cpumask(%struct.task_struct* %call13, i32 %14)
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %if.end20
  call void @svc_sock_update_bufs(%struct.svc_serv* %serv)
  %call26 = call i32 @wake_up_process(%struct.task_struct* %call13)
  br label %while.cond

while.end:                                        ; preds = %if.then16, %if.then10, %while.cond
  %nrservs.addr.2 = phi i32 [ %dec, %if.then10 ], [ %dec, %if.then16 ], [ %nrservs.addr.1, %while.cond ]
  %task.1 = phi %struct.task_struct* [ %task.0, %if.then10 ], [ %call13, %if.then16 ], [ %task.0, %while.cond ]
  %error.0 = phi i32 [ %conv, %if.then10 ], [ %conv18, %if.then16 ], [ 0, %while.cond ]
  br label %while.cond27

while.cond27:                                     ; preds = %while.body33, %while.end
  %nrservs.addr.3 = phi i32 [ %nrservs.addr.2, %while.end ], [ %inc, %while.body33 ]
  %task.2 = phi %struct.task_struct* [ %task.1, %while.end ], [ %task.3, %while.body33 ]
  %cmp28 = icmp slt i32 %nrservs.addr.3, 0
  br i1 %cmp28, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond27
  %call30 = call %struct.task_struct* @choose_victim(%struct.svc_serv* %serv, %struct.svc_pool* %pool, i32* %state)
  %cmp31 = icmp ne %struct.task_struct* %call30, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond27
  %task.3 = phi %struct.task_struct* [ %call30, %land.rhs ], [ %task.2, %while.cond27 ]
  %15 = phi i1 [ false, %while.cond27 ], [ %cmp31, %land.rhs ]
  br i1 %15, label %while.body33, label %while.end35

while.body33:                                     ; preds = %land.end
  %call34 = call i32 @send_sig(i32 2, %struct.task_struct* %task.3, i32 1)
  %inc = add nsw i32 %nrservs.addr.3, 1
  br label %while.cond27

while.end35:                                      ; preds = %land.end
  ret i32 %error.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.svc_pool* @choose_pool(%struct.svc_serv* %serv, %struct.svc_pool* %pool, i32* %state) #2 {
entry:
  %cmp = icmp ne %struct.svc_pool* %pool, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %sv_pools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 14
  %0 = load %struct.svc_pool*, %struct.svc_pool** %sv_pools, align 8, !tbaa !711
  %1 = load i32, i32* %state, align 4, !tbaa !49
  %inc = add i32 %1, 1
  store i32 %inc, i32* %state, align 4, !tbaa !49
  %sv_nrpools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 13
  %2 = load i32, i32* %sv_nrpools, align 8, !tbaa !721
  %rem = urem i32 %1, %2
  %idxprom = zext i32 %rem to i64
  %arrayidx = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i64 %idxprom
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi %struct.svc_pool* [ %arrayidx, %if.end ], [ %pool, %entry ]
  ret %struct.svc_pool* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_pool_map_get_node(i32 %pidx) #0 {
entry:
  %count = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 0
  %0 = load i32, i32* %count, align 8, !tbaa !712
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  %mode = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 1
  %1 = load i32, i32* %mode, align 4, !tbaa !722
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  %pool_to = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 3
  %2 = load i32*, i32** %pool_to, align 8, !tbaa !715
  %idxprom = zext i32 %pidx to i64
  %arrayidx = getelementptr inbounds i32, i32* %2, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !49
  %call = call i32 @__cpu_to_node(i32 %3)
  br label %cleanup

if.end:                                           ; preds = %if.then
  %mode2 = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 1
  %4 = load i32, i32* %mode2, align 4, !tbaa !722
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.then4, label %cleanup

if.then4:                                         ; preds = %if.end
  %pool_to5 = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 3
  %5 = load i32*, i32** %pool_to5, align 8, !tbaa !715
  %idxprom6 = zext i32 %pidx to i64
  %arrayidx7 = getelementptr inbounds i32, i32* %5, i64 %idxprom6
  %6 = load i32, i32* %arrayidx7, align 4, !tbaa !49
  br label %cleanup

cleanup:                                          ; preds = %if.then4, %if.end, %if.then1, %entry
  %retval.0 = phi i32 [ %call, %if.then1 ], [ %6, %if.then4 ], [ -1, %if.end ], [ -1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.svc_rqst* @svc_prepare_thread(%struct.svc_serv* %serv, %struct.svc_pool* %pool, i32 %node) #0 {
entry:
  %call = call i8* @kzalloc_node(i64 6992, i32 208, i32 %node)
  %0 = bitcast i8* %call to %struct.svc_rqst*
  %tobool = icmp ne %struct.svc_rqst* %0, null
  br i1 %tobool, label %do.body, label %out_enomem

do.body:                                          ; preds = %entry
  %rq_wait = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %0, i32 0, i32 40
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %rq_wait, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.3.555, i32 0, i32 0), %struct.lock_class_key* @svc_prepare_thread.__key)
  %sv_nrthreads = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 3
  %1 = load i32, i32* %sv_nrthreads, align 8, !tbaa !707
  %inc = add i32 %1, 1
  store i32 %inc, i32* %sv_nrthreads, align 8, !tbaa !707
  %sp_lock = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %pool, i32 0, i32 1
  call void @spin_lock_bh.544(%struct.spinlock* %sp_lock)
  %sp_nrthreads = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %pool, i32 0, i32 4
  %2 = load i32, i32* %sp_nrthreads, align 16, !tbaa !704
  %inc1 = add i32 %2, 1
  store i32 %inc1, i32* %sp_nrthreads, align 16, !tbaa !704
  %rq_all = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %0, i32 0, i32 1
  %sp_all_threads = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %pool, i32 0, i32 5
  call void @list_add.556(%struct.list_head* %rq_all, %struct.list_head* %sp_all_threads)
  %sp_lock2 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %pool, i32 0, i32 1
  call void @spin_unlock_bh.545(%struct.spinlock* %sp_lock2)
  %rq_server = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %0, i32 0, i32 7
  store %struct.svc_serv* %serv, %struct.svc_serv** %rq_server, align 8, !tbaa !642
  %rq_pool = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %0, i32 0, i32 8
  store %struct.svc_pool* %pool, %struct.svc_pool** %rq_pool, align 8, !tbaa !702
  %sv_xdrsize = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 7
  %3 = load i32, i32* %sv_xdrsize, align 8, !tbaa !723
  %conv = zext i32 %3 to i64
  %call.i1 = call i8* @__kmalloc_node(i64 %conv, i32 208, i32 %node) #7
  %rq_argp = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %0, i32 0, i32 29
  store i8* %call.i1, i8** %rq_argp, align 8, !tbaa !674
  %rq_argp4 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %0, i32 0, i32 29
  %4 = load i8*, i8** %rq_argp4, align 8, !tbaa !674
  %tobool5 = icmp ne i8* %4, null
  br i1 %tobool5, label %if.end7, label %out_thread

if.end7:                                          ; preds = %do.body
  %sv_xdrsize8 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 7
  %5 = load i32, i32* %sv_xdrsize8, align 8, !tbaa !723
  %conv9 = zext i32 %5 to i64
  %call.i = call i8* @__kmalloc_node(i64 %conv9, i32 208, i32 %node) #7
  %rq_resp = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %0, i32 0, i32 30
  store i8* %call.i, i8** %rq_resp, align 8, !tbaa !676
  %rq_resp11 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %0, i32 0, i32 30
  %6 = load i8*, i8** %rq_resp11, align 8, !tbaa !676
  %tobool12 = icmp ne i8* %6, null
  br i1 %tobool12, label %if.end14, label %out_thread

if.end14:                                         ; preds = %if.end7
  %sv_max_mesg = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 6
  %7 = load i32, i32* %sv_max_mesg, align 4, !tbaa !724
  %call15 = call i32 @svc_init_buffer(%struct.svc_rqst* %0, i32 %7, i32 %node)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %cleanup, label %out_thread

out_thread:                                       ; preds = %if.end14, %if.end7, %do.body
  call void @svc_exit_thread(%struct.svc_rqst* %0)
  br label %out_enomem

out_enomem:                                       ; preds = %out_thread, %entry
  %call19 = call i8* @ERR_PTR.557(i64 -12)
  %8 = bitcast i8* %call19 to %struct.svc_rqst*
  br label %cleanup

cleanup:                                          ; preds = %out_enomem, %if.end14
  %retval.0 = phi %struct.svc_rqst* [ %8, %out_enomem ], [ %0, %if.end14 ]
  ret %struct.svc_rqst* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR.551(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR.552(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

declare void @__module_get(%struct.module*) #4

declare %struct.task_struct* @kthread_create_on_node(i32 (i8*)*, i8*, i32, i8*, ...) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @svc_pool_map_set_cpumask(%struct.task_struct* %task, i32 %pidx) #2 {
entry:
  %pool_to = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 3
  %0 = load i32*, i32** %pool_to, align 8, !tbaa !715
  %idxprom = zext i32 %pidx to i64
  %arrayidx = getelementptr inbounds i32, i32* %0, i64 %idxprom
  %1 = load i32, i32* %arrayidx, align 4, !tbaa !49
  %count = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 0
  %2 = load i32, i32* %count, align 8, !tbaa !712
  %cmp = icmp eq i32 %2, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  %3 = load i8, i8* @svc_pool_map_set_cpumask.__warned, align 1, !tbaa !29, !range !31
  %tobool7 = trunc i8 %3 to i1
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %tobool14 = icmp ne i32 %lnot.ext13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2.528, i32 0, i32 0), i32 326)
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then
  %tobool23 = icmp ne i32 %lnot.ext13, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end
  store i8 1, i8* @svc_pool_map_set_cpumask.__warned, align 1, !tbaa !29
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end, %entry
  %count42 = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 0
  %4 = load i32, i32* %count42, align 8, !tbaa !712
  %cmp43 = icmp eq i32 %4, 0
  br i1 %cmp43, label %cleanup.cont, label %if.end46

if.end46:                                         ; preds = %if.end33
  %mode = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 1
  %5 = load i32, i32* %mode, align 4, !tbaa !722
  %Pivot = icmp slt i32 %5, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end46
  %SwitchLeaf2 = icmp eq i32 %5, 2
  br i1 %SwitchLeaf2, label %sw.bb48, label %cleanup.cont

LeafBlock:                                        ; preds = %if.end46
  %SwitchLeaf = icmp eq i32 %5, 1
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup.cont

sw.bb:                                            ; preds = %LeafBlock
  %call = call %struct.cpumask* @get_cpu_mask(i32 %1)
  %call47 = call i32 @set_cpus_allowed_ptr(%struct.task_struct* %task, %struct.cpumask* %call)
  br label %cleanup.cont

sw.bb48:                                          ; preds = %LeafBlock1
  %call49 = call %struct.cpumask* @cpumask_of_node(i32 %1)
  %call50 = call i32 @set_cpus_allowed_ptr(%struct.task_struct* %task, %struct.cpumask* %call49)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %sw.bb48, %sw.bb, %LeafBlock, %LeafBlock1, %if.end33
  ret void
}

declare i32 @wake_up_process(%struct.task_struct*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.task_struct* @choose_victim(%struct.svc_serv* %serv, %struct.svc_pool* %pool, i32* %state) #2 {
entry:
  %cmp = icmp ne %struct.svc_pool* %pool, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %sp_lock = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %pool, i32 0, i32 1
  call void @spin_lock_bh.544(%struct.spinlock* %sp_lock)
  br label %found_pool

if.else:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %if.end, %if.else
  %i.0 = phi i32 [ 0, %if.else ], [ %inc, %if.end ]
  %sv_nrpools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 13
  %0 = load i32, i32* %sv_nrpools, align 8, !tbaa !721
  %cmp1 = icmp ult i32 %i.0, %0
  br i1 %cmp1, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %sv_pools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 14
  %1 = load %struct.svc_pool*, %struct.svc_pool** %sv_pools, align 8, !tbaa !711
  %2 = load i32, i32* %state, align 4, !tbaa !49
  %dec = add i32 %2, -1
  store i32 %dec, i32* %state, align 4, !tbaa !49
  %sv_nrpools2 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 13
  %3 = load i32, i32* %sv_nrpools2, align 8, !tbaa !721
  %rem = urem i32 %dec, %3
  %idxprom = zext i32 %rem to i64
  %arrayidx = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %1, i64 %idxprom
  %sp_lock3 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx, i32 0, i32 1
  call void @spin_lock_bh.544(%struct.spinlock* %sp_lock3)
  %sp_all_threads = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx, i32 0, i32 5
  %call = call i32 @list_empty.548(%struct.list_head* %sp_all_threads)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %found_pool

if.end:                                           ; preds = %for.body
  %sp_lock5 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx, i32 0, i32 1
  call void @spin_unlock_bh.545(%struct.spinlock* %sp_lock5)
  %inc = add i32 %i.0, 1
  br label %for.cond

found_pool:                                       ; preds = %for.body, %if.then
  %pool.addr.0 = phi %struct.svc_pool* [ %pool, %if.then ], [ %arrayidx, %for.body ]
  %sp_all_threads7 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %pool.addr.0, i32 0, i32 5
  %call8 = call i32 @list_empty.548(%struct.list_head* %sp_all_threads7)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end12, label %if.then10

if.then10:                                        ; preds = %found_pool
  %sp_all_threads11 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %pool.addr.0, i32 0, i32 5
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %sp_all_threads11, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !725
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 -16
  %6 = bitcast i8* %add.ptr to %struct.svc_rqst*
  %rq_all = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %6, i32 0, i32 1
  call void @list_del_init.553(%struct.list_head* %rq_all)
  %rq_task = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %6, i32 0, i32 41
  %7 = load %struct.task_struct*, %struct.task_struct** %rq_task, align 8, !tbaa !720
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %found_pool
  %task.0 = phi %struct.task_struct* [ null, %found_pool ], [ %7, %if.then10 ]
  %sp_lock13 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %pool.addr.0, i32 0, i32 1
  call void @spin_unlock_bh.545(%struct.spinlock* %sp_lock13)
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %for.cond
  %retval.0 = phi %struct.task_struct* [ %task.0, %if.end12 ], [ null, %for.cond ]
  ret %struct.task_struct* %retval.0
}

declare i32 @send_sig(i32, %struct.task_struct*, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init.553(%struct.list_head* %entry1) #2 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD.554(%struct.list_head* %entry1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.554(%struct.list_head* %list) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !163
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.cpumask* @get_cpu_mask(i32 %cpu) #2 {
entry:
  %rem = urem i32 %cpu, 64
  %add = add i32 1, %rem
  %idxprom = zext i32 %add to i64
  %arrayidx = getelementptr inbounds [65 x [64 x i64]], [65 x [64 x i64]]* @cpu_bit_bitmap, i64 0, i64 %idxprom
  %arraydecay = getelementptr inbounds [64 x i64], [64 x i64]* %arrayidx, i32 0, i32 0
  %div = udiv i32 %cpu, 64
  %idx.ext = zext i32 %div to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds i64, i64* %arraydecay, i64 %idx.neg
  %0 = bitcast i64* %add.ptr to i8*
  %1 = bitcast i8* %0 to %struct.cpumask*
  ret %struct.cpumask* %1
}

declare i32 @set_cpus_allowed_ptr(%struct.task_struct*, %struct.cpumask*) #4

declare %struct.cpumask* @cpumask_of_node(i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc_node(i64 %size, i32 %flags, i32 %node) #2 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc_node(i64 %size, i32 %or, i32 %node) #7
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add.556(%struct.list_head* %new, %struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_init_buffer(%struct.svc_rqst* %rqstp, i32 %size, i32 %node) #0 {
entry:
  %call = call i32 @svc_is_backchannel(%struct.svc_rqst* %rqstp)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup61, label %if.end

if.end:                                           ; preds = %entry
  %conv = zext i32 %size to i64
  %div = udiv i64 %conv, 4096
  %add = add i64 %div, 1
  %conv1 = trunc i64 %add to i32
  %conv2 = zext i32 %conv1 to i64
  %cmp = icmp ugt i64 %conv2, 259
  %lnot = xor i1 %cmp, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %tobool5 = icmp ne i32 %lnot.ext, 0
  %lnot6 = xor i1 %tobool5, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv10 = sext i32 %lnot.ext9 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv10, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %if.then12, label %if.end40

if.then12:                                        ; preds = %if.end
  %0 = load i8, i8* @svc_init_buffer.__warned, align 1, !tbaa !29, !range !31
  %tobool13 = trunc i8 %0 to i1
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot18 = xor i1 %lnot16, true
  %lnot.ext19 = zext i1 %lnot18 to i32
  %tobool20 = icmp ne i32 %lnot.ext19, 0
  %lnot21 = xor i1 %tobool20, true
  %lnot23 = xor i1 %lnot21, true
  %lnot.ext24 = zext i1 %lnot23 to i32
  %conv25 = sext i32 %lnot.ext24 to i64
  %expval26 = call i64 @llvm.expect.i64(i64 %conv25, i64 0)
  %tobool27 = icmp ne i64 %expval26, 0
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.then12
  call void @warn_slowpath_null(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2.528, i32 0, i32 0), i32 580)
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.then12
  %tobool30 = icmp ne i32 %lnot.ext19, 0
  %lnot31 = xor i1 %tobool30, true
  %lnot33 = xor i1 %lnot31, true
  %lnot.ext34 = zext i1 %lnot33 to i32
  %conv35 = sext i32 %lnot.ext34 to i64
  %expval36 = call i64 @llvm.expect.i64(i64 %conv35, i64 0)
  %tobool37 = icmp ne i64 %expval36, 0
  br i1 %tobool37, label %if.then38, label %if.end40

if.then38:                                        ; preds = %if.end29
  store i8 1, i8* @svc_init_buffer.__warned, align 1, !tbaa !29
  br label %if.end40

if.end40:                                         ; preds = %if.then38, %if.end29, %if.end
  %conv49 = zext i32 %conv1 to i64
  %cmp50 = icmp ugt i64 %conv49, 259
  %.conv1 = select i1 %cmp50, i32 259, i32 %conv1
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %if.end40
  %pages.1 = phi i32 [ %.conv1, %if.end40 ], [ %pages.2, %cleanup.cont ]
  %arghi.0 = phi i32 [ 0, %if.end40 ], [ %arghi.1, %cleanup.cont ]
  %tobool54 = icmp ne i32 %pages.1, 0
  br i1 %tobool54, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call55 = call %struct.page* @alloc_pages_node(i32 %node, i32 208, i32 0)
  %tobool56 = icmp ne %struct.page* %call55, null
  br i1 %tobool56, label %if.end58, label %LeafBlock

if.end58:                                         ; preds = %while.body
  %rq_pages = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %inc = add i32 %arghi.0, 1
  %idxprom = zext i32 %arghi.0 to i64
  %arrayidx = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages, i64 0, i64 %idxprom
  store %struct.page* %call55, %struct.page** %arrayidx, align 8, !tbaa !28
  %dec = add i32 %pages.1, -1
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end58, %while.body
  %pages.2 = phi i32 [ %dec, %if.end58 ], [ %pages.1, %while.body ]
  %arghi.1 = phi i32 [ %inc, %if.end58 ], [ %arghi.0, %while.body ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end58 ], [ 3, %while.body ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 3
  br i1 %SwitchLeaf, label %while.end, label %cleanup.cont

cleanup.cont:                                     ; preds = %LeafBlock
  br label %while.cond

while.end:                                        ; preds = %LeafBlock, %while.cond
  %pages.3 = phi i32 [ %pages.2, %LeafBlock ], [ %pages.1, %while.cond ]
  %cmp59 = icmp eq i32 %pages.3, 0
  %conv60 = zext i1 %cmp59 to i32
  br label %cleanup61

cleanup61:                                        ; preds = %while.end, %entry
  %retval.0 = phi i32 [ %conv60, %while.end ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR.557(i64 %error) #2 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @svc_is_backchannel(%struct.svc_rqst* %rqstp) #2 {
entry:
  %rq_server = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 7
  %0 = load %struct.svc_serv*, %struct.svc_serv** %rq_server, align 8, !tbaa !642
  %sv_bc_xprt = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 21
  %1 = load %struct.svc_xprt*, %struct.svc_xprt** %sv_bc_xprt, align 8, !tbaa !645
  %tobool = icmp ne %struct.svc_xprt* %1, null
  %. = select i1 %tobool, i32 1, i32 0
  ret i32 %.
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.page* @alloc_pages_node(i32 %nid, i32 %gfp_mask, i32 %order) #2 {
entry:
  %cmp = icmp slt i32 %nid, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @numa_node_id()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %nid.addr.0 = phi i32 [ %call, %if.then ], [ %nid, %entry ]
  %call1 = call %struct.zonelist* @node_zonelist(i32 %nid.addr.0, i32 %gfp_mask)
  %call2 = call %struct.page* @__alloc_pages(i32 %gfp_mask, i32 %order, %struct.zonelist* %call1)
  ret %struct.page* %call2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @numa_node_id() #2 {
entry:
  %0 = call i32 asm "movl %gs:${1:P},$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @numa_node) #9, !srcloc !726
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.zonelist* @node_zonelist(i32 %nid, i32 %flags) #2 {
entry:
  %idxprom = sext i32 %nid to i64
  %arrayidx = getelementptr inbounds [0 x %struct.pglist_data*], [0 x %struct.pglist_data*]* @node_data, i64 0, i64 %idxprom
  %0 = load %struct.pglist_data*, %struct.pglist_data** %arrayidx, align 8, !tbaa !28
  %node_zonelists = getelementptr inbounds %struct.pglist_data, %struct.pglist_data* %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [2 x %struct.zonelist], [2 x %struct.zonelist]* %node_zonelists, i32 0, i32 0
  %call = call i32 @gfp_zonelist(i32 %flags)
  %idx.ext = sext i32 %call to i64
  %add.ptr = getelementptr inbounds %struct.zonelist, %struct.zonelist* %arraydecay, i64 %idx.ext
  ret %struct.zonelist* %add.ptr
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.page* @__alloc_pages(i32 %gfp_mask, i32 %order, %struct.zonelist* %zonelist) #2 {
entry:
  %call = call %struct.page* @__alloc_pages_nodemask(i32 %gfp_mask, i32 %order, %struct.zonelist* %zonelist, %struct.tcp_mib* null)
  ret %struct.page* %call
}

declare %struct.page* @__alloc_pages_nodemask(i32, i32, %struct.zonelist*, %struct.tcp_mib*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @gfp_zonelist(i32 %flags) #2 {
entry:
  %and = and i32 %flags, 262144
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  %. = select i1 %tobool2, i32 1, i32 0
  ret i32 %.
}

declare i8* @__kmalloc_node(i64, i32, i32) #4

declare i32 @__cpu_to_node(i32) #4

; Function Attrs: nounwind uwtable
define void @svc_shutdown_net(%struct.svc_serv* %serv, %struct.net* %net) #0 {
entry:
  call void @svc_close_net(%struct.svc_serv* %serv, %struct.net* %net)
  %sv_shutdown = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 15
  %0 = load void (%struct.svc_serv*, %struct.net*)*, void (%struct.svc_serv*, %struct.net*)** %sv_shutdown, align 8, !tbaa !727
  %tobool = icmp ne void (%struct.svc_serv*, %struct.net*)* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %sv_shutdown1 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 15
  %1 = load void (%struct.svc_serv*, %struct.net*)*, void (%struct.svc_serv*, %struct.net*)** %sv_shutdown1, align 8, !tbaa !727
  call void %1(%struct.svc_serv* %serv, %struct.net* %net)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.svc_serv* @svc_create_pooled(%struct.svc_program* %prog, i32 %bufsize, void (%struct.svc_serv*, %struct.net*)* %shutdown, i32 (i8*)* %func, %struct.module* %mod) #0 {
entry:
  %call = call i32 @svc_pool_map_get()
  %call1 = call %struct.svc_serv* @__svc_create(%struct.svc_program* %prog, i32 %bufsize, i32 %call, void (%struct.svc_serv*, %struct.net*)* %shutdown)
  %cmp = icmp ne %struct.svc_serv* %call1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %sv_function = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %call1, i32 0, i32 17
  store i32 (i8*)* %func, i32 (i8*)** %sv_function, align 8, !tbaa !710
  %sv_module = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %call1, i32 0, i32 16
  store %struct.module* %mod, %struct.module** %sv_module, align 8, !tbaa !718
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.svc_serv* %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_pool_map_get() #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @svc_pool_map_mutex, i32 0)
  %count = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 0
  %0 = load i32, i32* %count, align 8, !tbaa !712
  %inc = add nsw i32 %0, 1
  store i32 %inc, i32* %count, align 8, !tbaa !712
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @mutex_unlock(%struct.mutex* @svc_pool_map_mutex)
  br label %cleanup

if.end:                                           ; preds = %entry
  %mode = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 1
  %1 = load i32, i32* %mode, align 4, !tbaa !722
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %call = call i32 @svc_pool_map_choose_mode()
  %mode3 = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 1
  store i32 %call, i32* %mode3, align 4, !tbaa !722
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %mode5 = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 1
  %2 = load i32, i32* %mode5, align 4, !tbaa !722
  %Pivot = icmp slt i32 %2, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end4
  %SwitchLeaf2 = icmp eq i32 %2, 2
  br i1 %SwitchLeaf2, label %sw.bb7, label %sw.epilog

LeafBlock:                                        ; preds = %if.end4
  %SwitchLeaf = icmp eq i32 %2, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %call6 = call i32 @svc_pool_map_init_percpu(%struct.svc_pool_map* @svc_pool_map)
  br label %sw.epilog

sw.bb7:                                           ; preds = %LeafBlock1
  %call8 = call i32 @svc_pool_map_init_pernode(%struct.svc_pool_map* @svc_pool_map)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb7, %sw.bb, %LeafBlock, %LeafBlock1
  %npools.0 = phi i32 [ %call6, %sw.bb ], [ %call8, %sw.bb7 ], [ -1, %LeafBlock1 ], [ -1, %LeafBlock ]
  %cmp9 = icmp slt i32 %npools.0, 0
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %sw.epilog
  %mode11 = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 1
  store i32 0, i32* %mode11, align 4, !tbaa !722
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %sw.epilog
  %npools.1 = phi i32 [ 1, %if.then10 ], [ %npools.0, %sw.epilog ]
  %npools13 = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 2
  store i32 %npools.1, i32* %npools13, align 8, !tbaa !716
  call void @mutex_unlock(%struct.mutex* @svc_pool_map_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %if.then
  %npools14 = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 2
  %3 = load i32, i32* %npools14, align 8, !tbaa !716
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal %struct.svc_serv* @__svc_create(%struct.svc_program* %prog, i32 %bufsize, i32 %npools, void (%struct.svc_serv*, %struct.net*)* %shutdown) #0 {
entry:
  %call = call i8* @kzalloc.558(i64 512, i32 208)
  %0 = bitcast i8* %call to %struct.svc_serv*
  %tobool = icmp ne %struct.svc_serv* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %pg_name = getelementptr inbounds %struct.svc_program, %struct.svc_program* %prog, i32 0, i32 6
  %1 = load i8*, i8** %pg_name, align 8, !tbaa !685
  %sv_name = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 12
  store i8* %1, i8** %sv_name, align 8, !tbaa !719
  %sv_program = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 0
  store %struct.svc_program* %prog, %struct.svc_program** %sv_program, align 8, !tbaa !728
  %sv_nrthreads = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 3
  store i32 1, i32* %sv_nrthreads, align 8, !tbaa !707
  %pg_stats = getelementptr inbounds %struct.svc_program, %struct.svc_program* %prog, i32 0, i32 8
  %2 = load %struct.svc_stat*, %struct.svc_stat** %pg_stats, align 8, !tbaa !729
  %sv_stats = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 1
  store %struct.svc_stat* %2, %struct.svc_stat** %sv_stats, align 8, !tbaa !670
  %cmp = icmp ugt i32 %bufsize, 1048576
  %.bufsize = select i1 %cmp, i32 1048576, i32 %bufsize
  %tobool3 = icmp ne i32 %.bufsize, 0
  %cond = select i1 %tobool3, i32 %.bufsize, i32 4096
  %sv_max_payload = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 5
  store i32 %cond, i32* %sv_max_payload, align 8, !tbaa !643
  %sv_max_payload4 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 5
  %3 = load i32, i32* %sv_max_payload4, align 8, !tbaa !643
  %conv = zext i32 %3 to i64
  %add = add i64 %conv, 4096
  %add5 = add i64 %add, 4095
  %div = udiv i64 %add5, 4096
  %mul = mul i64 %div, 4096
  %conv6 = trunc i64 %mul to i32
  %sv_max_mesg = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 6
  store i32 %conv6, i32* %sv_max_mesg, align 4, !tbaa !724
  %sv_shutdown = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 15
  store void (%struct.svc_serv*, %struct.net*)* %shutdown, void (%struct.svc_serv*, %struct.net*)** %sv_shutdown, align 8, !tbaa !727
  br label %while.cond

while.cond:                                       ; preds = %for.end, %if.end
  %xdrsize.0 = phi i32 [ 0, %if.end ], [ %xdrsize.1, %for.end ]
  %prog.addr.0 = phi %struct.svc_program* [ %prog, %if.end ], [ %15, %for.end ]
  %tobool7 = icmp ne %struct.svc_program* %prog.addr.0, null
  br i1 %tobool7, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %pg_nvers = getelementptr inbounds %struct.svc_program, %struct.svc_program* %prog.addr.0, i32 0, i32 4
  %4 = load i32, i32* %pg_nvers, align 4, !tbaa !662
  %sub = sub i32 %4, 1
  %pg_lovers = getelementptr inbounds %struct.svc_program, %struct.svc_program* %prog.addr.0, i32 0, i32 2
  store i32 %sub, i32* %pg_lovers, align 4, !tbaa !686
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body
  %vers.0 = phi i32 [ 0, %while.body ], [ %inc, %for.inc ]
  %xdrsize.1 = phi i32 [ %xdrsize.0, %while.body ], [ %xdrsize.3, %for.inc ]
  %pg_nvers8 = getelementptr inbounds %struct.svc_program, %struct.svc_program* %prog.addr.0, i32 0, i32 4
  %5 = load i32, i32* %pg_nvers8, align 4, !tbaa !662
  %cmp9 = icmp ult i32 %vers.0, %5
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %pg_vers = getelementptr inbounds %struct.svc_program, %struct.svc_program* %prog.addr.0, i32 0, i32 5
  %6 = load %struct.svc_version**, %struct.svc_version*** %pg_vers, align 8, !tbaa !663
  %idxprom = zext i32 %vers.0 to i64
  %arrayidx = getelementptr inbounds %struct.svc_version*, %struct.svc_version** %6, i64 %idxprom
  %7 = load %struct.svc_version*, %struct.svc_version** %arrayidx, align 8, !tbaa !28
  %tobool11 = icmp ne %struct.svc_version* %7, null
  br i1 %tobool11, label %if.then12, label %for.inc

if.then12:                                        ; preds = %for.body
  %pg_hivers = getelementptr inbounds %struct.svc_program, %struct.svc_program* %prog.addr.0, i32 0, i32 3
  store i32 %vers.0, i32* %pg_hivers, align 8, !tbaa !687
  %pg_lovers13 = getelementptr inbounds %struct.svc_program, %struct.svc_program* %prog.addr.0, i32 0, i32 2
  %8 = load i32, i32* %pg_lovers13, align 4, !tbaa !686
  %cmp14 = icmp ugt i32 %8, %vers.0
  br i1 %cmp14, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.then12
  %pg_lovers17 = getelementptr inbounds %struct.svc_program, %struct.svc_program* %prog.addr.0, i32 0, i32 2
  store i32 %vers.0, i32* %pg_lovers17, align 4, !tbaa !686
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.then12
  %pg_vers19 = getelementptr inbounds %struct.svc_program, %struct.svc_program* %prog.addr.0, i32 0, i32 5
  %9 = load %struct.svc_version**, %struct.svc_version*** %pg_vers19, align 8, !tbaa !663
  %idxprom20 = zext i32 %vers.0 to i64
  %arrayidx21 = getelementptr inbounds %struct.svc_version*, %struct.svc_version** %9, i64 %idxprom20
  %10 = load %struct.svc_version*, %struct.svc_version** %arrayidx21, align 8, !tbaa !28
  %vs_xdrsize = getelementptr inbounds %struct.svc_version, %struct.svc_version* %10, i32 0, i32 3
  %11 = load i32, i32* %vs_xdrsize, align 8, !tbaa !730
  %cmp22 = icmp ugt i32 %11, %xdrsize.1
  br i1 %cmp22, label %if.then24, label %for.inc

if.then24:                                        ; preds = %if.end18
  %pg_vers25 = getelementptr inbounds %struct.svc_program, %struct.svc_program* %prog.addr.0, i32 0, i32 5
  %12 = load %struct.svc_version**, %struct.svc_version*** %pg_vers25, align 8, !tbaa !663
  %idxprom26 = zext i32 %vers.0 to i64
  %arrayidx27 = getelementptr inbounds %struct.svc_version*, %struct.svc_version** %12, i64 %idxprom26
  %13 = load %struct.svc_version*, %struct.svc_version** %arrayidx27, align 8, !tbaa !28
  %vs_xdrsize28 = getelementptr inbounds %struct.svc_version, %struct.svc_version* %13, i32 0, i32 3
  %14 = load i32, i32* %vs_xdrsize28, align 8, !tbaa !730
  br label %for.inc

for.inc:                                          ; preds = %if.then24, %if.end18, %for.body
  %xdrsize.3 = phi i32 [ %xdrsize.1, %for.body ], [ %14, %if.then24 ], [ %xdrsize.1, %if.end18 ]
  %inc = add i32 %vers.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %pg_next = getelementptr inbounds %struct.svc_program, %struct.svc_program* %prog.addr.0, i32 0, i32 0
  %15 = load %struct.svc_program*, %struct.svc_program** %pg_next, align 8, !tbaa !731
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %sv_xdrsize = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 7
  store i32 %xdrsize.0, i32* %sv_xdrsize, align 8, !tbaa !723
  %sv_tempsocks = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 9
  call void @INIT_LIST_HEAD.554(%struct.list_head* %sv_tempsocks)
  %sv_permsocks = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 8
  call void @INIT_LIST_HEAD.554(%struct.list_head* %sv_permsocks)
  %sv_temptimer = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 11
  call void @init_timer_key(%struct.timer_list* %sv_temptimer, i32 0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.18.559, i32 0, i32 0), %struct.lock_class_key* @__svc_create.__key)
  %sv_lock = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 2
  %call32 = call %struct.raw_spinlock* @spinlock_check.560(%struct.spinlock* %sv_lock)
  %sv_lock34 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 2
  %16 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %sv_lock34, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %16 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.20.561, i32 0, i32 0), %struct.lock_class_key* @__svc_create.__key.19)
  %sv_nrpools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 13
  store i32 %npools, i32* %sv_nrpools, align 8, !tbaa !721
  %sv_nrpools39 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 13
  %17 = load i32, i32* %sv_nrpools39, align 8, !tbaa !721
  %conv40 = zext i32 %17 to i64
  %call41 = call i8* @kcalloc.562(i64 %conv40, i64 192, i32 208)
  %18 = bitcast i8* %call41 to %struct.svc_pool*
  %sv_pools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 14
  store %struct.svc_pool* %18, %struct.svc_pool** %sv_pools, align 8, !tbaa !711
  %sv_pools42 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 14
  %19 = load %struct.svc_pool*, %struct.svc_pool** %sv_pools42, align 8, !tbaa !711
  %tobool43 = icmp ne %struct.svc_pool* %19, null
  br i1 %tobool43, label %if.end45, label %if.then44

if.then44:                                        ; preds = %while.end
  %20 = bitcast %struct.svc_serv* %0 to i8*
  call void @kfree(i8* %20)
  br label %cleanup

if.end45:                                         ; preds = %while.end
  br label %for.cond46

for.cond46:                                       ; preds = %do.end64, %if.end45
  %i.0 = phi i32 [ 0, %if.end45 ], [ %inc75, %do.end64 ]
  %sv_nrpools47 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 13
  %21 = load i32, i32* %sv_nrpools47, align 8, !tbaa !721
  %cmp48 = icmp ult i32 %i.0, %21
  br i1 %cmp48, label %for.body50, label %for.end76

for.body50:                                       ; preds = %for.cond46
  %sv_pools51 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 14
  %22 = load %struct.svc_pool*, %struct.svc_pool** %sv_pools51, align 8, !tbaa !711
  %idxprom52 = zext i32 %i.0 to i64
  %arrayidx53 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %22, i64 %idxprom52
  %23 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %23, 512
  %tobool55 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool55, true
  %lnot56 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot56 to i32
  %conv57 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv57, i64 0)
  %tobool58 = icmp ne i64 %expval, 0
  br i1 %tobool58, label %if.then59, label %do.end64

if.then59:                                        ; preds = %for.body50
  %24 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end64

do.end64:                                         ; preds = %if.then59, %for.body50
  %sp_id = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx53, i32 0, i32 0
  store i32 %i.0, i32* %sp_id, align 64, !tbaa !717
  %sp_threads = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx53, i32 0, i32 2
  call void @INIT_LIST_HEAD.554(%struct.list_head* %sp_threads)
  %sp_sockets = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx53, i32 0, i32 3
  call void @INIT_LIST_HEAD.554(%struct.list_head* %sp_sockets)
  %sp_all_threads = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx53, i32 0, i32 5
  call void @INIT_LIST_HEAD.554(%struct.list_head* %sp_all_threads)
  %sp_lock = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx53, i32 0, i32 1
  %call66 = call %struct.raw_spinlock* @spinlock_check.560(%struct.spinlock* %sp_lock)
  %sp_lock68 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx53, i32 0, i32 1
  %25 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %sp_lock68, i32 0, i32 0
  %rlock69 = bitcast %union.anon.11* %25 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock69, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.23.564, i32 0, i32 0), %struct.lock_class_key* @__svc_create.__key.22)
  %inc75 = add i32 %i.0, 1
  br label %for.cond46

for.end76:                                        ; preds = %for.cond46
  %call77 = call i32 @svc_uses_rpcbind(%struct.svc_serv* %0)
  %tobool78 = icmp ne i32 %call77, 0
  br i1 %tobool78, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %for.end76
  %sv_shutdown79 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 15
  %26 = load void (%struct.svc_serv*, %struct.net*)*, void (%struct.svc_serv*, %struct.net*)** %sv_shutdown79, align 8, !tbaa !727
  %tobool80 = icmp ne void (%struct.svc_serv*, %struct.net*)* %26, null
  br i1 %tobool80, label %cleanup, label %if.then81

if.then81:                                        ; preds = %land.lhs.true
  %sv_shutdown82 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 15
  store void (%struct.svc_serv*, %struct.net*)* @svc_rpcb_cleanup, void (%struct.svc_serv*, %struct.net*)** %sv_shutdown82, align 8, !tbaa !727
  br label %cleanup

cleanup:                                          ; preds = %if.then81, %land.lhs.true, %for.end76, %if.then44, %entry
  %retval.0 = phi %struct.svc_serv* [ null, %if.then44 ], [ null, %entry ], [ %0, %if.then81 ], [ %0, %land.lhs.true ], [ %0, %for.end76 ]
  ret %struct.svc_serv* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.558(i64 %size, i32 %flags) #2 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #7
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check.560(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kcalloc.562(i64 %n, i64 %size, i32 %flags) #2 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc_array.572(i64 %n, i64 %size, i32 %or)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_uses_rpcbind(%struct.svc_serv* %serv) #0 {
entry:
  %sv_program = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.inc10, %entry
  %pg_next.sink = phi %struct.svc_program** [ %pg_next, %for.inc10 ], [ %sv_program, %entry ]
  %0 = load %struct.svc_program*, %struct.svc_program** %pg_next.sink, align 8, !tbaa !28
  %tobool = icmp ne %struct.svc_program* %0, null
  br i1 %tobool, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %i.0 = phi i32 [ 0, %for.body ], [ %inc, %for.inc ]
  %pg_nvers = getelementptr inbounds %struct.svc_program, %struct.svc_program* %0, i32 0, i32 4
  %1 = load i32, i32* %pg_nvers, align 4, !tbaa !662
  %cmp = icmp ult i32 %i.0, %1
  br i1 %cmp, label %for.body2, label %for.inc10

for.body2:                                        ; preds = %for.cond1
  %pg_vers = getelementptr inbounds %struct.svc_program, %struct.svc_program* %0, i32 0, i32 5
  %2 = load %struct.svc_version**, %struct.svc_version*** %pg_vers, align 8, !tbaa !663
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.svc_version*, %struct.svc_version** %2, i64 %idxprom
  %3 = load %struct.svc_version*, %struct.svc_version** %arrayidx, align 8, !tbaa !28
  %cmp3 = icmp eq %struct.svc_version* %3, null
  br i1 %cmp3, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body2
  %pg_vers4 = getelementptr inbounds %struct.svc_program, %struct.svc_program* %0, i32 0, i32 5
  %4 = load %struct.svc_version**, %struct.svc_version*** %pg_vers4, align 8, !tbaa !663
  %idxprom5 = zext i32 %i.0 to i64
  %arrayidx6 = getelementptr inbounds %struct.svc_version*, %struct.svc_version** %4, i64 %idxprom5
  %5 = load %struct.svc_version*, %struct.svc_version** %arrayidx6, align 8, !tbaa !28
  %vs_hidden = getelementptr inbounds %struct.svc_version, %struct.svc_version* %5, i32 0, i32 4
  %bf.load = load i8, i8* %vs_hidden, align 4
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %cmp7 = icmp eq i32 %bf.cast, 0
  br i1 %cmp7, label %cleanup, label %for.inc

for.inc:                                          ; preds = %if.end, %for.body2
  %inc = add i32 %i.0, 1
  br label %for.cond1

for.inc10:                                        ; preds = %for.cond1
  %pg_next = getelementptr inbounds %struct.svc_program, %struct.svc_program* %0, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %if.end, %for.cond
  %retval.0 = phi i32 [ 1, %if.end ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @svc_rpcb_cleanup(%struct.svc_serv* %serv, %struct.net* %net) #0 {
entry:
  call void @svc_unregister(%struct.svc_serv* %serv, %struct.net* %net)
  call void @rpcb_put_local(%struct.net* %net)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_unregister(%struct.svc_serv* %serv, %struct.net* %net) #0 {
entry:
  %call = call %struct.thread_info* @current_thread_info.565()
  call void @clear_ti_thread_flag(%struct.thread_info* %call, i32 2)
  %sv_program = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.inc17, %entry
  %pg_next.sink = phi %struct.svc_program** [ %pg_next, %for.inc17 ], [ %sv_program, %entry ]
  %0 = load %struct.svc_program*, %struct.svc_program** %pg_next.sink, align 8, !tbaa !28
  %tobool = icmp ne %struct.svc_program* %0, null
  br i1 %tobool, label %for.body, label %do.body20

for.body:                                         ; preds = %for.cond
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %i.0 = phi i32 [ 0, %for.body ], [ %inc, %for.inc ]
  %pg_nvers = getelementptr inbounds %struct.svc_program, %struct.svc_program* %0, i32 0, i32 4
  %1 = load i32, i32* %pg_nvers, align 4, !tbaa !662
  %cmp = icmp ult i32 %i.0, %1
  br i1 %cmp, label %for.body2, label %for.inc17

for.body2:                                        ; preds = %for.cond1
  %pg_vers = getelementptr inbounds %struct.svc_program, %struct.svc_program* %0, i32 0, i32 5
  %2 = load %struct.svc_version**, %struct.svc_version*** %pg_vers, align 8, !tbaa !663
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.svc_version*, %struct.svc_version** %2, i64 %idxprom
  %3 = load %struct.svc_version*, %struct.svc_version** %arrayidx, align 8, !tbaa !28
  %cmp3 = icmp eq %struct.svc_version* %3, null
  br i1 %cmp3, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body2
  %pg_vers4 = getelementptr inbounds %struct.svc_program, %struct.svc_program* %0, i32 0, i32 5
  %4 = load %struct.svc_version**, %struct.svc_version*** %pg_vers4, align 8, !tbaa !663
  %idxprom5 = zext i32 %i.0 to i64
  %arrayidx6 = getelementptr inbounds %struct.svc_version*, %struct.svc_version** %4, i64 %idxprom5
  %5 = load %struct.svc_version*, %struct.svc_version** %arrayidx6, align 8, !tbaa !28
  %vs_hidden = getelementptr inbounds %struct.svc_version, %struct.svc_version* %5, i32 0, i32 4
  %bf.load = load i8, i8* %vs_hidden, align 4
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool7 = icmp ne i32 %bf.cast, 0
  br i1 %tobool7, label %for.inc, label %do.body

do.body:                                          ; preds = %if.end
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %6, 512
  %tobool10 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.then13, label %do.end

if.then13:                                        ; preds = %do.body
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then13, %do.body
  %pg_prog = getelementptr inbounds %struct.svc_program, %struct.svc_program* %0, i32 0, i32 1
  %8 = load i32, i32* %pg_prog, align 8, !tbaa !659
  call void @__svc_unregister(%struct.net* %net, i32 %8, i32 %i.0)
  br label %for.inc

for.inc:                                          ; preds = %do.end, %if.end, %for.body2
  %inc = add i32 %i.0, 1
  br label %for.cond1

for.inc17:                                        ; preds = %for.cond1
  %pg_next = getelementptr inbounds %struct.svc_program, %struct.svc_program* %0, i32 0, i32 0
  br label %for.cond

do.body20:                                        ; preds = %for.cond
  %9 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !732
  %sighand = getelementptr inbounds %struct.task_struct, %struct.task_struct* %9, i32 0, i32 76
  %10 = load %struct.sighand_struct*, %struct.sighand_struct** %sighand, align 8, !tbaa !733
  %siglock = getelementptr inbounds %struct.sighand_struct, %struct.sighand_struct* %10, i32 0, i32 2
  %call24 = call %struct.raw_spinlock* @spinlock_check.560(%struct.spinlock* %siglock)
  %call25 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call24)
  call void @recalc_sigpending()
  %11 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !732
  %sighand31 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %11, i32 0, i32 76
  %12 = load %struct.sighand_struct*, %struct.sighand_struct** %sighand31, align 8, !tbaa !733
  %siglock32 = getelementptr inbounds %struct.sighand_struct, %struct.sighand_struct* %12, i32 0, i32 2
  call void @spin_unlock_irqrestore.568(%struct.spinlock* %siglock32, i64 %call25)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.565() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !734
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @clear_ti_thread_flag(%struct.thread_info* %ti, i32 %flag) #2 {
entry:
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i32 0, i32 2
  %0 = bitcast i32* %flags to i64*
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %0, i32 %flag, i64* %0) #7, !srcloc !735
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__svc_unregister(%struct.net* %net, i32 %program, i32 %version) #0 {
entry:
  %call = call i32 @rpcb_v4_register(%struct.net* %net, i32 %program, i32 %version, %struct.sockaddr* null, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.31.1130, i32 0, i32 0))
  %cmp = icmp eq i32 %call, -93
  br i1 %cmp, label %if.then, label %do.body

if.then:                                          ; preds = %entry
  %call1 = call i32 @rpcb_register(%struct.net* %net, i32 %program, i32 %version, i32 0, i16 zeroext 0)
  br label %do.body

do.body:                                          ; preds = %if.then, %entry
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 512
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.end

if.then4:                                         ; preds = %do.body
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then4, %do.body
  ret void
}

declare void @recalc_sigpending() #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore.568(%struct.spinlock* %lock, i64 %flags) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kmalloc_array.572(i64 %n, i64 %size, i32 %flags) #2 {
entry:
  %cmp = icmp ne i64 %size, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %div = udiv i64 -1, %size
  %cmp1 = icmp ugt i64 %n, %div
  br i1 %cmp1, label %return, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %mul = mul i64 %n, %size
  %call = call i8* @__kmalloc(i64 %mul, i32 %flags)
  br label %return

return:                                           ; preds = %if.end, %land.lhs.true
  %retval.0 = phi i8* [ %call, %if.end ], [ null, %land.lhs.true ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_pool_map_choose_mode() #0 {
entry:
  %0 = load i32, i32* @nr_online_nodes, align 4, !tbaa !49
  %cmp = icmp sgt i32 %0, 1
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @__first_node(%struct.tcp_mib* getelementptr inbounds ([5 x %struct.tcp_mib], [5 x %struct.tcp_mib]* @node_states, i64 0, i64 1))
  %call1 = call %struct.cpumask* @cpumask_of_node(i32 %call)
  %call2 = call i32 @cpumask_weight(%struct.cpumask* %call1)
  %cmp3 = icmp ugt i32 %call2, 2
  %. = select i1 %cmp3, i32 1, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 2, %entry ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_pool_map_init_percpu(%struct.svc_pool_map* %m) #0 {
entry:
  %0 = load i32, i32* @nr_cpu_ids, align 4, !tbaa !49
  %call = call i32 @svc_pool_map_alloc_arrays(%struct.svc_pool_map* %m, i32 %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %do.end12, %if.end
  %pidx.0 = phi i32 [ 0, %if.end ], [ %inc, %do.end12 ]
  %cpu.0 = phi i32 [ -1, %if.end ], [ %call1, %do.end12 ]
  %1 = load %struct.cpumask*, %struct.cpumask** @cpu_online_mask, align 8, !tbaa !28
  %call1 = call i32 @cpumask_next(i32 %cpu.0, %struct.cpumask* %1)
  %2 = load i32, i32* @nr_cpu_ids, align 4, !tbaa !49
  %cmp = icmp ult i32 %call1, %2
  br i1 %cmp, label %do.body, label %cleanup

do.body:                                          ; preds = %for.cond
  %cmp2 = icmp ugt i32 %pidx.0, %0
  %lnot = xor i1 %cmp2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body6, label %do.end12

do.body6:                                         ; preds = %do.body
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2.528, i32 0, i32 0), i32 192, i64 12) #7, !srcloc !736
  br label %do.body7

do.body7:                                         ; preds = %do.body7, %do.body6
  br label %do.body7

do.end12:                                         ; preds = %do.body
  %to_pool = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* %m, i32 0, i32 4
  %3 = load i32*, i32** %to_pool, align 8, !tbaa !714
  %idxprom = zext i32 %call1 to i64
  %arrayidx = getelementptr inbounds i32, i32* %3, i64 %idxprom
  store i32 %pidx.0, i32* %arrayidx, align 4, !tbaa !49
  %pool_to = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* %m, i32 0, i32 3
  %4 = load i32*, i32** %pool_to, align 8, !tbaa !715
  %idxprom13 = zext i32 %pidx.0 to i64
  %arrayidx14 = getelementptr inbounds i32, i32* %4, i64 %idxprom13
  store i32 %call1, i32* %arrayidx14, align 4, !tbaa !49
  %inc = add i32 %pidx.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ %pidx.0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_pool_map_init_pernode(%struct.svc_pool_map* %m) #0 {
entry:
  %0 = load i32, i32* @nr_node_ids, align 4, !tbaa !49
  %call = call i32 @svc_pool_map_alloc_arrays(%struct.svc_pool_map* %m, i32 %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @__first_node(%struct.tcp_mib* getelementptr inbounds ([5 x %struct.tcp_mib], [5 x %struct.tcp_mib]* @node_states, i64 0, i64 1))
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %pidx.0 = phi i32 [ 0, %if.end ], [ %pidx.1, %for.inc ]
  %node.0 = phi i32 [ %call1, %if.end ], [ %call20, %for.inc ]
  %cmp = icmp ult i32 %node.0, 1024
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %call2 = call %struct.cpumask* @cpumask_of_node(i32 %node.0)
  %call3 = call i32 @cpumask_weight(%struct.cpumask* %call2)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.body, label %for.inc

do.body:                                          ; preds = %for.body
  %cmp6 = icmp ugt i32 %pidx.0, %0
  %lnot = xor i1 %cmp6, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %do.body10, label %do.end16

do.body10:                                        ; preds = %do.body
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2.528, i32 0, i32 0), i32 221, i64 12) #7, !srcloc !737
  br label %do.body11

do.body11:                                        ; preds = %do.body11, %do.body10
  br label %do.body11

do.end16:                                         ; preds = %do.body
  %to_pool = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* %m, i32 0, i32 4
  %1 = load i32*, i32** %to_pool, align 8, !tbaa !714
  %idxprom = zext i32 %node.0 to i64
  %arrayidx = getelementptr inbounds i32, i32* %1, i64 %idxprom
  store i32 %pidx.0, i32* %arrayidx, align 4, !tbaa !49
  %pool_to = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* %m, i32 0, i32 3
  %2 = load i32*, i32** %pool_to, align 8, !tbaa !715
  %idxprom17 = zext i32 %pidx.0 to i64
  %arrayidx18 = getelementptr inbounds i32, i32* %2, i64 %idxprom17
  store i32 %node.0, i32* %arrayidx18, align 4, !tbaa !49
  %inc = add i32 %pidx.0, 1
  br label %for.inc

for.inc:                                          ; preds = %do.end16, %for.body
  %pidx.1 = phi i32 [ %inc, %do.end16 ], [ %pidx.0, %for.body ]
  %call20 = call i32 @__next_node(i32 %node.0, %struct.tcp_mib* getelementptr inbounds ([5 x %struct.tcp_mib], [5 x %struct.tcp_mib]* @node_states, i64 0, i64 1))
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ %pidx.0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_pool_map_alloc_arrays(%struct.svc_pool_map* %m, i32 %maxpools) #0 {
entry:
  %conv = zext i32 %maxpools to i64
  %call = call i8* @kcalloc.562(i64 %conv, i64 4, i32 208)
  %0 = bitcast i8* %call to i32*
  %to_pool = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* %m, i32 0, i32 4
  store i32* %0, i32** %to_pool, align 8, !tbaa !714
  %to_pool1 = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* %m, i32 0, i32 4
  %1 = load i32*, i32** %to_pool1, align 8, !tbaa !714
  %tobool = icmp ne i32* %1, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %conv2 = zext i32 %maxpools to i64
  %call3 = call i8* @kcalloc.562(i64 %conv2, i64 4, i32 208)
  %2 = bitcast i8* %call3 to i32*
  %pool_to = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* %m, i32 0, i32 3
  store i32* %2, i32** %pool_to, align 8, !tbaa !715
  %pool_to4 = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* %m, i32 0, i32 3
  %3 = load i32*, i32** %pool_to4, align 8, !tbaa !715
  %tobool5 = icmp ne i32* %3, null
  br i1 %tobool5, label %return, label %fail_free

fail_free:                                        ; preds = %if.end
  %to_pool8 = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* %m, i32 0, i32 4
  %4 = load i32*, i32** %to_pool8, align 8, !tbaa !714
  %5 = bitcast i32* %4 to i8*
  call void @kfree(i8* %5)
  %to_pool9 = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* %m, i32 0, i32 4
  store i32* null, i32** %to_pool9, align 8, !tbaa !714
  br label %return

return:                                           ; preds = %fail_free, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -12, %entry ], [ -12, %fail_free ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__first_node(%struct.tcp_mib* %srcp) #2 {
entry:
  %bits = getelementptr inbounds %struct.tcp_mib, %struct.tcp_mib* %srcp, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i64], [16 x i64]* %bits, i32 0, i32 0
  %call = call i64 @find_first_bit(i64* %arraydecay, i64 1024)
  %conv = trunc i64 %call to i32
  %cmp = icmp slt i32 1024, %conv
  %.conv = select i1 %cmp, i32 1024, i32 %conv
  ret i32 %.conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @cpumask_weight(%struct.cpumask* %srcp) #2 {
entry:
  %bits = getelementptr inbounds %struct.cpumask, %struct.cpumask* %srcp, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i64], [64 x i64]* %bits, i32 0, i32 0
  %0 = load i32, i32* @nr_cpu_ids, align 4, !tbaa !49
  %call = call i32 @bitmap_weight(i64* %arraydecay, i32 %0)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__next_node(i32 %n, %struct.tcp_mib* %srcp) #2 {
entry:
  %bits = getelementptr inbounds %struct.tcp_mib, %struct.tcp_mib* %srcp, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i64], [16 x i64]* %bits, i32 0, i32 0
  %add = add nsw i32 %n, 1
  %conv = sext i32 %add to i64
  %call = call i64 @find_next_bit(i64* %arraydecay, i64 1024, i64 %conv)
  %conv1 = trunc i64 %call to i32
  %cmp = icmp slt i32 1024, %conv1
  %.conv1 = select i1 %cmp, i32 1024, i32 %conv1
  ret i32 %.conv1
}

declare i64 @find_next_bit(i64*, i64, i64) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @bitmap_weight(i64* %src, i32 %nbits) #2 {
entry:
  %call = call i32 @__bitmap_weight(i64* %src, i32 %nbits)
  ret i32 %call
}

declare i32 @__bitmap_weight(i64*, i32) #4

declare i64 @find_first_bit(i64*, i64) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @cpumask_next(i32 %n, %struct.cpumask* %srcp) #2 {
entry:
  %cmp = icmp ne i32 %n, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @cpumask_check(i32 %n)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %bits = getelementptr inbounds %struct.cpumask, %struct.cpumask* %srcp, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i64], [64 x i64]* %bits, i32 0, i32 0
  %0 = load i32, i32* @nr_cpu_ids, align 4, !tbaa !49
  %conv = sext i32 %0 to i64
  %add = add nsw i32 %n, 1
  %conv1 = sext i32 %add to i64
  %call2 = call i64 @find_next_bit(i64* %arraydecay, i64 %conv, i64 %conv1)
  %conv3 = trunc i64 %call2 to i32
  ret i32 %conv3
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @cpumask_check(i32 %cpu) #2 {
entry:
  %0 = load i32, i32* @nr_cpu_ids, align 4, !tbaa !49
  %cmp = icmp uge i32 %cpu, %0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  %1 = load i8, i8* @cpumask_check.__warned, align 1, !tbaa !29, !range !31
  %tobool7 = trunc i8 %1 to i1
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %tobool14 = icmp ne i32 %lnot.ext13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.24.574, i32 0, i32 0), i32 108)
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then
  %tobool23 = icmp ne i32 %lnot.ext13, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end
  store i8 1, i8* @cpumask_check.__warned, align 1, !tbaa !29
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.svc_serv* @svc_create(%struct.svc_program* %prog, i32 %bufsize, void (%struct.svc_serv*, %struct.net*)* %shutdown) #0 {
entry:
  %call = call %struct.svc_serv* @__svc_create(%struct.svc_program* %prog, i32 %bufsize, i32 1, void (%struct.svc_serv*, %struct.net*)* %shutdown)
  ret %struct.svc_serv* %call
}

; Function Attrs: nounwind uwtable
define i32 @svc_bind(%struct.svc_serv* %serv, %struct.net* %net) #0 {
entry:
  %call = call i32 @svc_uses_rpcbind(%struct.svc_serv* %serv)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call1 = call i32 @svc_rpcb_setup(%struct.svc_serv* %serv, %struct.net* %net)
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call1, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @svc_rpcb_setup(%struct.svc_serv* %serv, %struct.net* %net) #0 {
entry:
  %call = call i32 @rpcb_create_local(%struct.net* %net)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @svc_unregister(%struct.svc_serv* %serv, %struct.net* %net)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @param_set_pool_mode(i8* %val, %struct.kernel_param* %kp) #0 {
entry:
  %0 = getelementptr inbounds %struct.kernel_param, %struct.kernel_param* %kp, i32 0, i32 4
  %arg = bitcast %union.anon.57* %0 to i8**
  %1 = load i8*, i8** %arg, align 8, !tbaa !166
  %2 = bitcast i8* %1 to i32*
  call void @mutex_lock_nested(%struct.mutex* @svc_pool_map_mutex, i32 0)
  %count = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 0
  %3 = load i32, i32* %count, align 8, !tbaa !712
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %out, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @strncmp(i8* %val, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.11.575, i32 0, i32 0), i64 4)
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.end
  store i32 -1, i32* %2, align 4, !tbaa !49
  br label %out

if.else:                                          ; preds = %if.end
  %call3 = call i32 @strncmp(i8* %val, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12.576, i32 0, i32 0), i64 6)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.else6, label %if.then5

if.then5:                                         ; preds = %if.else
  store i32 0, i32* %2, align 4, !tbaa !49
  br label %out

if.else6:                                         ; preds = %if.else
  %call7 = call i32 @strncmp(i8* %val, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.13.577, i32 0, i32 0), i64 6)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.else10, label %if.then9

if.then9:                                         ; preds = %if.else6
  store i32 1, i32* %2, align 4, !tbaa !49
  br label %out

if.else10:                                        ; preds = %if.else6
  %call11 = call i32 @strncmp(i8* %val, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.14.578, i32 0, i32 0), i64 7)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %out, label %if.then13

if.then13:                                        ; preds = %if.else10
  store i32 2, i32* %2, align 4, !tbaa !49
  br label %out

out:                                              ; preds = %if.then13, %if.else10, %if.then9, %if.then5, %if.then2, %entry
  %err.4 = phi i32 [ -16, %entry ], [ 0, %if.then2 ], [ 0, %if.then5 ], [ 0, %if.then9 ], [ 0, %if.then13 ], [ -22, %if.else10 ]
  call void @mutex_unlock(%struct.mutex* @svc_pool_map_mutex)
  ret i32 %err.4
}

; Function Attrs: nounwind uwtable
define internal i32 @param_get_pool_mode(i8* %buf, %struct.kernel_param* %kp) #0 {
entry:
  %0 = getelementptr inbounds %struct.kernel_param, %struct.kernel_param* %kp, i32 0, i32 4
  %arg = bitcast %union.anon.57* %0 to i8**
  %1 = load i8*, i8** %arg, align 8, !tbaa !166
  %2 = bitcast i8* %1 to i32*
  %3 = load i32, i32* %2, align 4, !tbaa !49
  %Pivot6 = icmp slt i32 %3, 1
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %3, 2
  br i1 %Pivot4, label %sw.bb4, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %3, 2
  br i1 %SwitchLeaf2, label %sw.bb7, label %sw.default

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %3, 0
  br i1 %Pivot, label %LeafBlock, label %sw.bb1

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %3, -1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %call = call i64 @strlcpy(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.11.575, i32 0, i32 0), i64 20)
  %conv = trunc i64 %call to i32
  br label %cleanup

sw.bb1:                                           ; preds = %NodeBlock
  %call2 = call i64 @strlcpy(i8* %buf, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12.576, i32 0, i32 0), i64 20)
  %conv3 = trunc i64 %call2 to i32
  br label %cleanup

sw.bb4:                                           ; preds = %NodeBlock3
  %call5 = call i64 @strlcpy(i8* %buf, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.13.577, i32 0, i32 0), i64 20)
  %conv6 = trunc i64 %call5 to i32
  br label %cleanup

sw.bb7:                                           ; preds = %LeafBlock1
  %call8 = call i64 @strlcpy(i8* %buf, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.14.578, i32 0, i32 0), i64 20)
  %conv9 = trunc i64 %call8 to i32
  br label %cleanup

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %4 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %sw.default, %sw.bb7, %sw.bb4, %sw.bb1, %sw.bb
  %retval.0 = phi i32 [ %conv, %sw.bb ], [ %4, %sw.default ], [ %conv3, %sw.bb1 ], [ %conv6, %sw.bb4 ], [ %conv9, %sw.bb7 ]
  ret i32 %retval.0
}

declare i32 @strncmp(i8*, i8*, i64) #4

; Function Attrs: nounwind uwtable
define %struct.svc_pool* @svc_pool_for_cpu(%struct.svc_serv* %serv, i32 %cpu) #0 {
entry:
  %sv_function = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 17
  %0 = load i32 (i8*)*, i32 (i8*)** %sv_function, align 8, !tbaa !710
  %tobool = icmp ne i32 (i8*)* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mode = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 1
  %1 = load i32, i32* %mode, align 4, !tbaa !722
  %Pivot = icmp slt i32 %1, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.then
  %SwitchLeaf2 = icmp eq i32 %1, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %if.end

LeafBlock:                                        ; preds = %if.then
  %SwitchLeaf = icmp eq i32 %1, 1
  br i1 %SwitchLeaf, label %sw.bb, label %if.end

sw.bb:                                            ; preds = %LeafBlock
  %to_pool = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 4
  %2 = load i32*, i32** %to_pool, align 8, !tbaa !714
  %idxprom = sext i32 %cpu to i64
  %arrayidx = getelementptr inbounds i32, i32* %2, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !49
  br label %if.end

sw.bb1:                                           ; preds = %LeafBlock1
  %to_pool2 = getelementptr inbounds %struct.svc_pool_map, %struct.svc_pool_map* @svc_pool_map, i32 0, i32 4
  %4 = load i32*, i32** %to_pool2, align 8, !tbaa !714
  %call = call i32 @__cpu_to_node(i32 %cpu)
  %idxprom3 = sext i32 %call to i64
  %arrayidx4 = getelementptr inbounds i32, i32* %4, i64 %idxprom3
  %5 = load i32, i32* %arrayidx4, align 4, !tbaa !49
  br label %if.end

if.end:                                           ; preds = %sw.bb1, %sw.bb, %LeafBlock, %LeafBlock1, %entry
  %pidx.1 = phi i32 [ 0, %entry ], [ %3, %sw.bb ], [ %5, %sw.bb1 ], [ 0, %LeafBlock1 ], [ 0, %LeafBlock ]
  %sv_pools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 14
  %6 = load %struct.svc_pool*, %struct.svc_pool** %sv_pools, align 8, !tbaa !711
  %sv_nrpools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 13
  %7 = load i32, i32* %sv_nrpools, align 8, !tbaa !721
  %rem = urem i32 %pidx.1, %7
  %idxprom5 = zext i32 %rem to i64
  %arrayidx6 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %6, i64 %idxprom5
  ret %struct.svc_pool* %arrayidx6
}

; Function Attrs: nounwind uwtable
define i32 @svc_register(%struct.svc_serv* %serv, %struct.net* %net, i32 %family, i16 zeroext %proto, i16 zeroext %port) #0 {
entry:
  %conv = zext i16 %proto to i32
  %cmp = icmp eq i32 %conv, 0
  %conv2 = zext i16 %port to i32
  %cmp3 = icmp eq i32 %conv2, 0
  %0 = select i1 %cmp, i1 %cmp3, i1 false
  %lnot = xor i1 %0, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot6 = xor i1 %tobool, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv10 = sext i32 %lnot.ext9 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv10, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = load i8, i8* @svc_register.__warned, align 1, !tbaa !29, !range !31
  %tobool12 = trunc i8 %1 to i1
  %lnot13 = xor i1 %tobool12, true
  %lnot15 = xor i1 %lnot13, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %tobool19 = icmp ne i32 %lnot.ext18, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %expval25 = call i64 @llvm.expect.i64(i64 %conv24, i64 0)
  %tobool26 = icmp ne i64 %expval25, 0
  br i1 %tobool26, label %if.then27, label %if.end

if.then27:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2.528, i32 0, i32 0), i32 943)
  br label %if.end

if.end:                                           ; preds = %if.then27, %if.then
  %tobool28 = icmp ne i32 %lnot.ext18, 0
  %lnot29 = xor i1 %tobool28, true
  %lnot31 = xor i1 %lnot29, true
  %lnot.ext32 = zext i1 %lnot31 to i32
  %conv33 = sext i32 %lnot.ext32 to i64
  %expval34 = call i64 @llvm.expect.i64(i64 %conv33, i64 0)
  %tobool35 = icmp ne i64 %expval34, 0
  br i1 %tobool35, label %if.then36, label %if.end38

if.then36:                                        ; preds = %if.end
  store i8 1, i8* @svc_register.__warned, align 1, !tbaa !29
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %if.end, %entry
  %conv47 = zext i16 %proto to i32
  %cmp48 = icmp eq i32 %conv47, 0
  %conv50 = zext i16 %port to i32
  %cmp51 = icmp eq i32 %conv50, 0
  %or.cond = and i1 %cmp48, %cmp51
  br i1 %or.cond, label %cleanup, label %if.end54

if.end54:                                         ; preds = %if.end38
  %sv_program = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.inc99, %if.end54
  %pg_next.sink = phi %struct.svc_program** [ %pg_next, %for.inc99 ], [ %sv_program, %if.end54 ]
  %error.0 = phi i32 [ 0, %if.end54 ], [ %error.3, %for.inc99 ]
  %2 = load %struct.svc_program*, %struct.svc_program** %pg_next.sink, align 8, !tbaa !28
  %tobool55 = icmp ne %struct.svc_program* %2, null
  br i1 %tobool55, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  br label %for.cond56

for.cond56:                                       ; preds = %for.inc, %for.body
  %i.0 = phi i32 [ 0, %for.body ], [ %inc, %for.inc ]
  %error.1 = phi i32 [ %error.0, %for.body ], [ %error.2, %for.inc ]
  %pg_nvers = getelementptr inbounds %struct.svc_program, %struct.svc_program* %2, i32 0, i32 4
  %3 = load i32, i32* %pg_nvers, align 4, !tbaa !662
  %cmp57 = icmp ult i32 %i.0, %3
  br i1 %cmp57, label %for.body59, label %for.inc99

for.body59:                                       ; preds = %for.cond56
  %pg_vers = getelementptr inbounds %struct.svc_program, %struct.svc_program* %2, i32 0, i32 5
  %4 = load %struct.svc_version**, %struct.svc_version*** %pg_vers, align 8, !tbaa !663
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.svc_version*, %struct.svc_version** %4, i64 %idxprom
  %5 = load %struct.svc_version*, %struct.svc_version** %arrayidx, align 8, !tbaa !28
  %cmp60 = icmp eq %struct.svc_version* %5, null
  br i1 %cmp60, label %for.inc, label %do.body

do.body:                                          ; preds = %for.body59
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %6, 512
  %tobool64 = icmp ne i32 %and, 0
  %lnot65 = xor i1 %tobool64, true
  %lnot67 = xor i1 %lnot65, true
  %lnot.ext68 = zext i1 %lnot67 to i32
  %conv69 = sext i32 %lnot.ext68 to i64
  %expval70 = call i64 @llvm.expect.i64(i64 %conv69, i64 0)
  %tobool71 = icmp ne i64 %expval70, 0
  br i1 %tobool71, label %if.then72, label %do.end

if.then72:                                        ; preds = %do.body
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then72, %do.body
  %pg_vers83 = getelementptr inbounds %struct.svc_program, %struct.svc_program* %2, i32 0, i32 5
  %8 = load %struct.svc_version**, %struct.svc_version*** %pg_vers83, align 8, !tbaa !663
  %idxprom84 = zext i32 %i.0 to i64
  %arrayidx85 = getelementptr inbounds %struct.svc_version*, %struct.svc_version** %8, i64 %idxprom84
  %9 = load %struct.svc_version*, %struct.svc_version** %arrayidx85, align 8, !tbaa !28
  %vs_hidden86 = getelementptr inbounds %struct.svc_version, %struct.svc_version* %9, i32 0, i32 4
  %bf.load87 = load i8, i8* %vs_hidden86, align 4
  %bf.clear88 = and i8 %bf.load87, 1
  %bf.cast89 = zext i8 %bf.clear88 to i32
  %tobool90 = icmp ne i32 %bf.cast89, 0
  br i1 %tobool90, label %for.inc, label %if.end92

if.end92:                                         ; preds = %do.end
  %pg_prog = getelementptr inbounds %struct.svc_program, %struct.svc_program* %2, i32 0, i32 1
  %10 = load i32, i32* %pg_prog, align 8, !tbaa !659
  %call94 = call i32 @__svc_register(%struct.net* %net, i32 %10, i32 %i.0, i32 %family, i16 zeroext %proto, i16 zeroext %port)
  %cmp95 = icmp slt i32 %call94, 0
  br i1 %cmp95, label %for.inc99, label %for.inc

for.inc:                                          ; preds = %if.end92, %do.end, %for.body59
  %error.2 = phi i32 [ %error.1, %for.body59 ], [ %error.1, %do.end ], [ %call94, %if.end92 ]
  %inc = add i32 %i.0, 1
  br label %for.cond56

for.inc99:                                        ; preds = %if.end92, %for.cond56
  %error.3 = phi i32 [ %call94, %if.end92 ], [ %error.1, %for.cond56 ]
  %pg_next = getelementptr inbounds %struct.svc_program, %struct.svc_program* %2, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %if.end38
  %retval.0 = phi i32 [ -22, %if.end38 ], [ %error.0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @__svc_register(%struct.net* %net, i32 %program, i32 %version, i32 %family, i16 zeroext %protocol, i16 zeroext %port) #0 {
entry:
  %Pivot = icmp slt i32 %family, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %family, 10
  br i1 %SwitchLeaf2, label %sw.bb1, label %sw.epilog

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %family, 2
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %call = call i32 @__svc_rpcb_register4(%struct.net* %net, i32 %program, i32 %version, i16 zeroext %protocol, i16 zeroext %port)
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %call2 = call i32 @__svc_rpcb_register6(%struct.net* %net, i32 %program, i32 %version, i16 zeroext %protocol, i16 zeroext %port)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb1, %sw.bb, %LeafBlock, %LeafBlock1
  %error.0 = phi i32 [ %call, %sw.bb ], [ %call2, %sw.bb1 ], [ -97, %LeafBlock1 ], [ -97, %LeafBlock ]
  %cmp = icmp slt i32 %error.0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.epilog
  %0 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.epilog
  ret i32 %error.0
}

; Function Attrs: nounwind uwtable
define internal i32 @__svc_rpcb_register4(%struct.net* %net, i32 %program, i32 %version, i16 zeroext %protocol, i16 zeroext %port) #0 {
entry:
  %sin = alloca %struct.sockaddr_in, align 4
  %sin_family = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %sin, i32 0, i32 0
  store i16 2, i16* %sin_family, align 4, !tbaa !738
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %sin, i32 0, i32 1
  %call = call zeroext i16 @__fswab16.585(i16 zeroext %port) #3
  %conv = zext i16 %call to i32
  %conv1 = trunc i32 %conv to i16
  store i16 %conv1, i16* %sin_port, align 2, !tbaa !191
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %sin, i32 0, i32 2
  %s_addr = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %sin_addr, i32 0, i32 0
  store i32 0, i32* %s_addr, align 4, !tbaa !739
  %__pad = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %sin, i32 0, i32 3
  %0 = bitcast [8 x i8]* %__pad to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 8, i32 4, i1 false)
  %conv2 = zext i16 %protocol to i32
  %Pivot = icmp slt i32 %conv2, 17
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv2, 17
  br i1 %SwitchLeaf2, label %sw.epilog, label %cleanup

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv2, 6
  br i1 %SwitchLeaf, label %sw.epilog, label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1
  %netid.0 = phi i8* [ getelementptr inbounds ([4 x i8], [4 x i8]* @.str.47.591, i32 0, i32 0), %LeafBlock1 ], [ getelementptr inbounds ([4 x i8], [4 x i8]* @.str.592, i32 0, i32 0), %LeafBlock ]
  %1 = bitcast %struct.sockaddr_in* %sin to %struct.sockaddr*
  %call4 = call i32 @rpcb_v4_register(%struct.net* %net, i32 %program, i32 %version, %struct.sockaddr* %1, i8* %netid.0)
  %cmp = icmp eq i32 %call4, -93
  br i1 %cmp, label %if.then, label %cleanup

if.then:                                          ; preds = %sw.epilog
  %conv6 = zext i16 %protocol to i32
  %call7 = call i32 @rpcb_register(%struct.net* %net, i32 %program, i32 %version, i32 %conv6, i16 zeroext %port)
  br label %cleanup

cleanup:                                          ; preds = %if.then, %sw.epilog, %LeafBlock, %LeafBlock1
  %retval.0 = phi i32 [ -92, %LeafBlock ], [ -92, %LeafBlock1 ], [ %call7, %if.then ], [ %call4, %sw.epilog ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @__svc_rpcb_register6(%struct.net* %net, i32 %program, i32 %version, i16 zeroext %protocol, i16 zeroext %port) #0 {
entry:
  %sin6 = alloca %struct.sockaddr_in6, align 4
  %sin6_family = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6, i32 0, i32 0
  store i16 10, i16* %sin6_family, align 4, !tbaa !740
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6, i32 0, i32 1
  %call = call zeroext i16 @__fswab16.585(i16 zeroext %port) #3
  %conv = zext i16 %call to i32
  %conv1 = trunc i32 %conv to i16
  store i16 %conv1, i16* %sin6_port, align 2, !tbaa !194
  %sin6_flowinfo = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6, i32 0, i32 2
  store i32 0, i32* %sin6_flowinfo, align 4, !tbaa !741
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6, i32 0, i32 3
  %in6_u = getelementptr inbounds %struct.in6_addr, %struct.in6_addr* %sin6_addr, i32 0, i32 0
  %u6_addr8 = bitcast %union.anon.68* %in6_u to [16 x i8]*
  %arrayinit.begin = getelementptr inbounds [16 x i8], [16 x i8]* %u6_addr8, i64 0, i64 0
  store i8 0, i8* %arrayinit.begin, align 1, !tbaa !166
  %arrayinit.element = getelementptr inbounds i8, i8* %arrayinit.begin, i64 1
  store i8 0, i8* %arrayinit.element, align 1, !tbaa !166
  %arrayinit.element2 = getelementptr inbounds i8, i8* %arrayinit.element, i64 1
  store i8 0, i8* %arrayinit.element2, align 1, !tbaa !166
  %arrayinit.element3 = getelementptr inbounds i8, i8* %arrayinit.element2, i64 1
  store i8 0, i8* %arrayinit.element3, align 1, !tbaa !166
  %arrayinit.element4 = getelementptr inbounds i8, i8* %arrayinit.element3, i64 1
  store i8 0, i8* %arrayinit.element4, align 1, !tbaa !166
  %arrayinit.element5 = getelementptr inbounds i8, i8* %arrayinit.element4, i64 1
  store i8 0, i8* %arrayinit.element5, align 1, !tbaa !166
  %arrayinit.element6 = getelementptr inbounds i8, i8* %arrayinit.element5, i64 1
  store i8 0, i8* %arrayinit.element6, align 1, !tbaa !166
  %arrayinit.element7 = getelementptr inbounds i8, i8* %arrayinit.element6, i64 1
  store i8 0, i8* %arrayinit.element7, align 1, !tbaa !166
  %arrayinit.element8 = getelementptr inbounds i8, i8* %arrayinit.element7, i64 1
  store i8 0, i8* %arrayinit.element8, align 1, !tbaa !166
  %arrayinit.element9 = getelementptr inbounds i8, i8* %arrayinit.element8, i64 1
  store i8 0, i8* %arrayinit.element9, align 1, !tbaa !166
  %arrayinit.element10 = getelementptr inbounds i8, i8* %arrayinit.element9, i64 1
  store i8 0, i8* %arrayinit.element10, align 1, !tbaa !166
  %arrayinit.element11 = getelementptr inbounds i8, i8* %arrayinit.element10, i64 1
  store i8 0, i8* %arrayinit.element11, align 1, !tbaa !166
  %arrayinit.element12 = getelementptr inbounds i8, i8* %arrayinit.element11, i64 1
  store i8 0, i8* %arrayinit.element12, align 1, !tbaa !166
  %arrayinit.element13 = getelementptr inbounds i8, i8* %arrayinit.element12, i64 1
  store i8 0, i8* %arrayinit.element13, align 1, !tbaa !166
  %arrayinit.element14 = getelementptr inbounds i8, i8* %arrayinit.element13, i64 1
  store i8 0, i8* %arrayinit.element14, align 1, !tbaa !166
  %arrayinit.element15 = getelementptr inbounds i8, i8* %arrayinit.element14, i64 1
  store i8 0, i8* %arrayinit.element15, align 1, !tbaa !166
  %sin6_scope_id = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6, i32 0, i32 4
  store i32 0, i32* %sin6_scope_id, align 4, !tbaa !197
  %conv16 = zext i16 %protocol to i32
  %Pivot = icmp slt i32 %conv16, 17
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv16, 17
  br i1 %SwitchLeaf2, label %sw.epilog, label %cleanup

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv16, 6
  br i1 %SwitchLeaf, label %sw.epilog, label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1
  %netid.0 = phi i8* [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.26.586, i32 0, i32 0), %LeafBlock1 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27.587, i32 0, i32 0), %LeafBlock ]
  %0 = bitcast %struct.sockaddr_in6* %sin6 to %struct.sockaddr*
  %call18 = call i32 @rpcb_v4_register(%struct.net* %net, i32 %program, i32 %version, %struct.sockaddr* %0, i8* %netid.0)
  %cmp = icmp eq i32 %call18, -93
  %.call18 = select i1 %cmp, i32 -97, i32 %call18
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %LeafBlock, %LeafBlock1
  %retval.0 = phi i32 [ %.call18, %sw.epilog ], [ -92, %LeafBlock ], [ -92, %LeafBlock1 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal zeroext i16 @__fswab16.585(i16 zeroext %val) #5 {
entry:
  %conv = zext i16 %val to i32
  %and = and i32 %conv, 255
  %shl = shl i32 %and, 8
  %conv1 = zext i16 %val to i32
  %and2 = and i32 %conv1, 65280
  %shr = ashr i32 %and2, 8
  %or = or i32 %shl, %shr
  %conv3 = trunc i32 %or to i16
  ret i16 %conv3
}

; Function Attrs: nounwind uwtable
define i32 @svc_addsock(%struct.svc_serv* %serv, i32 %fd, i8* %name_return, i64 %len) #0 {
entry:
  %err = alloca i32, align 4
  %addr = alloca %struct.__kernel_sockaddr_storage, align 8
  %salen = alloca i32, align 4
  store i32 0, i32* %err, align 4, !tbaa !49
  %call = call %struct.socket* @sockfd_lookup(i32 %fd, i32* %err)
  %0 = bitcast %struct.__kernel_sockaddr_storage* %addr to %struct.sockaddr*
  %tobool = icmp ne %struct.socket* %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i32, i32* %err, align 4, !tbaa !49
  br label %cleanup

if.end:                                           ; preds = %entry
  store i32 -97, i32* %err, align 4, !tbaa !49
  %sk = getelementptr inbounds %struct.socket, %struct.socket* %call, i32 0, i32 5
  %2 = load %struct.sock*, %struct.sock** %sk, align 8, !tbaa !387
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 0
  %skc_family = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 3
  %3 = load i16, i16* %skc_family, align 8, !tbaa !462
  %conv = zext i16 %3 to i32
  %cmp = icmp ne i32 %conv, 2
  br i1 %cmp, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %if.end
  %sk2 = getelementptr inbounds %struct.socket, %struct.socket* %call, i32 0, i32 5
  %4 = load %struct.sock*, %struct.sock** %sk2, align 8, !tbaa !387
  %__sk_common3 = getelementptr inbounds %struct.sock, %struct.sock* %4, i32 0, i32 0
  %skc_family4 = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common3, i32 0, i32 3
  %5 = load i16, i16* %skc_family4, align 8, !tbaa !462
  %conv5 = zext i16 %5 to i32
  %cmp6 = icmp ne i32 %conv5, 10
  br i1 %cmp6, label %out, label %if.end9

if.end9:                                          ; preds = %land.lhs.true, %if.end
  store i32 -93, i32* %err, align 4, !tbaa !49
  %sk10 = getelementptr inbounds %struct.socket, %struct.socket* %call, i32 0, i32 5
  %6 = load %struct.sock*, %struct.sock** %sk10, align 8, !tbaa !387
  %sk_protocol = getelementptr inbounds %struct.sock, %struct.sock* %6, i32 0, i32 20
  %bf.load = load i32, i32* %sk_protocol, align 8
  %bf.lshr = lshr i32 %bf.load, 8
  %bf.clear = and i32 %bf.lshr, 255
  %cmp11 = icmp ne i32 %bf.clear, 6
  br i1 %cmp11, label %land.lhs.true13, label %if.end22

land.lhs.true13:                                  ; preds = %if.end9
  %sk14 = getelementptr inbounds %struct.socket, %struct.socket* %call, i32 0, i32 5
  %7 = load %struct.sock*, %struct.sock** %sk14, align 8, !tbaa !387
  %sk_protocol15 = getelementptr inbounds %struct.sock, %struct.sock* %7, i32 0, i32 20
  %bf.load16 = load i32, i32* %sk_protocol15, align 8
  %bf.lshr17 = lshr i32 %bf.load16, 8
  %bf.clear18 = and i32 %bf.lshr17, 255
  %cmp19 = icmp ne i32 %bf.clear18, 17
  br i1 %cmp19, label %out, label %if.end22

if.end22:                                         ; preds = %land.lhs.true13, %if.end9
  store i32 -106, i32* %err, align 4, !tbaa !49
  %state = getelementptr inbounds %struct.socket, %struct.socket* %call, i32 0, i32 0
  %8 = load i32, i32* %state, align 8, !tbaa !397
  %cmp23 = icmp ugt i32 %8, 1
  br i1 %cmp23, label %out, label %if.end26

if.end26:                                         ; preds = %if.end22
  store i32 -2, i32* %err, align 4, !tbaa !49
  %call27 = call zeroext i1 @try_module_get(%struct.module* @__this_module)
  br i1 %call27, label %if.end29, label %out

if.end29:                                         ; preds = %if.end26
  %call30 = call %struct.svc_sock* @svc_setup_socket(%struct.svc_serv* %serv, %struct.socket* %call, i32 0)
  %9 = bitcast %struct.svc_sock* %call30 to i8*
  %call31 = call i64 @IS_ERR.589(i8* %9)
  %tobool32 = icmp ne i64 %call31, 0
  br i1 %tobool32, label %if.then33, label %if.end36

if.then33:                                        ; preds = %if.end29
  call void @module_put(%struct.module* @__this_module)
  %10 = bitcast %struct.svc_sock* %call30 to i8*
  %call34 = call i64 @PTR_ERR.590(i8* %10)
  %conv35 = trunc i64 %call34 to i32
  store i32 %conv35, i32* %err, align 4, !tbaa !49
  br label %out

if.end36:                                         ; preds = %if.end29
  %sk_sock = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %call30, i32 0, i32 1
  %11 = load %struct.socket*, %struct.socket** %sk_sock, align 8, !tbaa !369
  %call37 = call i32 @kernel_getsockname(%struct.socket* %11, %struct.sockaddr* %0, i32* %salen)
  %cmp38 = icmp eq i32 %call37, 0
  br i1 %cmp38, label %if.then40, label %if.end42

if.then40:                                        ; preds = %if.end36
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %call30, i32 0, i32 0
  %12 = load i32, i32* %salen, align 4, !tbaa !49
  %conv41 = sext i32 %12 to i64
  call void @svc_xprt_set_local(%struct.svc_xprt* %sk_xprt, %struct.sockaddr* %0, i64 %conv41)
  br label %if.end42

if.end42:                                         ; preds = %if.then40, %if.end36
  %sk_xprt43 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %call30, i32 0, i32 0
  call void @svc_add_new_perm_xprt(%struct.svc_serv* %serv, %struct.svc_xprt* %sk_xprt43)
  %conv44 = trunc i64 %len to i32
  %call45 = call i32 @svc_one_sock_name(%struct.svc_sock* %call30, i8* %name_return, i32 %conv44)
  br label %cleanup

out:                                              ; preds = %if.then33, %if.end26, %if.end22, %land.lhs.true13, %land.lhs.true
  %file = getelementptr inbounds %struct.socket, %struct.socket* %call, i32 0, i32 4
  %13 = load %struct.file*, %struct.file** %file, align 8, !tbaa !742
  call void @fput(%struct.file* %13)
  %14 = load i32, i32* %err, align 4, !tbaa !49
  br label %cleanup

cleanup:                                          ; preds = %out, %if.end42, %if.then
  %retval.0 = phi i32 [ %14, %out ], [ %call45, %if.end42 ], [ %1, %if.then ]
  ret i32 %retval.0
}

declare %struct.socket* @sockfd_lookup(i32, i32*) #4

; Function Attrs: nounwind uwtable
define internal %struct.svc_sock* @svc_setup_socket(%struct.svc_serv* %serv, %struct.socket* %sock, i32 %flags) #0 {
entry:
  %and = and i32 %flags, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and1 = and i32 %0, 256
  %tobool2 = icmp ne i32 %and1, 0
  %lnot3 = xor i1 %tobool2, true
  %lnot5 = xor i1 %lnot3, true
  %lnot.ext6 = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext6 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %call8 = call i8* @kzalloc.597(i64 3088, i32 208)
  %2 = bitcast i8* %call8 to %struct.svc_sock*
  %tobool9 = icmp ne %struct.svc_sock* %2, null
  br i1 %tobool9, label %if.end12, label %if.then10

if.then10:                                        ; preds = %do.end
  %call11 = call i8* @ERR_PTR.598(i64 -12)
  %3 = bitcast i8* %call11 to %struct.svc_sock*
  br label %cleanup

if.end12:                                         ; preds = %do.end
  %sk = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %4 = load %struct.sock*, %struct.sock** %sk, align 8, !tbaa !387
  %tobool13 = icmp ne i32 %lnot.ext, 0
  br i1 %tobool13, label %if.then14, label %if.end24

if.then14:                                        ; preds = %if.end12
  %sk15 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %5 = load %struct.sock*, %struct.sock** %sk15, align 8, !tbaa !387
  %call16 = call %struct.net* @sock_net.599(%struct.sock* %5)
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %4, i32 0, i32 0
  %skc_family = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 3
  %6 = load i16, i16* %skc_family, align 8, !tbaa !462
  %conv17 = zext i16 %6 to i32
  %sk_protocol = getelementptr inbounds %struct.sock, %struct.sock* %4, i32 0, i32 20
  %bf.load = load i32, i32* %sk_protocol, align 8
  %bf.lshr = lshr i32 %bf.load, 8
  %bf.clear = and i32 %bf.lshr, 255
  %conv18 = trunc i32 %bf.clear to i16
  %call19 = call %struct.inet_sock* @inet_sk(%struct.sock* %4)
  %inet_sport = getelementptr inbounds %struct.inet_sock, %struct.inet_sock* %call19, i32 0, i32 5
  %7 = load i16, i16* %inet_sport, align 8, !tbaa !743
  %call20 = call zeroext i16 @__fswab16.600(i16 zeroext %7) #3
  %conv21 = zext i16 %call20 to i32
  %conv22 = trunc i32 %conv21 to i16
  %call23 = call i32 @svc_register(%struct.svc_serv* %serv, %struct.net* %call16, i32 %conv17, i16 zeroext %conv18, i16 zeroext %conv22)
  br label %if.end24

if.end24:                                         ; preds = %if.then14, %if.end12
  %err.0 = phi i32 [ %call23, %if.then14 ], [ 0, %if.end12 ]
  %cmp = icmp slt i32 %err.0, 0
  %8 = bitcast %struct.svc_sock* %2 to i8*
  br i1 %cmp, label %if.then26, label %if.end29

if.then26:                                        ; preds = %if.end24
  call void @kfree(i8* %8)
  %conv27 = sext i32 %err.0 to i64
  %call28 = call i8* @ERR_PTR.598(i64 %conv27)
  %9 = bitcast i8* %call28 to %struct.svc_sock*
  br label %cleanup

if.end29:                                         ; preds = %if.end24
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %4, i32 0, i32 47
  store i8* %8, i8** %sk_user_data, align 8, !tbaa !398
  %sk_sock = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 1
  store %struct.socket* %sock, %struct.socket** %sk_sock, align 8, !tbaa !369
  %sk_sk = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 2
  store %struct.sock* %4, %struct.sock** %sk_sk, align 8, !tbaa !372
  %sk_state_change = getelementptr inbounds %struct.sock, %struct.sock* %4, i32 0, i32 56
  %10 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_state_change, align 8, !tbaa !400
  %sk_ostate = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 3
  store void (%struct.sock*)* %10, void (%struct.sock*)** %sk_ostate, align 8, !tbaa !744
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %4, i32 0, i32 57
  %11 = load void (%struct.sock*, i32)*, void (%struct.sock*, i32)** %sk_data_ready, align 8, !tbaa !399
  %sk_odata = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 4
  store void (%struct.sock*, i32)* %11, void (%struct.sock*, i32)** %sk_odata, align 8, !tbaa !745
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %4, i32 0, i32 58
  %12 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !401
  %sk_owspace = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 5
  store void (%struct.sock*)* %12, void (%struct.sock*)** %sk_owspace, align 8, !tbaa !746
  %type = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 1
  %13 = load i16, i16* %type, align 4, !tbaa !747
  %conv30 = sext i16 %13 to i32
  %cmp31 = icmp eq i32 %conv30, 2
  br i1 %cmp31, label %if.then33, label %if.else

if.then33:                                        ; preds = %if.end29
  call void @svc_udp_init(%struct.svc_sock* %2, %struct.svc_serv* %serv)
  br label %do.body38

if.else:                                          ; preds = %if.end29
  %sk_sock34 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 1
  %14 = load %struct.socket*, %struct.socket** %sk_sock34, align 8, !tbaa !369
  %sv_max_mesg = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 6
  %15 = load i32, i32* %sv_max_mesg, align 4, !tbaa !724
  %mul = mul i32 4, %15
  %sv_max_mesg35 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 6
  %16 = load i32, i32* %sv_max_mesg35, align 4, !tbaa !724
  %mul36 = mul i32 4, %16
  call void @svc_sock_setbufsize(%struct.socket* %14, i32 %mul, i32 %mul36)
  call void @svc_tcp_init(%struct.svc_sock* %2, %struct.svc_serv* %serv)
  br label %do.body38

do.body38:                                        ; preds = %if.else, %if.then33
  %17 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and39 = and i32 %17, 256
  %tobool40 = icmp ne i32 %and39, 0
  %lnot41 = xor i1 %tobool40, true
  %lnot43 = xor i1 %lnot41, true
  %lnot.ext44 = zext i1 %lnot43 to i32
  %conv45 = sext i32 %lnot.ext44 to i64
  %expval46 = call i64 @llvm.expect.i64(i64 %conv45, i64 0)
  %tobool47 = icmp ne i64 %expval46, 0
  br i1 %tobool47, label %if.then48, label %cleanup

if.then48:                                        ; preds = %do.body38
  %18 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then48, %do.body38, %if.then26, %if.then10
  %retval.0 = phi %struct.svc_sock* [ %9, %if.then26 ], [ %3, %if.then10 ], [ %2, %if.then48 ], [ %2, %do.body38 ]
  ret %struct.svc_sock* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR.589(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR.590(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @svc_xprt_set_local(%struct.svc_xprt* %xprt, %struct.sockaddr* %sa, i64 %salen) #2 {
entry:
  %xpt_local = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 12
  %0 = bitcast %struct.__kernel_sockaddr_storage* %xpt_local to i8*
  %1 = bitcast %struct.sockaddr* %sa to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 %salen, i32 2, i1 false)
  %xpt_locallen = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 13
  store i64 %salen, i64* %xpt_locallen, align 8, !tbaa !748
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_one_sock_name(%struct.svc_sock* %svsk, i8* %buf, i32 %remaining) #0 {
entry:
  %sk_sk = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 2
  %0 = load %struct.sock*, %struct.sock** %sk_sk, align 8, !tbaa !372
  %sk_protocol = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 20
  %bf.load = load i32, i32* %sk_protocol, align 8
  %bf.lshr = lshr i32 %bf.load, 8
  %bf.clear = and i32 %bf.lshr, 255
  %cmp = icmp eq i32 %bf.clear, 17
  %cond = select i1 %cmp, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.47.591, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.592, i32 0, i32 0)
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 0
  %skc_family = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 3
  %1 = load i16, i16* %skc_family, align 8, !tbaa !462
  %conv = zext i16 %1 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb9, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %conv1 = sext i32 %remaining to i64
  %call = call %struct.inet_sock* @inet_sk(%struct.sock* %0)
  %sk2 = getelementptr inbounds %struct.inet_sock, %struct.inet_sock* %call, i32 0, i32 0
  %__sk_common3 = getelementptr inbounds %struct.sock, %struct.sock* %sk2, i32 0, i32 0
  %2 = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common3, i32 0, i32 0
  %3 = bitcast %struct.pgprot* %2 to %struct.exception_table_entry*
  %skc_rcv_saddr = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %3, i32 0, i32 1
  %call4 = call %struct.inet_sock* @inet_sk(%struct.sock* %0)
  %sk5 = getelementptr inbounds %struct.inet_sock, %struct.inet_sock* %call4, i32 0, i32 0
  %__sk_common6 = getelementptr inbounds %struct.sock, %struct.sock* %sk5, i32 0, i32 0
  %4 = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common6, i32 0, i32 2
  %5 = bitcast %struct.atomic_t* %4 to %struct.nlattr*
  %skc_num = getelementptr inbounds %struct.nlattr, %struct.nlattr* %5, i32 0, i32 1
  %6 = load i16, i16* %skc_num, align 2, !tbaa !166
  %conv7 = zext i16 %6 to i32
  %call8 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 %conv1, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.67.593, i32 0, i32 0), i8* %cond, i32* %skc_rcv_saddr, i32 %conv7)
  br label %sw.epilog

sw.bb9:                                           ; preds = %LeafBlock1
  %conv10 = sext i32 %remaining to i64
  %call11 = call %struct.ipv6_pinfo* @inet6_sk(%struct.sock* %0)
  %rcv_saddr = getelementptr inbounds %struct.ipv6_pinfo, %struct.ipv6_pinfo* %call11, i32 0, i32 1
  %call12 = call %struct.inet_sock* @inet_sk(%struct.sock* %0)
  %sk13 = getelementptr inbounds %struct.inet_sock, %struct.inet_sock* %call12, i32 0, i32 0
  %__sk_common14 = getelementptr inbounds %struct.sock, %struct.sock* %sk13, i32 0, i32 0
  %7 = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common14, i32 0, i32 2
  %8 = bitcast %struct.atomic_t* %7 to %struct.nlattr*
  %skc_num15 = getelementptr inbounds %struct.nlattr, %struct.nlattr* %8, i32 0, i32 1
  %9 = load i16, i16* %skc_num15, align 2, !tbaa !166
  %conv16 = zext i16 %9 to i32
  %call17 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 %conv10, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.68.594, i32 0, i32 0), i8* %cond, %struct.in6_addr* %rcv_saddr, i32 %conv16)
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %conv18 = sext i32 %remaining to i64
  %__sk_common19 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 0
  %skc_family20 = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common19, i32 0, i32 3
  %10 = load i16, i16* %skc_family20, align 8, !tbaa !462
  %conv21 = zext i16 %10 to i32
  %call22 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 %conv18, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.69.595, i32 0, i32 0), i32 %conv21)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb9, %sw.bb
  %len.0 = phi i32 [ %call8, %sw.bb ], [ %call22, %sw.default ], [ %call17, %sw.bb9 ]
  %cmp23 = icmp sge i32 %len.0, %remaining
  br i1 %cmp23, label %if.then, label %cleanup

if.then:                                          ; preds = %sw.epilog
  store i8 0, i8* %buf, align 1, !tbaa !166
  br label %cleanup

cleanup:                                          ; preds = %if.then, %sw.epilog
  %retval.0 = phi i32 [ -36, %if.then ], [ %len.0, %sw.epilog ]
  ret i32 %retval.0
}

declare void @fput(%struct.file*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.inet_sock* @inet_sk(%struct.sock* %sk) #2 {
entry:
  %0 = bitcast %struct.sock* %sk to %struct.inet_sock*
  ret %struct.inet_sock* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.ipv6_pinfo* @inet6_sk(%struct.sock* %__sk) #2 {
entry:
  %call = call %struct.inet_sock* @inet_sk(%struct.sock* %__sk)
  %pinet6 = getelementptr inbounds %struct.inet_sock, %struct.inet_sock* %call, i32 0, i32 1
  %0 = load %struct.ipv6_pinfo*, %struct.ipv6_pinfo** %pinet6, align 8, !tbaa !749
  ret %struct.ipv6_pinfo* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.597(i64 %size, i32 %flags) #2 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #7
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR.598(i64 %error) #2 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.net* @sock_net.599(%struct.sock* %sk) #2 {
entry:
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_net = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 9
  %call = call %struct.net* @read_pnet.685(%struct.net** %skc_net)
  ret %struct.net* %call
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal zeroext i16 @__fswab16.600(i16 zeroext %val) #5 {
entry:
  %conv = zext i16 %val to i32
  %and = and i32 %conv, 255
  %shl = shl i32 %and, 8
  %conv1 = zext i16 %val to i32
  %and2 = and i32 %conv1, 65280
  %shr = ashr i32 %and2, 8
  %or = or i32 %shl, %shr
  %conv3 = trunc i32 %or to i16
  ret i16 %conv3
}

; Function Attrs: nounwind uwtable
define internal void @svc_udp_init(%struct.svc_sock* %svsk, %struct.svc_serv* %serv) #0 {
entry:
  %one = alloca i32, align 4
  store i32 1, i32* %one, align 4, !tbaa !49
  %sk_sock = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 1
  %0 = load %struct.socket*, %struct.socket** %sk_sock, align 8, !tbaa !369
  %sk = getelementptr inbounds %struct.socket, %struct.socket* %0, i32 0, i32 5
  %1 = load %struct.sock*, %struct.sock** %sk, align 8, !tbaa !387
  %call = call %struct.net* @sock_net.599(%struct.sock* %1)
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  call void @svc_xprt_init(%struct.net* %call, %struct.svc_xprt_class* @svc_udp_class, %struct.svc_xprt* %sk_xprt, %struct.svc_serv* %serv)
  %sk_xprt1 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt1, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 12, i64* %xpt_flags) #7, !srcloc !750
  %sk_sk = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 2
  %2 = load %struct.sock*, %struct.sock** %sk_sk, align 8, !tbaa !372
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 57
  store void (%struct.sock*, i32)* @svc_udp_data_ready, void (%struct.sock*, i32)** %sk_data_ready, align 8, !tbaa !399
  %sk_sk2 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 2
  %3 = load %struct.sock*, %struct.sock** %sk_sk2, align 8, !tbaa !372
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 58
  store void (%struct.sock*)* @svc_write_space, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !401
  %sk_sock3 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 1
  %4 = load %struct.socket*, %struct.socket** %sk_sock3, align 8, !tbaa !369
  %sk_xprt4 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  %xpt_server = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt4, i32 0, i32 6
  %5 = load %struct.svc_serv*, %struct.svc_serv** %xpt_server, align 8, !tbaa !751
  %sv_max_mesg = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %5, i32 0, i32 6
  %6 = load i32, i32* %sv_max_mesg, align 4, !tbaa !724
  %mul = mul i32 3, %6
  %sk_xprt5 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  %xpt_server6 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt5, i32 0, i32 6
  %7 = load %struct.svc_serv*, %struct.svc_serv** %xpt_server6, align 8, !tbaa !751
  %sv_max_mesg7 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %7, i32 0, i32 6
  %8 = load i32, i32* %sv_max_mesg7, align 4, !tbaa !724
  %mul8 = mul i32 3, %8
  call void @svc_sock_setbufsize(%struct.socket* %4, i32 %mul, i32 %mul8)
  %sk_xprt9 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  %xpt_flags10 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt9, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags10, i32 3, i64* %xpt_flags10) #7, !srcloc !752
  %sk_xprt11 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  %xpt_flags12 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt11, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags12, i32 7, i64* %xpt_flags12) #7, !srcloc !752
  %sk_sk13 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 2
  %9 = load %struct.sock*, %struct.sock** %sk_sk13, align 8, !tbaa !372
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %9, i32 0, i32 0
  %skc_family = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 3
  %10 = load i16, i16* %skc_family, align 8, !tbaa !462
  %conv = zext i16 %10 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.epilog, label %do.body

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.epilog, label %do.body

do.body:                                          ; preds = %LeafBlock, %LeafBlock1
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7.621, i32 0, i32 0), i32 721, i64 12) #7, !srcloc !753
  br label %do.body15

do.body15:                                        ; preds = %do.body15, %do.body
  br label %do.body15

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1
  %level.0 = phi i32 [ 0, %LeafBlock ], [ 41, %LeafBlock1 ]
  %optname.0 = phi i32 [ 8, %LeafBlock ], [ 49, %LeafBlock1 ]
  %sk_sock18 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 1
  %11 = load %struct.socket*, %struct.socket** %sk_sock18, align 8, !tbaa !369
  %12 = bitcast i32* %one to i8*
  %call19 = call i32 @kernel_setsockopt(%struct.socket* %11, i32 %level.0, i32 %optname.0, i8* %12, i32 4)
  %13 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %13, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot21 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot21 to i32
  %conv22 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv22, i64 0)
  %tobool23 = icmp ne i64 %expval, 0
  br i1 %tobool23, label %if.then, label %do.end26

if.then:                                          ; preds = %sw.epilog
  %14 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end26

do.end26:                                         ; preds = %if.then, %sw.epilog
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_sock_setbufsize(%struct.socket* %sock, i32 %snd, i32 %rcv) #0 {
entry:
  %sk = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %0 = load %struct.sock*, %struct.sock** %sk, align 8, !tbaa !387
  call void @lock_sock(%struct.sock* %0)
  %mul = mul i32 %snd, 2
  %sk1 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %1 = load %struct.sock*, %struct.sock** %sk1, align 8, !tbaa !387
  %sk_sndbuf = getelementptr inbounds %struct.sock, %struct.sock* %1, i32 0, i32 18
  store i32 %mul, i32* %sk_sndbuf, align 8, !tbaa !433
  %mul2 = mul i32 %rcv, 2
  %sk3 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %2 = load %struct.sock*, %struct.sock** %sk3, align 8, !tbaa !387
  %sk_rcvbuf = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 7
  store i32 %mul2, i32* %sk_rcvbuf, align 4, !tbaa !468
  %sk4 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %3 = load %struct.sock*, %struct.sock** %sk4, align 8, !tbaa !387
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 58
  %4 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !401
  %sk5 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %5 = load %struct.sock*, %struct.sock** %sk5, align 8, !tbaa !387
  call void %4(%struct.sock* %5)
  %sk6 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %6 = load %struct.sock*, %struct.sock** %sk6, align 8, !tbaa !387
  call void @release_sock(%struct.sock* %6)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_tcp_init(%struct.svc_sock* %svsk, %struct.svc_serv* %serv) #0 {
entry:
  %sk_sk = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 2
  %0 = load %struct.sock*, %struct.sock** %sk_sk, align 8, !tbaa !372
  %sk_sock = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 1
  %1 = load %struct.socket*, %struct.socket** %sk_sock, align 8, !tbaa !369
  %sk1 = getelementptr inbounds %struct.socket, %struct.socket* %1, i32 0, i32 5
  %2 = load %struct.sock*, %struct.sock** %sk1, align 8, !tbaa !387
  %call = call %struct.net* @sock_net.599(%struct.sock* %2)
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  call void @svc_xprt_init(%struct.net* %call, %struct.svc_xprt_class* @svc_tcp_class, %struct.svc_xprt* %sk_xprt, %struct.svc_serv* %serv)
  %sk_xprt2 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt2, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 12, i64* %xpt_flags) #7, !srcloc !752
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 0
  %skc_state = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 4
  %3 = load volatile i8, i8* %skc_state, align 2, !tbaa !389
  %conv = zext i8 %3 to i32
  %cmp = icmp eq i32 %conv, 10
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %4, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv5, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %cmp, label %do.body, label %do.body13

do.body:                                          ; preds = %entry
  br i1 %tobool6, label %if.then7, label %do.end

if.then7:                                         ; preds = %do.body
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then7, %do.body
  %sk_xprt9 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  %xpt_flags10 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt9, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags10, i32 11, i64* %xpt_flags10) #7, !srcloc !752
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 57
  store void (%struct.sock*, i32)* @svc_tcp_listen_data_ready, void (%struct.sock*, i32)** %sk_data_ready, align 8, !tbaa !399
  %sk_xprt11 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  %xpt_flags12 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt11, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags12, i32 1, i64* %xpt_flags12) #7, !srcloc !752
  br label %if.end45

do.body13:                                        ; preds = %entry
  br i1 %tobool6, label %if.then23, label %do.end27

if.then23:                                        ; preds = %do.body13
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end27

do.end27:                                         ; preds = %if.then23, %do.body13
  %sk_state_change = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 56
  store void (%struct.sock*)* @svc_tcp_state_change, void (%struct.sock*)** %sk_state_change, align 8, !tbaa !400
  %sk_data_ready28 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 57
  store void (%struct.sock*, i32)* @svc_tcp_data_ready, void (%struct.sock*, i32)** %sk_data_ready28, align 8, !tbaa !399
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 58
  store void (%struct.sock*)* @svc_tcp_write_space, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !401
  %sk_reclen = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 6
  store i32 0, i32* %sk_reclen, align 8, !tbaa !754
  %sk_tcplen = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 7
  store i32 0, i32* %sk_tcplen, align 4, !tbaa !755
  %sk_datalen = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 8
  store i32 0, i32* %sk_datalen, align 8, !tbaa !756
  %sk_pages = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 9
  %arrayidx = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %sk_pages, i64 0, i64 0
  %7 = bitcast %struct.page** %arrayidx to i8*
  call void @llvm.memset.p0i8.i64(i8* %7, i8 0, i64 2072, i32 8, i1 false)
  %call29 = call %struct.tcp_sock* @tcp_sk.605(%struct.sock* %0)
  %nonagle = getelementptr inbounds %struct.tcp_sock, %struct.tcp_sock* %call29, i32 0, i32 24
  %bf.load = load i8, i8* %nonagle, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv30 = zext i8 %bf.clear to i32
  %or = or i32 %conv30, 1
  %conv31 = trunc i32 %or to i8
  %bf.load32 = load i8, i8* %nonagle, align 1
  %bf.value = and i8 %conv31, 15
  %bf.clear33 = and i8 %bf.load32, -16
  %bf.set = or i8 %bf.clear33, %bf.value
  store i8 %bf.set, i8* %nonagle, align 1
  %sk_xprt34 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  %xpt_flags35 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt34, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags35, i32 3, i64* %xpt_flags35) #7, !srcloc !752
  %__sk_common36 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 0
  %skc_state37 = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common36, i32 0, i32 4
  %8 = load volatile i8, i8* %skc_state37, align 2, !tbaa !389
  %conv38 = zext i8 %8 to i32
  %cmp39 = icmp ne i32 %conv38, 1
  br i1 %cmp39, label %if.then41, label %if.end45

if.then41:                                        ; preds = %do.end27
  %sk_xprt42 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  %xpt_flags43 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt42, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags43, i32 2, i64* %xpt_flags43) #7, !srcloc !752
  br label %if.end45

if.end45:                                         ; preds = %if.then41, %do.end27, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_tcp_listen_data_ready(%struct.sock* %sk, i32 %count_unused) #0 {
entry:
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 47
  %0 = load i8*, i8** %sk_user_data, align 8, !tbaa !398
  %1 = bitcast i8* %0 to %struct.svc_sock*
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_state = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 4
  %3 = load volatile i8, i8* %skc_state, align 2, !tbaa !389
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %__sk_common4 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_state5 = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common4, i32 0, i32 4
  %5 = load volatile i8, i8* %skc_state5, align 2, !tbaa !389
  %conv6 = zext i8 %5 to i32
  %cmp = icmp eq i32 %conv6, 10
  br i1 %cmp, label %if.then8, label %if.end14

if.then8:                                         ; preds = %do.end
  %tobool9 = icmp ne %struct.svc_sock* %1, null
  br i1 %tobool9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then8
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 0
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 1, i64* %xpt_flags) #7, !srcloc !752
  %sk_xprt11 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 0
  call void @svc_xprt_enqueue(%struct.svc_xprt* %sk_xprt11)
  br label %if.end14

if.else:                                          ; preds = %if.then8
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end14

if.end14:                                         ; preds = %if.else, %if.then10, %do.end
  %call15 = call %struct.__wait_queue_head* @sk_sleep(%struct.sock* %sk)
  %tobool16 = icmp ne %struct.__wait_queue_head* %call15, null
  br i1 %tobool16, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.end14
  %call17 = call i32 @waitqueue_active.611(%struct.__wait_queue_head* %call15)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %land.lhs.true
  call void @__wake_up(%struct.__wait_queue_head* %call15, i32 1, i32 0, i8* null)
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %land.lhs.true, %if.end14
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_tcp_state_change(%struct.sock* %sk) #0 {
entry:
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 47
  %0 = load i8*, i8** %sk_user_data, align 8, !tbaa !398
  %1 = bitcast i8* %0 to %struct.svc_sock*
  %call = call %struct.__wait_queue_head* @sk_sleep(%struct.sock* %sk)
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_state = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 4
  %3 = load volatile i8, i8* %skc_state, align 2, !tbaa !389
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tobool6 = icmp ne %struct.svc_sock* %1, null
  br i1 %tobool6, label %if.else, label %if.then7

if.then7:                                         ; preds = %do.end
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end10

if.else:                                          ; preds = %do.end
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 0
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 2, i64* %xpt_flags) #7, !srcloc !752
  %sk_xprt9 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 0
  call void @svc_xprt_enqueue(%struct.svc_xprt* %sk_xprt9)
  br label %if.end10

if.end10:                                         ; preds = %if.else, %if.then7
  %tobool11 = icmp ne %struct.__wait_queue_head* %call, null
  br i1 %tobool11, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %if.end10
  %call12 = call i32 @waitqueue_active.611(%struct.__wait_queue_head* %call)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %land.lhs.true
  call void @__wake_up(%struct.__wait_queue_head* %call, i32 1, i32 0, i8* null)
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %land.lhs.true, %if.end10
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_tcp_data_ready(%struct.sock* %sk, i32 %count) #0 {
entry:
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 47
  %0 = load i8*, i8** %sk_user_data, align 8, !tbaa !398
  %1 = bitcast i8* %0 to %struct.svc_sock*
  %call = call %struct.__wait_queue_head* @sk_sleep(%struct.sock* %sk)
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tobool5 = icmp ne %struct.svc_sock* %1, null
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %do.end
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 0
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 3, i64* %xpt_flags) #7, !srcloc !752
  %sk_xprt7 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 0
  call void @svc_xprt_enqueue(%struct.svc_xprt* %sk_xprt7)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %do.end
  %tobool9 = icmp ne %struct.__wait_queue_head* %call, null
  br i1 %tobool9, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %if.end8
  %call10 = call i32 @waitqueue_active.611(%struct.__wait_queue_head* %call)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %land.lhs.true
  call void @__wake_up(%struct.__wait_queue_head* %call, i32 1, i32 1, i8* null)
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %land.lhs.true, %if.end8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_tcp_write_space(%struct.sock* %sk) #0 {
entry:
  %sk_socket = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 46
  %0 = load %struct.socket*, %struct.socket** %sk_socket, align 8, !tbaa !435
  %call = call i32 @sk_stream_wspace.606(%struct.sock* %sk)
  %call1 = call i32 @sk_stream_min_wspace.607(%struct.sock* %sk)
  %cmp = icmp sge i32 %call, %call1
  %tobool = icmp ne %struct.socket* %0, null
  %or.cond = and i1 %cmp, %tobool
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %0, i32 0, i32 2
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags, i32 2, i64* %flags) #7, !srcloc !750
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @svc_write_space(%struct.sock* %sk)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.tcp_sock* @tcp_sk.605(%struct.sock* %sk) #2 {
entry:
  %0 = bitcast %struct.sock* %sk to %struct.tcp_sock*
  ret %struct.tcp_sock* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @sk_stream_wspace.606(%struct.sock* %sk) #2 {
entry:
  %sk_sndbuf = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 18
  %0 = load i32, i32* %sk_sndbuf, align 8, !tbaa !433
  %sk_wmem_queued = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 21
  %1 = load i32, i32* %sk_wmem_queued, align 4, !tbaa !434
  %sub = sub nsw i32 %0, %1
  ret i32 %sub
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @sk_stream_min_wspace.607(%struct.sock* %sk) #2 {
entry:
  %sk_wmem_queued = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 21
  %0 = load i32, i32* %sk_wmem_queued, align 4, !tbaa !434
  %shr = ashr i32 %0, 1
  ret i32 %shr
}

; Function Attrs: nounwind uwtable
define internal void @svc_write_space(%struct.sock* %sk) #0 {
entry:
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 47
  %0 = load i8*, i8** %sk_user_data, align 8, !tbaa !398
  %1 = bitcast i8* %0 to %struct.svc_sock*
  %call = call %struct.__wait_queue_head* @sk_sleep(%struct.sock* %sk)
  %tobool = icmp ne %struct.svc_sock* %1, null
  br i1 %tobool, label %do.body, label %if.end8

do.body:                                          ; preds = %entry
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 256
  %tobool1 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.end

if.then4:                                         ; preds = %do.body
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 0
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt, i32 0, i32 5
  %3 = load volatile i64, i64* %xpt_flags, align 8, !tbaa !88
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then4, %do.body
  %sk_xprt7 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 0
  call void @svc_xprt_enqueue(%struct.svc_xprt* %sk_xprt7)
  br label %if.end8

if.end8:                                          ; preds = %do.end, %entry
  %tobool9 = icmp ne %struct.__wait_queue_head* %call, null
  br i1 %tobool9, label %land.lhs.true, label %if.end28

land.lhs.true:                                    ; preds = %if.end8
  %call10 = call i32 @waitqueue_active.611(%struct.__wait_queue_head* %call)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %do.body13, label %if.end28

do.body13:                                        ; preds = %land.lhs.true
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and14 = and i32 %5, 256
  %tobool15 = icmp ne i32 %and14, 0
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot.ext19 = zext i1 %lnot18 to i32
  %conv20 = sext i32 %lnot.ext19 to i64
  %expval21 = call i64 @llvm.expect.i64(i64 %conv20, i64 0)
  %tobool22 = icmp ne i64 %expval21, 0
  br i1 %tobool22, label %if.then23, label %do.end27

if.then23:                                        ; preds = %do.body13
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end27

do.end27:                                         ; preds = %if.then23, %do.body13
  call void @__wake_up(%struct.__wait_queue_head* %call, i32 1, i32 1, i8* null)
  br label %if.end28

if.end28:                                         ; preds = %do.end27, %land.lhs.true, %if.end8
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.__wait_queue_head* @sk_sleep(%struct.sock* %sk) #2 {
entry:
  %tobool = trunc i8 0 to i1
  br i1 %tobool, label %if.then, label %do.body1

if.then:                                          ; preds = %entry
  call void @__compiletime_assert_1677()
  br label %do.body1

do.body1:                                         ; preds = %if.then, %entry
  %sk_wq = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 9
  %0 = load volatile %struct.socket_wq*, %struct.socket_wq** %sk_wq, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %land.lhs.true, label %do.end17

land.lhs.true:                                    ; preds = %do.body1
  %1 = load i8, i8* @sk_sleep.__warned, align 1, !tbaa !29, !range !31
  %tobool7 = trunc i8 %1 to i1
  br i1 %tobool7, label %do.end17, label %land.lhs.true8

land.lhs.true8:                                   ; preds = %land.lhs.true
  call void @rcu_read_lock_held.614()
  br label %do.end17

do.end17:                                         ; preds = %land.lhs.true8, %land.lhs.true, %do.body1
  %wait = getelementptr inbounds %struct.socket_wq, %struct.socket_wq* %0, i32 0, i32 0
  ret %struct.__wait_queue_head* %wait
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @waitqueue_active.611(%struct.__wait_queue_head* %q) #2 {
entry:
  %task_list = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %q, i32 0, i32 1
  %call = call i32 @list_empty.613(%struct.list_head* %task_list)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty.613(%struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare void @__compiletime_assert_1677() #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock_held.614() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call1 = call i32 @rcu_is_cpu_idle()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call zeroext i1 @rcu_lockdep_current_cpu_online()
  br i1 %call5, label %if.end7, label %return

if.end7:                                          ; preds = %if.end4
  %call8 = call i32 @lock_is_held(%struct.lockdep_map* @rcu_lock_map)
  br label %return

return:                                           ; preds = %if.end7, %if.end4, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.svc_xprt* @svc_tcp_create(%struct.svc_serv* %serv, %struct.net* %net, %struct.sockaddr* %sa, i32 %salen, i32 %flags) #0 {
entry:
  %call = call %struct.svc_xprt* @svc_create_socket(%struct.svc_serv* %serv, i32 6, %struct.net* %net, %struct.sockaddr* %sa, i32 %salen, i32 %flags)
  ret %struct.svc_xprt* %call
}

; Function Attrs: nounwind uwtable
define internal %struct.svc_xprt* @svc_tcp_accept(%struct.svc_xprt* %xprt) #0 {
entry:
  %addr = alloca %struct.__kernel_sockaddr_storage, align 8
  %newsock = alloca %struct.socket*, align 8
  %slen = alloca i32, align 4
  %buf = alloca [63 x i8], align 16
  %0 = bitcast %struct.svc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.svc_sock*
  %2 = bitcast %struct.__kernel_sockaddr_storage* %addr to %struct.sockaddr*
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 0
  %xpt_server = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt, i32 0, i32 6
  %3 = load %struct.svc_serv*, %struct.svc_serv** %xpt_server, align 8, !tbaa !751
  %sk_sock = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 1
  %4 = load %struct.socket*, %struct.socket** %sk_sock, align 8, !tbaa !369
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %5, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tobool3 = icmp ne %struct.socket* %4, null
  br i1 %tobool3, label %if.end5, label %cleanup

if.end5:                                          ; preds = %do.end
  %sk_xprt6 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 0
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt6, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 1, i64* %xpt_flags) #7, !srcloc !750
  %call7 = call i32 @kernel_accept(%struct.socket* %4, %struct.socket** %newsock, i32 2048)
  %cmp = icmp slt i32 %call7, 0
  br i1 %cmp, label %if.then9, label %if.end28

if.then9:                                         ; preds = %if.end5
  switch i32 %call7, label %do.body17 [
    i32 -12, label %if.then12
    i32 -11, label %cleanup
  ]

if.then12:                                        ; preds = %if.then9
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

do.body17:                                        ; preds = %if.then9
  %call18 = call i32 @net_ratelimit()
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.then20, label %cleanup

if.then20:                                        ; preds = %do.body17
  %8 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end28:                                         ; preds = %if.end5
  %sk_xprt29 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 0
  %xpt_flags30 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt29, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags30, i32 1, i64* %xpt_flags30) #7, !srcloc !752
  %9 = load %struct.socket*, %struct.socket** %newsock, align 8, !tbaa !28
  %call31 = call i32 @kernel_getpeername(%struct.socket* %9, %struct.sockaddr* %2, i32* %slen)
  %cmp32 = icmp slt i32 %call31, 0
  br i1 %cmp32, label %do.body35, label %if.end45

do.body35:                                        ; preds = %if.end28
  %call36 = call i32 @net_ratelimit()
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %if.then38, label %failed

if.then38:                                        ; preds = %do.body35
  %10 = call i32 (i8*, ...) @printk(i8* null)
  br label %failed

if.end45:                                         ; preds = %if.end28
  %call46 = call i32 @svc_port_is_privileged(%struct.sockaddr* %2)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %do.body67, label %do.body49

do.body49:                                        ; preds = %if.end45
  %11 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and50 = and i32 %11, 256
  %tobool51 = icmp ne i32 %and50, 0
  %lnot52 = xor i1 %tobool51, true
  %lnot54 = xor i1 %lnot52, true
  %lnot.ext55 = zext i1 %lnot54 to i32
  %conv56 = sext i32 %lnot.ext55 to i64
  %expval57 = call i64 @llvm.expect.i64(i64 %conv56, i64 0)
  %tobool58 = icmp ne i64 %expval57, 0
  br i1 %tobool58, label %if.then59, label %do.body67

if.then59:                                        ; preds = %do.body49
  %arraydecay = getelementptr inbounds [63 x i8], [63 x i8]* %buf, i32 0, i32 0
  call void @__svc_print_addr(%struct.sockaddr* %2, i8* %arraydecay, i64 63)
  %12 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.body67

do.body67:                                        ; preds = %if.then59, %do.body49, %if.end45
  %13 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and68 = and i32 %13, 256
  %tobool69 = icmp ne i32 %and68, 0
  %lnot70 = xor i1 %tobool69, true
  %lnot72 = xor i1 %lnot70, true
  %lnot.ext73 = zext i1 %lnot72 to i32
  %conv74 = sext i32 %lnot.ext73 to i64
  %expval75 = call i64 @llvm.expect.i64(i64 %conv74, i64 0)
  %tobool76 = icmp ne i64 %expval75, 0
  br i1 %tobool76, label %if.then77, label %do.end84

if.then77:                                        ; preds = %do.body67
  %arraydecay79 = getelementptr inbounds [63 x i8], [63 x i8]* %buf, i32 0, i32 0
  call void @__svc_print_addr(%struct.sockaddr* %2, i8* %arraydecay79, i64 63)
  %14 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end84

do.end84:                                         ; preds = %if.then77, %do.body67
  %15 = load %struct.socket*, %struct.socket** %newsock, align 8, !tbaa !28
  %sk = getelementptr inbounds %struct.socket, %struct.socket* %15, i32 0, i32 5
  %16 = load %struct.sock*, %struct.sock** %sk, align 8, !tbaa !387
  %sk_sndtimeo = getelementptr inbounds %struct.sock, %struct.sock* %16, i32 0, i32 42
  store i64 7500, i64* %sk_sndtimeo, align 8, !tbaa !757
  %17 = load %struct.socket*, %struct.socket** %newsock, align 8, !tbaa !28
  %call85 = call %struct.svc_sock* @svc_setup_socket(%struct.svc_serv* %3, %struct.socket* %17, i32 3)
  %18 = bitcast %struct.svc_sock* %call85 to i8*
  %call86 = call i64 @IS_ERR.589(i8* %18)
  %tobool87 = icmp ne i64 %call86, 0
  br i1 %tobool87, label %failed, label %if.end89

if.end89:                                         ; preds = %do.end84
  %sk_xprt90 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %call85, i32 0, i32 0
  %19 = load i32, i32* %slen, align 4, !tbaa !49
  %conv91 = sext i32 %19 to i64
  call void @svc_xprt_set_remote(%struct.svc_xprt* %sk_xprt90, %struct.sockaddr* %2, i64 %conv91)
  %20 = load %struct.socket*, %struct.socket** %newsock, align 8, !tbaa !28
  %call92 = call i32 @kernel_getsockname(%struct.socket* %20, %struct.sockaddr* %2, i32* %slen)
  %cmp93 = icmp slt i32 %call92, 0
  %lnot95 = xor i1 %cmp93, true
  %lnot97 = xor i1 %lnot95, true
  %lnot.ext98 = zext i1 %lnot97 to i32
  %conv99 = sext i32 %lnot.ext98 to i64
  %expval100 = call i64 @llvm.expect.i64(i64 %conv99, i64 0)
  %tobool101 = icmp ne i64 %expval100, 0
  br i1 %tobool101, label %do.body103, label %if.end119

do.body103:                                       ; preds = %if.end89
  %21 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and104 = and i32 %21, 256
  %tobool105 = icmp ne i32 %and104, 0
  %lnot106 = xor i1 %tobool105, true
  %lnot108 = xor i1 %lnot106, true
  %lnot.ext109 = zext i1 %lnot108 to i32
  %conv110 = sext i32 %lnot.ext109 to i64
  %expval111 = call i64 @llvm.expect.i64(i64 %conv110, i64 0)
  %tobool112 = icmp ne i64 %expval111, 0
  br i1 %tobool112, label %if.then113, label %do.end118

if.then113:                                       ; preds = %do.body103
  %22 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end118

do.end118:                                        ; preds = %if.then113, %do.body103
  store i32 2, i32* %slen, align 4, !tbaa !49
  br label %if.end119

if.end119:                                        ; preds = %do.end118, %if.end89
  %sk_xprt120 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %call85, i32 0, i32 0
  %23 = load i32, i32* %slen, align 4, !tbaa !49
  %conv121 = sext i32 %23 to i64
  call void @svc_xprt_set_local(%struct.svc_xprt* %sk_xprt120, %struct.sockaddr* %2, i64 %conv121)
  %sv_stats = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %3, i32 0, i32 1
  %24 = load %struct.svc_stat*, %struct.svc_stat** %sv_stats, align 8, !tbaa !670
  %tobool122 = icmp ne %struct.svc_stat* %24, null
  br i1 %tobool122, label %if.then123, label %if.end125

if.then123:                                       ; preds = %if.end119
  %sv_stats124 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %3, i32 0, i32 1
  %25 = load %struct.svc_stat*, %struct.svc_stat** %sv_stats124, align 8, !tbaa !670
  %nettcpconn = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %25, i32 0, i32 4
  %26 = load i32, i32* %nettcpconn, align 4, !tbaa !758
  %inc = add i32 %26, 1
  store i32 %inc, i32* %nettcpconn, align 4, !tbaa !758
  br label %if.end125

if.end125:                                        ; preds = %if.then123, %if.end119
  %sk_xprt126 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %call85, i32 0, i32 0
  br label %cleanup

failed:                                           ; preds = %do.end84, %if.then38, %do.body35
  %27 = load %struct.socket*, %struct.socket** %newsock, align 8, !tbaa !28
  call void @sock_release(%struct.socket* %27)
  br label %cleanup

cleanup:                                          ; preds = %failed, %if.end125, %if.then20, %do.body17, %if.then12, %if.then9, %do.end
  %retval.0 = phi %struct.svc_xprt* [ null, %failed ], [ %sk_xprt126, %if.end125 ], [ null, %do.end ], [ null, %if.then9 ], [ null, %if.then20 ], [ null, %do.body17 ], [ null, %if.then12 ]
  ret %struct.svc_xprt* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_tcp_has_wspace(%struct.svc_xprt* %xprt) #0 {
entry:
  %0 = bitcast %struct.svc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.svc_sock*
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 0
  %xpt_server = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt, i32 0, i32 6
  %2 = load %struct.svc_serv*, %struct.svc_serv** %xpt_server, align 8, !tbaa !751
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  %3 = load volatile i64, i64* %xpt_flags, align 8, !tbaa !88
  %and.i = and i64 2048, %3
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %xpt_reserved = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 7
  %call4 = call i32 @atomic_read.647(%struct.atomic_t* %xpt_reserved)
  %sv_max_mesg = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %2, i32 0, i32 6
  %4 = load i32, i32* %sv_max_mesg, align 4, !tbaa !724
  %add = add i32 %call4, %4
  %sk_sk = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 2
  %5 = load %struct.sock*, %struct.sock** %sk_sk, align 8, !tbaa !372
  %call5 = call i32 @sk_stream_wspace.606(%struct.sock* %5)
  %cmp = icmp sge i32 %call5, %add
  br i1 %cmp, label %cleanup, label %if.end7

if.end7:                                          ; preds = %if.end
  %sk_sock = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 1
  %6 = load %struct.socket*, %struct.socket** %sk_sock, align 8, !tbaa !369
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %6, i32 0, i32 2
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags, i32 2, i64* %flags) #7, !srcloc !752
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end7 ], [ 1, %entry ], [ 1, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_tcp_recvfrom(%struct.svc_rqst* %rqstp) #0 {
entry:
  %rq_xprt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %0 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt, align 8, !tbaa !635
  %1 = bitcast %struct.svc_xprt* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.svc_sock*
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 0
  %xpt_server = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt, i32 0, i32 6
  %3 = load %struct.svc_serv*, %struct.svc_serv** %xpt_server, align 8, !tbaa !751
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %4, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %sk_xprt3 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 0
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt3, i32 0, i32 5
  %5 = load volatile i64, i64* %xpt_flags, align 8, !tbaa !88
  %sk_xprt4 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 0
  %xpt_flags5 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt4, i32 0, i32 5
  %6 = load volatile i64, i64* %xpt_flags5, align 8, !tbaa !88
  %sk_xprt7 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 0
  %xpt_flags8 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt7, i32 0, i32 5
  %7 = load volatile i64, i64* %xpt_flags8, align 8, !tbaa !88
  %8 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %call11 = call i32 @svc_tcp_recv_record(%struct.svc_sock* %2, %struct.svc_rqst* %rqstp)
  %cmp = icmp slt i32 %call11, 0
  br i1 %cmp, label %error, label %if.end14

if.end14:                                         ; preds = %do.end
  %call15 = call i32 @svc_tcp_restore_pages(%struct.svc_sock* %2, %struct.svc_rqst* %rqstp)
  %call16 = call i32 @svc_sock_reclen(%struct.svc_sock* %2)
  %conv17 = zext i32 %call16 to i64
  %sk_tcplen = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 7
  %9 = load i32, i32* %sk_tcplen, align 4, !tbaa !755
  %conv18 = zext i32 %9 to i64
  %sub = sub i64 %conv18, 4
  %sub19 = sub i64 %conv17, %sub
  %conv20 = trunc i64 %sub19 to i32
  %rq_vec = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 22
  %arraydecay = getelementptr inbounds [259 x %struct.iovec], [259 x %struct.iovec]* %rq_vec, i32 0, i32 0
  %arrayidx = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i64 0
  %rq_pages = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %arrayidx21 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages, i64 0, i64 0
  %sk_datalen = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 8
  %10 = load i32, i32* %sk_datalen, align 8, !tbaa !756
  %add = add i32 %10, %conv20
  %call22 = call i32 @copy_pages_to_kvecs(%struct.iovec* %arrayidx, %struct.page** %arrayidx21, i32 %add)
  %rq_pages23 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %idxprom = sext i32 %call22 to i64
  %arrayidx24 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages23, i64 0, i64 %idxprom
  %rq_respages = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 19
  store %struct.page** %arrayidx24, %struct.page*** %rq_respages, align 8, !tbaa !695
  %rq_respages25 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 19
  %11 = load %struct.page**, %struct.page*** %rq_respages25, align 8, !tbaa !695
  %add.ptr26 = getelementptr inbounds %struct.page*, %struct.page** %11, i64 1
  %rq_next_page = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 21
  store %struct.page** %add.ptr26, %struct.page*** %rq_next_page, align 8, !tbaa !696
  %call27 = call i32 @svc_partial_recvfrom(%struct.svc_rqst* %rqstp, %struct.iovec* %arraydecay, i32 %call22, i32 %conv20, i32 %call15)
  %cmp28 = icmp sge i32 %call27, 0
  br i1 %cmp28, label %if.then30, label %if.end35

if.then30:                                        ; preds = %if.end14
  %sk_tcplen31 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 7
  %12 = load i32, i32* %sk_tcplen31, align 4, !tbaa !755
  %add32 = add i32 %12, %call27
  store i32 %add32, i32* %sk_tcplen31, align 4, !tbaa !755
  %sk_datalen33 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 8
  %13 = load i32, i32* %sk_datalen33, align 8, !tbaa !756
  %add34 = add i32 %13, %call27
  store i32 %add34, i32* %sk_datalen33, align 8, !tbaa !756
  br label %if.end35

if.end35:                                         ; preds = %if.then30, %if.end14
  %cmp36 = icmp ne i32 %call27, %conv20
  br i1 %cmp36, label %if.then40, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end35
  %call38 = call i32 @svc_sock_final_rec(%struct.svc_sock* %2)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %if.end71, label %if.then40

if.then40:                                        ; preds = %lor.lhs.false, %if.end35
  call void @svc_tcp_save_pages(%struct.svc_sock* %2, %struct.svc_rqst* %rqstp)
  %cmp41 = icmp slt i32 %call27, 0
  %cmp43 = icmp ne i32 %call27, -11
  %or.cond = and i1 %cmp41, %cmp43
  br i1 %or.cond, label %err_delete, label %if.end46

if.end46:                                         ; preds = %if.then40
  %cmp47 = icmp eq i32 %call27, %conv20
  br i1 %cmp47, label %if.then49, label %do.body50

if.then49:                                        ; preds = %if.end46
  call void @svc_tcp_fragment_received(%struct.svc_sock* %2)
  br label %cleanup

do.body50:                                        ; preds = %if.end46
  %14 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and51 = and i32 %14, 256
  %tobool52 = icmp ne i32 %and51, 0
  %lnot53 = xor i1 %tobool52, true
  %lnot55 = xor i1 %lnot53, true
  %lnot.ext56 = zext i1 %lnot55 to i32
  %conv57 = sext i32 %lnot.ext56 to i64
  %expval58 = call i64 @llvm.expect.i64(i64 %conv57, i64 0)
  %tobool59 = icmp ne i64 %expval58, 0
  br i1 %tobool59, label %if.then60, label %cleanup

if.then60:                                        ; preds = %do.body50
  %call65 = call i32 @svc_sock_reclen(%struct.svc_sock* %2)
  %15 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end71:                                         ; preds = %lor.lhs.false
  %call72 = call i32 @svc_sock_reclen(%struct.svc_sock* %2)
  %cmp73 = icmp ult i32 %call72, 8
  br i1 %cmp73, label %err_delete, label %if.end76

if.end76:                                         ; preds = %if.end71
  %sk_datalen77 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 8
  %16 = load i32, i32* %sk_datalen77, align 8, !tbaa !756
  %rq_arg = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %len78 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 7
  store i32 %16, i32* %len78, align 8, !tbaa !759
  %rq_arg79 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg79, i32 0, i32 3
  store i32 0, i32* %page_base, align 8, !tbaa !760
  %rq_arg80 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %len81 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg80, i32 0, i32 7
  %17 = load i32, i32* %len81, align 8, !tbaa !759
  %conv82 = zext i32 %17 to i64
  %rq_arg83 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg83, i32 0, i32 0
  %arrayidx84 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx84, i32 0, i32 1
  %18 = load i64, i64* %iov_len, align 8, !tbaa !149
  %cmp85 = icmp ule i64 %conv82, %18
  %rq_arg88 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %len89 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg88, i32 0, i32 7
  %19 = load i32, i32* %len89, align 8, !tbaa !759
  %conv90 = zext i32 %19 to i64
  %rq_arg91 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %head92 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg91, i32 0, i32 0
  %arrayidx93 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head92, i64 0, i64 0
  %iov_len94 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx93, i32 0, i32 1
  br i1 %cmp85, label %if.then87, label %if.else96

if.then87:                                        ; preds = %if.end76
  store i64 %conv90, i64* %iov_len94, align 8, !tbaa !149
  br label %if.end108

if.else96:                                        ; preds = %if.end76
  %20 = load i64, i64* %iov_len94, align 8, !tbaa !149
  %sub104 = sub i64 %conv90, %20
  %conv105 = trunc i64 %sub104 to i32
  br label %if.end108

if.end108:                                        ; preds = %if.else96, %if.then87
  %conv105.sink = phi i32 [ %conv105, %if.else96 ], [ 0, %if.then87 ]
  %rq_arg106 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %page_len107 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg106, i32 0, i32 4
  store i32 %conv105.sink, i32* %page_len107, align 4, !tbaa !761
  %rq_xprt_ctxt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 12
  store i8* null, i8** %rq_xprt_ctxt, align 8, !tbaa !762
  %rq_prot = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 27
  store i32 6, i32* %rq_prot, align 8, !tbaa !647
  %rq_arg109 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %head110 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg109, i32 0, i32 0
  %arrayidx111 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head110, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx111, i32 0, i32 0
  %21 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %22 = bitcast i8* %21 to i32*
  %arrayidx112 = getelementptr inbounds i32, i32* %22, i64 1
  %23 = load i32, i32* %arrayidx112, align 4, !tbaa !49
  %tobool113 = icmp ne i32 %23, 0
  br i1 %tobool113, label %if.then114, label %if.end116

if.then114:                                       ; preds = %if.end108
  %call115 = call i32 @receive_cb_reply(%struct.svc_sock* %2, %struct.svc_rqst* %rqstp)
  br label %if.end116

if.end116:                                        ; preds = %if.then114, %if.end108
  %len.0 = phi i32 [ %call115, %if.then114 ], [ %call27, %if.end108 ]
  %sk_datalen117 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 8
  store i32 0, i32* %sk_datalen117, align 8, !tbaa !756
  call void @svc_tcp_fragment_received(%struct.svc_sock* %2)
  %cmp118 = icmp slt i32 %len.0, 0
  br i1 %cmp118, label %error, label %if.end121

if.end121:                                        ; preds = %if.end116
  %sk_xprt122 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 0
  call void @svc_xprt_copy_addrs(%struct.svc_rqst* %rqstp, %struct.svc_xprt* %sk_xprt122)
  %sv_stats = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %3, i32 0, i32 1
  %24 = load %struct.svc_stat*, %struct.svc_stat** %sv_stats, align 8, !tbaa !670
  %tobool123 = icmp ne %struct.svc_stat* %24, null
  br i1 %tobool123, label %if.then124, label %if.end126

if.then124:                                       ; preds = %if.end121
  %sv_stats125 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %3, i32 0, i32 1
  %25 = load %struct.svc_stat*, %struct.svc_stat** %sv_stats125, align 8, !tbaa !670
  %nettcpcnt = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %25, i32 0, i32 3
  %26 = load i32, i32* %nettcpcnt, align 8, !tbaa !763
  %inc = add i32 %26, 1
  store i32 %inc, i32* %nettcpcnt, align 8, !tbaa !763
  br label %if.end126

if.end126:                                        ; preds = %if.then124, %if.end121
  %rq_arg127 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %len128 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg127, i32 0, i32 7
  %27 = load i32, i32* %len128, align 8, !tbaa !759
  br label %cleanup

error:                                            ; preds = %if.end116, %do.end
  %len.1 = phi i32 [ %call11, %do.end ], [ %len.0, %if.end116 ]
  %cmp129 = icmp ne i32 %len.1, -11
  br i1 %cmp129, label %err_delete, label %do.body133

do.body133:                                       ; preds = %error
  %28 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and134 = and i32 %28, 256
  %tobool135 = icmp ne i32 %and134, 0
  %lnot136 = xor i1 %tobool135, true
  %lnot138 = xor i1 %lnot136, true
  %lnot.ext139 = zext i1 %lnot138 to i32
  %conv140 = sext i32 %lnot.ext139 to i64
  %expval141 = call i64 @llvm.expect.i64(i64 %conv140, i64 0)
  %tobool142 = icmp ne i64 %expval141, 0
  br i1 %tobool142, label %if.then143, label %cleanup

if.then143:                                       ; preds = %do.body133
  %29 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

err_delete:                                       ; preds = %error, %if.end71, %if.then40
  %30 = call i32 (i8*, ...) @printk(i8* null)
  %sk_xprt152 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 0
  %xpt_flags153 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt152, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags153, i32 2, i64* %xpt_flags153) #7, !srcloc !752
  br label %cleanup

cleanup:                                          ; preds = %err_delete, %if.then143, %do.body133, %if.end126, %if.then60, %do.body50, %if.then49
  %retval.0 = phi i32 [ %27, %if.end126 ], [ 0, %if.then143 ], [ 0, %do.body133 ], [ 0, %if.then49 ], [ 0, %if.then60 ], [ 0, %do.body50 ], [ 0, %err_delete ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @svc_tcp_prep_reply_hdr(%struct.svc_rqst* %rqstp) #0 {
entry:
  %rq_res = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  call void @svc_putnl.632(%struct.iovec* %arrayidx, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_tcp_sendto(%struct.svc_rqst* %rqstp) #0 {
entry:
  %reclen = alloca i32, align 4
  %rq_res = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res, i32 0, i32 7
  %0 = load i32, i32* %len, align 8, !tbaa !152
  %sub = sub i32 %0, 4
  %or = or i32 -2147483648, %sub
  %call = call i32 @__fswab32.624(i32 %or) #3
  store i32 %call, i32* %reclen, align 4, !tbaa !49
  %cmp = icmp uge i64 4, 64
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  %1 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %2 = bitcast i32* %reclen to i8*
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = call i8* @__memcpy(i8* %1, i8* %2, i64 4)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 4, i32 1, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %rq_res5 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %call6 = call i32 @svc_sendto(%struct.svc_rqst* %rqstp, %struct.xdr_buf* %rq_res5)
  %len7 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res, i32 0, i32 7
  %3 = load i32, i32* %len7, align 8, !tbaa !152
  %cmp8 = icmp ne i32 %call6, %3
  br i1 %cmp8, label %if.then9, label %if.end15

if.then9:                                         ; preds = %if.end
  %4 = call i32 (i8*, ...) @printk(i8* null)
  %rq_xprt13 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %5 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt13, align 8, !tbaa !635
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %5, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 2, i64* %xpt_flags) #7, !srcloc !752
  %rq_xprt14 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %6 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt14, align 8, !tbaa !635
  call void @svc_xprt_enqueue(%struct.svc_xprt* %6)
  br label %if.end15

if.end15:                                         ; preds = %if.then9, %if.end
  %sent.0 = phi i32 [ -11, %if.then9 ], [ %call6, %if.end ]
  ret i32 %sent.0
}

; Function Attrs: nounwind uwtable
define internal void @svc_release_skb(%struct.svc_rqst* %rqstp) #0 {
entry:
  %rq_xprt_ctxt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 12
  %0 = load i8*, i8** %rq_xprt_ctxt, align 8, !tbaa !762
  %1 = bitcast i8* %0 to %struct.sk_buff*
  %tobool = icmp ne %struct.sk_buff* %1, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %rq_xprt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %2 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt, align 8, !tbaa !635
  %3 = bitcast %struct.svc_xprt* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.svc_sock*
  %rq_xprt_ctxt1 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 12
  store i8* null, i8** %rq_xprt_ctxt1, align 8, !tbaa !762
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %5, 256
  %tobool2 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then5, label %do.end

if.then5:                                         ; preds = %if.then
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then5, %if.then
  %sk_sk = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %4, i32 0, i32 2
  %7 = load %struct.sock*, %struct.sock** %sk_sk, align 8, !tbaa !372
  call void @skb_free_datagram_locked(%struct.sock* %7, %struct.sk_buff* %1)
  br label %if.end6

if.end6:                                          ; preds = %do.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_tcp_sock_detach(%struct.svc_xprt* %xprt) #0 {
entry:
  %0 = bitcast %struct.svc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.svc_sock*
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  call void @svc_sock_detach(%struct.svc_xprt* %xprt)
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  %4 = load volatile i64, i64* %xpt_flags, align 8, !tbaa !88
  %and.i = and i64 2048, %4
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool4 = icmp ne i32 %conv.i, 0
  br i1 %tobool4, label %if.end10, label %if.then8

if.then8:                                         ; preds = %do.end
  call void @svc_tcp_clear_pages(%struct.svc_sock* %1)
  %sk_sock = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 1
  %5 = load %struct.socket*, %struct.socket** %sk_sock, align 8, !tbaa !369
  %call9 = call i32 @kernel_sock_shutdown(%struct.socket* %5, i32 2)
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_sock_free(%struct.svc_xprt* %xprt) #0 {
entry:
  %0 = bitcast %struct.svc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.svc_sock*
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %sk_sock = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 1
  %4 = load %struct.socket*, %struct.socket** %sk_sock, align 8, !tbaa !369
  %file = getelementptr inbounds %struct.socket, %struct.socket* %4, i32 0, i32 4
  %5 = load %struct.file*, %struct.file** %file, align 8, !tbaa !742
  %tobool3 = icmp ne %struct.file* %5, null
  %sk_sock5 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 1
  %6 = load %struct.socket*, %struct.socket** %sk_sock5, align 8, !tbaa !369
  br i1 %tobool3, label %if.then4, label %if.else

if.then4:                                         ; preds = %do.end
  %file6 = getelementptr inbounds %struct.socket, %struct.socket* %6, i32 0, i32 4
  %7 = load %struct.file*, %struct.file** %file6, align 8, !tbaa !742
  call void @fput(%struct.file* %7)
  br label %if.end8

if.else:                                          ; preds = %do.end
  call void @sock_release(%struct.socket* %6)
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then4
  %8 = bitcast %struct.svc_sock* %1 to i8*
  call void @kfree(i8* %8)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_sock_detach(%struct.svc_xprt* %xprt) #0 {
entry:
  %0 = bitcast %struct.svc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.svc_sock*
  %sk_sk = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 2
  %2 = load %struct.sock*, %struct.sock** %sk_sk, align 8, !tbaa !372
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %3, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %sk_ostate = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 3
  %5 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_ostate, align 8, !tbaa !744
  %sk_state_change = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 56
  store void (%struct.sock*)* %5, void (%struct.sock*)** %sk_state_change, align 8, !tbaa !400
  %sk_odata = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 4
  %6 = load void (%struct.sock*, i32)*, void (%struct.sock*, i32)** %sk_odata, align 8, !tbaa !745
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 57
  store void (%struct.sock*, i32)* %6, void (%struct.sock*, i32)** %sk_data_ready, align 8, !tbaa !399
  %sk_owspace = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 5
  %7 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_owspace, align 8, !tbaa !746
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 58
  store void (%struct.sock*)* %7, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !401
  %call3 = call %struct.__wait_queue_head* @sk_sleep(%struct.sock* %2)
  %tobool4 = icmp ne %struct.__wait_queue_head* %call3, null
  br i1 %tobool4, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %do.end
  %call5 = call i32 @waitqueue_active.611(%struct.__wait_queue_head* %call3)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true
  call void @__wake_up(%struct.__wait_queue_head* %call3, i32 1, i32 1, i8* null)
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %land.lhs.true, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_tcp_clear_pages(%struct.svc_sock* %svsk) #0 {
entry:
  %sk_datalen = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 8
  %0 = load i32, i32* %sk_datalen, align 8, !tbaa !756
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %out, label %if.end

if.end:                                           ; preds = %entry
  %sk_datalen1 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 8
  %1 = load i32, i32* %sk_datalen1, align 8, !tbaa !756
  %conv = zext i32 %1 to i64
  %add = add i64 %conv, 4096
  %sub = sub i64 %add, 1
  %shr = lshr i64 %sub, 12
  %conv2 = trunc i64 %shr to i32
  br label %for.cond

for.cond:                                         ; preds = %do.end16, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %do.end16 ]
  %cmp3 = icmp ult i32 %i.0, %conv2
  br i1 %cmp3, label %do.body, label %out

do.body:                                          ; preds = %for.cond
  %sk_pages = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 9
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %sk_pages, i64 0, i64 %idxprom
  %2 = load %struct.page*, %struct.page** %arrayidx, align 8, !tbaa !28
  %cmp5 = icmp eq %struct.page* %2, null
  %lnot = xor i1 %cmp5, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv8 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body10, label %do.end16

do.body10:                                        ; preds = %do.body
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7.621, i32 0, i32 0), i32 920, i64 12) #7, !srcloc !764
  br label %do.body11

do.body11:                                        ; preds = %do.body11, %do.body10
  br label %do.body11

do.end16:                                         ; preds = %do.body
  %sk_pages17 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 9
  %idxprom18 = zext i32 %i.0 to i64
  %arrayidx19 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %sk_pages17, i64 0, i64 %idxprom18
  %3 = load %struct.page*, %struct.page** %arrayidx19, align 8, !tbaa !28
  call void @put_page(%struct.page* %3)
  %sk_pages20 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 9
  %idxprom21 = zext i32 %i.0 to i64
  %arrayidx22 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %sk_pages20, i64 0, i64 %idxprom21
  store %struct.page* null, %struct.page** %arrayidx22, align 8, !tbaa !28
  %inc = add i32 %i.0, 1
  br label %for.cond

out:                                              ; preds = %for.cond, %entry
  %sk_tcplen = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 7
  store i32 0, i32* %sk_tcplen, align 4, !tbaa !755
  %sk_datalen23 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 8
  store i32 0, i32* %sk_datalen23, align 8, !tbaa !756
  ret void
}

declare void @skb_free_datagram_locked(%struct.sock*, %struct.sk_buff*) #4

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__fswab32.624(i32 %val) #5 {
entry:
  %call = call i32 @__arch_swab32.631(i32 %val) #3
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_sendto(%struct.svc_rqst* %rqstp, %struct.xdr_buf* %xdr) #0 {
entry:
  %buffer = alloca %union.anon.75, align 8
  %buf = alloca [63 x i8], align 16
  %msg = alloca %struct.msghdr, align 8
  %rq_xprt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %0 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt, align 8, !tbaa !635
  %1 = bitcast %struct.svc_xprt* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.svc_sock*
  %sk_sock = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 1
  %3 = load %struct.socket*, %struct.socket** %sk_sock, align 8, !tbaa !369
  %hdr = bitcast %union.anon.75* %buffer to %struct.arch_uprobe_task*
  %rq_prot = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 27
  %4 = load i32, i32* %rq_prot, align 8, !tbaa !647
  %cmp = icmp eq i32 %4, 17
  br i1 %cmp, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %msg_name = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 0
  %rq_addr = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 3
  %5 = bitcast %struct.__kernel_sockaddr_storage* %rq_addr to i8*
  store i8* %5, i8** %msg_name, align 8, !tbaa !451
  %msg_namelen = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 1
  %rq_addrlen = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 4
  %6 = load i64, i64* %rq_addrlen, align 8, !tbaa !648
  %conv = trunc i64 %6 to i32
  store i32 %conv, i32* %msg_namelen, align 8, !tbaa !453
  %msg_iov = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 2
  store %struct.iovec* null, %struct.iovec** %msg_iov, align 8, !tbaa !454
  %msg_iovlen = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 3
  store i64 0, i64* %msg_iovlen, align 8, !tbaa !455
  %msg_control = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 4
  %7 = bitcast %struct.arch_uprobe_task* %hdr to i8*
  store i8* %7, i8** %msg_control, align 8, !tbaa !456
  %msg_controllen = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 5
  store i64 40, i64* %msg_controllen, align 8, !tbaa !457
  %msg_flags = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 6
  store i32 32768, i32* %msg_flags, align 8, !tbaa !458
  call void @svc_set_cmsg_data(%struct.svc_rqst* %rqstp, %struct.arch_uprobe_task* %hdr)
  %call = call i32 @sock_sendmsg(%struct.socket* %3, %struct.msghdr* %msg, i64 0)
  %cmp1 = icmp slt i32 %call, 0
  %. = select i1 %cmp1, i32 2, i32 0
  %Pivot = icmp slt i32 %., 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.then
  %SwitchLeaf2 = icmp eq i32 %., 2
  br i1 %SwitchLeaf2, label %do.body, label %cleanup22

LeafBlock:                                        ; preds = %if.then
  %SwitchLeaf = icmp eq i32 %., 0
  br i1 %SwitchLeaf, label %if.end4, label %cleanup22

if.end4:                                          ; preds = %LeafBlock, %entry
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 1
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  %8 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %9 = ptrtoint i8* %8 to i64
  %and = and i64 %9, 4095
  %rq_respages = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 19
  %10 = load %struct.page**, %struct.page*** %rq_respages, align 8, !tbaa !695
  %arrayidx5 = getelementptr inbounds %struct.page*, %struct.page** %10, i64 0
  %11 = load %struct.page*, %struct.page** %arrayidx5, align 8, !tbaa !28
  %rq_respages6 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 19
  %12 = load %struct.page**, %struct.page*** %rq_respages6, align 8, !tbaa !695
  %arrayidx7 = getelementptr inbounds %struct.page*, %struct.page** %12, i64 0
  %13 = load %struct.page*, %struct.page** %arrayidx7, align 8, !tbaa !28
  %call8 = call i32 @svc_send_common(%struct.socket* %3, %struct.xdr_buf* %xdr, %struct.page* %11, i64 0, %struct.page* %13, i64 %and)
  br label %do.body

do.body:                                          ; preds = %if.end4, %LeafBlock1
  %len.0 = phi i32 [ %call8, %if.end4 ], [ 0, %LeafBlock1 ]
  %14 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and9 = and i32 %14, 256
  %tobool = icmp ne i32 %and9, 0
  %lnot = xor i1 %tobool, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv11 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.then13, label %cleanup22

if.then13:                                        ; preds = %do.body
  %arraydecay = getelementptr inbounds [63 x i8], [63 x i8]* %buf, i32 0, i32 0
  %call19 = call i8* @svc_print_addr(%struct.svc_rqst* %rqstp, i8* %arraydecay, i64 63)
  %15 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup22

cleanup22:                                        ; preds = %if.then13, %do.body, %LeafBlock, %LeafBlock1
  %retval.0 = phi i32 [ %len.0, %if.then13 ], [ %len.0, %do.body ], [ undef, %LeafBlock1 ], [ undef, %LeafBlock ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @svc_set_cmsg_data(%struct.svc_rqst* %rqstp, %struct.arch_uprobe_task* %cmh) #0 {
entry:
  %rq_xprt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %0 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt, align 8, !tbaa !635
  %1 = bitcast %struct.svc_xprt* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.svc_sock*
  %sk_sk = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 2
  %3 = load %struct.sock*, %struct.sock** %sk_sk, align 8, !tbaa !372
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 0
  %skc_family = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 3
  %4 = load i16, i16* %skc_family, align 8, !tbaa !462
  %conv = zext i16 %4 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb3, label %sw.epilog

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %5 = bitcast %struct.arch_uprobe_task* %cmh to i8*
  %add.ptr1 = getelementptr inbounds i8, i8* %5, i64 16
  %6 = bitcast i8* %add.ptr1 to %struct.in_pktinfo*
  %cmsg_level = getelementptr inbounds %struct.arch_uprobe_task, %struct.arch_uprobe_task* %cmh, i32 0, i32 1
  store i32 0, i32* %cmsg_level, align 8, !tbaa !765
  %cmsg_type = getelementptr inbounds %struct.arch_uprobe_task, %struct.arch_uprobe_task* %cmh, i32 0, i32 2
  store i32 8, i32* %cmsg_type, align 4, !tbaa !767
  %ipi_ifindex = getelementptr inbounds %struct.in_pktinfo, %struct.in_pktinfo* %6, i32 0, i32 0
  store i32 0, i32* %ipi_ifindex, align 4, !tbaa !768
  %call = call %struct.sockaddr_in* @svc_daddr_in(%struct.svc_rqst* %rqstp)
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %call, i32 0, i32 2
  %s_addr = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %sin_addr, i32 0, i32 0
  %7 = load i32, i32* %s_addr, align 4, !tbaa !374
  %ipi_spec_dst = getelementptr inbounds %struct.in_pktinfo, %struct.in_pktinfo* %6, i32 0, i32 1
  %s_addr2 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %ipi_spec_dst, i32 0, i32 0
  store i32 %7, i32* %s_addr2, align 4, !tbaa !770
  %cmsg_len = getelementptr inbounds %struct.arch_uprobe_task, %struct.arch_uprobe_task* %cmh, i32 0, i32 0
  store i64 28, i64* %cmsg_len, align 8, !tbaa !771
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock1
  %8 = bitcast %struct.arch_uprobe_task* %cmh to i8*
  %add.ptr5 = getelementptr inbounds i8, i8* %8, i64 16
  %9 = bitcast i8* %add.ptr5 to %struct.in6_pktinfo*
  %call6 = call %struct.sockaddr_in6* @svc_daddr_in6(%struct.svc_rqst* %rqstp)
  %cmsg_level7 = getelementptr inbounds %struct.arch_uprobe_task, %struct.arch_uprobe_task* %cmh, i32 0, i32 1
  store i32 41, i32* %cmsg_level7, align 8, !tbaa !765
  %cmsg_type8 = getelementptr inbounds %struct.arch_uprobe_task, %struct.arch_uprobe_task* %cmh, i32 0, i32 2
  store i32 50, i32* %cmsg_type8, align 4, !tbaa !767
  %sin6_scope_id = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %call6, i32 0, i32 4
  %10 = load i32, i32* %sin6_scope_id, align 4, !tbaa !197
  %ipi6_ifindex = getelementptr inbounds %struct.in6_pktinfo, %struct.in6_pktinfo* %9, i32 0, i32 1
  store i32 %10, i32* %ipi6_ifindex, align 4, !tbaa !772
  %ipi6_addr = getelementptr inbounds %struct.in6_pktinfo, %struct.in6_pktinfo* %9, i32 0, i32 0
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %call6, i32 0, i32 3
  %11 = bitcast %struct.in6_addr* %ipi6_addr to i8*
  %12 = bitcast %struct.in6_addr* %sin6_addr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %12, i64 16, i32 4, i1 false), !tbaa.struct !774
  %cmsg_len9 = getelementptr inbounds %struct.arch_uprobe_task, %struct.arch_uprobe_task* %cmh, i32 0, i32 0
  store i64 36, i64* %cmsg_len9, align 8, !tbaa !771
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb3, %sw.bb, %LeafBlock, %LeafBlock1
  ret void
}

declare i32 @sock_sendmsg(%struct.socket*, %struct.msghdr*, i64) #4

; Function Attrs: nounwind uwtable
define i32 @svc_send_common(%struct.socket* %sock, %struct.xdr_buf* %xdr, %struct.page* %headpage, i64 %headoffset, %struct.page* %tailpage, i64 %tailoffset) #0 {
entry:
  %pages = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 2
  %0 = load %struct.page**, %struct.page*** %pages, align 8, !tbaa !354
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 3
  %1 = load i32, i32* %page_base, align 8, !tbaa !355
  %conv = zext i32 %1 to i64
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 4
  %2 = load i32, i32* %page_len, align 4, !tbaa !150
  %len1 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 7
  %3 = load i32, i32* %len1, align 8, !tbaa !152
  %conv2 = sext i32 %3 to i64
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %4 = load i64, i64* %iov_len, align 8, !tbaa !149
  %cmp = icmp eq i64 %conv2, %4
  %. = select i1 %cmp, i32 0, i32 32768
  %conv4 = trunc i64 %headoffset to i32
  %head5 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head5, i64 0, i64 0
  %iov_len7 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx6, i32 0, i32 1
  %5 = load i64, i64* %iov_len7, align 8, !tbaa !149
  %call = call i32 @kernel_sendpage(%struct.socket* %sock, %struct.page* %headpage, i32 %conv4, i64 %5, i32 %.)
  %conv8 = sext i32 %call to i64
  %head9 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 0
  %arrayidx10 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head9, i64 0, i64 0
  %iov_len11 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx10, i32 0, i32 1
  %6 = load i64, i64* %iov_len11, align 8, !tbaa !149
  %cmp12 = icmp ne i64 %conv8, %6
  br i1 %cmp12, label %out, label %if.end15

if.end15:                                         ; preds = %entry
  %head16 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 0
  %arrayidx17 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head16, i64 0, i64 0
  %iov_len18 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx17, i32 0, i32 1
  %7 = load i64, i64* %iov_len18, align 8, !tbaa !149
  %conv19 = sext i32 %3 to i64
  %sub = sub i64 %conv19, %7
  %conv20 = trunc i64 %sub to i32
  %cmp21 = icmp eq i32 %conv20, 0
  br i1 %cmp21, label %out, label %if.end24

if.end24:                                         ; preds = %if.end15
  %sub25 = sub i64 4096, %conv
  %conv26 = zext i32 %2 to i64
  %cmp27 = icmp ult i64 %sub25, %conv26
  %sub29 = sub i64 4096, %conv
  %conv30 = zext i32 %2 to i64
  %cond = select i1 %cmp27, i64 %sub29, i64 %conv30
  %conv31 = trunc i64 %cond to i32
  br label %while.cond

while.cond:                                       ; preds = %if.end48, %if.end24
  %size.0 = phi i32 [ %conv31, %if.end24 ], [ %conv59, %if.end48 ]
  %ppage.0 = phi %struct.page** [ %0, %if.end24 ], [ %incdec.ptr, %if.end48 ]
  %base.0 = phi i64 [ %conv, %if.end24 ], [ 0, %if.end48 ]
  %pglen.0 = phi i32 [ %2, %if.end24 ], [ %sub50, %if.end48 ]
  %flags.1 = phi i32 [ %., %if.end24 ], [ %.flags.1, %if.end48 ]
  %slen.0 = phi i32 [ %conv20, %if.end24 ], [ %sub49, %if.end48 ]
  %len.0 = phi i32 [ %call, %if.end24 ], [ %len.1, %if.end48 ]
  %cmp32 = icmp ugt i32 %pglen.0, 0
  br i1 %cmp32, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %cmp34 = icmp eq i32 %slen.0, %size.0
  %.flags.1 = select i1 %cmp34, i32 0, i32 %flags.1
  %8 = load %struct.page*, %struct.page** %ppage.0, align 8, !tbaa !28
  %conv38 = trunc i64 %base.0 to i32
  %conv39 = sext i32 %size.0 to i64
  %call40 = call i32 @kernel_sendpage(%struct.socket* %sock, %struct.page* %8, i32 %conv38, i64 %conv39, i32 %.flags.1)
  %cmp41 = icmp sgt i32 %call40, 0
  %add = add nsw i32 %len.0, %call40
  %len.1 = select i1 %cmp41, i32 %add, i32 %len.0
  %cmp45 = icmp ne i32 %call40, %size.0
  br i1 %cmp45, label %out, label %if.end48

if.end48:                                         ; preds = %while.body
  %sub49 = sub nsw i32 %slen.0, %size.0
  %sub50 = sub i32 %pglen.0, %size.0
  %conv51 = zext i32 %sub50 to i64
  %cmp52 = icmp ult i64 4096, %conv51
  %conv56 = zext i32 %sub50 to i64
  %cond58 = select i1 %cmp52, i64 4096, i64 %conv56
  %conv59 = trunc i64 %cond58 to i32
  %incdec.ptr = getelementptr inbounds %struct.page*, %struct.page** %ppage.0, i32 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 1
  %arrayidx60 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_len61 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx60, i32 0, i32 1
  %9 = load i64, i64* %iov_len61, align 8, !tbaa !149
  %tobool = icmp ne i64 %9, 0
  br i1 %tobool, label %if.then62, label %out

if.then62:                                        ; preds = %while.end
  %conv63 = trunc i64 %tailoffset to i32
  %tail64 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 1
  %arrayidx65 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail64, i64 0, i64 0
  %iov_len66 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx65, i32 0, i32 1
  %10 = load i64, i64* %iov_len66, align 8, !tbaa !149
  %call67 = call i32 @kernel_sendpage(%struct.socket* %sock, %struct.page* %tailpage, i32 %conv63, i64 %10, i32 0)
  %cmp68 = icmp sgt i32 %call67, 0
  %add71 = add nsw i32 %len.0, %call67
  %add71.len.0 = select i1 %cmp68, i32 %add71, i32 %len.0
  br label %out

out:                                              ; preds = %if.then62, %while.end, %while.body, %if.end15, %entry
  %len.4 = phi i32 [ %call, %entry ], [ %call, %if.end15 ], [ %len.1, %while.body ], [ %add71.len.0, %if.then62 ], [ %len.0, %while.end ]
  ret i32 %len.4
}

declare i32 @kernel_sendpage(%struct.socket*, %struct.page*, i32, i64, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr_in* @svc_daddr_in(%struct.svc_rqst* %rqst) #2 {
entry:
  %rq_daddr = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqst, i32 0, i32 5
  %0 = bitcast %struct.__kernel_sockaddr_storage* %rq_daddr to %struct.sockaddr_in*
  ret %struct.sockaddr_in* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr_in6* @svc_daddr_in6(%struct.svc_rqst* %rqst) #2 {
entry:
  %rq_daddr = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqst, i32 0, i32 5
  %0 = bitcast %struct.__kernel_sockaddr_storage* %rq_daddr to %struct.sockaddr_in6*
  ret %struct.sockaddr_in6* %0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__arch_swab32.631(i32 %val) #5 {
entry:
  %0 = call i32 asm "bswapl $0", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %val) #3, !srcloc !775
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @svc_putnl.632(%struct.iovec* %iov, i32 %val) #2 {
entry:
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  %0 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %1 = load i64, i64* %iov_len, align 8, !tbaa !149
  %add.ptr = getelementptr i8, i8* %0, i64 %1
  %2 = bitcast i8* %add.ptr to i32*
  %call = call i32 @__fswab32.624(i32 %val) #3
  store i32 %call, i32* %2, align 4, !tbaa !49
  %iov_len1 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %3 = load i64, i64* %iov_len1, align 8, !tbaa !149
  %add = add i64 %3, 4
  store i64 %add, i64* %iov_len1, align 8, !tbaa !149
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_tcp_recv_record(%struct.svc_sock* %svsk, %struct.svc_rqst* %rqstp) #0 {
entry:
  %iov = alloca %struct.iovec, align 8
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  %xpt_server = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt, i32 0, i32 6
  %0 = load %struct.svc_serv*, %struct.svc_serv** %xpt_server, align 8, !tbaa !751
  %sk_xprt1 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt1, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 3, i64* %xpt_flags) #7, !srcloc !750
  %sk_tcplen = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 7
  %1 = load i32, i32* %sk_tcplen, align 4, !tbaa !755
  %conv = zext i32 %1 to i64
  %cmp = icmp ult i64 %conv, 4
  br i1 %cmp, label %if.then, label %if.end53

if.then:                                          ; preds = %entry
  %sk_tcplen3 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 7
  %2 = load i32, i32* %sk_tcplen3, align 4, !tbaa !755
  %conv4 = zext i32 %2 to i64
  %sub = sub i64 4, %conv4
  %conv5 = trunc i64 %sub to i32
  %sk_reclen = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 6
  %3 = bitcast i32* %sk_reclen to i8*
  %sk_tcplen6 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 7
  %4 = load i32, i32* %sk_tcplen6, align 4, !tbaa !755
  %idx.ext = zext i32 %4 to i64
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 %idx.ext
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  store i8* %add.ptr, i8** %iov_base, align 8, !tbaa !147
  %conv7 = zext i32 %conv5 to i64
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  store i64 %conv7, i64* %iov_len, align 8, !tbaa !149
  %call = call i32 @svc_recvfrom(%struct.svc_rqst* %rqstp, %struct.iovec* %iov, i32 1, i32 %conv5)
  %cmp8 = icmp slt i32 %call, 0
  br i1 %cmp8, label %cleanup, label %if.end

if.end:                                           ; preds = %if.then
  %sk_tcplen11 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 7
  %5 = load i32, i32* %sk_tcplen11, align 4, !tbaa !755
  %add = add i32 %5, %call
  store i32 %add, i32* %sk_tcplen11, align 4, !tbaa !755
  %cmp12 = icmp ult i32 %call, %conv5
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %6, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot15 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot15 to i32
  %conv16 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool17 = icmp ne i64 %expval, 0
  br i1 %cmp12, label %do.body, label %do.body22

do.body:                                          ; preds = %if.end
  br i1 %tobool17, label %if.then18, label %cleanup

if.then18:                                        ; preds = %do.body
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

do.body22:                                        ; preds = %if.end
  br i1 %tobool17, label %if.then32, label %do.end37

if.then32:                                        ; preds = %do.body22
  %call33 = call i32 @svc_sock_reclen(%struct.svc_sock* %svsk)
  %8 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end37

do.end37:                                         ; preds = %if.then32, %do.body22
  %call38 = call i32 @svc_sock_reclen(%struct.svc_sock* %svsk)
  %sk_datalen = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 8
  %9 = load i32, i32* %sk_datalen, align 8, !tbaa !756
  %add39 = add i32 %call38, %9
  %sv_max_mesg = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 6
  %10 = load i32, i32* %sv_max_mesg, align 4, !tbaa !724
  %cmp40 = icmp ugt i32 %add39, %10
  br i1 %cmp40, label %do.body43, label %cleanup

do.body43:                                        ; preds = %do.end37
  %call44 = call i32 @net_ratelimit()
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %if.then46, label %cleanup

if.then46:                                        ; preds = %do.body43
  %call47 = call i32 @svc_sock_reclen(%struct.svc_sock* %svsk)
  %11 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then46, %do.body43, %do.end37, %if.then18, %do.body, %if.then
  %cleanup.dest.slot.0 = phi i32 [ 2, %if.then ], [ 1, %if.then18 ], [ 1, %do.body ], [ 9, %if.then46 ], [ 9, %do.body43 ], [ 0, %do.end37 ]
  %Pivot6 = icmp slt i32 %cleanup.dest.slot.0, 2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %cleanup
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 9
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %cleanup.dest.slot.0, 9
  br i1 %SwitchLeaf4, label %err_delete, label %cleanup72

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf2, label %do.body55, label %cleanup72

LeafBlock:                                        ; preds = %cleanup
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end53, label %cleanup72

if.end53:                                         ; preds = %LeafBlock, %entry
  %call54 = call i32 @svc_sock_reclen(%struct.svc_sock* %svsk)
  br label %cleanup72

do.body55:                                        ; preds = %LeafBlock1
  %12 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and56 = and i32 %12, 256
  %tobool57 = icmp ne i32 %and56, 0
  %lnot58 = xor i1 %tobool57, true
  %lnot60 = xor i1 %lnot58, true
  %lnot.ext61 = zext i1 %lnot60 to i32
  %conv62 = sext i32 %lnot.ext61 to i64
  %expval63 = call i64 @llvm.expect.i64(i64 %conv62, i64 0)
  %tobool64 = icmp ne i64 %expval63, 0
  br i1 %tobool64, label %if.then65, label %cleanup72

if.then65:                                        ; preds = %do.body55
  %13 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup72

err_delete:                                       ; preds = %LeafBlock3
  %sk_xprt70 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  %xpt_flags71 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt70, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags71, i32 2, i64* %xpt_flags71) #7, !srcloc !752
  br label %cleanup72

cleanup72:                                        ; preds = %err_delete, %if.then65, %do.body55, %if.end53, %LeafBlock, %LeafBlock1, %LeafBlock3
  %retval.1 = phi i32 [ %call54, %if.end53 ], [ -11, %err_delete ], [ %call, %if.then65 ], [ %call, %do.body55 ], [ -11, %LeafBlock3 ], [ -11, %LeafBlock1 ], [ -11, %LeafBlock ]
  ret i32 %retval.1
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_tcp_restore_pages(%struct.svc_sock* %svsk, %struct.svc_rqst* %rqstp) #0 {
entry:
  %sk_datalen = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 8
  %0 = load i32, i32* %sk_datalen, align 8, !tbaa !756
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %sk_datalen1 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 8
  %1 = load i32, i32* %sk_datalen1, align 8, !tbaa !756
  %conv = zext i32 %1 to i64
  %add = add i64 %conv, 4096
  %sub = sub i64 %add, 1
  %shr = lshr i64 %sub, 12
  %conv2 = trunc i64 %shr to i32
  br label %for.cond

for.cond:                                         ; preds = %do.end25, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %do.end25 ]
  %cmp3 = icmp ult i32 %i.0, %conv2
  %rq_pages = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages, i64 0, i64 %idxprom
  %2 = load %struct.page*, %struct.page** %arrayidx, align 8, !tbaa !28
  %cmp5 = icmp ne %struct.page* %2, null
  br i1 %cmp5, label %if.then7, label %do.body

if.then7:                                         ; preds = %for.body
  %rq_pages8 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %idxprom9 = zext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages8, i64 0, i64 %idxprom9
  %3 = load %struct.page*, %struct.page** %arrayidx10, align 8, !tbaa !28
  call void @put_page(%struct.page* %3)
  br label %do.body

do.body:                                          ; preds = %if.then7, %for.body
  %sk_pages = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 9
  %idxprom12 = zext i32 %i.0 to i64
  %arrayidx13 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %sk_pages, i64 0, i64 %idxprom12
  %4 = load %struct.page*, %struct.page** %arrayidx13, align 8, !tbaa !28
  %cmp14 = icmp eq %struct.page* %4, null
  %lnot = xor i1 %cmp14, true
  %lnot16 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot16 to i32
  %conv17 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv17, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body19, label %do.end25

do.body19:                                        ; preds = %do.body
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7.621, i32 0, i32 0), i32 889, i64 12) #7, !srcloc !776
  br label %do.body20

do.body20:                                        ; preds = %do.body20, %do.body19
  br label %do.body20

do.end25:                                         ; preds = %do.body
  %sk_pages26 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 9
  %idxprom27 = zext i32 %i.0 to i64
  %arrayidx28 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %sk_pages26, i64 0, i64 %idxprom27
  %5 = load %struct.page*, %struct.page** %arrayidx28, align 8, !tbaa !28
  %rq_pages29 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %idxprom30 = zext i32 %i.0 to i64
  %arrayidx31 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages29, i64 0, i64 %idxprom30
  store %struct.page* %5, %struct.page** %arrayidx31, align 8, !tbaa !28
  %sk_pages32 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 9
  %idxprom33 = zext i32 %i.0 to i64
  %arrayidx34 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %sk_pages32, i64 0, i64 %idxprom33
  store %struct.page* null, %struct.page** %arrayidx34, align 8, !tbaa !28
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %arrayidx36 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages, i64 0, i64 0
  %6 = load %struct.page*, %struct.page** %arrayidx36, align 8, !tbaa !28
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %6 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %7 = inttoptr i64 %add.i to i8*
  %rq_arg = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 0
  %arrayidx37 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx37, i32 0, i32 0
  store i8* %7, i8** %iov_base, align 8, !tbaa !147
  br label %cleanup

cleanup:                                          ; preds = %for.end, %entry
  %retval.0 = phi i32 [ %1, %for.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @svc_sock_reclen(%struct.svc_sock* %svsk) #2 {
entry:
  %sk_reclen = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 6
  %0 = load i32, i32* %sk_reclen, align 8, !tbaa !754
  %call = call i32 @__fswab32.624(i32 %0) #3
  %and = and i32 %call, 2147483647
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal i32 @copy_pages_to_kvecs(%struct.iovec* %vec, %struct.page** %pages, i32 %len) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %while.body ]
  %t.0 = phi i32 [ 0, %entry ], [ %conv5, %while.body ]
  %cmp = icmp slt i32 %t.0, %len
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.page*, %struct.page** %pages, i64 %idxprom
  %0 = load %struct.page*, %struct.page** %arrayidx, align 8, !tbaa !28
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %0 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %1 = inttoptr i64 %add.i to i8*
  %idxprom1 = sext i32 %i.0 to i64
  %arrayidx2 = getelementptr inbounds %struct.iovec, %struct.iovec* %vec, i64 %idxprom1
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx2, i32 0, i32 0
  store i8* %1, i8** %iov_base, align 8, !tbaa !147
  %idxprom3 = sext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds %struct.iovec, %struct.iovec* %vec, i64 %idxprom3
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx4, i32 0, i32 1
  store i64 4096, i64* %iov_len, align 8, !tbaa !149
  %inc = add nsw i32 %i.0, 1
  %conv = sext i32 %t.0 to i64
  %add = add i64 %conv, 4096
  %conv5 = trunc i64 %add to i32
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret i32 %i.0
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_partial_recvfrom(%struct.svc_rqst* %rqstp, %struct.iovec* %iov, i32 %nr, i32 %buflen, i32 %base) #0 {
entry:
  %cmp = icmp eq i32 %base, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @svc_recvfrom(%struct.svc_rqst* %rqstp, %struct.iovec* %iov, i32 %nr, i32 %buflen)
  br label %cleanup

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %if.end5, %if.end
  %base.addr.0 = phi i32 [ %base, %if.end ], [ %conv10, %if.end5 ]
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %if.end5 ]
  %cmp1 = icmp ult i32 %i.0, %nr
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 %idxprom
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %0 = load i64, i64* %iov_len, align 8, !tbaa !149
  %conv = zext i32 %base.addr.0 to i64
  %cmp2 = icmp ugt i64 %0, %conv
  br i1 %cmp2, label %for.end, label %if.end5

if.end5:                                          ; preds = %for.body
  %idxprom6 = zext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 %idxprom6
  %iov_len8 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx7, i32 0, i32 1
  %1 = load i64, i64* %iov_len8, align 8, !tbaa !149
  %conv9 = zext i32 %base.addr.0 to i64
  %sub = sub i64 %conv9, %1
  %conv10 = trunc i64 %sub to i32
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %idxprom11 = zext i32 %i.0 to i64
  %arrayidx12 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 %idxprom11
  %iov_len13 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx12, i32 0, i32 1
  %2 = load i64, i64* %iov_len13, align 8, !tbaa !149
  %idxprom14 = zext i32 %i.0 to i64
  %arrayidx15 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 %idxprom14
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx15, i32 0, i32 0
  %3 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %conv16 = zext i32 %base.addr.0 to i64
  %idxprom17 = zext i32 %i.0 to i64
  %arrayidx18 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 %idxprom17
  %iov_len19 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx18, i32 0, i32 1
  %4 = load i64, i64* %iov_len19, align 8, !tbaa !149
  %sub20 = sub i64 %4, %conv16
  store i64 %sub20, i64* %iov_len19, align 8, !tbaa !149
  %idxprom21 = zext i32 %i.0 to i64
  %arrayidx22 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 %idxprom21
  %iov_base23 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx22, i32 0, i32 0
  %5 = load i8*, i8** %iov_base23, align 8, !tbaa !147
  %idx.ext = zext i32 %base.addr.0 to i64
  %add.ptr = getelementptr i8, i8* %5, i64 %idx.ext
  store i8* %add.ptr, i8** %iov_base23, align 8, !tbaa !147
  %idxprom24 = zext i32 %i.0 to i64
  %arrayidx25 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 %idxprom24
  %sub26 = sub i32 %nr, %i.0
  %call27 = call i32 @svc_recvfrom(%struct.svc_rqst* %rqstp, %struct.iovec* %arrayidx25, i32 %sub26, i32 %buflen)
  %idxprom28 = zext i32 %i.0 to i64
  %arrayidx29 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 %idxprom28
  %iov_len30 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx29, i32 0, i32 1
  store i64 %2, i64* %iov_len30, align 8, !tbaa !149
  %idxprom31 = zext i32 %i.0 to i64
  %arrayidx32 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i64 %idxprom31
  %iov_base33 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx32, i32 0, i32 0
  store i8* %3, i8** %iov_base33, align 8, !tbaa !147
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %call27, %for.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @svc_sock_final_rec(%struct.svc_sock* %svsk) #2 {
entry:
  %sk_reclen = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 6
  %0 = load i32, i32* %sk_reclen, align 8, !tbaa !754
  %call = call i32 @__fswab32.624(i32 %0) #3
  %and = and i32 %call, -2147483648
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal void @svc_tcp_save_pages(%struct.svc_sock* %svsk, %struct.svc_rqst* %rqstp) #0 {
entry:
  %sk_datalen = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 8
  %0 = load i32, i32* %sk_datalen, align 8, !tbaa !756
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %sk_datalen1 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 8
  %1 = load i32, i32* %sk_datalen1, align 8, !tbaa !756
  %conv = zext i32 %1 to i64
  %add = add i64 %conv, 4096
  %sub = sub i64 %add, 1
  %shr = lshr i64 %sub, 12
  %conv2 = trunc i64 %shr to i32
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %cmp3 = icmp ult i32 %i.0, %conv2
  br i1 %cmp3, label %for.body, label %cleanup.cont

for.body:                                         ; preds = %for.cond
  %rq_pages = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages, i64 0, i64 %idxprom
  %2 = load %struct.page*, %struct.page** %arrayidx, align 8, !tbaa !28
  %sk_pages = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 9
  %idxprom5 = zext i32 %i.0 to i64
  %arrayidx6 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %sk_pages, i64 0, i64 %idxprom5
  store %struct.page* %2, %struct.page** %arrayidx6, align 8, !tbaa !28
  %rq_pages7 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %idxprom8 = zext i32 %i.0 to i64
  %arrayidx9 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages7, i64 0, i64 %idxprom8
  store %struct.page* null, %struct.page** %arrayidx9, align 8, !tbaa !28
  %inc = add i32 %i.0, 1
  br label %for.cond

cleanup.cont:                                     ; preds = %for.cond, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_tcp_fragment_received(%struct.svc_sock* %svsk) #0 {
entry:
  %call = call i32 @svc_recv_available(%struct.svc_sock* %svsk)
  %conv = sext i32 %call to i64
  %cmp = icmp ugt i64 %conv, 4
  br i1 %cmp, label %if.then, label %do.body

if.then:                                          ; preds = %entry
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 3, i64* %xpt_flags) #7, !srcloc !752
  br label %do.body

do.body:                                          ; preds = %if.then, %entry
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv3 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then5, label %do.end

if.then5:                                         ; preds = %do.body
  %call6 = call i32 @svc_sock_final_rec(%struct.svc_sock* %svsk)
  %call8 = call i32 @svc_sock_reclen(%struct.svc_sock* %svsk)
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then5, %do.body
  %sk_tcplen = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 7
  store i32 0, i32* %sk_tcplen, align 4, !tbaa !755
  %sk_reclen = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 6
  store i32 0, i32* %sk_reclen, align 8, !tbaa !754
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @receive_cb_reply(%struct.svc_sock* %svsk, %struct.svc_rqst* %rqstp) #0 {
entry:
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 0
  %xpt_bc_xprt = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt, i32 0, i32 19
  %0 = load %struct.rpc_xprt*, %struct.rpc_xprt** %xpt_bc_xprt, align 8, !tbaa !777
  %rq_arg = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  %1 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %2 = bitcast i8* %1 to i32*
  %3 = load i32, i32* %2, align 4, !tbaa !49
  %tobool = icmp ne %struct.rpc_xprt* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call %struct.rpc_rqst* @xprt_lookup_rqst(%struct.rpc_xprt* %0, i32 %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %req.0 = phi %struct.rpc_rqst* [ %call, %if.then ], [ null, %entry ]
  %tobool1 = icmp ne %struct.rpc_rqst* %req.0, null
  br i1 %tobool1, label %if.end5, label %if.then2

if.then2:                                         ; preds = %if.end
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end5:                                          ; preds = %if.end
  %cmp = icmp uge i64 64, 64
  %rq_private_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req.0, i32 0, i32 17
  %5 = bitcast %struct.xdr_buf* %rq_private_buf to i8*
  %rq_rcv_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req.0, i32 0, i32 2
  %6 = bitcast %struct.xdr_buf* %rq_rcv_buf to i8*
  br i1 %cmp, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end5
  %call7 = call i8* @__memcpy(i8* %5, i8* %6, i64 64)
  br label %if.end10

if.else:                                          ; preds = %if.end5
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 64, i32 8, i1 false)
  br label %if.end10

if.end10:                                         ; preds = %if.else, %if.then6
  %rq_private_buf11 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req.0, i32 0, i32 17
  %head12 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf11, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head12, i64 0, i64 0
  %rq_arg14 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %head15 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg14, i32 0, i32 0
  %arrayidx16 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head15, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx13, i32 0, i32 1
  %7 = load i64, i64* %iov_len, align 8, !tbaa !149
  %iov_len17 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx16, i32 0, i32 1
  %8 = load i64, i64* %iov_len17, align 8, !tbaa !149
  %cmp18 = icmp ult i64 %7, %8
  br i1 %cmp18, label %cleanup, label %if.end20

if.end20:                                         ; preds = %if.end10
  %iov_len22 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx16, i32 0, i32 1
  %9 = load i64, i64* %iov_len22, align 8, !tbaa !149
  %iov_base24 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx13, i32 0, i32 0
  %10 = load i8*, i8** %iov_base24, align 8, !tbaa !147
  %iov_base25 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx16, i32 0, i32 0
  %11 = load i8*, i8** %iov_base25, align 8, !tbaa !147
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 %9, i32 1, i1 false)
  %rq_task = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req.0, i32 0, i32 3
  %12 = load %struct.rpc_task*, %struct.rpc_task** %rq_task, align 8, !tbaa !280
  %rq_arg27 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg27, i32 0, i32 7
  %13 = load i32, i32* %len, align 8, !tbaa !759
  call void @xprt_complete_rqst(%struct.rpc_task* %12, i32 %13)
  %rq_arg28 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %len29 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg28, i32 0, i32 7
  store i32 0, i32* %len29, align 8, !tbaa !759
  br label %cleanup

cleanup:                                          ; preds = %if.end20, %if.end10, %if.then2
  %retval.0 = phi i32 [ 0, %if.end20 ], [ -11, %if.then2 ], [ -11, %if.end10 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_recv_available(%struct.svc_sock* %svsk) #0 {
entry:
  %avail = alloca i32, align 4
  %sk_sock = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %svsk, i32 0, i32 1
  %0 = load %struct.socket*, %struct.socket** %sk_sock, align 8, !tbaa !369
  %1 = ptrtoint i32* %avail to i64
  %call = call i32 @kernel_sock_ioctl(%struct.socket* %0, i32 21531, i64 %1)
  %cmp = icmp sge i32 %call, 0
  %2 = load i32, i32* %avail, align 4
  %cond = select i1 %cmp, i32 %2, i32 %call
  ret i32 %cond
}

declare i32 @kernel_sock_ioctl(%struct.socket*, i32, i64) #4

; Function Attrs: nounwind uwtable
define internal i32 @svc_recvfrom(%struct.svc_rqst* %rqstp, %struct.iovec* %iov, i32 %nr, i32 %buflen) #0 {
entry:
  %msg = alloca %struct.msghdr, align 8
  %rq_xprt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %0 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt, align 8, !tbaa !635
  %1 = bitcast %struct.svc_xprt* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.svc_sock*
  %3 = bitcast %struct.msghdr* %msg to i8*
  call void @llvm.memset.p0i8.i64(i8* %3, i8 0, i64 56, i32 8, i1 false)
  %4 = bitcast i8* %3 to %struct.msghdr*
  %5 = getelementptr %struct.msghdr, %struct.msghdr* %4, i32 0, i32 6
  store i32 64, i32* %5
  %rq_xprt_hlen = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 15
  store i64 0, i64* %rq_xprt_hlen, align 8, !tbaa !778
  %sk_sock = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 1
  %6 = load %struct.socket*, %struct.socket** %sk_sock, align 8, !tbaa !369
  %conv = sext i32 %nr to i64
  %conv1 = sext i32 %buflen to i64
  %msg_flags = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 6
  %7 = load i32, i32* %msg_flags, align 8, !tbaa !458
  %call = call i32 @kernel_recvmsg(%struct.socket* %6, %struct.msghdr* %msg, %struct.iovec* %iov, i64 %conv, i64 %conv1, i32 %7)
  %8 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %8, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv3 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %9 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  ret i32 %call
}

declare i32 @kernel_recvmsg(%struct.socket*, %struct.msghdr*, %struct.iovec*, i64, i64, i32) #4

declare i32 @net_ratelimit() #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read.647(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !49
  ret i32 %0
}

declare i32 @kernel_accept(%struct.socket*, %struct.socket**, i32) #4

declare i32 @kernel_getpeername(%struct.socket*, %struct.sockaddr*, i32*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @__svc_print_addr(%struct.sockaddr* %addr, i8* %buf, i64 %len) #2 {
entry:
  %0 = bitcast %struct.sockaddr* %addr to %struct.sockaddr_in*
  %1 = bitcast %struct.sockaddr* %addr to %struct.sockaddr_in6*
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %addr, i32 0, i32 0
  %2 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %2 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb3, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %0, i32 0, i32 2
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %0, i32 0, i32 1
  %3 = load i16, i16* %sin_port, align 2, !tbaa !191
  %call = call zeroext i16 @__fswab16.600(i16 zeroext %3) #3
  %conv1 = zext i16 %call to i32
  %call2 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 %len, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.24.1235, i32 0, i32 0), %struct.atomic_t* %sin_addr, i32 %conv1)
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock1
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %1, i32 0, i32 3
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %1, i32 0, i32 1
  %4 = load i16, i16* %sin6_port, align 2, !tbaa !194
  %call4 = call zeroext i16 @__fswab16.600(i16 zeroext %4) #3
  %conv5 = zext i16 %call4 to i32
  %call6 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 %len, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.25.1236, i32 0, i32 0), %struct.in6_addr* %sin6_addr, i32 %conv5)
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %sa_family7 = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %addr, i32 0, i32 0
  %5 = load i16, i16* %sa_family7, align 2, !tbaa !189
  %conv8 = zext i16 %5 to i32
  %call9 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 %len, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.26.1237, i32 0, i32 0), i32 %conv8)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @svc_xprt_set_remote(%struct.svc_xprt* %xprt, %struct.sockaddr* %sa, i64 %salen) #2 {
entry:
  %xpt_remote = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 14
  %0 = bitcast %struct.__kernel_sockaddr_storage* %xpt_remote to i8*
  %1 = bitcast %struct.sockaddr* %sa to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 %salen, i32 2, i1 false)
  %xpt_remotelen = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 15
  store i64 %salen, i64* %xpt_remotelen, align 8, !tbaa !779
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.svc_xprt* @svc_create_socket(%struct.svc_serv* %serv, i32 %protocol, %struct.net* %net, %struct.sockaddr* %sin, i32 %len, i32 %flags) #0 {
entry:
  %sock = alloca %struct.socket*, align 8
  %addr = alloca %struct.__kernel_sockaddr_storage, align 8
  %newlen = alloca i32, align 4
  %val = alloca i32, align 4
  %buf = alloca [63 x i8], align 16
  %0 = bitcast %struct.__kernel_sockaddr_storage* %addr to %struct.sockaddr*
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [63 x i8], [63 x i8]* %buf, i32 0, i32 0
  call void @__svc_print_addr(%struct.sockaddr* %sin, i8* %arraydecay, i64 63)
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  switch i32 %protocol, label %if.then7 [
    i32 17, label %if.end10
    i32 6, label %if.end10
  ]

if.then7:                                         ; preds = %do.end
  %3 = call i32 (i8*, ...) @printk(i8* null)
  %call9 = call i8* @ERR_PTR.598(i64 -22)
  %4 = bitcast i8* %call9 to %struct.svc_xprt*
  br label %cleanup

if.end10:                                         ; preds = %do.end, %do.end
  %cmp11 = icmp eq i32 %protocol, 17
  %cond = select i1 %cmp11, i32 2, i32 1
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sin, i32 0, i32 0
  %5 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv13 = zext i16 %5 to i32
  %Pivot = icmp slt i32 %conv13, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end10
  %SwitchLeaf2 = icmp eq i32 %conv13, 10
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %if.end10
  %SwitchLeaf = icmp eq i32 %conv13, 2
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %call15 = call i8* @ERR_PTR.598(i64 -22)
  %6 = bitcast i8* %call15 to %struct.svc_xprt*
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1
  %family.0 = phi i32 [ 10, %LeafBlock1 ], [ 2, %LeafBlock ]
  %call16 = call i32 @__sock_create(%struct.net* %net, i32 %family.0, i32 %cond, i32 %protocol, %struct.socket** %sock, i32 1)
  %cmp17 = icmp slt i32 %call16, 0
  br i1 %cmp17, label %if.then19, label %if.end22

if.then19:                                        ; preds = %sw.epilog
  %conv20 = sext i32 %call16 to i64
  %call21 = call i8* @ERR_PTR.598(i64 %conv20)
  %7 = bitcast i8* %call21 to %struct.svc_xprt*
  br label %cleanup

if.end22:                                         ; preds = %sw.epilog
  %8 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  call void @svc_reclassify_socket(%struct.socket* %8)
  store i32 1, i32* %val, align 4, !tbaa !49
  %cmp23 = icmp eq i32 %family.0, 10
  br i1 %cmp23, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.end22
  %9 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  %10 = bitcast i32* %val to i8*
  %call26 = call i32 @kernel_setsockopt(%struct.socket* %9, i32 41, i32 26, i8* %10, i32 4)
  br label %if.end27

if.end27:                                         ; preds = %if.then25, %if.end22
  %cmp28 = icmp eq i32 %cond, 1
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end27
  %11 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  %sk = getelementptr inbounds %struct.socket, %struct.socket* %11, i32 0, i32 5
  %12 = load %struct.sock*, %struct.sock** %sk, align 8, !tbaa !387
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %12, i32 0, i32 0
  %skc_reuse = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 5
  %bf.load = load i8, i8* %skc_reuse, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %skc_reuse, align 1
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %if.end27
  %13 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  %call32 = call i32 @kernel_bind(%struct.socket* %13, %struct.sockaddr* %sin, i32 %len)
  %cmp33 = icmp slt i32 %call32, 0
  br i1 %cmp33, label %do.body59, label %if.end36

if.end36:                                         ; preds = %if.end31
  store i32 %len, i32* %newlen, align 4, !tbaa !49
  %14 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  %call37 = call i32 @kernel_getsockname(%struct.socket* %14, %struct.sockaddr* %0, i32* %newlen)
  %cmp38 = icmp slt i32 %call37, 0
  br i1 %cmp38, label %do.body59, label %if.end41

if.end41:                                         ; preds = %if.end36
  %cmp42 = icmp eq i32 %protocol, 6
  br i1 %cmp42, label %if.then44, label %if.end50

if.then44:                                        ; preds = %if.end41
  %15 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  %call45 = call i32 @kernel_listen(%struct.socket* %15, i32 64)
  %cmp46 = icmp slt i32 %call45, 0
  br i1 %cmp46, label %do.body59, label %if.end50

if.end50:                                         ; preds = %if.then44, %if.end41
  %16 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  %call51 = call %struct.svc_sock* @svc_setup_socket(%struct.svc_serv* %serv, %struct.socket* %16, i32 %flags)
  %17 = bitcast %struct.svc_sock* %call51 to i8*
  %call52 = call i64 @IS_ERR.589(i8* %17)
  %tobool53 = icmp ne i64 %call52, 0
  br i1 %tobool53, label %if.then54, label %if.end57

if.then54:                                        ; preds = %if.end50
  %18 = bitcast %struct.svc_sock* %call51 to i8*
  %call55 = call i64 @PTR_ERR.590(i8* %18)
  %conv56 = trunc i64 %call55 to i32
  br label %do.body59

if.end57:                                         ; preds = %if.end50
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %call51, i32 0, i32 0
  %19 = load i32, i32* %newlen, align 4, !tbaa !49
  %conv58 = sext i32 %19 to i64
  call void @svc_xprt_set_local(%struct.svc_xprt* %sk_xprt, %struct.sockaddr* %0, i64 %conv58)
  %20 = bitcast %struct.svc_sock* %call51 to %struct.svc_xprt*
  br label %cleanup

do.body59:                                        ; preds = %if.then54, %if.then44, %if.end36, %if.end31
  %error.0 = phi i32 [ %conv56, %if.then54 ], [ %call32, %if.end31 ], [ %call37, %if.end36 ], [ %call45, %if.then44 ]
  %21 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and60 = and i32 %21, 256
  %tobool61 = icmp ne i32 %and60, 0
  %lnot62 = xor i1 %tobool61, true
  %lnot64 = xor i1 %lnot62, true
  %lnot.ext65 = zext i1 %lnot64 to i32
  %conv66 = sext i32 %lnot.ext65 to i64
  %expval67 = call i64 @llvm.expect.i64(i64 %conv66, i64 0)
  %tobool68 = icmp ne i64 %expval67, 0
  br i1 %tobool68, label %if.then69, label %do.end73

if.then69:                                        ; preds = %do.body59
  %22 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end73

do.end73:                                         ; preds = %if.then69, %do.body59
  %23 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !28
  call void @sock_release(%struct.socket* %23)
  %conv74 = sext i32 %error.0 to i64
  %call75 = call i8* @ERR_PTR.598(i64 %conv74)
  %24 = bitcast i8* %call75 to %struct.svc_xprt*
  br label %cleanup

cleanup:                                          ; preds = %do.end73, %if.end57, %if.then19, %sw.default, %if.then7
  %retval.0 = phi %struct.svc_xprt* [ %4, %if.then7 ], [ %7, %if.then19 ], [ %24, %do.end73 ], [ %20, %if.end57 ], [ %6, %sw.default ]
  ret %struct.svc_xprt* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @svc_reclassify_socket(%struct.socket* %sock) #0 {
entry:
  %sk1 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %0 = load %struct.sock*, %struct.sock** %sk1, align 8, !tbaa !387
  %sk_lock = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %owned = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock, i32 0, i32 1
  %1 = load i32, i32* %owned, align 8, !tbaa !444
  %tobool = icmp ne i32 %1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end35

if.then:                                          ; preds = %entry
  %2 = load i8, i8* @svc_reclassify_socket.__warned, align 1, !tbaa !29, !range !31
  %tobool9 = trunc i8 %2 to i1
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %tobool16 = icmp ne i32 %lnot.ext15, 0
  %lnot17 = xor i1 %tobool16, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool23 = icmp ne i64 %expval22, 0
  br i1 %tobool23, label %if.then24, label %if.end

if.then24:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7.621, i32 0, i32 0), i32 88)
  br label %if.end

if.end:                                           ; preds = %if.then24, %if.then
  %tobool25 = icmp ne i32 %lnot.ext15, 0
  %lnot26 = xor i1 %tobool25, true
  %lnot28 = xor i1 %lnot26, true
  %lnot.ext29 = zext i1 %lnot28 to i32
  %conv30 = sext i32 %lnot.ext29 to i64
  %expval31 = call i64 @llvm.expect.i64(i64 %conv30, i64 0)
  %tobool32 = icmp ne i64 %expval31, 0
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %if.end
  store i8 1, i8* @svc_reclassify_socket.__warned, align 1, !tbaa !29
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %if.end, %entry
  %sk_lock44 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %owned45 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock44, i32 0, i32 1
  %3 = load i32, i32* %owned45, align 8, !tbaa !444
  %tobool46 = icmp ne i32 %3, 0
  br i1 %tobool46, label %cleanup.cont, label %if.end48

if.end48:                                         ; preds = %if.end35
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 0
  %skc_family = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 3
  %4 = load i16, i16* %skc_family, align 8, !tbaa !462
  %conv49 = zext i16 %4 to i32
  %Pivot = icmp slt i32 %conv49, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end48
  %SwitchLeaf2 = icmp eq i32 %conv49, 10
  br i1 %SwitchLeaf2, label %do.body71, label %do.body99

LeafBlock:                                        ; preds = %if.end48
  %SwitchLeaf = icmp eq i32 %conv49, 2
  br i1 %SwitchLeaf, label %do.body, label %do.body99

do.body:                                          ; preds = %LeafBlock
  %sk_lock50 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %owned51 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock50, i32 0, i32 1
  store i32 0, i32* %owned51, align 8, !tbaa !444
  %sk_lock53 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %wq = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock53, i32 0, i32 2
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wq, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.8.661, i32 0, i32 0), %struct.lock_class_key* @svc_reclassify_socket.__key)
  call void @spinlock_check.662()
  %sk_lock57 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %slock58 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock57, i32 0, i32 0
  %5 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock58, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %5 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10.663, i32 0, i32 0), %struct.lock_class_key* @svc_reclassify_socket.__key.9)
  %sk_lock63 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %6 = bitcast %struct.socket_lock_t* %sk_lock63 to i8*
  call void @debug_check_no_locks_freed(i8* %6, i64 216)
  %sk_lock64 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %slock65 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock64, i32 0, i32 0
  %7 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock65, i32 0, i32 0
  %8 = bitcast %union.anon.11* %7 to %struct.anon.2*
  %dep_map = getelementptr inbounds %struct.anon.2, %struct.anon.2* %8, i32 0, i32 1
  call void @lockdep_init_map(%struct.lockdep_map* %dep_map, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.11.664, i32 0, i32 0), %struct.lock_class_key* getelementptr inbounds ([2 x %struct.lock_class_key], [2 x %struct.lock_class_key]* @svc_slock_key, i64 0, i64 0), i32 0)
  %sk_lock66 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %dep_map67 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock66, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %dep_map67, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.12.665, i32 0, i32 0), %struct.lock_class_key* getelementptr inbounds ([2 x %struct.lock_class_key], [2 x %struct.lock_class_key]* @svc_key, i64 0, i64 0), i32 0)
  br label %cleanup.cont

do.body71:                                        ; preds = %LeafBlock1
  %sk_lock72 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %owned73 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock72, i32 0, i32 1
  store i32 0, i32* %owned73, align 8, !tbaa !444
  %sk_lock75 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %wq76 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock75, i32 0, i32 2
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wq76, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.8.661, i32 0, i32 0), %struct.lock_class_key* @svc_reclassify_socket.__key.13)
  call void @spinlock_check.662()
  %sk_lock84 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %slock85 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock84, i32 0, i32 0
  %9 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock85, i32 0, i32 0
  %rlock86 = bitcast %union.anon.11* %9 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock86, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.10.663, i32 0, i32 0), %struct.lock_class_key* @svc_reclassify_socket.__key.14)
  %sk_lock91 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %10 = bitcast %struct.socket_lock_t* %sk_lock91 to i8*
  call void @debug_check_no_locks_freed(i8* %10, i64 216)
  %sk_lock92 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %slock93 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock92, i32 0, i32 0
  %11 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock93, i32 0, i32 0
  %12 = bitcast %union.anon.11* %11 to %struct.anon.2*
  %dep_map94 = getelementptr inbounds %struct.anon.2, %struct.anon.2* %12, i32 0, i32 1
  call void @lockdep_init_map(%struct.lockdep_map* %dep_map94, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.15.666, i32 0, i32 0), %struct.lock_class_key* getelementptr inbounds ([2 x %struct.lock_class_key], [2 x %struct.lock_class_key]* @svc_slock_key, i64 0, i64 1), i32 0)
  %sk_lock95 = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 1
  %dep_map96 = getelementptr inbounds %struct.socket_lock_t, %struct.socket_lock_t* %sk_lock95, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %dep_map96, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.16.667, i32 0, i32 0), %struct.lock_class_key* getelementptr inbounds ([2 x %struct.lock_class_key], [2 x %struct.lock_class_key]* @svc_key, i64 0, i64 1), i32 0)
  br label %cleanup.cont

do.body99:                                        ; preds = %LeafBlock, %LeafBlock1
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7.621, i32 0, i32 0), i32 108, i64 12) #7, !srcloc !780
  br label %do.body100

do.body100:                                       ; preds = %do.body100, %do.body99
  br label %do.body100

cleanup.cont:                                     ; preds = %do.body71, %do.body, %if.end35
  ret void
}

declare i32 @kernel_setsockopt(%struct.socket*, i32, i32, i8*, i32) #4

declare i32 @kernel_listen(%struct.socket*, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @spinlock_check.662() #2 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @lock_sock(%struct.sock* %sk) #2 {
entry:
  call void @lock_sock_nested(%struct.sock* %sk, i32 0)
  ret void
}

declare void @release_sock(%struct.sock*) #4

declare void @lock_sock_nested(%struct.sock*, i32) #4

; Function Attrs: nounwind uwtable
define internal void @svc_udp_data_ready(%struct.sock* %sk, i32 %count) #0 {
entry:
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 47
  %0 = load i8*, i8** %sk_user_data, align 8, !tbaa !398
  %1 = bitcast i8* %0 to %struct.svc_sock*
  %call = call %struct.__wait_queue_head* @sk_sleep(%struct.sock* %sk)
  %tobool = icmp ne %struct.svc_sock* %1, null
  br i1 %tobool, label %do.body, label %if.end10

do.body:                                          ; preds = %entry
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 256
  %tobool1 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %do.end

if.then4:                                         ; preds = %do.body
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 0
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt, i32 0, i32 5
  %3 = load volatile i64, i64* %xpt_flags, align 8, !tbaa !88
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then4, %do.body
  %sk_xprt7 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 0
  %xpt_flags8 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt7, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags8, i32 3, i64* %xpt_flags8) #7, !srcloc !752
  %sk_xprt9 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 0
  call void @svc_xprt_enqueue(%struct.svc_xprt* %sk_xprt9)
  br label %if.end10

if.end10:                                         ; preds = %do.end, %entry
  %tobool11 = icmp ne %struct.__wait_queue_head* %call, null
  br i1 %tobool11, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %if.end10
  %call12 = call i32 @waitqueue_active.611(%struct.__wait_queue_head* %call)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %land.lhs.true
  call void @__wake_up(%struct.__wait_queue_head* %call, i32 1, i32 1, i8* null)
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %land.lhs.true, %if.end10
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.svc_xprt* @svc_udp_create(%struct.svc_serv* %serv, %struct.net* %net, %struct.sockaddr* %sa, i32 %salen, i32 %flags) #0 {
entry:
  %call = call %struct.svc_xprt* @svc_create_socket(%struct.svc_serv* %serv, i32 17, %struct.net* %net, %struct.sockaddr* %sa, i32 %salen, i32 %flags)
  ret %struct.svc_xprt* %call
}

; Function Attrs: nounwind uwtable
define internal %struct.svc_xprt* @svc_udp_accept(%struct.svc_xprt* %xprt) #0 {
entry:
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7.621, i32 0, i32 0), i32 657, i64 12) #7, !srcloc !781
  br label %do.body1

do.body1:                                         ; preds = %do.body1, %entry
  br label %do.body1
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_udp_has_wspace(%struct.svc_xprt* %xprt) #0 {
entry:
  %0 = bitcast %struct.svc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.svc_sock*
  %xpt_server = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 6
  %2 = load %struct.svc_serv*, %struct.svc_serv** %xpt_server, align 8, !tbaa !782
  %sk_sock = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 1
  %3 = load %struct.socket*, %struct.socket** %sk_sock, align 8, !tbaa !369
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %3, i32 0, i32 2
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags, i32 2, i64* %flags) #7, !srcloc !752
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 0
  %xpt_reserved = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt, i32 0, i32 7
  %call = call i32 @atomic_read.647(%struct.atomic_t* %xpt_reserved)
  %sv_max_mesg = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %2, i32 0, i32 6
  %4 = load i32, i32* %sv_max_mesg, align 4, !tbaa !724
  %add = add i32 %call, %4
  %conv = zext i32 %add to i64
  %mul = mul i64 %conv, 2
  %sk_sk = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 2
  %5 = load %struct.sock*, %struct.sock** %sk_sk, align 8, !tbaa !372
  %call1 = call i64 @sock_wspace(%struct.sock* %5)
  %cmp = icmp ugt i64 %mul, %call1
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %sk_sock3 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %1, i32 0, i32 1
  %6 = load %struct.socket*, %struct.socket** %sk_sock3, align 8, !tbaa !369
  %flags4 = getelementptr inbounds %struct.socket, %struct.socket* %6, i32 0, i32 2
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags4, i32 2, i64* %flags4) #7, !srcloc !750
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 1, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_udp_recvfrom(%struct.svc_rqst* %rqstp) #0 {
entry:
  %buffer = alloca %union.anon.75, align 8
  %msg = alloca %struct.msghdr, align 8
  %err = alloca i32, align 4
  %coerce = alloca %struct.pgprot, align 8
  %rq_xprt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %0 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt, align 8, !tbaa !635
  %1 = bitcast %struct.svc_xprt* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.svc_sock*
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 0
  %xpt_server = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt, i32 0, i32 6
  %3 = load %struct.svc_serv*, %struct.svc_serv** %xpt_server, align 8, !tbaa !751
  %hdr = bitcast %union.anon.75* %buffer to %struct.arch_uprobe_task*
  %msg_name = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 0
  %call = call %struct.sockaddr* @svc_addr(%struct.svc_rqst* %rqstp)
  %4 = bitcast %struct.sockaddr* %call to i8*
  store i8* %4, i8** %msg_name, align 8, !tbaa !451
  %msg_namelen = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 1
  store i32 0, i32* %msg_namelen, align 8, !tbaa !453
  %msg_iov = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 2
  store %struct.iovec* null, %struct.iovec** %msg_iov, align 8, !tbaa !454
  %msg_iovlen = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 3
  store i64 0, i64* %msg_iovlen, align 8, !tbaa !455
  %msg_control = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 4
  %5 = bitcast %struct.arch_uprobe_task* %hdr to i8*
  store i8* %5, i8** %msg_control, align 8, !tbaa !456
  %msg_controllen = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 5
  store i64 40, i64* %msg_controllen, align 8, !tbaa !457
  %msg_flags = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 6
  store i32 64, i32* %msg_flags, align 8, !tbaa !458
  %sk_xprt1 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 0
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt1, i32 0, i32 5
  %call2 = call i32 @test_and_clear_bit.670(i32 7, i64* %xpt_flags)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %sk_sock = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 1
  %6 = load %struct.socket*, %struct.socket** %sk_sock, align 8, !tbaa !369
  %sv_nrthreads = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %3, i32 0, i32 3
  %7 = load i32, i32* %sv_nrthreads, align 8, !tbaa !707
  %add = add i32 %7, 3
  %sv_max_mesg = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %3, i32 0, i32 6
  %8 = load i32, i32* %sv_max_mesg, align 4, !tbaa !724
  %mul = mul i32 %add, %8
  %sv_nrthreads3 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %3, i32 0, i32 3
  %9 = load i32, i32* %sv_nrthreads3, align 8, !tbaa !707
  %add4 = add i32 %9, 3
  %sv_max_mesg5 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %3, i32 0, i32 6
  %10 = load i32, i32* %sv_max_mesg5, align 4, !tbaa !724
  %mul6 = mul i32 %add4, %10
  call void @svc_sock_setbufsize(%struct.socket* %6, i32 %mul, i32 %mul6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sk_xprt7 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 0
  %xpt_flags8 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt7, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags8, i32 3, i64* %xpt_flags8) #7, !srcloc !750
  %sk_sock9 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 1
  %11 = load %struct.socket*, %struct.socket** %sk_sock9, align 8, !tbaa !369
  %call10 = call i32 @kernel_recvmsg(%struct.socket* %11, %struct.msghdr* %msg, %struct.iovec* null, i64 0, i64 0, i32 66)
  store i32 %call10, i32* %err, align 4, !tbaa !49
  %12 = load i32, i32* %err, align 4, !tbaa !49
  %cmp = icmp sge i32 %12, 0
  br i1 %cmp, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end
  %sk_sk = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 2
  %13 = load %struct.sock*, %struct.sock** %sk_sk, align 8, !tbaa !372
  %call12 = call %struct.sk_buff* @skb_recv_datagram(%struct.sock* %13, i32 0, i32 1, i32* %err)
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end
  %skb.0 = phi %struct.sk_buff* [ %call12, %if.then11 ], [ null, %if.end ]
  %cmp14 = icmp eq %struct.sk_buff* %skb.0, null
  br i1 %cmp14, label %if.then15, label %if.end27

if.then15:                                        ; preds = %if.end13
  %14 = load i32, i32* %err, align 4, !tbaa !49
  %cmp16 = icmp ne i32 %14, -11
  br i1 %cmp16, label %do.body, label %cleanup

do.body:                                          ; preds = %if.then15
  %15 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %15, 256
  %tobool18 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool18, true
  %lnot19 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot19 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool20 = icmp ne i64 %expval, 0
  br i1 %tobool20, label %if.then21, label %do.end

if.then21:                                        ; preds = %do.body
  %16 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then21, %do.body
  %sk_xprt24 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 0
  %xpt_flags25 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt24, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags25, i32 3, i64* %xpt_flags25) #7, !srcloc !752
  br label %cleanup

if.end27:                                         ; preds = %if.end13
  %call28 = call %struct.sockaddr* @svc_addr(%struct.svc_rqst* %rqstp)
  %call29 = call i64 @svc_addr_len(%struct.sockaddr* %call28)
  %rq_addrlen = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 4
  store i64 %call29, i64* %rq_addrlen, align 8, !tbaa !648
  %tstamp = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb.0, i32 0, i32 2
  %tv64 = bitcast %struct.pgprot* %tstamp to i64*
  %17 = load i64, i64* %tv64, align 8, !tbaa !166
  %cmp30 = icmp eq i64 %17, 0
  br i1 %cmp30, label %if.then32, label %if.end35

if.then32:                                        ; preds = %if.end27
  %tstamp33 = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb.0, i32 0, i32 2
  %call34 = call i64 @ktime_get_real()
  %coerce.dive = getelementptr inbounds %struct.pgprot, %struct.pgprot* %coerce, i32 0, i32 0
  store i64 %call34, i64* %coerce.dive, align 8
  %18 = bitcast %struct.pgprot* %tstamp33 to i8*
  %19 = bitcast %struct.pgprot* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %18, i8* %19, i64 8, i32 8, i1 false), !tbaa.struct !290
  br label %if.end35

if.end35:                                         ; preds = %if.then32, %if.end27
  %sk_sk36 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 2
  %20 = load %struct.sock*, %struct.sock** %sk_sk36, align 8, !tbaa !372
  %sk_stamp = getelementptr inbounds %struct.sock, %struct.sock* %20, i32 0, i32 45
  %tstamp37 = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb.0, i32 0, i32 2
  %21 = bitcast %struct.pgprot* %sk_stamp to i8*
  %22 = bitcast %struct.pgprot* %tstamp37 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %21, i8* %22, i64 8, i32 8, i1 false), !tbaa.struct !290
  %sk_xprt38 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 0
  %xpt_flags39 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt38, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags39, i32 3, i64* %xpt_flags39) #7, !srcloc !752
  %len40 = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb.0, i32 0, i32 8
  %23 = load i32, i32* %len40, align 8, !tbaa !348
  %conv41 = zext i32 %23 to i64
  %sub42 = sub i64 %conv41, 8
  %conv43 = trunc i64 %sub42 to i32
  %rq_arg = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %len44 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 7
  store i32 %conv43, i32* %len44, align 8, !tbaa !759
  %rq_prot = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 27
  store i32 17, i32* %rq_prot, align 8, !tbaa !647
  %call45 = call i32 @svc_udp_get_dest_address(%struct.svc_rqst* %rqstp, %struct.arch_uprobe_task* %hdr)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %if.end56, label %do.body48

do.body48:                                        ; preds = %if.end35
  %call49 = call i32 @net_ratelimit()
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %if.then51, label %out_free

if.then51:                                        ; preds = %do.body48
  %24 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_free

if.end56:                                         ; preds = %if.end35
  %call57 = call %struct.sockaddr* @svc_daddr(%struct.svc_rqst* %rqstp)
  %call58 = call i64 @svc_addr_len(%struct.sockaddr* %call57)
  %rq_daddrlen = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 6
  store i64 %call58, i64* %rq_daddrlen, align 8, !tbaa !783
  %call59 = call zeroext i1 @skb_is_nonlinear(%struct.sk_buff* %skb.0)
  br i1 %call59, label %if.then60, label %if.else

if.then60:                                        ; preds = %if.end56
  call void @local_bh_disable()
  %rq_arg61 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %call62 = call i32 @csum_partial_copy_to_xdr(%struct.xdr_buf* %rq_arg61, %struct.sk_buff* %skb.0)
  %tobool63 = icmp ne i32 %call62, 0
  call void @local_bh_enable()
  br i1 %tobool63, label %out_free, label %if.end65

if.end65:                                         ; preds = %if.then60
  %sk_sk66 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 2
  %25 = load %struct.sock*, %struct.sock** %sk_sk66, align 8, !tbaa !372
  call void @skb_free_datagram_locked(%struct.sock* %25, %struct.sk_buff* %skb.0)
  br label %if.end76

if.else:                                          ; preds = %if.end56
  %data = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb.0, i32 0, i32 40
  %26 = load i8*, i8** %data, align 8, !tbaa !351
  %add.ptr67 = getelementptr inbounds i8, i8* %26, i64 8
  %rq_arg68 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg68, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  store i8* %add.ptr67, i8** %iov_base, align 8, !tbaa !147
  %rq_arg69 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %head70 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg69, i32 0, i32 0
  %arrayidx71 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head70, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx71, i32 0, i32 1
  store i64 %sub42, i64* %iov_len, align 8, !tbaa !149
  %call72 = call zeroext i16 @skb_checksum_complete(%struct.sk_buff* %skb.0)
  %tobool73 = icmp ne i16 %call72, 0
  br i1 %tobool73, label %out_free, label %if.end75

if.end75:                                         ; preds = %if.else
  %27 = bitcast %struct.sk_buff* %skb.0 to i8*
  %rq_xprt_ctxt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 12
  store i8* %27, i8** %rq_xprt_ctxt, align 8, !tbaa !762
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %if.end65
  %rq_arg77 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg77, i32 0, i32 3
  store i32 0, i32* %page_base, align 8, !tbaa !760
  %rq_arg78 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %head79 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg78, i32 0, i32 0
  %arrayidx80 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head79, i64 0, i64 0
  %iov_len81 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx80, i32 0, i32 1
  %28 = load i64, i64* %iov_len81, align 8, !tbaa !149
  %cmp82 = icmp ule i64 %sub42, %28
  %rq_arg85 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %head86 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg85, i32 0, i32 0
  %arrayidx87 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head86, i64 0, i64 0
  %iov_len88 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx87, i32 0, i32 1
  br i1 %cmp82, label %if.then84, label %if.else91

if.then84:                                        ; preds = %if.end76
  store i64 %sub42, i64* %iov_len88, align 8, !tbaa !149
  %rq_arg89 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg89, i32 0, i32 4
  store i32 0, i32* %page_len, align 4, !tbaa !761
  %rq_pages = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %arraydecay = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages, i32 0, i32 0
  %add.ptr90 = getelementptr inbounds %struct.page*, %struct.page** %arraydecay, i64 1
  br label %if.end110

if.else91:                                        ; preds = %if.end76
  %29 = load i64, i64* %iov_len88, align 8, !tbaa !149
  %sub96 = sub i64 %sub42, %29
  %conv97 = trunc i64 %sub96 to i32
  %rq_arg98 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %page_len99 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg98, i32 0, i32 4
  store i32 %conv97, i32* %page_len99, align 4, !tbaa !761
  %rq_pages100 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %arraydecay101 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages100, i32 0, i32 0
  %add.ptr102 = getelementptr inbounds %struct.page*, %struct.page** %arraydecay101, i64 1
  %rq_arg103 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %page_len104 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg103, i32 0, i32 4
  %30 = load i32, i32* %page_len104, align 4, !tbaa !761
  %conv105 = zext i32 %30 to i64
  %add106 = add i64 %conv105, 4096
  %sub107 = sub i64 %add106, 1
  %div = udiv i64 %sub107, 4096
  %add.ptr108 = getelementptr inbounds %struct.page*, %struct.page** %add.ptr102, i64 %div
  br label %if.end110

if.end110:                                        ; preds = %if.else91, %if.then84
  %add.ptr108.sink = phi %struct.page** [ %add.ptr108, %if.else91 ], [ %add.ptr90, %if.then84 ]
  %rq_respages109 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 19
  store %struct.page** %add.ptr108.sink, %struct.page*** %rq_respages109, align 8, !tbaa !695
  %rq_respages111 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 19
  %31 = load %struct.page**, %struct.page*** %rq_respages111, align 8, !tbaa !695
  %add.ptr112 = getelementptr inbounds %struct.page*, %struct.page** %31, i64 1
  %rq_next_page = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 21
  store %struct.page** %add.ptr112, %struct.page*** %rq_next_page, align 8, !tbaa !696
  %sv_stats = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %3, i32 0, i32 1
  %32 = load %struct.svc_stat*, %struct.svc_stat** %sv_stats, align 8, !tbaa !670
  %tobool113 = icmp ne %struct.svc_stat* %32, null
  br i1 %tobool113, label %if.then114, label %if.end116

if.then114:                                       ; preds = %if.end110
  %sv_stats115 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %3, i32 0, i32 1
  %33 = load %struct.svc_stat*, %struct.svc_stat** %sv_stats115, align 8, !tbaa !670
  %netudpcnt = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %33, i32 0, i32 2
  %34 = load i32, i32* %netudpcnt, align 4, !tbaa !784
  %inc = add i32 %34, 1
  store i32 %inc, i32* %netudpcnt, align 4, !tbaa !784
  br label %if.end116

if.end116:                                        ; preds = %if.then114, %if.end110
  %conv117 = trunc i64 %sub42 to i32
  br label %cleanup

out_free:                                         ; preds = %if.else, %if.then60, %if.then51, %do.body48
  call void @trace_kfree_skb(%struct.sk_buff* %skb.0, i8* bitcast (i32 (%struct.svc_rqst*)* @svc_udp_recvfrom to i8*))
  %sk_sk118 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 2
  %35 = load %struct.sock*, %struct.sock** %sk_sk118, align 8, !tbaa !372
  call void @skb_free_datagram_locked(%struct.sock* %35, %struct.sk_buff* %skb.0)
  br label %cleanup

cleanup:                                          ; preds = %out_free, %if.end116, %do.end, %if.then15
  %retval.0 = phi i32 [ 0, %out_free ], [ %conv117, %if.end116 ], [ 0, %do.end ], [ 0, %if.then15 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @svc_udp_prep_reply_hdr(%struct.svc_rqst* %rqstp) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_udp_sendto(%struct.svc_rqst* %rqstp) #0 {
entry:
  %rq_res = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %call = call i32 @svc_sendto(%struct.svc_rqst* %rqstp, %struct.xdr_buf* %rq_res)
  %cmp = icmp eq i32 %call, -111
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %rq_res1 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %call2 = call i32 @svc_sendto(%struct.svc_rqst* %rqstp, %struct.xdr_buf* %rq_res1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %error.0 = phi i32 [ %call2, %if.then ], [ %call, %entry ]
  ret i32 %error.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr* @svc_addr(%struct.svc_rqst* %rqst) #2 {
entry:
  %rq_addr = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqst, i32 0, i32 3
  %0 = bitcast %struct.__kernel_sockaddr_storage* %rq_addr to %struct.sockaddr*
  ret %struct.sockaddr* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_and_clear_bit.670(i32 %nr, i64* %addr) #2 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !785
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @svc_addr_len(%struct.sockaddr* %sa) #2 {
entry:
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sa, i32 0, i32 0
  %0 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %0 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %do.end4, label %do.body

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %do.end4, label %do.body

do.body:                                          ; preds = %LeafBlock, %LeafBlock1
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.50.684, i32 0, i32 0), i32 169, i64 12) #7, !srcloc !786
  br label %do.body2

do.body2:                                         ; preds = %do.body2, %do.body
  br label %do.body2

do.end4:                                          ; preds = %LeafBlock, %LeafBlock1
  %retval.0 = phi i64 [ 16, %LeafBlock ], [ 28, %LeafBlock1 ]
  ret i64 %retval.0
}

declare i64 @ktime_get_real() #4

; Function Attrs: nounwind uwtable
define internal i32 @svc_udp_get_dest_address(%struct.svc_rqst* %rqstp, %struct.arch_uprobe_task* %cmh) #0 {
entry:
  %cmsg_level = getelementptr inbounds %struct.arch_uprobe_task, %struct.arch_uprobe_task* %cmh, i32 0, i32 1
  %0 = load i32, i32* %cmsg_level, align 8, !tbaa !765
  %Pivot = icmp slt i32 %0, 41
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %0, 41
  br i1 %SwitchLeaf2, label %sw.bb1, label %return

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %0, 0
  br i1 %SwitchLeaf, label %sw.bb, label %return

sw.bb:                                            ; preds = %LeafBlock
  %call = call i32 @svc_udp_get_dest_address4(%struct.svc_rqst* %rqstp, %struct.arch_uprobe_task* %cmh)
  br label %return

sw.bb1:                                           ; preds = %LeafBlock1
  %call2 = call i32 @svc_udp_get_dest_address6(%struct.svc_rqst* %rqstp, %struct.arch_uprobe_task* %cmh)
  br label %return

return:                                           ; preds = %sw.bb1, %sw.bb, %LeafBlock, %LeafBlock1
  %retval.0 = phi i32 [ %call, %sw.bb ], [ %call2, %sw.bb1 ], [ 0, %LeafBlock ], [ 0, %LeafBlock1 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr* @svc_daddr(%struct.svc_rqst* %rqst) #2 {
entry:
  %rq_daddr = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqst, i32 0, i32 5
  %0 = bitcast %struct.__kernel_sockaddr_storage* %rq_daddr to %struct.sockaddr*
  ret %struct.sockaddr* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @skb_is_nonlinear(%struct.sk_buff* %skb) #2 {
entry:
  %data_len = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 9
  %0 = load i32, i32* %data_len, align 4, !tbaa !470
  %tobool = icmp ne i32 %0, 0
  ret i1 %tobool
}

declare void @local_bh_disable() #4

declare void @local_bh_enable() #4

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @skb_checksum_complete(%struct.sk_buff* %skb) #2 {
entry:
  %call = call i32 @skb_csum_unnecessary.683(%struct.sk_buff* %skb)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  %call1 = call zeroext i16 @__skb_checksum_complete(%struct.sk_buff* %skb)
  %conv = zext i16 %call1 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %entry
  %cond = phi i32 [ %conv, %cond.false ], [ 0, %entry ]
  %conv2 = trunc i32 %cond to i16
  ret i16 %conv2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @trace_kfree_skb(%struct.sk_buff* %skb, i8* %location) #2 {
entry:
  %call.i = call i32 @atomic_read.647(%struct.atomic_t* getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_kfree_skb, i64 0, i32 1, i32 0)) #7
  %tobool.i = icmp ne i32 %call.i, 0
  %lnot.ext.i = zext i1 %tobool.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv.i, i64 0) #7
  %cmp.i = icmp sgt i64 %expval.i, 0
  %..i = select i1 %cmp.i, i1 true, i1 false
  br i1 %..i, label %do.body, label %if.end21

do.body:                                          ; preds = %entry
  call void @rcu_read_lock_sched_notrace.674()
  %0 = load volatile %struct.tracepoint_func*, %struct.tracepoint_func** getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_kfree_skb, i32 0, i32 4), align 8, !tbaa !28
  %call2 = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %land.lhs.true, label %do.end10

land.lhs.true:                                    ; preds = %do.body
  %1 = load i8, i8* @trace_kfree_skb.__warned, align 1, !tbaa !29, !range !31
  %tobool3 = trunc i8 %1 to i1
  br i1 %tobool3, label %do.end10, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %land.lhs.true
  %call5 = call i32 @rcu_read_lock_sched_held.675()
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %do.end10, label %if.then7

if.then7:                                         ; preds = %land.lhs.true4
  store i8 1, i8* @trace_kfree_skb.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.51.676, i32 0, i32 0), i32 34, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end10

do.end10:                                         ; preds = %if.then7, %land.lhs.true4, %land.lhs.true, %do.body
  %tobool11 = icmp ne %struct.tracepoint_func* %0, null
  br i1 %tobool11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %do.end10
  br label %do.body13

do.body13:                                        ; preds = %do.body13, %if.then12
  %it_func_ptr.0 = phi %struct.tracepoint_func* [ %0, %if.then12 ], [ %incdec.ptr, %do.body13 ]
  %func = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 0
  %2 = load i8*, i8** %func, align 8, !tbaa !120
  %data = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 1
  %3 = load i8*, i8** %data, align 8, !tbaa !122
  %4 = bitcast i8* %2 to void (i8*, %struct.sk_buff*, i8*)*
  call void %4(i8* %3, %struct.sk_buff* %skb, i8* %location)
  %incdec.ptr = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 1
  %func15 = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %incdec.ptr, i32 0, i32 0
  %5 = load i8*, i8** %func15, align 8, !tbaa !120
  %tobool16 = icmp ne i8* %5, null
  br i1 %tobool16, label %do.body13, label %if.end18

if.end18:                                         ; preds = %do.body13, %do.end10
  call void @rcu_read_unlock_sched_notrace.678()
  br label %if.end21

if.end21:                                         ; preds = %if.end18, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock_sched_notrace.674() #2 {
entry:
  %call = call %struct.thread_info* @current_thread_info.679()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !787
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rcu_read_lock_sched_held.675() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @rcu_is_cpu_idle()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call zeroext i1 @rcu_lockdep_current_cpu_online()
  br i1 %call5, label %if.end7, label %cleanup

if.end7:                                          ; preds = %if.end4
  %0 = load i32, i32* @debug_locks, align 4, !tbaa !49
  %tobool8 = icmp ne i32 %0, 0
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end7
  %call10 = call i32 @lock_is_held(%struct.lockdep_map* @rcu_sched_lock_map)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end7
  %lockdep_opinion.0 = phi i32 [ %call10, %if.then9 ], [ 0, %if.end7 ]
  %tobool12 = icmp ne i32 %lockdep_opinion.0, 0
  br i1 %tobool12, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end11
  %call13 = call %struct.thread_info* @current_thread_info.679()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call13, i32 0, i32 5
  %1 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %lor.end, label %do.body

do.body:                                          ; preds = %lor.lhs.false
  %call15 = call i64 @arch_local_save_flags.680()
  %call23 = call i32 @arch_irqs_disabled_flags.681(i64 %call15)
  %tobool24 = icmp ne i32 %call23, 0
  br label %lor.end

lor.end:                                          ; preds = %do.body, %lor.lhs.false, %if.end11
  %2 = phi i1 [ true, %lor.lhs.false ], [ true, %if.end11 ], [ %tobool24, %do.body ]
  %lor.ext = zext i1 %2 to i32
  br label %cleanup

cleanup:                                          ; preds = %lor.end, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %lor.ext, %lor.end ], [ 1, %entry ], [ 0, %if.end ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_unlock_sched_notrace.678() #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !788
  %call = call %struct.thread_info* @current_thread_info.679()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !789
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.679() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !790
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @arch_local_save_flags.680() #2 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), align 8, !tbaa !136
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.52.682, i32 0, i32 0), i32 824, i64 12) #7, !srcloc !791
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call i64 asm sideeffect "771:\0A\09call *${2:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${1:c}\0A  .byte 772b-771b\0A  .short ${3:c}\0A.popsection\0A", "={ax},i,i,i,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 44, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), i32 1) #7, !srcloc !792
  ret i64 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @arch_irqs_disabled_flags.681(i64 %flags) #2 {
entry:
  %and = and i64 %flags, 512
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @skb_csum_unnecessary.683(%struct.sk_buff* %skb) #2 {
entry:
  %ip_summed = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 14
  %bf.load = load i16, i16* %ip_summed, align 4
  %bf.lshr = lshr i16 %bf.load, 2
  %bf.clear = and i16 %bf.lshr, 3
  %bf.cast = trunc i16 %bf.clear to i8
  %conv = zext i8 %bf.cast to i32
  %and = and i32 %conv, 1
  ret i32 %and
}

declare zeroext i16 @__skb_checksum_complete(%struct.sk_buff*) #4

; Function Attrs: nounwind uwtable
define internal i32 @svc_udp_get_dest_address4(%struct.svc_rqst* %rqstp, %struct.arch_uprobe_task* %cmh) #0 {
entry:
  %0 = bitcast %struct.arch_uprobe_task* %cmh to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 16
  %1 = bitcast i8* %add.ptr to %struct.in_pktinfo*
  %call = call %struct.sockaddr_in* @svc_daddr_in(%struct.svc_rqst* %rqstp)
  %cmsg_type = getelementptr inbounds %struct.arch_uprobe_task, %struct.arch_uprobe_task* %cmh, i32 0, i32 2
  %2 = load i32, i32* %cmsg_type, align 4, !tbaa !767
  %cmp = icmp ne i32 %2, 8
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %sin_family = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %call, i32 0, i32 0
  store i16 2, i16* %sin_family, align 4, !tbaa !738
  %ipi_spec_dst = getelementptr inbounds %struct.in_pktinfo, %struct.in_pktinfo* %1, i32 0, i32 1
  %s_addr = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %ipi_spec_dst, i32 0, i32 0
  %3 = load i32, i32* %s_addr, align 4, !tbaa !770
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %call, i32 0, i32 2
  %s_addr1 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %sin_addr, i32 0, i32 0
  store i32 %3, i32* %s_addr1, align 4, !tbaa !374
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 1, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_udp_get_dest_address6(%struct.svc_rqst* %rqstp, %struct.arch_uprobe_task* %cmh) #0 {
entry:
  %0 = bitcast %struct.arch_uprobe_task* %cmh to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 16
  %1 = bitcast i8* %add.ptr to %struct.in6_pktinfo*
  %call = call %struct.sockaddr_in6* @svc_daddr_in6(%struct.svc_rqst* %rqstp)
  %cmsg_type = getelementptr inbounds %struct.arch_uprobe_task, %struct.arch_uprobe_task* %cmh, i32 0, i32 2
  %2 = load i32, i32* %cmsg_type, align 4, !tbaa !767
  %cmp = icmp ne i32 %2, 50
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %sin6_family = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %call, i32 0, i32 0
  store i16 10, i16* %sin6_family, align 4, !tbaa !740
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %call, i32 0, i32 3
  %ipi6_addr = getelementptr inbounds %struct.in6_pktinfo, %struct.in6_pktinfo* %1, i32 0, i32 0
  %3 = bitcast %struct.in6_addr* %sin6_addr to i8*
  %4 = bitcast %struct.in6_addr* %ipi6_addr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 16, i32 4, i1 false), !tbaa.struct !774
  %ipi6_ifindex = getelementptr inbounds %struct.in6_pktinfo, %struct.in6_pktinfo* %1, i32 0, i32 1
  %5 = load i32, i32* %ipi6_ifindex, align 4, !tbaa !772
  %sin6_scope_id = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %call, i32 0, i32 4
  store i32 %5, i32* %sin6_scope_id, align 4, !tbaa !197
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 1, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @sock_wspace(%struct.sock* %sk) #2 {
entry:
  %sk_shutdown = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 20
  %bf.load = load i32, i32* %sk_shutdown, align 8
  %bf.clear = and i32 %bf.load, 3
  %and = and i32 %bf.clear, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end2, label %if.then

if.then:                                          ; preds = %entry
  %sk_sndbuf = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 18
  %0 = load i32, i32* %sk_sndbuf, align 8, !tbaa !433
  %sk_wmem_alloc = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 16
  %call = call i32 @atomic_read.647(%struct.atomic_t* %sk_wmem_alloc)
  %sub = sub nsw i32 %0, %call
  %cmp = icmp slt i32 %sub, 0
  %.sub = select i1 %cmp, i32 0, i32 %sub
  br label %if.end2

if.end2:                                          ; preds = %if.then, %entry
  %amt.1 = phi i32 [ 0, %entry ], [ %.sub, %if.then ]
  %conv = sext i32 %amt.1 to i64
  ret i64 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.net* @read_pnet.685(%struct.net** %pnet) #2 {
entry:
  %0 = load %struct.net*, %struct.net** %pnet, align 8, !tbaa !28
  ret %struct.net* %0
}

; Function Attrs: nounwind uwtable
define void @svc_sock_update_bufs(%struct.svc_serv* %serv) #0 {
entry:
  %sv_lock = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 2
  call void @spin_lock_bh.689(%struct.spinlock* %sv_lock)
  %sv_permsocks = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 8
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %xpt_list5.sink = phi %struct.list_head* [ %xpt_list5, %for.body ], [ %sv_permsocks, %entry ]
  %next6 = getelementptr inbounds %struct.list_head, %struct.list_head* %xpt_list5.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next6, align 8, !tbaa !28
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr8 = getelementptr inbounds i8, i8* %1, i64 -24
  %2 = bitcast i8* %add.ptr8 to %struct.svc_sock*
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 0
  %xpt_list = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt, i32 0, i32 3
  %sv_permsocks1 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 8
  %cmp = icmp ne %struct.list_head* %xpt_list, %sv_permsocks1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %sk_xprt2 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 0
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt2, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 7, i64* %xpt_flags) #7, !srcloc !752
  %sk_xprt4 = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 0
  %xpt_list5 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %sk_xprt4, i32 0, i32 3
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %sv_lock9 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 2
  call void @spin_unlock_bh.690(%struct.spinlock* %sv_lock9)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_bh.689(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_bh.690(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define void @svc_init_xprt_sock() #0 {
entry:
  %call = call i32 @svc_reg_xprt_class(%struct.svc_xprt_class* @svc_tcp_class)
  %call1 = call i32 @svc_reg_xprt_class(%struct.svc_xprt_class* @svc_udp_class)
  call void @svc_init_bc_xprt_sock()
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_init_bc_xprt_sock() #0 {
entry:
  %call = call i32 @svc_reg_xprt_class(%struct.svc_xprt_class* @svc_tcp_bc_class)
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.svc_xprt* @svc_bc_tcp_create(%struct.svc_serv* %serv, %struct.net* %net, %struct.sockaddr* %sa, i32 %salen, i32 %flags) #0 {
entry:
  %call = call %struct.svc_xprt* @svc_bc_create_socket(%struct.svc_serv* %serv, i32 6, %struct.net* %net)
  ret %struct.svc_xprt* %call
}

; Function Attrs: nounwind uwtable
define internal void @svc_bc_tcp_sock_detach(%struct.svc_xprt* %xprt) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_bc_sock_free(%struct.svc_xprt* %xprt) #0 {
entry:
  %tobool = icmp ne %struct.svc_xprt* %xprt, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.svc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.svc_sock*
  %2 = bitcast %struct.svc_sock* %1 to i8*
  call void @kfree(i8* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.svc_xprt* @svc_bc_create_socket(%struct.svc_serv* %serv, i32 %protocol, %struct.net* %net) #0 {
entry:
  %cmp = icmp ne i32 %protocol, 6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = call i32 (i8*, ...) @printk(i8* null)
  %call1 = call i8* @ERR_PTR.598(i64 -22)
  %1 = bitcast i8* %call1 to %struct.svc_xprt*
  br label %cleanup

if.end:                                           ; preds = %entry
  %call2 = call i8* @kzalloc.597(i64 3088, i32 208)
  %2 = bitcast i8* %call2 to %struct.svc_sock*
  %tobool = icmp ne %struct.svc_sock* %2, null
  br i1 %tobool, label %if.end5, label %if.then3

if.then3:                                         ; preds = %if.end
  %call4 = call i8* @ERR_PTR.598(i64 -12)
  %3 = bitcast i8* %call4 to %struct.svc_xprt*
  br label %cleanup

if.end5:                                          ; preds = %if.end
  %sk_xprt = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %2, i32 0, i32 0
  call void @svc_xprt_init(%struct.net* %net, %struct.svc_xprt_class* @svc_tcp_bc_class, %struct.svc_xprt* %sk_xprt, %struct.svc_serv* %serv)
  %sv_bc_xprt = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 21
  store %struct.svc_xprt* %sk_xprt, %struct.svc_xprt** %sv_bc_xprt, align 8, !tbaa !645
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %if.then3, %if.then
  %retval.0 = phi %struct.svc_xprt* [ %1, %if.then ], [ %sk_xprt, %if.end5 ], [ %3, %if.then3 ]
  ret %struct.svc_xprt* %retval.0
}

; Function Attrs: nounwind uwtable
define void @svc_cleanup_xprt_sock() #0 {
entry:
  call void @svc_unreg_xprt_class(%struct.svc_xprt_class* @svc_tcp_class)
  call void @svc_unreg_xprt_class(%struct.svc_xprt_class* @svc_udp_class)
  call void @svc_cleanup_bc_xprt_sock()
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_cleanup_bc_xprt_sock() #0 {
entry:
  call void @svc_unreg_xprt_class(%struct.svc_xprt_class* @svc_tcp_bc_class)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.auth_domain.5097* @auth_domain_find(i8* %name) #0 {
entry:
  %call = call %struct.auth_domain.5097* @auth_domain_lookup(i8* %name, %struct.auth_domain.5097* null)
  ret %struct.auth_domain.5097* %call
}

; Function Attrs: nounwind uwtable
define %struct.auth_domain.5097* @auth_domain_lookup(i8* %name, %struct.auth_domain.5097* %new) #0 {
entry:
  %call = call i64 @hash_str(i8* %name, i32 6)
  %arrayidx = getelementptr inbounds [64 x %struct.hlist_head], [64 x %struct.hlist_head]* @auth_domain_table, i64 0, i64 %call
  call void @spin_lock.694(%struct.spinlock* @auth_domain_lock)
  %first = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %arrayidx, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.hlist_node** [ %next, %for.inc ], [ %first, %entry ]
  %0 = load %struct.hlist_node*, %struct.hlist_node** %next.sink, align 8, !tbaa !28
  %tobool7 = icmp ne %struct.hlist_node* %0, null
  %1 = bitcast %struct.hlist_node* %0 to i8*
  %add.ptr11 = getelementptr inbounds i8, i8* %1, i64 -8
  %2 = bitcast i8* %add.ptr11 to %struct.auth_domain.5097*
  %cond14 = select i1 %tobool7, %struct.auth_domain.5097* %2, %struct.auth_domain.5097* null
  %tobool2 = icmp ne %struct.auth_domain.5097* %cond14, null
  br i1 %tobool2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %name3 = getelementptr inbounds %struct.auth_domain.5097, %struct.auth_domain.5097* %cond14, i32 0, i32 2
  %3 = load i8*, i8** %name3, align 8, !tbaa !793
  %call4 = call i32 @strcmp(i8* %3, i8* %name)
  %cmp = icmp eq i32 %call4, 0
  br i1 %cmp, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %ref = getelementptr inbounds %struct.auth_domain.5097, %struct.auth_domain.5097* %cond14, i32 0, i32 0
  call void @kref_get(%struct.arch_spinlock* %ref)
  call void @spin_unlock.695(%struct.spinlock* @auth_domain_lock)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %hash = getelementptr inbounds %struct.auth_domain.5097, %struct.auth_domain.5097* %cond14, i32 0, i32 1
  %next = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %hash, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool15 = icmp ne %struct.auth_domain.5097* %new, null
  br i1 %tobool15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %for.end
  %hash17 = getelementptr inbounds %struct.auth_domain.5097, %struct.auth_domain.5097* %new, i32 0, i32 1
  call void @hlist_add_head(%struct.hlist_node* %hash17, %struct.hlist_head* %arrayidx)
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %for.end
  call void @spin_unlock.695(%struct.spinlock* @auth_domain_lock)
  br label %cleanup

cleanup:                                          ; preds = %if.end18, %if.then
  %retval.0 = phi %struct.auth_domain.5097* [ %cond14, %if.then ], [ %new, %if.end18 ]
  ret %struct.auth_domain.5097* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @hash_str(i8* %name, i32 %bits) #2 {
entry:
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %len.0 = phi i32 [ 0, %entry ], [ %inc, %do.cond ]
  %l.0 = phi i64 [ 0, %entry ], [ %or, %do.cond ]
  %hash.0 = phi i64 [ 0, %entry ], [ %hash.1, %do.cond ]
  %name.addr.0 = phi i8* [ %name, %entry ], [ %incdec.ptr, %do.cond ]
  %incdec.ptr = getelementptr inbounds i8, i8* %name.addr.0, i32 1
  %0 = load i8, i8* %name.addr.0, align 1, !tbaa !166
  %tobool = icmp ne i8 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  %conv4 = trunc i32 %len.0 to i8
  %.len.0 = select i1 %tobool3, i32 -1, i32 %len.0
  %conv4. = select i1 %tobool3, i8 %conv4, i8 %0
  %shl = shl i64 %l.0, 8
  %conv5 = zext i8 %conv4. to i64
  %or = or i64 %shl, %conv5
  %inc = add nsw i32 %.len.0, 1
  %and = and i32 %inc, 7
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then7, label %do.cond

if.then7:                                         ; preds = %do.body
  %xor = xor i64 %hash.0, %or
  %shl.i = shl i64 %xor, 18
  %sub.i = sub i64 %xor, %shl.i
  %shl1.i = shl i64 %shl.i, 33
  %sub2.i = sub i64 %sub.i, %shl1.i
  %shl3.i = shl i64 %shl1.i, 3
  %add.i = add i64 %sub2.i, %shl3.i
  %shl4.i = shl i64 %shl3.i, 3
  %sub5.i = sub i64 %add.i, %shl4.i
  %shl6.i = shl i64 %shl4.i, 4
  %add7.i = add i64 %sub5.i, %shl6.i
  %shl8.i = shl i64 %shl6.i, 2
  %add9.i = add i64 %add7.i, %shl8.i
  br label %do.cond

do.cond:                                          ; preds = %if.then7, %do.body
  %hash.1 = phi i64 [ %add9.i, %if.then7 ], [ %hash.0, %do.body ]
  %tobool9 = icmp ne i32 %inc, 0
  br i1 %tobool9, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %sub = sub nsw i32 64, %bits
  %sh_prom = zext i32 %sub to i64
  %shr = lshr i64 %hash.1, %sh_prom
  ret i64 %shr
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock.694(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_get(%struct.arch_spinlock* %kref) #2 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_add_return.696(i32 1, %struct.atomic_t* %refcount)
  %cmp = icmp slt i32 %call, 2
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  %0 = load i8, i8* @kref_get.__warned, align 1, !tbaa !29, !range !31
  %tobool7 = trunc i8 %0 to i1
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %tobool14 = icmp ne i32 %lnot.ext13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.23.1160, i32 0, i32 0), i32 47)
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then
  %tobool23 = icmp ne i32 %lnot.ext13, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end
  store i8 1, i8* @kref_get.__warned, align 1, !tbaa !29
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock.695(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @hlist_add_head(%struct.hlist_node* %n, %struct.hlist_head* %h) #2 {
entry:
  %first1 = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %h, i32 0, i32 0
  %0 = load %struct.hlist_node*, %struct.hlist_node** %first1, align 8, !tbaa !580
  %next = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 0
  store %struct.hlist_node* %0, %struct.hlist_node** %next, align 8, !tbaa !567
  %tobool = icmp ne %struct.hlist_node* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %next2 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 0
  %pprev = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %0, i32 0, i32 1
  store %struct.hlist_node** %next2, %struct.hlist_node*** %pprev, align 8, !tbaa !566
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %first3 = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %h, i32 0, i32 0
  store %struct.hlist_node* %n, %struct.hlist_node** %first3, align 8, !tbaa !580
  %first4 = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %h, i32 0, i32 0
  %pprev5 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 1
  store %struct.hlist_node** %first4, %struct.hlist_node*** %pprev5, align 8, !tbaa !566
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_return.696(i32 %i, %struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #7, !srcloc !795
  %add = add nsw i32 %i, %0
  ret i32 %add
}

; Function Attrs: nounwind uwtable
define void @auth_domain_put(%struct.auth_domain.5097* %dom) #0 {
entry:
  %ref = getelementptr inbounds %struct.auth_domain.5097, %struct.auth_domain.5097* %dom, i32 0, i32 0
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %ref, i32 0, i32 0
  %call = call i32 @_atomic_dec_and_lock(%struct.atomic_t* %refcount, %struct.spinlock* @auth_domain_lock)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %hash = getelementptr inbounds %struct.auth_domain.5097, %struct.auth_domain.5097* %dom, i32 0, i32 1
  call void @hlist_del(%struct.hlist_node* %hash)
  %flavour = getelementptr inbounds %struct.auth_domain.5097, %struct.auth_domain.5097* %dom, i32 0, i32 3
  %0 = load %struct.auth_ops.5094*, %struct.auth_ops.5094** %flavour, align 8, !tbaa !796
  %domain_release = getelementptr inbounds %struct.auth_ops.5094, %struct.auth_ops.5094* %0, i32 0, i32 5
  %1 = load void (%struct.auth_domain.5097*)*, void (%struct.auth_domain.5097*)** %domain_release, align 8, !tbaa !797
  call void %1(%struct.auth_domain.5097* %dom)
  call void @spin_unlock.695(%struct.spinlock* @auth_domain_lock)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @hlist_del(%struct.hlist_node* %n) #2 {
entry:
  call void @__hlist_del.700(%struct.hlist_node* %n)
  %next = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 0
  store %struct.hlist_node* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 1048832 to i8*), i64 -2401263026318606336) to %struct.hlist_node*), %struct.hlist_node** %next, align 8, !tbaa !567
  %pprev = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 1
  store %struct.hlist_node** bitcast (i8* getelementptr (i8, i8* inttoptr (i64 2097664 to i8*), i64 -2401263026318606336) to %struct.hlist_node**), %struct.hlist_node*** %pprev, align 8, !tbaa !566
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__hlist_del.700(%struct.hlist_node* %n) #2 {
entry:
  %next1 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 0
  %0 = load %struct.hlist_node*, %struct.hlist_node** %next1, align 8, !tbaa !567
  %pprev2 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 1
  %1 = load %struct.hlist_node**, %struct.hlist_node*** %pprev2, align 8, !tbaa !566
  store %struct.hlist_node* %0, %struct.hlist_node** %1, align 8, !tbaa !28
  %tobool = icmp ne %struct.hlist_node* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %pprev3 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %0, i32 0, i32 1
  store %struct.hlist_node** %1, %struct.hlist_node*** %pprev3, align 8, !tbaa !566
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @svc_auth_unregister(i32 %flavor) #0 {
entry:
  call void @spin_lock.694(%struct.spinlock* @authtab_lock)
  %cmp = icmp ult i32 %flavor, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %idxprom = zext i32 %flavor to i64
  %arrayidx = getelementptr inbounds [8 x %struct.auth_ops.5094*], [8 x %struct.auth_ops.5094*]* @authtab, i64 0, i64 %idxprom
  store %struct.auth_ops.5094* null, %struct.auth_ops.5094** %arrayidx, align 8, !tbaa !28
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @spin_unlock.695(%struct.spinlock* @authtab_lock)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @svc_auth_register(i32 %flavor, %struct.auth_ops.5094* %aops) #0 {
entry:
  call void @spin_lock.694(%struct.spinlock* @authtab_lock)
  %cmp = icmp ult i32 %flavor, 8
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %idxprom = zext i32 %flavor to i64
  %arrayidx = getelementptr inbounds [8 x %struct.auth_ops.5094*], [8 x %struct.auth_ops.5094*]* @authtab, i64 0, i64 %idxprom
  %0 = load %struct.auth_ops.5094*, %struct.auth_ops.5094** %arrayidx, align 8, !tbaa !28
  %cmp1 = icmp eq %struct.auth_ops.5094* %0, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %idxprom2 = zext i32 %flavor to i64
  %arrayidx3 = getelementptr inbounds [8 x %struct.auth_ops.5094*], [8 x %struct.auth_ops.5094*]* @authtab, i64 0, i64 %idxprom2
  store %struct.auth_ops.5094* %aops, %struct.auth_ops.5094** %arrayidx3, align 8, !tbaa !28
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %rv.0 = phi i32 [ 0, %if.then ], [ -22, %land.lhs.true ], [ -22, %entry ]
  call void @spin_unlock.695(%struct.spinlock* @authtab_lock)
  ret i32 %rv.0
}

; Function Attrs: nounwind uwtable
define i32 @svc_set_client(%struct.svc_rqst.5096* %rqstp) #0 {
entry:
  %rq_authop = getelementptr inbounds %struct.svc_rqst.5096, %struct.svc_rqst.5096* %rqstp, i32 0, i32 10
  %0 = load %struct.auth_ops.5094*, %struct.auth_ops.5094** %rq_authop, align 8, !tbaa !688
  %set_client = getelementptr inbounds %struct.auth_ops.5094, %struct.auth_ops.5094* %0, i32 0, i32 6
  %1 = load i32 (%struct.svc_rqst.5096*)*, i32 (%struct.svc_rqst.5096*)** %set_client, align 8, !tbaa !798
  %call = call i32 %1(%struct.svc_rqst.5096* %rqstp)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @svc_authenticate(%struct.svc_rqst.5096* %rqstp, i32* %authp) #0 {
entry:
  store i32 0, i32* %authp, align 4, !tbaa !49
  %rq_arg = getelementptr inbounds %struct.svc_rqst.5096, %struct.svc_rqst.5096* %rqstp, i32 0, i32 16
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %call = call i32 @svc_getnl.704(%struct.iovec* %arrayidx)
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  call void @spin_lock.694(%struct.spinlock* @authtab_lock)
  %cmp = icmp uge i32 %call, 8
  br i1 %cmp, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %idxprom = zext i32 %call to i64
  %arrayidx5 = getelementptr inbounds [8 x %struct.auth_ops.5094*], [8 x %struct.auth_ops.5094*]* @authtab, i64 0, i64 %idxprom
  %2 = load %struct.auth_ops.5094*, %struct.auth_ops.5094** %arrayidx5, align 8, !tbaa !28
  %tobool6 = icmp ne %struct.auth_ops.5094* %2, null
  br i1 %tobool6, label %lor.lhs.false7, label %if.then9

lor.lhs.false7:                                   ; preds = %lor.lhs.false
  %owner = getelementptr inbounds %struct.auth_ops.5094, %struct.auth_ops.5094* %2, i32 0, i32 1
  %3 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !799
  %call8 = call zeroext i1 @try_module_get(%struct.module* %3)
  br i1 %call8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %lor.lhs.false7, %lor.lhs.false, %do.end
  call void @spin_unlock.695(%struct.spinlock* @authtab_lock)
  store i32 16777216, i32* %authp, align 4, !tbaa !49
  br label %cleanup

if.end10:                                         ; preds = %lor.lhs.false7
  call void @spin_unlock.695(%struct.spinlock* @authtab_lock)
  %rq_authop = getelementptr inbounds %struct.svc_rqst.5096, %struct.svc_rqst.5096* %rqstp, i32 0, i32 10
  store %struct.auth_ops.5094* %2, %struct.auth_ops.5094** %rq_authop, align 8, !tbaa !688
  %accept = getelementptr inbounds %struct.auth_ops.5094, %struct.auth_ops.5094* %2, i32 0, i32 3
  %accept11 = bitcast {}** %accept to i32 (%struct.svc_rqst.5096*, i32*)**
  %4 = load i32 (%struct.svc_rqst.5096*, i32*)*, i32 (%struct.svc_rqst.5096*, i32*)** %accept11, align 8, !tbaa !800
  %call12 = call i32 %4(%struct.svc_rqst.5096* %rqstp, i32* %authp)
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.then9
  %retval.0 = phi i32 [ 8, %if.then9 ], [ %call12, %if.end10 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @svc_getnl.704(%struct.iovec* %iov) #2 {
entry:
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  %0 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %1 = bitcast i8* %0 to i32*
  %incdec.ptr = getelementptr inbounds i32, i32* %1, i32 1
  %2 = load i32, i32* %1, align 4, !tbaa !49
  %3 = bitcast i32* %incdec.ptr to i8*
  %iov_base1 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  store i8* %3, i8** %iov_base1, align 8, !tbaa !147
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %4 = load i64, i64* %iov_len, align 8, !tbaa !149
  %sub = sub i64 %4, 4
  store i64 %sub, i64* %iov_len, align 8, !tbaa !149
  %call = call i32 @__fswab32.706(i32 %2) #3
  ret i32 %call
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__fswab32.706(i32 %val) #5 {
entry:
  %call = call i32 @__arch_swab32.707(i32 %val) #3
  ret i32 %call
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__arch_swab32.707(i32 %val) #5 {
entry:
  %0 = call i32 asm "bswapl $0", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %val) #3, !srcloc !801
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define i32 @svc_authorise(%struct.svc_rqst.5096* %rqstp) #0 {
entry:
  %rq_authop = getelementptr inbounds %struct.svc_rqst.5096, %struct.svc_rqst.5096* %rqstp, i32 0, i32 10
  %0 = load %struct.auth_ops.5094*, %struct.auth_ops.5094** %rq_authop, align 8, !tbaa !688
  %rq_authop1 = getelementptr inbounds %struct.svc_rqst.5096, %struct.svc_rqst.5096* %rqstp, i32 0, i32 10
  store %struct.auth_ops.5094* null, %struct.auth_ops.5094** %rq_authop1, align 8, !tbaa !688
  %tobool = icmp ne %struct.auth_ops.5094* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %release = getelementptr inbounds %struct.auth_ops.5094, %struct.auth_ops.5094* %0, i32 0, i32 4
  %1 = load i32 (%struct.svc_rqst.5096*)*, i32 (%struct.svc_rqst.5096*)** %release, align 8, !tbaa !802
  %call = call i32 %1(%struct.svc_rqst.5096* %rqstp)
  %owner = getelementptr inbounds %struct.auth_ops.5094, %struct.auth_ops.5094* %0, i32 0, i32 1
  %2 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !799
  call void @module_put(%struct.module* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rv.0 = phi i32 [ %call, %if.then ], [ 0, %entry ]
  ret i32 %rv.0
}

; Function Attrs: nounwind uwtable
define internal i32 @svcauth_unix_accept(%struct.svc_rqst.5259* %rqstp, i32* %authp) #0 {
entry:
  %rq_arg = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 16
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %rq_res = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 17
  %head1 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head1, i64 0, i64 0
  %rq_cred = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 11
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %0 = load i64, i64* %iov_len, align 8, !tbaa !149
  %conv = trunc i64 %0 to i32
  %cr_group_info = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 2
  store %struct.group_info* null, %struct.group_info** %cr_group_info, align 8, !tbaa !803
  %cr_principal = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 4
  store i8* null, i8** %cr_principal, align 8, !tbaa !804
  %rq_client = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 35
  store %struct.auth_domain.5260* null, %struct.auth_domain.5260** %rq_client, align 8, !tbaa !805
  %sub = sub nsw i32 %conv, 12
  %cmp = icmp slt i32 %sub, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @svc_getu32.748(%struct.iovec* %arrayidx)
  %call4 = call i32 @svc_getu32.748(%struct.iovec* %arrayidx)
  %call5 = call i32 @svc_getnl.749(%struct.iovec* %arrayidx)
  %add = add i32 %call5, 3
  %shr = lshr i32 %add, 2
  %cmp6 = icmp ugt i32 %shr, 64
  br i1 %cmp6, label %badcred, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %add8 = add i32 %shr, 3
  %mul = mul i32 %add8, 4
  %sub9 = sub i32 %sub, %mul
  %cmp10 = icmp slt i32 %sub9, 0
  br i1 %cmp10, label %badcred, label %if.end13

if.end13:                                         ; preds = %lor.lhs.false
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  %1 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %2 = bitcast i8* %1 to i32*
  %idx.ext = zext i32 %shr to i64
  %add.ptr = getelementptr inbounds i32, i32* %2, i64 %idx.ext
  %3 = bitcast i32* %add.ptr to i8*
  %iov_base14 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  store i8* %3, i8** %iov_base14, align 8, !tbaa !147
  %mul15 = mul i32 %shr, 4
  %conv16 = zext i32 %mul15 to i64
  %iov_len17 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %4 = load i64, i64* %iov_len17, align 8, !tbaa !149
  %sub18 = sub i64 %4, %conv16
  store i64 %sub18, i64* %iov_len17, align 8, !tbaa !149
  %call19 = call i32 @svc_getnl.749(%struct.iovec* %arrayidx)
  %call20 = call i32 @make_kuid(i32 %call19)
  %cr_uid = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 0
  store i32 %call20, i32* %cr_uid, align 8, !tbaa !806
  %call21 = call i32 @svc_getnl.749(%struct.iovec* %arrayidx)
  %call22 = call i32 @make_kgid(i32 %call21)
  %cr_gid = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 1
  store i32 %call22, i32* %cr_gid, align 4, !tbaa !807
  %call23 = call i32 @svc_getnl.749(%struct.iovec* %arrayidx)
  %cmp24 = icmp ugt i32 %call23, 16
  br i1 %cmp24, label %badcred, label %lor.lhs.false26

lor.lhs.false26:                                  ; preds = %if.end13
  %add27 = add i32 %call23, 2
  %mul28 = mul i32 %add27, 4
  %sub29 = sub i32 %sub9, %mul28
  %cmp30 = icmp slt i32 %sub29, 0
  br i1 %cmp30, label %badcred, label %if.end33

if.end33:                                         ; preds = %lor.lhs.false26
  %call34 = call %struct.group_info* @groups_alloc(i32 %call23)
  %cr_group_info35 = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 2
  store %struct.group_info* %call34, %struct.group_info** %cr_group_info35, align 8, !tbaa !803
  %cr_group_info36 = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 2
  %5 = load %struct.group_info*, %struct.group_info** %cr_group_info36, align 8, !tbaa !803
  %cmp37 = icmp eq %struct.group_info* %5, null
  br i1 %cmp37, label %cleanup, label %if.end40

if.end40:                                         ; preds = %if.end33
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end40
  %i.0 = phi i32 [ 0, %if.end40 ], [ %inc, %for.body ]
  %cmp41 = icmp ult i32 %i.0, %call23
  br i1 %cmp41, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call43 = call i32 @svc_getnl.749(%struct.iovec* %arrayidx)
  %call44 = call i32 @make_kgid(i32 %call43)
  %cr_group_info45 = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 2
  %6 = load %struct.group_info*, %struct.group_info** %cr_group_info45, align 8, !tbaa !803
  %blocks = getelementptr inbounds %struct.group_info, %struct.group_info* %6, i32 0, i32 4
  %div = udiv i32 %i.0, 1024
  %idxprom = zext i32 %div to i64
  %arrayidx46 = getelementptr inbounds [0 x i32*], [0 x i32*]* %blocks, i64 0, i64 %idxprom
  %7 = load i32*, i32** %arrayidx46, align 8, !tbaa !28
  %rem = urem i32 %i.0, 1024
  %idxprom47 = zext i32 %rem to i64
  %arrayidx48 = getelementptr inbounds i32, i32* %7, i64 %idxprom47
  store i32 %call44, i32* %arrayidx48, align 4, !tbaa !49
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call49 = call i32 @svc_getu32.748(%struct.iovec* %arrayidx)
  %cmp50 = icmp ne i32 %call49, 0
  br i1 %cmp50, label %if.then56, label %lor.lhs.false52

lor.lhs.false52:                                  ; preds = %for.end
  %call53 = call i32 @svc_getu32.748(%struct.iovec* %arrayidx)
  %cmp54 = icmp ne i32 %call53, 0
  br i1 %cmp54, label %if.then56, label %if.end57

if.then56:                                        ; preds = %lor.lhs.false52, %for.end
  store i32 50331648, i32* %authp, align 4, !tbaa !49
  br label %cleanup

if.end57:                                         ; preds = %lor.lhs.false52
  call void @svc_putnl.750(%struct.iovec* %arrayidx2, i32 0)
  call void @svc_putnl.750(%struct.iovec* %arrayidx2, i32 0)
  %rq_cred58 = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 11
  %cr_flavor = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred58, i32 0, i32 3
  store i32 1, i32* %cr_flavor, align 8, !tbaa !808
  br label %cleanup

badcred:                                          ; preds = %lor.lhs.false26, %if.end13, %lor.lhs.false, %if.end
  store i32 16777216, i32* %authp, align 4, !tbaa !49
  br label %cleanup

cleanup:                                          ; preds = %badcred, %if.end57, %if.then56, %if.end33, %entry
  %retval.0 = phi i32 [ 8, %badcred ], [ 8, %if.then56 ], [ 5, %if.end57 ], [ 1, %entry ], [ 7, %if.end33 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @svcauth_unix_release(%struct.svc_rqst.5259* %rqstp) #0 {
entry:
  %rq_client = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 35
  %0 = load %struct.auth_domain.5260*, %struct.auth_domain.5260** %rq_client, align 8, !tbaa !805
  %tobool = icmp ne %struct.auth_domain.5260* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %rq_client1 = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 35
  %1 = load %struct.auth_domain.5260*, %struct.auth_domain.5260** %rq_client1, align 8, !tbaa !805
  call void bitcast (void (%struct.auth_domain.5097*)* @auth_domain_put to void (%struct.auth_domain.5260*)*)(%struct.auth_domain.5260* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rq_client2 = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 35
  store %struct.auth_domain.5260* null, %struct.auth_domain.5260** %rq_client2, align 8, !tbaa !805
  %rq_cred = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 11
  %cr_group_info = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 2
  %2 = load %struct.group_info*, %struct.group_info** %cr_group_info, align 8, !tbaa !809
  %tobool3 = icmp ne %struct.group_info* %2, null
  br i1 %tobool3, label %do.body, label %if.end12

do.body:                                          ; preds = %if.end
  %rq_cred5 = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 11
  %cr_group_info6 = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred5, i32 0, i32 2
  %3 = load %struct.group_info*, %struct.group_info** %cr_group_info6, align 8, !tbaa !809
  %usage = getelementptr inbounds %struct.group_info, %struct.group_info* %3, i32 0, i32 0
  %call = call i32 @atomic_dec_and_test.717(%struct.atomic_t* %usage)
  %tobool7 = icmp ne i32 %call, 0
  br i1 %tobool7, label %if.then8, label %if.end12

if.then8:                                         ; preds = %do.body
  %rq_cred9 = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 11
  %cr_group_info10 = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred9, i32 0, i32 2
  %4 = load %struct.group_info*, %struct.group_info** %cr_group_info10, align 8, !tbaa !809
  call void @groups_free(%struct.group_info* %4)
  br label %if.end12

if.end12:                                         ; preds = %if.then8, %do.body, %if.end
  %rq_cred13 = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 11
  %cr_group_info14 = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred13, i32 0, i32 2
  store %struct.group_info* null, %struct.group_info** %cr_group_info14, align 8, !tbaa !809
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @svcauth_unix_domain_release(%struct.auth_domain.5260* %dom) #0 {
entry:
  %0 = bitcast %struct.auth_domain.5260* %dom to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.unix_domain*
  %name = getelementptr inbounds %struct.auth_domain.5260, %struct.auth_domain.5260* %dom, i32 0, i32 2
  %2 = load i8*, i8** %name, align 8, !tbaa !793
  call void @kfree(i8* %2)
  %3 = bitcast %struct.unix_domain* %1 to i8*
  call void @kfree(i8* %3)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @svcauth_unix_set_client(%struct.svc_rqst.5259* %rqstp) #0 {
entry:
  %sin6_storage = alloca %struct.sockaddr_in6, align 4
  %rq_cred = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 11
  %rq_xprt = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 2
  %0 = load %struct.svc_xprt.5727*, %struct.svc_xprt.5727** %rq_xprt, align 8, !tbaa !635
  %xpt_net = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %0, i32 0, i32 18
  %1 = load %struct.net*, %struct.net** %xpt_net, align 8, !tbaa !810
  %2 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.713(%struct.net* %1, i32 %2)
  %3 = bitcast i8* %call to %struct.sunrpc_net*
  %rq_addr = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 3
  %ss_family = getelementptr inbounds %struct.__kernel_sockaddr_storage, %struct.__kernel_sockaddr_storage* %rq_addr, i32 0, i32 0
  %4 = load i16, i16* %ss_family, align 8, !tbaa !811
  %conv = zext i16 %4 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb2, label %do.body

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %do.body

sw.bb:                                            ; preds = %LeafBlock
  %call1 = call %struct.sockaddr_in* @svc_addr_in(%struct.svc_rqst.5259* %rqstp)
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %call1, i32 0, i32 2
  %s_addr = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %sin_addr, i32 0, i32 0
  %5 = load i32, i32* %s_addr, align 4, !tbaa !374
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6_storage, i32 0, i32 3
  call void @ipv6_addr_set_v4mapped(i32 %5, %struct.in6_addr* %sin6_addr)
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock1
  %call3 = call %struct.sockaddr_in6* @svc_addr_in6(%struct.svc_rqst.5259* %rqstp)
  br label %sw.epilog

do.body:                                          ; preds = %LeafBlock, %LeafBlock1
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.714, i32 0, i32 0), i32 678, i64 12) #7, !srcloc !812
  br label %do.body4

do.body4:                                         ; preds = %do.body4, %do.body
  br label %do.body4

sw.epilog:                                        ; preds = %sw.bb2, %sw.bb
  %sin6.0 = phi %struct.sockaddr_in6* [ %sin6_storage, %sw.bb ], [ %call3, %sw.bb2 ]
  %rq_client = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 35
  store %struct.auth_domain.5260* null, %struct.auth_domain.5260** %rq_client, align 8, !tbaa !805
  %rq_proc = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 26
  %6 = load i32, i32* %rq_proc, align 4, !tbaa !658
  %cmp = icmp eq i32 %6, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %sw.epilog
  %call8 = call %struct.ip_map* @ip_map_cached_get(%struct.svc_xprt.5727* %0)
  %cmp9 = icmp eq %struct.ip_map* %call8, null
  br i1 %cmp9, label %if.then11, label %if.end14

if.then11:                                        ; preds = %if.end
  %ip_map_cache = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %3, i32 0, i32 1
  %7 = load %struct.cache_detail*, %struct.cache_detail** %ip_map_cache, align 8, !tbaa !813
  %rq_server = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 7
  %8 = load %struct.svc_serv.5729*, %struct.svc_serv.5729** %rq_server, align 8, !tbaa !642
  %sv_program = getelementptr inbounds %struct.svc_serv.5729, %struct.svc_serv.5729* %8, i32 0, i32 0
  %9 = load %struct.svc_program.5742*, %struct.svc_program.5742** %sv_program, align 8, !tbaa !728
  %pg_class = getelementptr inbounds %struct.svc_program.5742, %struct.svc_program.5742* %9, i32 0, i32 7
  %10 = load i8*, i8** %pg_class, align 8, !tbaa !815
  %sin6_addr12 = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6.0, i32 0, i32 3
  %call13 = call %struct.ip_map* @__ip_map_lookup(%struct.cache_detail* %7, i8* %10, %struct.in6_addr* %sin6_addr12)
  br label %if.end14

if.end14:                                         ; preds = %if.then11, %if.end
  %ipm.0 = phi %struct.ip_map* [ %call13, %if.then11 ], [ %call8, %if.end ]
  %cmp15 = icmp eq %struct.ip_map* %ipm.0, null
  br i1 %cmp15, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end14
  %ip_map_cache19 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %3, i32 0, i32 1
  %11 = load %struct.cache_detail*, %struct.cache_detail** %ip_map_cache19, align 8, !tbaa !813
  %h = getelementptr inbounds %struct.ip_map, %struct.ip_map* %ipm.0, i32 0, i32 0
  %rq_chandle = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 33
  %call20 = call i32 @cache_check(%struct.cache_detail* %11, %struct.cache_head* %h, %struct.cache_req* %rq_chandle)
  %Pivot17 = icmp slt i32 %call20, -2
  br i1 %Pivot17, label %NodeBlock8, label %NodeBlock14

NodeBlock14:                                      ; preds = %if.end18
  %Pivot15 = icmp slt i32 %call20, 0
  br i1 %Pivot15, label %LeafBlock10, label %LeafBlock12

LeafBlock12:                                      ; preds = %NodeBlock14
  %SwitchLeaf13 = icmp eq i32 %call20, 0
  br i1 %SwitchLeaf13, label %sw.bb31, label %do.body22

LeafBlock10:                                      ; preds = %NodeBlock14
  %SwitchLeaf11 = icmp eq i32 %call20, -2
  br i1 %SwitchLeaf11, label %cleanup, label %do.body22

NodeBlock8:                                       ; preds = %if.end18
  %Pivot9 = icmp slt i32 %call20, -11
  br i1 %Pivot9, label %LeafBlock4, label %LeafBlock6

LeafBlock6:                                       ; preds = %NodeBlock8
  %SwitchLeaf7 = icmp eq i32 %call20, -11
  br i1 %SwitchLeaf7, label %cleanup, label %do.body22

LeafBlock4:                                       ; preds = %NodeBlock8
  %SwitchLeaf5 = icmp eq i32 %call20, -110
  br i1 %SwitchLeaf5, label %cleanup, label %do.body22

do.body22:                                        ; preds = %LeafBlock4, %LeafBlock6, %LeafBlock10, %LeafBlock12
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.714, i32 0, i32 0), i32 695, i64 12) #7, !srcloc !816
  br label %do.body23

do.body23:                                        ; preds = %do.body23, %do.body22
  br label %do.body23

sw.bb31:                                          ; preds = %LeafBlock12
  %m_client = getelementptr inbounds %struct.ip_map, %struct.ip_map* %ipm.0, i32 0, i32 3
  %12 = load %struct.unix_domain*, %struct.unix_domain** %m_client, align 8, !tbaa !817
  %h32 = getelementptr inbounds %struct.unix_domain, %struct.unix_domain* %12, i32 0, i32 0
  %rq_client33 = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 35
  store %struct.auth_domain.5260* %h32, %struct.auth_domain.5260** %rq_client33, align 8, !tbaa !805
  %rq_client34 = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 35
  %13 = load %struct.auth_domain.5260*, %struct.auth_domain.5260** %rq_client34, align 8, !tbaa !805
  %ref = getelementptr inbounds %struct.auth_domain.5260, %struct.auth_domain.5260* %13, i32 0, i32 0
  call void @kref_get.715(%struct.arch_spinlock* %ref)
  call void @ip_map_cached_put(%struct.svc_xprt.5727* %0, %struct.ip_map* %ipm.0)
  %cr_uid = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 0
  %14 = load i32, i32* %cr_uid, align 8, !tbaa !806
  %call36 = call %struct.group_info* @unix_gid_find(i32 %14, %struct.svc_rqst.5259* %rqstp)
  %15 = bitcast %struct.group_info* %call36 to i8*
  %call37 = call i64 @PTR_ERR.716(i8* %15)
  %Pivot28 = icmp slt i64 %call37, -11
  br i1 %Pivot28, label %LeafBlock19, label %NodeBlock25

NodeBlock25:                                      ; preds = %sw.bb31
  %Pivot26 = icmp slt i64 %call37, -2
  br i1 %Pivot26, label %LeafBlock21, label %LeafBlock23

LeafBlock23:                                      ; preds = %NodeBlock25
  %SwitchLeaf24 = icmp eq i64 %call37, -2
  br i1 %SwitchLeaf24, label %cleanup, label %do.body41

LeafBlock21:                                      ; preds = %NodeBlock25
  %SwitchLeaf22 = icmp eq i64 %call37, -11
  br i1 %SwitchLeaf22, label %cleanup, label %do.body41

LeafBlock19:                                      ; preds = %sw.bb31
  %SwitchLeaf20 = icmp eq i64 %call37, -108
  br i1 %SwitchLeaf20, label %cleanup, label %do.body41

do.body41:                                        ; preds = %LeafBlock19, %LeafBlock21, %LeafBlock23
  %cr_group_info = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 2
  %16 = load %struct.group_info*, %struct.group_info** %cr_group_info, align 8, !tbaa !803
  %usage = getelementptr inbounds %struct.group_info, %struct.group_info* %16, i32 0, i32 0
  %call42 = call i32 @atomic_dec_and_test.717(%struct.atomic_t* %usage)
  %tobool = icmp ne i32 %call42, 0
  br i1 %tobool, label %if.then43, label %do.end47

if.then43:                                        ; preds = %do.body41
  %cr_group_info44 = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 2
  %17 = load %struct.group_info*, %struct.group_info** %cr_group_info44, align 8, !tbaa !803
  call void @groups_free(%struct.group_info* %17)
  br label %do.end47

do.end47:                                         ; preds = %if.then43, %do.body41
  %cr_group_info48 = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 2
  store %struct.group_info* %call36, %struct.group_info** %cr_group_info48, align 8, !tbaa !803
  br label %cleanup

cleanup:                                          ; preds = %do.end47, %LeafBlock19, %LeafBlock21, %LeafBlock23, %LeafBlock4, %LeafBlock6, %LeafBlock10, %if.end14, %sw.epilog
  %retval.0 = phi i32 [ 5, %sw.epilog ], [ 8, %if.end14 ], [ 7, %LeafBlock4 ], [ 6, %LeafBlock6 ], [ 8, %LeafBlock10 ], [ 6, %LeafBlock21 ], [ 7, %LeafBlock19 ], [ 5, %LeafBlock23 ], [ 5, %do.end47 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @net_generic.713(%struct.net* %net, i32 %id) #2 {
entry:
  call void @rcu_read_lock.732()
  %gen = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 37
  %0 = load volatile %struct.net_generic*, %struct.net_generic** %gen, align 16, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.body8

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @net_generic.__warned.733, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %do.body8, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held.734()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.body8, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @net_generic.__warned.733, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 40, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.body8

do.body8:                                         ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %cmp = icmp eq i32 %id, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.body8
  %len = getelementptr inbounds %struct.net_generic, %struct.net_generic* %0, i32 0, i32 0
  %2 = load i32, i32* %len, align 8, !tbaa !176
  %cmp9 = icmp ugt i32 %id, %2
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %do.body8
  %3 = phi i1 [ true, %do.body8 ], [ %cmp9, %lor.rhs ]
  %lnot = xor i1 %3, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %do.body13, label %do.end21

do.body13:                                        ; preds = %lor.end
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 41, i64 12) #7, !srcloc !820
  br label %do.body14

do.body14:                                        ; preds = %do.body14, %do.body13
  br label %do.body14

do.end21:                                         ; preds = %lor.end
  %ptr22 = getelementptr inbounds %struct.net_generic, %struct.net_generic* %0, i32 0, i32 2
  %sub = sub nsw i32 %id, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [0 x i8*], [0 x i8*]* %ptr22, i64 0, i64 %idxprom
  %4 = load i8*, i8** %arrayidx, align 8, !tbaa !28
  call void @rcu_read_unlock.737()
  %tobool24 = icmp ne i8* %4, null
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %do.body35, label %do.end43

do.body35:                                        ; preds = %do.end21
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 45, i64 12) #7, !srcloc !821
  br label %do.body36

do.body36:                                        ; preds = %do.body36, %do.body35
  br label %do.body36

do.end43:                                         ; preds = %do.end21
  ret i8* %4
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr_in* @svc_addr_in(%struct.svc_rqst.5259* %rqst) #2 {
entry:
  %rq_addr = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqst, i32 0, i32 3
  %0 = bitcast %struct.__kernel_sockaddr_storage* %rq_addr to %struct.sockaddr_in*
  ret %struct.sockaddr_in* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @ipv6_addr_set_v4mapped(i32 %addr, %struct.in6_addr* %v4mapped) #2 {
entry:
  call void @ipv6_addr_set(%struct.in6_addr* %v4mapped, i32 0, i32 0, i32 -65536, i32 %addr)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr_in6* @svc_addr_in6(%struct.svc_rqst.5259* %rqst) #2 {
entry:
  %rq_addr = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqst, i32 0, i32 3
  %0 = bitcast %struct.__kernel_sockaddr_storage* %rq_addr to %struct.sockaddr_in6*
  ret %struct.sockaddr_in6* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.ip_map* @ip_map_cached_get(%struct.svc_xprt.5727* %xprt) #2 {
entry:
  %xpt_flags = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %xprt, i32 0, i32 5
  %0 = load volatile i64, i64* %xpt_flags, align 8, !tbaa !88
  %and.i = and i64 4096, %0
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  %xpt_lock = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %xprt, i32 0, i32 9
  call void @spin_lock.727(%struct.spinlock* %xpt_lock)
  %xpt_auth_cache = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %xprt, i32 0, i32 10
  %1 = load i8*, i8** %xpt_auth_cache, align 8, !tbaa !822
  %2 = bitcast i8* %1 to %struct.ip_map*
  %cmp = icmp ne %struct.ip_map* %2, null
  br i1 %cmp, label %if.then4, label %if.end14

if.then4:                                         ; preds = %if.then
  %h = getelementptr inbounds %struct.ip_map, %struct.ip_map* %2, i32 0, i32 0
  %call5 = call i32 @cache_valid(%struct.cache_head* %h)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.end, label %if.then7

if.then7:                                         ; preds = %if.then4
  %xpt_net = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %xprt, i32 0, i32 18
  %3 = load %struct.net*, %struct.net** %xpt_net, align 8, !tbaa !810
  %4 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call8 = call i8* @net_generic.713(%struct.net* %3, i32 %4)
  %5 = bitcast i8* %call8 to %struct.sunrpc_net*
  %xpt_auth_cache9 = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %xprt, i32 0, i32 10
  store i8* null, i8** %xpt_auth_cache9, align 8, !tbaa !822
  %xpt_lock10 = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %xprt, i32 0, i32 9
  call void @spin_unlock.728(%struct.spinlock* %xpt_lock10)
  %h11 = getelementptr inbounds %struct.ip_map, %struct.ip_map* %2, i32 0, i32 0
  %ip_map_cache = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %5, i32 0, i32 1
  %6 = load %struct.cache_detail*, %struct.cache_detail** %ip_map_cache, align 8, !tbaa !813
  call void @cache_put(%struct.cache_head* %h11, %struct.cache_detail* %6)
  br label %cleanup

if.end:                                           ; preds = %if.then4
  %h12 = getelementptr inbounds %struct.ip_map, %struct.ip_map* %2, i32 0, i32 0
  call void @cache_get(%struct.cache_head* %h12)
  br label %if.end14

if.end14:                                         ; preds = %if.end, %if.then
  %xpt_lock15 = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %xprt, i32 0, i32 9
  call void @spin_unlock.728(%struct.spinlock* %xpt_lock15)
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %if.then7, %entry
  %retval.0 = phi %struct.ip_map* [ null, %if.then7 ], [ %2, %if.end14 ], [ null, %entry ]
  ret %struct.ip_map* %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.ip_map* @__ip_map_lookup(%struct.cache_detail* %cd, i8* %class, %struct.in6_addr* %addr) #0 {
entry:
  %ip = alloca %struct.ip_map, align 8
  %m_class = getelementptr inbounds %struct.ip_map, %struct.ip_map* %ip, i32 0, i32 1
  %arraydecay = getelementptr inbounds [8 x i8], [8 x i8]* %m_class, i32 0, i32 0
  %call = call i8* @strcpy(i8* %arraydecay, i8* %class)
  %m_addr = getelementptr inbounds %struct.ip_map, %struct.ip_map* %ip, i32 0, i32 2
  %0 = bitcast %struct.in6_addr* %m_addr to i8*
  %1 = bitcast %struct.in6_addr* %addr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 16, i32 4, i1 false), !tbaa.struct !774
  %h = getelementptr inbounds %struct.ip_map, %struct.ip_map* %ip, i32 0, i32 0
  %call1 = call i64 @hash_str.731(i8* %class, i32 8)
  %call2 = call i32 @hash_ip6(%struct.in6_addr* %addr)
  %conv = sext i32 %call2 to i64
  %xor = xor i64 %call1, %conv
  %conv3 = trunc i64 %xor to i32
  %call4 = call %struct.cache_head* @sunrpc_cache_lookup(%struct.cache_detail* %cd, %struct.cache_head* %h, i32 %conv3)
  %tobool = icmp ne %struct.cache_head* %call4, null
  %2 = bitcast %struct.cache_head* %call4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.ip_map*
  %retval.0 = select i1 %tobool, %struct.ip_map* %3, %struct.ip_map* null
  ret %struct.ip_map* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_get.715(%struct.arch_spinlock* %kref) #2 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_add_return.729(i32 1, %struct.atomic_t* %refcount)
  %cmp = icmp slt i32 %call, 2
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  %0 = load i8, i8* @kref_get.__warned.730, align 1, !tbaa !29, !range !31
  %tobool7 = trunc i8 %0 to i1
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %tobool14 = icmp ne i32 %lnot.ext13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.23.1160, i32 0, i32 0), i32 47)
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then
  %tobool23 = icmp ne i32 %lnot.ext13, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end
  store i8 1, i8* @kref_get.__warned.730, align 1, !tbaa !29
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @ip_map_cached_put(%struct.svc_xprt.5727* %xprt, %struct.ip_map* %ipm) #2 {
entry:
  %xpt_flags = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %xprt, i32 0, i32 5
  %0 = load volatile i64, i64* %xpt_flags, align 8, !tbaa !88
  %and.i = and i64 4096, %0
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %xpt_lock = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %xprt, i32 0, i32 9
  call void @spin_lock.727(%struct.spinlock* %xpt_lock)
  %xpt_auth_cache = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %xprt, i32 0, i32 10
  %1 = load i8*, i8** %xpt_auth_cache, align 8, !tbaa !822
  %cmp = icmp eq i8* %1, null
  br i1 %cmp, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %2 = bitcast %struct.ip_map* %ipm to i8*
  %xpt_auth_cache5 = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %xprt, i32 0, i32 10
  store i8* %2, i8** %xpt_auth_cache5, align 8, !tbaa !822
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %ipm.addr.0 = phi %struct.ip_map* [ null, %if.then4 ], [ %ipm, %if.then ]
  %xpt_lock6 = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %xprt, i32 0, i32 9
  call void @spin_unlock.728(%struct.spinlock* %xpt_lock6)
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  %ipm.addr.1 = phi %struct.ip_map* [ %ipm.addr.0, %if.end ], [ %ipm, %entry ]
  %tobool8 = icmp ne %struct.ip_map* %ipm.addr.1, null
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end7
  %xpt_net = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %xprt, i32 0, i32 18
  %3 = load %struct.net*, %struct.net** %xpt_net, align 8, !tbaa !810
  %4 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call10 = call i8* @net_generic.713(%struct.net* %3, i32 %4)
  %5 = bitcast i8* %call10 to %struct.sunrpc_net*
  %h = getelementptr inbounds %struct.ip_map, %struct.ip_map* %ipm.addr.1, i32 0, i32 0
  %ip_map_cache = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %5, i32 0, i32 1
  %6 = load %struct.cache_detail*, %struct.cache_detail** %ip_map_cache, align 8, !tbaa !813
  call void @cache_put(%struct.cache_head* %h, %struct.cache_detail* %6)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end7
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.group_info* @unix_gid_find(i32 %uid, %struct.svc_rqst.5259* %rqstp) #0 {
entry:
  %rq_xprt = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 2
  %0 = load %struct.svc_xprt.5727*, %struct.svc_xprt.5727** %rq_xprt, align 8, !tbaa !635
  %xpt_net = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %0, i32 0, i32 18
  %1 = load %struct.net*, %struct.net** %xpt_net, align 8, !tbaa !810
  %2 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.713(%struct.net* %1, i32 %2)
  %3 = bitcast i8* %call to %struct.sunrpc_net*
  %unix_gid_cache = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %3, i32 0, i32 2
  %4 = load %struct.cache_detail*, %struct.cache_detail** %unix_gid_cache, align 8, !tbaa !823
  %call1 = call %struct.unix_gid* @unix_gid_lookup(%struct.cache_detail* %4, i32 %uid)
  %tobool = icmp ne %struct.unix_gid* %call1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call2 = call i8* @ERR_PTR.718(i64 -11)
  %5 = bitcast i8* %call2 to %struct.group_info*
  br label %cleanup

if.end:                                           ; preds = %entry
  %unix_gid_cache3 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %3, i32 0, i32 2
  %6 = load %struct.cache_detail*, %struct.cache_detail** %unix_gid_cache3, align 8, !tbaa !823
  %h = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %call1, i32 0, i32 0
  %rq_chandle = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 33
  %call4 = call i32 @cache_check(%struct.cache_detail* %6, %struct.cache_head* %h, %struct.cache_req* %rq_chandle)
  %Pivot6 = icmp slt i32 %call4, -2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %call4, 0
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %call4, 0
  br i1 %SwitchLeaf4, label %sw.bb8, label %sw.default

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %call4, -2
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.default

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %call4, -110
  br i1 %SwitchLeaf, label %sw.bb6, label %sw.default

sw.bb:                                            ; preds = %LeafBlock1
  %call5 = call i8* @ERR_PTR.718(i64 -2)
  %7 = bitcast i8* %call5 to %struct.group_info*
  br label %cleanup

sw.bb6:                                           ; preds = %LeafBlock
  %call7 = call i8* @ERR_PTR.718(i64 -108)
  %8 = bitcast i8* %call7 to %struct.group_info*
  br label %cleanup

sw.bb8:                                           ; preds = %LeafBlock3
  %gi9 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %call1, i32 0, i32 2
  %9 = load %struct.group_info*, %struct.group_info** %gi9, align 8, !tbaa !824
  %call10 = call %struct.group_info* @get_group_info.719(%struct.group_info* %9)
  %h11 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %call1, i32 0, i32 0
  %unix_gid_cache12 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %3, i32 0, i32 2
  %10 = load %struct.cache_detail*, %struct.cache_detail** %unix_gid_cache12, align 8, !tbaa !823
  call void @cache_put(%struct.cache_head* %h11, %struct.cache_detail* %10)
  br label %cleanup

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  %call13 = call i8* @ERR_PTR.718(i64 -11)
  %11 = bitcast i8* %call13 to %struct.group_info*
  br label %cleanup

cleanup:                                          ; preds = %sw.default, %sw.bb8, %sw.bb6, %sw.bb, %if.then
  %retval.0 = phi %struct.group_info* [ %8, %sw.bb6 ], [ %11, %sw.default ], [ %7, %sw.bb ], [ %call10, %sw.bb8 ], [ %5, %if.then ]
  ret %struct.group_info* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR.716(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_dec_and_test.717(%struct.atomic_t* %v) #2 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0; sete $1", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32* %counter) #7, !srcloc !826
  %0 = load i8, i8* %c, align 1, !tbaa !166
  %conv = zext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define internal %struct.unix_gid* @unix_gid_lookup(%struct.cache_detail* %cd, i32 %uid) #0 {
entry:
  %ug = alloca %struct.unix_gid, align 8
  %uid1 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %ug, i32 0, i32 1
  store i32 %uid, i32* %uid1, align 8, !tbaa !827
  %h = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %ug, i32 0, i32 0
  %call = call i32 @unix_gid_hash(i32 %uid)
  %call2 = call %struct.cache_head* @sunrpc_cache_lookup(%struct.cache_detail* %cd, %struct.cache_head* %h, i32 %call)
  %tobool = icmp ne %struct.cache_head* %call2, null
  %0 = bitcast %struct.cache_head* %call2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.unix_gid*
  %retval.0 = select i1 %tobool, %struct.unix_gid* %1, %struct.unix_gid* null
  ret %struct.unix_gid* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR.718(i64 %error) #2 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.group_info* @get_group_info.719(%struct.group_info* %gi) #2 {
entry:
  %usage = getelementptr inbounds %struct.group_info, %struct.group_info* %gi, i32 0, i32 0
  call void @atomic_inc.722(%struct.atomic_t* %usage)
  ret %struct.group_info* %gi
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @cache_put(%struct.cache_head* %h, %struct.cache_detail* %cd) #2 {
entry:
  %ref = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 3
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %ref, i32 0, i32 0
  %call = call i32 @atomic_read.720(%struct.atomic_t* %refcount)
  %cmp = icmp sle i32 %call, 2
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %expiry_time = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 1
  %0 = load i64, i64* %expiry_time, align 8, !tbaa !828
  %nextcheck = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 18
  %1 = load i64, i64* %nextcheck, align 8, !tbaa !829
  %cmp1 = icmp slt i64 %0, %1
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %expiry_time2 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 1
  %2 = load i64, i64* %expiry_time2, align 8, !tbaa !828
  %nextcheck3 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 18
  store i64 %2, i64* %nextcheck3, align 8, !tbaa !829
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %ref4 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 3
  %cache_put = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 6
  %3 = load void (%struct.arch_spinlock*)*, void (%struct.arch_spinlock*)** %cache_put, align 8, !tbaa !831
  call void @kref_put(%struct.arch_spinlock* %ref4, void (%struct.arch_spinlock*)* %3)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read.720(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !49
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* %release) #2 {
entry:
  call void @kref_sub(%struct.arch_spinlock* %kref, i32 1, void (%struct.arch_spinlock*)* %release)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_sub(%struct.arch_spinlock* %kref, i32 %count, void (%struct.arch_spinlock*)* %release) #2 {
entry:
  %cmp = icmp eq void (%struct.arch_spinlock*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.23.1160, i32 0, i32 0), i32 71)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_sub_and_test(i32 %count, %struct.atomic_t* %refcount)
  %tobool14 = icmp ne i32 %call, 0
  br i1 %tobool14, label %if.then15, label %return

if.then15:                                        ; preds = %if.end
  call void %release(%struct.arch_spinlock* %kref)
  br label %return

return:                                           ; preds = %if.then15, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_sub_and_test(i32 %i, %struct.atomic_t* %v) #2 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subl $2,$0; sete $1", "=*m,=*qm,ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32 %i, i32* %counter) #7, !srcloc !832
  %0 = load i8, i8* %c, align 1, !tbaa !166
  %conv = zext i8 %0 to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.722(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !833
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @unix_gid_hash(i32 %uid) #0 {
entry:
  %call = call i32 @from_kuid.723(i32 %uid)
  %conv = zext i32 %call to i64
  %shl.i = shl i64 %conv, 18
  %sub.i = sub i64 %conv, %shl.i
  %shl1.i = shl i64 %shl.i, 33
  %sub2.i = sub i64 %sub.i, %shl1.i
  %shl3.i = shl i64 %shl1.i, 3
  %add.i = add i64 %sub2.i, %shl3.i
  %shl4.i = shl i64 %shl3.i, 3
  %sub5.i = sub i64 %add.i, %shl4.i
  %shl6.i = shl i64 %shl4.i, 4
  %add7.i = add i64 %sub5.i, %shl6.i
  %shl8.i = shl i64 %shl6.i, 2
  %add9.i = add i64 %add7.i, %shl8.i
  %shr.i = lshr i64 %add9.i, 56
  %conv2 = trunc i64 %shr.i to i32
  ret i32 %conv2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @from_kuid.723(i32 %kuid) #2 {
entry:
  %call = call i32 @__kuid_val.725(i32 %kuid)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__kuid_val.725(i32 %uid) #2 {
entry:
  ret i32 %uid
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock.727(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock.728(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_return.729(i32 %i, %struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #7, !srcloc !834
  %add = add nsw i32 %i, %0
  ret i32 %add
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @hash_str.731(i8* %name, i32 %bits) #2 {
entry:
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %len.0 = phi i32 [ 0, %entry ], [ %inc, %do.cond ]
  %l.0 = phi i64 [ 0, %entry ], [ %or, %do.cond ]
  %hash.0 = phi i64 [ 0, %entry ], [ %hash.1, %do.cond ]
  %name.addr.0 = phi i8* [ %name, %entry ], [ %incdec.ptr, %do.cond ]
  %incdec.ptr = getelementptr inbounds i8, i8* %name.addr.0, i32 1
  %0 = load i8, i8* %name.addr.0, align 1, !tbaa !166
  %tobool = icmp ne i8 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  %conv4 = trunc i32 %len.0 to i8
  %.len.0 = select i1 %tobool3, i32 -1, i32 %len.0
  %conv4. = select i1 %tobool3, i8 %conv4, i8 %0
  %shl = shl i64 %l.0, 8
  %conv5 = zext i8 %conv4. to i64
  %or = or i64 %shl, %conv5
  %inc = add nsw i32 %.len.0, 1
  %and = and i32 %inc, 7
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then7, label %do.cond

if.then7:                                         ; preds = %do.body
  %xor = xor i64 %hash.0, %or
  %shl.i = shl i64 %xor, 18
  %sub.i = sub i64 %xor, %shl.i
  %shl1.i = shl i64 %shl.i, 33
  %sub2.i = sub i64 %sub.i, %shl1.i
  %shl3.i = shl i64 %shl1.i, 3
  %add.i = add i64 %sub2.i, %shl3.i
  %shl4.i = shl i64 %shl3.i, 3
  %sub5.i = sub i64 %add.i, %shl4.i
  %shl6.i = shl i64 %shl4.i, 4
  %add7.i = add i64 %sub5.i, %shl6.i
  %shl8.i = shl i64 %shl6.i, 2
  %add9.i = add i64 %add7.i, %shl8.i
  br label %do.cond

do.cond:                                          ; preds = %if.then7, %do.body
  %hash.1 = phi i64 [ %add9.i, %if.then7 ], [ %hash.0, %do.body ]
  %tobool9 = icmp ne i32 %inc, 0
  br i1 %tobool9, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %sub = sub nsw i32 64, %bits
  %sh_prom = zext i32 %sub to i64
  %shr = lshr i64 %hash.1, %sh_prom
  ret i64 %shr
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hash_ip6(%struct.in6_addr* %ip) #2 {
entry:
  %call = call i32 @ipv6_addr_hash(%struct.in6_addr* %ip)
  %call1 = call i32 @hash_32(i32 %call, i32 8)
  ret i32 %call1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @ipv6_addr_hash(%struct.in6_addr* %a) #2 {
entry:
  %0 = bitcast %struct.in6_addr* %a to i64*
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 0
  %1 = load i64, i64* %arrayidx, align 8, !tbaa !88
  %arrayidx1 = getelementptr inbounds i64, i64* %0, i64 1
  %2 = load i64, i64* %arrayidx1, align 8, !tbaa !88
  %xor = xor i64 %1, %2
  %shr = lshr i64 %xor, 32
  %xor2 = xor i64 %xor, %shr
  %conv = trunc i64 %xor2 to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hash_32(i32 %val, i32 %bits) #2 {
entry:
  %conv = zext i32 %val to i64
  %mul = mul i64 %conv, 2654404609
  %conv1 = trunc i64 %mul to i32
  %sub = sub i32 32, %bits
  %shr = lshr i32 %conv1, %sub
  ret i32 %shr
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @cache_valid(%struct.cache_head* %h) #2 {
entry:
  %expiry_time = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 1
  %0 = load i64, i64* %expiry_time, align 8, !tbaa !828
  %cmp = icmp ne i64 %0, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 4
  %1 = load volatile i64, i64* %flags, align 8, !tbaa !88
  %and.i = and i64 1, %1
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %tobool, %land.rhs ]
  %land.ext = zext i1 %2 to i32
  ret i32 %land.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @cache_get(%struct.cache_head* %h) #2 {
entry:
  %ref = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 3
  call void @kref_get.715(%struct.arch_spinlock* %ref)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @ipv6_addr_set(%struct.in6_addr* %addr, i32 %w1, i32 %w2, i32 %w3, i32 %w4) #2 {
entry:
  %in6_u = getelementptr inbounds %struct.in6_addr, %struct.in6_addr* %addr, i32 0, i32 0
  %u6_addr32 = bitcast %union.anon.68* %in6_u to [4 x i32]*
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %u6_addr32, i64 0, i64 0
  call void @__ipv6_addr_set_half(i32* %arrayidx, i32 %w1, i32 %w2)
  %in6_u1 = getelementptr inbounds %struct.in6_addr, %struct.in6_addr* %addr, i32 0, i32 0
  %u6_addr322 = bitcast %union.anon.68* %in6_u1 to [4 x i32]*
  %arrayidx3 = getelementptr inbounds [4 x i32], [4 x i32]* %u6_addr322, i64 0, i64 2
  call void @__ipv6_addr_set_half(i32* %arrayidx3, i32 %w3, i32 %w4)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__ipv6_addr_set_half(i32* %addr, i32 %wh, i32 %wl) #2 {
entry:
  %arrayidx = getelementptr inbounds i32, i32* %addr, i64 0
  store i32 %wh, i32* %arrayidx, align 4, !tbaa !49
  %arrayidx1 = getelementptr inbounds i32, i32* %addr, i64 1
  store i32 %wl, i32* %arrayidx1, align 4, !tbaa !49
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock.732() #2 {
entry:
  call void @__rcu_read_lock.744()
  call void @rcu_lock_acquire.745(%struct.lockdep_map* @rcu_lock_map)
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_lock.__warned.746, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_lock.__warned.746, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 780, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.15.1329, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rcu_read_lock_held.734() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call1 = call i32 @rcu_is_cpu_idle()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call zeroext i1 @rcu_lockdep_current_cpu_online()
  br i1 %call5, label %if.end7, label %return

if.end7:                                          ; preds = %if.end4
  %call8 = call i32 @lock_is_held(%struct.lockdep_map* @rcu_lock_map)
  br label %return

return:                                           ; preds = %if.end7, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call8, %if.end7 ], [ 1, %entry ], [ 0, %if.end ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_unlock.737() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_unlock.__warned.738, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_unlock.__warned.738, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 801, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.16.1322, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  call void @rcu_lock_release.741(%struct.lockdep_map* @rcu_lock_map)
  call void @__rcu_read_unlock.742()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_release.741(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_release(%struct.lockdep_map* %map, i32 1, i64 ptrtoint (i8* blockaddress(@rcu_lock_release.741, %__here) to i64))
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_unlock.742() #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !835
  %call = call %struct.thread_info* @current_thread_info.743()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !836
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.743() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !837
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_lock.744() #2 {
entry:
  %call = call %struct.thread_info* @current_thread_info.743()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !838
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_acquire.745(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_acquire(%struct.lockdep_map* %map, i32 0, i32 0, i32 2, i32 1, %struct.lockdep_map* null, i64 ptrtoint (i8* blockaddress(@rcu_lock_acquire.745, %__here) to i64))
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @svc_getu32.748(%struct.iovec* %iov) #2 {
entry:
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  %0 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %1 = bitcast i8* %0 to i32*
  %incdec.ptr = getelementptr inbounds i32, i32* %1, i32 1
  %2 = load i32, i32* %1, align 4, !tbaa !49
  %3 = bitcast i32* %incdec.ptr to i8*
  %iov_base1 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  store i8* %3, i8** %iov_base1, align 8, !tbaa !147
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %4 = load i64, i64* %iov_len, align 8, !tbaa !149
  %sub = sub i64 %4, 4
  store i64 %sub, i64* %iov_len, align 8, !tbaa !149
  ret i32 %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @svc_getnl.749(%struct.iovec* %iov) #2 {
entry:
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  %0 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %1 = bitcast i8* %0 to i32*
  %incdec.ptr = getelementptr inbounds i32, i32* %1, i32 1
  %2 = load i32, i32* %1, align 4, !tbaa !49
  %3 = bitcast i32* %incdec.ptr to i8*
  %iov_base1 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  store i8* %3, i8** %iov_base1, align 8, !tbaa !147
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %4 = load i64, i64* %iov_len, align 8, !tbaa !149
  %sub = sub i64 %4, 4
  store i64 %sub, i64* %iov_len, align 8, !tbaa !149
  %call = call i32 @__fswab32.751(i32 %2) #3
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @make_kuid(i32 %uid) #2 {
entry:
  ret i32 %uid
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @make_kgid(i32 %gid) #2 {
entry:
  ret i32 %gid
}

declare %struct.group_info* @groups_alloc(i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @svc_putnl.750(%struct.iovec* %iov, i32 %val) #2 {
entry:
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  %0 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %1 = load i64, i64* %iov_len, align 8, !tbaa !149
  %add.ptr = getelementptr i8, i8* %0, i64 %1
  %2 = bitcast i8* %add.ptr to i32*
  %call = call i32 @__fswab32.751(i32 %val) #3
  store i32 %call, i32* %2, align 4, !tbaa !49
  %iov_len1 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %3 = load i64, i64* %iov_len1, align 8, !tbaa !149
  %add = add i64 %3, 4
  store i64 %add, i64* %iov_len1, align 8, !tbaa !149
  ret void
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__fswab32.751(i32 %val) #5 {
entry:
  %call = call i32 @__arch_swab32.752(i32 %val) #3
  ret i32 %call
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__arch_swab32.752(i32 %val) #5 {
entry:
  %0 = call i32 asm "bswapl $0", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %val) #3, !srcloc !839
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @svcauth_null_accept(%struct.svc_rqst.5259* %rqstp, i32* %authp) #0 {
entry:
  %rq_arg = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 16
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %rq_res = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 17
  %head1 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head1, i64 0, i64 0
  %rq_cred = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 11
  %cr_group_info = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 2
  store %struct.group_info* null, %struct.group_info** %cr_group_info, align 8, !tbaa !803
  %cr_principal = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 4
  store i8* null, i8** %cr_principal, align 8, !tbaa !804
  %rq_client = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 35
  store %struct.auth_domain.5260* null, %struct.auth_domain.5260** %rq_client, align 8, !tbaa !805
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %0 = load i64, i64* %iov_len, align 8, !tbaa !149
  %cmp = icmp ult i64 %0, 12
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @svc_getu32.748(%struct.iovec* %arrayidx)
  %cmp3 = icmp ne i32 %call, 0
  br i1 %cmp3, label %do.body, label %if.end10

do.body:                                          ; preds = %if.end
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 16
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then7, label %do.end

if.then7:                                         ; preds = %do.body
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then7, %do.body
  store i32 16777216, i32* %authp, align 4, !tbaa !49
  br label %cleanup

if.end10:                                         ; preds = %if.end
  %call11 = call i32 @svc_getu32.748(%struct.iovec* %arrayidx)
  %cmp12 = icmp ne i32 %call11, 0
  br i1 %cmp12, label %do.body18, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end10
  %call14 = call i32 @svc_getu32.748(%struct.iovec* %arrayidx)
  %cmp15 = icmp ne i32 %call14, 0
  br i1 %cmp15, label %do.body18, label %if.end33

do.body18:                                        ; preds = %lor.lhs.false, %if.end10
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and19 = and i32 %3, 16
  %tobool20 = icmp ne i32 %and19, 0
  %lnot21 = xor i1 %tobool20, true
  %lnot23 = xor i1 %lnot21, true
  %lnot.ext24 = zext i1 %lnot23 to i32
  %conv25 = sext i32 %lnot.ext24 to i64
  %expval26 = call i64 @llvm.expect.i64(i64 %conv25, i64 0)
  %tobool27 = icmp ne i64 %expval26, 0
  br i1 %tobool27, label %if.then28, label %do.end32

if.then28:                                        ; preds = %do.body18
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end32

do.end32:                                         ; preds = %if.then28, %do.body18
  store i32 50331648, i32* %authp, align 4, !tbaa !49
  br label %cleanup

if.end33:                                         ; preds = %lor.lhs.false
  %cr_uid = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 0
  store i32 -1, i32* %cr_uid, align 8, !tbaa !806
  %cr_gid = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 1
  store i32 -1, i32* %cr_gid, align 4, !tbaa !807
  %call34 = call %struct.group_info* @groups_alloc(i32 0)
  %cr_group_info35 = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 2
  store %struct.group_info* %call34, %struct.group_info** %cr_group_info35, align 8, !tbaa !803
  %cr_group_info36 = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 2
  %5 = load %struct.group_info*, %struct.group_info** %cr_group_info36, align 8, !tbaa !803
  %cmp37 = icmp eq %struct.group_info* %5, null
  br i1 %cmp37, label %cleanup, label %if.end40

if.end40:                                         ; preds = %if.end33
  call void @svc_putnl.750(%struct.iovec* %arrayidx2, i32 0)
  call void @svc_putnl.750(%struct.iovec* %arrayidx2, i32 0)
  %rq_cred41 = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 11
  %cr_flavor = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred41, i32 0, i32 3
  store i32 0, i32* %cr_flavor, align 8, !tbaa !808
  br label %cleanup

cleanup:                                          ; preds = %if.end40, %if.end33, %do.end32, %do.end, %entry
  %retval.0 = phi i32 [ 8, %do.end ], [ 8, %do.end32 ], [ 5, %if.end40 ], [ 1, %entry ], [ 7, %if.end33 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @svcauth_null_release(%struct.svc_rqst.5259* %rqstp) #0 {
entry:
  %rq_client = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 35
  %0 = load %struct.auth_domain.5260*, %struct.auth_domain.5260** %rq_client, align 8, !tbaa !805
  %tobool = icmp ne %struct.auth_domain.5260* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %rq_client1 = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 35
  %1 = load %struct.auth_domain.5260*, %struct.auth_domain.5260** %rq_client1, align 8, !tbaa !805
  call void bitcast (void (%struct.auth_domain.5097*)* @auth_domain_put to void (%struct.auth_domain.5260*)*)(%struct.auth_domain.5260* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rq_client2 = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 35
  store %struct.auth_domain.5260* null, %struct.auth_domain.5260** %rq_client2, align 8, !tbaa !805
  %rq_cred = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 11
  %cr_group_info = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred, i32 0, i32 2
  %2 = load %struct.group_info*, %struct.group_info** %cr_group_info, align 8, !tbaa !809
  %tobool3 = icmp ne %struct.group_info* %2, null
  br i1 %tobool3, label %do.body, label %if.end12

do.body:                                          ; preds = %if.end
  %rq_cred5 = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 11
  %cr_group_info6 = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred5, i32 0, i32 2
  %3 = load %struct.group_info*, %struct.group_info** %cr_group_info6, align 8, !tbaa !809
  %usage = getelementptr inbounds %struct.group_info, %struct.group_info* %3, i32 0, i32 0
  %call = call i32 @atomic_dec_and_test.717(%struct.atomic_t* %usage)
  %tobool7 = icmp ne i32 %call, 0
  br i1 %tobool7, label %if.then8, label %if.end12

if.then8:                                         ; preds = %do.body
  %rq_cred9 = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 11
  %cr_group_info10 = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred9, i32 0, i32 2
  %4 = load %struct.group_info*, %struct.group_info** %cr_group_info10, align 8, !tbaa !809
  call void @groups_free(%struct.group_info* %4)
  br label %if.end12

if.end12:                                         ; preds = %if.then8, %do.body, %if.end
  %rq_cred13 = getelementptr inbounds %struct.svc_rqst.5259, %struct.svc_rqst.5259* %rqstp, i32 0, i32 11
  %cr_group_info14 = getelementptr inbounds %struct.svc_cred, %struct.svc_cred* %rq_cred13, i32 0, i32 2
  store %struct.group_info* null, %struct.group_info** %cr_group_info14, align 8, !tbaa !809
  ret i32 0
}

; Function Attrs: nounwind uwtable
define void @svcauth_unix_purge(%struct.net* %net) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.713(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %ip_map_cache = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 1
  %2 = load %struct.cache_detail*, %struct.cache_detail** %ip_map_cache, align 8, !tbaa !813
  call void @cache_purge(%struct.cache_detail* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.auth_domain.5260* @unix_domain_find(i8* %name) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %if.end20, %entry
  %h23.sink = phi %struct.auth_domain.5260* [ %h23, %if.end20 ], [ null, %entry ]
  %new.0 = phi %struct.unix_domain* [ null, %entry ], [ %1, %if.end20 ]
  %call24 = call %struct.auth_domain.5260* bitcast (%struct.auth_domain.5097* (i8*, %struct.auth_domain.5097*)* @auth_domain_lookup to %struct.auth_domain.5260* (i8*, %struct.auth_domain.5260*)*)(i8* %name, %struct.auth_domain.5260* %h23.sink)
  %tobool = icmp ne %struct.auth_domain.5260* %call24, null
  br i1 %tobool, label %if.then, label %if.end7

if.then:                                          ; preds = %while.cond
  %tobool1 = icmp ne %struct.unix_domain* %new.0, null
  %h = getelementptr inbounds %struct.unix_domain, %struct.unix_domain* %new.0, i32 0, i32 0
  %cmp = icmp ne %struct.auth_domain.5260* %call24, %h
  %or.cond = and i1 %tobool1, %cmp
  br i1 %or.cond, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %h3 = getelementptr inbounds %struct.unix_domain, %struct.unix_domain* %new.0, i32 0, i32 0
  call void @svcauth_unix_domain_release(%struct.auth_domain.5260* %h3)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %flavour = getelementptr inbounds %struct.auth_domain.5260, %struct.auth_domain.5260* %call24, i32 0, i32 3
  %0 = load %struct.auth_ops.5257*, %struct.auth_ops.5257** %flavour, align 8, !tbaa !796
  %cmp4 = icmp ne %struct.auth_ops.5257* %0, @svcauth_unix
  br i1 %cmp4, label %if.then5, label %cleanup

if.then5:                                         ; preds = %if.end
  call void bitcast (void (%struct.auth_domain.5097*)* @auth_domain_put to void (%struct.auth_domain.5260*)*)(%struct.auth_domain.5260* %call24)
  br label %cleanup

if.end7:                                          ; preds = %while.cond
  %call.i = call i8* @__kmalloc(i64 40, i32 208) #7
  %1 = bitcast i8* %call.i to %struct.unix_domain*
  %cmp9 = icmp eq %struct.unix_domain* %1, null
  br i1 %cmp9, label %cleanup, label %if.end11

if.end11:                                         ; preds = %if.end7
  %h12 = getelementptr inbounds %struct.unix_domain, %struct.unix_domain* %1, i32 0, i32 0
  %ref = getelementptr inbounds %struct.auth_domain.5260, %struct.auth_domain.5260* %h12, i32 0, i32 0
  call void @kref_init(%struct.arch_spinlock* %ref)
  %call13 = call i8* @kstrdup(i8* %name, i32 208)
  %h14 = getelementptr inbounds %struct.unix_domain, %struct.unix_domain* %1, i32 0, i32 0
  %name15 = getelementptr inbounds %struct.auth_domain.5260, %struct.auth_domain.5260* %h14, i32 0, i32 2
  store i8* %call13, i8** %name15, align 8, !tbaa !840
  %h16 = getelementptr inbounds %struct.unix_domain, %struct.unix_domain* %1, i32 0, i32 0
  %name17 = getelementptr inbounds %struct.auth_domain.5260, %struct.auth_domain.5260* %h16, i32 0, i32 2
  %2 = load i8*, i8** %name17, align 8, !tbaa !840
  %cmp18 = icmp eq i8* %2, null
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end11
  %3 = bitcast %struct.unix_domain* %1 to i8*
  call void @kfree(i8* %3)
  br label %cleanup

if.end20:                                         ; preds = %if.end11
  %h21 = getelementptr inbounds %struct.unix_domain, %struct.unix_domain* %1, i32 0, i32 0
  %flavour22 = getelementptr inbounds %struct.auth_domain.5260, %struct.auth_domain.5260* %h21, i32 0, i32 3
  store %struct.auth_ops.5257* @svcauth_unix, %struct.auth_ops.5257** %flavour22, align 8, !tbaa !842
  %h23 = getelementptr inbounds %struct.unix_domain, %struct.unix_domain* %1, i32 0, i32 0
  br label %while.cond

cleanup:                                          ; preds = %if.then19, %if.end7, %if.then5, %if.end
  %retval.0 = phi %struct.auth_domain.5260* [ null, %if.then5 ], [ null, %if.then19 ], [ %call24, %if.end ], [ null, %if.end7 ]
  ret %struct.auth_domain.5260* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_init(%struct.arch_spinlock* %kref) #2 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  call void @atomic_set.760(%struct.atomic_t* %refcount, i32 1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set.760(%struct.atomic_t* %v, i32 %i) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !240
  ret void
}

; Function Attrs: nounwind uwtable
define void @svcauth_unix_info_release(%struct.svc_xprt.5727* %xpt) #0 {
entry:
  %xpt_auth_cache = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %xpt, i32 0, i32 10
  %0 = load i8*, i8** %xpt_auth_cache, align 8, !tbaa !822
  %1 = bitcast i8* %0 to %struct.ip_map*
  %cmp = icmp ne %struct.ip_map* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %xpt_net = getelementptr inbounds %struct.svc_xprt.5727, %struct.svc_xprt.5727* %xpt, i32 0, i32 18
  %2 = load %struct.net*, %struct.net** %xpt_net, align 8, !tbaa !810
  %3 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.713(%struct.net* %2, i32 %3)
  %4 = bitcast i8* %call to %struct.sunrpc_net*
  %h = getelementptr inbounds %struct.ip_map, %struct.ip_map* %1, i32 0, i32 0
  %ip_map_cache = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %4, i32 0, i32 1
  %5 = load %struct.cache_detail*, %struct.cache_detail** %ip_map_cache, align 8, !tbaa !813
  call void @cache_put(%struct.cache_head* %h, %struct.cache_detail* %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @unix_gid_cache_create(%struct.net* %net) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.713(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %call1 = call %struct.cache_detail* @cache_create_net(%struct.cache_detail* @unix_gid_cache_template, %struct.net* %net)
  %2 = bitcast %struct.cache_detail* %call1 to i8*
  %call2 = call i64 @IS_ERR.761(i8* %2)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = bitcast %struct.cache_detail* %call1 to i8*
  %call3 = call i64 @PTR_ERR.716(i8* %3)
  %conv = trunc i64 %call3 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  %call4 = call i32 @cache_register_net(%struct.cache_detail* %call1, %struct.net* %net)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  call void @cache_destroy_net(%struct.cache_detail* %call1, %struct.net* undef)
  br label %cleanup

if.end7:                                          ; preds = %if.end
  %unix_gid_cache = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 2
  store %struct.cache_detail* %call1, %struct.cache_detail** %unix_gid_cache, align 8, !tbaa !823
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %if.then6, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ %call4, %if.then6 ], [ 0, %if.end7 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR.761(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: nounwind uwtable
define internal void @unix_gid_put(%struct.arch_spinlock* %kref) #0 {
entry:
  %0 = bitcast %struct.arch_spinlock* %kref to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -24
  %1 = bitcast i8* %add.ptr to %struct.cache_head*
  %2 = bitcast %struct.cache_head* %1 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr3 to %struct.unix_gid*
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %1, i32 0, i32 4
  %4 = load volatile i64, i64* %flags, align 8, !tbaa !88
  %and.i1 = and i64 1, %4
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool = icmp ne i32 %conv.i3, 0
  br i1 %tobool, label %cond.true7, label %if.end19

cond.true7:                                       ; preds = %entry
  %flags8 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %1, i32 0, i32 4
  %5 = load volatile i64, i64* %flags8, align 8, !tbaa !88
  %and.i = and i64 2, %5
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool10 = icmp ne i32 %conv.i, 0
  br i1 %tobool10, label %if.end19, label %do.body

do.body:                                          ; preds = %cond.true7
  %gi = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %3, i32 0, i32 2
  %6 = load %struct.group_info*, %struct.group_info** %gi, align 8, !tbaa !824
  %usage = getelementptr inbounds %struct.group_info, %struct.group_info* %6, i32 0, i32 0
  %call15 = call i32 @atomic_dec_and_test.717(%struct.atomic_t* %usage)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %do.body
  %gi18 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %3, i32 0, i32 2
  %7 = load %struct.group_info*, %struct.group_info** %gi18, align 8, !tbaa !824
  call void @groups_free(%struct.group_info* %7)
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %do.body, %cond.true7, %entry
  %8 = bitcast %struct.unix_gid* %3 to i8*
  call void @kfree(i8* %8)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @unix_gid_request(%struct.cache_detail* %cd, %struct.cache_head* %h, i8** %bpp, i32* %blen) #0 {
entry:
  %tuid = alloca [20 x i8], align 16
  %0 = bitcast %struct.cache_head* %h to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.unix_gid*
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %tuid, i32 0, i32 0
  %uid = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %1, i32 0, i32 1
  %2 = load i32, i32* %uid, align 8, !tbaa !827
  %call = call i32 @from_kuid.723(i32 %2)
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 20, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.10.772, i32 0, i32 0), i32 %call)
  %arraydecay2 = getelementptr inbounds [20 x i8], [20 x i8]* %tuid, i32 0, i32 0
  call void @qword_add(i8** %bpp, i32* %blen, i8* %arraydecay2)
  %3 = load i8*, i8** %bpp, align 8, !tbaa !28
  %arrayidx = getelementptr inbounds i8, i8* %3, i64 -1
  store i8 10, i8* %arrayidx, align 1, !tbaa !166
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @unix_gid_parse(%struct.cache_detail* %cd, i8* %mesg, i32 %mlen) #0 {
entry:
  %mesg.addr = alloca i8*, align 8
  %id = alloca i32, align 4
  %gids = alloca i32, align 4
  %ug = alloca %struct.unix_gid, align 8
  %gid = alloca i32, align 4
  store i8* %mesg, i8** %mesg.addr, align 8, !tbaa !28
  %0 = load i8*, i8** %mesg.addr, align 8, !tbaa !28
  %sub = sub nsw i32 %mlen, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds i8, i8* %0, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !166
  %conv = sext i8 %1 to i32
  %cmp = icmp ne i32 %conv, 10
  br i1 %cmp, label %cleanup70, label %if.end

if.end:                                           ; preds = %entry
  %2 = load i8*, i8** %mesg.addr, align 8, !tbaa !28
  %sub2 = sub nsw i32 %mlen, 1
  %idxprom3 = sext i32 %sub2 to i64
  %arrayidx4 = getelementptr inbounds i8, i8* %2, i64 %idxprom3
  store i8 0, i8* %arrayidx4, align 1, !tbaa !166
  %call = call i32 @get_int(i8** %mesg.addr, i32* %id)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup70, label %if.end6

if.end6:                                          ; preds = %if.end
  %3 = load i32, i32* %id, align 4, !tbaa !49
  %call7 = call i32 @make_kuid(i32 %3)
  %call8 = call zeroext i1 @uid_valid(i32 %call7)
  br i1 %call8, label %if.end10, label %cleanup70

if.end10:                                         ; preds = %if.end6
  %uid11 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %ug, i32 0, i32 1
  store i32 %call7, i32* %uid11, align 8, !tbaa !827
  %call12 = call i64 @get_expiry(i8** %mesg.addr)
  %cmp13 = icmp eq i64 %call12, 0
  br i1 %cmp13, label %cleanup70, label %if.end16

if.end16:                                         ; preds = %if.end10
  %call17 = call i32 @get_int(i8** %mesg.addr, i32* %gids)
  %tobool18 = icmp ne i32 %call17, 0
  %4 = load i32, i32* %gids, align 4
  %cmp19 = icmp slt i32 %4, 0
  %or.cond = or i1 %tobool18, %cmp19
  %5 = load i32, i32* %gids, align 4
  %cmp22 = icmp sgt i32 %5, 8192
  %or.cond3 = or i1 %or.cond, %cmp22
  br i1 %or.cond3, label %cleanup70, label %if.end25

if.end25:                                         ; preds = %if.end16
  %6 = load i32, i32* %gids, align 4, !tbaa !49
  %call26 = call %struct.group_info* @groups_alloc(i32 %6)
  %gi = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %ug, i32 0, i32 2
  store %struct.group_info* %call26, %struct.group_info** %gi, align 8, !tbaa !824
  %gi27 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %ug, i32 0, i32 2
  %7 = load %struct.group_info*, %struct.group_info** %gi27, align 8, !tbaa !824
  %tobool28 = icmp ne %struct.group_info* %7, null
  br i1 %tobool28, label %if.end30, label %cleanup70

if.end30:                                         ; preds = %if.end25
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end30
  %i.0 = phi i32 [ 0, %if.end30 ], [ %inc, %for.inc ]
  %8 = load i32, i32* %gids, align 4, !tbaa !49
  %cmp31 = icmp slt i32 %i.0, %8
  br i1 %cmp31, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call33 = call i32 @get_int(i8** %mesg.addr, i32* %gid)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %cleanup, label %if.end36

if.end36:                                         ; preds = %for.body
  %9 = load i32, i32* %gid, align 4, !tbaa !49
  %call37 = call i32 @make_kgid(i32 %9)
  %call38 = call zeroext i1 @gid_valid.770(i32 %call37)
  br i1 %call38, label %if.end40, label %cleanup

if.end40:                                         ; preds = %if.end36
  %gi41 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %ug, i32 0, i32 2
  %10 = load %struct.group_info*, %struct.group_info** %gi41, align 8, !tbaa !824
  %blocks = getelementptr inbounds %struct.group_info, %struct.group_info* %10, i32 0, i32 4
  %div = udiv i32 %i.0, 1024
  %idxprom42 = zext i32 %div to i64
  %arrayidx43 = getelementptr inbounds [0 x i32*], [0 x i32*]* %blocks, i64 0, i64 %idxprom42
  %11 = load i32*, i32** %arrayidx43, align 8, !tbaa !28
  %rem = urem i32 %i.0, 1024
  %idxprom44 = zext i32 %rem to i64
  %arrayidx45 = getelementptr inbounds i32, i32* %11, i64 %idxprom44
  store i32 %call37, i32* %arrayidx45, align 4, !tbaa !49
  br label %cleanup

cleanup:                                          ; preds = %if.end40, %if.end36, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end40 ], [ 5, %for.body ], [ 5, %if.end36 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 5
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %cleanup
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 5
  br i1 %SwitchLeaf2, label %out, label %cleanup70

LeafBlock:                                        ; preds = %cleanup
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup70

for.inc:                                          ; preds = %LeafBlock
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call47 = call %struct.unix_gid* @unix_gid_lookup(%struct.cache_detail* %cd, i32 %call7)
  %tobool48 = icmp ne %struct.unix_gid* %call47, null
  br i1 %tobool48, label %if.then49, label %out

if.then49:                                        ; preds = %for.end
  %h = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %ug, i32 0, i32 0
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 4
  store i64 0, i64* %flags, align 8, !tbaa !843
  %h50 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %ug, i32 0, i32 0
  %expiry_time = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h50, i32 0, i32 1
  store i64 %call12, i64* %expiry_time, align 8, !tbaa !844
  %h51 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %ug, i32 0, i32 0
  %h52 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %call47, i32 0, i32 0
  %call53 = call i32 @unix_gid_hash(i32 %call7)
  %call54 = call %struct.cache_head* @sunrpc_cache_update(%struct.cache_detail* %cd, %struct.cache_head* %h51, %struct.cache_head* %h52, i32 %call53)
  %tobool55 = icmp ne %struct.cache_head* %call54, null
  br i1 %tobool55, label %if.else, label %out

if.else:                                          ; preds = %if.then49
  call void @cache_put(%struct.cache_head* %call54, %struct.cache_detail* %cd)
  br label %out

out:                                              ; preds = %if.else, %if.then49, %for.end, %LeafBlock1
  %err.2 = phi i32 [ -22, %LeafBlock1 ], [ 0, %if.else ], [ -12, %if.then49 ], [ -12, %for.end ]
  %gi60 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %ug, i32 0, i32 2
  %12 = load %struct.group_info*, %struct.group_info** %gi60, align 8, !tbaa !824
  %tobool61 = icmp ne %struct.group_info* %12, null
  br i1 %tobool61, label %do.body, label %cleanup70

do.body:                                          ; preds = %out
  %gi63 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %ug, i32 0, i32 2
  %13 = load %struct.group_info*, %struct.group_info** %gi63, align 8, !tbaa !824
  %usage = getelementptr inbounds %struct.group_info, %struct.group_info* %13, i32 0, i32 0
  %call64 = call i32 @atomic_dec_and_test.717(%struct.atomic_t* %usage)
  %tobool65 = icmp ne i32 %call64, 0
  br i1 %tobool65, label %if.then66, label %cleanup70

if.then66:                                        ; preds = %do.body
  %gi67 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %ug, i32 0, i32 2
  %14 = load %struct.group_info*, %struct.group_info** %gi67, align 8, !tbaa !824
  call void @groups_free(%struct.group_info* %14)
  br label %cleanup70

cleanup70:                                        ; preds = %if.then66, %do.body, %out, %LeafBlock, %LeafBlock1, %if.end25, %if.end16, %if.end10, %if.end6, %if.end, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -22, %if.end ], [ -22, %if.end6 ], [ -22, %if.end10 ], [ -22, %if.end16 ], [ -12, %if.end25 ], [ %err.2, %do.body ], [ %err.2, %if.then66 ], [ %err.2, %out ], [ undef, %LeafBlock ], [ undef, %LeafBlock1 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @unix_gid_show(%struct.seq_file* %m, %struct.cache_detail* %cd, %struct.cache_head* %h) #0 {
entry:
  %cmp = icmp eq %struct.cache_head* %h, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @seq_puts(%struct.seq_file* %m, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.11.764, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %entry
  %0 = bitcast %struct.cache_head* %h to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.unix_gid*
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 4
  %2 = load volatile i64, i64* %flags, align 8, !tbaa !88
  %and.i1 = and i64 1, %2
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool = icmp ne i32 %conv.i3, 0
  br i1 %tobool, label %cond.true5, label %if.end14

cond.true5:                                       ; preds = %if.end
  %flags6 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 4
  %3 = load volatile i64, i64* %flags6, align 8, !tbaa !88
  %and.i = and i64 2, %3
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool8 = icmp ne i32 %conv.i, 0
  br i1 %tobool8, label %if.end14, label %if.then13

if.then13:                                        ; preds = %cond.true5
  %gi = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %1, i32 0, i32 2
  %4 = load %struct.group_info*, %struct.group_info** %gi, align 8, !tbaa !824
  %ngroups = getelementptr inbounds %struct.group_info, %struct.group_info* %4, i32 0, i32 1
  %5 = load i32, i32* %ngroups, align 4, !tbaa !618
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %cond.true5, %if.end
  %glen.0 = phi i32 [ %5, %if.then13 ], [ 0, %cond.true5 ], [ 0, %if.end ]
  %uid = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %1, i32 0, i32 1
  %6 = load i32, i32* %uid, align 8, !tbaa !827
  %call15 = call i32 @from_kuid_munged(i32 %6)
  %call16 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12.765, i32 0, i32 0), i32 %call15, i32 %glen.0)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end14
  %i.0 = phi i32 [ 0, %if.end14 ], [ %inc, %for.body ]
  %cmp17 = icmp slt i32 %i.0, %glen.0
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %gi18 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %1, i32 0, i32 2
  %7 = load %struct.group_info*, %struct.group_info** %gi18, align 8, !tbaa !824
  %blocks = getelementptr inbounds %struct.group_info, %struct.group_info* %7, i32 0, i32 4
  %div = udiv i32 %i.0, 1024
  %idxprom = zext i32 %div to i64
  %arrayidx = getelementptr inbounds [0 x i32*], [0 x i32*]* %blocks, i64 0, i64 %idxprom
  %8 = load i32*, i32** %arrayidx, align 8, !tbaa !28
  %rem = urem i32 %i.0, 1024
  %idxprom19 = zext i32 %rem to i64
  %arrayidx20 = getelementptr inbounds i32, i32* %8, i64 %idxprom19
  %9 = load i32, i32* %arrayidx20, align 4, !tbaa !49
  %call21 = call i32 @from_kgid_munged(i32 %9)
  %call22 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.13.766, i32 0, i32 0), i32 %call21)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call23 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.14.767, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal %struct.cache_head* @unix_gid_alloc() #0 {
entry:
  %call.i = call i8* @__kmalloc(i64 56, i32 208) #7
  %0 = bitcast i8* %call.i to %struct.unix_gid*
  %tobool = icmp ne %struct.unix_gid* %0, null
  %h = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %0, i32 0, i32 0
  %retval.0 = select i1 %tobool, %struct.cache_head* %h, %struct.cache_head* null
  ret %struct.cache_head* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @unix_gid_match(%struct.cache_head* %corig, %struct.cache_head* %cnew) #0 {
entry:
  %0 = bitcast %struct.cache_head* %corig to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.unix_gid*
  %2 = bitcast %struct.cache_head* %cnew to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr3 to %struct.unix_gid*
  %uid = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %1, i32 0, i32 1
  %4 = load i32, i32* %uid, align 8, !tbaa !827
  %uid4 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %3, i32 0, i32 1
  %5 = load i32, i32* %uid4, align 8, !tbaa !827
  %call = call zeroext i1 @uid_eq.763(i32 %4, i32 %5)
  %conv = zext i1 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal void @unix_gid_init(%struct.cache_head* %cnew, %struct.cache_head* %citem) #0 {
entry:
  %0 = bitcast %struct.cache_head* %cnew to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.unix_gid*
  %2 = bitcast %struct.cache_head* %citem to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr3 to %struct.unix_gid*
  %uid = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %3, i32 0, i32 1
  %4 = load i32, i32* %uid, align 8, !tbaa !827
  %uid4 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %1, i32 0, i32 1
  store i32 %4, i32* %uid4, align 8, !tbaa !827
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @unix_gid_update(%struct.cache_head* %cnew, %struct.cache_head* %citem) #0 {
entry:
  %0 = bitcast %struct.cache_head* %cnew to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.unix_gid*
  %2 = bitcast %struct.cache_head* %citem to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr3 to %struct.unix_gid*
  %gi = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %3, i32 0, i32 2
  %4 = load %struct.group_info*, %struct.group_info** %gi, align 8, !tbaa !824
  %call = call %struct.group_info* @get_group_info.719(%struct.group_info* %4)
  %gi4 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %3, i32 0, i32 2
  %5 = load %struct.group_info*, %struct.group_info** %gi4, align 8, !tbaa !824
  %gi5 = getelementptr inbounds %struct.unix_gid, %struct.unix_gid* %1, i32 0, i32 2
  store %struct.group_info* %5, %struct.group_info** %gi5, align 8, !tbaa !824
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @uid_eq.763(i32 %left, i32 %right) #2 {
entry:
  %call = call i32 @__kuid_val.725(i32 %left)
  %call1 = call i32 @__kuid_val.725(i32 %right)
  %cmp = icmp eq i32 %call, %call1
  ret i1 %cmp
}

declare i32 @seq_puts(%struct.seq_file*, i8*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @from_kuid_munged(i32 %kuid) #2 {
entry:
  %call = call i32 @from_kuid.723(i32 %kuid)
  %cmp = icmp eq i32 %call, -1
  %0 = load i32, i32* @overflowuid, align 4
  %.call = select i1 %cmp, i32 %0, i32 %call
  ret i32 %.call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @from_kgid_munged(i32 %kgid) #2 {
entry:
  %call = call i32 @from_kgid.768(i32 %kgid)
  %cmp = icmp eq i32 %call, -1
  %0 = load i32, i32* @overflowgid, align 4
  %.call = select i1 %cmp, i32 %0, i32 %call
  ret i32 %.call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @from_kgid.768(i32 %kgid) #2 {
entry:
  %call = call i32 @__kgid_val.769(i32 %kgid)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__kgid_val.769(i32 %gid) #2 {
entry:
  ret i32 %gid
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @get_int(i8** %bpp, i32* %anint) #2 {
entry:
  %buf = alloca [50 x i8], align 16
  %ep = alloca i8*, align 8
  %arraydecay = getelementptr inbounds [50 x i8], [50 x i8]* %buf, i32 0, i32 0
  %call = call i32 @qword_get(i8** %bpp, i8* %arraydecay, i32 50)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp eq i32 %call, 0
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %arraydecay4 = getelementptr inbounds [50 x i8], [50 x i8]* %buf, i32 0, i32 0
  %call5 = call i64 @simple_strtol(i8* %arraydecay4, i8** %ep, i32 0)
  %conv = trunc i64 %call5 to i32
  %0 = load i8*, i8** %ep, align 8, !tbaa !28
  %1 = load i8, i8* %0, align 1, !tbaa !166
  %tobool = icmp ne i8 %1, 0
  br i1 %tobool, label %cleanup, label %if.end7

if.end7:                                          ; preds = %if.end3
  store i32 %conv, i32* %anint, align 4, !tbaa !49
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %if.end3, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end7 ], [ -22, %entry ], [ -2, %if.end ], [ -22, %if.end3 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @uid_valid(i32 %uid) #2 {
entry:
  %call = call zeroext i1 @uid_eq.763(i32 %uid, i32 -1)
  %lnot = xor i1 %call, true
  ret i1 %lnot
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @get_expiry(i8** %bpp) #2 {
entry:
  %rv = alloca i32, align 4
  %boot = alloca %struct.load_weight, align 8
  %call = call i32 @get_int(i8** %bpp, i32* %rv)
  %tobool = icmp ne i32 %call, 0
  %0 = load i32, i32* %rv, align 4
  %cmp = icmp slt i32 %0, 0
  %or.cond = or i1 %tobool, %cmp
  br i1 %or.cond, label %cleanup, label %if.end2

if.end2:                                          ; preds = %entry
  call void @getboottime(%struct.load_weight* %boot)
  %1 = load i32, i32* %rv, align 4, !tbaa !49
  %conv = sext i32 %1 to i64
  %tv_sec = getelementptr inbounds %struct.load_weight, %struct.load_weight* %boot, i32 0, i32 0
  %2 = load i64, i64* %tv_sec, align 8, !tbaa !845
  %sub = sub nsw i64 %conv, %2
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %entry
  %retval.0 = phi i64 [ %sub, %if.end2 ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @gid_valid.770(i32 %gid) #2 {
entry:
  %call = call zeroext i1 @gid_eq.771(i32 %gid, i32 -1)
  %lnot = xor i1 %call, true
  ret i1 %lnot
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @gid_eq.771(i32 %left, i32 %right) #2 {
entry:
  %call = call i32 @__kgid_val.769(i32 %left)
  %call1 = call i32 @__kgid_val.769(i32 %right)
  %cmp = icmp eq i32 %call, %call1
  ret i1 %cmp
}

declare void @getboottime(%struct.load_weight*) #4

declare i64 @simple_strtol(i8*, i8**, i32) #4

; Function Attrs: nounwind uwtable
define void @unix_gid_cache_destroy(%struct.net* %net) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.713(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %unix_gid_cache = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 2
  %2 = load %struct.cache_detail*, %struct.cache_detail** %unix_gid_cache, align 8, !tbaa !823
  %unix_gid_cache1 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 2
  store %struct.cache_detail* null, %struct.cache_detail** %unix_gid_cache1, align 8, !tbaa !823
  call void @cache_purge(%struct.cache_detail* %2)
  call void @cache_unregister_net(%struct.cache_detail* %2, %struct.net* %net)
  call void @cache_destroy_net(%struct.cache_detail* %2, %struct.net* undef)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @ip_map_cache_create(%struct.net* %net) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.713(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %call1 = call %struct.cache_detail* @cache_create_net(%struct.cache_detail* @ip_map_cache_template, %struct.net* %net)
  %2 = bitcast %struct.cache_detail* %call1 to i8*
  %call2 = call i64 @IS_ERR.761(i8* %2)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = bitcast %struct.cache_detail* %call1 to i8*
  %call3 = call i64 @PTR_ERR.716(i8* %3)
  %conv = trunc i64 %call3 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  %call4 = call i32 @cache_register_net(%struct.cache_detail* %call1, %struct.net* %net)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  call void @cache_destroy_net(%struct.cache_detail* %call1, %struct.net* undef)
  br label %cleanup

if.end7:                                          ; preds = %if.end
  %ip_map_cache = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 1
  store %struct.cache_detail* %call1, %struct.cache_detail** %ip_map_cache, align 8, !tbaa !813
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %if.then6, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ %call4, %if.then6 ], [ 0, %if.end7 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @ip_map_put(%struct.arch_spinlock* %kref) #0 {
entry:
  %0 = bitcast %struct.arch_spinlock* %kref to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -24
  %1 = bitcast i8* %add.ptr to %struct.cache_head*
  %2 = bitcast %struct.cache_head* %1 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr3 to %struct.ip_map*
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %1, i32 0, i32 4
  %4 = load volatile i64, i64* %flags, align 8, !tbaa !88
  %and.i1 = and i64 1, %4
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool = icmp ne i32 %conv.i3, 0
  br i1 %tobool, label %cond.true7, label %if.end

cond.true7:                                       ; preds = %entry
  %flags8 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %1, i32 0, i32 4
  %5 = load volatile i64, i64* %flags8, align 8, !tbaa !88
  %and.i = and i64 2, %5
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool10 = icmp ne i32 %conv.i, 0
  br i1 %tobool10, label %if.end, label %if.then

if.then:                                          ; preds = %cond.true7
  %m_client = getelementptr inbounds %struct.ip_map, %struct.ip_map* %3, i32 0, i32 3
  %6 = load %struct.unix_domain*, %struct.unix_domain** %m_client, align 8, !tbaa !817
  %h = getelementptr inbounds %struct.unix_domain, %struct.unix_domain* %6, i32 0, i32 0
  call void bitcast (void (%struct.auth_domain.5097*)* @auth_domain_put to void (%struct.auth_domain.5260*)*)(%struct.auth_domain.5260* %h)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.true7, %entry
  %7 = bitcast %struct.ip_map* %3 to i8*
  call void @kfree(i8* %7)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @ip_map_request(%struct.cache_detail* %cd, %struct.cache_head* %h, i8** %bpp, i32* %blen) #0 {
entry:
  %text_addr = alloca [40 x i8], align 16
  %0 = bitcast %struct.cache_head* %h to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.ip_map*
  %m_addr = getelementptr inbounds %struct.ip_map, %struct.ip_map* %1, i32 0, i32 2
  %call = call zeroext i1 @ipv6_addr_v4mapped(%struct.in6_addr* %m_addr)
  %arraydecay = getelementptr inbounds [40 x i8], [40 x i8]* %text_addr, i32 0, i32 0
  %m_addr1 = getelementptr inbounds %struct.ip_map, %struct.ip_map* %1, i32 0, i32 2
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %in6_u = getelementptr inbounds %struct.in6_addr, %struct.in6_addr* %m_addr1, i32 0, i32 0
  %u6_addr32 = bitcast %union.anon.68* %in6_u to [4 x i32]*
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %u6_addr32, i64 0, i64 3
  %call2 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 20, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1.794, i32 0, i32 0), i32* %arrayidx)
  br label %if.end

if.else:                                          ; preds = %entry
  %call5 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 40, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19.780, i32 0, i32 0), %struct.in6_addr* %m_addr1)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %m_class = getelementptr inbounds %struct.ip_map, %struct.ip_map* %1, i32 0, i32 1
  %arraydecay6 = getelementptr inbounds [8 x i8], [8 x i8]* %m_class, i32 0, i32 0
  call void @qword_add(i8** %bpp, i32* %blen, i8* %arraydecay6)
  %arraydecay7 = getelementptr inbounds [40 x i8], [40 x i8]* %text_addr, i32 0, i32 0
  call void @qword_add(i8** %bpp, i32* %blen, i8* %arraydecay7)
  %2 = load i8*, i8** %bpp, align 8, !tbaa !28
  %arrayidx8 = getelementptr inbounds i8, i8* %2, i64 -1
  store i8 10, i8* %arrayidx8, align 1, !tbaa !166
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ip_map_parse(%struct.cache_detail* %cd, i8* %mesg, i32 %mlen) #0 {
entry:
  %mesg.addr = alloca i8*, align 8
  %class = alloca [8 x i8], align 1
  %address = alloca %union.anon.74, align 4
  %sin6 = alloca %struct.sockaddr_in6, align 4
  store i8* %mesg, i8** %mesg.addr, align 8, !tbaa !28
  %0 = load i8*, i8** %mesg.addr, align 8, !tbaa !28
  %1 = load i8*, i8** %mesg.addr, align 8, !tbaa !28
  %sub = sub nsw i32 %mlen, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 %idxprom
  %2 = load i8, i8* %arrayidx, align 1, !tbaa !166
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 10
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %3 = load i8*, i8** %mesg.addr, align 8, !tbaa !28
  %sub2 = sub nsw i32 %mlen, 1
  %idxprom3 = sext i32 %sub2 to i64
  %arrayidx4 = getelementptr inbounds i8, i8* %3, i64 %idxprom3
  store i8 0, i8* %arrayidx4, align 1, !tbaa !166
  %arraydecay = getelementptr inbounds [8 x i8], [8 x i8]* %class, i32 0, i32 0
  %call = call i32 @qword_get(i8** %mesg.addr, i8* %arraydecay, i32 8)
  %cmp5 = icmp sle i32 %call, 0
  br i1 %cmp5, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end
  %call9 = call i32 @qword_get(i8** %mesg.addr, i8* %0, i32 %mlen)
  %cmp10 = icmp sle i32 %call9, 0
  br i1 %cmp10, label %cleanup, label %if.end13

if.end13:                                         ; preds = %if.end8
  %net = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 25
  %4 = load %struct.net*, %struct.net** %net, align 8, !tbaa !846
  %conv14 = sext i32 %call9 to i64
  %sa = bitcast %union.anon.74* %address to %struct.sockaddr*
  %call15 = call i64 @rpc_pton(%struct.net* %4, i8* %0, i64 %conv14, %struct.sockaddr* %sa, i64 28)
  %cmp16 = icmp eq i64 %call15, 0
  br i1 %cmp16, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end13
  %sa20 = bitcast %union.anon.74* %address to %struct.sockaddr*
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sa20, i32 0, i32 0
  %5 = load i16, i16* %sa_family, align 4, !tbaa !166
  %conv21 = zext i16 %5 to i32
  %Pivot = icmp slt i32 %conv21, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end19
  %SwitchLeaf2 = icmp eq i32 %conv21, 10
  br i1 %SwitchLeaf2, label %sw.bb22, label %cleanup

LeafBlock:                                        ; preds = %if.end19
  %SwitchLeaf = icmp eq i32 %conv21, 2
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %LeafBlock
  %sin6_family = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6, i32 0, i32 0
  store i16 10, i16* %sin6_family, align 4, !tbaa !740
  %s4 = bitcast %union.anon.74* %address to %struct.sockaddr_in*
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %s4, i32 0, i32 2
  %s_addr = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %sin_addr, i32 0, i32 0
  %6 = load i32, i32* %s_addr, align 4, !tbaa !166
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6, i32 0, i32 3
  call void @ipv6_addr_set_v4mapped(i32 %6, %struct.in6_addr* %sin6_addr)
  br label %sw.epilog

sw.bb22:                                          ; preds = %LeafBlock1
  %cmp23 = icmp uge i64 28, 64
  %7 = bitcast %struct.sockaddr_in6* %sin6 to i8*
  %s6 = bitcast %union.anon.74* %address to %struct.sockaddr_in6*
  %8 = bitcast %struct.sockaddr_in6* %s6 to i8*
  br i1 %cmp23, label %if.then25, label %if.else

if.then25:                                        ; preds = %sw.bb22
  %call26 = call i8* @__memcpy(i8* %7, i8* %8, i64 28)
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb22
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 28, i32 4, i1 false)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.else, %if.then25, %sw.bb
  %call29 = call i64 @get_expiry(i8** %mesg.addr)
  %cmp30 = icmp eq i64 %call29, 0
  br i1 %cmp30, label %cleanup, label %if.end33

if.end33:                                         ; preds = %sw.epilog
  %call34 = call i32 @qword_get(i8** %mesg.addr, i8* %0, i32 %mlen)
  %cmp35 = icmp slt i32 %call34, 0
  br i1 %cmp35, label %cleanup, label %if.end38

if.end38:                                         ; preds = %if.end33
  %tobool = icmp ne i32 %call34, 0
  br i1 %tobool, label %if.then39, label %if.end46

if.then39:                                        ; preds = %if.end38
  %call40 = call %struct.auth_domain.5260* @unix_domain_find(i8* %0)
  %cmp41 = icmp eq %struct.auth_domain.5260* %call40, null
  br i1 %cmp41, label %cleanup, label %if.end46

if.end46:                                         ; preds = %if.then39, %if.end38
  %dom.0 = phi %struct.auth_domain.5260* [ %call40, %if.then39 ], [ null, %if.end38 ]
  %arraydecay47 = getelementptr inbounds [8 x i8], [8 x i8]* %class, i32 0, i32 0
  %sin6_addr48 = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6, i32 0, i32 3
  %call49 = call %struct.ip_map* @__ip_map_lookup(%struct.cache_detail* %cd, i8* %arraydecay47, %struct.in6_addr* %sin6_addr48)
  %tobool50 = icmp ne %struct.ip_map* %call49, null
  br i1 %tobool50, label %if.then51, label %if.end55

if.then51:                                        ; preds = %if.end46
  %9 = bitcast %struct.auth_domain.5260* %dom.0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %9, i64 0
  %10 = bitcast i8* %add.ptr to %struct.unix_domain*
  %call53 = call i32 @__ip_map_update(%struct.cache_detail* %cd, %struct.ip_map* %call49, %struct.unix_domain* %10, i64 %call29)
  br label %if.end55

if.end55:                                         ; preds = %if.then51, %if.end46
  %err.0 = phi i32 [ %call53, %if.then51 ], [ -12, %if.end46 ]
  %tobool56 = icmp ne %struct.auth_domain.5260* %dom.0, null
  br i1 %tobool56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.end55
  call void bitcast (void (%struct.auth_domain.5097*)* @auth_domain_put to void (%struct.auth_domain.5260*)*)(%struct.auth_domain.5260* %dom.0)
  br label %if.end58

if.end58:                                         ; preds = %if.then57, %if.end55
  call void @cache_flush()
  br label %cleanup

cleanup:                                          ; preds = %if.end58, %if.then39, %if.end33, %sw.epilog, %LeafBlock, %LeafBlock1, %if.end13, %if.end8, %if.end, %entry
  %retval.0 = phi i32 [ %err.0, %if.end58 ], [ -22, %entry ], [ -22, %if.end ], [ -22, %if.end8 ], [ -22, %if.end13 ], [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -22, %sw.epilog ], [ -22, %if.end33 ], [ -2, %if.then39 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @ip_map_show(%struct.seq_file* %m, %struct.cache_detail* %cd, %struct.cache_head* %h) #0 {
entry:
  %addr = alloca %struct.in6_addr, align 4
  %cmp = icmp eq %struct.cache_head* %h, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @seq_puts(%struct.seq_file* %m, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21.774, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %entry
  %0 = bitcast %struct.cache_head* %h to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.ip_map*
  %m_addr = getelementptr inbounds %struct.ip_map, %struct.ip_map* %1, i32 0, i32 2
  %2 = bitcast %struct.in6_addr* %addr to i8*
  %3 = bitcast %struct.in6_addr* %m_addr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 16, i32 4, i1 false), !tbaa.struct !774
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 4
  %4 = load volatile i64, i64* %flags, align 8, !tbaa !88
  %and.i1 = and i64 1, %4
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool = icmp ne i32 %conv.i3, 0
  br i1 %tobool, label %cond.true5, label %if.end15

cond.true5:                                       ; preds = %if.end
  %flags6 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 4
  %5 = load volatile i64, i64* %flags6, align 8, !tbaa !88
  %and.i = and i64 2, %5
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool8 = icmp ne i32 %conv.i, 0
  br i1 %tobool8, label %if.end15, label %if.then13

if.then13:                                        ; preds = %cond.true5
  %m_client = getelementptr inbounds %struct.ip_map, %struct.ip_map* %1, i32 0, i32 3
  %6 = load %struct.unix_domain*, %struct.unix_domain** %m_client, align 8, !tbaa !817
  %h14 = getelementptr inbounds %struct.unix_domain, %struct.unix_domain* %6, i32 0, i32 0
  %name = getelementptr inbounds %struct.auth_domain.5260, %struct.auth_domain.5260* %h14, i32 0, i32 2
  %7 = load i8*, i8** %name, align 8, !tbaa !840
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %cond.true5, %if.end
  %dom.0 = phi i8* [ getelementptr inbounds ([12 x i8], [12 x i8]* @.str.20.775, i32 0, i32 0), %cond.true5 ], [ %7, %if.then13 ], [ getelementptr inbounds ([12 x i8], [12 x i8]* @.str.20.775, i32 0, i32 0), %if.end ]
  %call16 = call zeroext i1 @ipv6_addr_v4mapped(%struct.in6_addr* %addr)
  %m_class = getelementptr inbounds %struct.ip_map, %struct.ip_map* %1, i32 0, i32 1
  %arraydecay = getelementptr inbounds [8 x i8], [8 x i8]* %m_class, i32 0, i32 0
  br i1 %call16, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end15
  %in6_u = getelementptr inbounds %struct.in6_addr, %struct.in6_addr* %addr, i32 0, i32 0
  %u6_addr32 = bitcast %union.anon.68* %in6_u to [4 x i32]*
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %u6_addr32, i64 0, i64 3
  %call18 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.22.776, i32 0, i32 0), i8* %arraydecay, i32* %arrayidx, i8* %dom.0)
  br label %cleanup

if.else:                                          ; preds = %if.end15
  %call21 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23.777, i32 0, i32 0), i8* %arraydecay, %struct.in6_addr* %addr, i8* %dom.0)
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.then17, %if.then
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal %struct.cache_head* @ip_map_alloc() #0 {
entry:
  %call.i = call i8* @__kmalloc(i64 72, i32 208) #7
  %0 = bitcast i8* %call.i to %struct.ip_map*
  %tobool = icmp ne %struct.ip_map* %0, null
  %h = getelementptr inbounds %struct.ip_map, %struct.ip_map* %0, i32 0, i32 0
  %retval.0 = select i1 %tobool, %struct.cache_head* %h, %struct.cache_head* null
  ret %struct.cache_head* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @ip_map_match(%struct.cache_head* %corig, %struct.cache_head* %cnew) #0 {
entry:
  %0 = bitcast %struct.cache_head* %corig to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.ip_map*
  %2 = bitcast %struct.cache_head* %cnew to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr3 to %struct.ip_map*
  %m_class = getelementptr inbounds %struct.ip_map, %struct.ip_map* %1, i32 0, i32 1
  %arraydecay = getelementptr inbounds [8 x i8], [8 x i8]* %m_class, i32 0, i32 0
  %m_class4 = getelementptr inbounds %struct.ip_map, %struct.ip_map* %3, i32 0, i32 1
  %arraydecay5 = getelementptr inbounds [8 x i8], [8 x i8]* %m_class4, i32 0, i32 0
  %call = call i32 @strcmp(i8* %arraydecay, i8* %arraydecay5)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %m_addr = getelementptr inbounds %struct.ip_map, %struct.ip_map* %1, i32 0, i32 2
  %m_addr6 = getelementptr inbounds %struct.ip_map, %struct.ip_map* %3, i32 0, i32 2
  %call7 = call zeroext i1 @ipv6_addr_equal(%struct.in6_addr* %m_addr, %struct.in6_addr* %m_addr6)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %call7, %land.rhs ]
  %land.ext = zext i1 %4 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define internal void @ip_map_init(%struct.cache_head* %cnew, %struct.cache_head* %citem) #0 {
entry:
  %0 = bitcast %struct.cache_head* %cnew to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.ip_map*
  %2 = bitcast %struct.cache_head* %citem to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr3 to %struct.ip_map*
  %m_class = getelementptr inbounds %struct.ip_map, %struct.ip_map* %1, i32 0, i32 1
  %arraydecay = getelementptr inbounds [8 x i8], [8 x i8]* %m_class, i32 0, i32 0
  %m_class4 = getelementptr inbounds %struct.ip_map, %struct.ip_map* %3, i32 0, i32 1
  %arraydecay5 = getelementptr inbounds [8 x i8], [8 x i8]* %m_class4, i32 0, i32 0
  %call = call i8* @strcpy(i8* %arraydecay, i8* %arraydecay5)
  %m_addr = getelementptr inbounds %struct.ip_map, %struct.ip_map* %1, i32 0, i32 2
  %m_addr6 = getelementptr inbounds %struct.ip_map, %struct.ip_map* %3, i32 0, i32 2
  %4 = bitcast %struct.in6_addr* %m_addr to i8*
  %5 = bitcast %struct.in6_addr* %m_addr6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 16, i32 8, i1 false), !tbaa.struct !774
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @update(%struct.cache_head* %cnew, %struct.cache_head* %citem) #0 {
entry:
  %0 = bitcast %struct.cache_head* %cnew to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.ip_map*
  %2 = bitcast %struct.cache_head* %citem to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr3 to %struct.ip_map*
  %m_client = getelementptr inbounds %struct.ip_map, %struct.ip_map* %3, i32 0, i32 3
  %4 = load %struct.unix_domain*, %struct.unix_domain** %m_client, align 8, !tbaa !817
  %h = getelementptr inbounds %struct.unix_domain, %struct.unix_domain* %4, i32 0, i32 0
  %ref = getelementptr inbounds %struct.auth_domain.5260, %struct.auth_domain.5260* %h, i32 0, i32 0
  call void @kref_get.715(%struct.arch_spinlock* %ref)
  %m_client4 = getelementptr inbounds %struct.ip_map, %struct.ip_map* %3, i32 0, i32 3
  %5 = load %struct.unix_domain*, %struct.unix_domain** %m_client4, align 8, !tbaa !817
  %m_client5 = getelementptr inbounds %struct.ip_map, %struct.ip_map* %1, i32 0, i32 3
  store %struct.unix_domain* %5, %struct.unix_domain** %m_client5, align 8, !tbaa !817
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @ipv6_addr_equal(%struct.in6_addr* %a1, %struct.in6_addr* %a2) #2 {
entry:
  %0 = bitcast %struct.in6_addr* %a1 to i64*
  %1 = bitcast %struct.in6_addr* %a2 to i64*
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 0
  %2 = load i64, i64* %arrayidx, align 8, !tbaa !88
  %arrayidx1 = getelementptr inbounds i64, i64* %1, i64 0
  %3 = load i64, i64* %arrayidx1, align 8, !tbaa !88
  %xor = xor i64 %2, %3
  %arrayidx2 = getelementptr inbounds i64, i64* %0, i64 1
  %4 = load i64, i64* %arrayidx2, align 8, !tbaa !88
  %arrayidx3 = getelementptr inbounds i64, i64* %1, i64 1
  %5 = load i64, i64* %arrayidx3, align 8, !tbaa !88
  %xor4 = xor i64 %4, %5
  %or = or i64 %xor, %xor4
  %cmp = icmp eq i64 %or, 0
  ret i1 %cmp
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @ipv6_addr_v4mapped(%struct.in6_addr* %a) #2 {
entry:
  %0 = bitcast %struct.in6_addr* %a to i64*
  %1 = load i64, i64* %0, align 8, !tbaa !291
  %in6_u = getelementptr inbounds %struct.in6_addr, %struct.in6_addr* %a, i32 0, i32 0
  %u6_addr32 = bitcast %union.anon.68* %in6_u to [4 x i32]*
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %u6_addr32, i64 0, i64 2
  %2 = load i32, i32* %arrayidx, align 4, !tbaa !166
  %xor = xor i32 %2, -65536
  %conv = zext i32 %xor to i64
  %or = or i64 %1, %conv
  %cmp = icmp eq i64 %or, 0
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define internal i32 @__ip_map_update(%struct.cache_detail* %cd, %struct.ip_map* %ipm, %struct.unix_domain* %udom, i64 %expiry) #0 {
entry:
  %ip = alloca %struct.ip_map, align 8
  %m_client = getelementptr inbounds %struct.ip_map, %struct.ip_map* %ip, i32 0, i32 3
  store %struct.unix_domain* %udom, %struct.unix_domain** %m_client, align 8, !tbaa !817
  %h = getelementptr inbounds %struct.ip_map, %struct.ip_map* %ip, i32 0, i32 0
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 4
  store i64 0, i64* %flags, align 8, !tbaa !847
  %tobool = icmp ne %struct.unix_domain* %udom, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %h1 = getelementptr inbounds %struct.ip_map, %struct.ip_map* %ip, i32 0, i32 0
  %flags2 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h1, i32 0, i32 4
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags2, i32 1, i64* %flags2) #7, !srcloc !848
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %h3 = getelementptr inbounds %struct.ip_map, %struct.ip_map* %ip, i32 0, i32 0
  %expiry_time = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h3, i32 0, i32 1
  store i64 %expiry, i64* %expiry_time, align 8, !tbaa !849
  %h4 = getelementptr inbounds %struct.ip_map, %struct.ip_map* %ip, i32 0, i32 0
  %h5 = getelementptr inbounds %struct.ip_map, %struct.ip_map* %ipm, i32 0, i32 0
  %m_class = getelementptr inbounds %struct.ip_map, %struct.ip_map* %ipm, i32 0, i32 1
  %arraydecay = getelementptr inbounds [8 x i8], [8 x i8]* %m_class, i32 0, i32 0
  %call = call i64 @hash_str.731(i8* %arraydecay, i32 8)
  %m_addr = getelementptr inbounds %struct.ip_map, %struct.ip_map* %ipm, i32 0, i32 2
  %call6 = call i32 @hash_ip6(%struct.in6_addr* %m_addr)
  %conv = sext i32 %call6 to i64
  %xor = xor i64 %call, %conv
  %conv7 = trunc i64 %xor to i32
  %call8 = call %struct.cache_head* @sunrpc_cache_update(%struct.cache_detail* %cd, %struct.cache_head* %h4, %struct.cache_head* %h5, i32 %conv7)
  %tobool9 = icmp ne %struct.cache_head* %call8, null
  br i1 %tobool9, label %if.end11, label %cleanup

if.end11:                                         ; preds = %if.end
  call void @cache_put(%struct.cache_head* %call8, %struct.cache_detail* %cd)
  br label %cleanup

cleanup:                                          ; preds = %if.end11, %if.end
  %retval.0 = phi i32 [ 0, %if.end11 ], [ -12, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @ip_map_cache_destroy(%struct.net* %net) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.713(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %ip_map_cache = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 1
  %2 = load %struct.cache_detail*, %struct.cache_detail** %ip_map_cache, align 8, !tbaa !813
  %ip_map_cache1 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 1
  store %struct.cache_detail* null, %struct.cache_detail** %ip_map_cache1, align 8, !tbaa !813
  call void @cache_purge(%struct.cache_detail* %2)
  call void @cache_unregister_net(%struct.cache_detail* %2, %struct.net* %net)
  call void @cache_destroy_net(%struct.cache_detail* %2, %struct.net* undef)
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @rpc_uaddr2sockaddr(%struct.net* %net, i8* %uaddr, i64 %uaddr_len, %struct.sockaddr* %sap, i64 %salen) #0 {
entry:
  %buf = alloca [61 x i8], align 16
  %portlo = alloca i64, align 8
  %porthi = alloca i64, align 8
  %cmp = icmp ugt i64 %uaddr_len, 57
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [61 x i8], [61 x i8]* %buf, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arraydecay, i8* %uaddr, i64 %uaddr_len, i32 1, i1 false)
  %arrayidx = getelementptr inbounds [61 x i8], [61 x i8]* %buf, i64 0, i64 %uaddr_len
  store i8 0, i8* %arrayidx, align 1, !tbaa !166
  %arraydecay1 = getelementptr inbounds [61 x i8], [61 x i8]* %buf, i32 0, i32 0
  %call = call i8* @strrchr(i8* %arraydecay1, i32 46)
  %cmp2 = icmp eq i8* %call, null
  %lnot = xor i1 %cmp2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %add.ptr = getelementptr inbounds i8, i8* %call, i64 1
  %call6 = call i32 @kstrtoul.782(i8* %add.ptr, i32 10, i64* %portlo)
  %cmp7 = icmp ne i32 %call6, 0
  %lnot9 = xor i1 %cmp7, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  br i1 %tobool15, label %cleanup, label %if.end17

if.end17:                                         ; preds = %if.end5
  %0 = load i64, i64* %portlo, align 8, !tbaa !88
  %cmp18 = icmp ugt i64 %0, 255
  %lnot20 = xor i1 %cmp18, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %expval25 = call i64 @llvm.expect.i64(i64 %conv24, i64 0)
  %tobool26 = icmp ne i64 %expval25, 0
  br i1 %tobool26, label %cleanup, label %if.end28

if.end28:                                         ; preds = %if.end17
  store i8 0, i8* %call, align 1, !tbaa !166
  %arraydecay29 = getelementptr inbounds [61 x i8], [61 x i8]* %buf, i32 0, i32 0
  %call30 = call i8* @strrchr(i8* %arraydecay29, i32 46)
  %cmp31 = icmp eq i8* %call30, null
  %lnot33 = xor i1 %cmp31, true
  %lnot35 = xor i1 %lnot33, true
  %lnot.ext36 = zext i1 %lnot35 to i32
  %conv37 = sext i32 %lnot.ext36 to i64
  %expval38 = call i64 @llvm.expect.i64(i64 %conv37, i64 0)
  %tobool39 = icmp ne i64 %expval38, 0
  br i1 %tobool39, label %cleanup, label %if.end41

if.end41:                                         ; preds = %if.end28
  %add.ptr42 = getelementptr inbounds i8, i8* %call30, i64 1
  %call43 = call i32 @kstrtoul.782(i8* %add.ptr42, i32 10, i64* %porthi)
  %cmp44 = icmp ne i32 %call43, 0
  %lnot46 = xor i1 %cmp44, true
  %lnot48 = xor i1 %lnot46, true
  %lnot.ext49 = zext i1 %lnot48 to i32
  %conv50 = sext i32 %lnot.ext49 to i64
  %expval51 = call i64 @llvm.expect.i64(i64 %conv50, i64 0)
  %tobool52 = icmp ne i64 %expval51, 0
  br i1 %tobool52, label %cleanup, label %if.end54

if.end54:                                         ; preds = %if.end41
  %1 = load i64, i64* %porthi, align 8, !tbaa !88
  %cmp55 = icmp ugt i64 %1, 255
  %lnot57 = xor i1 %cmp55, true
  %lnot59 = xor i1 %lnot57, true
  %lnot.ext60 = zext i1 %lnot59 to i32
  %conv61 = sext i32 %lnot.ext60 to i64
  %expval62 = call i64 @llvm.expect.i64(i64 %conv61, i64 0)
  %tobool63 = icmp ne i64 %expval62, 0
  br i1 %tobool63, label %cleanup, label %if.end65

if.end65:                                         ; preds = %if.end54
  %2 = load i64, i64* %porthi, align 8, !tbaa !88
  %shl = shl i64 %2, 8
  %3 = load i64, i64* %portlo, align 8, !tbaa !88
  %or = or i64 %shl, %3
  %conv66 = trunc i64 %or to i16
  store i8 0, i8* %call30, align 1, !tbaa !166
  %arraydecay67 = getelementptr inbounds [61 x i8], [61 x i8]* %buf, i32 0, i32 0
  %arraydecay68 = getelementptr inbounds [61 x i8], [61 x i8]* %buf, i32 0, i32 0
  %call69 = call i64 @strlen(i8* %arraydecay68)
  %call70 = call i64 @rpc_pton(%struct.net* %net, i8* %arraydecay67, i64 %call69, %struct.sockaddr* %sap, i64 %salen)
  %cmp71 = icmp eq i64 %call70, 0
  br i1 %cmp71, label %cleanup, label %if.end74

if.end74:                                         ; preds = %if.end65
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sap, i32 0, i32 0
  %4 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv75 = zext i16 %4 to i32
  %Pivot = icmp slt i32 %conv75, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end74
  %SwitchLeaf2 = icmp eq i32 %conv75, 10
  br i1 %SwitchLeaf2, label %sw.bb79, label %cleanup

LeafBlock:                                        ; preds = %if.end74
  %SwitchLeaf = icmp eq i32 %conv75, 2
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %LeafBlock
  %call76 = call zeroext i16 @__fswab16.785(i16 zeroext %conv66) #3
  %conv77 = zext i16 %call76 to i32
  %conv78 = trunc i32 %conv77 to i16
  %5 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %5, i32 0, i32 1
  store i16 %conv78, i16* %sin_port, align 2, !tbaa !191
  br label %cleanup

sw.bb79:                                          ; preds = %LeafBlock1
  %call80 = call zeroext i16 @__fswab16.785(i16 zeroext %conv66) #3
  %conv81 = zext i16 %call80 to i32
  %conv82 = trunc i32 %conv81 to i16
  %6 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %6, i32 0, i32 1
  store i16 %conv82, i16* %sin6_port, align 2, !tbaa !194
  br label %cleanup

cleanup:                                          ; preds = %sw.bb79, %sw.bb, %LeafBlock, %LeafBlock1, %if.end65, %if.end54, %if.end41, %if.end28, %if.end17, %if.end5, %if.end, %entry
  %retval.0 = phi i64 [ 16, %sw.bb ], [ 28, %sw.bb79 ], [ 0, %entry ], [ 0, %if.end ], [ 0, %if.end5 ], [ 0, %if.end17 ], [ 0, %if.end28 ], [ 0, %if.end41 ], [ 0, %if.end54 ], [ 0, %if.end65 ], [ 0, %LeafBlock ], [ 0, %LeafBlock1 ]
  ret i64 %retval.0
}

declare i8* @strrchr(i8*, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul.782(i8* %s, i32 %base, i64* %res) #2 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i64 @rpc_pton(%struct.net* %net, i8* %buf, i64 %buflen, %struct.sockaddr* %sap, i64 %salen) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %conv = zext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, %buflen
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8, i8* %buf, i64 %idxprom
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !166
  %conv2 = sext i8 %0 to i32
  %cmp3 = icmp eq i32 %conv2, 58
  br i1 %cmp3, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %call = call i64 @rpc_pton6(%struct.net* %net, i8* %buf, i64 %buflen, %struct.sockaddr* %sap, i64 %salen)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call5 = call i64 @rpc_pton4(i8* %buf, i64 %buflen, %struct.sockaddr* %sap, i64 %salen)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then
  %retval.0 = phi i64 [ %call, %if.then ], [ %call5, %for.end ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal zeroext i16 @__fswab16.785(i16 zeroext %val) #5 {
entry:
  %conv = zext i16 %val to i32
  %and = and i32 %conv, 255
  %shl = shl i32 %and, 8
  %conv1 = zext i16 %val to i32
  %and2 = and i32 %conv1, 65280
  %shr = ashr i32 %and2, 8
  %or = or i32 %shl, %shr
  %conv3 = trunc i32 %or to i16
  ret i16 %conv3
}

; Function Attrs: nounwind uwtable
define internal i64 @rpc_pton6(%struct.net* %net, i8* %buf, i64 %buflen, %struct.sockaddr* %sap, i64 %salen) #0 {
entry:
  %delim = alloca i8*, align 8
  %0 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in6*
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %0, i32 0, i32 3
  %in6_u = getelementptr inbounds %struct.in6_addr, %struct.in6_addr* %sin6_addr, i32 0, i32 0
  %1 = bitcast %union.anon.68* %in6_u to i8*
  %cmp = icmp ugt i64 %buflen, 60
  %cmp1 = icmp ult i64 %salen, 28
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = bitcast %struct.sockaddr* %sap to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 28, i32 2, i1 false)
  %conv = trunc i64 %buflen to i32
  %call = call i32 @in6_pton(i8* %buf, i32 %conv, i8* %1, i32 37, i8** %delim)
  %cmp2 = icmp eq i32 %call, 0
  br i1 %cmp2, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %3 = load i8*, i8** %delim, align 8, !tbaa !28
  %call6 = call i32 @rpc_parse_scope_id(%struct.net* %net, i8* %buf, i64 %buflen, i8* %3, %struct.sockaddr_in6* %0)
  %tobool = icmp ne i32 %call6, 0
  br i1 %tobool, label %if.end8, label %cleanup

if.end8:                                          ; preds = %if.end5
  %sin6_family = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %0, i32 0, i32 0
  store i16 10, i16* %sin6_family, align 4, !tbaa !740
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %if.end5, %if.end, %entry
  %retval.0 = phi i64 [ 28, %if.end8 ], [ 0, %entry ], [ 0, %if.end ], [ 0, %if.end5 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @rpc_pton4(i8* %buf, i64 %buflen, %struct.sockaddr* %sap, i64 %salen) #0 {
entry:
  %0 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in*
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %0, i32 0, i32 2
  %s_addr = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %sin_addr, i32 0, i32 0
  %1 = bitcast i32* %s_addr to i8*
  %cmp = icmp ugt i64 %buflen, 16
  %cmp1 = icmp ult i64 %salen, 16
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = bitcast %struct.sockaddr* %sap to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 16, i32 2, i1 false)
  %conv = trunc i64 %buflen to i32
  %call = call i32 @in4_pton(i8* %buf, i32 %conv, i8* %1, i32 0, i8** null)
  %cmp2 = icmp eq i32 %call, 0
  br i1 %cmp2, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %sin_family = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %0, i32 0, i32 0
  store i16 2, i16* %sin_family, align 4, !tbaa !738
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %if.end, %entry
  %retval.0 = phi i64 [ 16, %if.end5 ], [ 0, %entry ], [ 0, %if.end ]
  ret i64 %retval.0
}

declare i32 @in4_pton(i8*, i32, i8*, i32, i8**) #4

declare i32 @in6_pton(i8*, i32, i8*, i32, i8**) #4

; Function Attrs: nounwind uwtable
define internal i32 @rpc_parse_scope_id(%struct.net* %net, i8* %buf, i64 %buflen, i8* %delim, %struct.sockaddr_in6* %sin6) #0 {
entry:
  %scope_id = alloca i64, align 8
  %add.ptr = getelementptr inbounds i8, i8* %buf, i64 %buflen
  %cmp = icmp eq i8* %add.ptr, %delim
  br i1 %cmp, label %cleanup26, label %if.end

if.end:                                           ; preds = %entry
  %0 = load i8, i8* %delim, align 1, !tbaa !166
  %conv = sext i8 %0 to i32
  %cmp1 = icmp ne i32 %conv, 37
  br i1 %cmp1, label %cleanup26, label %if.end4

if.end4:                                          ; preds = %if.end
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6, i32 0, i32 3
  %call = call i32 @ipv6_addr_type(%struct.in6_addr* %sin6_addr)
  %and = and i32 %call, 32
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end6, label %cleanup26

if.end6:                                          ; preds = %if.end4
  %add.ptr7 = getelementptr inbounds i8, i8* %buf, i64 %buflen
  %sub.ptr.lhs.cast = ptrtoint i8* %add.ptr7 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %delim to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub = sub nsw i64 %sub.ptr.sub, 1
  %add.ptr8 = getelementptr inbounds i8, i8* %delim, i64 1
  %call9 = call i8* @kstrndup(i8* %add.ptr8, i64 %sub, i32 208)
  %tobool10 = icmp ne i8* %call9, null
  br i1 %tobool10, label %if.then11, label %cleanup26

if.then11:                                        ; preds = %if.end6
  store i64 0, i64* %scope_id, align 8, !tbaa !88
  %call12 = call %struct.net_device* @dev_get_by_name(%struct.net* %net, i8* %call9)
  %cmp13 = icmp ne %struct.net_device* %call12, null
  br i1 %cmp13, label %if.then15, label %if.else

if.then15:                                        ; preds = %if.then11
  %ifindex = getelementptr inbounds %struct.net_device, %struct.net_device* %call12, i32 0, i32 17
  %1 = load i32, i32* %ifindex, align 8, !tbaa !850
  %conv16 = sext i32 %1 to i64
  store i64 %conv16, i64* %scope_id, align 8, !tbaa !88
  call void @dev_put(%struct.net_device* %call12)
  br label %if.end22

if.else:                                          ; preds = %if.then11
  %call17 = call i32 @kstrtoul.782(i8* %call9, i32 10, i64* %scope_id)
  %cmp18 = icmp eq i32 %call17, 0
  br i1 %cmp18, label %if.then20, label %if.end22

if.then20:                                        ; preds = %if.else
  call void @kfree(i8* %call9)
  br label %cleanup

if.end22:                                         ; preds = %if.else, %if.then15
  call void @kfree(i8* %call9)
  %2 = load i64, i64* %scope_id, align 8, !tbaa !88
  %conv23 = trunc i64 %2 to i32
  %sin6_scope_id = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6, i32 0, i32 4
  store i32 %conv23, i32* %sin6_scope_id, align 4, !tbaa !197
  br label %cleanup

cleanup:                                          ; preds = %if.end22, %if.then20
  %retval.0 = phi i32 [ 1, %if.end22 ], [ 0, %if.then20 ]
  br label %cleanup26

cleanup26:                                        ; preds = %cleanup, %if.end6, %if.end4, %if.end, %entry
  %retval.1 = phi i32 [ %retval.0, %cleanup ], [ 1, %entry ], [ 0, %if.end ], [ 0, %if.end4 ], [ 0, %if.end6 ]
  ret i32 %retval.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @ipv6_addr_type(%struct.in6_addr* %addr) #2 {
entry:
  %call = call i32 @__ipv6_addr_type(%struct.in6_addr* %addr)
  %and = and i32 %call, 65535
  ret i32 %and
}

declare i8* @kstrndup(i8*, i64, i32) #4

declare %struct.net_device* @dev_get_by_name(%struct.net*, i8*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @dev_put(%struct.net_device* %dev) #2 {
entry:
  %pcpu_refcnt = getelementptr inbounds %struct.net_device, %struct.net_device* %dev, i32 0, i32 81
  %0 = load i32*, i32** %pcpu_refcnt, align 8, !tbaa !863
  call void asm "decl %gs:${0:P}", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %0, i32* %0) #7, !srcloc !864
  ret void
}

declare i32 @__ipv6_addr_type(%struct.in6_addr*) #4

; Function Attrs: nounwind uwtable
define i64 @rpc_ntop(%struct.sockaddr* %sap, i8* %buf, i64 %buflen) #0 {
entry:
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sap, i32 0, i32 0
  %0 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %0 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb2, label %return

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %return

sw.bb:                                            ; preds = %LeafBlock
  %call = call i32 @rpc_ntop4(%struct.sockaddr* %sap, i8* %buf, i64 %buflen)
  %conv1 = sext i32 %call to i64
  br label %return

sw.bb2:                                           ; preds = %LeafBlock1
  %call3 = call i64 @rpc_ntop6(%struct.sockaddr* %sap, i8* %buf, i64 %buflen)
  br label %return

return:                                           ; preds = %sw.bb2, %sw.bb, %LeafBlock, %LeafBlock1
  %retval.0 = phi i64 [ %conv1, %sw.bb ], [ %call3, %sw.bb2 ], [ 0, %LeafBlock ], [ 0, %LeafBlock1 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_ntop4(%struct.sockaddr* %sap, i8* %buf, i64 %buflen) #0 {
entry:
  %0 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in*
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %0, i32 0, i32 2
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 %buflen, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1.794, i32 0, i32 0), %struct.atomic_t* %sin_addr)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @rpc_ntop6(%struct.sockaddr* %sap, i8* %buf, i64 %buflen) #0 {
entry:
  %scopebuf = alloca [12 x i8], align 1
  %0 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in6*
  %conv = trunc i64 %buflen to i32
  %call = call i64 @rpc_ntop6_noscopeid(%struct.sockaddr* %sap, i8* %buf, i32 %conv)
  %cmp = icmp eq i64 %call, 0
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv3 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %0, i32 0, i32 3
  %call4 = call i32 @ipv6_addr_type(%struct.in6_addr* %sin6_addr)
  %and = and i32 %call4, 32
  %tobool5 = icmp ne i32 %and, 0
  br i1 %tobool5, label %if.end7, label %cleanup

if.end7:                                          ; preds = %if.end
  %sin6_scope_id = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %0, i32 0, i32 4
  %1 = load i32, i32* %sin6_scope_id, align 4, !tbaa !197
  %cmp8 = icmp eq i32 %1, 0
  br i1 %cmp8, label %cleanup, label %if.end11

if.end11:                                         ; preds = %if.end7
  %arraydecay = getelementptr inbounds [12 x i8], [12 x i8]* %scopebuf, i32 0, i32 0
  %sin6_scope_id12 = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %0, i32 0, i32 4
  %2 = load i32, i32* %sin6_scope_id12, align 4, !tbaa !197
  %call13 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 12, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.2.788, i32 0, i32 0), i32 37, i32 %2)
  %conv14 = sext i32 %call13 to i64
  %cmp15 = icmp ugt i64 %conv14, 12
  %lnot17 = xor i1 %cmp15, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool23 = icmp ne i64 %expval22, 0
  br i1 %tobool23, label %cleanup, label %if.end25

if.end25:                                         ; preds = %if.end11
  %conv26 = sext i32 %call13 to i64
  %add = add i64 %call, %conv26
  %cmp27 = icmp ugt i64 %add, %buflen
  %lnot29 = xor i1 %cmp27, true
  %lnot31 = xor i1 %lnot29, true
  %lnot.ext32 = zext i1 %lnot31 to i32
  %conv33 = sext i32 %lnot.ext32 to i64
  %expval34 = call i64 @llvm.expect.i64(i64 %conv33, i64 0)
  %tobool35 = icmp ne i64 %expval34, 0
  br i1 %tobool35, label %cleanup, label %if.end37

if.end37:                                         ; preds = %if.end25
  %arraydecay38 = getelementptr inbounds [12 x i8], [12 x i8]* %scopebuf, i32 0, i32 0
  %call39 = call i8* @strcat(i8* %buf, i8* %arraydecay38)
  br label %cleanup

cleanup:                                          ; preds = %if.end37, %if.end25, %if.end11, %if.end7, %if.end, %entry
  %retval.0 = phi i64 [ %add, %if.end37 ], [ %call, %entry ], [ %call, %if.end ], [ %call, %if.end7 ], [ 0, %if.end11 ], [ 0, %if.end25 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @rpc_ntop6_noscopeid(%struct.sockaddr* %sap, i8* %buf, i32 %buflen) #0 {
entry:
  %0 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in6*
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %0, i32 0, i32 3
  %call = call zeroext i1 @ipv6_addr_any(%struct.in6_addr* %sin6_addr)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %buflen to i64
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 %conv, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.3.789, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %entry
  %call3 = call zeroext i1 @ipv6_addr_loopback(%struct.in6_addr* %sin6_addr)
  br i1 %call3, label %if.then4, label %if.end8

if.then4:                                         ; preds = %if.end
  %conv5 = sext i32 %buflen to i64
  %call6 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 %conv5, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4.790, i32 0, i32 0))
  br label %cleanup

if.end8:                                          ; preds = %if.end
  %call9 = call zeroext i1 @ipv6_addr_v4mapped.791(%struct.in6_addr* %sin6_addr)
  %conv11 = sext i32 %buflen to i64
  br i1 %call9, label %if.then10, label %if.end14

if.then10:                                        ; preds = %if.end8
  %in6_u = getelementptr inbounds %struct.in6_addr, %struct.in6_addr* %sin6_addr, i32 0, i32 0
  %u6_addr32 = bitcast %union.anon.68* %in6_u to [4 x i32]*
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %u6_addr32, i64 0, i64 3
  %call12 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 %conv11, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.5.792, i32 0, i32 0), i32* %arrayidx)
  br label %cleanup

if.end14:                                         ; preds = %if.end8
  %call16 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 %conv11, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.6.793, i32 0, i32 0), %struct.in6_addr* %sin6_addr)
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %if.then10, %if.then4, %if.then
  %call16.sink = phi i32 [ %call16, %if.end14 ], [ %call12, %if.then10 ], [ %call6, %if.then4 ], [ %call1, %if.then ]
  %conv17 = sext i32 %call16.sink to i64
  ret i64 %conv17
}

declare i8* @strcat(i8*, i8*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @ipv6_addr_any(%struct.in6_addr* %a) #2 {
entry:
  %0 = bitcast %struct.in6_addr* %a to i64*
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 0
  %1 = load i64, i64* %arrayidx, align 8, !tbaa !88
  %arrayidx1 = getelementptr inbounds i64, i64* %0, i64 1
  %2 = load i64, i64* %arrayidx1, align 8, !tbaa !88
  %or = or i64 %1, %2
  %cmp = icmp eq i64 %or, 0
  ret i1 %cmp
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @ipv6_addr_loopback(%struct.in6_addr* %a) #2 {
entry:
  %0 = bitcast %struct.in6_addr* %a to i64*
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 0
  %1 = load i64, i64* %arrayidx, align 8, !tbaa !88
  %arrayidx1 = getelementptr inbounds i64, i64* %0, i64 1
  %2 = load i64, i64* %arrayidx1, align 8, !tbaa !88
  %xor = xor i64 %2, 72057594037927936
  %or = or i64 %1, %xor
  %cmp = icmp eq i64 %or, 0
  ret i1 %cmp
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @ipv6_addr_v4mapped.791(%struct.in6_addr* %a) #2 {
entry:
  %0 = bitcast %struct.in6_addr* %a to i64*
  %1 = load i64, i64* %0, align 8, !tbaa !291
  %in6_u = getelementptr inbounds %struct.in6_addr, %struct.in6_addr* %a, i32 0, i32 0
  %u6_addr32 = bitcast %union.anon.68* %in6_u to [4 x i32]*
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %u6_addr32, i64 0, i64 2
  %2 = load i32, i32* %arrayidx, align 4, !tbaa !166
  %xor = xor i32 %2, -65536
  %conv = zext i32 %xor to i64
  %or = or i64 %1, %conv
  %cmp = icmp eq i64 %or, 0
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define i8* @rpc_sockaddr2uaddr(%struct.sockaddr* %sap, i32 %gfp_flags) #0 {
entry:
  %portbuf = alloca [9 x i8], align 1
  %addrbuf = alloca [57 x i8], align 16
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sap, i32 0, i32 0
  %0 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %0 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb5, label %cleanup

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %LeafBlock
  %arraydecay = getelementptr inbounds [57 x i8], [57 x i8]* %addrbuf, i32 0, i32 0
  %call = call i32 @rpc_ntop4(%struct.sockaddr* %sap, i8* %arraydecay, i64 57)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %sw.bb
  %1 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %1, i32 0, i32 1
  br label %sw.epilog

sw.bb5:                                           ; preds = %LeafBlock1
  %arraydecay6 = getelementptr inbounds [57 x i8], [57 x i8]* %addrbuf, i32 0, i32 0
  %call7 = call i64 @rpc_ntop6_noscopeid(%struct.sockaddr* %sap, i8* %arraydecay6, i32 57)
  %cmp8 = icmp eq i64 %call7, 0
  br i1 %cmp8, label %cleanup, label %if.end11

if.end11:                                         ; preds = %sw.bb5
  %2 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %2, i32 0, i32 1
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end11, %if.end
  %sin6_port.sink = phi i16* [ %sin6_port, %if.end11 ], [ %sin_port, %if.end ]
  %3 = load i16, i16* %sin6_port.sink, align 2, !tbaa !865
  %call12 = call zeroext i16 @__fswab16.785(i16 zeroext %3) #3
  %conv13 = zext i16 %call12 to i32
  %conv14 = trunc i32 %conv13 to i16
  %arraydecay15 = getelementptr inbounds [9 x i8], [9 x i8]* %portbuf, i32 0, i32 0
  %conv16 = zext i16 %conv14 to i32
  %shr = ashr i32 %conv16, 8
  %conv17 = zext i16 %conv14 to i32
  %and = and i32 %conv17, 255
  %call18 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay15, i64 9, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.795, i32 0, i32 0), i32 %shr, i32 %and)
  %cmp19 = icmp sgt i32 %call18, 9
  br i1 %cmp19, label %cleanup, label %if.end22

if.end22:                                         ; preds = %sw.epilog
  %arraydecay23 = getelementptr inbounds [57 x i8], [57 x i8]* %addrbuf, i32 0, i32 0
  %arraydecay24 = getelementptr inbounds [9 x i8], [9 x i8]* %portbuf, i32 0, i32 0
  %call25 = call i64 @strlcat(i8* %arraydecay23, i8* %arraydecay24, i64 57)
  %cmp26 = icmp ugt i64 %call25, 57
  br i1 %cmp26, label %cleanup, label %if.end29

if.end29:                                         ; preds = %if.end22
  %arraydecay30 = getelementptr inbounds [57 x i8], [57 x i8]* %addrbuf, i32 0, i32 0
  %call31 = call i8* @kstrdup(i8* %arraydecay30, i32 %gfp_flags)
  br label %cleanup

cleanup:                                          ; preds = %if.end29, %if.end22, %sw.epilog, %sw.bb5, %sw.bb, %LeafBlock, %LeafBlock1
  %retval.0 = phi i8* [ %call31, %if.end29 ], [ null, %sw.bb ], [ null, %sw.bb5 ], [ null, %LeafBlock ], [ null, %LeafBlock1 ], [ null, %sw.epilog ], [ null, %if.end22 ]
  ret i8* %retval.0
}

declare i64 @strlcat(i8*, i8*, i64) #4

; Function Attrs: nounwind uwtable
define void @rpcb_getport_async(%struct.rpc_task* %task) #0 {
entry:
  %addr = alloca %struct.__kernel_sockaddr_storage, align 8
  %0 = bitcast %struct.__kernel_sockaddr_storage* %addr to %struct.sockaddr*
  call void @rcu_read_lock.799()
  br label %do.body

do.body:                                          ; preds = %do.end9, %entry
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %1 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !26
  %call = call %struct.rpc_clnt* @rpcb_find_transport_owner(%struct.rpc_clnt* %1)
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %call, i32 0, i32 4
  %2 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call2 = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %land.lhs.true, label %do.end9

land.lhs.true:                                    ; preds = %do.body
  %3 = load i8, i8* @rpcb_getport_async.__warned, align 1, !tbaa !29, !range !31
  %tobool3 = trunc i8 %3 to i1
  br i1 %tobool3, label %do.end9, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %land.lhs.true
  %call5 = call i32 @rcu_read_lock_held.800()
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %do.end9, label %if.then

if.then:                                          ; preds = %land.lhs.true4
  store i8 1, i8* @rpcb_getport_async.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.6.801, i32 0, i32 0), i32 664, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end9

do.end9:                                          ; preds = %if.then, %land.lhs.true4, %land.lhs.true, %do.body
  %call10 = call %struct.rpc_xprt* @xprt_get(%struct.rpc_xprt* %2)
  %cmp = icmp eq %struct.rpc_xprt* %call10, null
  br i1 %cmp, label %do.body, label %do.end12

do.end12:                                         ; preds = %do.end9
  call void @rcu_read_unlock.803()
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %4, 32
  %tobool14 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool14, true
  %lnot15 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot15 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool16 = icmp ne i64 %expval, 0
  br i1 %tobool16, label %if.then17, label %do.end22

if.then17:                                        ; preds = %do.end12
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end22

do.end22:                                         ; preds = %if.then17, %do.end12
  %binding = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call10, i32 0, i32 10
  call void @rpc_sleep_on(%struct.rpc_wait_queue* %binding, %struct.rpc_task* %task, void (%struct.rpc_task*)* null)
  %call23 = call i32 @xprt_test_and_set_binding(%struct.rpc_xprt* %call10)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %do.body26, label %if.end43

do.body26:                                        ; preds = %do.end22
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and27 = and i32 %6, 32
  %tobool28 = icmp ne i32 %and27, 0
  %lnot29 = xor i1 %tobool28, true
  %lnot31 = xor i1 %lnot29, true
  %lnot.ext32 = zext i1 %lnot31 to i32
  %conv33 = sext i32 %lnot.ext32 to i64
  %expval34 = call i64 @llvm.expect.i64(i64 %conv33, i64 0)
  %tobool35 = icmp ne i64 %expval34, 0
  br i1 %tobool35, label %if.then36, label %do.end42

if.then36:                                        ; preds = %do.body26
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end42

do.end42:                                         ; preds = %if.then36, %do.body26
  call void @xprt_put(%struct.rpc_xprt* %call10)
  br label %cleanup

if.end43:                                         ; preds = %do.end22
  %call44 = call i32 @xprt_bound.806(%struct.rpc_xprt* %call10)
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %do.body47, label %if.end64

do.body47:                                        ; preds = %if.end43
  %8 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and48 = and i32 %8, 32
  %tobool49 = icmp ne i32 %and48, 0
  %lnot50 = xor i1 %tobool49, true
  %lnot52 = xor i1 %lnot50, true
  %lnot.ext53 = zext i1 %lnot52 to i32
  %conv54 = sext i32 %lnot.ext53 to i64
  %expval55 = call i64 @llvm.expect.i64(i64 %conv54, i64 0)
  %tobool56 = icmp ne i64 %expval55, 0
  br i1 %tobool56, label %if.then57, label %bailout_nofree

if.then57:                                        ; preds = %do.body47
  %9 = call i32 (i8*, ...) @printk(i8* null)
  br label %bailout_nofree

if.end64:                                         ; preds = %if.end43
  %call65 = call i64 @rpc_peeraddr(%struct.rpc_clnt* %call, %struct.sockaddr* %0, i64 128)
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %0, i32 0, i32 0
  %10 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv66 = zext i16 %10 to i32
  %Pivot = icmp slt i32 %conv66, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end64
  %SwitchLeaf2 = icmp eq i32 %conv66, 10
  br i1 %SwitchLeaf2, label %sw.epilog, label %do.body79

LeafBlock:                                        ; preds = %if.end64
  %SwitchLeaf = icmp eq i32 %conv66, 2
  br i1 %SwitchLeaf, label %sw.epilog, label %do.body79

do.body79:                                        ; preds = %LeafBlock, %LeafBlock1
  %11 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and80 = and i32 %11, 32
  %tobool81 = icmp ne i32 %and80, 0
  %lnot82 = xor i1 %tobool81, true
  %lnot84 = xor i1 %lnot82, true
  %lnot.ext85 = zext i1 %lnot84 to i32
  %conv86 = sext i32 %lnot.ext85 to i64
  %expval87 = call i64 @llvm.expect.i64(i64 %conv86, i64 0)
  %tobool88 = icmp ne i64 %expval87, 0
  br i1 %tobool88, label %if.then89, label %bailout_nofree

if.then89:                                        ; preds = %do.body79
  %12 = call i32 (i8*, ...) @printk(i8* null)
  br label %bailout_nofree

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1
  %.sink11 = phi [0 x %struct.rpcb_info]* [ bitcast ([3 x %struct.rpcb_info]* @rpcb_next_version6 to [0 x %struct.rpcb_info]*), %LeafBlock1 ], [ bitcast ([2 x %struct.rpcb_info]* @rpcb_next_version to [0 x %struct.rpcb_info]*), %LeafBlock ]
  %bind_index71 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call10, i32 0, i32 21
  %13 = load i32, i32* %bind_index71, align 8, !tbaa !272
  %idxprom72 = zext i32 %13 to i64
  %arrayidx73 = getelementptr inbounds [0 x %struct.rpcb_info], [0 x %struct.rpcb_info]* %.sink11, i64 0, i64 %idxprom72
  %rpc_proc74 = getelementptr inbounds %struct.rpcb_info, %struct.rpcb_info* %arrayidx73, i32 0, i32 1
  %14 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %rpc_proc74, align 8, !tbaa !866
  %bind_index75 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call10, i32 0, i32 21
  %15 = load i32, i32* %bind_index75, align 8, !tbaa !272
  %idxprom76 = zext i32 %15 to i64
  %arrayidx77 = getelementptr inbounds [0 x %struct.rpcb_info], [0 x %struct.rpcb_info]* %.sink11, i64 0, i64 %idxprom76
  %rpc_vers78 = getelementptr inbounds %struct.rpcb_info, %struct.rpcb_info* %arrayidx77, i32 0, i32 0
  %16 = load i32, i32* %rpc_vers78, align 8, !tbaa !868
  %cmp96 = icmp eq %struct.rpc_procinfo* %14, null
  br i1 %cmp96, label %if.then98, label %do.body118

if.then98:                                        ; preds = %sw.epilog
  %bind_index99 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call10, i32 0, i32 21
  store i32 0, i32* %bind_index99, align 8, !tbaa !272
  %17 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and101 = and i32 %17, 32
  %tobool102 = icmp ne i32 %and101, 0
  %lnot103 = xor i1 %tobool102, true
  %lnot105 = xor i1 %lnot103, true
  %lnot.ext106 = zext i1 %lnot105 to i32
  %conv107 = sext i32 %lnot.ext106 to i64
  %expval108 = call i64 @llvm.expect.i64(i64 %conv107, i64 0)
  %tobool109 = icmp ne i64 %expval108, 0
  br i1 %tobool109, label %if.then110, label %bailout_nofree

if.then110:                                       ; preds = %if.then98
  %18 = call i32 (i8*, ...) @printk(i8* null)
  br label %bailout_nofree

do.body118:                                       ; preds = %sw.epilog
  %19 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and119 = and i32 %19, 32
  %tobool120 = icmp ne i32 %and119, 0
  %lnot121 = xor i1 %tobool120, true
  %lnot123 = xor i1 %lnot121, true
  %lnot.ext124 = zext i1 %lnot123 to i32
  %conv125 = sext i32 %lnot.ext124 to i64
  %expval126 = call i64 @llvm.expect.i64(i64 %conv125, i64 0)
  %tobool127 = icmp ne i64 %expval126, 0
  br i1 %tobool127, label %if.then128, label %do.end134

if.then128:                                       ; preds = %do.body118
  %20 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end134

do.end134:                                        ; preds = %if.then128, %do.body118
  %xprt_net = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call10, i32 0, i32 40
  %21 = load %struct.net*, %struct.net** %xprt_net, align 8, !tbaa !171
  %servername135 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call10, i32 0, i32 41
  %22 = load i8*, i8** %servername135, align 8, !tbaa !216
  %prot136 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call10, i32 0, i32 5
  %23 = load i32, i32* %prot136, align 8, !tbaa !186
  %call137 = call %struct.rpc_clnt* @rpcb_create(%struct.net* %21, i8* %22, %struct.sockaddr* %0, i64 %call65, i32 %23, i32 %16)
  %24 = bitcast %struct.rpc_clnt* %call137 to i8*
  %call138 = call i64 @IS_ERR.811(i8* %24)
  %tobool139 = icmp ne i64 %call138, 0
  br i1 %tobool139, label %if.then140, label %if.end161

if.then140:                                       ; preds = %do.end134
  %25 = bitcast %struct.rpc_clnt* %call137 to i8*
  %call141 = call i64 @PTR_ERR.812(i8* %25)
  %conv142 = trunc i64 %call141 to i32
  %26 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and144 = and i32 %26, 32
  %tobool145 = icmp ne i32 %and144, 0
  %lnot146 = xor i1 %tobool145, true
  %lnot148 = xor i1 %lnot146, true
  %lnot.ext149 = zext i1 %lnot148 to i32
  %conv150 = sext i32 %lnot.ext149 to i64
  %expval151 = call i64 @llvm.expect.i64(i64 %conv150, i64 0)
  %tobool152 = icmp ne i64 %expval151, 0
  br i1 %tobool152, label %if.then153, label %bailout_nofree

if.then153:                                       ; preds = %if.then140
  %27 = bitcast %struct.rpc_clnt* %call137 to i8*
  %call156 = call i64 @PTR_ERR.812(i8* %27)
  %28 = call i32 (i8*, ...) @printk(i8* null)
  br label %bailout_nofree

if.end161:                                        ; preds = %do.end134
  %call162 = call i8* @kzalloc.814(i64 56, i32 32)
  %29 = bitcast i8* %call162 to %struct.rpcbind_args*
  %tobool163 = icmp ne %struct.rpcbind_args* %29, null
  br i1 %tobool163, label %if.end182, label %do.body165

do.body165:                                       ; preds = %if.end161
  %30 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and166 = and i32 %30, 32
  %tobool167 = icmp ne i32 %and166, 0
  %lnot168 = xor i1 %tobool167, true
  %lnot170 = xor i1 %lnot168, true
  %lnot.ext171 = zext i1 %lnot170 to i32
  %conv172 = sext i32 %lnot.ext171 to i64
  %expval173 = call i64 @llvm.expect.i64(i64 %conv172, i64 0)
  %tobool174 = icmp ne i64 %expval173, 0
  br i1 %tobool174, label %if.then175, label %bailout_release_client

if.then175:                                       ; preds = %do.body165
  %31 = call i32 (i8*, ...) @printk(i8* null)
  br label %bailout_release_client

if.end182:                                        ; preds = %if.end161
  %cl_prog183 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %call, i32 0, i32 6
  %32 = load i32, i32* %cl_prog183, align 8, !tbaa !155
  %r_prog = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %29, i32 0, i32 1
  store i32 %32, i32* %r_prog, align 8, !tbaa !869
  %cl_vers184 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %call, i32 0, i32 7
  %33 = load i32, i32* %cl_vers184, align 4, !tbaa !156
  %r_vers = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %29, i32 0, i32 2
  store i32 %33, i32* %r_vers, align 4, !tbaa !871
  %prot185 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call10, i32 0, i32 5
  %34 = load i32, i32* %prot185, align 8, !tbaa !186
  %r_prot = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %29, i32 0, i32 3
  store i32 %34, i32* %r_prot, align 8, !tbaa !872
  %r_port = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %29, i32 0, i32 4
  store i16 0, i16* %r_port, align 4, !tbaa !873
  %r_xprt = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %29, i32 0, i32 0
  store %struct.rpc_xprt* %call10, %struct.rpc_xprt** %r_xprt, align 8, !tbaa !874
  %r_status = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %29, i32 0, i32 8
  store i32 -5, i32* %r_status, align 8, !tbaa !875
  %Pivot9 = icmp slt i32 %16, 3
  br i1 %Pivot9, label %LeafBlock4, label %LeafBlock6

LeafBlock6:                                       ; preds = %if.end182
  %.off = add i32 %16, -3
  %SwitchLeaf7 = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf7, label %sw.bb186, label %do.body192

LeafBlock4:                                       ; preds = %if.end182
  %SwitchLeaf5 = icmp eq i32 %16, 2
  br i1 %SwitchLeaf5, label %sw.bb189, label %do.body192

sw.bb186:                                         ; preds = %LeafBlock6
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call10, i32 0, i32 42
  %arrayidx187 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 5
  %35 = load i8*, i8** %arrayidx187, align 8, !tbaa !28
  %r_netid = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %29, i32 0, i32 5
  store i8* %35, i8** %r_netid, align 8, !tbaa !876
  %call188 = call i8* @rpc_sockaddr2uaddr(%struct.sockaddr* %0, i32 32)
  %r_addr = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %29, i32 0, i32 6
  store i8* %call188, i8** %r_addr, align 8, !tbaa !877
  %r_owner = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %29, i32 0, i32 7
  store i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.31.1130, i32 0, i32 0), i8** %r_owner, align 8, !tbaa !878
  br label %sw.epilog198

sw.bb189:                                         ; preds = %LeafBlock4
  %r_addr190 = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %29, i32 0, i32 6
  store i8* null, i8** %r_addr190, align 8, !tbaa !877
  br label %sw.epilog198

do.body192:                                       ; preds = %LeafBlock4, %LeafBlock6
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.6.801, i32 0, i32 0), i32 755, i64 12) #7, !srcloc !879
  br label %do.body193

do.body193:                                       ; preds = %do.body193, %do.body192
  br label %do.body193

sw.epilog198:                                     ; preds = %sw.bb189, %sw.bb186
  %call199 = call %struct.rpc_task* @rpcb_call_async(%struct.rpc_clnt* %call137, %struct.rpcbind_args* %29, %struct.rpc_procinfo* %14)
  call void @rpc_release_client(%struct.rpc_clnt* %call137)
  %36 = bitcast %struct.rpc_task* %call199 to i8*
  %call200 = call i64 @IS_ERR.811(i8* %36)
  %tobool201 = icmp ne i64 %call200, 0
  br i1 %tobool201, label %do.body203, label %if.end220

do.body203:                                       ; preds = %sw.epilog198
  %37 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and204 = and i32 %37, 32
  %tobool205 = icmp ne i32 %and204, 0
  %lnot206 = xor i1 %tobool205, true
  %lnot208 = xor i1 %lnot206, true
  %lnot.ext209 = zext i1 %lnot208 to i32
  %conv210 = sext i32 %lnot.ext209 to i64
  %expval211 = call i64 @llvm.expect.i64(i64 %conv210, i64 0)
  %tobool212 = icmp ne i64 %expval211, 0
  br i1 %tobool212, label %if.then213, label %cleanup

if.then213:                                       ; preds = %do.body203
  %38 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end220:                                        ; preds = %sw.epilog198
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call10, i32 0, i32 39
  %bind_count = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat, i32 0, i32 0
  %39 = load i64, i64* %bind_count, align 8, !tbaa !378
  %inc = add i64 %39, 1
  store i64 %inc, i64* %bind_count, align 8, !tbaa !378
  call void @rpc_put_task(%struct.rpc_task* %call199)
  br label %cleanup

bailout_release_client:                           ; preds = %if.then175, %do.body165
  call void @rpc_release_client(%struct.rpc_clnt* %call137)
  br label %bailout_nofree

bailout_nofree:                                   ; preds = %bailout_release_client, %if.then153, %if.then140, %if.then110, %if.then98, %if.then89, %do.body79, %if.then57, %do.body47
  %status.0 = phi i32 [ -12, %bailout_release_client ], [ 0, %if.then57 ], [ 0, %do.body47 ], [ -97, %if.then89 ], [ -97, %do.body79 ], [ -96, %if.then110 ], [ -96, %if.then98 ], [ %conv142, %if.then153 ], [ %conv142, %if.then140 ]
  call void @rpcb_wake_rpcbind_waiters(%struct.rpc_xprt* %call10, i32 %status.0)
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 16
  store i32 %status.0, i32* %tk_status, align 4, !tbaa !59
  call void @xprt_put(%struct.rpc_xprt* %call10)
  br label %cleanup

cleanup:                                          ; preds = %bailout_nofree, %if.end220, %if.then213, %do.body203, %do.end42
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock.799() #2 {
entry:
  call void @__rcu_read_lock.849()
  call void @rcu_lock_acquire.850(%struct.lockdep_map* @rcu_lock_map)
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_lock.__warned.851, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_lock.__warned.851, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 780, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.15.1329, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_clnt* @rpcb_find_transport_owner(%struct.rpc_clnt* %clnt) #0 {
entry:
  %cl_parent = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 19
  %0 = load %struct.rpc_clnt*, %struct.rpc_clnt** %cl_parent, align 8, !tbaa !168
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 4
  %1 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end7

land.lhs.true:                                    ; preds = %entry
  %2 = load i8, i8* @rpcb_find_transport_owner.__warned, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %2 to i1
  br i1 %tobool1, label %do.end7, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held.800()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.end7, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rpcb_find_transport_owner.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.6.801, i32 0, i32 0), i32 627, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end7

do.end7:                                          ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end31, %do.end7
  %parent.0 = phi %struct.rpc_clnt* [ %0, %do.end7 ], [ %5, %if.end31 ]
  %clnt.addr.0 = phi %struct.rpc_clnt* [ %clnt, %do.end7 ], [ %parent.0, %if.end31 ]
  %cmp = icmp ne %struct.rpc_clnt* %parent.0, %clnt.addr.0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %cl_xprt9 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %parent.0, i32 0, i32 4
  %3 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt9, align 8, !tbaa !28
  %call11 = call i32 @debug_lockdep_rcu_enabled()
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %land.lhs.true13, label %do.end24

land.lhs.true13:                                  ; preds = %while.body
  %4 = load i8, i8* @rpcb_find_transport_owner.__warned.40, align 1, !tbaa !29, !range !31
  %tobool14 = trunc i8 %4 to i1
  br i1 %tobool14, label %do.end24, label %land.lhs.true15

land.lhs.true15:                                  ; preds = %land.lhs.true13
  %call16 = call i32 @rcu_read_lock_held.800()
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %do.end24, label %if.then18

if.then18:                                        ; preds = %land.lhs.true15
  store i8 1, i8* @rpcb_find_transport_owner.__warned.40, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.6.801, i32 0, i32 0), i32 630, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end24

do.end24:                                         ; preds = %if.then18, %land.lhs.true15, %land.lhs.true13, %while.body
  %cmp26 = icmp ne %struct.rpc_xprt* %3, %1
  br i1 %cmp26, label %while.end, label %if.end28

if.end28:                                         ; preds = %do.end24
  %cl_autobind = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt.addr.0, i32 0, i32 13
  %bf.load = load i8, i8* %cl_autobind, align 8
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool29 = icmp ne i32 %bf.cast, 0
  br i1 %tobool29, label %while.end, label %if.end31

if.end31:                                         ; preds = %if.end28
  %cl_parent32 = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %parent.0, i32 0, i32 19
  %5 = load %struct.rpc_clnt*, %struct.rpc_clnt** %cl_parent32, align 8, !tbaa !168
  br label %while.cond

while.end:                                        ; preds = %if.end28, %do.end24, %while.cond
  ret %struct.rpc_clnt* %clnt.addr.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rcu_read_lock_held.800() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call1 = call i32 @rcu_is_cpu_idle()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call zeroext i1 @rcu_lockdep_current_cpu_online()
  br i1 %call5, label %if.end7, label %return

if.end7:                                          ; preds = %if.end4
  %call8 = call i32 @lock_is_held(%struct.lockdep_map* @rcu_lock_map)
  br label %return

return:                                           ; preds = %if.end7, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call8, %if.end7 ], [ 1, %entry ], [ 0, %if.end ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_unlock.803() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_unlock.__warned.843, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_unlock.__warned.843, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 801, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.16.1322, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  call void @rcu_lock_release.846(%struct.lockdep_map* @rcu_lock_map)
  call void @__rcu_read_unlock.847()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_test_and_set_binding(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @test_and_set_bit.821(i32 5, i64* %state)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_bound.806(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %0 = load volatile i64, i64* %state, align 8, !tbaa !88
  %and.i = and i64 16, %0
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  ret i32 %conv.i
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_clnt* @rpcb_create(%struct.net* %net, i8* %hostname, %struct.sockaddr* %srvaddr, i64 %salen, i32 %proto, i32 %version) #0 {
entry:
  %args = alloca %struct.rpc_create_args, align 8
  %net1 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 0
  store %struct.net* %net, %struct.net** %net1, align 8, !tbaa !198
  %protocol = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 1
  store i32 %proto, i32* %protocol, align 8, !tbaa !200
  %address = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 2
  store %struct.sockaddr* %srvaddr, %struct.sockaddr** %address, align 8, !tbaa !201
  %addrsize = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 3
  store i64 %salen, i64* %addrsize, align 8, !tbaa !202
  %saddress = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 4
  store %struct.sockaddr* null, %struct.sockaddr** %saddress, align 8, !tbaa !203
  %timeout = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 5
  store %struct.rpc_timeout* null, %struct.rpc_timeout** %timeout, align 8, !tbaa !204
  %servername = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 6
  store i8* %hostname, i8** %servername, align 8, !tbaa !205
  %program = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 7
  store %struct.rpc_program* @rpcb_program, %struct.rpc_program** %program, align 8, !tbaa !206
  %prognumber = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 8
  store i32 0, i32* %prognumber, align 8, !tbaa !209
  %version2 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 9
  store i32 %version, i32* %version2, align 4, !tbaa !210
  %authflavor = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 10
  store i32 1, i32* %authflavor, align 8, !tbaa !212
  %flags = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 11
  store i64 24, i64* %flags, align 8, !tbaa !213
  %client_name = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 12
  store i8* null, i8** %client_name, align 8, !tbaa !214
  %bc_xprt = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 13
  store %struct.svc_xprt* null, %struct.svc_xprt** %bc_xprt, align 8, !tbaa !215
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %srvaddr, i32 0, i32 0
  %0 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %0 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb3, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %1 = bitcast %struct.sockaddr* %srvaddr to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %1, i32 0, i32 1
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock1
  %2 = bitcast %struct.sockaddr* %srvaddr to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %2, i32 0, i32 1
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %call = call i8* @ERR_PTR.823(i64 -97)
  %3 = bitcast i8* %call to %struct.rpc_clnt*
  br label %cleanup

sw.epilog:                                        ; preds = %sw.bb3, %sw.bb
  %sin6_port.sink = phi i16* [ %sin6_port, %sw.bb3 ], [ %sin_port, %sw.bb ]
  store i16 28416, i16* %sin6_port.sink, align 2, !tbaa !865
  %call4 = call %struct.rpc_clnt* @rpc_create(%struct.rpc_create_args* %args)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %sw.default
  %retval.0 = phi %struct.rpc_clnt* [ %call4, %sw.epilog ], [ %3, %sw.default ]
  ret %struct.rpc_clnt* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR.811(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR.812(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.814(i64 %size, i32 %flags) #2 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #7
  ret i8* %call.i
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_task* @rpcb_call_async(%struct.rpc_clnt* %rpcb_clnt, %struct.rpcbind_args* %map, %struct.rpc_procinfo* %proc) #0 {
entry:
  %msg = alloca %struct.rpc_message, align 8
  %task_setup_data = alloca %struct.rpc_task_setup, align 8
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 0
  store %struct.rpc_procinfo* %proc, %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !2
  %rpc_argp = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 1
  %0 = bitcast %struct.rpcbind_args* %map to i8*
  store i8* %0, i8** %rpc_argp, align 8, !tbaa !7
  %rpc_resp = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 2
  %1 = bitcast %struct.rpcbind_args* %map to i8*
  store i8* %1, i8** %rpc_resp, align 8, !tbaa !8
  %rpc_cred = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 3
  store %struct.rpc_cred* null, %struct.rpc_cred** %rpc_cred, align 8, !tbaa !9
  %task = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 0
  store %struct.rpc_task* null, %struct.rpc_task** %task, align 8, !tbaa !10
  %rpc_client = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 1
  store %struct.rpc_clnt* %rpcb_clnt, %struct.rpc_clnt** %rpc_client, align 8, !tbaa !13
  %rpc_message = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 2
  store %struct.rpc_message* %msg, %struct.rpc_message** %rpc_message, align 8, !tbaa !14
  %callback_ops = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 3
  store %struct.rpc_call_ops* @rpcb_getport_ops, %struct.rpc_call_ops** %callback_ops, align 8, !tbaa !15
  %callback_data = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 4
  %2 = bitcast %struct.rpcbind_args* %map to i8*
  store i8* %2, i8** %callback_data, align 8, !tbaa !16
  %workqueue = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 5
  store %struct.workqueue_struct* null, %struct.workqueue_struct** %workqueue, align 8, !tbaa !17
  %flags = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 6
  store i16 1025, i16* %flags, align 8, !tbaa !18
  %priority = getelementptr inbounds %struct.rpc_task_setup, %struct.rpc_task_setup* %task_setup_data, i32 0, i32 7
  store i8 0, i8* %priority, align 2, !tbaa !19
  %call = call %struct.rpc_task* @rpc_run_task(%struct.rpc_task_setup* %task_setup_data)
  ret %struct.rpc_task* %call
}

; Function Attrs: nounwind uwtable
define internal void @rpcb_wake_rpcbind_waiters(%struct.rpc_xprt* %xprt, i32 %status) #0 {
entry:
  call void @xprt_clear_binding(%struct.rpc_xprt* %xprt)
  %binding = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 10
  call void @rpc_wake_up_status(%struct.rpc_wait_queue* %binding, i32 %status)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_clear_binding(%struct.rpc_xprt* %xprt) #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !880
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %state, i32 5, i64* %state) #7, !srcloc !881
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !882
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpcb_getport_done(%struct.rpc_task* %child, i8* %data) #0 {
entry:
  %0 = bitcast i8* %data to %struct.rpcbind_args*
  %r_xprt = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %r_xprt, align 8, !tbaa !874
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %child, i32 0, i32 16
  %2 = load i32, i32* %tk_status, align 4, !tbaa !59
  %cmp = icmp eq i32 %2, -5
  %. = select i1 %cmp, i32 -93, i32 %2
  %cmp1 = icmp eq i32 %., -93
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %entry
  %bind_index = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 21
  %3 = load i32, i32* %bind_index, align 8, !tbaa !272
  %inc = add i32 %3, 1
  store i32 %inc, i32* %bind_index, align 8, !tbaa !272
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %entry
  %cmp4 = icmp slt i32 %., 0
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end3
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 1
  %4 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %set_port = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %4, i32 0, i32 5
  %5 = load void (%struct.rpc_xprt*, i16)*, void (%struct.rpc_xprt*, i16)** %set_port, align 8, !tbaa !883
  call void %5(%struct.rpc_xprt* %1, i16 zeroext 0)
  br label %do.body

if.else:                                          ; preds = %if.end3
  %r_port = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %0, i32 0, i32 4
  %6 = load i16, i16* %r_port, align 4, !tbaa !873
  %conv = zext i16 %6 to i32
  %cmp6 = icmp eq i32 %conv, 0
  %ops9 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 1
  %7 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops9, align 8, !tbaa !81
  %set_port10 = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %7, i32 0, i32 5
  %8 = load void (%struct.rpc_xprt*, i16)*, void (%struct.rpc_xprt*, i16)** %set_port10, align 8, !tbaa !883
  br i1 %cmp6, label %if.then8, label %if.else11

if.then8:                                         ; preds = %if.else
  call void %8(%struct.rpc_xprt* %1, i16 zeroext 0)
  br label %do.body

if.else11:                                        ; preds = %if.else
  %r_port14 = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %0, i32 0, i32 4
  %9 = load i16, i16* %r_port14, align 4, !tbaa !873
  call void %8(%struct.rpc_xprt* %1, i16 zeroext %9)
  call void @xprt_set_bound.819(%struct.rpc_xprt* %1)
  br label %do.body

do.body:                                          ; preds = %if.else11, %if.then8, %if.then5
  %status.2 = phi i32 [ %., %if.then5 ], [ -13, %if.then8 ], [ 0, %if.else11 ]
  %10 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %10, 32
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot17 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot17 to i32
  %conv18 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv18, i64 0)
  %tobool19 = icmp ne i64 %expval, 0
  br i1 %tobool19, label %if.then20, label %do.end

if.then20:                                        ; preds = %do.body
  %11 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then20, %do.body
  %r_status = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %0, i32 0, i32 8
  store i32 %status.2, i32* %r_status, align 8, !tbaa !875
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpcb_map_release(i8* %data) #0 {
entry:
  %0 = bitcast i8* %data to %struct.rpcbind_args*
  %r_xprt = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %r_xprt, align 8, !tbaa !874
  %r_status = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %0, i32 0, i32 8
  %2 = load i32, i32* %r_status, align 8, !tbaa !875
  call void @rpcb_wake_rpcbind_waiters(%struct.rpc_xprt* %1, i32 %2)
  %r_xprt1 = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %0, i32 0, i32 0
  %3 = load %struct.rpc_xprt*, %struct.rpc_xprt** %r_xprt1, align 8, !tbaa !874
  call void @xprt_put(%struct.rpc_xprt* %3)
  %r_addr = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %0, i32 0, i32 6
  %4 = load i8*, i8** %r_addr, align 8, !tbaa !877
  call void @kfree(i8* %4)
  %5 = bitcast %struct.rpcbind_args* %0 to i8*
  call void @kfree(i8* %5)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_set_bound.819(%struct.rpc_xprt* %xprt) #2 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @test_and_set_bit.821(i32 4, i64* %state)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_and_set_bit.821(i32 %nr, i64* %addr) #2 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !884
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR.823(i64 %error) #2 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal void @rpcb_enc_getaddr(%struct.rpc_rqst* %req, %struct.xdr_stream* %xdr, %struct.rpcbind_args* %rpcb) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 32
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %call5 = call i32* @xdr_reserve_space(%struct.xdr_stream* %xdr, i64 8)
  %r_prog6 = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %rpcb, i32 0, i32 1
  %2 = load i32, i32* %r_prog6, align 8, !tbaa !869
  %call7 = call i32 @__fswab32.833(i32 %2) #3
  %incdec.ptr = getelementptr inbounds i32, i32* %call5, i32 1
  store i32 %call7, i32* %call5, align 4, !tbaa !49
  %r_vers8 = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %rpcb, i32 0, i32 2
  %3 = load i32, i32* %r_vers8, align 4, !tbaa !871
  %call9 = call i32 @__fswab32.833(i32 %3) #3
  store i32 %call9, i32* %incdec.ptr, align 4, !tbaa !49
  %r_netid10 = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %rpcb, i32 0, i32 5
  %4 = load i8*, i8** %r_netid10, align 8, !tbaa !876
  call void @encode_rpcb_string(%struct.xdr_stream* %xdr, i8* %4, i32 4)
  %r_addr11 = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %rpcb, i32 0, i32 6
  %5 = load i8*, i8** %r_addr11, align 8, !tbaa !877
  call void @encode_rpcb_string(%struct.xdr_stream* %xdr, i8* %5, i32 57)
  %r_owner = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %rpcb, i32 0, i32 7
  %6 = load i8*, i8** %r_owner, align 8, !tbaa !878
  call void @encode_rpcb_string(%struct.xdr_stream* %xdr, i8* %6, i32 2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rpcb_dec_set(%struct.rpc_rqst* %req, %struct.xdr_stream* %xdr, i32* %boolp) #0 {
entry:
  %call = call i32* @xdr_inline_decode(%struct.xdr_stream* %xdr, i64 4)
  %cmp = icmp eq i32* %call, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  store i32 0, i32* %boolp, align 4, !tbaa !49
  %0 = load i32, i32* %call, align 4, !tbaa !49
  %cmp2 = icmp ne i32 %0, 0
  %. = select i1 %cmp2, i32 1, i32 0
  store i32 %., i32* %boolp, align 4
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 32
  %tobool6 = icmp ne i32 %and, 0
  %lnot7 = xor i1 %tobool6, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %conv11 = sext i32 %lnot.ext10 to i64
  %expval12 = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool13 = icmp ne i64 %expval12, 0
  br i1 %tobool13, label %if.then14, label %cleanup

if.then14:                                        ; preds = %if.end
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then14, %if.end, %entry
  %retval.0 = phi i32 [ -5, %entry ], [ 0, %if.then14 ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rpcb_dec_getaddr(%struct.rpc_rqst* %req, %struct.xdr_stream* %xdr, %struct.rpcbind_args* %rpcb) #0 {
entry:
  %address = alloca %struct.__kernel_sockaddr_storage, align 8
  %0 = bitcast %struct.__kernel_sockaddr_storage* %address to %struct.sockaddr*
  %r_port = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %rpcb, i32 0, i32 4
  store i16 0, i16* %r_port, align 4, !tbaa !873
  %call = call i32* @xdr_inline_decode(%struct.xdr_stream* %xdr, i64 4)
  %cmp = icmp eq i32* %call, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body71, label %if.end

if.end:                                           ; preds = %entry
  %call2 = call i32 @__be32_to_cpup(i32* %call)
  %cmp3 = icmp eq i32 %call2, 0
  br i1 %cmp3, label %do.body, label %if.end18

do.body:                                          ; preds = %if.end
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 32
  %tobool6 = icmp ne i32 %and, 0
  %lnot7 = xor i1 %tobool6, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %conv11 = sext i32 %lnot.ext10 to i64
  %expval12 = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool13 = icmp ne i64 %expval12, 0
  br i1 %tobool13, label %if.then14, label %cleanup

if.then14:                                        ; preds = %do.body
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end18:                                         ; preds = %if.end
  %conv19 = zext i32 %call2 to i64
  %cmp20 = icmp ugt i64 %conv19, 57
  %lnot22 = xor i1 %cmp20, true
  %lnot24 = xor i1 %lnot22, true
  %lnot.ext25 = zext i1 %lnot24 to i32
  %conv26 = sext i32 %lnot.ext25 to i64
  %expval27 = call i64 @llvm.expect.i64(i64 %conv26, i64 0)
  %tobool28 = icmp ne i64 %expval27, 0
  br i1 %tobool28, label %do.body71, label %if.end30

if.end30:                                         ; preds = %if.end18
  %conv31 = zext i32 %call2 to i64
  %call32 = call i32* @xdr_inline_decode(%struct.xdr_stream* %xdr, i64 %conv31)
  %cmp33 = icmp eq i32* %call32, null
  %lnot35 = xor i1 %cmp33, true
  %lnot37 = xor i1 %lnot35, true
  %lnot.ext38 = zext i1 %lnot37 to i32
  %conv39 = sext i32 %lnot.ext38 to i64
  %expval40 = call i64 @llvm.expect.i64(i64 %conv39, i64 0)
  %tobool41 = icmp ne i64 %expval40, 0
  br i1 %tobool41, label %do.body71, label %do.body44

do.body44:                                        ; preds = %if.end30
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and45 = and i32 %3, 32
  %tobool46 = icmp ne i32 %and45, 0
  %lnot47 = xor i1 %tobool46, true
  %lnot49 = xor i1 %lnot47, true
  %lnot.ext50 = zext i1 %lnot49 to i32
  %conv51 = sext i32 %lnot.ext50 to i64
  %expval52 = call i64 @llvm.expect.i64(i64 %conv51, i64 0)
  %tobool53 = icmp ne i64 %expval52, 0
  br i1 %tobool53, label %if.then54, label %do.end62

if.then54:                                        ; preds = %do.body44
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end62

do.end62:                                         ; preds = %if.then54, %do.body44
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 0
  %5 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %xprt_net = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %5, i32 0, i32 40
  %6 = load %struct.net*, %struct.net** %xprt_net, align 8, !tbaa !171
  %7 = bitcast i32* %call32 to i8*
  %conv63 = zext i32 %call2 to i64
  %call64 = call i64 @rpc_uaddr2sockaddr(%struct.net* %6, i8* %7, i64 %conv63, %struct.sockaddr* %0, i64 128)
  %cmp65 = icmp eq i64 %call64, 0
  br i1 %cmp65, label %do.body71, label %if.end68

if.end68:                                         ; preds = %do.end62
  %call69 = call zeroext i16 @rpc_get_port.830(%struct.sockaddr* %0)
  %r_port70 = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %rpcb, i32 0, i32 4
  store i16 %call69, i16* %r_port70, align 4, !tbaa !873
  br label %cleanup

do.body71:                                        ; preds = %do.end62, %if.end30, %if.end18, %entry
  %8 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and72 = and i32 %8, 32
  %tobool73 = icmp ne i32 %and72, 0
  %lnot74 = xor i1 %tobool73, true
  %lnot76 = xor i1 %lnot74, true
  %lnot.ext77 = zext i1 %lnot76 to i32
  %conv78 = sext i32 %lnot.ext77 to i64
  %expval79 = call i64 @llvm.expect.i64(i64 %conv78, i64 0)
  %tobool80 = icmp ne i64 %expval79, 0
  br i1 %tobool80, label %if.then81, label %cleanup

if.then81:                                        ; preds = %do.body71
  %9 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then81, %do.body71, %if.end68, %if.then14, %do.body
  %retval.0 = phi i32 [ 0, %if.end68 ], [ 0, %if.then14 ], [ 0, %do.body ], [ -5, %if.then81 ], [ -5, %do.body71 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__be32_to_cpup(i32* %p) #2 {
entry:
  %call = call i32 @__swab32p(i32* %p)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @rpc_get_port.830(%struct.sockaddr* %sap) #2 {
entry:
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sap, i32 0, i32 0
  %0 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %0 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb3, label %return

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %return

sw.bb:                                            ; preds = %LeafBlock
  %1 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %1, i32 0, i32 1
  %2 = load i16, i16* %sin_port, align 2, !tbaa !191
  %call = call zeroext i16 @__fswab16.832(i16 zeroext %2) #3
  %conv1 = zext i16 %call to i32
  %conv2 = trunc i32 %conv1 to i16
  br label %return

sw.bb3:                                           ; preds = %LeafBlock1
  %3 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %3, i32 0, i32 1
  %4 = load i16, i16* %sin6_port, align 2, !tbaa !194
  %call4 = call zeroext i16 @__fswab16.832(i16 zeroext %4) #3
  %conv5 = zext i16 %call4 to i32
  %conv6 = trunc i32 %conv5 to i16
  br label %return

return:                                           ; preds = %sw.bb3, %sw.bb, %LeafBlock, %LeafBlock1
  %retval.0 = phi i16 [ %conv2, %sw.bb ], [ %conv6, %sw.bb3 ], [ 0, %LeafBlock ], [ 0, %LeafBlock1 ]
  ret i16 %retval.0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal zeroext i16 @__fswab16.832(i16 zeroext %val) #5 {
entry:
  %conv = zext i16 %val to i32
  %and = and i32 %conv, 255
  %shl = shl i32 %and, 8
  %conv1 = zext i16 %val to i32
  %and2 = and i32 %conv1, 65280
  %shr = ashr i32 %and2, 8
  %or = or i32 %shl, %shr
  %conv3 = trunc i32 %or to i16
  ret i16 %conv3
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__swab32p(i32* %p) #2 {
entry:
  %0 = load i32, i32* %p, align 4, !tbaa !49
  %call = call i32 @__fswab32.833(i32 %0) #3
  ret i32 %call
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__fswab32.833(i32 %val) #5 {
entry:
  %call = call i32 @__arch_swab32.834(i32 %val) #3
  ret i32 %call
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__arch_swab32.834(i32 %val) #5 {
entry:
  %0 = call i32 asm "bswapl $0", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %val) #3, !srcloc !885
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal void @encode_rpcb_string(%struct.xdr_stream* %xdr, i8* %string, i32 %maxstrlen) #0 {
entry:
  %call = call i64 @strlen(i8* %string)
  %conv = trunc i64 %call to i32
  %cmp = icmp ugt i32 %conv, %maxstrlen
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot3 = xor i1 %tobool, true
  %lnot5 = xor i1 %lnot3, true
  %lnot.ext6 = zext i1 %lnot5 to i32
  %conv7 = sext i32 %lnot.ext6 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end35

if.then:                                          ; preds = %entry
  %0 = load i8, i8* @encode_rpcb_string.__warned, align 1, !tbaa !29, !range !31
  %tobool9 = trunc i8 %0 to i1
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %tobool16 = icmp ne i32 %lnot.ext15, 0
  %lnot17 = xor i1 %tobool16, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool23 = icmp ne i64 %expval22, 0
  br i1 %tobool23, label %if.then24, label %if.end

if.then24:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.6.801, i32 0, i32 0), i32 887)
  br label %if.end

if.end:                                           ; preds = %if.then24, %if.then
  %tobool25 = icmp ne i32 %lnot.ext15, 0
  %lnot26 = xor i1 %tobool25, true
  %lnot28 = xor i1 %lnot26, true
  %lnot.ext29 = zext i1 %lnot28 to i32
  %conv30 = sext i32 %lnot.ext29 to i64
  %expval31 = call i64 @llvm.expect.i64(i64 %conv30, i64 0)
  %tobool32 = icmp ne i64 %expval31, 0
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %if.end
  store i8 1, i8* @encode_rpcb_string.__warned, align 1, !tbaa !29
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %if.end, %entry
  %cmp44 = icmp ugt i32 %conv, %maxstrlen
  %maxstrlen.conv = select i1 %cmp44, i32 %maxstrlen, i32 %conv
  %add = add i32 4, %maxstrlen.conv
  %conv48 = zext i32 %add to i64
  %call49 = call i32* @xdr_reserve_space(%struct.xdr_stream* %xdr, i64 %conv48)
  %call50 = call i32* @xdr_encode_opaque(i32* %call49, i8* %string, i32 %maxstrlen.conv)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpcb_enc_mapping(%struct.rpc_rqst* %req, %struct.xdr_stream* %xdr, %struct.rpcbind_args* %rpcb) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 32
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %call6 = call i32* @xdr_reserve_space(%struct.xdr_stream* %xdr, i64 16)
  %r_prog7 = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %rpcb, i32 0, i32 1
  %2 = load i32, i32* %r_prog7, align 8, !tbaa !869
  %call8 = call i32 @__fswab32.833(i32 %2) #3
  %incdec.ptr = getelementptr inbounds i32, i32* %call6, i32 1
  store i32 %call8, i32* %call6, align 4, !tbaa !49
  %r_vers9 = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %rpcb, i32 0, i32 2
  %3 = load i32, i32* %r_vers9, align 4, !tbaa !871
  %call10 = call i32 @__fswab32.833(i32 %3) #3
  %incdec.ptr11 = getelementptr inbounds i32, i32* %incdec.ptr, i32 1
  store i32 %call10, i32* %incdec.ptr, align 4, !tbaa !49
  %r_prot12 = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %rpcb, i32 0, i32 3
  %4 = load i32, i32* %r_prot12, align 8, !tbaa !872
  %call13 = call i32 @__fswab32.833(i32 %4) #3
  %incdec.ptr14 = getelementptr inbounds i32, i32* %incdec.ptr11, i32 1
  store i32 %call13, i32* %incdec.ptr11, align 4, !tbaa !49
  %r_port15 = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %rpcb, i32 0, i32 4
  %5 = load i16, i16* %r_port15, align 4, !tbaa !873
  %conv16 = zext i16 %5 to i32
  %call17 = call i32 @__fswab32.833(i32 %conv16) #3
  store i32 %call17, i32* %incdec.ptr14, align 4, !tbaa !49
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rpcb_dec_getport(%struct.rpc_rqst* %req, %struct.xdr_stream* %xdr, %struct.rpcbind_args* %rpcb) #0 {
entry:
  %r_port = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %rpcb, i32 0, i32 4
  store i16 0, i16* %r_port, align 4, !tbaa !873
  %call = call i32* @xdr_inline_decode(%struct.xdr_stream* %xdr, i64 4)
  %cmp = icmp eq i32* %call, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call2 = call i32 @__be32_to_cpup(i32* %call)
  %conv3 = zext i32 %call2 to i64
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 32
  %tobool4 = icmp ne i32 %and, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %expval10 = call i64 @llvm.expect.i64(i64 %conv9, i64 0)
  %tobool11 = icmp ne i64 %expval10, 0
  br i1 %tobool11, label %if.then12, label %do.end

if.then12:                                        ; preds = %if.end
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then12, %if.end
  %cmp17 = icmp ugt i64 %conv3, 65535
  %lnot19 = xor i1 %cmp17, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %cleanup, label %if.end27

if.end27:                                         ; preds = %do.end
  %conv28 = trunc i64 %conv3 to i16
  %r_port29 = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %rpcb, i32 0, i32 4
  store i16 %conv28, i16* %r_port29, align 4, !tbaa !873
  br label %cleanup

cleanup:                                          ; preds = %if.end27, %do.end, %entry
  %retval.0 = phi i32 [ 0, %if.end27 ], [ -5, %entry ], [ -5, %do.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_release.846(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_release(%struct.lockdep_map* %map, i32 1, i64 ptrtoint (i8* blockaddress(@rcu_lock_release.846, %__here) to i64))
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_unlock.847() #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !886
  %call = call %struct.thread_info* @current_thread_info.848()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !887
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.848() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !888
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_lock.849() #2 {
entry:
  %call = call %struct.thread_info* @current_thread_info.848()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !889
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_acquire.850(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_acquire(%struct.lockdep_map* %map, i32 0, i32 0, i32 2, i32 1, %struct.lockdep_map* null, i64 ptrtoint (i8* blockaddress(@rcu_lock_acquire.850, %__here) to i64))
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpcb_put_local(%struct.net* %net) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.855(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %rpcb_local_clnt = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 9
  %2 = load %struct.rpc_clnt*, %struct.rpc_clnt** %rpcb_local_clnt, align 8, !tbaa !890
  %rpcb_local_clnt4 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 10
  %3 = load %struct.rpc_clnt*, %struct.rpc_clnt** %rpcb_local_clnt4, align 8, !tbaa !891
  %rpcb_clnt_lock = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 11
  call void @spin_lock.856(%struct.spinlock* %rpcb_clnt_lock)
  %rpcb_users = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 12
  %4 = load i32, i32* %rpcb_users, align 8, !tbaa !892
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %rpcb_users1 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 12
  %5 = load i32, i32* %rpcb_users1, align 8, !tbaa !892
  %dec = add i32 %5, -1
  store i32 %dec, i32* %rpcb_users1, align 8, !tbaa !892
  %cmp = icmp eq i32 %dec, 0
  br i1 %cmp, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %rpcb_local_clnt3 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 9
  store %struct.rpc_clnt* null, %struct.rpc_clnt** %rpcb_local_clnt3, align 8, !tbaa !890
  %rpcb_local_clnt44 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 10
  store %struct.rpc_clnt* null, %struct.rpc_clnt** %rpcb_local_clnt44, align 8, !tbaa !891
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %rpcb_users5 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 12
  %6 = load i32, i32* %rpcb_users5, align 8, !tbaa !892
  %tobool6 = icmp ne i32 %6, 0
  %lnot = xor i1 %tobool6, true
  %lnot.ext = zext i1 %lnot to i32
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  %shutdown.0 = phi i32 [ %lnot.ext, %if.end ], [ 0, %entry ]
  %rpcb_clnt_lock8 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 11
  call void @spin_unlock.857(%struct.spinlock* %rpcb_clnt_lock8)
  %tobool9 = icmp ne i32 %shutdown.0, 0
  br i1 %tobool9, label %if.then10, label %if.end17

if.then10:                                        ; preds = %if.end7
  %tobool11 = icmp ne %struct.rpc_clnt* %3, null
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.then10
  call void @rpc_shutdown_client(%struct.rpc_clnt* %3)
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.then10
  %tobool14 = icmp ne %struct.rpc_clnt* %2, null
  br i1 %tobool14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end13
  call void @rpc_shutdown_client(%struct.rpc_clnt* %2)
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.end13, %if.end7
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @net_generic.855(%struct.net* %net, i32 %id) #2 {
entry:
  call void @rcu_read_lock.799()
  %gen = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 37
  %0 = load volatile %struct.net_generic*, %struct.net_generic** %gen, align 16, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.body8

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @net_generic.__warned.858, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %do.body8, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held.800()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.body8, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @net_generic.__warned.858, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 40, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.body8

do.body8:                                         ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %cmp = icmp eq i32 %id, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.body8
  %len = getelementptr inbounds %struct.net_generic, %struct.net_generic* %0, i32 0, i32 0
  %2 = load i32, i32* %len, align 8, !tbaa !176
  %cmp9 = icmp ugt i32 %id, %2
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %do.body8
  %3 = phi i1 [ true, %do.body8 ], [ %cmp9, %lor.rhs ]
  %lnot = xor i1 %3, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %do.body13, label %do.end21

do.body13:                                        ; preds = %lor.end
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 41, i64 12) #7, !srcloc !893
  br label %do.body14

do.body14:                                        ; preds = %do.body14, %do.body13
  br label %do.body14

do.end21:                                         ; preds = %lor.end
  %ptr22 = getelementptr inbounds %struct.net_generic, %struct.net_generic* %0, i32 0, i32 2
  %sub = sub nsw i32 %id, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [0 x i8*], [0 x i8*]* %ptr22, i64 0, i64 %idxprom
  %4 = load i8*, i8** %arrayidx, align 8, !tbaa !28
  call void @rcu_read_unlock.803()
  %tobool24 = icmp ne i8* %4, null
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %do.body35, label %do.end43

do.body35:                                        ; preds = %do.end21
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 45, i64 12) #7, !srcloc !894
  br label %do.body36

do.body36:                                        ; preds = %do.body36, %do.body35
  br label %do.body36

do.end43:                                         ; preds = %do.end21
  ret i8* %4
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock.856(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock.857(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @rpcb_create_local(%struct.net* %net) #0 {
entry:
  %call = call i32 @rpcb_get_local(%struct.net* %net)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @rpcb_create_local.rpcb_create_local_mutex, i32 0)
  %call1 = call i32 @rpcb_get_local(%struct.net* %net)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %out, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @rpcb_create_local_unix(%struct.net* %net)
  %cmp = icmp ne i32 %call5, 0
  br i1 %cmp, label %if.then6, label %out

if.then6:                                         ; preds = %if.end4
  %call7 = call i32 @rpcb_create_local_net(%struct.net* %net)
  br label %out

out:                                              ; preds = %if.then6, %if.end4, %if.end
  %result.1 = phi i32 [ 0, %if.end ], [ %call7, %if.then6 ], [ 0, %if.end4 ]
  call void @mutex_unlock(%struct.mutex* @rpcb_create_local.rpcb_create_local_mutex)
  br label %cleanup

cleanup:                                          ; preds = %out, %entry
  %retval.0 = phi i32 [ %result.1, %out ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rpcb_get_local(%struct.net* %net) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.855(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %rpcb_clnt_lock = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 11
  call void @spin_lock.856(%struct.spinlock* %rpcb_clnt_lock)
  %rpcb_users = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 12
  %2 = load i32, i32* %rpcb_users, align 8, !tbaa !892
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %rpcb_users1 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 12
  %3 = load i32, i32* %rpcb_users1, align 8, !tbaa !892
  %inc = add i32 %3, 1
  store i32 %inc, i32* %rpcb_users1, align 8, !tbaa !892
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rpcb_users2 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 12
  %4 = load i32, i32* %rpcb_users2, align 8, !tbaa !892
  %rpcb_clnt_lock3 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 11
  call void @spin_unlock.857(%struct.spinlock* %rpcb_clnt_lock3)
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal i32 @rpcb_create_local_unix(%struct.net* %net) #0 {
entry:
  %args = alloca %struct.rpc_create_args, align 8
  %net1 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 0
  store %struct.net* %net, %struct.net** %net1, align 8, !tbaa !198
  %protocol = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 1
  store i32 257, i32* %protocol, align 8, !tbaa !200
  %address = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 2
  store %struct.sockaddr* bitcast (%struct.sockaddr_un* @rpcb_create_local_unix.rpcb_localaddr_rpcbind to %struct.sockaddr*), %struct.sockaddr** %address, align 8, !tbaa !201
  %addrsize = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 3
  store i64 110, i64* %addrsize, align 8, !tbaa !202
  %saddress = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 4
  store %struct.sockaddr* null, %struct.sockaddr** %saddress, align 8, !tbaa !203
  %timeout = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 5
  store %struct.rpc_timeout* null, %struct.rpc_timeout** %timeout, align 8, !tbaa !204
  %servername = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 6
  store i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.18.862, i32 0, i32 0), i8** %servername, align 8, !tbaa !205
  %program = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 7
  store %struct.rpc_program* @rpcb_program, %struct.rpc_program** %program, align 8, !tbaa !206
  %prognumber = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 8
  store i32 0, i32* %prognumber, align 8, !tbaa !209
  %version = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 9
  store i32 2, i32* %version, align 4, !tbaa !210
  %authflavor = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 10
  store i32 0, i32* %authflavor, align 8, !tbaa !212
  %flags = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 11
  store i64 0, i64* %flags, align 8, !tbaa !213
  %client_name = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 12
  store i8* null, i8** %client_name, align 8, !tbaa !214
  %bc_xprt = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 13
  store %struct.svc_xprt* null, %struct.svc_xprt** %bc_xprt, align 8, !tbaa !215
  %call = call %struct.rpc_clnt* @rpc_create(%struct.rpc_create_args* %args)
  %0 = bitcast %struct.rpc_clnt* %call to i8*
  %call2 = call i64 @IS_ERR.811(i8* %0)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %do.body, label %if.end11

do.body:                                          ; preds = %entry
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 32
  %tobool3 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool3, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then6, label %do.end

if.then6:                                         ; preds = %do.body
  %2 = bitcast %struct.rpc_clnt* %call to i8*
  %call7 = call i64 @PTR_ERR.812(i8* %2)
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then6, %do.body
  %4 = bitcast %struct.rpc_clnt* %call to i8*
  %call9 = call i64 @PTR_ERR.812(i8* %4)
  %conv10 = trunc i64 %call9 to i32
  br label %out

if.end11:                                         ; preds = %entry
  %call12 = call %struct.rpc_clnt* @rpc_bind_new_program(%struct.rpc_clnt* %call, %struct.rpc_program* @rpcb_program, i32 4)
  %5 = bitcast %struct.rpc_clnt* %call12 to i8*
  %call13 = call i64 @IS_ERR.811(i8* %5)
  %tobool14 = icmp ne i64 %call13, 0
  br i1 %tobool14, label %do.body16, label %if.end32

do.body16:                                        ; preds = %if.end11
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and17 = and i32 %6, 32
  %tobool18 = icmp ne i32 %and17, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %if.then26, label %if.end32

if.then26:                                        ; preds = %do.body16
  %7 = bitcast %struct.rpc_clnt* %call12 to i8*
  %call27 = call i64 @PTR_ERR.812(i8* %7)
  %8 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end32

if.end32:                                         ; preds = %if.then26, %do.body16, %if.end11
  %clnt4.0 = phi %struct.rpc_clnt* [ %call12, %if.end11 ], [ null, %if.then26 ], [ null, %do.body16 ]
  call void @rpcb_set_local(%struct.net* %net, %struct.rpc_clnt* %call, %struct.rpc_clnt* %clnt4.0)
  br label %out

out:                                              ; preds = %if.end32, %do.end
  %result.0 = phi i32 [ %conv10, %do.end ], [ 0, %if.end32 ]
  ret i32 %result.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rpcb_create_local_net(%struct.net* %net) #0 {
entry:
  %args = alloca %struct.rpc_create_args, align 8
  %net1 = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 0
  store %struct.net* %net, %struct.net** %net1, align 8, !tbaa !198
  %protocol = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 1
  store i32 6, i32* %protocol, align 8, !tbaa !200
  %address = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 2
  store %struct.sockaddr* bitcast (%struct.sockaddr_in* @rpcb_create_local_net.rpcb_inaddr_loopback to %struct.sockaddr*), %struct.sockaddr** %address, align 8, !tbaa !201
  %addrsize = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 3
  store i64 16, i64* %addrsize, align 8, !tbaa !202
  %saddress = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 4
  store %struct.sockaddr* null, %struct.sockaddr** %saddress, align 8, !tbaa !203
  %timeout = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 5
  store %struct.rpc_timeout* null, %struct.rpc_timeout** %timeout, align 8, !tbaa !204
  %servername = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 6
  store i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.18.862, i32 0, i32 0), i8** %servername, align 8, !tbaa !205
  %program = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 7
  store %struct.rpc_program* @rpcb_program, %struct.rpc_program** %program, align 8, !tbaa !206
  %prognumber = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 8
  store i32 0, i32* %prognumber, align 8, !tbaa !209
  %version = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 9
  store i32 2, i32* %version, align 4, !tbaa !210
  %authflavor = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 10
  store i32 1, i32* %authflavor, align 8, !tbaa !212
  %flags = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 11
  store i64 16, i64* %flags, align 8, !tbaa !213
  %client_name = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 12
  store i8* null, i8** %client_name, align 8, !tbaa !214
  %bc_xprt = getelementptr inbounds %struct.rpc_create_args, %struct.rpc_create_args* %args, i32 0, i32 13
  store %struct.svc_xprt* null, %struct.svc_xprt** %bc_xprt, align 8, !tbaa !215
  %call = call %struct.rpc_clnt* @rpc_create(%struct.rpc_create_args* %args)
  %0 = bitcast %struct.rpc_clnt* %call to i8*
  %call2 = call i64 @IS_ERR.811(i8* %0)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %do.body, label %if.end11

do.body:                                          ; preds = %entry
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 32
  %tobool3 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool3, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then6, label %do.end

if.then6:                                         ; preds = %do.body
  %2 = bitcast %struct.rpc_clnt* %call to i8*
  %call7 = call i64 @PTR_ERR.812(i8* %2)
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then6, %do.body
  %4 = bitcast %struct.rpc_clnt* %call to i8*
  %call9 = call i64 @PTR_ERR.812(i8* %4)
  %conv10 = trunc i64 %call9 to i32
  br label %out

if.end11:                                         ; preds = %entry
  %call12 = call %struct.rpc_clnt* @rpc_bind_new_program(%struct.rpc_clnt* %call, %struct.rpc_program* @rpcb_program, i32 4)
  %5 = bitcast %struct.rpc_clnt* %call12 to i8*
  %call13 = call i64 @IS_ERR.811(i8* %5)
  %tobool14 = icmp ne i64 %call13, 0
  br i1 %tobool14, label %do.body16, label %if.end32

do.body16:                                        ; preds = %if.end11
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and17 = and i32 %6, 32
  %tobool18 = icmp ne i32 %and17, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %if.then26, label %if.end32

if.then26:                                        ; preds = %do.body16
  %7 = bitcast %struct.rpc_clnt* %call12 to i8*
  %call27 = call i64 @PTR_ERR.812(i8* %7)
  %8 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end32

if.end32:                                         ; preds = %if.then26, %do.body16, %if.end11
  %clnt4.0 = phi %struct.rpc_clnt* [ %call12, %if.end11 ], [ null, %if.then26 ], [ null, %do.body16 ]
  call void @rpcb_set_local(%struct.net* %net, %struct.rpc_clnt* %call, %struct.rpc_clnt* %clnt4.0)
  br label %out

out:                                              ; preds = %if.end32, %do.end
  %result.0 = phi i32 [ %conv10, %do.end ], [ 0, %if.end32 ]
  ret i32 %result.0
}

; Function Attrs: nounwind uwtable
define internal void @rpcb_set_local(%struct.net* %net, %struct.rpc_clnt* %clnt, %struct.rpc_clnt* %clnt4) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.855(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %rpcb_local_clnt = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 9
  store %struct.rpc_clnt* %clnt, %struct.rpc_clnt** %rpcb_local_clnt, align 8, !tbaa !890
  %rpcb_local_clnt4 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 10
  store %struct.rpc_clnt* %clnt4, %struct.rpc_clnt** %rpcb_local_clnt4, align 8, !tbaa !891
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !895
  %rpcb_users = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 12
  store i32 1, i32* %rpcb_users, align 8, !tbaa !892
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 32
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @rpcb_register(%struct.net* %net, i32 %prog, i32 %vers, i32 %prot, i16 zeroext %port) #0 {
entry:
  %map = alloca %struct.rpcbind_args, align 8
  %msg = alloca %struct.rpc_message, align 8
  %0 = bitcast %struct.rpcbind_args* %map to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 56, i32 8, i1 false)
  %r_prog = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %map, i32 0, i32 1
  store i32 %prog, i32* %r_prog, align 8, !tbaa !869
  %r_vers = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %map, i32 0, i32 2
  store i32 %vers, i32* %r_vers, align 4, !tbaa !871
  %r_prot = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %map, i32 0, i32 3
  store i32 %prot, i32* %r_prot, align 8, !tbaa !872
  %r_port = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %map, i32 0, i32 4
  store i16 %port, i16* %r_port, align 4, !tbaa !873
  %1 = bitcast %struct.rpc_message* %msg to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 32, i32 8, i1 false)
  %rpc_argp = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 1
  %2 = bitcast %struct.rpcbind_args* %map to i8*
  store i8* %2, i8** %rpc_argp, align 8, !tbaa !7
  %3 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.855(%struct.net* %net, i32 %3)
  %4 = bitcast i8* %call to %struct.sunrpc_net*
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %5, 32
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 0
  store %struct.rpc_procinfo* getelementptr inbounds ([4 x %struct.rpc_procinfo], [4 x %struct.rpc_procinfo]* @rpcb_procedures2, i64 0, i64 2), %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !2
  %tobool7 = icmp ne i16 %port, 0
  br i1 %tobool7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %do.end
  %rpc_proc9 = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 0
  store %struct.rpc_procinfo* getelementptr inbounds ([4 x %struct.rpc_procinfo], [4 x %struct.rpc_procinfo]* @rpcb_procedures2, i64 0, i64 1), %struct.rpc_procinfo** %rpc_proc9, align 8, !tbaa !2
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %do.end
  %rpcb_local_clnt = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %4, i32 0, i32 9
  %7 = load %struct.rpc_clnt*, %struct.rpc_clnt** %rpcb_local_clnt, align 8, !tbaa !890
  %call11 = call i32 @rpcb_register_call(%struct.rpc_clnt* %7, %struct.rpc_message* %msg)
  ret i32 %call11
}

; Function Attrs: nounwind uwtable
define internal i32 @rpcb_register_call(%struct.rpc_clnt* %clnt, %struct.rpc_message* %msg) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %rpc_resp = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 2
  store i8* %0, i8** %rpc_resp, align 8, !tbaa !8
  %call = call i32 @rpc_call_sync(%struct.rpc_clnt* %clnt, %struct.rpc_message* %msg, i32 1024)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %do.body, label %if.end5

do.body:                                          ; preds = %entry
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 32
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then3, label %cleanup

if.then3:                                         ; preds = %do.body
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end5:                                          ; preds = %entry
  %3 = load i32, i32* %result, align 4, !tbaa !49
  %tobool6 = icmp ne i32 %3, 0
  %. = select i1 %tobool6, i32 0, i32 -13
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %if.then3, %do.body
  %retval.0 = phi i32 [ %call, %if.then3 ], [ %call, %do.body ], [ %., %if.end5 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @rpcb_v4_register(%struct.net* %net, i32 %program, i32 %version, %struct.sockaddr* %address, i8* %netid) #0 {
entry:
  %map = alloca %struct.rpcbind_args, align 8
  %msg = alloca %struct.rpc_message, align 8
  %r_xprt = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %map, i32 0, i32 0
  store %struct.rpc_xprt* null, %struct.rpc_xprt** %r_xprt, align 8, !tbaa !874
  %r_prog = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %map, i32 0, i32 1
  store i32 %program, i32* %r_prog, align 8, !tbaa !869
  %r_vers = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %map, i32 0, i32 2
  store i32 %version, i32* %r_vers, align 4, !tbaa !871
  %r_prot = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %map, i32 0, i32 3
  store i32 0, i32* %r_prot, align 8, !tbaa !872
  %r_port = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %map, i32 0, i32 4
  store i16 0, i16* %r_port, align 4, !tbaa !873
  %r_netid = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %map, i32 0, i32 5
  store i8* %netid, i8** %r_netid, align 8, !tbaa !876
  %r_addr = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %map, i32 0, i32 6
  store i8* null, i8** %r_addr, align 8, !tbaa !877
  %r_owner = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %map, i32 0, i32 7
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5.877, i32 0, i32 0), i8** %r_owner, align 8, !tbaa !878
  %r_status = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %map, i32 0, i32 8
  store i32 0, i32* %r_status, align 8, !tbaa !875
  %0 = bitcast %struct.rpc_message* %msg to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 32, i32 8, i1 false)
  %rpc_argp = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 1
  %1 = bitcast %struct.rpcbind_args* %map to i8*
  store i8* %1, i8** %rpc_argp, align 8, !tbaa !7
  %2 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.855(%struct.net* %net, i32 %2)
  %3 = bitcast i8* %call to %struct.sunrpc_net*
  %rpcb_local_clnt4 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %3, i32 0, i32 10
  %4 = load %struct.rpc_clnt*, %struct.rpc_clnt** %rpcb_local_clnt4, align 8, !tbaa !891
  %cmp = icmp eq %struct.rpc_clnt* %4, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp eq %struct.sockaddr* %address, null
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %call3 = call i32 @rpcb_unregister_all_protofamilies(%struct.sunrpc_net* %3, %struct.rpc_message* %msg)
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %address, i32 0, i32 0
  %5 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %5 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end4
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb6, label %cleanup

LeafBlock:                                        ; preds = %if.end4
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %LeafBlock
  %call5 = call i32 @rpcb_register_inet4(%struct.sunrpc_net* %3, %struct.sockaddr* %address, %struct.rpc_message* %msg)
  br label %cleanup

sw.bb6:                                           ; preds = %LeafBlock1
  %call7 = call i32 @rpcb_register_inet6(%struct.sunrpc_net* %3, %struct.sockaddr* %address, %struct.rpc_message* %msg)
  br label %cleanup

cleanup:                                          ; preds = %sw.bb6, %sw.bb, %LeafBlock, %LeafBlock1, %if.then2, %entry
  %retval.0 = phi i32 [ %call3, %if.then2 ], [ %call5, %sw.bb ], [ %call7, %sw.bb6 ], [ -93, %entry ], [ -97, %LeafBlock ], [ -97, %LeafBlock1 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rpcb_unregister_all_protofamilies(%struct.sunrpc_net* %sn, %struct.rpc_message* %msg) #0 {
entry:
  %rpc_argp = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 1
  %0 = load i8*, i8** %rpc_argp, align 8, !tbaa !7
  %1 = bitcast i8* %0 to %struct.rpcbind_args*
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 32
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %r_addr = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %1, i32 0, i32 6
  store i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.31.1130, i32 0, i32 0), i8** %r_addr, align 8, !tbaa !877
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 0
  store %struct.rpc_procinfo* getelementptr inbounds ([4 x %struct.rpc_procinfo], [4 x %struct.rpc_procinfo]* @rpcb_procedures4, i64 0, i64 2), %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !2
  %rpcb_local_clnt4 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %sn, i32 0, i32 10
  %4 = load %struct.rpc_clnt*, %struct.rpc_clnt** %rpcb_local_clnt4, align 8, !tbaa !891
  %call3 = call i32 @rpcb_register_call(%struct.rpc_clnt* %4, %struct.rpc_message* %msg)
  ret i32 %call3
}

; Function Attrs: nounwind uwtable
define internal i32 @rpcb_register_inet4(%struct.sunrpc_net* %sn, %struct.sockaddr* %sap, %struct.rpc_message* %msg) #0 {
entry:
  %0 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in*
  %rpc_argp = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 1
  %1 = load i8*, i8** %rpc_argp, align 8, !tbaa !7
  %2 = bitcast i8* %1 to %struct.rpcbind_args*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %0, i32 0, i32 1
  %3 = load i16, i16* %sin_port, align 2, !tbaa !191
  %call = call zeroext i16 @__fswab16.832(i16 zeroext %3) #3
  %conv = zext i16 %call to i32
  %conv1 = trunc i32 %conv to i16
  %call2 = call i8* @rpc_sockaddr2uaddr(%struct.sockaddr* %sap, i32 208)
  %r_addr = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %2, i32 0, i32 6
  store i8* %call2, i8** %r_addr, align 8, !tbaa !877
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %4, 32
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 0
  store %struct.rpc_procinfo* getelementptr inbounds ([4 x %struct.rpc_procinfo], [4 x %struct.rpc_procinfo]* @rpcb_procedures4, i64 0, i64 2), %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !2
  %tobool10 = icmp ne i16 %conv1, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %do.end
  %rpc_proc12 = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 0
  store %struct.rpc_procinfo* getelementptr inbounds ([4 x %struct.rpc_procinfo], [4 x %struct.rpc_procinfo]* @rpcb_procedures4, i64 0, i64 1), %struct.rpc_procinfo** %rpc_proc12, align 8, !tbaa !2
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %do.end
  %rpcb_local_clnt4 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %sn, i32 0, i32 10
  %6 = load %struct.rpc_clnt*, %struct.rpc_clnt** %rpcb_local_clnt4, align 8, !tbaa !891
  %call14 = call i32 @rpcb_register_call(%struct.rpc_clnt* %6, %struct.rpc_message* %msg)
  %r_addr15 = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %2, i32 0, i32 6
  %7 = load i8*, i8** %r_addr15, align 8, !tbaa !877
  call void @kfree(i8* %7)
  ret i32 %call14
}

; Function Attrs: nounwind uwtable
define internal i32 @rpcb_register_inet6(%struct.sunrpc_net* %sn, %struct.sockaddr* %sap, %struct.rpc_message* %msg) #0 {
entry:
  %0 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in6*
  %rpc_argp = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 1
  %1 = load i8*, i8** %rpc_argp, align 8, !tbaa !7
  %2 = bitcast i8* %1 to %struct.rpcbind_args*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %0, i32 0, i32 1
  %3 = load i16, i16* %sin6_port, align 2, !tbaa !194
  %call = call zeroext i16 @__fswab16.832(i16 zeroext %3) #3
  %conv = zext i16 %call to i32
  %conv1 = trunc i32 %conv to i16
  %call2 = call i8* @rpc_sockaddr2uaddr(%struct.sockaddr* %sap, i32 208)
  %r_addr = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %2, i32 0, i32 6
  store i8* %call2, i8** %r_addr, align 8, !tbaa !877
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %4, 32
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 0
  store %struct.rpc_procinfo* getelementptr inbounds ([4 x %struct.rpc_procinfo], [4 x %struct.rpc_procinfo]* @rpcb_procedures4, i64 0, i64 2), %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !2
  %tobool10 = icmp ne i16 %conv1, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %do.end
  %rpc_proc12 = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %msg, i32 0, i32 0
  store %struct.rpc_procinfo* getelementptr inbounds ([4 x %struct.rpc_procinfo], [4 x %struct.rpc_procinfo]* @rpcb_procedures4, i64 0, i64 1), %struct.rpc_procinfo** %rpc_proc12, align 8, !tbaa !2
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %do.end
  %rpcb_local_clnt4 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %sn, i32 0, i32 10
  %6 = load %struct.rpc_clnt*, %struct.rpc_clnt** %rpcb_local_clnt4, align 8, !tbaa !891
  %call14 = call i32 @rpcb_register_call(%struct.rpc_clnt* %6, %struct.rpc_message* %msg)
  %r_addr15 = getelementptr inbounds %struct.rpcbind_args, %struct.rpcbind_args* %2, i32 0, i32 6
  %7 = load i8*, i8** %r_addr15, align 8, !tbaa !877
  call void @kfree(i8* %7)
  ret i32 %call14
}

; Function Attrs: nounwind uwtable
define i64 @rpc_calc_rto(%struct.rpc_rtt* %rt, i32 %timer) #0 {
entry:
  %dec = add i32 %timer, -1
  %cmp = icmp eq i32 %timer, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %timeo = getelementptr inbounds %struct.rpc_rtt, %struct.rpc_rtt* %rt, i32 0, i32 0
  %0 = load i64, i64* %timeo, align 8, !tbaa !896
  br label %cleanup

if.end:                                           ; preds = %entry
  %srtt = getelementptr inbounds %struct.rpc_rtt, %struct.rpc_rtt* %rt, i32 0, i32 1
  %idxprom = zext i32 %dec to i64
  %arrayidx = getelementptr inbounds [5 x i64], [5 x i64]* %srtt, i64 0, i64 %idxprom
  %1 = load i64, i64* %arrayidx, align 8, !tbaa !88
  %add = add i64 %1, 7
  %shr = lshr i64 %add, 3
  %sdrtt = getelementptr inbounds %struct.rpc_rtt, %struct.rpc_rtt* %rt, i32 0, i32 2
  %idxprom1 = zext i32 %dec to i64
  %arrayidx2 = getelementptr inbounds [5 x i64], [5 x i64]* %sdrtt, i64 0, i64 %idxprom1
  %2 = load i64, i64* %arrayidx2, align 8, !tbaa !88
  %add3 = add i64 %shr, %2
  %cmp4 = icmp ugt i64 %add3, 15000
  %.add3 = select i1 %cmp4, i64 15000, i64 %add3
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %0, %if.then ], [ %.add3, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define void @rpc_update_rtt(%struct.rpc_rtt* %rt, i32 %timer, i64 %m) #0 {
entry:
  %dec = add i32 %timer, -1
  %cmp = icmp eq i32 %timer, 0
  %cmp1 = icmp slt i64 %m, 0
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %cleanup.cont, label %if.end3

if.end3:                                          ; preds = %entry
  %cmp4 = icmp eq i64 %m, 0
  %.m = select i1 %cmp4, i64 1, i64 %m
  %srtt7 = getelementptr inbounds %struct.rpc_rtt, %struct.rpc_rtt* %rt, i32 0, i32 1
  %idxprom = zext i32 %dec to i64
  %arrayidx = getelementptr inbounds [5 x i64], [5 x i64]* %srtt7, i64 0, i64 %idxprom
  %0 = load i64, i64* %arrayidx, align 8, !tbaa !88
  %shr = ashr i64 %0, 3
  %sub = sub nsw i64 %.m, %shr
  %1 = load i64, i64* %arrayidx, align 8, !tbaa !88
  %add = add nsw i64 %1, %sub
  store i64 %add, i64* %arrayidx, align 8, !tbaa !88
  %cmp8 = icmp slt i64 %sub, 0
  %sub10 = sub nsw i64 0, %sub
  %m.addr.1 = select i1 %cmp8, i64 %sub10, i64 %sub
  %sdrtt12 = getelementptr inbounds %struct.rpc_rtt, %struct.rpc_rtt* %rt, i32 0, i32 2
  %idxprom13 = zext i32 %dec to i64
  %arrayidx14 = getelementptr inbounds [5 x i64], [5 x i64]* %sdrtt12, i64 0, i64 %idxprom13
  %2 = load i64, i64* %arrayidx14, align 8, !tbaa !88
  %shr15 = ashr i64 %2, 2
  %sub16 = sub nsw i64 %m.addr.1, %shr15
  %3 = load i64, i64* %arrayidx14, align 8, !tbaa !88
  %add17 = add nsw i64 %3, %sub16
  store i64 %add17, i64* %arrayidx14, align 8, !tbaa !88
  %4 = load i64, i64* %arrayidx14, align 8, !tbaa !88
  %cmp18 = icmp slt i64 %4, 25
  %.add17 = select i1 %cmp18, i64 25, i64 %add17
  store i64 %.add17, i64* %arrayidx14, align 8
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end3, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_init_rtt(%struct.rpc_rtt* %rt, i64 %timeo) #0 {
entry:
  %timeo1 = getelementptr inbounds %struct.rpc_rtt, %struct.rpc_rtt* %rt, i32 0, i32 0
  store i64 %timeo, i64* %timeo1, align 8, !tbaa !896
  %cmp = icmp ugt i64 %timeo, 50
  %sub = sub i64 %timeo, 50
  %shl = shl i64 %sub, 3
  %init.0 = select i1 %cmp, i64 %shl, i64 0
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp2 = icmp ult i32 %i.0, 5
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %srtt = getelementptr inbounds %struct.rpc_rtt, %struct.rpc_rtt* %rt, i32 0, i32 1
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [5 x i64], [5 x i64]* %srtt, i64 0, i64 %idxprom
  store i64 %init.0, i64* %arrayidx, align 8, !tbaa !88
  %sdrtt = getelementptr inbounds %struct.rpc_rtt, %struct.rpc_rtt* %rt, i32 0, i32 2
  %idxprom3 = zext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds [5 x i64], [5 x i64]* %sdrtt, i64 0, i64 %idxprom3
  store i64 50, i64* %arrayidx4, align 8, !tbaa !88
  %ntimeouts = getelementptr inbounds %struct.rpc_rtt, %struct.rpc_rtt* %rt, i32 0, i32 3
  %idxprom5 = zext i32 %i.0 to i64
  %arrayidx6 = getelementptr inbounds [5 x i32], [5 x i32]* %ntimeouts, i64 0, i64 %idxprom5
  store i32 0, i32* %arrayidx6, align 4, !tbaa !49
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @xdr_process_buf(%struct.xdr_buf* %buf, i32 %offset, i32 %len, i32 (%struct.scatterlist*, i8*)* %actor, i8* %data) #0 {
entry:
  %sg = alloca [1 x %struct.scatterlist], align 16
  %arraydecay = getelementptr inbounds [1 x %struct.scatterlist], [1 x %struct.scatterlist]* %sg, i32 0, i32 0
  call void @sg_init_table(%struct.scatterlist* %arraydecay, i32 1)
  %conv = zext i32 %offset to i64
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %0 = load i64, i64* %iov_len, align 8, !tbaa !149
  %cmp = icmp uge i64 %conv, %0
  %head2 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head2, i64 0, i64 0
  %iov_len4 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx3, i32 0, i32 1
  %1 = load i64, i64* %iov_len4, align 8, !tbaa !149
  %conv5 = zext i32 %offset to i64
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %sub = sub i64 %conv5, %1
  %conv6 = trunc i64 %sub to i32
  br label %if.end23

if.else:                                          ; preds = %entry
  %sub11 = sub i64 %1, %conv5
  %conv12 = trunc i64 %sub11 to i32
  %cmp13 = icmp ugt i32 %conv12, %len
  %len.conv12 = select i1 %cmp13, i32 %len, i32 %conv12
  %arraydecay16 = getelementptr inbounds [1 x %struct.scatterlist], [1 x %struct.scatterlist]* %sg, i32 0, i32 0
  %head17 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx18 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head17, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx18, i32 0, i32 0
  %2 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %2, i64 %idx.ext
  call void @sg_set_buf(%struct.scatterlist* %arraydecay16, i8* %add.ptr, i32 %len.conv12)
  %arraydecay19 = getelementptr inbounds [1 x %struct.scatterlist], [1 x %struct.scatterlist]* %sg, i32 0, i32 0
  %call = call i32 %actor(%struct.scatterlist* %arraydecay19, i8* %data)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %out, label %if.end21

if.end21:                                         ; preds = %if.else
  %sub22 = sub i32 %len, %len.conv12
  br label %if.end23

if.end23:                                         ; preds = %if.end21, %if.then
  %ret.0 = phi i32 [ 0, %if.then ], [ %call, %if.end21 ]
  %len.addr.0 = phi i32 [ %len, %if.then ], [ %sub22, %if.end21 ]
  %offset.addr.0 = phi i32 [ %conv6, %if.then ], [ 0, %if.end21 ]
  %cmp24 = icmp eq i32 %len.addr.0, 0
  br i1 %cmp24, label %out, label %if.end27

if.end27:                                         ; preds = %if.end23
  %page_len28 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %3 = load i32, i32* %page_len28, align 4, !tbaa !150
  %cmp29 = icmp uge i32 %offset.addr.0, %3
  %page_len32 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %4 = load i32, i32* %page_len32, align 4, !tbaa !150
  br i1 %cmp29, label %if.then31, label %if.else34

if.then31:                                        ; preds = %if.end27
  %sub33 = sub i32 %offset.addr.0, %4
  br label %if.end63

if.else34:                                        ; preds = %if.end27
  %sub36 = sub i32 %4, %offset.addr.0
  %cmp37 = icmp ugt i32 %sub36, %len.addr.0
  %len.addr.0.sub36 = select i1 %cmp37, i32 %len.addr.0, i32 %sub36
  %sub41 = sub i32 %len.addr.0, %len.addr.0.sub36
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 3
  %5 = load i32, i32* %page_base, align 8, !tbaa !355
  %add = add i32 %offset.addr.0, %5
  %conv42 = zext i32 %add to i64
  %and = and i64 %conv42, 4095
  %conv43 = trunc i64 %and to i32
  %page_base44 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 3
  %6 = load i32, i32* %page_base44, align 8, !tbaa !355
  %add45 = add i32 %offset.addr.0, %6
  %shr = lshr i32 %add45, 12
  %conv46 = zext i32 %conv43 to i64
  %sub47 = sub i64 4096, %conv46
  %conv48 = trunc i64 %sub47 to i32
  br label %do.body

do.body:                                          ; preds = %if.end59, %if.else34
  %i.0 = phi i32 [ %shr, %if.else34 ], [ %inc, %if.end59 ]
  %page_len.1 = phi i32 [ %len.addr.0.sub36, %if.else34 ], [ %sub60, %if.end59 ]
  %thislen.1 = phi i32 [ %conv48, %if.else34 ], [ 4096, %if.end59 ]
  %page_offset.0 = phi i32 [ %conv43, %if.else34 ], [ 0, %if.end59 ]
  %cmp49 = icmp ugt i32 %thislen.1, %page_len.1
  %page_len.1.thislen.1 = select i1 %cmp49, i32 %page_len.1, i32 %thislen.1
  %arraydecay53 = getelementptr inbounds [1 x %struct.scatterlist], [1 x %struct.scatterlist]* %sg, i32 0, i32 0
  %pages = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 2
  %7 = load %struct.page**, %struct.page*** %pages, align 8, !tbaa !354
  %idxprom = sext i32 %i.0 to i64
  %arrayidx54 = getelementptr inbounds %struct.page*, %struct.page** %7, i64 %idxprom
  %8 = load %struct.page*, %struct.page** %arrayidx54, align 8, !tbaa !28
  call void @sg_set_page(%struct.scatterlist* %arraydecay53, %struct.page* %8, i32 %page_len.1.thislen.1, i32 %page_offset.0)
  %arraydecay55 = getelementptr inbounds [1 x %struct.scatterlist], [1 x %struct.scatterlist]* %sg, i32 0, i32 0
  %call56 = call i32 %actor(%struct.scatterlist* %arraydecay55, i8* %data)
  %tobool57 = icmp ne i32 %call56, 0
  br i1 %tobool57, label %out, label %if.end59

if.end59:                                         ; preds = %do.body
  %sub60 = sub i32 %page_len.1, %page_len.1.thislen.1
  %inc = add nsw i32 %i.0, 1
  %cmp61 = icmp ne i32 %sub60, 0
  br i1 %cmp61, label %do.body, label %if.end63

if.end63:                                         ; preds = %if.end59, %if.then31
  %ret.1 = phi i32 [ %ret.0, %if.then31 ], [ %call56, %if.end59 ]
  %len.addr.1 = phi i32 [ %len.addr.0, %if.then31 ], [ %sub41, %if.end59 ]
  %offset.addr.1 = phi i32 [ %sub33, %if.then31 ], [ 0, %if.end59 ]
  %cmp64 = icmp eq i32 %len.addr.1, 0
  br i1 %cmp64, label %out, label %if.end67

if.end67:                                         ; preds = %if.end63
  %conv68 = zext i32 %offset.addr.1 to i64
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arrayidx69 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_len70 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx69, i32 0, i32 1
  %9 = load i64, i64* %iov_len70, align 8, !tbaa !149
  %cmp71 = icmp ult i64 %conv68, %9
  br i1 %cmp71, label %if.then73, label %if.end93

if.then73:                                        ; preds = %if.end67
  %tail74 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arrayidx75 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail74, i64 0, i64 0
  %iov_len76 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx75, i32 0, i32 1
  %10 = load i64, i64* %iov_len76, align 8, !tbaa !149
  %conv77 = zext i32 %offset.addr.1 to i64
  %sub78 = sub i64 %10, %conv77
  %conv79 = trunc i64 %sub78 to i32
  %cmp80 = icmp ugt i32 %conv79, %len.addr.1
  %len.addr.1.conv79 = select i1 %cmp80, i32 %len.addr.1, i32 %conv79
  %arraydecay84 = getelementptr inbounds [1 x %struct.scatterlist], [1 x %struct.scatterlist]* %sg, i32 0, i32 0
  %tail85 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arrayidx86 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail85, i64 0, i64 0
  %iov_base87 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx86, i32 0, i32 0
  %11 = load i8*, i8** %iov_base87, align 8, !tbaa !147
  %idx.ext88 = zext i32 %offset.addr.1 to i64
  %add.ptr89 = getelementptr i8, i8* %11, i64 %idx.ext88
  call void @sg_set_buf(%struct.scatterlist* %arraydecay84, i8* %add.ptr89, i32 %len.addr.1.conv79)
  %arraydecay90 = getelementptr inbounds [1 x %struct.scatterlist], [1 x %struct.scatterlist]* %sg, i32 0, i32 0
  %call91 = call i32 %actor(%struct.scatterlist* %arraydecay90, i8* %data)
  %sub92 = sub i32 %len.addr.1, %len.addr.1.conv79
  br label %if.end93

if.end93:                                         ; preds = %if.then73, %if.end67
  %ret.2 = phi i32 [ %call91, %if.then73 ], [ %ret.1, %if.end67 ]
  %len.addr.2 = phi i32 [ %sub92, %if.then73 ], [ %len.addr.1, %if.end67 ]
  %cmp94 = icmp ne i32 %len.addr.2, 0
  %.ret.2 = select i1 %cmp94, i32 -22, i32 %ret.2
  br label %out

out:                                              ; preds = %if.end93, %if.end63, %do.body, %if.end23, %if.else
  %ret.4 = phi i32 [ %.ret.2, %if.end93 ], [ %call, %if.else ], [ %ret.0, %if.end23 ], [ %call56, %do.body ], [ %ret.1, %if.end63 ]
  ret i32 %ret.4
}

declare void @sg_init_table(%struct.scatterlist*, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_set_buf(%struct.scatterlist* %sg, i8* %buf, i32 %buflen) #2 {
entry:
  %0 = ptrtoint i8* %buf to i64
  %call = call zeroext i1 @__virt_addr_valid(i64 %0)
  %lnot = xor i1 %call, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body3, label %do.end8

do.body3:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.2.888, i32 0, i32 0), i32 115, i64 12) #7, !srcloc !897
  br label %do.body4

do.body4:                                         ; preds = %do.body4, %do.body3
  br label %do.body4

do.end8:                                          ; preds = %entry
  %1 = ptrtoint i8* %buf to i64
  %call9 = call i64 @__phys_addr(i64 %1)
  %shr = lshr i64 %call9, 12
  %add.ptr = getelementptr inbounds %struct.page, %struct.page* inttoptr (i64 -24189255811072 to %struct.page*), i64 %shr
  %2 = ptrtoint i8* %buf to i64
  %and = and i64 %2, 4095
  %conv10 = trunc i64 %and to i32
  call void @sg_set_page(%struct.scatterlist* %sg, %struct.page* %add.ptr, i32 %buflen, i32 %conv10)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_set_page(%struct.scatterlist* %sg, %struct.page* %page, i32 %len, i32 %offset) #2 {
entry:
  call void @sg_assign_page(%struct.scatterlist* %sg, %struct.page* %page)
  %offset1 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 2
  store i32 %offset, i32* %offset1, align 8, !tbaa !898
  %length = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 3
  store i32 %len, i32* %length, align 4, !tbaa !900
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_assign_page(%struct.scatterlist* %sg, %struct.page* %page) #2 {
entry:
  %page_link1 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %0 = load i64, i64* %page_link1, align 8, !tbaa !901
  %and = and i64 %0, 3
  %1 = ptrtoint %struct.page* %page to i64
  %and2 = and i64 %1, 3
  %tobool = icmp ne i64 %and2, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.body11

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.2.888, i32 0, i32 0), i32 65, i64 12) #7, !srcloc !902
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.body11:                                        ; preds = %entry
  %sg_magic = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 0
  %2 = load i64, i64* %sg_magic, align 8, !tbaa !903
  %cmp = icmp ne i64 %2, 2271560481
  %lnot13 = xor i1 %cmp, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv17 = sext i32 %lnot.ext16 to i64
  %expval18 = call i64 @llvm.expect.i64(i64 %conv17, i64 0)
  %tobool19 = icmp ne i64 %expval18, 0
  br i1 %tobool19, label %do.body21, label %do.body30

do.body21:                                        ; preds = %do.body11
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.2.888, i32 0, i32 0), i32 67, i64 12) #7, !srcloc !904
  br label %do.body22

do.body22:                                        ; preds = %do.body22, %do.body21
  br label %do.body22

do.body30:                                        ; preds = %do.body11
  %page_link31 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %3 = load i64, i64* %page_link31, align 8, !tbaa !901
  %and32 = and i64 %3, 1
  %tobool33 = icmp ne i64 %and32, 0
  %lnot34 = xor i1 %tobool33, true
  %lnot36 = xor i1 %lnot34, true
  %lnot.ext37 = zext i1 %lnot36 to i32
  %conv38 = sext i32 %lnot.ext37 to i64
  %expval39 = call i64 @llvm.expect.i64(i64 %conv38, i64 0)
  %tobool40 = icmp ne i64 %expval39, 0
  br i1 %tobool40, label %do.body42, label %do.end50

do.body42:                                        ; preds = %do.body30
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.2.888, i32 0, i32 0), i32 68, i64 12) #7, !srcloc !905
  br label %do.body43

do.body43:                                        ; preds = %do.body43, %do.body42
  br label %do.body43

do.end50:                                         ; preds = %do.body30
  %4 = ptrtoint %struct.page* %page to i64
  %or = or i64 %and, %4
  %page_link51 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  store i64 %or, i64* %page_link51, align 8, !tbaa !901
  ret void
}

declare zeroext i1 @__virt_addr_valid(i64) #4

; Function Attrs: nounwind uwtable
define i32 @xdr_encode_array2(%struct.xdr_buf* %buf, i32 %base, %struct.xdr_array2_desc* %desc) #0 {
entry:
  %conv = zext i32 %base to i64
  %add = add i64 %conv, 4
  %array_len = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 1
  %0 = load i32, i32* %array_len, align 4, !tbaa !906
  %elem_size = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %1 = load i32, i32* %elem_size, align 8, !tbaa !908
  %mul = mul i32 %0, %1
  %conv1 = zext i32 %mul to i64
  %add2 = add i64 %add, %conv1
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i32 0, i32 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %2 = load i64, i64* %iov_len, align 8, !tbaa !149
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %3 = load i32, i32* %page_len, align 4, !tbaa !150
  %conv3 = zext i32 %3 to i64
  %add4 = add i64 %2, %conv3
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arraydecay5 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i32 0, i32 0
  %iov_len6 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay5, i32 0, i32 1
  %4 = load i64, i64* %iov_len6, align 8, !tbaa !149
  %add7 = add i64 %add4, %4
  %cmp = icmp ugt i64 %add2, %add7
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @xdr_xcode_array2(%struct.xdr_buf* %buf, i32 %base, %struct.xdr_array2_desc* %desc, i32 1)
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call, %if.end ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @xdr_xcode_array2(%struct.xdr_buf* %buf, i32 %base, %struct.xdr_array2_desc* %desc, i32 %encode) #0 {
entry:
  %_min1 = alloca i32, align 4
  %_min2 = alloca i32, align 4
  %_min1137 = alloca i32, align 4
  %_min2138 = alloca i32, align 4
  %_min1223 = alloca i32, align 4
  %_min2224 = alloca i32, align 4
  %_min1294 = alloca i32, align 4
  %_min2295 = alloca i32, align 4
  %tobool = icmp ne i32 %encode, 0
  %array_len = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = load i32, i32* %array_len, align 4, !tbaa !906
  %call = call i32 @xdr_encode_word(%struct.xdr_buf* %buf, i32 %base, i32 %0)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %cleanup370, label %if.end16

if.else:                                          ; preds = %entry
  %call3 = call i32 @xdr_decode_word(%struct.xdr_buf* %buf, i32 %base, i32* %array_len)
  %cmp4 = icmp ne i32 %call3, 0
  br i1 %cmp4, label %cleanup370, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %array_len5 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 1
  %1 = load i32, i32* %array_len5, align 4, !tbaa !906
  %array_maxlen = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 2
  %2 = load i32, i32* %array_maxlen, align 8, !tbaa !909
  %cmp6 = icmp ugt i32 %1, %2
  br i1 %cmp6, label %cleanup370, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %lor.lhs.false
  %conv = zext i32 %base to i64
  %add = add i64 %conv, 4
  %array_len8 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 1
  %3 = load i32, i32* %array_len8, align 4, !tbaa !906
  %elem_size = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %4 = load i32, i32* %elem_size, align 8, !tbaa !908
  %mul = mul i32 %3, %4
  %conv9 = zext i32 %mul to i64
  %add10 = add i64 %add, %conv9
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  %5 = load i32, i32* %len, align 8, !tbaa !152
  %conv11 = zext i32 %5 to i64
  %cmp12 = icmp ugt i64 %add10, %conv11
  br i1 %cmp12, label %cleanup370, label %if.end16

if.end16:                                         ; preds = %lor.lhs.false7, %if.then
  %add17 = add i32 %base, 4
  %xcode = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 3
  %6 = load i32 (%struct.xdr_array2_desc*, i8*)*, i32 (%struct.xdr_array2_desc*, i8*)** %xcode, align 8, !tbaa !910
  %tobool18 = icmp ne i32 (%struct.xdr_array2_desc*, i8*)* %6, null
  br i1 %tobool18, label %if.end20, label %cleanup370

if.end20:                                         ; preds = %if.end16
  %array_len21 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 1
  %7 = load i32, i32* %array_len21, align 4, !tbaa !906
  %elem_size22 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %8 = load i32, i32* %elem_size22, align 8, !tbaa !908
  %mul23 = mul i32 %7, %8
  %tobool24 = icmp ne i32 %mul23, 0
  br i1 %tobool24, label %land.lhs.true, label %if.end83

land.lhs.true:                                    ; preds = %if.end20
  %conv25 = zext i32 %add17 to i64
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i32 0, i32 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %9 = load i64, i64* %iov_len, align 8, !tbaa !149
  %cmp26 = icmp ult i64 %conv25, %9
  br i1 %cmp26, label %if.then28, label %if.end83

if.then28:                                        ; preds = %land.lhs.true
  %head29 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arraydecay30 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head29, i32 0, i32 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay30, i32 0, i32 0
  %10 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %idx.ext = zext i32 %add17 to i64
  %add.ptr = getelementptr i8, i8* %10, i64 %idx.ext
  %head31 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arraydecay32 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head31, i32 0, i32 0
  %iov_len33 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay32, i32 0, i32 1
  %11 = load i64, i64* %iov_len33, align 8, !tbaa !149
  %conv34 = zext i32 %add17 to i64
  %sub = sub i64 %11, %conv34
  %conv35 = trunc i64 %sub to i32
  %cmp36 = icmp ult i32 %mul23, %conv35
  %mul23.conv35 = select i1 %cmp36, i32 %mul23, i32 %conv35
  %sub38 = sub i32 %mul23, %mul23.conv35
  br label %while.cond

while.cond:                                       ; preds = %if.end46, %if.then28
  %avail_here.0 = phi i32 [ %mul23.conv35, %if.then28 ], [ %sub51, %if.end46 ]
  %c.0 = phi i8* [ %add.ptr, %if.then28 ], [ %add.ptr49, %if.end46 ]
  %err.0 = phi i32 [ undef, %if.then28 ], [ %call43, %if.end46 ]
  %elem_size39 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %12 = load i32, i32* %elem_size39, align 8, !tbaa !908
  %cmp40 = icmp uge i32 %avail_here.0, %12
  br i1 %cmp40, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %xcode42 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 3
  %13 = load i32 (%struct.xdr_array2_desc*, i8*)*, i32 (%struct.xdr_array2_desc*, i8*)** %xcode42, align 8, !tbaa !910
  %call43 = call i32 %13(%struct.xdr_array2_desc* %desc, i8* %c.0)
  %tobool44 = icmp ne i32 %call43, 0
  br i1 %tobool44, label %out, label %if.end46

if.end46:                                         ; preds = %while.body
  %elem_size47 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %14 = load i32, i32* %elem_size47, align 8, !tbaa !908
  %idx.ext48 = zext i32 %14 to i64
  %add.ptr49 = getelementptr inbounds i8, i8* %c.0, i64 %idx.ext48
  %elem_size50 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %15 = load i32, i32* %elem_size50, align 8, !tbaa !908
  %sub51 = sub i32 %avail_here.0, %15
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %tobool52 = icmp ne i32 %avail_here.0, 0
  br i1 %tobool52, label %if.then53, label %if.end78

if.then53:                                        ; preds = %while.end
  %tobool54 = icmp ne i8* null, null
  br i1 %tobool54, label %if.end62, label %if.then55

if.then55:                                        ; preds = %if.then53
  %elem_size56 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %16 = load i32, i32* %elem_size56, align 8, !tbaa !908
  %conv57 = zext i32 %16 to i64
  %call.i2 = call i8* @__kmalloc(i64 %conv57, i32 208) #7
  %tobool59 = icmp ne i8* %call.i2, null
  br i1 %tobool59, label %if.end62, label %out

if.end62:                                         ; preds = %if.then55, %if.then53
  %elem.0 = phi i8* [ null, %if.then53 ], [ %call.i2, %if.then55 ]
  %err.1 = phi i32 [ %err.0, %if.then53 ], [ -12, %if.then55 ]
  %tobool63 = icmp ne i32 %encode, 0
  br i1 %tobool63, label %if.then64, label %if.else72

if.then64:                                        ; preds = %if.end62
  %xcode65 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 3
  %17 = load i32 (%struct.xdr_array2_desc*, i8*)*, i32 (%struct.xdr_array2_desc*, i8*)** %xcode65, align 8, !tbaa !910
  %call66 = call i32 %17(%struct.xdr_array2_desc* %desc, i8* %elem.0)
  %tobool67 = icmp ne i32 %call66, 0
  br i1 %tobool67, label %out, label %if.end69

if.end69:                                         ; preds = %if.then64
  %conv70 = zext i32 %avail_here.0 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %c.0, i8* %elem.0, i64 %conv70, i32 1, i1 false)
  br label %if.end78

if.else72:                                        ; preds = %if.end62
  %conv74 = zext i32 %avail_here.0 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %elem.0, i8* %c.0, i64 %conv74, i32 1, i1 false)
  br label %if.end78

if.end78:                                         ; preds = %if.else72, %if.end69, %while.end
  %copied.0 = phi i32 [ 0, %while.end ], [ %avail_here.0, %if.else72 ], [ %avail_here.0, %if.end69 ]
  %elem.1 = phi i8* [ null, %while.end ], [ %elem.0, %if.else72 ], [ %elem.0, %if.end69 ]
  %err.3 = phi i32 [ %err.0, %while.end ], [ %call66, %if.end69 ], [ %err.1, %if.else72 ]
  %head79 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arraydecay80 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head79, i32 0, i32 0
  %iov_len81 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay80, i32 0, i32 1
  %18 = load i64, i64* %iov_len81, align 8, !tbaa !149
  %conv82 = trunc i64 %18 to i32
  br label %if.end83

if.end83:                                         ; preds = %if.end78, %land.lhs.true, %if.end20
  %todo.0 = phi i32 [ %sub38, %if.end78 ], [ %mul23, %land.lhs.true ], [ %mul23, %if.end20 ]
  %copied.1 = phi i32 [ %copied.0, %if.end78 ], [ 0, %land.lhs.true ], [ 0, %if.end20 ]
  %elem.2 = phi i8* [ %elem.1, %if.end78 ], [ null, %land.lhs.true ], [ null, %if.end20 ]
  %err.4 = phi i32 [ %err.3, %if.end78 ], [ undef, %land.lhs.true ], [ undef, %if.end20 ]
  %base.addr.0 = phi i32 [ %conv82, %if.end78 ], [ %add17, %land.lhs.true ], [ %add17, %if.end20 ]
  %head84 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arraydecay85 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head84, i32 0, i32 0
  %iov_len86 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay85, i32 0, i32 1
  %19 = load i64, i64* %iov_len86, align 8, !tbaa !149
  %conv87 = zext i32 %base.addr.0 to i64
  %sub88 = sub i64 %conv87, %19
  %conv89 = trunc i64 %sub88 to i32
  %tobool90 = icmp ne i32 %todo.0, 0
  br i1 %tobool90, label %land.lhs.true91, label %if.end310

land.lhs.true91:                                  ; preds = %if.end83
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %20 = load i32, i32* %page_len, align 4, !tbaa !150
  %cmp92 = icmp ult i32 %conv89, %20
  br i1 %cmp92, label %if.then94, label %if.end310

if.then94:                                        ; preds = %land.lhs.true91
  store i32 %todo.0, i32* %_min1, align 4, !tbaa !49
  %page_len95 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %21 = load i32, i32* %page_len95, align 4, !tbaa !150
  %sub96 = sub i32 %21, %conv89
  store i32 %sub96, i32* %_min2, align 4, !tbaa !49
  %22 = load i32, i32* %_min1, align 4, !tbaa !49
  %23 = load i32, i32* %_min2, align 4, !tbaa !49
  %cmp100 = icmp ult i32 %22, %23
  %24 = load i32, i32* %_min1, align 4
  %25 = load i32, i32* %_min2, align 4
  %cond105 = select i1 %cmp100, i32 %24, i32 %25
  %sub106 = sub i32 %todo.0, %cond105
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 3
  %26 = load i32, i32* %page_base, align 8, !tbaa !355
  %add107 = add i32 %conv89, %26
  %pages = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 2
  %27 = load %struct.page**, %struct.page*** %pages, align 8, !tbaa !354
  %shr = lshr i32 %add107, 12
  %idx.ext108 = zext i32 %shr to i64
  %add.ptr109 = getelementptr inbounds %struct.page*, %struct.page** %27, i64 %idx.ext108
  %conv110 = zext i32 %add107 to i64
  %and = and i64 %conv110, 4095
  %conv111 = trunc i64 %and to i32
  %conv113 = zext i32 %conv111 to i64
  %sub114 = sub i64 4096, %conv113
  %conv115 = trunc i64 %sub114 to i32
  %cmp118 = icmp ult i32 %conv115, %cond105
  %conv115.cond105 = select i1 %cmp118, i32 %conv115, i32 %cond105
  %28 = load %struct.page*, %struct.page** %add.ptr109, align 8, !tbaa !28
  %call124 = call i8* @kmap(%struct.page* %28)
  %idx.ext125 = zext i32 %conv111 to i64
  %add.ptr126 = getelementptr i8, i8* %call124, i64 %idx.ext125
  br label %while.cond127

while.cond127:                                    ; preds = %if.end293, %if.then94
  %ppages.0 = phi %struct.page** [ %add.ptr109, %if.then94 ], [ %ppages.1, %if.end293 ]
  %avail_here.1 = phi i32 [ %cond105, %if.then94 ], [ %sub130, %if.end293 ]
  %copied.2 = phi i32 [ %copied.1, %if.then94 ], [ %copied.12, %if.end293 ]
  %c.1 = phi i8* [ %add.ptr126, %if.then94 ], [ %c.5, %if.end293 ]
  %elem.3 = phi i8* [ %elem.2, %if.then94 ], [ %elem.9, %if.end293 ]
  %err.5 = phi i32 [ %err.4, %if.then94 ], [ %err.18, %if.end293 ]
  %avail_page.0 = phi i32 [ %conv115.cond105, %if.then94 ], [ %cond304, %if.end293 ]
  %tobool128 = icmp ne i32 %avail_here.1, 0
  br i1 %tobool128, label %while.body129, label %while.end305

while.body129:                                    ; preds = %while.cond127
  %sub130 = sub i32 %avail_here.1, %avail_page.0
  %tobool131 = icmp ne i32 %copied.2, 0
  br i1 %tobool131, label %if.then136, label %lor.lhs.false132

lor.lhs.false132:                                 ; preds = %while.body129
  %elem_size133 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %29 = load i32, i32* %elem_size133, align 8, !tbaa !908
  %cmp134 = icmp ult i32 %avail_page.0, %29
  br i1 %cmp134, label %if.then136, label %if.end203

if.then136:                                       ; preds = %lor.lhs.false132, %while.body129
  store i32 %avail_page.0, i32* %_min1137, align 4, !tbaa !49
  %elem_size139 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %30 = load i32, i32* %elem_size139, align 8, !tbaa !908
  %sub140 = sub i32 %30, %copied.2
  store i32 %sub140, i32* %_min2138, align 4, !tbaa !49
  %31 = load i32, i32* %_min1137, align 4, !tbaa !49
  %32 = load i32, i32* %_min2138, align 4, !tbaa !49
  %cmp144 = icmp ult i32 %31, %32
  %33 = load i32, i32* %_min1137, align 4
  %34 = load i32, i32* %_min2138, align 4
  %cond149 = select i1 %cmp144, i32 %33, i32 %34
  %tobool150 = icmp ne i8* %elem.3, null
  br i1 %tobool150, label %if.end158, label %if.then151

if.then151:                                       ; preds = %if.then136
  %elem_size152 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %35 = load i32, i32* %elem_size152, align 8, !tbaa !908
  %conv153 = zext i32 %35 to i64
  %call.i1 = call i8* @__kmalloc(i64 %conv153, i32 208) #7
  %tobool155 = icmp ne i8* %call.i1, null
  br i1 %tobool155, label %if.end158, label %LeafBlock

if.end158:                                        ; preds = %if.then151, %if.then136
  %elem.4 = phi i8* [ %elem.3, %if.then136 ], [ %call.i1, %if.then151 ]
  %err.6 = phi i32 [ %err.5, %if.then136 ], [ -12, %if.then151 ]
  %tobool159 = icmp ne i32 %encode, 0
  br i1 %tobool159, label %if.then160, label %if.else181

if.then160:                                       ; preds = %if.end158
  %tobool161 = icmp ne i32 %copied.2, 0
  br i1 %tobool161, label %if.end168, label %if.then162

if.then162:                                       ; preds = %if.then160
  %xcode163 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 3
  %36 = load i32 (%struct.xdr_array2_desc*, i8*)*, i32 (%struct.xdr_array2_desc*, i8*)** %xcode163, align 8, !tbaa !910
  %call164 = call i32 %36(%struct.xdr_array2_desc* %desc, i8* %elem.4)
  %tobool165 = icmp ne i32 %call164, 0
  br i1 %tobool165, label %LeafBlock, label %if.end168

if.end168:                                        ; preds = %if.then162, %if.then160
  %err.7 = phi i32 [ %err.6, %if.then160 ], [ %call164, %if.then162 ]
  %conv170 = zext i32 %cond149 to i64
  %idx.ext172 = zext i32 %copied.2 to i64
  %add.ptr173 = getelementptr inbounds i8, i8* %elem.4, i64 %idx.ext172
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %c.1, i8* %add.ptr173, i64 %conv170, i32 1, i1 false)
  %add175 = add i32 %copied.2, %cond149
  %elem_size176 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %37 = load i32, i32* %elem_size176, align 8, !tbaa !908
  %cmp177 = icmp eq i32 %add175, %37
  %.add175 = select i1 %cmp177, i32 0, i32 %add175
  br label %if.end199

if.else181:                                       ; preds = %if.end158
  %conv183 = zext i32 %cond149 to i64
  %idx.ext185 = zext i32 %copied.2 to i64
  %add.ptr186 = getelementptr inbounds i8, i8* %elem.4, i64 %idx.ext185
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr186, i8* %c.1, i64 %conv183, i32 1, i1 false)
  %add188 = add i32 %copied.2, %cond149
  %elem_size189 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %38 = load i32, i32* %elem_size189, align 8, !tbaa !908
  %cmp190 = icmp eq i32 %add188, %38
  br i1 %cmp190, label %if.then192, label %if.end199

if.then192:                                       ; preds = %if.else181
  %xcode193 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 3
  %39 = load i32 (%struct.xdr_array2_desc*, i8*)*, i32 (%struct.xdr_array2_desc*, i8*)** %xcode193, align 8, !tbaa !910
  %call194 = call i32 %39(%struct.xdr_array2_desc* %desc, i8* %elem.4)
  %tobool195 = icmp ne i32 %call194, 0
  br i1 %tobool195, label %LeafBlock, label %if.end199

if.end199:                                        ; preds = %if.then192, %if.else181, %if.end168
  %copied.5 = phi i32 [ %.add175, %if.end168 ], [ %add188, %if.else181 ], [ 0, %if.then192 ]
  %err.9 = phi i32 [ %err.7, %if.end168 ], [ %err.6, %if.else181 ], [ %call194, %if.then192 ]
  %sub200 = sub i32 %avail_page.0, %cond149
  %idx.ext201 = zext i32 %cond149 to i64
  %add.ptr202 = getelementptr inbounds i8, i8* %c.1, i64 %idx.ext201
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end199, %if.then192, %if.then162, %if.then151
  %copied.6 = phi i32 [ %copied.5, %if.end199 ], [ %copied.2, %if.then151 ], [ %copied.2, %if.then162 ], [ %add188, %if.then192 ]
  %c.2 = phi i8* [ %add.ptr202, %if.end199 ], [ %c.1, %if.then151 ], [ %c.1, %if.then162 ], [ %c.1, %if.then192 ]
  %elem.5 = phi i8* [ %elem.4, %if.end199 ], [ %call.i1, %if.then151 ], [ %elem.4, %if.then162 ], [ %elem.4, %if.then192 ]
  %err.10 = phi i32 [ %err.9, %if.end199 ], [ -12, %if.then151 ], [ %call164, %if.then162 ], [ %call194, %if.then192 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end199 ], [ 4, %if.then151 ], [ 4, %if.then162 ], [ 4, %if.then192 ]
  %avail_page.1 = phi i32 [ %sub200, %if.end199 ], [ %avail_page.0, %if.then151 ], [ %avail_page.0, %if.then162 ], [ %avail_page.0, %if.then192 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end203, label %NodeBlock

if.end203:                                        ; preds = %LeafBlock, %lor.lhs.false132
  %copied.7 = phi i32 [ %copied.2, %lor.lhs.false132 ], [ %copied.6, %LeafBlock ]
  %c.3 = phi i8* [ %c.1, %lor.lhs.false132 ], [ %c.2, %LeafBlock ]
  %elem.6 = phi i8* [ %elem.3, %lor.lhs.false132 ], [ %elem.5, %LeafBlock ]
  %err.11 = phi i32 [ %err.5, %lor.lhs.false132 ], [ %err.10, %LeafBlock ]
  %avail_page.2 = phi i32 [ %avail_page.0, %lor.lhs.false132 ], [ %avail_page.1, %LeafBlock ]
  br label %while.cond204

while.cond204:                                    ; preds = %if.end213, %if.end203
  %c.4 = phi i8* [ %c.3, %if.end203 ], [ %add.ptr216, %if.end213 ]
  %err.12 = phi i32 [ %err.11, %if.end203 ], [ %call210, %if.end213 ]
  %avail_page.3 = phi i32 [ %avail_page.2, %if.end203 ], [ %sub218, %if.end213 ]
  %elem_size205 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %40 = load i32, i32* %elem_size205, align 8, !tbaa !908
  %cmp206 = icmp uge i32 %avail_page.3, %40
  br i1 %cmp206, label %while.body208, label %while.end219

while.body208:                                    ; preds = %while.cond204
  %xcode209 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 3
  %41 = load i32 (%struct.xdr_array2_desc*, i8*)*, i32 (%struct.xdr_array2_desc*, i8*)** %xcode209, align 8, !tbaa !910
  %call210 = call i32 %41(%struct.xdr_array2_desc* %desc, i8* %c.4)
  %tobool211 = icmp ne i32 %call210, 0
  br i1 %tobool211, label %NodeBlock, label %if.end213

if.end213:                                        ; preds = %while.body208
  %elem_size214 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %42 = load i32, i32* %elem_size214, align 8, !tbaa !908
  %idx.ext215 = zext i32 %42 to i64
  %add.ptr216 = getelementptr inbounds i8, i8* %c.4, i64 %idx.ext215
  %elem_size217 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %43 = load i32, i32* %elem_size217, align 8, !tbaa !908
  %sub218 = sub i32 %avail_page.3, %43
  br label %while.cond204

while.end219:                                     ; preds = %while.cond204
  %tobool220 = icmp ne i32 %avail_page.3, 0
  br i1 %tobool220, label %if.then221, label %if.end289

if.then221:                                       ; preds = %while.end219
  store i32 %avail_page.3, i32* %_min1223, align 4, !tbaa !49
  %elem_size225 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %44 = load i32, i32* %elem_size225, align 8, !tbaa !908
  %sub226 = sub i32 %44, %copied.7
  store i32 %sub226, i32* %_min2224, align 4, !tbaa !49
  %45 = load i32, i32* %_min1223, align 4, !tbaa !49
  %46 = load i32, i32* %_min2224, align 4, !tbaa !49
  %cmp230 = icmp ult i32 %45, %46
  %47 = load i32, i32* %_min1223, align 4
  %48 = load i32, i32* %_min2224, align 4
  %cond235 = select i1 %cmp230, i32 %47, i32 %48
  %tobool236 = icmp ne i8* %elem.6, null
  br i1 %tobool236, label %if.end244, label %if.then237

if.then237:                                       ; preds = %if.then221
  %elem_size238 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %49 = load i32, i32* %elem_size238, align 8, !tbaa !908
  %conv239 = zext i32 %49 to i64
  %call.i = call i8* @__kmalloc(i64 %conv239, i32 208) #7
  %tobool241 = icmp ne i8* %call.i, null
  br i1 %tobool241, label %if.end244, label %LeafBlock2

if.end244:                                        ; preds = %if.then237, %if.then221
  %elem.7 = phi i8* [ %elem.6, %if.then221 ], [ %call.i, %if.then237 ]
  %err.13 = phi i32 [ %err.12, %if.then221 ], [ -12, %if.then237 ]
  %tobool245 = icmp ne i32 %encode, 0
  br i1 %tobool245, label %if.then246, label %if.else267

if.then246:                                       ; preds = %if.end244
  %tobool247 = icmp ne i32 %copied.7, 0
  br i1 %tobool247, label %if.end254, label %if.then248

if.then248:                                       ; preds = %if.then246
  %xcode249 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 3
  %50 = load i32 (%struct.xdr_array2_desc*, i8*)*, i32 (%struct.xdr_array2_desc*, i8*)** %xcode249, align 8, !tbaa !910
  %call250 = call i32 %50(%struct.xdr_array2_desc* %desc, i8* %elem.7)
  %tobool251 = icmp ne i32 %call250, 0
  br i1 %tobool251, label %LeafBlock2, label %if.end254

if.end254:                                        ; preds = %if.then248, %if.then246
  %err.14 = phi i32 [ %err.13, %if.then246 ], [ %call250, %if.then248 ]
  %conv256 = zext i32 %cond235 to i64
  %idx.ext258 = zext i32 %copied.7 to i64
  %add.ptr259 = getelementptr inbounds i8, i8* %elem.7, i64 %idx.ext258
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %c.4, i8* %add.ptr259, i64 %conv256, i32 1, i1 false)
  %add261 = add i32 %copied.7, %cond235
  %elem_size262 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %51 = load i32, i32* %elem_size262, align 8, !tbaa !908
  %cmp263 = icmp eq i32 %add261, %51
  %.add261 = select i1 %cmp263, i32 0, i32 %add261
  br label %if.end285

if.else267:                                       ; preds = %if.end244
  %conv269 = zext i32 %cond235 to i64
  %idx.ext271 = zext i32 %copied.7 to i64
  %add.ptr272 = getelementptr inbounds i8, i8* %elem.7, i64 %idx.ext271
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr272, i8* %c.4, i64 %conv269, i32 1, i1 false)
  %add274 = add i32 %copied.7, %cond235
  %elem_size275 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %52 = load i32, i32* %elem_size275, align 8, !tbaa !908
  %cmp276 = icmp eq i32 %add274, %52
  br i1 %cmp276, label %if.then278, label %if.end285

if.then278:                                       ; preds = %if.else267
  %xcode279 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 3
  %53 = load i32 (%struct.xdr_array2_desc*, i8*)*, i32 (%struct.xdr_array2_desc*, i8*)** %xcode279, align 8, !tbaa !910
  %call280 = call i32 %53(%struct.xdr_array2_desc* %desc, i8* %elem.7)
  %tobool281 = icmp ne i32 %call280, 0
  br i1 %tobool281, label %LeafBlock2, label %if.end285

if.end285:                                        ; preds = %if.then278, %if.else267, %if.end254
  %copied.10 = phi i32 [ %.add261, %if.end254 ], [ %add274, %if.else267 ], [ 0, %if.then278 ]
  %err.16 = phi i32 [ %err.14, %if.end254 ], [ %err.13, %if.else267 ], [ %call280, %if.then278 ]
  br label %LeafBlock2

LeafBlock2:                                       ; preds = %if.end285, %if.then278, %if.then248, %if.then237
  %copied.11 = phi i32 [ %copied.10, %if.end285 ], [ %copied.7, %if.then237 ], [ %copied.7, %if.then248 ], [ %add274, %if.then278 ]
  %elem.8 = phi i8* [ %elem.7, %if.end285 ], [ %call.i, %if.then237 ], [ %elem.7, %if.then248 ], [ %elem.7, %if.then278 ]
  %err.17 = phi i32 [ %err.16, %if.end285 ], [ -12, %if.then237 ], [ %call250, %if.then248 ], [ %call280, %if.then278 ]
  %cleanup.dest.slot.1 = phi i32 [ 0, %if.end285 ], [ 4, %if.then237 ], [ 4, %if.then248 ], [ 4, %if.then278 ]
  %SwitchLeaf3 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf3, label %if.end289, label %NodeBlock

if.end289:                                        ; preds = %LeafBlock2, %while.end219
  %copied.12 = phi i32 [ %copied.7, %while.end219 ], [ %copied.11, %LeafBlock2 ]
  %elem.9 = phi i8* [ %elem.6, %while.end219 ], [ %elem.8, %LeafBlock2 ]
  %err.18 = phi i32 [ %err.12, %while.end219 ], [ %err.17, %LeafBlock2 ]
  %tobool290 = icmp ne i32 %sub130, 0
  br i1 %tobool290, label %if.then291, label %if.end293

if.then291:                                       ; preds = %if.end289
  call void @kunmap()
  %incdec.ptr = getelementptr inbounds %struct.page*, %struct.page** %ppages.0, i32 1
  %54 = load %struct.page*, %struct.page** %incdec.ptr, align 8, !tbaa !28
  %call292 = call i8* @kmap(%struct.page* %54)
  br label %if.end293

if.end293:                                        ; preds = %if.then291, %if.end289
  %ppages.1 = phi %struct.page** [ %incdec.ptr, %if.then291 ], [ %ppages.0, %if.end289 ]
  %c.5 = phi i8* [ %call292, %if.then291 ], [ %c.4, %if.end289 ]
  store i32 %sub130, i32* %_min1294, align 4, !tbaa !49
  store i32 4096, i32* %_min2295, align 4, !tbaa !49
  %55 = load i32, i32* %_min1294, align 4, !tbaa !49
  %56 = load i32, i32* %_min2295, align 4, !tbaa !49
  %cmp299 = icmp ult i32 %55, %56
  %57 = load i32, i32* %_min1294, align 4
  %58 = load i32, i32* %_min2295, align 4
  %cond304 = select i1 %cmp299, i32 %57, i32 %58
  br label %while.cond127

while.end305:                                     ; preds = %while.cond127
  %page_len306 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %59 = load i32, i32* %page_len306, align 4, !tbaa !150
  br label %NodeBlock

NodeBlock:                                        ; preds = %while.end305, %LeafBlock2, %while.body208, %LeafBlock
  %copied.13 = phi i32 [ %copied.2, %while.end305 ], [ %copied.7, %while.body208 ], [ %copied.6, %LeafBlock ], [ %copied.11, %LeafBlock2 ]
  %elem.10 = phi i8* [ %elem.3, %while.end305 ], [ %elem.6, %while.body208 ], [ %elem.5, %LeafBlock ], [ %elem.8, %LeafBlock2 ]
  %err.19 = phi i32 [ %err.5, %while.end305 ], [ %call210, %while.body208 ], [ %err.10, %LeafBlock ], [ %err.17, %LeafBlock2 ]
  %cleanup.dest.slot.2 = phi i32 [ 0, %while.end305 ], [ 4, %while.body208 ], [ %cleanup.dest.slot.0, %LeafBlock ], [ %cleanup.dest.slot.1, %LeafBlock2 ]
  %base.addr.1 = phi i32 [ %59, %while.end305 ], [ %conv111, %while.body208 ], [ %conv111, %LeafBlock ], [ %conv111, %LeafBlock2 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.2, 4
  br i1 %Pivot, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock
  %SwitchLeaf8 = icmp eq i32 %cleanup.dest.slot.2, 4
  br i1 %SwitchLeaf8, label %out, label %cleanup370

LeafBlock5:                                       ; preds = %NodeBlock
  %SwitchLeaf6 = icmp eq i32 %cleanup.dest.slot.2, 0
  br i1 %SwitchLeaf6, label %if.end310, label %cleanup370

if.end310:                                        ; preds = %LeafBlock5, %land.lhs.true91, %if.end83
  %ppages.2 = phi %struct.page** [ null, %land.lhs.true91 ], [ null, %if.end83 ], [ %ppages.0, %LeafBlock5 ]
  %todo.1 = phi i32 [ %todo.0, %land.lhs.true91 ], [ %todo.0, %if.end83 ], [ %sub106, %LeafBlock5 ]
  %copied.14 = phi i32 [ %copied.1, %land.lhs.true91 ], [ %copied.1, %if.end83 ], [ %copied.13, %LeafBlock5 ]
  %elem.11 = phi i8* [ %elem.2, %land.lhs.true91 ], [ %elem.2, %if.end83 ], [ %elem.10, %LeafBlock5 ]
  %err.20 = phi i32 [ %err.4, %land.lhs.true91 ], [ %err.4, %if.end83 ], [ %err.19, %LeafBlock5 ]
  %base.addr.2 = phi i32 [ %conv89, %land.lhs.true91 ], [ %conv89, %if.end83 ], [ %base.addr.1, %LeafBlock5 ]
  %page_len311 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %60 = load i32, i32* %page_len311, align 4, !tbaa !150
  %sub312 = sub i32 %base.addr.2, %60
  %tobool313 = icmp ne i32 %todo.1, 0
  br i1 %tobool313, label %if.then314, label %out

if.then314:                                       ; preds = %if.end310
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arraydecay315 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i32 0, i32 0
  %iov_base316 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay315, i32 0, i32 0
  %61 = load i8*, i8** %iov_base316, align 8, !tbaa !147
  %idx.ext317 = zext i32 %sub312 to i64
  %add.ptr318 = getelementptr i8, i8* %61, i64 %idx.ext317
  %tobool319 = icmp ne i32 %copied.14, 0
  br i1 %tobool319, label %if.then320, label %if.end351

if.then320:                                       ; preds = %if.then314
  %elem_size322 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %62 = load i32, i32* %elem_size322, align 8, !tbaa !908
  %sub323 = sub i32 %62, %copied.14
  %tobool324 = icmp ne i32 %encode, 0
  %conv327 = zext i32 %sub323 to i64
  %idx.ext329 = zext i32 %copied.14 to i64
  %add.ptr330 = getelementptr inbounds i8, i8* %elem.11, i64 %idx.ext329
  br i1 %tobool324, label %if.then325, label %if.else332

if.then325:                                       ; preds = %if.then320
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr318, i8* %add.ptr330, i64 %conv327, i32 1, i1 false)
  br label %if.end344

if.else332:                                       ; preds = %if.then320
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr330, i8* %add.ptr318, i64 %conv327, i32 1, i1 false)
  %xcode339 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 3
  %63 = load i32 (%struct.xdr_array2_desc*, i8*)*, i32 (%struct.xdr_array2_desc*, i8*)** %xcode339, align 8, !tbaa !910
  %call340 = call i32 %63(%struct.xdr_array2_desc* %desc, i8* %elem.11)
  %tobool341 = icmp ne i32 %call340, 0
  br i1 %tobool341, label %NodeBlock14, label %if.end344

if.end344:                                        ; preds = %if.else332, %if.then325
  %err.21 = phi i32 [ %err.20, %if.then325 ], [ %call340, %if.else332 ]
  %sub345 = sub i32 %todo.1, %sub323
  %idx.ext346 = zext i32 %sub323 to i64
  %add.ptr347 = getelementptr inbounds i8, i8* %add.ptr318, i64 %idx.ext346
  br label %NodeBlock14

NodeBlock14:                                      ; preds = %if.end344, %if.else332
  %todo.2 = phi i32 [ %sub345, %if.end344 ], [ %todo.1, %if.else332 ]
  %c.6 = phi i8* [ %add.ptr347, %if.end344 ], [ %add.ptr318, %if.else332 ]
  %err.22 = phi i32 [ %err.21, %if.end344 ], [ %call340, %if.else332 ]
  %cleanup.dest.slot.3 = phi i32 [ 0, %if.end344 ], [ 4, %if.else332 ]
  %Pivot15 = icmp slt i32 %cleanup.dest.slot.3, 4
  br i1 %Pivot15, label %LeafBlock10, label %LeafBlock12

LeafBlock12:                                      ; preds = %NodeBlock14
  %SwitchLeaf13 = icmp eq i32 %cleanup.dest.slot.3, 4
  br i1 %SwitchLeaf13, label %out, label %cleanup370

LeafBlock10:                                      ; preds = %NodeBlock14
  %SwitchLeaf11 = icmp eq i32 %cleanup.dest.slot.3, 0
  br i1 %SwitchLeaf11, label %if.end351, label %cleanup370

if.end351:                                        ; preds = %LeafBlock10, %if.then314
  %todo.3 = phi i32 [ %todo.1, %if.then314 ], [ %todo.2, %LeafBlock10 ]
  %c.7 = phi i8* [ %add.ptr318, %if.then314 ], [ %c.6, %LeafBlock10 ]
  br label %while.cond352

while.cond352:                                    ; preds = %if.end359, %if.end351
  %todo.4 = phi i32 [ %todo.3, %if.end351 ], [ %sub364, %if.end359 ]
  %c.8 = phi i8* [ %c.7, %if.end351 ], [ %add.ptr362, %if.end359 ]
  %tobool353 = icmp ne i32 %todo.4, 0
  br i1 %tobool353, label %while.body354, label %out

while.body354:                                    ; preds = %while.cond352
  %xcode355 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 3
  %64 = load i32 (%struct.xdr_array2_desc*, i8*)*, i32 (%struct.xdr_array2_desc*, i8*)** %xcode355, align 8, !tbaa !910
  %call356 = call i32 %64(%struct.xdr_array2_desc* %desc, i8* %c.8)
  %tobool357 = icmp ne i32 %call356, 0
  br i1 %tobool357, label %out, label %if.end359

if.end359:                                        ; preds = %while.body354
  %elem_size360 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %65 = load i32, i32* %elem_size360, align 8, !tbaa !908
  %idx.ext361 = zext i32 %65 to i64
  %add.ptr362 = getelementptr inbounds i8, i8* %c.8, i64 %idx.ext361
  %elem_size363 = getelementptr inbounds %struct.xdr_array2_desc, %struct.xdr_array2_desc* %desc, i32 0, i32 0
  %66 = load i32, i32* %elem_size363, align 8, !tbaa !908
  %sub364 = sub i32 %todo.4, %66
  br label %while.cond352

out:                                              ; preds = %while.body354, %while.cond352, %LeafBlock12, %if.end310, %LeafBlock7, %if.then64, %if.then55, %while.body
  %ppages.3 = phi %struct.page** [ %ppages.2, %LeafBlock12 ], [ %ppages.0, %LeafBlock7 ], [ null, %while.body ], [ null, %if.then55 ], [ null, %if.then64 ], [ %ppages.2, %while.body354 ], [ %ppages.2, %while.cond352 ], [ %ppages.2, %if.end310 ]
  %elem.12 = phi i8* [ %elem.11, %LeafBlock12 ], [ %elem.10, %LeafBlock7 ], [ null, %while.body ], [ %call.i2, %if.then55 ], [ %elem.0, %if.then64 ], [ %elem.11, %while.body354 ], [ %elem.11, %while.cond352 ], [ %elem.11, %if.end310 ]
  %err.23 = phi i32 [ %err.22, %LeafBlock12 ], [ %err.19, %LeafBlock7 ], [ %call43, %while.body ], [ -12, %if.then55 ], [ %call66, %if.then64 ], [ %call356, %while.body354 ], [ 0, %while.cond352 ], [ 0, %if.end310 ]
  call void @kfree(i8* %elem.12)
  %tobool367 = icmp ne %struct.page** %ppages.3, null
  br i1 %tobool367, label %if.then368, label %cleanup370

if.then368:                                       ; preds = %out
  call void @kunmap()
  br label %cleanup370

cleanup370:                                       ; preds = %if.then368, %out, %LeafBlock10, %LeafBlock12, %LeafBlock5, %LeafBlock7, %if.end16, %lor.lhs.false7, %lor.lhs.false, %if.else, %if.then
  %retval.0 = phi i32 [ -22, %if.then ], [ -22, %lor.lhs.false7 ], [ -22, %lor.lhs.false ], [ -22, %if.else ], [ 0, %if.end16 ], [ %err.23, %if.then368 ], [ %err.23, %out ], [ undef, %LeafBlock7 ], [ undef, %LeafBlock5 ], [ undef, %LeafBlock12 ], [ undef, %LeafBlock10 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @xdr_encode_word(%struct.xdr_buf* %buf, i32 %base, i32 %obj) #0 {
entry:
  %raw = alloca i32, align 4
  %call = call i32 @__fswab32.892(i32 %obj) #3
  store i32 %call, i32* %raw, align 4, !tbaa !49
  %0 = bitcast i32* %raw to i8*
  %call1 = call i32 @write_bytes_to_xdr_buf(%struct.xdr_buf* %buf, i32 %base, i8* %0, i32 4)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define i32 @xdr_decode_word(%struct.xdr_buf* %buf, i32 %base, i32* %obj) #0 {
entry:
  %raw = alloca i32, align 4
  %0 = bitcast i32* %raw to i8*
  %call = call i32 @read_bytes_from_xdr_buf(%struct.xdr_buf* %buf, i32 %base, i8* %0, i32 4)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %raw, align 4, !tbaa !49
  %call1 = call i32 @__fswab32.892(i32 %1) #3
  store i32 %call1, i32* %obj, align 4, !tbaa !49
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kmap(%struct.page* %page) #2 {
entry:
  call void @__might_sleep(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.25.949, i32 0, i32 0), i32 58, i32 0)
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %page to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %0 = inttoptr i64 %add.i to i8*
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kunmap() #2 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @read_bytes_from_xdr_buf(%struct.xdr_buf* %buf, i32 %base, i8* %obj, i32 %len) #0 {
entry:
  %subbuf = alloca %struct.xdr_buf, align 8
  %call = call i32 @xdr_buf_subsegment(%struct.xdr_buf* %buf, %struct.xdr_buf* %subbuf, i32 %base, i32 %len)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @__read_bytes_from_xdr_buf(%struct.xdr_buf* %subbuf, i8* %obj, i32 %len)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__fswab32.892(i32 %val) #5 {
entry:
  %call = call i32 @__arch_swab32.893(i32 %val) #3
  ret i32 %call
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__arch_swab32.893(i32 %val) #5 {
entry:
  %0 = call i32 asm "bswapl $0", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %val) #3, !srcloc !911
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define i32 @xdr_buf_subsegment(%struct.xdr_buf* %buf, %struct.xdr_buf* %subbuf, i32 %base, i32 %len) #0 {
entry:
  %_min1 = alloca i32, align 4
  %_min2 = alloca i32, align 4
  %len1 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 7
  store i32 %len, i32* %len1, align 8, !tbaa !152
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 6
  store i32 %len, i32* %buflen, align 4, !tbaa !153
  %conv = zext i32 %base to i64
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %0 = load i64, i64* %iov_len, align 8, !tbaa !149
  %cmp = icmp ult i64 %conv, %0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %head3 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head3, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx4, i32 0, i32 0
  %1 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %idx.ext = zext i32 %base to i64
  %add.ptr = getelementptr i8, i8* %1, i64 %idx.ext
  %head5 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head5, i64 0, i64 0
  %iov_base7 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx6, i32 0, i32 0
  store i8* %add.ptr, i8** %iov_base7, align 8, !tbaa !147
  %head8 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head8, i64 0, i64 0
  %iov_len10 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx9, i32 0, i32 1
  %2 = load i64, i64* %iov_len10, align 8, !tbaa !149
  %conv11 = zext i32 %base to i64
  %sub = sub i64 %2, %conv11
  %conv12 = trunc i64 %sub to i32
  %cmp13 = icmp ult i32 %len, %conv12
  %len.conv12 = select i1 %cmp13, i32 %len, i32 %conv12
  %conv15 = zext i32 %len.conv12 to i64
  %head16 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 0
  %arrayidx17 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head16, i64 0, i64 0
  %iov_len18 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx17, i32 0, i32 1
  store i64 %conv15, i64* %iov_len18, align 8, !tbaa !149
  %head19 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 0
  %arrayidx20 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head19, i64 0, i64 0
  %iov_len21 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx20, i32 0, i32 1
  %3 = load i64, i64* %iov_len21, align 8, !tbaa !149
  %conv22 = zext i32 %len to i64
  %sub23 = sub i64 %conv22, %3
  %conv24 = trunc i64 %sub23 to i32
  br label %if.end

if.else:                                          ; preds = %entry
  %head25 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 0
  %arrayidx26 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head25, i64 0, i64 0
  %iov_base27 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx26, i32 0, i32 0
  store i8* null, i8** %iov_base27, align 8, !tbaa !147
  %head28 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 0
  %arrayidx29 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head28, i64 0, i64 0
  %iov_len30 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx29, i32 0, i32 1
  store i64 0, i64* %iov_len30, align 8, !tbaa !149
  %head31 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx32 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head31, i64 0, i64 0
  %iov_len33 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx32, i32 0, i32 1
  %4 = load i64, i64* %iov_len33, align 8, !tbaa !149
  %conv34 = zext i32 %base to i64
  %sub35 = sub i64 %conv34, %4
  %conv36 = trunc i64 %sub35 to i32
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %base.addr.0 = phi i32 [ 0, %if.then ], [ %conv36, %if.else ]
  %len.addr.0 = phi i32 [ %conv24, %if.then ], [ %len, %if.else ]
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %5 = load i32, i32* %page_len, align 4, !tbaa !150
  %cmp37 = icmp ult i32 %base.addr.0, %5
  br i1 %cmp37, label %if.then39, label %if.else59

if.then39:                                        ; preds = %if.end
  %page_len40 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %6 = load i32, i32* %page_len40, align 4, !tbaa !150
  %sub41 = sub i32 %6, %base.addr.0
  store i32 %sub41, i32* %_min1, align 4, !tbaa !49
  store i32 %len.addr.0, i32* %_min2, align 4, !tbaa !49
  %7 = load i32, i32* %_min1, align 4, !tbaa !49
  %8 = load i32, i32* %_min2, align 4, !tbaa !49
  %cmp45 = icmp ult i32 %7, %8
  %9 = load i32, i32* %_min1, align 4
  %10 = load i32, i32* %_min2, align 4
  %cond50 = select i1 %cmp45, i32 %9, i32 %10
  %page_len51 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 4
  store i32 %cond50, i32* %page_len51, align 4, !tbaa !150
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 3
  %11 = load i32, i32* %page_base, align 8, !tbaa !355
  %add = add i32 %base.addr.0, %11
  %conv52 = zext i32 %add to i64
  %and = and i64 %conv52, 4095
  %conv53 = trunc i64 %and to i32
  %page_base54 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 3
  store i32 %conv53, i32* %page_base54, align 8, !tbaa !355
  %pages = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 2
  %12 = load %struct.page**, %struct.page*** %pages, align 8, !tbaa !354
  %shr = lshr i32 %add, 12
  %idxprom = zext i32 %shr to i64
  %arrayidx55 = getelementptr inbounds %struct.page*, %struct.page** %12, i64 %idxprom
  %pages56 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 2
  store %struct.page** %arrayidx55, %struct.page*** %pages56, align 8, !tbaa !354
  %page_len57 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 4
  %13 = load i32, i32* %page_len57, align 4, !tbaa !150
  %sub58 = sub i32 %len.addr.0, %13
  br label %if.end63

if.else59:                                        ; preds = %if.end
  %page_len60 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %14 = load i32, i32* %page_len60, align 4, !tbaa !150
  %sub61 = sub i32 %base.addr.0, %14
  %page_len62 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 4
  store i32 0, i32* %page_len62, align 4, !tbaa !150
  br label %if.end63

if.end63:                                         ; preds = %if.else59, %if.then39
  %base.addr.1 = phi i32 [ 0, %if.then39 ], [ %sub61, %if.else59 ]
  %len.addr.1 = phi i32 [ %sub58, %if.then39 ], [ %len.addr.0, %if.else59 ]
  %conv64 = zext i32 %base.addr.1 to i64
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arrayidx65 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_len66 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx65, i32 0, i32 1
  %15 = load i64, i64* %iov_len66, align 8, !tbaa !149
  %cmp67 = icmp ult i64 %conv64, %15
  br i1 %cmp67, label %if.then69, label %if.else103

if.then69:                                        ; preds = %if.end63
  %tail70 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arrayidx71 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail70, i64 0, i64 0
  %iov_base72 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx71, i32 0, i32 0
  %16 = load i8*, i8** %iov_base72, align 8, !tbaa !147
  %idx.ext73 = zext i32 %base.addr.1 to i64
  %add.ptr74 = getelementptr i8, i8* %16, i64 %idx.ext73
  %tail75 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 1
  %arrayidx76 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail75, i64 0, i64 0
  %iov_base77 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx76, i32 0, i32 0
  store i8* %add.ptr74, i8** %iov_base77, align 8, !tbaa !147
  %tail80 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arrayidx81 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail80, i64 0, i64 0
  %iov_len82 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx81, i32 0, i32 1
  %17 = load i64, i64* %iov_len82, align 8, !tbaa !149
  %conv83 = zext i32 %base.addr.1 to i64
  %sub84 = sub i64 %17, %conv83
  %conv85 = trunc i64 %sub84 to i32
  %cmp87 = icmp ult i32 %len.addr.1, %conv85
  %len.addr.1.conv85 = select i1 %cmp87, i32 %len.addr.1, i32 %conv85
  %conv93 = zext i32 %len.addr.1.conv85 to i64
  %tail94 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 1
  %arrayidx95 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail94, i64 0, i64 0
  %iov_len96 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx95, i32 0, i32 1
  store i64 %conv93, i64* %iov_len96, align 8, !tbaa !149
  %tail97 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 1
  %arrayidx98 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail97, i64 0, i64 0
  %iov_len99 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx98, i32 0, i32 1
  %18 = load i64, i64* %iov_len99, align 8, !tbaa !149
  %conv100 = zext i32 %len.addr.1 to i64
  %sub101 = sub i64 %conv100, %18
  %conv102 = trunc i64 %sub101 to i32
  br label %if.end116

if.else103:                                       ; preds = %if.end63
  %tail104 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 1
  %arrayidx105 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail104, i64 0, i64 0
  %iov_base106 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx105, i32 0, i32 0
  store i8* null, i8** %iov_base106, align 8, !tbaa !147
  %tail107 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 1
  %arrayidx108 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail107, i64 0, i64 0
  %iov_len109 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx108, i32 0, i32 1
  store i64 0, i64* %iov_len109, align 8, !tbaa !149
  %tail110 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arrayidx111 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail110, i64 0, i64 0
  %iov_len112 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx111, i32 0, i32 1
  %19 = load i64, i64* %iov_len112, align 8, !tbaa !149
  %conv113 = zext i32 %base.addr.1 to i64
  %sub114 = sub i64 %conv113, %19
  %conv115 = trunc i64 %sub114 to i32
  br label %if.end116

if.end116:                                        ; preds = %if.else103, %if.then69
  %base.addr.2 = phi i32 [ 0, %if.then69 ], [ %conv115, %if.else103 ]
  %len.addr.2 = phi i32 [ %conv102, %if.then69 ], [ %len.addr.1, %if.else103 ]
  %tobool = icmp ne i32 %base.addr.2, 0
  %tobool117 = icmp ne i32 %len.addr.2, 0
  %or.cond = or i1 %tobool, %tobool117
  %retval.0 = select i1 %or.cond, i32 -1, i32 0
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @__read_bytes_from_xdr_buf(%struct.xdr_buf* %subbuf, i8* %obj, i32 %len) #0 {
entry:
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %0 = load i64, i64* %iov_len, align 8, !tbaa !149
  %conv = trunc i64 %0 to i32
  %cmp = icmp ult i32 %len, %conv
  %len.conv = select i1 %cmp, i32 %len, i32 %conv
  %conv2 = zext i32 %len.conv to i64
  %head3 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head3, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx4, i32 0, i32 0
  %1 = load i8*, i8** %iov_base, align 8, !tbaa !147
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %obj, i8* %1, i64 %conv2, i32 1, i1 false)
  %sub = sub i32 %len, %len.conv
  %idx.ext = zext i32 %len.conv to i64
  %add.ptr = getelementptr i8, i8* %obj, i64 %idx.ext
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 4
  %2 = load i32, i32* %page_len, align 4, !tbaa !150
  %cmp9 = icmp ult i32 %sub, %2
  %cond14 = select i1 %cmp9, i32 %sub, i32 %2
  %tobool = icmp ne i32 %cond14, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %pages = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 2
  %3 = load %struct.page**, %struct.page*** %pages, align 8, !tbaa !354
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 3
  %4 = load i32, i32* %page_base, align 8, !tbaa !355
  %conv15 = zext i32 %4 to i64
  %conv16 = zext i32 %cond14 to i64
  call void @_copy_from_pages(i8* %add.ptr, %struct.page** %3, i64 %conv15, i64 %conv16)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sub17 = sub i32 %sub, %cond14
  %idx.ext18 = zext i32 %cond14 to i64
  %add.ptr19 = getelementptr i8, i8* %add.ptr, i64 %idx.ext18
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 1
  %arrayidx22 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_len23 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx22, i32 0, i32 1
  %5 = load i64, i64* %iov_len23, align 8, !tbaa !149
  %conv24 = trunc i64 %5 to i32
  %cmp26 = icmp ult i32 %sub17, %conv24
  %sub17.conv24 = select i1 %cmp26, i32 %sub17, i32 %conv24
  %conv33 = zext i32 %sub17.conv24 to i64
  %tail35 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 1
  %arrayidx36 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail35, i64 0, i64 0
  %iov_base37 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx36, i32 0, i32 0
  %6 = load i8*, i8** %iov_base37, align 8, !tbaa !147
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr19, i8* %6, i64 %conv33, i32 1, i1 false)
  ret void
}

; Function Attrs: nounwind uwtable
define void @_copy_from_pages(i8* %p, %struct.page** %pages, i64 %pgbase, i64 %len) #0 {
entry:
  %shr = lshr i64 %pgbase, 12
  %add.ptr = getelementptr inbounds %struct.page*, %struct.page** %pages, i64 %shr
  %and = and i64 %pgbase, 4095
  br label %do.body

do.body:                                          ; preds = %do.body6, %entry
  %pgfrom.0 = phi %struct.page** [ %add.ptr, %entry ], [ %pgfrom.1, %do.body6 ]
  %len.addr.0 = phi i64 [ %len, %entry ], [ %sub19, %do.body6 ]
  %pgbase.addr.0 = phi i64 [ %and, %entry ], [ %pgbase.addr.1, %do.body6 ]
  %p.addr.0 = phi i8* [ %p, %entry ], [ %add.ptr17, %do.body6 ]
  %sub = sub i64 4096, %pgbase.addr.0
  %cmp = icmp ugt i64 %sub, %len.addr.0
  %len.addr.0.sub = select i1 %cmp, i64 %len.addr.0, i64 %sub
  %0 = load %struct.page*, %struct.page** %pgfrom.0, align 8, !tbaa !28
  %call = call i8* @kmap_atomic.894(%struct.page* %0)
  %add.ptr1 = getelementptr inbounds i8, i8* %call, i64 %pgbase.addr.0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p.addr.0, i8* %add.ptr1, i64 %len.addr.0.sub, i32 1, i1 false)
  %tobool = trunc i8 0 to i1
  br i1 %tobool, label %if.then4, label %do.body6

if.then4:                                         ; preds = %do.body
  call void @__compiletime_assert_290()
  br label %do.body6

do.body6:                                         ; preds = %if.then4, %do.body
  call void @__kunmap_atomic.895()
  %add = add i64 %pgbase.addr.0, %len.addr.0.sub
  %cmp13 = icmp eq i64 %add, 4096
  %incdec.ptr = getelementptr inbounds %struct.page*, %struct.page** %pgfrom.0, i32 1
  %pgfrom.1 = select i1 %cmp13, %struct.page** %incdec.ptr, %struct.page** %pgfrom.0
  %pgbase.addr.1 = select i1 %cmp13, i64 0, i64 %add
  %add.ptr17 = getelementptr inbounds i8, i8* %p.addr.0, i64 %len.addr.0.sub
  %sub19 = sub i64 %len.addr.0, %len.addr.0.sub
  %cmp20 = icmp ne i64 %sub19, 0
  br i1 %cmp20, label %do.body, label %do.end22

do.end22:                                         ; preds = %do.body6
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kmap_atomic.894(%struct.page* %page) #2 {
entry:
  call void @pagefault_disable.898()
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %page to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %0 = inttoptr i64 %add.i to i8*
  ret i8* %0
}

declare void @__compiletime_assert_290() #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @__kunmap_atomic.895() #2 {
entry:
  call void @pagefault_enable.896()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pagefault_enable.896() #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !912
  %call = call %struct.thread_info* @current_thread_info.897()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !913
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.897() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !914
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pagefault_disable.898() #2 {
entry:
  %call = call %struct.thread_info* @current_thread_info.897()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !915
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @write_bytes_to_xdr_buf(%struct.xdr_buf* %buf, i32 %base, i8* %obj, i32 %len) #0 {
entry:
  %subbuf = alloca %struct.xdr_buf, align 8
  %call = call i32 @xdr_buf_subsegment(%struct.xdr_buf* %buf, %struct.xdr_buf* %subbuf, i32 %base, i32 %len)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @__write_bytes_to_xdr_buf(%struct.xdr_buf* %subbuf, i8* %obj, i32 %len)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @__write_bytes_to_xdr_buf(%struct.xdr_buf* %subbuf, i8* %obj, i32 %len) #0 {
entry:
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %0 = load i64, i64* %iov_len, align 8, !tbaa !149
  %conv = trunc i64 %0 to i32
  %cmp = icmp ult i32 %len, %conv
  %len.conv = select i1 %cmp, i32 %len, i32 %conv
  %conv2 = zext i32 %len.conv to i64
  %head3 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head3, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx4, i32 0, i32 0
  %1 = load i8*, i8** %iov_base, align 8, !tbaa !147
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %obj, i64 %conv2, i32 1, i1 false)
  %sub = sub i32 %len, %len.conv
  %idx.ext = zext i32 %len.conv to i64
  %add.ptr = getelementptr i8, i8* %obj, i64 %idx.ext
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 4
  %2 = load i32, i32* %page_len, align 4, !tbaa !150
  %cmp9 = icmp ult i32 %sub, %2
  %cond14 = select i1 %cmp9, i32 %sub, i32 %2
  %tobool = icmp ne i32 %cond14, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %pages = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 2
  %3 = load %struct.page**, %struct.page*** %pages, align 8, !tbaa !354
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 3
  %4 = load i32, i32* %page_base, align 8, !tbaa !355
  %conv15 = zext i32 %4 to i64
  %conv16 = zext i32 %cond14 to i64
  call void @_copy_to_pages(%struct.page** %3, i64 %conv15, i8* %add.ptr, i64 %conv16)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sub17 = sub i32 %sub, %cond14
  %idx.ext18 = zext i32 %cond14 to i64
  %add.ptr19 = getelementptr i8, i8* %add.ptr, i64 %idx.ext18
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 1
  %arrayidx22 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_len23 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx22, i32 0, i32 1
  %5 = load i64, i64* %iov_len23, align 8, !tbaa !149
  %conv24 = trunc i64 %5 to i32
  %cmp26 = icmp ult i32 %sub17, %conv24
  %sub17.conv24 = select i1 %cmp26, i32 %sub17, i32 %conv24
  %conv33 = zext i32 %sub17.conv24 to i64
  %tail35 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 1
  %arrayidx36 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail35, i64 0, i64 0
  %iov_base37 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx36, i32 0, i32 0
  %6 = load i8*, i8** %iov_base37, align 8, !tbaa !147
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %add.ptr19, i64 %conv33, i32 1, i1 false)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @_copy_to_pages(%struct.page** %pages, i64 %pgbase, i8* %p, i64 %len) #0 {
entry:
  %shr = lshr i64 %pgbase, 12
  %add.ptr = getelementptr inbounds %struct.page*, %struct.page** %pages, i64 %shr
  %and = and i64 %pgbase, 4095
  br label %for.cond

for.cond:                                         ; preds = %if.end16, %entry
  %pgto.0 = phi %struct.page** [ %add.ptr, %entry ], [ %pgto.1, %if.end16 ]
  %len.addr.0 = phi i64 [ %len, %entry ], [ %sub12, %if.end16 ]
  %p.addr.0 = phi i8* [ %p, %entry ], [ %add.ptr24, %if.end16 ]
  %pgbase.addr.0 = phi i64 [ %and, %entry ], [ %pgbase.addr.1, %if.end16 ]
  %sub = sub i64 4096, %pgbase.addr.0
  %cmp = icmp ugt i64 %sub, %len.addr.0
  %len.addr.0.sub = select i1 %cmp, i64 %len.addr.0, i64 %sub
  %0 = load %struct.page*, %struct.page** %pgto.0, align 8, !tbaa !28
  %call = call i8* @kmap_atomic.894(%struct.page* %0)
  %add.ptr1 = getelementptr inbounds i8, i8* %call, i64 %pgbase.addr.0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr1, i8* %p.addr.0, i64 %len.addr.0.sub, i32 1, i1 false)
  %tobool = trunc i8 0 to i1
  br i1 %tobool, label %if.then3, label %do.body5

if.then3:                                         ; preds = %for.cond
  call void @__compiletime_assert_246()
  br label %do.body5

do.body5:                                         ; preds = %if.then3, %for.cond
  call void @__kunmap_atomic.895()
  %sub12 = sub i64 %len.addr.0, %len.addr.0.sub
  %cmp13 = icmp eq i64 %sub12, 0
  br i1 %cmp13, label %do.end27, label %if.end16

if.end16:                                         ; preds = %do.body5
  %add = add i64 %pgbase.addr.0, %len.addr.0.sub
  %cmp17 = icmp eq i64 %add, 4096
  %incdec.ptr = getelementptr inbounds %struct.page*, %struct.page** %pgto.0, i32 1
  %pgto.1 = select i1 %cmp17, %struct.page** %incdec.ptr, %struct.page** %pgto.0
  %pgbase.addr.1 = select i1 %cmp17, i64 0, i64 %add
  %add.ptr24 = getelementptr inbounds i8, i8* %p.addr.0, i64 %len.addr.0.sub
  br label %for.cond

do.end27:                                         ; preds = %do.body5
  ret void
}

declare void @__compiletime_assert_246() #4

; Function Attrs: nounwind uwtable
define i32 @xdr_decode_array2(%struct.xdr_buf* %buf, i32 %base, %struct.xdr_array2_desc* %desc) #0 {
entry:
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  %0 = load i32, i32* %len, align 8, !tbaa !152
  %cmp = icmp uge i32 %base, %0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @xdr_xcode_array2(%struct.xdr_buf* %buf, i32 %base, %struct.xdr_array2_desc* %desc, i32 0)
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call, %if.end ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @xdr_buf_read_netobj(%struct.xdr_buf* %buf, %struct.perf_raw_record* %obj, i32 %offset) #0 {
entry:
  %subbuf = alloca %struct.xdr_buf, align 8
  %len = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 0
  %call = call i32 @xdr_decode_word(%struct.xdr_buf* %buf, i32 %offset, i32* %len)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %add = add i32 %offset, 4
  %len1 = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 0
  %0 = load i32, i32* %len1, align 8, !tbaa !916
  %call2 = call i32 @xdr_buf_subsegment(%struct.xdr_buf* %buf, %struct.xdr_buf* %subbuf, i32 %add, i32 %0)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  %1 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %data = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 1
  store i8* %1, i8** %data, align 8, !tbaa !918
  %head6 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 0
  %arrayidx7 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head6, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx7, i32 0, i32 1
  %2 = load i64, i64* %iov_len, align 8, !tbaa !149
  %len8 = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 0
  %3 = load i32, i32* %len8, align 8, !tbaa !916
  %conv = zext i32 %3 to i64
  %cmp = icmp eq i64 %2, %conv
  br i1 %cmp, label %cleanup, label %if.end11

if.end11:                                         ; preds = %if.end5
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 1
  %arrayidx12 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_base13 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx12, i32 0, i32 0
  %4 = load i8*, i8** %iov_base13, align 8, !tbaa !147
  %data14 = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 1
  store i8* %4, i8** %data14, align 8, !tbaa !918
  %tail15 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %subbuf, i32 0, i32 1
  %arrayidx16 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail15, i64 0, i64 0
  %iov_len17 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx16, i32 0, i32 1
  %5 = load i64, i64* %iov_len17, align 8, !tbaa !149
  %len18 = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 0
  %6 = load i32, i32* %len18, align 8, !tbaa !916
  %conv19 = zext i32 %6 to i64
  %cmp20 = icmp eq i64 %5, %conv19
  br i1 %cmp20, label %cleanup, label %if.end23

if.end23:                                         ; preds = %if.end11
  %len24 = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 0
  %7 = load i32, i32* %len24, align 8, !tbaa !916
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 6
  %8 = load i32, i32* %buflen, align 4, !tbaa !153
  %len25 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  %9 = load i32, i32* %len25, align 8, !tbaa !152
  %sub = sub i32 %8, %9
  %cmp26 = icmp ugt i32 %7, %sub
  br i1 %cmp26, label %cleanup, label %if.end29

if.end29:                                         ; preds = %if.end23
  %tail30 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arrayidx31 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail30, i64 0, i64 0
  %iov_len32 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx31, i32 0, i32 1
  %10 = load i64, i64* %iov_len32, align 8, !tbaa !149
  %cmp33 = icmp ne i64 %10, 0
  br i1 %cmp33, label %if.then35, label %if.else

if.then35:                                        ; preds = %if.end29
  %tail36 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arrayidx37 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail36, i64 0, i64 0
  %iov_base38 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx37, i32 0, i32 0
  %11 = load i8*, i8** %iov_base38, align 8, !tbaa !147
  %tail39 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  br label %if.end51

if.else:                                          ; preds = %if.end29
  %head43 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx44 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head43, i64 0, i64 0
  %iov_base45 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx44, i32 0, i32 0
  %12 = load i8*, i8** %iov_base45, align 8, !tbaa !147
  %head46 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  br label %if.end51

if.end51:                                         ; preds = %if.else, %if.then35
  %head46.sink = phi [1 x %struct.iovec]* [ %head46, %if.else ], [ %tail39, %if.then35 ]
  %.sink = phi i8* [ %12, %if.else ], [ %11, %if.then35 ]
  %arrayidx47 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head46.sink, i64 0, i64 0
  %iov_len48 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx47, i32 0, i32 1
  %13 = load i64, i64* %iov_len48, align 8, !tbaa !149
  %add.ptr49 = getelementptr i8, i8* %.sink, i64 %13
  %data50 = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 1
  store i8* %add.ptr49, i8** %data50, align 8, !tbaa !918
  %data52 = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 1
  %14 = load i8*, i8** %data52, align 8, !tbaa !918
  %len53 = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 0
  %15 = load i32, i32* %len53, align 8, !tbaa !916
  call void @__read_bytes_from_xdr_buf(%struct.xdr_buf* %subbuf, i8* %14, i32 %15)
  br label %cleanup

cleanup:                                          ; preds = %if.end51, %if.end23, %if.end11, %if.end5, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end51 ], [ -14, %entry ], [ -14, %if.end ], [ 0, %if.end5 ], [ 0, %if.end11 ], [ -12, %if.end23 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @xdr_buf_trim(%struct.xdr_buf* %buf, i32 %len) #0 {
entry:
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %0 = load i64, i64* %iov_len, align 8, !tbaa !149
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  %tail1 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arrayidx2 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail1, i64 0, i64 0
  %iov_len3 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx2, i32 0, i32 1
  %1 = load i64, i64* %iov_len3, align 8, !tbaa !149
  %conv = zext i32 %len to i64
  %cmp = icmp ult i64 %1, %conv
  %.conv = select i1 %cmp, i64 %1, i64 %conv
  %tail5 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arrayidx6 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail5, i64 0, i64 0
  %iov_len7 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx6, i32 0, i32 1
  %2 = load i64, i64* %iov_len7, align 8, !tbaa !149
  %sub = sub i64 %2, %.conv
  store i64 %sub, i64* %iov_len7, align 8, !tbaa !149
  %conv8 = zext i32 %len to i64
  %sub9 = sub i64 %conv8, %.conv
  %conv10 = trunc i64 %sub9 to i32
  %tobool11 = icmp ne i32 %conv10, 0
  br i1 %tobool11, label %if.end13, label %fix_len

if.end13:                                         ; preds = %if.then, %entry
  %trim.0 = phi i32 [ %len, %entry ], [ %conv10, %if.then ]
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %3 = load i32, i32* %page_len, align 4, !tbaa !150
  %tobool14 = icmp ne i32 %3, 0
  br i1 %tobool14, label %if.then15, label %if.end37

if.then15:                                        ; preds = %if.end13
  %page_len17 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %4 = load i32, i32* %page_len17, align 4, !tbaa !150
  %cmp20 = icmp ult i32 %4, %trim.0
  %.trim.0 = select i1 %cmp20, i32 %4, i32 %trim.0
  %conv26 = zext i32 %.trim.0 to i64
  %page_len27 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %5 = load i32, i32* %page_len27, align 4, !tbaa !150
  %conv28 = zext i32 %5 to i64
  %sub29 = sub i64 %conv28, %conv26
  %conv30 = trunc i64 %sub29 to i32
  store i32 %conv30, i32* %page_len27, align 4, !tbaa !150
  %conv31 = zext i32 %trim.0 to i64
  %sub32 = sub i64 %conv31, %conv26
  %conv33 = trunc i64 %sub32 to i32
  %tobool34 = icmp ne i32 %conv33, 0
  br i1 %tobool34, label %if.end37, label %fix_len

if.end37:                                         ; preds = %if.then15, %if.end13
  %trim.1 = phi i32 [ %trim.0, %if.end13 ], [ %conv33, %if.then15 ]
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx38 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_len39 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx38, i32 0, i32 1
  %6 = load i64, i64* %iov_len39, align 8, !tbaa !149
  %tobool40 = icmp ne i64 %6, 0
  br i1 %tobool40, label %if.then41, label %fix_len

if.then41:                                        ; preds = %if.end37
  %head43 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx44 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head43, i64 0, i64 0
  %iov_len45 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx44, i32 0, i32 1
  %7 = load i64, i64* %iov_len45, align 8, !tbaa !149
  %conv47 = zext i32 %trim.1 to i64
  %cmp49 = icmp ult i64 %7, %conv47
  %.conv47 = select i1 %cmp49, i64 %7, i64 %conv47
  %head55 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx56 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head55, i64 0, i64 0
  %iov_len57 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx56, i32 0, i32 1
  %8 = load i64, i64* %iov_len57, align 8, !tbaa !149
  %sub58 = sub i64 %8, %.conv47
  store i64 %sub58, i64* %iov_len57, align 8, !tbaa !149
  %conv59 = zext i32 %trim.1 to i64
  %sub60 = sub i64 %conv59, %.conv47
  %conv61 = trunc i64 %sub60 to i32
  br label %fix_len

fix_len:                                          ; preds = %if.then41, %if.end37, %if.then15, %if.then
  %trim.3 = phi i32 [ %conv10, %if.then ], [ %conv33, %if.then15 ], [ %conv61, %if.then41 ], [ %trim.1, %if.end37 ]
  %sub63 = sub i32 %len, %trim.3
  %len64 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  %9 = load i32, i32* %len64, align 8, !tbaa !152
  %sub65 = sub i32 %9, %sub63
  store i32 %sub65, i32* %len64, align 8, !tbaa !152
  ret void
}

; Function Attrs: nounwind uwtable
define void @xdr_buf_from_iov(%struct.iovec* %iov, %struct.xdr_buf* %buf) #0 {
entry:
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %0 = bitcast %struct.iovec* %arrayidx to i8*
  %1 = bitcast %struct.iovec* %iov to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 16, i32 8, i1 false), !tbaa.struct !919
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arrayidx1 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %2 = bitcast %struct.iovec* %arrayidx1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* bitcast (%struct.iovec* @empty_iov to i8*), i64 16, i32 8, i1 false), !tbaa.struct !919
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  store i32 0, i32* %page_len, align 4, !tbaa !150
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %3 = load i64, i64* %iov_len, align 8, !tbaa !149
  %conv = trunc i64 %3 to i32
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  store i32 %conv, i32* %len, align 8, !tbaa !152
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 6
  store i32 %conv, i32* %buflen, align 4, !tbaa !153
  ret void
}

; Function Attrs: nounwind uwtable
define void @xdr_enter_page(%struct.xdr_stream* %xdr, i32 %len) #0 {
entry:
  %call = call i32 @xdr_align_pages(%struct.xdr_stream* %xdr, i32 %len)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 @xdr_set_page_base(%struct.xdr_stream* %xdr, i32 0, i32 %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xdr_align_pages(%struct.xdr_stream* %xdr, i32 %len) #0 {
entry:
  %buf1 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  %0 = load %struct.xdr_buf*, %struct.xdr_buf** %buf1, align 8, !tbaa !920
  %add = add i32 %len, 3
  %shr = lshr i32 %add, 2
  %call = call i32 @xdr_stream_pos(%struct.xdr_stream* %xdr)
  %nwords2 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 6
  %1 = load i32, i32* %nwords2, align 8, !tbaa !922
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i32 0, i32 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %2 = load i64, i64* %iov_len, align 8, !tbaa !149
  %conv = zext i32 %call to i64
  %cmp3 = icmp ugt i64 %2, %conv
  br i1 %cmp3, label %if.then5, label %if.end13

if.then5:                                         ; preds = %if.end
  %iov_len6 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %3 = load i64, i64* %iov_len6, align 8, !tbaa !149
  %conv7 = zext i32 %call to i64
  %sub = sub i64 %3, %conv7
  call void @xdr_shrink_bufhead(%struct.xdr_buf* %0, i64 %sub)
  %len8 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %0, i32 0, i32 7
  %4 = load i32, i32* %len8, align 8, !tbaa !152
  %sub9 = sub i32 %4, %call
  %add10 = add i32 %sub9, 3
  %shr11 = lshr i32 %add10, 2
  %nwords12 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 6
  store i32 %shr11, i32* %nwords12, align 8, !tbaa !922
  br label %if.end13

if.end13:                                         ; preds = %if.then5, %if.end
  %nwords14 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 6
  %5 = load i32, i32* %nwords14, align 8, !tbaa !922
  %cmp15 = icmp ugt i32 %shr, %5
  br i1 %cmp15, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end13
  %nwords18 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 6
  %6 = load i32, i32* %nwords18, align 8, !tbaa !922
  %shl = shl i32 %6, 2
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end13
  %nwords.0 = phi i32 [ %6, %if.then17 ], [ %shr, %if.end13 ]
  %len.addr.0 = phi i32 [ %shl, %if.then17 ], [ %len, %if.end13 ]
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %0, i32 0, i32 4
  %7 = load i32, i32* %page_len, align 4, !tbaa !150
  %cmp20 = icmp ule i32 %7, %len.addr.0
  br i1 %cmp20, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.end19
  %page_len23 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %0, i32 0, i32 4
  %8 = load i32, i32* %page_len23, align 4, !tbaa !150
  br label %cleanup

if.else:                                          ; preds = %if.end19
  %nwords24 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 6
  %9 = load i32, i32* %nwords24, align 8, !tbaa !922
  %cmp25 = icmp ult i32 %nwords.0, %9
  br i1 %cmp25, label %if.then27, label %cleanup

if.then27:                                        ; preds = %if.else
  %page_len28 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %0, i32 0, i32 4
  %10 = load i32, i32* %page_len28, align 4, !tbaa !150
  %sub29 = sub i32 %10, %len.addr.0
  %conv30 = zext i32 %sub29 to i64
  call void @xdr_shrink_pagelen(%struct.xdr_buf* %0, i64 %conv30)
  %len31 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %0, i32 0, i32 7
  %11 = load i32, i32* %len31, align 8, !tbaa !152
  %sub32 = sub i32 %11, %call
  %add33 = add i32 %sub32, 3
  %shr34 = lshr i32 %add33, 2
  %nwords35 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 6
  store i32 %shr34, i32* %nwords35, align 8, !tbaa !922
  br label %cleanup

cleanup:                                          ; preds = %if.then27, %if.else, %if.then22, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ %8, %if.then22 ], [ %len.addr.0, %if.then27 ], [ %len.addr.0, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @xdr_set_page_base(%struct.xdr_stream* %xdr, i32 %base, i32 %len) #0 {
entry:
  %buf = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  %0 = load %struct.xdr_buf*, %struct.xdr_buf** %buf, align 8, !tbaa !920
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %0, i32 0, i32 4
  %1 = load i32, i32* %page_len, align 4, !tbaa !150
  %cmp = icmp uge i32 %base, %1
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %sub = sub i32 %1, %base
  %cmp1 = icmp ugt i32 %len, %sub
  %sub.len = select i1 %cmp1, i32 %sub, i32 %len
  %buf4 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  %2 = load %struct.xdr_buf*, %struct.xdr_buf** %buf4, align 8, !tbaa !920
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %2, i32 0, i32 3
  %3 = load i32, i32* %page_base, align 8, !tbaa !355
  %add = add i32 %base, %3
  %shr = lshr i32 %add, 12
  %buf5 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  %4 = load %struct.xdr_buf*, %struct.xdr_buf** %buf5, align 8, !tbaa !920
  %pages = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %4, i32 0, i32 2
  %5 = load %struct.page**, %struct.page*** %pages, align 8, !tbaa !354
  %idxprom = zext i32 %shr to i64
  %arrayidx = getelementptr inbounds %struct.page*, %struct.page** %5, i64 %idxprom
  %page_ptr = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 5
  store %struct.page** %arrayidx, %struct.page*** %page_ptr, align 8, !tbaa !923
  %page_ptr6 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 5
  %6 = load %struct.page**, %struct.page*** %page_ptr6, align 8, !tbaa !923
  %7 = load %struct.page*, %struct.page** %6, align 8, !tbaa !28
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %7 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %8 = inttoptr i64 %add.i to i8*
  %conv = zext i32 %add to i64
  %and = and i64 %conv, 4095
  %conv7 = trunc i64 %and to i32
  %idx.ext = zext i32 %conv7 to i64
  %add.ptr = getelementptr i8, i8* %8, i64 %idx.ext
  %9 = bitcast i8* %add.ptr to i32*
  %p = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  store i32* %9, i32** %p, align 8, !tbaa !924
  %add8 = add i32 %conv7, %sub.len
  %conv9 = zext i32 %add8 to i64
  %cmp10 = icmp ugt i64 %conv9, 4096
  %pgend.0 = select i1 %cmp10, i32 4096, i32 %add8
  %idx.ext14 = zext i32 %pgend.0 to i64
  %add.ptr15 = getelementptr i8, i8* %8, i64 %idx.ext14
  %10 = bitcast i8* %add.ptr15 to i32*
  %end = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 2
  store i32* %10, i32** %end, align 8, !tbaa !925
  %iov = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 3
  store %struct.iovec* null, %struct.iovec** %iov, align 8, !tbaa !926
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @xdr_stream_pos(%struct.xdr_stream* %xdr) #0 {
entry:
  %buf = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  %0 = load %struct.xdr_buf*, %struct.xdr_buf** %buf, align 8, !tbaa !920
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %0, i32 0, i32 7
  %1 = load i32, i32* %len, align 8, !tbaa !152
  %add = add i32 %1, 3
  %shr = lshr i32 %add, 2
  %nwords = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 6
  %2 = load i32, i32* %nwords, align 8, !tbaa !922
  %sub = sub i32 %shr, %2
  %shl = shl i32 %sub, 2
  ret i32 %shl
}

; Function Attrs: nounwind uwtable
define internal void @xdr_shrink_bufhead(%struct.xdr_buf* %buf, i64 %len) #0 {
entry:
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %0 = load i32, i32* %page_len, align 4, !tbaa !150
  %tail1 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arraydecay = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail1, i32 0, i32 0
  %head2 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arraydecay3 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head2, i32 0, i32 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay3, i32 0, i32 1
  %1 = load i64, i64* %iov_len, align 8, !tbaa !149
  %cmp = icmp ugt i64 %len, %1
  %lnot = xor i1 %cmp, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end36

if.then:                                          ; preds = %entry
  %2 = load i8, i8* @xdr_shrink_bufhead.__warned, align 1, !tbaa !29, !range !31
  %tobool10 = trunc i8 %2 to i1
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %tobool17 = icmp ne i32 %lnot.ext16, 0
  %lnot18 = xor i1 %tobool17, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  %expval23 = call i64 @llvm.expect.i64(i64 %conv22, i64 0)
  %tobool24 = icmp ne i64 %expval23, 0
  br i1 %tobool24, label %if.then25, label %if.end

if.then25:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.899, i32 0, i32 0), i32 322)
  br label %if.end

if.end:                                           ; preds = %if.then25, %if.then
  %tobool26 = icmp ne i32 %lnot.ext16, 0
  %lnot27 = xor i1 %tobool26, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end
  store i8 1, i8* @xdr_shrink_bufhead.__warned, align 1, !tbaa !29
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.end, %entry
  %iov_len45 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay3, i32 0, i32 1
  %3 = load i64, i64* %iov_len45, align 8, !tbaa !149
  %cmp46 = icmp ugt i64 %len, %3
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.end36
  %iov_len49 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay3, i32 0, i32 1
  %4 = load i64, i64* %iov_len49, align 8, !tbaa !149
  br label %if.end50

if.end50:                                         ; preds = %if.then48, %if.end36
  %len.addr.0 = phi i64 [ %4, %if.then48 ], [ %len, %if.end36 ]
  %iov_len51 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %5 = load i64, i64* %iov_len51, align 8, !tbaa !149
  %cmp52 = icmp ne i64 %5, 0
  br i1 %cmp52, label %if.then54, label %if.end110

if.then54:                                        ; preds = %if.end50
  %iov_len55 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %6 = load i64, i64* %iov_len55, align 8, !tbaa !149
  %cmp56 = icmp ugt i64 %6, %len.addr.0
  br i1 %cmp56, label %if.then58, label %if.end61

if.then58:                                        ; preds = %if.then54
  %iov_len59 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %7 = load i64, i64* %iov_len59, align 8, !tbaa !149
  %sub = sub i64 %7, %len.addr.0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 0
  %8 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 %len.addr.0
  %iov_base60 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 0
  %9 = load i8*, i8** %iov_base60, align 8, !tbaa !147
  call void @llvm.memmove.p0i8.p0i8.i64(i8* %add.ptr, i8* %9, i64 %sub, i32 1, i1 false)
  br label %if.end61

if.end61:                                         ; preds = %if.then58, %if.then54
  %conv62 = zext i32 %0 to i64
  %cmp63 = icmp ugt i64 %len.addr.0, %conv62
  %conv66 = zext i32 %0 to i64
  %conv66.len.addr.0 = select i1 %cmp63, i64 %conv66, i64 %len.addr.0
  %sub68 = sub i64 %len.addr.0, %conv66.len.addr.0
  %iov_len69 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %10 = load i64, i64* %iov_len69, align 8, !tbaa !149
  %cmp70 = icmp uge i64 %sub68, %10
  br i1 %cmp70, label %if.end81, label %if.else

if.else:                                          ; preds = %if.end61
  %iov_len73 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %11 = load i64, i64* %iov_len73, align 8, !tbaa !149
  %sub74 = sub i64 %11, %sub68
  %cmp75 = icmp ugt i64 %conv66.len.addr.0, %sub74
  br i1 %cmp75, label %if.then77, label %if.end81

if.then77:                                        ; preds = %if.else
  %iov_len78 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %12 = load i64, i64* %iov_len78, align 8, !tbaa !149
  %sub79 = sub i64 %12, %sub68
  br label %if.end81

if.end81:                                         ; preds = %if.then77, %if.else, %if.end61
  %copy.2 = phi i64 [ 0, %if.end61 ], [ %sub79, %if.then77 ], [ %conv66.len.addr.0, %if.else ]
  %cmp82 = icmp ne i64 %copy.2, 0
  br i1 %cmp82, label %if.then84, label %if.end90

if.then84:                                        ; preds = %if.end81
  %iov_base85 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 0
  %13 = load i8*, i8** %iov_base85, align 8, !tbaa !147
  %add.ptr86 = getelementptr inbounds i8, i8* %13, i64 %sub68
  %pages = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 2
  %14 = load %struct.page**, %struct.page*** %pages, align 8, !tbaa !354
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 3
  %15 = load i32, i32* %page_base, align 8, !tbaa !355
  %add = add i32 %15, %0
  %conv87 = zext i32 %add to i64
  %add88 = add i64 %conv87, %sub68
  %sub89 = sub i64 %add88, %len.addr.0
  call void @_copy_from_pages(i8* %add.ptr86, %struct.page** %14, i64 %sub89, i64 %copy.2)
  br label %if.end90

if.end90:                                         ; preds = %if.then84, %if.end81
  %conv91 = zext i32 %0 to i64
  %cmp92 = icmp ugt i64 %len.addr.0, %conv91
  br i1 %cmp92, label %if.then94, label %if.end110

if.then94:                                        ; preds = %if.end90
  %conv95 = zext i32 %0 to i64
  %sub96 = sub i64 %len.addr.0, %conv95
  %iov_len97 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %16 = load i64, i64* %iov_len97, align 8, !tbaa !149
  %cmp98 = icmp ugt i64 %sub96, %16
  br i1 %cmp98, label %if.then100, label %if.end102

if.then100:                                       ; preds = %if.then94
  %iov_len101 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %17 = load i64, i64* %iov_len101, align 8, !tbaa !149
  br label %if.end102

if.end102:                                        ; preds = %if.then100, %if.then94
  %copy.3 = phi i64 [ %17, %if.then100 ], [ %sub96, %if.then94 ]
  %iov_base103 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 0
  %18 = load i8*, i8** %iov_base103, align 8, !tbaa !147
  %iov_base104 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay3, i32 0, i32 0
  %19 = load i8*, i8** %iov_base104, align 8, !tbaa !147
  %iov_len105 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay3, i32 0, i32 1
  %20 = load i64, i64* %iov_len105, align 8, !tbaa !149
  %add.ptr106 = getelementptr inbounds i8, i8* %19, i64 %20
  %idx.neg = sub i64 0, %sub96
  %add.ptr107 = getelementptr inbounds i8, i8* %add.ptr106, i64 %idx.neg
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %18, i8* %add.ptr107, i64 %copy.3, i32 1, i1 false)
  br label %if.end110

if.end110:                                        ; preds = %if.end102, %if.end90, %if.end50
  %cmp111 = icmp ne i32 %0, 0
  br i1 %cmp111, label %if.then113, label %if.end141

if.then113:                                       ; preds = %if.end110
  %conv114 = zext i32 %0 to i64
  %cmp115 = icmp ugt i64 %conv114, %len.addr.0
  br i1 %cmp115, label %if.then117, label %if.end126

if.then117:                                       ; preds = %if.then113
  %pages118 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 2
  %21 = load %struct.page**, %struct.page*** %pages118, align 8, !tbaa !354
  %page_base119 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 3
  %22 = load i32, i32* %page_base119, align 8, !tbaa !355
  %conv120 = zext i32 %22 to i64
  %add121 = add i64 %conv120, %len.addr.0
  %page_base122 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 3
  %23 = load i32, i32* %page_base122, align 8, !tbaa !355
  %conv123 = zext i32 %23 to i64
  %conv124 = zext i32 %0 to i64
  %sub125 = sub i64 %conv124, %len.addr.0
  call void @_shift_data_right_pages(%struct.page** %21, i64 %add121, i64 %conv123, i64 %sub125)
  br label %if.end126

if.end126:                                        ; preds = %if.then117, %if.then113
  %conv127 = zext i32 %0 to i64
  %cmp128 = icmp ugt i64 %len.addr.0, %conv127
  %conv131 = zext i32 %0 to i64
  %conv131.len.addr.0 = select i1 %cmp128, i64 %conv131, i64 %len.addr.0
  %pages133 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 2
  %24 = load %struct.page**, %struct.page*** %pages133, align 8, !tbaa !354
  %page_base134 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 3
  %25 = load i32, i32* %page_base134, align 8, !tbaa !355
  %conv135 = zext i32 %25 to i64
  %iov_base136 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay3, i32 0, i32 0
  %26 = load i8*, i8** %iov_base136, align 8, !tbaa !147
  %iov_len137 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay3, i32 0, i32 1
  %27 = load i64, i64* %iov_len137, align 8, !tbaa !149
  %add.ptr138 = getelementptr inbounds i8, i8* %26, i64 %27
  %idx.neg139 = sub i64 0, %len.addr.0
  %add.ptr140 = getelementptr inbounds i8, i8* %add.ptr138, i64 %idx.neg139
  call void @_copy_to_pages(%struct.page** %24, i64 %conv135, i8* %add.ptr140, i64 %conv131.len.addr.0)
  br label %if.end141

if.end141:                                        ; preds = %if.end126, %if.end110
  %iov_len142 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay3, i32 0, i32 1
  %28 = load i64, i64* %iov_len142, align 8, !tbaa !149
  %sub143 = sub i64 %28, %len.addr.0
  store i64 %sub143, i64* %iov_len142, align 8, !tbaa !149
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 6
  %29 = load i32, i32* %buflen, align 4, !tbaa !153
  %conv144 = zext i32 %29 to i64
  %sub145 = sub i64 %conv144, %len.addr.0
  %conv146 = trunc i64 %sub145 to i32
  store i32 %conv146, i32* %buflen, align 4, !tbaa !153
  %len147 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  %30 = load i32, i32* %len147, align 8, !tbaa !152
  %buflen148 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 6
  %31 = load i32, i32* %buflen148, align 4, !tbaa !153
  %cmp149 = icmp ugt i32 %30, %31
  br i1 %cmp149, label %if.then151, label %if.end154

if.then151:                                       ; preds = %if.end141
  %buflen152 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 6
  %32 = load i32, i32* %buflen152, align 4, !tbaa !153
  %len153 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  store i32 %32, i32* %len153, align 8, !tbaa !152
  br label %if.end154

if.end154:                                        ; preds = %if.then151, %if.end141
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xdr_shrink_pagelen(%struct.xdr_buf* %buf, i64 %len) #0 {
entry:
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %0 = load i32, i32* %page_len, align 4, !tbaa !150
  %tail1 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arraydecay = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail1, i32 0, i32 0
  %conv = zext i32 %0 to i64
  %cmp = icmp ugt i64 %len, %conv
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body5, label %do.end10

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.899, i32 0, i32 0), i32 397, i64 12) #7, !srcloc !927
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.end10:                                         ; preds = %entry
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 6
  %1 = load i32, i32* %buflen, align 4, !tbaa !153
  %conv11 = zext i32 %1 to i64
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arraydecay12 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i32 0, i32 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay12, i32 0, i32 1
  %2 = load i64, i64* %iov_len, align 8, !tbaa !149
  %sub = sub i64 %conv11, %2
  %page_len13 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %3 = load i32, i32* %page_len13, align 4, !tbaa !150
  %conv14 = zext i32 %3 to i64
  %sub15 = sub i64 %sub, %conv14
  %conv16 = trunc i64 %sub15 to i32
  %cmp17 = icmp ne i32 %conv16, 0
  br i1 %cmp17, label %if.then19, label %if.end45

if.then19:                                        ; preds = %do.end10
  %conv20 = zext i32 %conv16 to i64
  %iov_len21 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %4 = load i64, i64* %iov_len21, align 8, !tbaa !149
  %sub22 = sub i64 %conv20, %4
  %conv23 = trunc i64 %sub22 to i32
  %conv24 = zext i32 %conv23 to i64
  %cmp25 = icmp ult i64 %len, %conv24
  %conv28 = trunc i64 %len to i32
  %conv28.conv23 = select i1 %cmp25, i32 %conv28, i32 %conv23
  %conv30 = zext i32 %conv28.conv23 to i64
  %iov_len31 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %5 = load i64, i64* %iov_len31, align 8, !tbaa !149
  %add = add i64 %5, %conv30
  store i64 %add, i64* %iov_len31, align 8, !tbaa !149
  %iov_len32 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %6 = load i64, i64* %iov_len32, align 8, !tbaa !149
  %cmp33 = icmp ugt i64 %6, %len
  br i1 %cmp33, label %if.then35, label %if.else

if.then35:                                        ; preds = %if.then19
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 0
  %7 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 %len
  %iov_base36 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 0
  %8 = load i8*, i8** %iov_base36, align 8, !tbaa !147
  %iov_len37 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %9 = load i64, i64* %iov_len37, align 8, !tbaa !149
  %sub38 = sub i64 %9, %len
  call void @llvm.memmove.p0i8.p0i8.i64(i8* %add.ptr, i8* %8, i64 %sub38, i32 1, i1 false)
  br label %if.end40

if.else:                                          ; preds = %if.then19
  %iov_len39 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %10 = load i64, i64* %iov_len39, align 8, !tbaa !149
  br label %if.end40

if.end40:                                         ; preds = %if.else, %if.then35
  %copy.0 = phi i64 [ %len, %if.then35 ], [ %10, %if.else ]
  %iov_base41 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 0
  %11 = load i8*, i8** %iov_base41, align 8, !tbaa !147
  %pages = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 2
  %12 = load %struct.page**, %struct.page*** %pages, align 8, !tbaa !354
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 3
  %13 = load i32, i32* %page_base, align 8, !tbaa !355
  %add42 = add i32 %13, %0
  %conv43 = zext i32 %add42 to i64
  %sub44 = sub i64 %conv43, %len
  call void @_copy_from_pages(i8* %11, %struct.page** %12, i64 %sub44, i64 %copy.0)
  br label %if.end45

if.end45:                                         ; preds = %if.end40, %do.end10
  %page_len46 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %14 = load i32, i32* %page_len46, align 4, !tbaa !150
  %conv47 = zext i32 %14 to i64
  %sub48 = sub i64 %conv47, %len
  %conv49 = trunc i64 %sub48 to i32
  store i32 %conv49, i32* %page_len46, align 4, !tbaa !150
  %buflen50 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 6
  %15 = load i32, i32* %buflen50, align 4, !tbaa !153
  %conv51 = zext i32 %15 to i64
  %sub52 = sub i64 %conv51, %len
  %conv53 = trunc i64 %sub52 to i32
  store i32 %conv53, i32* %buflen50, align 4, !tbaa !153
  %len54 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  %16 = load i32, i32* %len54, align 8, !tbaa !152
  %buflen55 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 6
  %17 = load i32, i32* %buflen55, align 4, !tbaa !153
  %cmp56 = icmp ugt i32 %16, %17
  br i1 %cmp56, label %if.then58, label %if.end61

if.then58:                                        ; preds = %if.end45
  %buflen59 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 6
  %18 = load i32, i32* %buflen59, align 4, !tbaa !153
  %len60 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  store i32 %18, i32* %len60, align 8, !tbaa !152
  br label %if.end61

if.end61:                                         ; preds = %if.then58, %if.end45
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #1

; Function Attrs: nounwind uwtable
define internal void @_shift_data_right_pages(%struct.page** %pages, i64 %pgto_base, i64 %pgfrom_base, i64 %len) #0 {
entry:
  %cmp = icmp ule i64 %pgto_base, %pgfrom_base
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.899, i32 0, i32 0), i32 179, i64 12) #7, !srcloc !928
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %add = add i64 %pgto_base, %len
  %add8 = add i64 %pgfrom_base, %len
  %shr = lshr i64 %add, 12
  %add.ptr = getelementptr inbounds %struct.page*, %struct.page** %pages, i64 %shr
  %shr9 = lshr i64 %add8, 12
  %add.ptr10 = getelementptr inbounds %struct.page*, %struct.page** %pages, i64 %shr9
  %and = and i64 %add, 4095
  %and11 = and i64 %add8, 4095
  br label %do.body12

do.body12:                                        ; preds = %do.body58, %do.end7
  %pgto.0 = phi %struct.page** [ %add.ptr, %do.end7 ], [ %incdec.ptr.pgto.0, %do.body58 ]
  %pgfrom.0 = phi %struct.page** [ %add.ptr10, %do.end7 ], [ %pgfrom.1, %do.body58 ]
  %len.addr.0 = phi i64 [ %len, %do.end7 ], [ %sub70, %do.body58 ]
  %pgfrom_base.addr.0 = phi i64 [ %and11, %do.end7 ], [ %sub30, %do.body58 ]
  %pgto_base.addr.0 = phi i64 [ %and, %do.end7 ], [ %sub, %do.body58 ]
  %cmp13 = icmp eq i64 %pgto_base.addr.0, 0
  %incdec.ptr = getelementptr inbounds %struct.page*, %struct.page** %pgto.0, i32 -1
  %incdec.ptr.pgto.0 = select i1 %cmp13, %struct.page** %incdec.ptr, %struct.page** %pgto.0
  %.pgto_base.addr.0 = select i1 %cmp13, i64 4096, i64 %pgto_base.addr.0
  %cmp17 = icmp eq i64 %pgfrom_base.addr.0, 0
  %incdec.ptr20 = getelementptr inbounds %struct.page*, %struct.page** %pgfrom.0, i32 -1
  %pgfrom.1 = select i1 %cmp17, %struct.page** %incdec.ptr20, %struct.page** %pgfrom.0
  %pgfrom_base.addr.1 = select i1 %cmp17, i64 4096, i64 %pgfrom_base.addr.0
  %cmp22 = icmp ugt i64 %len.addr.0, %.pgto_base.addr.0
  %.pgto_base.addr.0.len.addr.0 = select i1 %cmp22, i64 %.pgto_base.addr.0, i64 %len.addr.0
  %cmp26 = icmp ugt i64 %.pgto_base.addr.0.len.addr.0, %pgfrom_base.addr.1
  %copy.1 = select i1 %cmp26, i64 %pgfrom_base.addr.1, i64 %.pgto_base.addr.0.len.addr.0
  %sub = sub i64 %.pgto_base.addr.0, %copy.1
  %sub30 = sub i64 %pgfrom_base.addr.1, %copy.1
  %0 = load %struct.page*, %struct.page** %incdec.ptr.pgto.0, align 8, !tbaa !28
  %call = call i8* @kmap_atomic.894(%struct.page* %0)
  %1 = load %struct.page*, %struct.page** %pgfrom.1, align 8, !tbaa !28
  %call31 = call i8* @kmap_atomic.894(%struct.page* %1)
  %add.ptr32 = getelementptr inbounds i8, i8* %call, i64 %sub
  %add.ptr33 = getelementptr inbounds i8, i8* %call31, i64 %sub30
  call void @llvm.memmove.p0i8.p0i8.i64(i8* %add.ptr32, i8* %add.ptr33, i64 %copy.1, i32 1, i1 false)
  %tobool39 = trunc i8 0 to i1
  br i1 %tobool39, label %if.then40, label %do.body42

if.then40:                                        ; preds = %do.body12
  call void @__compiletime_assert_213()
  br label %do.body42

do.body42:                                        ; preds = %if.then40, %do.body12
  call void @__kunmap_atomic.895()
  %tobool55 = trunc i8 0 to i1
  br i1 %tobool55, label %if.then56, label %do.body58

if.then56:                                        ; preds = %do.body42
  call void @__compiletime_assert_214()
  br label %do.body58

do.body58:                                        ; preds = %if.then56, %do.body42
  call void @__kunmap_atomic.895()
  %sub70 = sub i64 %len.addr.0, %copy.1
  %cmp71 = icmp ne i64 %sub70, 0
  br i1 %cmp71, label %do.body12, label %do.end73

do.end73:                                         ; preds = %do.body58
  ret void
}

declare void @__compiletime_assert_213() #4

declare void @__compiletime_assert_214() #4

; Function Attrs: nounwind uwtable
define i32 @xdr_read_pages(%struct.xdr_stream* %xdr, i32 %len) #0 {
entry:
  %buf1 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  %0 = load %struct.xdr_buf*, %struct.xdr_buf** %buf1, align 8, !tbaa !920
  %call = call i32 @xdr_align_pages(%struct.xdr_stream* %xdr, i32 %len)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %add = add i32 %call, 3
  %shr = lshr i32 %add, 2
  %shl = shl i32 %shr, 2
  %sub = sub i32 %shl, %call
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i32 0, i32 0
  %iov2 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 3
  store %struct.iovec* %arraydecay, %struct.iovec** %iov2, align 8, !tbaa !926
  %nwords3 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 6
  %1 = load i32, i32* %nwords3, align 8, !tbaa !922
  %sub4 = sub i32 %1, %shr
  %shl5 = shl i32 %sub4, 2
  %add6 = add i32 %shl5, %sub
  %conv = zext i32 %add6 to i64
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %2 = load i64, i64* %iov_len, align 8, !tbaa !149
  %cmp7 = icmp ugt i64 %conv, %2
  br i1 %cmp7, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end
  %iov_len10 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %3 = load i64, i64* %iov_len10, align 8, !tbaa !149
  %conv11 = trunc i64 %3 to i32
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %if.end
  %end.0 = phi i32 [ %conv11, %if.then9 ], [ %add6, %if.end ]
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 0
  %4 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %idx.ext = zext i32 %sub to i64
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %idx.ext
  %5 = bitcast i8* %add.ptr to i32*
  %p = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  store i32* %5, i32** %p, align 8, !tbaa !924
  %iov_base13 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 0
  %6 = load i8*, i8** %iov_base13, align 8, !tbaa !147
  %idx.ext14 = zext i32 %end.0 to i64
  %add.ptr15 = getelementptr inbounds i8, i8* %6, i64 %idx.ext14
  %7 = bitcast i8* %add.ptr15 to i32*
  %end16 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 2
  store i32* %7, i32** %end16, align 8, !tbaa !925
  %page_ptr = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 5
  store %struct.page** null, %struct.page*** %page_ptr, align 8, !tbaa !923
  %sub17 = sub i32 %end.0, %sub
  %add18 = add i32 %sub17, 3
  %shr19 = lshr i32 %add18, 2
  %nwords20 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 6
  store i32 %shr19, i32* %nwords20, align 8, !tbaa !922
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %entry
  %retval.0 = phi i32 [ %call, %if.end12 ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32* @xdr_inline_decode(%struct.xdr_stream* %xdr, i64 %nbytes) #0 {
entry:
  %cmp = icmp eq i64 %nbytes, 0
  %p1 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  %0 = load i32*, i32** %p1, align 8, !tbaa !924
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %end = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 2
  %1 = load i32*, i32** %end, align 8, !tbaa !925
  %cmp3 = icmp eq i32* %0, %1
  br i1 %cmp3, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %if.end
  %call = call zeroext i1 @xdr_set_next_buffer(%struct.xdr_stream* %xdr)
  br i1 %call, label %if.end5, label %cleanup

if.end5:                                          ; preds = %land.lhs.true, %if.end
  %call6 = call i32* @__xdr_inline_decode(%struct.xdr_stream* %xdr, i64 %nbytes)
  %cmp7 = icmp ne i32* %call6, null
  br i1 %cmp7, label %cleanup, label %if.end9

if.end9:                                          ; preds = %if.end5
  %call10 = call i32* @xdr_copy_to_scratch(%struct.xdr_stream* %xdr, i64 %nbytes)
  br label %cleanup

cleanup:                                          ; preds = %if.end9, %if.end5, %land.lhs.true, %entry
  %retval.0 = phi i32* [ %call10, %if.end9 ], [ %0, %entry ], [ null, %land.lhs.true ], [ %call6, %if.end5 ]
  ret i32* %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @xdr_set_next_buffer(%struct.xdr_stream* %xdr) #0 {
entry:
  %page_ptr = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 5
  %0 = load %struct.page**, %struct.page*** %page_ptr, align 8, !tbaa !923
  %cmp = icmp ne %struct.page** %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @xdr_set_next_page(%struct.xdr_stream* %xdr)
  br label %if.end9

if.else:                                          ; preds = %entry
  %iov = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 3
  %1 = load %struct.iovec*, %struct.iovec** %iov, align 8, !tbaa !926
  %buf = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  %2 = load %struct.xdr_buf*, %struct.xdr_buf** %buf, align 8, !tbaa !920
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %2, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i32 0, i32 0
  %cmp1 = icmp eq %struct.iovec* %1, %arraydecay
  br i1 %cmp1, label %if.then2, label %if.end9

if.then2:                                         ; preds = %if.else
  %call = call i32 @xdr_set_page_base(%struct.xdr_stream* %xdr, i32 0, i32 4096)
  %cmp3 = icmp slt i32 %call, 0
  br i1 %cmp3, label %if.then4, label %if.end9

if.then4:                                         ; preds = %if.then2
  %buf5 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  %3 = load %struct.xdr_buf*, %struct.xdr_buf** %buf5, align 8, !tbaa !920
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %3, i32 0, i32 1
  %arraydecay6 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i32 0, i32 0
  %buf7 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  %4 = load %struct.xdr_buf*, %struct.xdr_buf** %buf7, align 8, !tbaa !920
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %4, i32 0, i32 7
  %5 = load i32, i32* %len, align 8, !tbaa !152
  call void @xdr_set_iov(%struct.xdr_stream* %xdr, %struct.iovec* %arraydecay6, i32 %5)
  br label %if.end9

if.end9:                                          ; preds = %if.then4, %if.then2, %if.else, %if.then
  %p = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  %6 = load i32*, i32** %p, align 8, !tbaa !924
  %end = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 2
  %7 = load i32*, i32** %end, align 8, !tbaa !925
  %cmp10 = icmp ne i32* %6, %7
  ret i1 %cmp10
}

; Function Attrs: nounwind uwtable
define internal i32* @__xdr_inline_decode(%struct.xdr_stream* %xdr, i64 %nbytes) #0 {
entry:
  %add = add i64 %nbytes, 3
  %shr = lshr i64 %add, 2
  %conv = trunc i64 %shr to i32
  %p1 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  %0 = load i32*, i32** %p1, align 8, !tbaa !924
  %idx.ext = zext i32 %conv to i64
  %add.ptr = getelementptr inbounds i32, i32* %0, i64 %idx.ext
  %nwords2 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 6
  %1 = load i32, i32* %nwords2, align 8, !tbaa !922
  %cmp = icmp ugt i32 %conv, %1
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %end = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 2
  %2 = load i32*, i32** %end, align 8, !tbaa !925
  %cmp4 = icmp ugt i32* %add.ptr, %2
  %cmp6 = icmp ult i32* %add.ptr, %0
  %.cmp6 = select i1 %cmp4, i1 true, i1 %cmp6
  br label %lor.end

lor.end:                                          ; preds = %lor.lhs.false, %entry
  %3 = phi i1 [ true, %entry ], [ %.cmp6, %lor.lhs.false ]
  %lnot = xor i1 %3, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %conv9 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv9, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.end
  %p10 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  store i32* %add.ptr, i32** %p10, align 8, !tbaa !924
  %nwords11 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 6
  %4 = load i32, i32* %nwords11, align 8, !tbaa !922
  %sub = sub i32 %4, %conv
  store i32 %sub, i32* %nwords11, align 8, !tbaa !922
  br label %cleanup

cleanup:                                          ; preds = %if.end, %lor.end
  %retval.0 = phi i32* [ %0, %if.end ], [ null, %lor.end ]
  ret i32* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32* @xdr_copy_to_scratch(%struct.xdr_stream* %xdr, i64 %nbytes) #0 {
entry:
  %scratch = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 4
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %scratch, i32 0, i32 0
  %0 = load i8*, i8** %iov_base, align 8, !tbaa !929
  %end = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 2
  %1 = load i32*, i32** %end, align 8, !tbaa !925
  %2 = bitcast i32* %1 to i8*
  %p1 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  %3 = load i32*, i32** %p1, align 8, !tbaa !924
  %4 = bitcast i32* %3 to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %2 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %4 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %scratch2 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 4
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %scratch2, i32 0, i32 1
  %5 = load i64, i64* %iov_len, align 8, !tbaa !930
  %cmp = icmp ugt i64 %nbytes, %5
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %p3 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  %6 = load i32*, i32** %p3, align 8, !tbaa !924
  %7 = bitcast i32* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %7, i64 %sub.ptr.sub, i32 1, i1 false)
  %add.ptr = getelementptr i8, i8* %0, i64 %sub.ptr.sub
  %sub = sub i64 %nbytes, %sub.ptr.sub
  %call = call zeroext i1 @xdr_set_next_buffer(%struct.xdr_stream* %xdr)
  br i1 %call, label %if.end5, label %cleanup

if.end5:                                          ; preds = %if.end
  %call6 = call i32* @__xdr_inline_decode(%struct.xdr_stream* %xdr, i64 %sub)
  %cmp7 = icmp eq i32* %call6, null
  br i1 %cmp7, label %cleanup, label %if.end9

if.end9:                                          ; preds = %if.end5
  %8 = bitcast i32* %call6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr, i8* %8, i64 %sub, i32 1, i1 false)
  %scratch13 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 4
  %iov_base14 = getelementptr inbounds %struct.iovec, %struct.iovec* %scratch13, i32 0, i32 0
  %9 = load i8*, i8** %iov_base14, align 8, !tbaa !929
  %10 = bitcast i8* %9 to i32*
  br label %cleanup

cleanup:                                          ; preds = %if.end9, %if.end5, %if.end, %entry
  %retval.0 = phi i32* [ %10, %if.end9 ], [ null, %entry ], [ null, %if.end ], [ null, %if.end5 ]
  ret i32* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @xdr_set_next_page(%struct.xdr_stream* %xdr) #0 {
entry:
  %page_ptr = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 5
  %0 = load %struct.page**, %struct.page*** %page_ptr, align 8, !tbaa !923
  %add.ptr = getelementptr inbounds %struct.page*, %struct.page** %0, i64 1
  %buf = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  %1 = load %struct.xdr_buf*, %struct.xdr_buf** %buf, align 8, !tbaa !920
  %pages = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %1, i32 0, i32 2
  %2 = load %struct.page**, %struct.page*** %pages, align 8, !tbaa !354
  %sub.ptr.lhs.cast = ptrtoint %struct.page** %add.ptr to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.page** %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %shl = shl i64 %sub.ptr.div, 12
  %conv = trunc i64 %shl to i32
  %buf1 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  %3 = load %struct.xdr_buf*, %struct.xdr_buf** %buf1, align 8, !tbaa !920
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %3, i32 0, i32 3
  %4 = load i32, i32* %page_base, align 8, !tbaa !355
  %sub = sub i32 %conv, %4
  %call = call i32 @xdr_set_page_base(%struct.xdr_stream* %xdr, i32 %sub, i32 4096)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %buf3 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  %5 = load %struct.xdr_buf*, %struct.xdr_buf** %buf3, align 8, !tbaa !920
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %5, i32 0, i32 1
  %arraydecay = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i32 0, i32 0
  %buf4 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  %6 = load %struct.xdr_buf*, %struct.xdr_buf** %buf4, align 8, !tbaa !920
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %6, i32 0, i32 7
  %7 = load i32, i32* %len, align 8, !tbaa !152
  call void @xdr_set_iov(%struct.xdr_stream* %xdr, %struct.iovec* %arraydecay, i32 %7)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xdr_set_iov(%struct.xdr_stream* %xdr, %struct.iovec* %iov, i32 %len) #0 {
entry:
  %conv = zext i32 %len to i64
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %0 = load i64, i64* %iov_len, align 8, !tbaa !149
  %cmp = icmp ugt i64 %conv, %0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %iov_len2 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 1
  %1 = load i64, i64* %iov_len2, align 8, !tbaa !149
  %conv3 = trunc i64 %1 to i32
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %len.addr.0 = phi i32 [ %conv3, %if.then ], [ %len, %entry ]
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  %2 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %3 = bitcast i8* %2 to i32*
  %p = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  store i32* %3, i32** %p, align 8, !tbaa !924
  %iov_base4 = getelementptr inbounds %struct.iovec, %struct.iovec* %iov, i32 0, i32 0
  %4 = load i8*, i8** %iov_base4, align 8, !tbaa !147
  %idx.ext = zext i32 %len.addr.0 to i64
  %add.ptr = getelementptr i8, i8* %4, i64 %idx.ext
  %5 = bitcast i8* %add.ptr to i32*
  %end = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 2
  store i32* %5, i32** %end, align 8, !tbaa !925
  %iov5 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 3
  store %struct.iovec* %iov, %struct.iovec** %iov5, align 8, !tbaa !926
  %page_ptr = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 5
  store %struct.page** null, %struct.page*** %page_ptr, align 8, !tbaa !923
  ret void
}

; Function Attrs: nounwind uwtable
define void @xdr_set_scratch_buffer(%struct.xdr_stream* %xdr, i8* %buf, i64 %buflen) #0 {
entry:
  %scratch = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 4
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %scratch, i32 0, i32 0
  store i8* %buf, i8** %iov_base, align 8, !tbaa !929
  %scratch1 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 4
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %scratch1, i32 0, i32 1
  store i64 %buflen, i64* %iov_len, align 8, !tbaa !930
  ret void
}

; Function Attrs: nounwind uwtable
define void @xdr_init_decode_pages(%struct.xdr_stream* %xdr, %struct.xdr_buf* %buf, %struct.page** %pages, i32 %len) #0 {
entry:
  %0 = bitcast %struct.xdr_buf* %buf to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 64, i32 8, i1 false)
  %pages1 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 2
  store %struct.page** %pages, %struct.page*** %pages1, align 8, !tbaa !354
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  store i32 %len, i32* %page_len, align 4, !tbaa !150
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 6
  store i32 %len, i32* %buflen, align 4, !tbaa !153
  %len2 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  store i32 %len, i32* %len2, align 8, !tbaa !152
  call void @xdr_init_decode(%struct.xdr_stream* %xdr, %struct.xdr_buf* %buf, i32* null)
  ret void
}

; Function Attrs: nounwind uwtable
define void @xdr_init_decode(%struct.xdr_stream* %xdr, %struct.xdr_buf* %buf, i32* %p) #0 {
entry:
  %buf1 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  store %struct.xdr_buf* %buf, %struct.xdr_buf** %buf1, align 8, !tbaa !920
  %scratch = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 4
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %scratch, i32 0, i32 0
  store i8* null, i8** %iov_base, align 8, !tbaa !929
  %scratch2 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 4
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %scratch2, i32 0, i32 1
  store i64 0, i64* %iov_len, align 8, !tbaa !930
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  %0 = load i32, i32* %len, align 8, !tbaa !152
  %add = add i32 %0, 3
  %shr = lshr i32 %add, 2
  %nwords = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 6
  store i32 %shr, i32* %nwords, align 8, !tbaa !922
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_len3 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %1 = load i64, i64* %iov_len3, align 8, !tbaa !149
  %cmp = icmp ne i64 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %head4 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head4, i32 0, i32 0
  %len5 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  %2 = load i32, i32* %len5, align 8, !tbaa !152
  call void @xdr_set_iov(%struct.xdr_stream* %xdr, %struct.iovec* %arraydecay, i32 %2)
  br label %if.end9

if.else:                                          ; preds = %entry
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %3 = load i32, i32* %page_len, align 4, !tbaa !150
  %cmp6 = icmp ne i32 %3, 0
  br i1 %cmp6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.else
  %len8 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  %4 = load i32, i32* %len8, align 8, !tbaa !152
  %call = call i32 @xdr_set_page_base(%struct.xdr_stream* %xdr, i32 0, i32 %4)
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.else, %if.then
  %cmp10 = icmp ne i32* %p, null
  br i1 %cmp10, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.end9
  %p11 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  %5 = load i32*, i32** %p11, align 8, !tbaa !924
  %cmp12 = icmp ugt i32* %p, %5
  br i1 %cmp12, label %land.lhs.true13, label %if.end20

land.lhs.true13:                                  ; preds = %land.lhs.true
  %end = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 2
  %6 = load i32*, i32** %end, align 8, !tbaa !925
  %cmp14 = icmp uge i32* %6, %p
  br i1 %cmp14, label %if.then15, label %if.end20

if.then15:                                        ; preds = %land.lhs.true13
  %p16 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  %7 = load i32*, i32** %p16, align 8, !tbaa !924
  %sub.ptr.lhs.cast = ptrtoint i32* %p to i64
  %sub.ptr.rhs.cast = ptrtoint i32* %7 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %nwords17 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 6
  %8 = load i32, i32* %nwords17, align 8, !tbaa !922
  %conv = zext i32 %8 to i64
  %sub = sub nsw i64 %conv, %sub.ptr.div
  %conv18 = trunc i64 %sub to i32
  store i32 %conv18, i32* %nwords17, align 8, !tbaa !922
  %p19 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  store i32* %p, i32** %p19, align 8, !tbaa !924
  br label %if.end20

if.end20:                                         ; preds = %if.then15, %land.lhs.true13, %land.lhs.true, %if.end9
  ret void
}

; Function Attrs: nounwind uwtable
define void @xdr_write_pages(%struct.xdr_stream* %xdr, %struct.page** %pages, i32 %base, i32 %len) #0 {
entry:
  %buf1 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  %0 = load %struct.xdr_buf*, %struct.xdr_buf** %buf1, align 8, !tbaa !920
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i32 0, i32 0
  %pages2 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %0, i32 0, i32 2
  store %struct.page** %pages, %struct.page*** %pages2, align 8, !tbaa !354
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %0, i32 0, i32 3
  store i32 %base, i32* %page_base, align 8, !tbaa !355
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %0, i32 0, i32 4
  store i32 %len, i32* %page_len, align 4, !tbaa !150
  %p = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  %1 = load i32*, i32** %p, align 8, !tbaa !924
  %2 = bitcast i32* %1 to i8*
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 0
  store i8* %2, i8** %iov_base, align 8, !tbaa !147
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  store i64 0, i64* %iov_len, align 8, !tbaa !149
  %iov3 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 3
  store %struct.iovec* %arraydecay, %struct.iovec** %iov3, align 8, !tbaa !926
  %and = and i32 %len, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end22

if.then:                                          ; preds = %entry
  %and4 = and i32 %len, 3
  %sub = sub i32 4, %and4
  %p5 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  %3 = load i32*, i32** %p5, align 8, !tbaa !924
  %end = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 2
  %4 = load i32*, i32** %end, align 8, !tbaa !925
  %cmp = icmp uge i32* %3, %4
  %lnot = xor i1 %cmp, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %do.body9, label %do.end14

do.body9:                                         ; preds = %if.then
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.899, i32 0, i32 0), i32 532, i64 12) #7, !srcloc !931
  br label %do.body10

do.body10:                                        ; preds = %do.body10, %do.body9
  br label %do.body10

do.end14:                                         ; preds = %if.then
  %p15 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  %5 = load i32*, i32** %p15, align 8, !tbaa !924
  %6 = bitcast i32* %5 to i8*
  %and16 = and i32 %len, 3
  %idx.ext = zext i32 %and16 to i64
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 %idx.ext
  %iov_base17 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 0
  store i8* %add.ptr, i8** %iov_base17, align 8, !tbaa !147
  %conv18 = zext i32 %sub to i64
  %iov_len19 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %7 = load i64, i64* %iov_len19, align 8, !tbaa !149
  %add = add i64 %7, %conv18
  store i64 %add, i64* %iov_len19, align 8, !tbaa !149
  %add20 = add i32 %len, %sub
  %p21 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  %8 = load i32*, i32** %p21, align 8, !tbaa !924
  %incdec.ptr = getelementptr inbounds i32, i32* %8, i32 1
  store i32* %incdec.ptr, i32** %p21, align 8, !tbaa !924
  store i32 0, i32* %8, align 4, !tbaa !49
  br label %if.end22

if.end22:                                         ; preds = %do.end14, %entry
  %len.addr.0 = phi i32 [ %add20, %do.end14 ], [ %len, %entry ]
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %0, i32 0, i32 6
  %9 = load i32, i32* %buflen, align 4, !tbaa !153
  %add23 = add i32 %9, %len.addr.0
  store i32 %add23, i32* %buflen, align 4, !tbaa !153
  %len24 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %0, i32 0, i32 7
  %10 = load i32, i32* %len24, align 8, !tbaa !152
  %add25 = add i32 %10, %len.addr.0
  store i32 %add25, i32* %len24, align 8, !tbaa !152
  ret void
}

; Function Attrs: nounwind uwtable
define i32* @xdr_reserve_space(%struct.xdr_stream* %xdr, i64 %nbytes) #0 {
entry:
  %p1 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  %0 = load i32*, i32** %p1, align 8, !tbaa !924
  %add = add i64 %nbytes, 3
  %and = and i64 %add, -4
  %shr = lshr i64 %and, 2
  %add.ptr = getelementptr inbounds i32, i32* %0, i64 %shr
  %end = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 2
  %1 = load i32*, i32** %end, align 8, !tbaa !925
  %cmp = icmp ugt i32* %add.ptr, %1
  %cmp2 = icmp ult i32* %add.ptr, %0
  %.cmp2 = select i1 %cmp, i1 true, i1 %cmp2
  %lnot = xor i1 %.cmp2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %p4 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  store i32* %add.ptr, i32** %p4, align 8, !tbaa !924
  %iov = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 3
  %2 = load %struct.iovec*, %struct.iovec** %iov, align 8, !tbaa !926
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %2, i32 0, i32 1
  %3 = load i64, i64* %iov_len, align 8, !tbaa !149
  %add5 = add i64 %3, %and
  store i64 %add5, i64* %iov_len, align 8, !tbaa !149
  %buf = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  %4 = load %struct.xdr_buf*, %struct.xdr_buf** %buf, align 8, !tbaa !920
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %4, i32 0, i32 7
  %5 = load i32, i32* %len, align 8, !tbaa !152
  %conv6 = zext i32 %5 to i64
  %add7 = add i64 %conv6, %and
  %conv8 = trunc i64 %add7 to i32
  store i32 %conv8, i32* %len, align 8, !tbaa !152
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32* [ %0, %if.end ], [ null, %entry ]
  ret i32* %retval.0
}

; Function Attrs: nounwind uwtable
define void @xdr_init_encode(%struct.xdr_stream* %xdr, %struct.xdr_buf* %buf, i32* %p) #0 {
entry:
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i32 0, i32 0
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 6
  %0 = load i32, i32* %buflen, align 4, !tbaa !153
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 4
  %1 = load i32, i32* %page_len, align 4, !tbaa !150
  %sub = sub i32 %0, %1
  %conv = zext i32 %sub to i64
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 1
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %2 = load i64, i64* %iov_len, align 8, !tbaa !149
  %sub1 = sub i64 %conv, %2
  %conv2 = trunc i64 %sub1 to i32
  %cmp = icmp slt i32 %conv2, 0
  %lnot = xor i1 %cmp, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv5, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body6, label %do.end11

do.body6:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.899, i32 0, i32 0), i32 462, i64 12) #7, !srcloc !932
  br label %do.body7

do.body7:                                         ; preds = %do.body7, %do.body6
  br label %do.body7

do.end11:                                         ; preds = %entry
  %buf12 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 1
  store %struct.xdr_buf* %buf, %struct.xdr_buf** %buf12, align 8, !tbaa !920
  %iov13 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 3
  store %struct.iovec* %arraydecay, %struct.iovec** %iov13, align 8, !tbaa !926
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 0
  %3 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %iov_len14 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %4 = load i64, i64* %iov_len14, align 8, !tbaa !149
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 %4
  %5 = bitcast i8* %add.ptr to i32*
  %p15 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  store i32* %5, i32** %p15, align 8, !tbaa !924
  %iov_base16 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 0
  %6 = load i8*, i8** %iov_base16, align 8, !tbaa !147
  %idx.ext = sext i32 %conv2 to i64
  %add.ptr17 = getelementptr inbounds i8, i8* %6, i64 %idx.ext
  %7 = bitcast i8* %add.ptr17 to i32*
  %end = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 2
  store i32* %7, i32** %end, align 8, !tbaa !925
  %iov_len19 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %8 = load i64, i64* %iov_len19, align 8, !tbaa !149
  %conv20 = sext i32 %conv2 to i64
  %cmp21 = icmp ugt i64 %8, %conv20
  %lnot23 = xor i1 %cmp21, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %conv27 = sext i32 %lnot.ext26 to i64
  %expval28 = call i64 @llvm.expect.i64(i64 %conv27, i64 0)
  %tobool29 = icmp ne i64 %expval28, 0
  br i1 %tobool29, label %do.body31, label %do.end39

do.body31:                                        ; preds = %do.end11
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.899, i32 0, i32 0), i32 467, i64 12) #7, !srcloc !933
  br label %do.body32

do.body32:                                        ; preds = %do.body32, %do.body31
  br label %do.body32

do.end39:                                         ; preds = %do.end11
  %p40 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  %9 = load i32*, i32** %p40, align 8, !tbaa !924
  %cmp41 = icmp ne i32* %p, %9
  %cmp43 = icmp ne i32* %p, null
  %or.cond = and i1 %cmp41, %cmp43
  br i1 %or.cond, label %do.body46, label %if.end77

do.body46:                                        ; preds = %do.end39
  %p47 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  %10 = load i32*, i32** %p47, align 8, !tbaa !924
  %cmp48 = icmp ult i32* %p, %10
  br i1 %cmp48, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.body46
  %end50 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 2
  %11 = load i32*, i32** %end50, align 8, !tbaa !925
  %cmp51 = icmp ugt i32* %p, %11
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %do.body46
  %12 = phi i1 [ true, %do.body46 ], [ %cmp51, %lor.rhs ]
  %lnot53 = xor i1 %12, true
  %lnot55 = xor i1 %lnot53, true
  %lnot.ext56 = zext i1 %lnot55 to i32
  %conv57 = sext i32 %lnot.ext56 to i64
  %expval58 = call i64 @llvm.expect.i64(i64 %conv57, i64 0)
  %tobool59 = icmp ne i64 %expval58, 0
  br i1 %tobool59, label %do.body61, label %do.end69

do.body61:                                        ; preds = %lor.end
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.899, i32 0, i32 0), i32 472, i64 12) #7, !srcloc !934
  br label %do.body62

do.body62:                                        ; preds = %do.body62, %do.body61
  br label %do.body62

do.end69:                                         ; preds = %lor.end
  %13 = bitcast i32* %p to i8*
  %p70 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  %14 = load i32*, i32** %p70, align 8, !tbaa !924
  %15 = bitcast i32* %14 to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %13 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %15 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %p71 = getelementptr inbounds %struct.xdr_stream, %struct.xdr_stream* %xdr, i32 0, i32 0
  store i32* %p, i32** %p71, align 8, !tbaa !924
  %len72 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  %16 = load i32, i32* %len72, align 8, !tbaa !152
  %conv73 = zext i32 %16 to i64
  %add = add i64 %conv73, %sub.ptr.sub
  %conv74 = trunc i64 %add to i32
  store i32 %conv74, i32* %len72, align 8, !tbaa !152
  %iov_len75 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %17 = load i64, i64* %iov_len75, align 8, !tbaa !149
  %add76 = add i64 %17, %sub.ptr.sub
  store i64 %add76, i64* %iov_len75, align 8, !tbaa !149
  br label %if.end77

if.end77:                                         ; preds = %do.end69, %do.end39
  ret void
}

; Function Attrs: nounwind uwtable
define void @xdr_shift_buf(%struct.xdr_buf* %buf, i64 %len) #0 {
entry:
  call void @xdr_shrink_bufhead(%struct.xdr_buf* %buf, i64 %len)
  ret void
}

; Function Attrs: nounwind uwtable
define void @xdr_inline_pages(%struct.xdr_buf* %xdr, i32 %offset, %struct.page** %pages, i32 %base, i32 %len) #0 {
entry:
  %head1 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head1, i32 0, i32 0
  %tail2 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 1
  %arraydecay3 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail2, i32 0, i32 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 0
  %0 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  %1 = load i64, i64* %iov_len, align 8, !tbaa !149
  %conv = trunc i64 %1 to i32
  %conv4 = zext i32 %offset to i64
  %iov_len5 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay, i32 0, i32 1
  store i64 %conv4, i64* %iov_len5, align 8, !tbaa !149
  %pages6 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 2
  store %struct.page** %pages, %struct.page*** %pages6, align 8, !tbaa !354
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 3
  store i32 %base, i32* %page_base, align 8, !tbaa !355
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 4
  store i32 %len, i32* %page_len, align 4, !tbaa !150
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 %idx.ext
  %iov_base7 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay3, i32 0, i32 0
  store i8* %add.ptr, i8** %iov_base7, align 8, !tbaa !147
  %sub = sub i32 %conv, %offset
  %conv8 = zext i32 %sub to i64
  %iov_len9 = getelementptr inbounds %struct.iovec, %struct.iovec* %arraydecay3, i32 0, i32 1
  store i64 %conv8, i64* %iov_len9, align 8, !tbaa !149
  %buflen10 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 6
  %2 = load i32, i32* %buflen10, align 4, !tbaa !153
  %add = add i32 %2, %len
  store i32 %add, i32* %buflen10, align 4, !tbaa !153
  ret void
}

; Function Attrs: nounwind uwtable
define void @xdr_terminate_string(%struct.xdr_buf* %buf, i32 %len) #0 {
entry:
  %pages = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 2
  %0 = load %struct.page**, %struct.page*** %pages, align 8, !tbaa !354
  %arrayidx = getelementptr inbounds %struct.page*, %struct.page** %0, i64 0
  %1 = load %struct.page*, %struct.page** %arrayidx, align 8, !tbaa !28
  %call = call i8* @kmap_atomic.894(%struct.page* %1)
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 3
  %2 = load i32, i32* %page_base, align 8, !tbaa !355
  %add = add i32 %2, %len
  %idxprom = zext i32 %add to i64
  %arrayidx1 = getelementptr inbounds i8, i8* %call, i64 %idxprom
  store i8 0, i8* %arrayidx1, align 1, !tbaa !166
  %tobool = trunc i8 0 to i1
  br i1 %tobool, label %if.then, label %do.body3

if.then:                                          ; preds = %entry
  call void @__compiletime_assert_127()
  br label %do.body3

do.body3:                                         ; preds = %if.then, %entry
  call void @__kunmap_atomic.895()
  ret void
}

declare void @__compiletime_assert_127() #4

; Function Attrs: nounwind uwtable
define i32* @xdr_decode_string_inplace(i32* %p, i8** %sp, i32* %lenp, i32 %maxlen) #0 {
entry:
  %incdec.ptr = getelementptr inbounds i32, i32* %p, i32 1
  %0 = load i32, i32* %p, align 4, !tbaa !49
  %call = call i32 @__fswab32.892(i32 %0) #3
  %cmp = icmp ugt i32 %call, %maxlen
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  store i32 %call, i32* %lenp, align 4, !tbaa !49
  %1 = bitcast i32* %incdec.ptr to i8*
  store i8* %1, i8** %sp, align 8, !tbaa !28
  %add = add i32 %call, 3
  %shr = lshr i32 %add, 2
  %idx.ext = zext i32 %shr to i64
  %add.ptr = getelementptr inbounds i32, i32* %incdec.ptr, i64 %idx.ext
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32* [ %add.ptr, %if.end ], [ null, %entry ]
  ret i32* %retval.0
}

; Function Attrs: nounwind uwtable
define i32* @xdr_encode_string(i32* %p, i8* %string) #0 {
entry:
  %call = call i64 @strlen(i8* %string)
  %conv = trunc i64 %call to i32
  %call1 = call i32* @xdr_encode_array.908(i32* %p, i8* %string, i32 %conv)
  ret i32* %call1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32* @xdr_encode_array.908(i32* %p, i8* %s, i32 %len) #2 {
entry:
  %call = call i32* @xdr_encode_opaque(i32* %p, i8* %s, i32 %len)
  ret i32* %call
}

; Function Attrs: nounwind uwtable
define i32* @xdr_encode_opaque(i32* %p, i8* %ptr, i32 %nbytes) #0 {
entry:
  %call = call i32 @__fswab32.892(i32 %nbytes) #3
  %incdec.ptr = getelementptr inbounds i32, i32* %p, i32 1
  store i32 %call, i32* %p, align 4, !tbaa !49
  %call1 = call i32* @xdr_encode_opaque_fixed(i32* %incdec.ptr, i8* %ptr, i32 %nbytes)
  ret i32* %call1
}

; Function Attrs: nounwind uwtable
define i32* @xdr_encode_opaque_fixed(i32* %p, i8* %ptr, i32 %nbytes) #0 {
entry:
  %cmp = icmp ne i32 %nbytes, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  %add = add i32 %nbytes, 3
  %shr = lshr i32 %add, 2
  %shl = shl i32 %shr, 2
  %sub = sub i32 %shl, %nbytes
  %cmp2 = icmp ne i8* %ptr, null
  br i1 %cmp2, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %conv5 = zext i32 %nbytes to i64
  %0 = bitcast i32* %p to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %ptr, i64 %conv5, i32 1, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %cmp6 = icmp ne i32 %sub, 0
  br i1 %cmp6, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end
  %1 = bitcast i32* %p to i8*
  %idx.ext = zext i32 %nbytes to i64
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 %idx.ext
  %conv9 = zext i32 %sub to i64
  call void @llvm.memset.p0i8.i64(i8* %add.ptr, i8 0, i64 %conv9, i32 1, i1 false)
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end
  %idx.ext11 = zext i32 %shr to i64
  %add.ptr12 = getelementptr inbounds i32, i32* %p, i64 %idx.ext11
  br label %if.end13

if.end13:                                         ; preds = %if.end10, %entry
  %p.addr.0 = phi i32* [ %add.ptr12, %if.end10 ], [ %p, %entry ]
  ret i32* %p.addr.0
}

; Function Attrs: nounwind uwtable
define i32* @xdr_decode_netobj(i32* %p, %struct.perf_raw_record* %obj) #0 {
entry:
  %incdec.ptr = getelementptr inbounds i32, i32* %p, i32 1
  %0 = load i32, i32* %p, align 4, !tbaa !49
  %call = call i32 @__fswab32.892(i32 %0) #3
  %cmp = icmp ugt i32 %call, 1024
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %len1 = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 0
  store i32 %call, i32* %len1, align 8, !tbaa !916
  %1 = bitcast i32* %incdec.ptr to i8*
  %data = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 1
  store i8* %1, i8** %data, align 8, !tbaa !918
  %add = add i32 %call, 3
  %shr = lshr i32 %add, 2
  %idx.ext = zext i32 %shr to i64
  %add.ptr = getelementptr inbounds i32, i32* %incdec.ptr, i64 %idx.ext
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32* [ %add.ptr, %if.end ], [ null, %entry ]
  ret i32* %retval.0
}

; Function Attrs: nounwind uwtable
define i32* @xdr_encode_netobj(i32* %p, %struct.perf_raw_record* %obj) #0 {
entry:
  %len = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 0
  %0 = load i32, i32* %len, align 8, !tbaa !916
  %add = add i32 %0, 3
  %shr = lshr i32 %add, 2
  %idxprom = zext i32 %shr to i64
  %arrayidx = getelementptr inbounds i32, i32* %p, i64 %idxprom
  store i32 0, i32* %arrayidx, align 4, !tbaa !49
  %len1 = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 0
  %1 = load i32, i32* %len1, align 8, !tbaa !916
  %call = call i32 @__fswab32.892(i32 %1) #3
  %incdec.ptr = getelementptr inbounds i32, i32* %p, i32 1
  store i32 %call, i32* %p, align 4, !tbaa !49
  %len2 = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 0
  %2 = load i32, i32* %len2, align 8, !tbaa !916
  %conv = zext i32 %2 to i64
  %3 = bitcast i32* %incdec.ptr to i8*
  %data = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 1
  %4 = load i8*, i8** %data, align 8, !tbaa !918
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 %conv, i32 1, i1 false)
  %len3 = getelementptr inbounds %struct.perf_raw_record, %struct.perf_raw_record* %obj, i32 0, i32 0
  %5 = load i32, i32* %len3, align 8, !tbaa !916
  %add4 = add i32 %5, 3
  %shr5 = lshr i32 %add4, 2
  %idx.ext = zext i32 %shr5 to i64
  %add.ptr = getelementptr inbounds i32, i32* %incdec.ptr, i64 %idx.ext
  ret i32* %add.ptr
}

; Function Attrs: nounwind uwtable
define internal i32 @init_sunrpc() #6 section ".init.text" {
entry:
  %call = call i32 @rpc_init_mempool()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @rpcauth_init_module()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %out2, label %if.end4

if.end4:                                          ; preds = %if.end
  call void @cache_initialize()
  %call5 = call i32 @register_pernet_subsys(%struct.pernet_operations* @sunrpc_net_ops)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %out3, label %if.end8

if.end8:                                          ; preds = %if.end4
  %call9 = call i32 @register_rpc_pipefs()
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %out4, label %if.end12

if.end12:                                         ; preds = %if.end8
  call void @rpc_register_sysctl()
  call void @svc_init_xprt_sock()
  %call13 = call i32 @init_socket_xprt()
  br label %cleanup

out4:                                             ; preds = %if.end8
  call void @unregister_pernet_subsys(%struct.pernet_operations* @sunrpc_net_ops)
  br label %out3

out3:                                             ; preds = %out4, %if.end4
  %err.0 = phi i32 [ %call9, %out4 ], [ %call5, %if.end4 ]
  call void @rpcauth_remove_module()
  br label %out2

out2:                                             ; preds = %out3, %if.end
  %err.1 = phi i32 [ %err.0, %out3 ], [ %call1, %if.end ]
  call void @rpc_destroy_mempool()
  br label %cleanup

cleanup:                                          ; preds = %out2, %if.end12, %entry
  %retval.0 = phi i32 [ 0, %if.end12 ], [ %err.1, %out2 ], [ %call, %entry ]
  ret i32 %retval.0
}

declare i32 @register_pernet_subsys(%struct.pernet_operations*) #4

declare void @unregister_pernet_subsys(%struct.pernet_operations*) #4

; Function Attrs: nounwind uwtable
define internal i32 @sunrpc_init_net(%struct.net* %net) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.914(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %call1 = call i32 @rpc_proc_init(%struct.net* %net)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call2 = call i32 @ip_map_cache_create(%struct.net* %net)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %err_ipmap, label %if.end5

if.end5:                                          ; preds = %if.end
  %call6 = call i32 @unix_gid_cache_create(%struct.net* %net)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %err_unixgid, label %if.end9

if.end9:                                          ; preds = %if.end5
  call void @rpc_pipefs_init_net(%struct.net* %net)
  %all_clients = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 7
  call void @INIT_LIST_HEAD.915(%struct.list_head* %all_clients)
  call void @spinlock_check.916()
  %rpc_client_lock12 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 8
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %rpc_client_lock12, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %2 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.917, i32 0, i32 0), %struct.lock_class_key* @sunrpc_init_net.__key)
  call void @spinlock_check.916()
  %rpcb_clnt_lock18 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 11
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %rpcb_clnt_lock18, i32 0, i32 0
  %rlock19 = bitcast %union.anon.11* %3 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock19, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.2.918, i32 0, i32 0), %struct.lock_class_key* @sunrpc_init_net.__key.1)
  br label %cleanup

err_unixgid:                                      ; preds = %if.end5
  call void @ip_map_cache_destroy(%struct.net* %net)
  br label %err_ipmap

err_ipmap:                                        ; preds = %err_unixgid, %if.end
  %err.0 = phi i32 [ %call6, %err_unixgid ], [ %call2, %if.end ]
  call void @rpc_proc_exit(%struct.net* %net)
  br label %cleanup

cleanup:                                          ; preds = %err_ipmap, %if.end9, %entry
  %retval.0 = phi i32 [ 0, %if.end9 ], [ %err.0, %err_ipmap ], [ %call1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sunrpc_exit_net(%struct.net* %net) #0 {
entry:
  call void @unix_gid_cache_destroy(%struct.net* %net)
  call void @ip_map_cache_destroy(%struct.net* %net)
  call void @rpc_proc_exit(%struct.net* %net)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @net_generic.914(%struct.net* %net, i32 %id) #2 {
entry:
  call void @rcu_read_lock.919()
  %gen = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 37
  %0 = load volatile %struct.net_generic*, %struct.net_generic** %gen, align 16, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.body8

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @net_generic.__warned.920, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %do.body8, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held.921()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.body8, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @net_generic.__warned.920, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 40, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.body8

do.body8:                                         ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %cmp = icmp eq i32 %id, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.body8
  %len = getelementptr inbounds %struct.net_generic, %struct.net_generic* %0, i32 0, i32 0
  %2 = load i32, i32* %len, align 8, !tbaa !176
  %cmp9 = icmp ugt i32 %id, %2
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %do.body8
  %3 = phi i1 [ true, %do.body8 ], [ %cmp9, %lor.rhs ]
  %lnot = xor i1 %3, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %do.body13, label %do.end21

do.body13:                                        ; preds = %lor.end
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 41, i64 12) #7, !srcloc !935
  br label %do.body14

do.body14:                                        ; preds = %do.body14, %do.body13
  br label %do.body14

do.end21:                                         ; preds = %lor.end
  %ptr22 = getelementptr inbounds %struct.net_generic, %struct.net_generic* %0, i32 0, i32 2
  %sub = sub nsw i32 %id, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [0 x i8*], [0 x i8*]* %ptr22, i64 0, i64 %idxprom
  %4 = load i8*, i8** %arrayidx, align 8, !tbaa !28
  call void @rcu_read_unlock.924()
  %tobool24 = icmp ne i8* %4, null
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %do.body35, label %do.end43

do.body35:                                        ; preds = %do.end21
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 45, i64 12) #7, !srcloc !936
  br label %do.body36

do.body36:                                        ; preds = %do.body36, %do.body35
  br label %do.body36

do.end43:                                         ; preds = %do.end21
  ret i8* %4
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.915(%struct.list_head* %list) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !163
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spinlock_check.916() #2 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock.919() #2 {
entry:
  call void @__rcu_read_lock.931()
  call void @rcu_lock_acquire.932(%struct.lockdep_map* @rcu_lock_map)
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_lock.__warned.933, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_lock.__warned.933, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 780, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.15.1329, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rcu_read_lock_held.921() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call1 = call i32 @rcu_is_cpu_idle()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call zeroext i1 @rcu_lockdep_current_cpu_online()
  br i1 %call5, label %if.end7, label %return

if.end7:                                          ; preds = %if.end4
  %call8 = call i32 @lock_is_held(%struct.lockdep_map* @rcu_lock_map)
  br label %return

return:                                           ; preds = %if.end7, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call8, %if.end7 ], [ 1, %entry ], [ 0, %if.end ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_unlock.924() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_unlock.__warned.925, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_unlock.__warned.925, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 801, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.16.1322, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  call void @rcu_lock_release.928(%struct.lockdep_map* @rcu_lock_map)
  call void @__rcu_read_unlock.929()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_release.928(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_release(%struct.lockdep_map* %map, i32 1, i64 ptrtoint (i8* blockaddress(@rcu_lock_release.928, %__here) to i64))
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_unlock.929() #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !937
  %call = call %struct.thread_info* @current_thread_info.930()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !938
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.930() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !939
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_lock.931() #2 {
entry:
  %call = call %struct.thread_info* @current_thread_info.930()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !940
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_acquire.932(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_acquire(%struct.lockdep_map* %map, i32 0, i32 0, i32 2, i32 1, %struct.lockdep_map* null, i64 ptrtoint (i8* blockaddress(@rcu_lock_acquire.932, %__here) to i64))
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @cleanup_sunrpc() #6 section ".exit.text" {
entry:
  call void @rpcauth_remove_module()
  call void @cleanup_socket_xprt()
  call void @svc_cleanup_xprt_sock()
  call void @unregister_rpc_pipefs()
  call void @rpc_destroy_mempool()
  call void @unregister_pernet_subsys(%struct.pernet_operations* @sunrpc_net_ops)
  call void @rpc_unregister_sysctl()
  call void @rcu_barrier()
  ret void
}

declare void @rcu_barrier() #4

declare i64 @no_llseek(%struct.file*, i64, i32) #4

; Function Attrs: nounwind uwtable
define internal i64 @cache_read_pipefs(%struct.file* %filp, i8* %buf, i64 %count, i64* %ppos) #0 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %filp)
  %call1 = call %struct.rpc_inode* @RPC_I(%struct.inode* %call)
  %private = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call1, i32 0, i32 1
  %0 = load i8*, i8** %private, align 8, !tbaa !941
  %1 = bitcast i8* %0 to %struct.cache_detail*
  %call2 = call i64 @cache_read(%struct.file* %filp, i8* %buf, i64 %count, %struct.cache_detail* %1)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define internal i64 @cache_write_pipefs(%struct.file* %filp, i8* %buf, i64 %count, i64* %ppos) #0 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %filp)
  %call1 = call %struct.rpc_inode* @RPC_I(%struct.inode* %call)
  %private = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call1, i32 0, i32 1
  %0 = load i8*, i8** %private, align 8, !tbaa !941
  %1 = bitcast i8* %0 to %struct.cache_detail*
  %call2 = call i64 @cache_write(%struct.file* %filp, i8* %buf, i64 %count, %struct.cache_detail* %1)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @cache_poll_pipefs(%struct.file* %filp, %struct.poll_table_struct* %wait) #0 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %filp)
  %call1 = call %struct.rpc_inode* @RPC_I(%struct.inode* %call)
  %private = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call1, i32 0, i32 1
  %0 = load i8*, i8** %private, align 8, !tbaa !941
  %1 = bitcast i8* %0 to %struct.cache_detail*
  %call2 = call i32 @cache_poll(%struct.file* %filp, %struct.poll_table_struct* %wait, %struct.cache_detail* %1)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i64 @cache_ioctl_pipefs(%struct.file* %filp, i32 %cmd, i64 %arg) #0 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %filp)
  %call1 = call %struct.rpc_inode* @RPC_I(%struct.inode* %call)
  %private = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call1, i32 0, i32 1
  %0 = load i8*, i8** %private, align 8, !tbaa !941
  %1 = bitcast i8* %0 to %struct.cache_detail*
  %call2 = call i32 @cache_ioctl(%struct.file* %filp, i32 %cmd, i64 %arg, %struct.cache_detail* %1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @cache_open_pipefs(%struct.inode* %inode, %struct.file* %filp) #0 {
entry:
  %call = call %struct.rpc_inode* @RPC_I(%struct.inode* %inode)
  %private = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call, i32 0, i32 1
  %0 = load i8*, i8** %private, align 8, !tbaa !941
  %1 = bitcast i8* %0 to %struct.cache_detail*
  %call1 = call i32 @cache_open(%struct.inode* %inode, %struct.file* %filp, %struct.cache_detail* %1)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @cache_release_pipefs(%struct.inode* %inode, %struct.file* %filp) #0 {
entry:
  %call = call %struct.rpc_inode* @RPC_I(%struct.inode* %inode)
  %private = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call, i32 0, i32 1
  %0 = load i8*, i8** %private, align 8, !tbaa !941
  %1 = bitcast i8* %0 to %struct.cache_detail*
  %call1 = call i32 @cache_release(%struct.file* %filp, %struct.cache_detail* %1)
  ret i32 %call1
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.rpc_inode* @RPC_I(%struct.inode* %inode) #2 {
entry:
  %0 = bitcast %struct.inode* %inode to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.rpc_inode*
  ret %struct.rpc_inode* %1
}

; Function Attrs: nounwind uwtable
define internal i32 @cache_release(%struct.file* %filp, %struct.cache_detail* %cd) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !947
  %1 = bitcast i8* %0 to %struct.cache_reader*
  %tobool = icmp ne %struct.cache_reader* %1, null
  br i1 %tobool, label %if.then, label %if.end15

if.then:                                          ; preds = %entry
  call void @spin_lock.935(%struct.spinlock* @queue_lock)
  %offset = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 1
  %2 = load i32, i32* %offset, align 8, !tbaa !952
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %if.then2, label %if.end10

if.then2:                                         ; preds = %if.then
  %q = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then2
  %cq.0 = phi %struct.netdev_hw_addr_list* [ %q, %if.then2 ], [ %9, %for.inc ]
  %list = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %cq.0, i32 0, i32 0
  %queue = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 20
  %cmp = icmp ne %struct.list_head* %list, %queue
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %reader = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %cq.0, i32 0, i32 1
  %3 = load i32, i32* %reader, align 8, !tbaa !955
  %tobool3 = icmp ne i32 %3, 0
  br i1 %tobool3, label %for.inc, label %if.then4

if.then4:                                         ; preds = %for.body
  %4 = bitcast %struct.netdev_hw_addr_list* %cq.0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr to %struct.cache_request*
  %readers = getelementptr inbounds %struct.cache_request, %struct.cache_request* %5, i32 0, i32 4
  %6 = load i32, i32* %readers, align 4, !tbaa !956
  %dec = add nsw i32 %6, -1
  store i32 %dec, i32* %readers, align 4, !tbaa !956
  br label %for.end

for.inc:                                          ; preds = %for.body
  %list6 = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %cq.0, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list6, i32 0, i32 0
  %7 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !958
  %8 = bitcast %struct.list_head* %7 to i8*
  %add.ptr8 = getelementptr inbounds i8, i8* %8, i64 0
  %9 = bitcast i8* %add.ptr8 to %struct.netdev_hw_addr_list*
  br label %for.cond

for.end:                                          ; preds = %if.then4, %for.cond
  %offset9 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 1
  store i32 0, i32* %offset9, align 8, !tbaa !952
  br label %if.end10

if.end10:                                         ; preds = %for.end, %if.then
  %q11 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 0
  %list12 = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q11, i32 0, i32 0
  call void @list_del(%struct.list_head* %list12)
  call void @spin_unlock.936(%struct.spinlock* @queue_lock)
  %private_data13 = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 15
  store i8* null, i8** %private_data13, align 8, !tbaa !947
  %10 = bitcast %struct.cache_reader* %1 to i8*
  call void @kfree(i8* %10)
  %call = call i64 @seconds_since_boot()
  %last_close = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 22
  store i64 %call, i64* %last_close, align 8, !tbaa !959
  %readers14 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 21
  call void @atomic_dec.937(%struct.atomic_t* %readers14)
  br label %if.end15

if.end15:                                         ; preds = %if.end10, %entry
  %owner = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 0
  %11 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !960
  call void @module_put(%struct.module* %11)
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock.935(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock.936(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @seconds_since_boot() #2 {
entry:
  %boot = alloca %struct.load_weight, align 8
  call void @getboottime(%struct.load_weight* %boot)
  %call = call i64 @get_seconds()
  %tv_sec = getelementptr inbounds %struct.load_weight, %struct.load_weight* %boot, i32 0, i32 0
  %0 = load i64, i64* %tv_sec, align 8, !tbaa !845
  %sub = sub i64 %call, %0
  ret i64 %sub
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_dec.937(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !961
  ret void
}

declare i64 @get_seconds() #4

; Function Attrs: nounwind uwtable
define internal i32 @cache_open(%struct.inode* %inode, %struct.file* %filp, %struct.cache_detail* %cd) #0 {
entry:
  %tobool = icmp ne %struct.cache_detail* %cd, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %owner = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 0
  %0 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !960
  %call = call zeroext i1 @try_module_get(%struct.module* %0)
  br i1 %call, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %call1 = call i32 @nonseekable_open(%struct.inode* %inode, %struct.file* %filp)
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 8
  %1 = load i32, i32* %f_mode, align 4, !tbaa !962
  %and = and i32 %1, 1
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.then3, label %if.end10

if.then3:                                         ; preds = %if.end
  %call.i = call i8* @__kmalloc(i64 32, i32 208) #7
  %2 = bitcast i8* %call.i to %struct.cache_reader*
  %tobool5 = icmp ne %struct.cache_reader* %2, null
  br i1 %tobool5, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.then3
  %owner7 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 0
  %3 = load %struct.module*, %struct.module** %owner7, align 8, !tbaa !960
  call void @module_put(%struct.module* %3)
  br label %cleanup

if.end8:                                          ; preds = %if.then3
  %offset = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %2, i32 0, i32 1
  store i32 0, i32* %offset, align 8, !tbaa !952
  %q = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %2, i32 0, i32 0
  %reader = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q, i32 0, i32 1
  store i32 1, i32* %reader, align 8, !tbaa !963
  %readers = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 21
  call void @atomic_inc.940(%struct.atomic_t* %readers)
  call void @spin_lock.935(%struct.spinlock* @queue_lock)
  %q9 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %2, i32 0, i32 0
  %list = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q9, i32 0, i32 0
  %queue = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 20
  call void @list_add.941(%struct.list_head* %list, %struct.list_head* %queue)
  call void @spin_unlock.936(%struct.spinlock* @queue_lock)
  br label %if.end10

if.end10:                                         ; preds = %if.end8, %if.end
  %rp.0 = phi %struct.cache_reader* [ %2, %if.end8 ], [ null, %if.end ]
  %4 = bitcast %struct.cache_reader* %rp.0 to i8*
  %private_data = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 15
  store i8* %4, i8** %private_data, align 8, !tbaa !947
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.then6, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ 0, %if.end10 ], [ -12, %if.then6 ], [ -13, %lor.lhs.false ], [ -13, %entry ]
  ret i32 %retval.0
}

declare i32 @nonseekable_open(%struct.inode*, %struct.file*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.940(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !964
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add.941(%struct.list_head* %new, %struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.inode* @file_inode(%struct.file* %f) #2 {
entry:
  %f_inode = getelementptr inbounds %struct.file, %struct.file* %f, i32 0, i32 2
  %0 = load %struct.inode*, %struct.inode** %f_inode, align 8, !tbaa !965
  ret %struct.inode* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @cache_ioctl(%struct.file* %filp, i32 %cmd, i64 %arg, %struct.cache_detail* %cd) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !947
  %1 = bitcast i8* %0 to %struct.cache_reader*
  %cmp = icmp eq i32 %cmd, 21531
  %tobool = icmp ne %struct.cache_reader* %1, null
  %or.cond = and i1 %cmp, %tobool
  br i1 %or.cond, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  call void @spin_lock.935(%struct.spinlock* @queue_lock)
  %q = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %cq.0 = phi %struct.netdev_hw_addr_list* [ %q, %if.end ], [ %9, %for.inc ]
  %list = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %cq.0, i32 0, i32 0
  %queue = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 20
  %cmp1 = icmp ne %struct.list_head* %list, %queue
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %reader = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %cq.0, i32 0, i32 1
  %2 = load i32, i32* %reader, align 8, !tbaa !955
  %tobool2 = icmp ne i32 %2, 0
  br i1 %tobool2, label %for.inc, label %if.then3

if.then3:                                         ; preds = %for.body
  %3 = bitcast %struct.netdev_hw_addr_list* %cq.0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.cache_request*
  %len4 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %4, i32 0, i32 3
  %5 = load i32, i32* %len4, align 8, !tbaa !966
  %offset = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 1
  %6 = load i32, i32* %offset, align 8, !tbaa !952
  %sub = sub nsw i32 %5, %6
  br label %for.end

for.inc:                                          ; preds = %for.body
  %list7 = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %cq.0, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list7, i32 0, i32 0
  %7 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !958
  %8 = bitcast %struct.list_head* %7 to i8*
  %add.ptr9 = getelementptr inbounds i8, i8* %8, i64 0
  %9 = bitcast i8* %add.ptr9 to %struct.netdev_hw_addr_list*
  br label %for.cond

for.end:                                          ; preds = %if.then3, %for.cond
  %len.0 = phi i32 [ %sub, %if.then3 ], [ 0, %for.cond ]
  call void @spin_unlock.936(%struct.spinlock* @queue_lock)
  call void @might_fault()
  %10 = inttoptr i64 %arg to i32*
  %11 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %len.0, i32* %10) #7, !srcloc !967
  br label %cleanup

cleanup:                                          ; preds = %for.end, %entry
  %retval.0 = phi i32 [ %11, %for.end ], [ -22, %entry ]
  ret i32 %retval.0
}

declare void @might_fault() #4

; Function Attrs: nounwind uwtable
define internal i32 @cache_poll(%struct.file* %filp, %struct.poll_table_struct* %wait, %struct.cache_detail* %cd) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !947
  %1 = bitcast i8* %0 to %struct.cache_reader*
  call void @poll_wait(%struct.file* %filp, %struct.__wait_queue_head* @queue_wait, %struct.poll_table_struct* %wait)
  %tobool = icmp ne %struct.cache_reader* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  call void @spin_lock.935(%struct.spinlock* @queue_lock)
  %q = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %cq.0 = phi %struct.netdev_hw_addr_list* [ %q, %if.end ], [ %5, %for.inc ]
  %list = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %cq.0, i32 0, i32 0
  %queue = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 20
  %cmp = icmp ne %struct.list_head* %list, %queue
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %reader = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %cq.0, i32 0, i32 1
  %2 = load i32, i32* %reader, align 8, !tbaa !955
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %for.inc, label %if.then2

if.then2:                                         ; preds = %for.body
  %or = or i32 131330, 65
  br label %for.end

for.inc:                                          ; preds = %for.body
  %list4 = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %cq.0, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list4, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !958
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr to %struct.netdev_hw_addr_list*
  br label %for.cond

for.end:                                          ; preds = %if.then2, %for.cond
  %mask.0 = phi i32 [ %or, %if.then2 ], [ 131330, %for.cond ]
  call void @spin_unlock.936(%struct.spinlock* @queue_lock)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %entry
  %retval.0 = phi i32 [ %mask.0, %for.end ], [ 131330, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @poll_wait(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #2 {
entry:
  %tobool = icmp ne %struct.poll_table_struct* %p, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %0 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8, !tbaa !968
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.__wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %1 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8, !tbaa !968
  call void %1(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @cache_write(%struct.file* %filp, i8* %buf, i64 %count, %struct.cache_detail* %cd) #0 {
entry:
  %f_mapping = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 18
  %0 = load %struct.address_space*, %struct.address_space** %f_mapping, align 8, !tbaa !970
  %call = call %struct.inode* @file_inode(%struct.file* %filp)
  %cache_parse = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 9
  %1 = load i32 (%struct.cache_detail*, i8*, i32)*, i32 (%struct.cache_detail*, i8*, i32)** %cache_parse, align 8, !tbaa !971
  %tobool = icmp ne i32 (%struct.cache_detail*, i8*, i32)* %1, null
  br i1 %tobool, label %if.end, label %out

if.end:                                           ; preds = %entry
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 0)
  %call1 = call i64 @cache_downcall(%struct.address_space* %0, i8* %buf, i64 %count, %struct.cache_detail* %cd)
  %i_mutex2 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex2)
  br label %out

out:                                              ; preds = %if.end, %entry
  %ret.0 = phi i64 [ %call1, %if.end ], [ -22, %entry ]
  ret i64 %ret.0
}

; Function Attrs: nounwind uwtable
define internal i64 @cache_downcall(%struct.address_space* %mapping, i8* %buf, i64 %count, %struct.cache_detail* %cd) #0 {
entry:
  %cmp = icmp uge i64 %count, 4096
  br i1 %cmp, label %out_slow, label %if.end

if.end:                                           ; preds = %entry
  %call = call %struct.page* @find_or_create_page(%struct.address_space* %mapping, i64 0, i32 208)
  %tobool = icmp ne %struct.page* %call, null
  br i1 %tobool, label %if.end2, label %out_slow

if.end2:                                          ; preds = %if.end
  %call3 = call i8* @kmap.943(%struct.page* %call)
  %call4 = call i64 @cache_do_downcall(i8* %call3, i8* %buf, i64 %count, %struct.cache_detail* %cd)
  call void @kunmap.944()
  call void @unlock_page(%struct.page* %call)
  call void @put_page(%struct.page* %call)
  br label %cleanup

out_slow:                                         ; preds = %if.end, %entry
  %call5 = call i64 @cache_slow_downcall(i8* %buf, i64 %count, %struct.cache_detail* %cd)
  br label %cleanup

cleanup:                                          ; preds = %out_slow, %if.end2
  %retval.0 = phi i64 [ %call5, %out_slow ], [ %call4, %if.end2 ]
  ret i64 %retval.0
}

declare %struct.page* @find_or_create_page(%struct.address_space*, i64, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kmap.943(%struct.page* %page) #2 {
entry:
  call void @__might_sleep(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.25.949, i32 0, i32 0), i32 58, i32 0)
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %page to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %0 = inttoptr i64 %add.i to i8*
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i64 @cache_do_downcall(i8* %kaddr, i8* %buf, i64 %count, %struct.cache_detail* %cd) #0 {
entry:
  %cmp = icmp eq i64 %count, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i64 @copy_from_user(i8* %kaddr, i8* %buf, i64 %count)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %arrayidx = getelementptr inbounds i8, i8* %kaddr, i64 %count
  store i8 0, i8* %arrayidx, align 1, !tbaa !166
  %cache_parse = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 9
  %0 = load i32 (%struct.cache_detail*, i8*, i32)*, i32 (%struct.cache_detail*, i8*, i32)** %cache_parse, align 8, !tbaa !971
  %conv = trunc i64 %count to i32
  %call3 = call i32 %0(%struct.cache_detail* %cd, i8* %kaddr, i32 %conv)
  %conv4 = sext i32 %call3 to i64
  %tobool5 = icmp ne i64 %conv4, 0
  %conv4.count = select i1 %tobool5, i64 %conv4, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i64 [ %conv4.count, %if.end2 ], [ -22, %entry ], [ -14, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kunmap.944() #2 {
entry:
  ret void
}

declare void @unlock_page(%struct.page*) #4

; Function Attrs: nounwind uwtable
define internal i64 @cache_slow_downcall(i8* %buf, i64 %count, %struct.cache_detail* %cd) #0 {
entry:
  %cmp = icmp uge i64 %count, 8192
  br i1 %cmp, label %out, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @queue_io_mutex, i32 0)
  %call = call i64 @cache_do_downcall(i8* getelementptr inbounds ([8192 x i8], [8192 x i8]* @cache_slow_downcall.write_buf, i32 0, i32 0), i8* %buf, i64 %count, %struct.cache_detail* %cd)
  call void @mutex_unlock(%struct.mutex* @queue_io_mutex)
  br label %out

out:                                              ; preds = %if.end, %entry
  %ret.0 = phi i64 [ %call, %if.end ], [ -22, %entry ]
  ret i64 %ret.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @copy_from_user(i8* %to, i8* %from, i64 %n) #2 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %cmp = icmp eq i32 %conv, -1
  %conv2 = sext i32 %conv to i64
  %cmp3 = icmp uge i64 %conv2, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp3
  %lnot = xor i1 %1, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %conv7 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv7)
  br label %if.end24

if.else:                                          ; preds = %entry
  %tobool8 = icmp ne i32 1, 0
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  br i1 %tobool15, label %if.then16, label %if.end

if.then16:                                        ; preds = %if.else
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.8.1377, i32 0, i32 0), i32 66, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.9.1378, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then16, %if.else
  br label %if.end24

if.end24:                                         ; preds = %if.end, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.end ]
  ret i64 %n.addr.0
}

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #8

declare i64 @_copy_from_user(i8*, i8*, i32) #4

; Function Attrs: nounwind uwtable
define internal i64 @cache_read(%struct.file* %filp, i8* %buf, i64 %count, %struct.cache_detail* %cd) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !947
  %1 = bitcast i8* %0 to %struct.cache_reader*
  %call = call %struct.inode* @file_inode(%struct.file* %filp)
  %cmp = icmp eq i64 %count, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 0)
  br label %again

again:                                            ; preds = %if.then219, %if.end
  %count.addr.0 = phi i64 [ %count, %if.end ], [ %count.addr.3, %if.then219 ]
  call void @spin_lock.935(%struct.spinlock* @queue_lock)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %again
  %q = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 0
  %list = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !972
  %queue = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 20
  %cmp1 = icmp ne %struct.list_head* %2, %queue
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %q2 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 0
  %list3 = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q2, i32 0, i32 0
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %list3, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next4, align 8, !tbaa !972
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr to %struct.netdev_hw_addr_list*
  %reader = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %5, i32 0, i32 1
  %6 = load i32, i32* %reader, align 8, !tbaa !955
  %tobool = icmp ne i32 %6, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %7 = phi i1 [ false, %while.cond ], [ %tobool, %land.rhs ]
  %q6 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 0
  %list7 = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q6, i32 0, i32 0
  %next8 = getelementptr inbounds %struct.list_head, %struct.list_head* %list7, i32 0, i32 0
  %8 = load %struct.list_head*, %struct.list_head** %next8, align 8, !tbaa !972
  br i1 %7, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %q9 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 0
  %list10 = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q9, i32 0, i32 0
  call void @list_move.951(%struct.list_head* %list10, %struct.list_head* %8)
  br label %while.cond

while.end:                                        ; preds = %land.end
  %queue14 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 20
  %cmp15 = icmp eq %struct.list_head* %8, %queue14
  br i1 %cmp15, label %if.then16, label %if.end64

if.then16:                                        ; preds = %while.end
  call void @spin_unlock.936(%struct.spinlock* @queue_lock)
  %i_mutex17 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex17)
  %offset = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 1
  %9 = load i32, i32* %offset, align 8, !tbaa !952
  %tobool18 = icmp ne i32 %9, 0
  %lnot = xor i1 %tobool18, true
  %lnot19 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot19 to i32
  %tobool20 = icmp ne i32 %lnot.ext, 0
  %lnot21 = xor i1 %tobool20, true
  %lnot23 = xor i1 %lnot21, true
  %lnot.ext24 = zext i1 %lnot23 to i32
  %conv = sext i32 %lnot.ext24 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool25 = icmp ne i64 %expval, 0
  br i1 %tobool25, label %if.then26, label %if.end55

if.then26:                                        ; preds = %if.then16
  %10 = load i8, i8* @cache_read.__warned, align 1, !tbaa !29, !range !31
  %tobool27 = trunc i8 %10 to i1
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot32 = xor i1 %lnot30, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %tobool34 = icmp ne i32 %lnot.ext33, 0
  %lnot35 = xor i1 %tobool34, true
  %lnot37 = xor i1 %lnot35, true
  %lnot.ext38 = zext i1 %lnot37 to i32
  %conv39 = sext i32 %lnot.ext38 to i64
  %expval40 = call i64 @llvm.expect.i64(i64 %conv39, i64 0)
  %tobool41 = icmp ne i64 %expval40, 0
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.then26
  call void @warn_slowpath_null(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.952, i32 0, i32 0), i32 790)
  br label %if.end43

if.end43:                                         ; preds = %if.then42, %if.then26
  %tobool45 = icmp ne i32 %lnot.ext33, 0
  %lnot46 = xor i1 %tobool45, true
  %lnot48 = xor i1 %lnot46, true
  %lnot.ext49 = zext i1 %lnot48 to i32
  %conv50 = sext i32 %lnot.ext49 to i64
  %expval51 = call i64 @llvm.expect.i64(i64 %conv50, i64 0)
  %tobool52 = icmp ne i64 %expval51, 0
  br i1 %tobool52, label %if.then53, label %if.end55

if.then53:                                        ; preds = %if.end43
  store i8 1, i8* @cache_read.__warned, align 1, !tbaa !29
  br label %if.end55

if.end55:                                         ; preds = %if.then53, %if.end43, %if.then16
  br label %cleanup

if.end64:                                         ; preds = %while.end
  %q66 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 0
  %list67 = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q66, i32 0, i32 0
  %next68 = getelementptr inbounds %struct.list_head, %struct.list_head* %list67, i32 0, i32 0
  %11 = load %struct.list_head*, %struct.list_head** %next68, align 8, !tbaa !972
  %12 = bitcast %struct.list_head* %11 to i8*
  %add.ptr70 = getelementptr inbounds i8, i8* %12, i64 0
  %13 = bitcast i8* %add.ptr70 to %struct.cache_request*
  %q72 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 0
  %reader73 = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q72, i32 0, i32 1
  %14 = load i32, i32* %reader73, align 8, !tbaa !973
  %tobool74 = icmp ne i32 %14, 0
  %lnot75 = xor i1 %tobool74, true
  %lnot77 = xor i1 %lnot75, true
  %lnot.ext78 = zext i1 %lnot77 to i32
  %tobool79 = icmp ne i32 %lnot.ext78, 0
  %lnot80 = xor i1 %tobool79, true
  %lnot82 = xor i1 %lnot80, true
  %lnot.ext83 = zext i1 %lnot82 to i32
  %conv84 = sext i32 %lnot.ext83 to i64
  %expval85 = call i64 @llvm.expect.i64(i64 %conv84, i64 0)
  %tobool86 = icmp ne i64 %expval85, 0
  br i1 %tobool86, label %if.then87, label %if.end117

if.then87:                                        ; preds = %if.end64
  %15 = load i8, i8* @cache_read.__warned.24, align 1, !tbaa !29, !range !31
  %tobool89 = trunc i8 %15 to i1
  %lnot90 = xor i1 %tobool89, true
  %lnot92 = xor i1 %lnot90, true
  %lnot94 = xor i1 %lnot92, true
  %lnot.ext95 = zext i1 %lnot94 to i32
  %tobool96 = icmp ne i32 %lnot.ext95, 0
  %lnot97 = xor i1 %tobool96, true
  %lnot99 = xor i1 %lnot97, true
  %lnot.ext100 = zext i1 %lnot99 to i32
  %conv101 = sext i32 %lnot.ext100 to i64
  %expval102 = call i64 @llvm.expect.i64(i64 %conv101, i64 0)
  %tobool103 = icmp ne i64 %expval102, 0
  br i1 %tobool103, label %if.then104, label %if.end105

if.then104:                                       ; preds = %if.then87
  call void @warn_slowpath_null(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.952, i32 0, i32 0), i32 794)
  br label %if.end105

if.end105:                                        ; preds = %if.then104, %if.then87
  %tobool107 = icmp ne i32 %lnot.ext95, 0
  %lnot108 = xor i1 %tobool107, true
  %lnot110 = xor i1 %lnot108, true
  %lnot.ext111 = zext i1 %lnot110 to i32
  %conv112 = sext i32 %lnot.ext111 to i64
  %expval113 = call i64 @llvm.expect.i64(i64 %conv112, i64 0)
  %tobool114 = icmp ne i64 %expval113, 0
  br i1 %tobool114, label %if.then115, label %if.end117

if.then115:                                       ; preds = %if.end105
  store i8 1, i8* @cache_read.__warned.24, align 1, !tbaa !29
  br label %if.end117

if.end117:                                        ; preds = %if.then115, %if.end105, %if.end64
  %offset126 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 1
  %16 = load i32, i32* %offset126, align 8, !tbaa !952
  %cmp127 = icmp eq i32 %16, 0
  br i1 %cmp127, label %if.then129, label %if.end130

if.then129:                                       ; preds = %if.end117
  %readers = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 4
  %17 = load i32, i32* %readers, align 4, !tbaa !956
  %inc = add nsw i32 %17, 1
  store i32 %inc, i32* %readers, align 4, !tbaa !956
  br label %if.end130

if.end130:                                        ; preds = %if.then129, %if.end117
  call void @spin_unlock.936(%struct.spinlock* @queue_lock)
  %len = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 3
  %18 = load i32, i32* %len, align 8, !tbaa !966
  %cmp131 = icmp eq i32 %18, 0
  br i1 %cmp131, label %if.then133, label %if.end140

if.then133:                                       ; preds = %if.end130
  %call134 = call i32 @cache_request(%struct.cache_detail* %cd, %struct.cache_request* %13)
  %cmp135 = icmp slt i32 %call134, 0
  br i1 %cmp135, label %out, label %if.end138

if.end138:                                        ; preds = %if.then133
  %len139 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 3
  store i32 %call134, i32* %len139, align 8, !tbaa !966
  br label %if.end140

if.end140:                                        ; preds = %if.end138, %if.end130
  %offset141 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 1
  %19 = load i32, i32* %offset141, align 8, !tbaa !952
  %cmp142 = icmp eq i32 %19, 0
  br i1 %cmp142, label %cond.true, label %if.else

cond.true:                                        ; preds = %if.end140
  %item = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 1
  %20 = load %struct.cache_head*, %struct.cache_head** %item, align 8, !tbaa !974
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %20, i32 0, i32 4
  %21 = load volatile i64, i64* %flags, align 8, !tbaa !88
  %and.i1 = and i64 4, %21
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool145 = icmp ne i32 %conv.i3, 0
  br i1 %tobool145, label %if.else, label %if.then150

if.then150:                                       ; preds = %cond.true
  call void @spin_lock.935(%struct.spinlock* @queue_lock)
  %q151 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 0
  %list152 = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q151, i32 0, i32 0
  %q153 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 0
  %list154 = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q153, i32 0, i32 0
  call void @list_move.951(%struct.list_head* %list152, %struct.list_head* %list154)
  call void @spin_unlock.936(%struct.spinlock* @queue_lock)
  br label %out

if.else:                                          ; preds = %cond.true, %if.end140
  %offset155 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 1
  %22 = load i32, i32* %offset155, align 8, !tbaa !952
  %conv156 = sext i32 %22 to i64
  %add = add i64 %conv156, %count.addr.0
  %len157 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 3
  %23 = load i32, i32* %len157, align 8, !tbaa !966
  %conv158 = sext i32 %23 to i64
  %cmp159 = icmp ugt i64 %add, %conv158
  br i1 %cmp159, label %if.then161, label %if.end165

if.then161:                                       ; preds = %if.else
  %len162 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 3
  %24 = load i32, i32* %len162, align 8, !tbaa !966
  %offset163 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 1
  %25 = load i32, i32* %offset163, align 8, !tbaa !952
  %sub = sub nsw i32 %24, %25
  %conv164 = sext i32 %sub to i64
  br label %if.end165

if.end165:                                        ; preds = %if.then161, %if.else
  %count.addr.1 = phi i64 [ %conv164, %if.then161 ], [ %count.addr.0, %if.else ]
  %buf166 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 2
  %26 = load i8*, i8** %buf166, align 8, !tbaa !975
  %offset167 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 1
  %27 = load i32, i32* %offset167, align 8, !tbaa !952
  %idx.ext = sext i32 %27 to i64
  %add.ptr168 = getelementptr inbounds i8, i8* %26, i64 %idx.ext
  %conv169 = trunc i64 %count.addr.1 to i32
  call void @might_fault() #7
  %call.i = call i64 @_copy_to_user(i8* %buf, i8* %add.ptr168, i32 %conv169) #7
  %conv.i4 = trunc i64 %call.i to i32
  %tobool171 = icmp ne i32 %conv.i4, 0
  br i1 %tobool171, label %out, label %if.end173

if.end173:                                        ; preds = %if.end165
  %offset174 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 1
  %28 = load i32, i32* %offset174, align 8, !tbaa !952
  %conv175 = sext i32 %28 to i64
  %add176 = add i64 %conv175, %count.addr.1
  %conv177 = trunc i64 %add176 to i32
  store i32 %conv177, i32* %offset174, align 8, !tbaa !952
  %offset178 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 1
  %29 = load i32, i32* %offset178, align 8, !tbaa !952
  %len179 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 3
  %30 = load i32, i32* %len179, align 8, !tbaa !966
  %cmp180 = icmp sge i32 %29, %30
  br i1 %cmp180, label %if.then182, label %out

if.then182:                                       ; preds = %if.end173
  %offset183 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 1
  store i32 0, i32* %offset183, align 8, !tbaa !952
  call void @spin_lock.935(%struct.spinlock* @queue_lock)
  %q184 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 0
  %list185 = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q184, i32 0, i32 0
  %q186 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 0
  %list187 = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q186, i32 0, i32 0
  call void @list_move.951(%struct.list_head* %list185, %struct.list_head* %list187)
  call void @spin_unlock.936(%struct.spinlock* @queue_lock)
  br label %out

out:                                              ; preds = %if.then182, %if.end173, %if.end165, %if.then150, %if.then133
  %count.addr.3 = phi i64 [ %count.addr.0, %if.then133 ], [ %count.addr.1, %if.end165 ], [ %count.addr.0, %if.then150 ], [ %count.addr.1, %if.then182 ], [ %count.addr.1, %if.end173 ]
  %err.1 = phi i32 [ %call134, %if.then133 ], [ -14, %if.end165 ], [ -11, %if.then150 ], [ 0, %if.then182 ], [ 0, %if.end173 ]
  %offset190 = getelementptr inbounds %struct.cache_reader, %struct.cache_reader* %1, i32 0, i32 1
  %31 = load i32, i32* %offset190, align 8, !tbaa !952
  %cmp191 = icmp eq i32 %31, 0
  br i1 %cmp191, label %if.then193, label %if.end216

if.then193:                                       ; preds = %out
  call void @spin_lock.935(%struct.spinlock* @queue_lock)
  %readers194 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 4
  %32 = load i32, i32* %readers194, align 4, !tbaa !956
  %dec = add nsw i32 %32, -1
  store i32 %dec, i32* %readers194, align 4, !tbaa !956
  %readers195 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 4
  %33 = load i32, i32* %readers195, align 4, !tbaa !956
  %cmp196 = icmp eq i32 %33, 0
  br i1 %cmp196, label %cond.true199, label %if.else214

cond.true199:                                     ; preds = %if.then193
  %item200 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 1
  %34 = load %struct.cache_head*, %struct.cache_head** %item200, align 8, !tbaa !974
  %flags201 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %34, i32 0, i32 4
  %35 = load volatile i64, i64* %flags201, align 8, !tbaa !88
  %and.i = and i64 4, %35
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool203 = icmp ne i32 %conv.i, 0
  br i1 %tobool203, label %if.else214, label %if.then209

if.then209:                                       ; preds = %cond.true199
  %q210 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 0
  %list211 = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q210, i32 0, i32 0
  call void @list_del(%struct.list_head* %list211)
  call void @spin_unlock.936(%struct.spinlock* @queue_lock)
  %item212 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 1
  %36 = load %struct.cache_head*, %struct.cache_head** %item212, align 8, !tbaa !974
  call void @cache_put.954(%struct.cache_head* %36, %struct.cache_detail* %cd)
  %buf213 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %13, i32 0, i32 2
  %37 = load i8*, i8** %buf213, align 8, !tbaa !975
  call void @kfree(i8* %37)
  %38 = bitcast %struct.cache_request* %13 to i8*
  call void @kfree(i8* %38)
  br label %if.end216

if.else214:                                       ; preds = %cond.true199, %if.then193
  call void @spin_unlock.936(%struct.spinlock* @queue_lock)
  br label %if.end216

if.end216:                                        ; preds = %if.else214, %if.then209, %out
  %cmp217 = icmp eq i32 %err.1, -11
  br i1 %cmp217, label %if.then219, label %if.end220

if.then219:                                       ; preds = %if.end216
  br label %again

if.end220:                                        ; preds = %if.end216
  %i_mutex221 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex221)
  %tobool222 = icmp ne i32 %err.1, 0
  %conv224 = sext i32 %err.1 to i64
  %cond = select i1 %tobool222, i64 %conv224, i64 %count.addr.3
  br label %cleanup

cleanup:                                          ; preds = %if.end220, %if.end55, %entry
  %retval.0 = phi i64 [ 0, %if.end55 ], [ 0, %entry ], [ %cond, %if.end220 ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_move.951(%struct.list_head* %list, %struct.list_head* %head) #2 {
entry:
  call void @__list_del_entry(%struct.list_head* %list)
  call void @list_add.941(%struct.list_head* %list, %struct.list_head* %head)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @cache_request(%struct.cache_detail* %detail, %struct.cache_request* %crq) #0 {
entry:
  %bp = alloca i8*, align 8
  %len = alloca i32, align 4
  %buf = getelementptr inbounds %struct.cache_request, %struct.cache_request* %crq, i32 0, i32 2
  %0 = load i8*, i8** %buf, align 8, !tbaa !975
  store i8* %0, i8** %bp, align 8, !tbaa !28
  store i32 4096, i32* %len, align 4, !tbaa !49
  %cache_request = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 8
  %1 = load void (%struct.cache_detail*, %struct.cache_head*, i8**, i32*)*, void (%struct.cache_detail*, %struct.cache_head*, i8**, i32*)** %cache_request, align 8, !tbaa !976
  %item = getelementptr inbounds %struct.cache_request, %struct.cache_request* %crq, i32 0, i32 1
  %2 = load %struct.cache_head*, %struct.cache_head** %item, align 8, !tbaa !974
  call void %1(%struct.cache_detail* %detail, %struct.cache_head* %2, i8** %bp, i32* %len)
  %3 = load i32, i32* %len, align 4, !tbaa !49
  %cmp = icmp slt i32 %3, 0
  %4 = load i32, i32* %len, align 4
  %conv = sext i32 %4 to i64
  %sub = sub i64 4096, %conv
  %conv1 = trunc i64 %sub to i32
  %retval.0 = select i1 %cmp, i32 -11, i32 %conv1
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @cache_put.954(%struct.cache_head* %h, %struct.cache_detail* %cd) #2 {
entry:
  %ref = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 3
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %ref, i32 0, i32 0
  %call = call i32 @atomic_read.955(%struct.atomic_t* %refcount)
  %cmp = icmp sle i32 %call, 2
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %expiry_time = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 1
  %0 = load i64, i64* %expiry_time, align 8, !tbaa !828
  %nextcheck = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 18
  %1 = load i64, i64* %nextcheck, align 8, !tbaa !829
  %cmp1 = icmp slt i64 %0, %1
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %expiry_time2 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 1
  %2 = load i64, i64* %expiry_time2, align 8, !tbaa !828
  %nextcheck3 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 18
  store i64 %2, i64* %nextcheck3, align 8, !tbaa !829
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %ref4 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 3
  %cache_put = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 6
  %3 = load void (%struct.arch_spinlock*)*, void (%struct.arch_spinlock*)** %cache_put, align 8, !tbaa !831
  call void @kref_put.956(%struct.arch_spinlock* %ref4, void (%struct.arch_spinlock*)* %3)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read.955(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !49
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put.956(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* %release) #2 {
entry:
  call void @kref_sub.957(%struct.arch_spinlock* %kref, i32 1, void (%struct.arch_spinlock*)* %release)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_sub.957(%struct.arch_spinlock* %kref, i32 %count, void (%struct.arch_spinlock*)* %release) #2 {
entry:
  %cmp = icmp eq void (%struct.arch_spinlock*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.23.1160, i32 0, i32 0), i32 71)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_sub_and_test.959(i32 %count, %struct.atomic_t* %refcount)
  %tobool14 = icmp ne i32 %call, 0
  br i1 %tobool14, label %if.then15, label %return

if.then15:                                        ; preds = %if.end
  call void %release(%struct.arch_spinlock* %kref)
  br label %return

return:                                           ; preds = %if.then15, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_sub_and_test.959(i32 %i, %struct.atomic_t* %v) #2 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subl $2,$0; sete $1", "=*m,=*qm,ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32 %i, i32* %counter) #7, !srcloc !977
  %0 = load i8, i8* %c, align 1, !tbaa !166
  %conv = zext i8 %0 to i32
  ret i32 %conv
}

declare i64 @_copy_to_user(i8*, i8*, i32) #4

declare i64 @seq_lseek(%struct.file*, i64, i32) #4

declare i64 @seq_read(%struct.file*, i8*, i64, i64*) #4

; Function Attrs: nounwind uwtable
define internal i32 @content_open_pipefs(%struct.inode* %inode, %struct.file* %filp) #0 {
entry:
  %call = call %struct.rpc_inode* @RPC_I(%struct.inode* %inode)
  %private = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call, i32 0, i32 1
  %0 = load i8*, i8** %private, align 8, !tbaa !941
  %1 = bitcast i8* %0 to %struct.cache_detail*
  %call1 = call i32 @content_open(%struct.file* %filp, %struct.cache_detail* %1)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @content_release_pipefs(%struct.inode* %inode, %struct.file* %filp) #0 {
entry:
  %call = call %struct.rpc_inode* @RPC_I(%struct.inode* %inode)
  %private = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call, i32 0, i32 1
  %0 = load i8*, i8** %private, align 8, !tbaa !941
  %1 = bitcast i8* %0 to %struct.cache_detail*
  %call1 = call i32 @content_release(%struct.inode* %inode, %struct.file* %filp, %struct.cache_detail* %1)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @content_release(%struct.inode* %inode, %struct.file* %file, %struct.cache_detail* %cd) #0 {
entry:
  %call = call i32 @seq_release_private(%struct.inode* %inode, %struct.file* %file)
  %owner = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 0
  %0 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !960
  call void @module_put(%struct.module* %0)
  ret i32 %call
}

declare i32 @seq_release_private(%struct.inode*, %struct.file*) #4

; Function Attrs: nounwind uwtable
define internal i32 @content_open(%struct.file* %file, %struct.cache_detail* %cd) #0 {
entry:
  %tobool = icmp ne %struct.cache_detail* %cd, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %owner = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 0
  %0 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !960
  %call = call zeroext i1 @try_module_get(%struct.module* %0)
  br i1 %call, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %call1 = call i8* @__seq_open_private(%struct.file* %file, %struct.seq_operations* @cache_content_op, i32 8)
  %1 = bitcast i8* %call1 to %struct.handle*
  %cmp = icmp eq %struct.handle* %1, null
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %owner3 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 0
  %2 = load %struct.module*, %struct.module** %owner3, align 8, !tbaa !960
  call void @module_put(%struct.module* %2)
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %cd5 = getelementptr inbounds %struct.handle, %struct.handle* %1, i32 0, i32 0
  store %struct.cache_detail* %cd, %struct.cache_detail** %cd5, align 8, !tbaa !978
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.then2, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ -12, %if.then2 ], [ 0, %if.end4 ], [ -13, %lor.lhs.false ], [ -13, %entry ]
  ret i32 %retval.0
}

declare i8* @__seq_open_private(%struct.file*, %struct.seq_operations*, i32) #4

; Function Attrs: nounwind uwtable
define internal i8* @c_start(%struct.seq_file* %m, i64* %pos) #0 {
entry:
  %0 = load i64, i64* %pos, align 8, !tbaa !291
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %m, i32 0, i32 10
  %1 = load i8*, i8** %private, align 8, !tbaa !980
  %2 = bitcast i8* %1 to %struct.handle*
  %cd2 = getelementptr inbounds %struct.handle, %struct.handle* %2, i32 0, i32 0
  %3 = load %struct.cache_detail*, %struct.cache_detail** %cd2, align 8, !tbaa !978
  %hash_lock = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %3, i32 0, i32 3
  call void @_raw_read_lock(%struct.rwlock_t* %hash_lock)
  %dec = add nsw i64 %0, -1
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %shr = ashr i64 %dec, 32
  %conv = trunc i64 %shr to i32
  %and = and i64 %dec, 4294967295
  %conv3 = trunc i64 %and to i32
  %hash_table = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %3, i32 0, i32 2
  %4 = load %struct.cache_head**, %struct.cache_head*** %hash_table, align 8, !tbaa !982
  %idxprom = zext i32 %conv to i64
  %arrayidx = getelementptr inbounds %struct.cache_head*, %struct.cache_head** %4, i64 %idxprom
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %next.sink = phi %struct.cache_head** [ %next, %for.inc ], [ %arrayidx, %if.end ]
  %entry1.0 = phi i32 [ %conv3, %if.end ], [ %dec5, %for.inc ]
  %5 = load %struct.cache_head*, %struct.cache_head** %next.sink, align 8, !tbaa !28
  %tobool4 = icmp ne %struct.cache_head* %5, null
  br i1 %tobool4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %dec5 = add i32 %entry1.0, -1
  %tobool6 = icmp ne i32 %entry1.0, 0
  br i1 %tobool6, label %for.inc, label %if.then7

if.then7:                                         ; preds = %for.body
  %6 = bitcast %struct.cache_head* %5 to i8*
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %next = getelementptr inbounds %struct.cache_head, %struct.cache_head* %5, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %and9 = and i64 %dec, -4294967296
  br label %do.body

do.body:                                          ; preds = %land.rhs, %for.end
  %hash.0 = phi i32 [ %conv, %for.end ], [ %inc, %land.rhs ]
  %n.0 = phi i64 [ %and9, %for.end ], [ %add, %land.rhs ]
  %inc = add i32 %hash.0, 1
  %add = add nsw i64 %n.0, 4294967296
  %hash_size = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %3, i32 0, i32 1
  %7 = load i32, i32* %hash_size, align 8, !tbaa !983
  %cmp = icmp ult i32 %inc, %7
  br i1 %cmp, label %land.rhs, label %do.end

land.rhs:                                         ; preds = %do.body
  %hash_table11 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %3, i32 0, i32 2
  %8 = load %struct.cache_head**, %struct.cache_head*** %hash_table11, align 8, !tbaa !982
  %idxprom12 = zext i32 %inc to i64
  %arrayidx13 = getelementptr inbounds %struct.cache_head*, %struct.cache_head** %8, i64 %idxprom12
  %9 = load %struct.cache_head*, %struct.cache_head** %arrayidx13, align 8, !tbaa !28
  %cmp14 = icmp eq %struct.cache_head* %9, null
  br i1 %cmp14, label %do.body, label %do.end

do.end:                                           ; preds = %land.rhs, %do.body
  %hash_size16 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %3, i32 0, i32 1
  %10 = load i32, i32* %hash_size16, align 8, !tbaa !983
  %cmp17 = icmp uge i32 %inc, %10
  br i1 %cmp17, label %cleanup, label %if.end20

if.end20:                                         ; preds = %do.end
  %add21 = add nsw i64 %add, 1
  store i64 %add21, i64* %pos, align 8, !tbaa !291
  %hash_table22 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %3, i32 0, i32 2
  %11 = load %struct.cache_head**, %struct.cache_head*** %hash_table22, align 8, !tbaa !982
  %idxprom23 = zext i32 %inc to i64
  %arrayidx24 = getelementptr inbounds %struct.cache_head*, %struct.cache_head** %11, i64 %idxprom23
  %12 = load %struct.cache_head*, %struct.cache_head** %arrayidx24, align 8, !tbaa !28
  %13 = bitcast %struct.cache_head* %12 to i8*
  br label %cleanup

cleanup:                                          ; preds = %if.end20, %do.end, %if.then7, %entry
  %retval.0 = phi i8* [ %6, %if.then7 ], [ %13, %if.end20 ], [ inttoptr (i64 1 to i8*), %entry ], [ null, %do.end ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @c_stop(%struct.seq_file* %m, i8* %p) #0 {
entry:
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %m, i32 0, i32 10
  %0 = load i8*, i8** %private, align 8, !tbaa !980
  %1 = bitcast i8* %0 to %struct.handle*
  %cd1 = getelementptr inbounds %struct.handle, %struct.handle* %1, i32 0, i32 0
  %2 = load %struct.cache_detail*, %struct.cache_detail** %cd1, align 8, !tbaa !978
  %hash_lock = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %2, i32 0, i32 3
  call void @_raw_read_unlock(%struct.rwlock_t* %hash_lock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @c_next(%struct.seq_file* %m, i8* %p, i64* %pos) #0 {
entry:
  %0 = bitcast i8* %p to %struct.cache_head*
  %1 = load i64, i64* %pos, align 8, !tbaa !291
  %shr = ashr i64 %1, 32
  %conv = trunc i64 %shr to i32
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %m, i32 0, i32 10
  %2 = load i8*, i8** %private, align 8, !tbaa !980
  %3 = bitcast i8* %2 to %struct.handle*
  %cd1 = getelementptr inbounds %struct.handle, %struct.handle* %3, i32 0, i32 0
  %4 = load %struct.cache_detail*, %struct.cache_detail** %cd1, align 8, !tbaa !978
  %cmp = icmp eq i8* %p, inttoptr (i64 1 to i8*)
  br i1 %cmp, label %if.end9, label %if.else

if.else:                                          ; preds = %entry
  %next = getelementptr inbounds %struct.cache_head, %struct.cache_head* %0, i32 0, i32 0
  %5 = load %struct.cache_head*, %struct.cache_head** %next, align 8, !tbaa !984
  %cmp3 = icmp eq %struct.cache_head* %5, null
  br i1 %cmp3, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else
  %inc = add nsw i32 %conv, 1
  %6 = load i64, i64* %pos, align 8, !tbaa !291
  %add = add nsw i64 %6, 4294967296
  store i64 %add, i64* %pos, align 8, !tbaa !291
  br label %if.end9

if.else6:                                         ; preds = %if.else
  %7 = load i64, i64* %pos, align 8, !tbaa !291
  %inc7 = add nsw i64 %7, 1
  store i64 %inc7, i64* %pos, align 8, !tbaa !291
  %next8 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %0, i32 0, i32 0
  br label %cleanup.sink.split

if.end9:                                          ; preds = %if.then5, %entry
  %hash.0 = phi i32 [ %inc, %if.then5 ], [ 0, %entry ]
  %8 = load i64, i64* %pos, align 8, !tbaa !291
  %and = and i64 %8, -4294967296
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end9
  %add15.sink = phi i64 [ %add15, %while.body ], [ %and, %if.end9 ]
  %hash.1 = phi i32 [ %hash.0, %if.end9 ], [ %inc14, %while.body ]
  store i64 %add15.sink, i64* %pos, align 8, !tbaa !291
  %hash_size = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %4, i32 0, i32 1
  %9 = load i32, i32* %hash_size, align 8, !tbaa !983
  %cmp10 = icmp slt i32 %hash.1, %9
  br i1 %cmp10, label %land.rhs, label %while.end

land.rhs:                                         ; preds = %while.cond
  %hash_table = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %4, i32 0, i32 2
  %10 = load %struct.cache_head**, %struct.cache_head*** %hash_table, align 8, !tbaa !982
  %idxprom = sext i32 %hash.1 to i64
  %arrayidx = getelementptr inbounds %struct.cache_head*, %struct.cache_head** %10, i64 %idxprom
  %11 = load %struct.cache_head*, %struct.cache_head** %arrayidx, align 8, !tbaa !28
  %cmp12 = icmp eq %struct.cache_head* %11, null
  br i1 %cmp12, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  %inc14 = add nsw i32 %hash.1, 1
  %12 = load i64, i64* %pos, align 8, !tbaa !291
  %add15 = add nsw i64 %12, 4294967296
  br label %while.cond

while.end:                                        ; preds = %land.rhs, %while.cond
  %hash_size16 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %4, i32 0, i32 1
  %13 = load i32, i32* %hash_size16, align 8, !tbaa !983
  %cmp17 = icmp sge i32 %hash.1, %13
  br i1 %cmp17, label %cleanup, label %if.end20

if.end20:                                         ; preds = %while.end
  %14 = load i64, i64* %pos, align 8, !tbaa !291
  %inc21 = add nsw i64 %14, 1
  store i64 %inc21, i64* %pos, align 8, !tbaa !291
  %hash_table22 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %4, i32 0, i32 2
  %15 = load %struct.cache_head**, %struct.cache_head*** %hash_table22, align 8, !tbaa !982
  %idxprom23 = sext i32 %hash.1 to i64
  %arrayidx24 = getelementptr inbounds %struct.cache_head*, %struct.cache_head** %15, i64 %idxprom23
  br label %cleanup.sink.split

cleanup.sink.split:                               ; preds = %if.end20, %if.else6
  %arrayidx24.sink = phi %struct.cache_head** [ %arrayidx24, %if.end20 ], [ %next8, %if.else6 ]
  %16 = load %struct.cache_head*, %struct.cache_head** %arrayidx24.sink, align 8, !tbaa !28
  %17 = bitcast %struct.cache_head* %16 to i8*
  br label %cleanup

cleanup:                                          ; preds = %cleanup.sink.split, %while.end
  %retval.0 = phi i8* [ null, %while.end ], [ %17, %cleanup.sink.split ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @c_show(%struct.seq_file* %m, i8* %p) #0 {
entry:
  %0 = bitcast i8* %p to %struct.cache_head*
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %m, i32 0, i32 10
  %1 = load i8*, i8** %private, align 8, !tbaa !980
  %2 = bitcast i8* %1 to %struct.handle*
  %cd1 = getelementptr inbounds %struct.handle, %struct.handle* %2, i32 0, i32 0
  %3 = load %struct.cache_detail*, %struct.cache_detail** %cd1, align 8, !tbaa !978
  %cmp = icmp eq i8* %p, inttoptr (i64 1 to i8*)
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %cache_show = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %3, i32 0, i32 10
  %4 = load i32 (%struct.seq_file*, %struct.cache_detail*, %struct.cache_head*)*, i32 (%struct.seq_file*, %struct.cache_detail*, %struct.cache_head*)** %cache_show, align 8, !tbaa !985
  %call = call i32 %4(%struct.seq_file* %m, %struct.cache_detail* %3, %struct.cache_head* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %5, 2048
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %if.end8

if.then4:                                         ; preds = %if.end
  %expiry_time = getelementptr inbounds %struct.cache_head, %struct.cache_head* %0, i32 0, i32 1
  %6 = load i64, i64* %expiry_time, align 8, !tbaa !828
  %call5 = call i64 @convert_to_wallclock(i64 %6)
  %ref = getelementptr inbounds %struct.cache_head, %struct.cache_head* %0, i32 0, i32 3
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %ref, i32 0, i32 0
  %call6 = call i32 @atomic_read.955(%struct.atomic_t* %refcount)
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %0, i32 0, i32 4
  %7 = load i64, i64* %flags, align 8, !tbaa !986
  %call7 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.28.960, i32 0, i32 0), i64 %call5, i32 %call6, i64 %7)
  br label %if.end8

if.end8:                                          ; preds = %if.then4, %if.end
  %call9 = call %struct.cache_head* @cache_get.961(%struct.cache_head* %0)
  %call10 = call i32 @cache_check(%struct.cache_detail* %3, %struct.cache_head* %0, %struct.cache_req* null)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end8
  %call13 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.29.964, i32 0, i32 0))
  br label %if.end19

if.else:                                          ; preds = %if.end8
  %call14 = call i32 @cache_is_expired(%struct.cache_detail* %3, %struct.cache_head* %0)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.else
  %call17 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.29.964, i32 0, i32 0))
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.else
  call void @cache_put.954(%struct.cache_head* %0, %struct.cache_detail* %3)
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %if.then12
  %cache_show20 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %3, i32 0, i32 10
  %8 = load i32 (%struct.seq_file*, %struct.cache_detail*, %struct.cache_head*)*, i32 (%struct.seq_file*, %struct.cache_detail*, %struct.cache_head*)** %cache_show20, align 8, !tbaa !985
  %call21 = call i32 %8(%struct.seq_file* %m, %struct.cache_detail* %3, %struct.cache_head* %0)
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %call21, %if.end19 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @convert_to_wallclock(i64 %sinceboot) #2 {
entry:
  %boot = alloca %struct.load_weight, align 8
  call void @getboottime(%struct.load_weight* %boot)
  %tv_sec = getelementptr inbounds %struct.load_weight, %struct.load_weight* %boot, i32 0, i32 0
  %0 = load i64, i64* %tv_sec, align 8, !tbaa !845
  %add = add nsw i64 %0, %sinceboot
  ret i64 %add
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.cache_head* @cache_get.961(%struct.cache_head* %h) #2 {
entry:
  %ref = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 3
  call void @kref_get.979(%struct.arch_spinlock* %ref)
  ret %struct.cache_head* %h
}

; Function Attrs: nounwind uwtable
define i32 @cache_check(%struct.cache_detail* %detail, %struct.cache_head* %h, %struct.cache_req* %rqstp) #0 {
entry:
  %call = call i32 @cache_is_valid(%struct.cache_head* %h)
  %expiry_time = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 1
  %0 = load i64, i64* %expiry_time, align 8, !tbaa !828
  %last_refresh = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 2
  %1 = load i64, i64* %last_refresh, align 8, !tbaa !987
  %sub = sub nsw i64 %0, %1
  %call1 = call i64 @seconds_since_boot()
  %last_refresh2 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 2
  %2 = load i64, i64* %last_refresh2, align 8, !tbaa !987
  %sub3 = sub nsw i64 %call1, %2
  %cmp = icmp eq %struct.cache_req* %rqstp, null
  %cmp4 = icmp eq i32 %call, -11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %.call = select i1 %cmp4, i32 -2, i32 %call
  br label %if.end24

if.else:                                          ; preds = %entry
  %div = sdiv i64 %sub, 2
  %cmp7 = icmp sgt i64 %sub3, %div
  %or.cond = or i1 %cmp4, %cmp7
  br i1 %or.cond, label %do.body, label %if.end24

do.body:                                          ; preds = %if.else
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %3, 2048
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot9 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then11, label %do.end

if.then11:                                        ; preds = %do.body
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then11, %do.body
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 4
  %call14 = call i32 @test_and_set_bit.966(i32 2, i64* %flags)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.end24, label %if.then16

if.then16:                                        ; preds = %do.end
  %call17 = call i32 @cache_make_upcall(%struct.cache_detail* %detail, %struct.cache_head* %h)
  %Pivot = icmp slt i32 %call17, -11
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.then16
  %SwitchLeaf2 = icmp eq i32 %call17, -11
  br i1 %SwitchLeaf2, label %sw.bb20, label %if.end24

LeafBlock:                                        ; preds = %if.then16
  %SwitchLeaf = icmp eq i32 %call17, -22
  br i1 %SwitchLeaf, label %sw.bb, label %if.end24

sw.bb:                                            ; preds = %LeafBlock
  %flags18 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 4
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags18, i32 2, i64* %flags18) #7, !srcloc !988
  call void @cache_revisit_request(%struct.cache_head* %h)
  %call19 = call i32 @try_to_negate_entry(%struct.cache_detail* %detail, %struct.cache_head* %h)
  br label %if.end24

sw.bb20:                                          ; preds = %LeafBlock1
  %flags21 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 4
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags21, i32 2, i64* %flags21) #7, !srcloc !988
  call void @cache_revisit_request(%struct.cache_head* %h)
  br label %if.end24

if.end24:                                         ; preds = %sw.bb20, %sw.bb, %LeafBlock, %LeafBlock1, %do.end, %if.else, %if.then
  %rv.4 = phi i32 [ %.call, %if.then ], [ %call, %if.else ], [ %call, %do.end ], [ %call19, %sw.bb ], [ %call, %sw.bb20 ], [ %call, %LeafBlock1 ], [ %call, %LeafBlock ]
  %cmp25 = icmp eq i32 %rv.4, -11
  br i1 %cmp25, label %if.then27, label %if.end36

if.then27:                                        ; preds = %if.end24
  %call28 = call zeroext i1 @cache_defer_req(%struct.cache_req* %rqstp, %struct.cache_head* %h)
  br i1 %call28, label %if.end36, label %if.then29

if.then29:                                        ; preds = %if.then27
  %call30 = call i32 @cache_is_valid(%struct.cache_head* %h)
  %cmp31 = icmp eq i32 %call30, -11
  %.call30 = select i1 %cmp31, i32 -110, i32 %call30
  br label %if.end36

if.end36:                                         ; preds = %if.then29, %if.then27, %if.end24
  %rv.7 = phi i32 [ %rv.4, %if.end24 ], [ %rv.4, %if.then27 ], [ %.call30, %if.then29 ]
  %tobool37 = icmp ne i32 %rv.7, 0
  br i1 %tobool37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.end36
  call void @cache_put.954(%struct.cache_head* %h, %struct.cache_detail* %detail)
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %if.end36
  ret i32 %rv.7
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @cache_is_expired(%struct.cache_detail* %detail, %struct.cache_head* %h) #2 {
entry:
  %expiry_time = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 1
  %0 = load i64, i64* %expiry_time, align 8, !tbaa !828
  %call = call i64 @seconds_since_boot()
  %cmp = icmp slt i64 %0, %call
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %flush_time = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 16
  %1 = load i64, i64* %flush_time, align 8, !tbaa !989
  %last_refresh = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 2
  %2 = load i64, i64* %last_refresh, align 8, !tbaa !987
  %cmp1 = icmp sgt i64 %1, %2
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  %lor.ext = zext i1 %3 to i32
  ret i32 %lor.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @cache_is_valid(%struct.cache_head* %h) #2 {
entry:
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 4
  %0 = load volatile i64, i64* %flags, align 8, !tbaa !88
  %and.i1 = and i64 1, %0
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool = icmp ne i32 %conv.i3, 0
  br i1 %tobool, label %cond.true4, label %return

cond.true4:                                       ; preds = %entry
  %flags5 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 4
  %1 = load volatile i64, i64* %flags5, align 8, !tbaa !88
  %and.i = and i64 2, %1
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool7 = icmp ne i32 %conv.i, 0
  br i1 %tobool7, label %return, label %if.else13

if.else13:                                        ; preds = %cond.true4
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !990
  br label %return

return:                                           ; preds = %if.else13, %cond.true4, %entry
  %retval.0 = phi i32 [ 0, %if.else13 ], [ -11, %entry ], [ -2, %cond.true4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_and_set_bit.966(i32 %nr, i64* %addr) #2 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !991
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @cache_make_upcall(%struct.cache_detail* %cd, %struct.cache_head* %h) #0 {
entry:
  %cache_upcall = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 7
  %0 = load i32 (%struct.cache_detail*, %struct.cache_head*)*, i32 (%struct.cache_detail*, %struct.cache_head*)** %cache_upcall, align 8, !tbaa !992
  %tobool = icmp ne i32 (%struct.cache_detail*, %struct.cache_head*)* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %cache_upcall1 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 7
  %1 = load i32 (%struct.cache_detail*, %struct.cache_head*)*, i32 (%struct.cache_detail*, %struct.cache_head*)** %cache_upcall1, align 8, !tbaa !992
  %call = call i32 %1(%struct.cache_detail* %cd, %struct.cache_head* %h)
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call i32 @sunrpc_cache_pipe_upcall(%struct.cache_detail* %cd, %struct.cache_head* %h)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %call2, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @cache_revisit_request(%struct.cache_head* %item) #0 {
entry:
  %pending = alloca %struct.list_head, align 8
  %0 = ptrtoint %struct.cache_head* %item to i64
  %shr = ashr i64 %0, 4
  %1 = ptrtoint %struct.cache_head* %item to i64
  %shr1 = ashr i64 %1, 13
  %xor = xor i64 %shr, %shr1
  %rem = urem i64 %xor, 256
  %conv = trunc i64 %rem to i32
  call void @INIT_LIST_HEAD.970(%struct.list_head* %pending)
  call void @spin_lock.935(%struct.spinlock* @cache_defer_lock)
  %idxprom = sext i32 %conv to i64
  %arrayidx = getelementptr inbounds [256 x %struct.hlist_head], [256 x %struct.hlist_head]* @cache_defer_hash, i64 0, i64 %idxprom
  %first = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %arrayidx, i32 0, i32 0
  %2 = load %struct.hlist_node*, %struct.hlist_node** %first, align 8, !tbaa !580
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %tmp.1.sink1 = phi %struct.hlist_node* [ %tmp.1, %for.inc ], [ %2, %entry ]
  %tmp.0 = phi %struct.hlist_node* [ undef, %entry ], [ %tmp.1, %for.inc ]
  %tobool12 = icmp ne %struct.hlist_node* %tmp.1.sink1, null
  %3 = bitcast %struct.hlist_node* %tmp.1.sink1 to i8*
  %add.ptr16 = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr16 to %struct.cache_deferred_req*
  %cond19 = select i1 %tobool12, %struct.cache_deferred_req* %4, %struct.cache_deferred_req* null
  %tobool4 = icmp ne %struct.cache_deferred_req* %cond19, null
  br i1 %tobool4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %hash5 = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %cond19, i32 0, i32 0
  %next = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %hash5, i32 0, i32 0
  %5 = load %struct.hlist_node*, %struct.hlist_node** %next, align 8, !tbaa !993
  %tobool7 = icmp ne i32 1, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %tmp.1 = phi %struct.hlist_node* [ %5, %land.rhs ], [ %tmp.0, %for.cond ]
  %6 = phi i1 [ false, %for.cond ], [ %tobool7, %land.rhs ]
  br i1 %6, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %item8 = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %cond19, i32 0, i32 2
  %7 = load %struct.cache_head*, %struct.cache_head** %item8, align 8, !tbaa !995
  %cmp = icmp eq %struct.cache_head* %7, %item
  br i1 %cmp, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @__unhash_deferred_req(%struct.cache_deferred_req* %cond19)
  %recent = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %cond19, i32 0, i32 1
  call void @list_add.941(%struct.list_head* %recent, %struct.list_head* %pending)
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  br label %for.cond

for.end:                                          ; preds = %land.end
  call void @spin_unlock.936(%struct.spinlock* @cache_defer_lock)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %call = call i32 @list_empty.968(%struct.list_head* %pending)
  %tobool20 = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool20, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %next22 = getelementptr inbounds %struct.list_head, %struct.list_head* %pending, i32 0, i32 0
  %8 = load %struct.list_head*, %struct.list_head** %next22, align 8, !tbaa !164
  %9 = bitcast %struct.list_head* %8 to i8*
  %add.ptr24 = getelementptr inbounds i8, i8* %9, i64 -16
  %10 = bitcast i8* %add.ptr24 to %struct.cache_deferred_req*
  %recent25 = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %10, i32 0, i32 1
  call void @list_del_init.969(%struct.list_head* %recent25)
  %revisit = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %10, i32 0, i32 4
  %11 = load void (%struct.cache_deferred_req*, i32)*, void (%struct.cache_deferred_req*, i32)** %revisit, align 8, !tbaa !996
  call void %11(%struct.cache_deferred_req* %10, i32 0)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @try_to_negate_entry(%struct.cache_detail* %detail, %struct.cache_head* %h) #0 {
entry:
  %hash_lock = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 3
  call void @_raw_write_lock(%struct.rwlock_t* %hash_lock)
  %call = call i32 @cache_is_valid(%struct.cache_head* %h)
  %cmp = icmp ne i32 %call, -11
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %hash_lock1 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 3
  call void @_raw_write_unlock(%struct.rwlock_t* %hash_lock1)
  br label %cleanup

if.end:                                           ; preds = %entry
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 4
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags, i32 1, i64* %flags) #7, !srcloc !997
  %call2 = call i64 @seconds_since_boot()
  %add = add nsw i64 %call2, 120
  call void @cache_fresh_locked(%struct.cache_head* %h, i64 %add)
  %hash_lock3 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 3
  call void @_raw_write_unlock(%struct.rwlock_t* %hash_lock3)
  call void @cache_fresh_unlocked(%struct.cache_head* %h, %struct.cache_detail* %detail)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ -2, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @cache_defer_req(%struct.cache_req* %req, %struct.cache_head* %item) #0 {
entry:
  %thread_wait = getelementptr inbounds %struct.cache_req, %struct.cache_req* %req, i32 0, i32 1
  %0 = load i32, i32* %thread_wait, align 8, !tbaa !998
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  call void @cache_wait_req(%struct.cache_req* %req, %struct.cache_head* %item)
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %item, i32 0, i32 4
  %1 = load volatile i64, i64* %flags, align 8, !tbaa !88
  %and.i1 = and i64 4, %1
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool1 = icmp ne i32 %conv.i3, 0
  br i1 %tobool1, label %if.end6, label %cleanup

if.end6:                                          ; preds = %if.then, %entry
  %defer = getelementptr inbounds %struct.cache_req, %struct.cache_req* %req, i32 0, i32 0
  %2 = load %struct.cache_deferred_req* (%struct.cache_req*)*, %struct.cache_deferred_req* (%struct.cache_req*)** %defer, align 8, !tbaa !999
  %call7 = call %struct.cache_deferred_req* %2(%struct.cache_req* %req)
  %cmp = icmp eq %struct.cache_deferred_req* %call7, null
  br i1 %cmp, label %cleanup, label %if.end9

if.end9:                                          ; preds = %if.end6
  call void @setup_deferral(%struct.cache_deferred_req* %call7, %struct.cache_head* %item, i32 1)
  %flags11 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %item, i32 0, i32 4
  %3 = load volatile i64, i64* %flags11, align 8, !tbaa !88
  %and.i = and i64 4, %3
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool13 = icmp ne i32 %conv.i, 0
  br i1 %tobool13, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end9
  call void @cache_revisit_request(%struct.cache_head* %item)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end9
  call void @cache_limit_defers()
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.end6, %if.then
  %retval.0 = phi i1 [ true, %if.end19 ], [ false, %if.then ], [ false, %if.end6 ]
  ret i1 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @cache_wait_req(%struct.cache_req* %req, %struct.cache_head* %item) #0 {
entry:
  %sleeper = alloca %struct.thread_deferred_req, align 8
  %handle = getelementptr inbounds %struct.thread_deferred_req, %struct.thread_deferred_req* %sleeper, i32 0, i32 0
  %completion = getelementptr inbounds %struct.thread_deferred_req, %struct.thread_deferred_req* %sleeper, i32 0, i32 1
  %completion1 = getelementptr inbounds %struct.thread_deferred_req, %struct.thread_deferred_req* %sleeper, i32 0, i32 1
  call void @init_completion(%struct.completion* %completion1)
  %completion2 = getelementptr inbounds %struct.thread_deferred_req, %struct.thread_deferred_req* %sleeper, i32 0, i32 1
  %0 = bitcast %struct.completion* %completion to i8*
  %1 = bitcast %struct.completion* %completion2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 96, i32 8, i1 false), !tbaa.struct !1000
  %revisit = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %handle, i32 0, i32 4
  store void (%struct.cache_deferred_req*, i32)* @cache_restart_thread, void (%struct.cache_deferred_req*, i32)** %revisit, align 8, !tbaa !996
  call void @setup_deferral(%struct.cache_deferred_req* %handle, %struct.cache_head* %item, i32 0)
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %item, i32 0, i32 4
  %2 = load volatile i64, i64* %flags, align 8, !tbaa !88
  %and.i = and i64 4, %2
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %completion6 = getelementptr inbounds %struct.thread_deferred_req, %struct.thread_deferred_req* %sleeper, i32 0, i32 1
  %thread_wait = getelementptr inbounds %struct.cache_req, %struct.cache_req* %req, i32 0, i32 1
  %3 = load i32, i32* %thread_wait, align 8, !tbaa !998
  %conv = sext i32 %3 to i64
  %call7 = call i64 @wait_for_completion_interruptible_timeout(%struct.completion* %completion6, i64 %conv)
  %cmp = icmp sle i64 %call7, 0
  br i1 %cmp, label %if.then, label %if.end15

if.then:                                          ; preds = %lor.lhs.false, %entry
  call void @spin_lock.935(%struct.spinlock* @cache_defer_lock)
  %handle9 = getelementptr inbounds %struct.thread_deferred_req, %struct.thread_deferred_req* %sleeper, i32 0, i32 0
  %hash = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %handle9, i32 0, i32 0
  %call10 = call i32 @hlist_unhashed(%struct.hlist_node* %hash)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.else, label %if.then12

if.then12:                                        ; preds = %if.then
  %handle13 = getelementptr inbounds %struct.thread_deferred_req, %struct.thread_deferred_req* %sleeper, i32 0, i32 0
  call void @__unhash_deferred_req(%struct.cache_deferred_req* %handle13)
  call void @spin_unlock.936(%struct.spinlock* @cache_defer_lock)
  br label %if.end15

if.else:                                          ; preds = %if.then
  call void @spin_unlock.936(%struct.spinlock* @cache_defer_lock)
  %completion14 = getelementptr inbounds %struct.thread_deferred_req, %struct.thread_deferred_req* %sleeper, i32 0, i32 1
  call void @wait_for_completion(%struct.completion* %completion14)
  br label %if.end15

if.end15:                                         ; preds = %if.else, %if.then12, %lor.lhs.false
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @setup_deferral(%struct.cache_deferred_req* %dreq, %struct.cache_head* %item, i32 %count_me) #0 {
entry:
  %item1 = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %dreq, i32 0, i32 2
  store %struct.cache_head* %item, %struct.cache_head** %item1, align 8, !tbaa !995
  call void @spin_lock.935(%struct.spinlock* @cache_defer_lock)
  call void @__hash_deferred_req(%struct.cache_deferred_req* %dreq, %struct.cache_head* %item)
  %tobool = icmp ne i32 %count_me, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = load i32, i32* @cache_defer_cnt, align 4, !tbaa !49
  %inc = add nsw i32 %0, 1
  store i32 %inc, i32* @cache_defer_cnt, align 4, !tbaa !49
  %recent = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %dreq, i32 0, i32 1
  call void @list_add.941(%struct.list_head* %recent, %struct.list_head* @cache_defer_list)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @spin_unlock.936(%struct.spinlock* @cache_defer_lock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @cache_limit_defers() #0 {
entry:
  %0 = load i32, i32* @cache_defer_cnt, align 4, !tbaa !49
  %cmp = icmp sle i32 %0, 300
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  call void @spin_lock.935(%struct.spinlock* @cache_defer_lock)
  %1 = load i32, i32* @cache_defer_cnt, align 4, !tbaa !49
  %cmp1 = icmp sgt i32 %1, 300
  br i1 %cmp1, label %if.then2, label %if.end8

if.then2:                                         ; preds = %if.end
  %call = call i32 @prandom_u32()
  %and = and i32 %call, 1
  %tobool = icmp ne i32 %and, 0
  %.sink = select i1 %tobool, %struct.list_head** getelementptr inbounds (%struct.list_head, %struct.list_head* @cache_defer_list, i32 0, i32 0), %struct.list_head** getelementptr inbounds (%struct.list_head, %struct.list_head* @cache_defer_list, i32 0, i32 1)
  %2 = load %struct.list_head*, %struct.list_head** %.sink, align 8, !tbaa !28
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr6 = getelementptr inbounds i8, i8* %3, i64 -16
  %4 = bitcast i8* %add.ptr6 to %struct.cache_deferred_req*
  call void @__unhash_deferred_req(%struct.cache_deferred_req* %4)
  br label %if.end8

if.end8:                                          ; preds = %if.then2, %if.end
  %discard.1 = phi %struct.cache_deferred_req* [ %4, %if.then2 ], [ null, %if.end ]
  call void @spin_unlock.936(%struct.spinlock* @cache_defer_lock)
  %tobool9 = icmp ne %struct.cache_deferred_req* %discard.1, null
  br i1 %tobool9, label %if.then10, label %cleanup.cont

if.then10:                                        ; preds = %if.end8
  %revisit = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %discard.1, i32 0, i32 4
  %5 = load void (%struct.cache_deferred_req*, i32)*, void (%struct.cache_deferred_req*, i32)** %revisit, align 8, !tbaa !996
  call void %5(%struct.cache_deferred_req* %discard.1, i32 1)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then10, %if.end8, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__unhash_deferred_req(%struct.cache_deferred_req* %dreq) #0 {
entry:
  %hash = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %dreq, i32 0, i32 0
  call void @hlist_del_init(%struct.hlist_node* %hash)
  %recent = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %dreq, i32 0, i32 1
  %call = call i32 @list_empty.968(%struct.list_head* %recent)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %recent1 = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %dreq, i32 0, i32 1
  call void @list_del_init.969(%struct.list_head* %recent1)
  %0 = load i32, i32* @cache_defer_cnt, align 4, !tbaa !49
  %dec = add nsw i32 %0, -1
  store i32 %dec, i32* @cache_defer_cnt, align 4, !tbaa !49
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @hlist_del_init(%struct.hlist_node* %n) #2 {
entry:
  %call = call i32 @hlist_unhashed(%struct.hlist_node* %n)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @__hlist_del.971(%struct.hlist_node* %n)
  call void @INIT_HLIST_NODE.972(%struct.hlist_node* %n)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty.968(%struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init.969(%struct.list_head* %entry1) #2 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD.970(%struct.list_head* %entry1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.970(%struct.list_head* %list) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !163
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hlist_unhashed(%struct.hlist_node* %h) #2 {
entry:
  %pprev = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %h, i32 0, i32 1
  %0 = load %struct.hlist_node**, %struct.hlist_node*** %pprev, align 8, !tbaa !566
  %tobool = icmp ne %struct.hlist_node** %0, null
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__hlist_del.971(%struct.hlist_node* %n) #2 {
entry:
  %next1 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 0
  %0 = load %struct.hlist_node*, %struct.hlist_node** %next1, align 8, !tbaa !567
  %pprev2 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 1
  %1 = load %struct.hlist_node**, %struct.hlist_node*** %pprev2, align 8, !tbaa !566
  store %struct.hlist_node* %0, %struct.hlist_node** %1, align 8, !tbaa !28
  %tobool = icmp ne %struct.hlist_node* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %pprev3 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %0, i32 0, i32 1
  store %struct.hlist_node** %1, %struct.hlist_node*** %pprev3, align 8, !tbaa !566
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_HLIST_NODE.972(%struct.hlist_node* %h) #2 {
entry:
  %next = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %h, i32 0, i32 0
  store %struct.hlist_node* null, %struct.hlist_node** %next, align 8, !tbaa !567
  %pprev = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %h, i32 0, i32 1
  store %struct.hlist_node** null, %struct.hlist_node*** %pprev, align 8, !tbaa !566
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__hash_deferred_req(%struct.cache_deferred_req* %dreq, %struct.cache_head* %item) #0 {
entry:
  %0 = ptrtoint %struct.cache_head* %item to i64
  %shr = ashr i64 %0, 4
  %1 = ptrtoint %struct.cache_head* %item to i64
  %shr1 = ashr i64 %1, 13
  %xor = xor i64 %shr, %shr1
  %rem = urem i64 %xor, 256
  %conv = trunc i64 %rem to i32
  %recent = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %dreq, i32 0, i32 1
  call void @INIT_LIST_HEAD.970(%struct.list_head* %recent)
  %hash2 = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %dreq, i32 0, i32 0
  %idxprom = sext i32 %conv to i64
  %arrayidx = getelementptr inbounds [256 x %struct.hlist_head], [256 x %struct.hlist_head]* @cache_defer_hash, i64 0, i64 %idxprom
  call void @hlist_add_head.974(%struct.hlist_node* %hash2, %struct.hlist_head* %arrayidx)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @hlist_add_head.974(%struct.hlist_node* %n, %struct.hlist_head* %h) #2 {
entry:
  %first1 = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %h, i32 0, i32 0
  %0 = load %struct.hlist_node*, %struct.hlist_node** %first1, align 8, !tbaa !580
  %next = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 0
  store %struct.hlist_node* %0, %struct.hlist_node** %next, align 8, !tbaa !567
  %tobool = icmp ne %struct.hlist_node* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %next2 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 0
  %pprev = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %0, i32 0, i32 1
  store %struct.hlist_node** %next2, %struct.hlist_node*** %pprev, align 8, !tbaa !566
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %first3 = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %h, i32 0, i32 0
  store %struct.hlist_node* %n, %struct.hlist_node** %first3, align 8, !tbaa !580
  %first4 = getelementptr inbounds %struct.hlist_head, %struct.hlist_head* %h, i32 0, i32 0
  %pprev5 = getelementptr inbounds %struct.hlist_node, %struct.hlist_node* %n, i32 0, i32 1
  store %struct.hlist_node** %first4, %struct.hlist_node*** %pprev5, align 8, !tbaa !566
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @init_completion(%struct.completion* %x) #2 {
entry:
  %done = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 0
  store i32 0, i32* %done, align 8, !tbaa !1001
  %wait = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 1
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wait, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.975, i32 0, i32 0), %struct.lock_class_key* @init_completion.__key)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @cache_restart_thread(%struct.cache_deferred_req* %dreq, i32 %too_many) #0 {
entry:
  %0 = bitcast %struct.cache_deferred_req* %dreq to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.thread_deferred_req*
  %completion = getelementptr inbounds %struct.thread_deferred_req, %struct.thread_deferred_req* %1, i32 0, i32 1
  call void @complete(%struct.completion* %completion)
  ret void
}

declare i64 @wait_for_completion_interruptible_timeout(%struct.completion*, i64) #4

declare void @wait_for_completion(%struct.completion*) #4

declare void @complete(%struct.completion*) #4

declare void @_raw_write_lock(%struct.rwlock_t*) #4 section ".spinlock.text"

declare void @_raw_write_unlock(%struct.rwlock_t*) #4 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal void @cache_fresh_locked(%struct.cache_head* %head, i64 %expiry) #0 {
entry:
  %expiry_time = getelementptr inbounds %struct.cache_head, %struct.cache_head* %head, i32 0, i32 1
  store i64 %expiry, i64* %expiry_time, align 8, !tbaa !828
  %call = call i64 @seconds_since_boot()
  %last_refresh = getelementptr inbounds %struct.cache_head, %struct.cache_head* %head, i32 0, i32 2
  store i64 %call, i64* %last_refresh, align 8, !tbaa !987
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !1002
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %head, i32 0, i32 4
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags, i32 0, i64* %flags) #7, !srcloc !997
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @cache_fresh_unlocked(%struct.cache_head* %head, %struct.cache_detail* %detail) #0 {
entry:
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %head, i32 0, i32 4
  %call = call i32 @test_and_clear_bit.977(i32 2, i64* %flags)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @cache_revisit_request(%struct.cache_head* %head)
  call void @cache_dequeue(%struct.cache_detail* %detail, %struct.cache_head* %head)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_and_clear_bit.977(i32 %nr, i64* %addr) #2 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !1003
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal void @cache_dequeue(%struct.cache_detail* %detail, %struct.cache_head* %ch) #0 {
entry:
  call void @spin_lock.935(%struct.spinlock* @queue_lock)
  %queue = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 20
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %list14.sink = phi %struct.list_head* [ %list14, %for.inc ], [ %queue, %entry ]
  %next15 = getelementptr inbounds %struct.list_head, %struct.list_head* %list14.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next15, align 8, !tbaa !28
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr17 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr17 to %struct.netdev_hw_addr_list*
  %list = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %2, i32 0, i32 0
  %queue1 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 20
  %cmp = icmp ne %struct.list_head* %list, %queue1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %reader = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %2, i32 0, i32 1
  %3 = load i32, i32* %reader, align 8, !tbaa !955
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %4 = bitcast %struct.netdev_hw_addr_list* %2 to i8*
  %add.ptr4 = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr4 to %struct.cache_request*
  %item = getelementptr inbounds %struct.cache_request, %struct.cache_request* %5, i32 0, i32 1
  %6 = load %struct.cache_head*, %struct.cache_head** %item, align 8, !tbaa !974
  %cmp5 = icmp ne %struct.cache_head* %6, %ch
  br i1 %cmp5, label %LeafBlock, label %if.end

if.end:                                           ; preds = %if.then
  %readers = getelementptr inbounds %struct.cache_request, %struct.cache_request* %5, i32 0, i32 4
  %7 = load i32, i32* %readers, align 4, !tbaa !956
  %cmp7 = icmp ne i32 %7, 0
  br i1 %cmp7, label %LeafBlock, label %if.end9

if.end9:                                          ; preds = %if.end
  %q = getelementptr inbounds %struct.cache_request, %struct.cache_request* %5, i32 0, i32 0
  %list10 = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q, i32 0, i32 0
  call void @list_del(%struct.list_head* %list10)
  call void @spin_unlock.936(%struct.spinlock* @queue_lock)
  %item11 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %5, i32 0, i32 1
  %8 = load %struct.cache_head*, %struct.cache_head** %item11, align 8, !tbaa !974
  call void @cache_put.954(%struct.cache_head* %8, %struct.cache_detail* %detail)
  %buf = getelementptr inbounds %struct.cache_request, %struct.cache_request* %5, i32 0, i32 2
  %9 = load i8*, i8** %buf, align 8, !tbaa !975
  call void @kfree(i8* %9)
  %10 = bitcast %struct.cache_request* %5 to i8*
  call void @kfree(i8* %10)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end9, %if.end, %if.then
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.end9 ], [ 4, %if.then ], [ 4, %if.end ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 4
  br i1 %SwitchLeaf, label %for.inc, label %cleanup.cont

for.inc:                                          ; preds = %LeafBlock, %for.body
  %list14 = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %2, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @spin_unlock.936(%struct.spinlock* @queue_lock)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %LeafBlock
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @sunrpc_cache_pipe_upcall(%struct.cache_detail* %detail, %struct.cache_head* %h) #0 {
entry:
  %cache_request = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 8
  %0 = load void (%struct.cache_detail*, %struct.cache_head*, i8**, i32*)*, void (%struct.cache_detail*, %struct.cache_head*, i8**, i32*)** %cache_request, align 8, !tbaa !976
  %tobool = icmp ne void (%struct.cache_detail*, %struct.cache_head*, i8**, i32*)* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call = call zeroext i1 @cache_listeners_exist(%struct.cache_detail* %detail)
  br i1 %call, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  call void @warn_no_listener(%struct.cache_detail* %detail)
  br label %cleanup

if.end2:                                          ; preds = %if.end
  %call.i1 = call i8* @__kmalloc(i64 4096, i32 208) #7
  %tobool4 = icmp ne i8* %call.i1, null
  br i1 %tobool4, label %if.end6, label %cleanup

if.end6:                                          ; preds = %if.end2
  %call.i = call i8* @__kmalloc(i64 48, i32 208) #7
  %1 = bitcast i8* %call.i to %struct.cache_request*
  %tobool8 = icmp ne %struct.cache_request* %1, null
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end6
  call void @kfree(i8* %call.i1)
  br label %cleanup

if.end10:                                         ; preds = %if.end6
  %q = getelementptr inbounds %struct.cache_request, %struct.cache_request* %1, i32 0, i32 0
  %reader = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q, i32 0, i32 1
  store i32 0, i32* %reader, align 8, !tbaa !973
  %call11 = call %struct.cache_head* @cache_get.961(%struct.cache_head* %h)
  %item = getelementptr inbounds %struct.cache_request, %struct.cache_request* %1, i32 0, i32 1
  store %struct.cache_head* %call11, %struct.cache_head** %item, align 8, !tbaa !974
  %buf12 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %1, i32 0, i32 2
  store i8* %call.i1, i8** %buf12, align 8, !tbaa !975
  %len = getelementptr inbounds %struct.cache_request, %struct.cache_request* %1, i32 0, i32 3
  store i32 0, i32* %len, align 8, !tbaa !966
  %readers = getelementptr inbounds %struct.cache_request, %struct.cache_request* %1, i32 0, i32 4
  store i32 0, i32* %readers, align 4, !tbaa !956
  call void @spin_lock.935(%struct.spinlock* @queue_lock)
  %q13 = getelementptr inbounds %struct.cache_request, %struct.cache_request* %1, i32 0, i32 0
  %list = getelementptr inbounds %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list* %q13, i32 0, i32 0
  %queue = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 20
  call void @list_add_tail.978(%struct.list_head* %list, %struct.list_head* %queue)
  call void @spin_unlock.936(%struct.spinlock* @queue_lock)
  call void @__wake_up(%struct.__wait_queue_head* @queue_wait, i32 3, i32 1, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.then9, %if.end2, %if.then1, %entry
  %retval.0 = phi i32 [ 0, %if.end10 ], [ -11, %if.then9 ], [ -22, %if.then1 ], [ -22, %entry ], [ -11, %if.end2 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @cache_listeners_exist(%struct.cache_detail* %detail) #0 {
entry:
  %readers = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 21
  %call = call i32 @atomic_read.955(%struct.atomic_t* %readers)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %last_close = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 22
  %0 = load i64, i64* %last_close, align 8, !tbaa !959
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %return, label %if.end2

if.end2:                                          ; preds = %if.end
  %last_close3 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 22
  %1 = load i64, i64* %last_close3, align 8, !tbaa !959
  %call4 = call i64 @seconds_since_boot()
  %sub = sub nsw i64 %call4, 30
  %cmp5 = icmp slt i64 %1, %sub
  %. = select i1 %cmp5, i1 false, i1 true
  br label %return

return:                                           ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i1 [ true, %entry ], [ false, %if.end ], [ %., %if.end2 ]
  ret i1 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @warn_no_listener(%struct.cache_detail* %detail) #0 {
entry:
  %last_warn = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 23
  %0 = load i64, i64* %last_warn, align 8, !tbaa !1004
  %last_close = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 22
  %1 = load i64, i64* %last_close, align 8, !tbaa !959
  %cmp = icmp ne i64 %0, %1
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %last_close1 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 22
  %2 = load i64, i64* %last_close1, align 8, !tbaa !959
  %last_warn2 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 23
  store i64 %2, i64* %last_warn2, align 8, !tbaa !1004
  %warn_no_listener = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 11
  %3 = load void (%struct.cache_detail*, i32)*, void (%struct.cache_detail*, i32)** %warn_no_listener, align 8, !tbaa !1005
  %tobool = icmp ne void (%struct.cache_detail*, i32)* %3, null
  br i1 %tobool, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.then
  %warn_no_listener4 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 11
  %4 = load void (%struct.cache_detail*, i32)*, void (%struct.cache_detail*, i32)** %warn_no_listener4, align 8, !tbaa !1005
  %last_close5 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 22
  %5 = load i64, i64* %last_close5, align 8, !tbaa !959
  %cmp6 = icmp ne i64 %5, 0
  %conv = zext i1 %cmp6 to i32
  call void %4(%struct.cache_detail* %detail, i32 %conv)
  br label %if.end7

if.end7:                                          ; preds = %if.then3, %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.978(%struct.list_head* %new, %struct.list_head* %head) #2 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !163
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_get.979(%struct.arch_spinlock* %kref) #2 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_add_return.980(i32 1, %struct.atomic_t* %refcount)
  %cmp = icmp slt i32 %call, 2
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  %0 = load i8, i8* @kref_get.__warned.981, align 1, !tbaa !29, !range !31
  %tobool7 = trunc i8 %0 to i1
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %tobool14 = icmp ne i32 %lnot.ext13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.23.1160, i32 0, i32 0), i32 47)
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then
  %tobool23 = icmp ne i32 %lnot.ext13, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end
  store i8 1, i8* @kref_get.__warned.981, align 1, !tbaa !29
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_return.980(i32 %i, %struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #7, !srcloc !1006
  %add = add nsw i32 %i, %0
  ret i32 %add
}

declare void @_raw_read_unlock(%struct.rwlock_t*) #4 section ".spinlock.text"

declare void @_raw_read_lock(%struct.rwlock_t*) #4 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal i64 @read_flush_pipefs(%struct.file* %filp, i8* %buf, i64 %count, i64* %ppos) #0 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %filp)
  %call1 = call %struct.rpc_inode* @RPC_I(%struct.inode* %call)
  %private = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call1, i32 0, i32 1
  %0 = load i8*, i8** %private, align 8, !tbaa !941
  %1 = bitcast i8* %0 to %struct.cache_detail*
  %call2 = call i64 @read_flush(i8* %buf, i64 %count, i64* %ppos, %struct.cache_detail* %1)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define internal i64 @write_flush_pipefs(%struct.file* %filp, i8* %buf, i64 %count, i64* %ppos) #0 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %filp)
  %call1 = call %struct.rpc_inode* @RPC_I(%struct.inode* %call)
  %private = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call1, i32 0, i32 1
  %0 = load i8*, i8** %private, align 8, !tbaa !941
  %1 = bitcast i8* %0 to %struct.cache_detail*
  %call2 = call i64 @write_flush(i8* %buf, i64 %count, i64* %ppos, %struct.cache_detail* %1)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @open_flush_pipefs(%struct.inode* %inode, %struct.file* %filp) #0 {
entry:
  %call = call %struct.rpc_inode* @RPC_I(%struct.inode* %inode)
  %private = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call, i32 0, i32 1
  %0 = load i8*, i8** %private, align 8, !tbaa !941
  %1 = bitcast i8* %0 to %struct.cache_detail*
  %call1 = call i32 @open_flush(%struct.inode* %inode, %struct.file* %filp, %struct.cache_detail* %1)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @release_flush_pipefs(%struct.inode* %inode, %struct.file* %filp) #0 {
entry:
  %call = call %struct.rpc_inode* @RPC_I(%struct.inode* %inode)
  %private = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call, i32 0, i32 1
  %0 = load i8*, i8** %private, align 8, !tbaa !941
  %1 = bitcast i8* %0 to %struct.cache_detail*
  %call1 = call i32 @release_flush(%struct.cache_detail* %1)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @release_flush(%struct.cache_detail* %cd) #0 {
entry:
  %owner = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 0
  %0 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !960
  call void @module_put(%struct.module* %0)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @open_flush(%struct.inode* %inode, %struct.file* %file, %struct.cache_detail* %cd) #0 {
entry:
  %tobool = icmp ne %struct.cache_detail* %cd, null
  br i1 %tobool, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %entry
  %owner = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 0
  %0 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !960
  %call = call zeroext i1 @try_module_get(%struct.module* %0)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  %call1 = call i32 @nonseekable_open(%struct.inode* %inode, %struct.file* %file)
  br label %return

return:                                           ; preds = %if.end, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ %call1, %if.end ], [ -13, %lor.lhs.false ], [ -13, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @write_flush(i8* %buf, i64 %count, i64* %ppos, %struct.cache_detail* %cd) #0 {
entry:
  %tbuf = alloca [20 x i8], align 16
  %bp = alloca i8*, align 8
  %ep = alloca i8*, align 8
  %0 = load i64, i64* %ppos, align 8, !tbaa !291
  %tobool = icmp ne i64 %0, 0
  %cmp = icmp ugt i64 %count, 19
  %or.cond = or i1 %tobool, %cmp
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %tbuf, i32 0, i32 0
  %call = call i64 @copy_from_user(i8* %arraydecay, i8* %buf, i64 %count)
  %tobool1 = icmp ne i64 %call, 0
  br i1 %tobool1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %arrayidx = getelementptr inbounds [20 x i8], [20 x i8]* %tbuf, i64 0, i64 %count
  store i8 0, i8* %arrayidx, align 1, !tbaa !166
  %arraydecay4 = getelementptr inbounds [20 x i8], [20 x i8]* %tbuf, i32 0, i32 0
  %call5 = call i64 @simple_strtoul(i8* %arraydecay4, i8** %ep, i32 0)
  %1 = load i8*, i8** %ep, align 8, !tbaa !28
  %2 = load i8, i8* %1, align 1, !tbaa !166
  %conv = sext i8 %2 to i32
  %tobool6 = icmp ne i32 %conv, 0
  br i1 %tobool6, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %if.end3
  %3 = load i8*, i8** %ep, align 8, !tbaa !28
  %4 = load i8, i8* %3, align 1, !tbaa !166
  %conv7 = sext i8 %4 to i32
  %cmp8 = icmp ne i32 %conv7, 10
  br i1 %cmp8, label %cleanup, label %if.end11

if.end11:                                         ; preds = %land.lhs.true, %if.end3
  %arraydecay12 = getelementptr inbounds [20 x i8], [20 x i8]* %tbuf, i32 0, i32 0
  store i8* %arraydecay12, i8** %bp, align 8, !tbaa !28
  %call13 = call i64 @get_expiry.982(i8** %bp)
  %flush_time = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 16
  store i64 %call13, i64* %flush_time, align 8, !tbaa !989
  %call14 = call i64 @seconds_since_boot()
  %nextcheck = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 18
  store i64 %call14, i64* %nextcheck, align 8, !tbaa !829
  call void @cache_flush()
  %5 = load i64, i64* %ppos, align 8, !tbaa !291
  %add = add i64 %5, %count
  store i64 %add, i64* %ppos, align 8, !tbaa !291
  br label %cleanup

cleanup:                                          ; preds = %if.end11, %land.lhs.true, %if.end, %entry
  %retval.0 = phi i64 [ %count, %if.end11 ], [ -22, %entry ], [ -14, %if.end ], [ -22, %land.lhs.true ]
  ret i64 %retval.0
}

declare i64 @simple_strtoul(i8*, i8**, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @get_expiry.982(i8** %bpp) #2 {
entry:
  %rv = alloca i32, align 4
  %boot = alloca %struct.load_weight, align 8
  %call = call i32 @get_int.986(i8** %bpp, i32* %rv)
  %tobool = icmp ne i32 %call, 0
  %0 = load i32, i32* %rv, align 4
  %cmp = icmp slt i32 %0, 0
  %or.cond = or i1 %tobool, %cmp
  br i1 %or.cond, label %cleanup, label %if.end2

if.end2:                                          ; preds = %entry
  call void @getboottime(%struct.load_weight* %boot)
  %1 = load i32, i32* %rv, align 4, !tbaa !49
  %conv = sext i32 %1 to i64
  %tv_sec = getelementptr inbounds %struct.load_weight, %struct.load_weight* %boot, i32 0, i32 0
  %2 = load i64, i64* %tv_sec, align 8, !tbaa !845
  %sub = sub nsw i64 %conv, %2
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %entry
  %retval.0 = phi i64 [ %sub, %if.end2 ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define void @cache_flush() #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call i32 @cache_clean()
  %cmp = icmp ne i32 %call, -1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @__might_sleep(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.952, i32 0, i32 0), i32 496, i32 0)
  %call1 = call i32 @_cond_resched()
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %while.cond2

while.cond2:                                      ; preds = %while.body5, %while.end
  %call3 = call i32 @cache_clean()
  %cmp4 = icmp ne i32 %call3, -1
  br i1 %cmp4, label %while.body5, label %while.end8

while.body5:                                      ; preds = %while.cond2
  call void @__might_sleep(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.952, i32 0, i32 0), i32 498, i32 0)
  %call7 = call i32 @_cond_resched()
  br label %while.cond2

while.end8:                                       ; preds = %while.cond2
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @cache_clean() #0 {
entry:
  call void @spin_lock.935(%struct.spinlock* @cache_list_lock)
  br label %while.cond

while.cond:                                       ; preds = %if.end12, %entry
  %0 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %cmp = icmp eq %struct.cache_detail* %0, null
  br i1 %cmp, label %while.body, label %lor.rhs

lor.rhs:                                          ; preds = %while.cond
  %1 = load i32, i32* @current_index, align 4, !tbaa !49
  %2 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %hash_size = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %2, i32 0, i32 1
  %3 = load i32, i32* %hash_size, align 8, !tbaa !983
  %cmp1 = icmp sge i32 %1, %3
  br i1 %cmp1, label %while.body, label %while.end

while.body:                                       ; preds = %lor.rhs, %while.cond
  %4 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %tobool = icmp ne %struct.cache_detail* %4, null
  %5 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8
  %others = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %5, i32 0, i32 17
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %others, i32 0, i32 0
  %.sink = select i1 %tobool, %struct.list_head** %next2, %struct.list_head** getelementptr inbounds (%struct.list_head, %struct.list_head* @cache_list, i32 0, i32 0)
  %6 = load %struct.list_head*, %struct.list_head** %.sink, align 8, !tbaa !28
  %cmp3 = icmp eq %struct.list_head* %6, @cache_list
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %while.body
  store %struct.cache_detail* null, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  call void @spin_unlock.936(%struct.spinlock* @cache_list_lock)
  br label %cleanup

if.end5:                                          ; preds = %while.body
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 -200
  %8 = bitcast i8* %add.ptr to %struct.cache_detail*
  store %struct.cache_detail* %8, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %9 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %nextcheck = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %9, i32 0, i32 18
  %10 = load i64, i64* %nextcheck, align 8, !tbaa !829
  %call = call i64 @seconds_since_boot()
  %cmp6 = icmp sgt i64 %10, %call
  br i1 %cmp6, label %if.then7, label %if.else9

if.then7:                                         ; preds = %if.end5
  %11 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %hash_size8 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %11, i32 0, i32 1
  %12 = load i32, i32* %hash_size8, align 8, !tbaa !983
  store i32 %12, i32* @current_index, align 4, !tbaa !49
  br label %if.end12

if.else9:                                         ; preds = %if.end5
  store i32 0, i32* @current_index, align 4, !tbaa !49
  %call10 = call i64 @seconds_since_boot()
  %add = add nsw i64 %call10, 1800
  %13 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %nextcheck11 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %13, i32 0, i32 18
  store i64 %add, i64* %nextcheck11, align 8, !tbaa !829
  br label %if.end12

if.end12:                                         ; preds = %if.else9, %if.then7
  br label %while.cond

while.end:                                        ; preds = %lor.rhs
  br label %while.cond13

while.cond13:                                     ; preds = %while.body18, %while.end
  %14 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %tobool14 = icmp ne %struct.cache_detail* %14, null
  br i1 %tobool14, label %land.lhs.true, label %while.end19

land.lhs.true:                                    ; preds = %while.cond13
  %15 = load i32, i32* @current_index, align 4, !tbaa !49
  %16 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %hash_size15 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %16, i32 0, i32 1
  %17 = load i32, i32* %hash_size15, align 8, !tbaa !983
  %cmp16 = icmp slt i32 %15, %17
  br i1 %cmp16, label %land.rhs, label %while.end19

land.rhs:                                         ; preds = %land.lhs.true
  %18 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %hash_table = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %18, i32 0, i32 2
  %19 = load %struct.cache_head**, %struct.cache_head*** %hash_table, align 8, !tbaa !982
  %20 = load i32, i32* @current_index, align 4, !tbaa !49
  %idxprom = sext i32 %20 to i64
  %arrayidx = getelementptr inbounds %struct.cache_head*, %struct.cache_head** %19, i64 %idxprom
  %21 = load %struct.cache_head*, %struct.cache_head** %arrayidx, align 8, !tbaa !28
  %cmp17 = icmp eq %struct.cache_head* %21, null
  br i1 %cmp17, label %while.body18, label %while.end19

while.body18:                                     ; preds = %land.rhs
  %22 = load i32, i32* @current_index, align 4, !tbaa !49
  %inc = add nsw i32 %22, 1
  store i32 %inc, i32* @current_index, align 4, !tbaa !49
  br label %while.cond13

while.end19:                                      ; preds = %land.rhs, %land.lhs.true, %while.cond13
  %23 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %tobool20 = icmp ne %struct.cache_detail* %23, null
  br i1 %tobool20, label %land.lhs.true21, label %if.else55

land.lhs.true21:                                  ; preds = %while.end19
  %24 = load i32, i32* @current_index, align 4, !tbaa !49
  %25 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %hash_size22 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %25, i32 0, i32 1
  %26 = load i32, i32* %hash_size22, align 8, !tbaa !983
  %cmp23 = icmp slt i32 %24, %26
  br i1 %cmp23, label %if.then24, label %if.else55

if.then24:                                        ; preds = %land.lhs.true21
  %27 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %hash_lock = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %27, i32 0, i32 3
  call void @_raw_write_lock(%struct.rwlock_t* %hash_lock)
  %28 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %hash_table25 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %28, i32 0, i32 2
  %29 = load %struct.cache_head**, %struct.cache_head*** %hash_table25, align 8, !tbaa !982
  %30 = load i32, i32* @current_index, align 4, !tbaa !49
  %idxprom26 = sext i32 %30 to i64
  %arrayidx27 = getelementptr inbounds %struct.cache_head*, %struct.cache_head** %29, i64 %idxprom26
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then24
  %next42.sink = phi %struct.cache_head** [ %next40, %for.inc ], [ %arrayidx27, %if.then24 ]
  %cp.0 = phi %struct.cache_head** [ %arrayidx27, %if.then24 ], [ %next40, %for.inc ]
  %31 = load %struct.cache_head*, %struct.cache_head** %next42.sink, align 8, !tbaa !28
  %tobool28 = icmp ne %struct.cache_head* %31, null
  br i1 %tobool28, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %32 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %nextcheck29 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %32, i32 0, i32 18
  %33 = load i64, i64* %nextcheck29, align 8, !tbaa !829
  %expiry_time = getelementptr inbounds %struct.cache_head, %struct.cache_head* %31, i32 0, i32 1
  %34 = load i64, i64* %expiry_time, align 8, !tbaa !828
  %cmp30 = icmp sgt i64 %33, %34
  br i1 %cmp30, label %if.then31, label %if.end35

if.then31:                                        ; preds = %for.body
  %expiry_time32 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %31, i32 0, i32 1
  %35 = load i64, i64* %expiry_time32, align 8, !tbaa !828
  %add33 = add nsw i64 %35, 1
  %36 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %nextcheck34 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %36, i32 0, i32 18
  store i64 %add33, i64* %nextcheck34, align 8, !tbaa !829
  br label %if.end35

if.end35:                                         ; preds = %if.then31, %for.body
  %37 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %call36 = call i32 @cache_is_expired(%struct.cache_detail* %37, %struct.cache_head* %31)
  %tobool37 = icmp ne i32 %call36, 0
  %next40 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %31, i32 0, i32 0
  br i1 %tobool37, label %if.end39, label %for.inc

if.end39:                                         ; preds = %if.end35
  %38 = load %struct.cache_head*, %struct.cache_head** %next40, align 8, !tbaa !984
  store %struct.cache_head* %38, %struct.cache_head** %cp.0, align 8, !tbaa !28
  %next41 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %31, i32 0, i32 0
  store %struct.cache_head* null, %struct.cache_head** %next41, align 8, !tbaa !984
  %39 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %entries = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %39, i32 0, i32 19
  %40 = load i32, i32* %entries, align 8, !tbaa !1007
  %dec = add nsw i32 %40, -1
  store i32 %dec, i32* %entries, align 8, !tbaa !1007
  br label %for.end

for.inc:                                          ; preds = %if.end35
  br label %for.cond

for.end:                                          ; preds = %if.end39, %for.cond
  %rv.0 = phi i32 [ 1, %if.end39 ], [ 0, %for.cond ]
  %41 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %hash_lock43 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %41, i32 0, i32 3
  call void @_raw_write_unlock(%struct.rwlock_t* %hash_lock43)
  %42 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %tobool44 = icmp ne %struct.cache_head* %31, null
  br i1 %tobool44, label %if.end47, label %if.then45

if.then45:                                        ; preds = %for.end
  %43 = load i32, i32* @current_index, align 4, !tbaa !49
  %inc46 = add nsw i32 %43, 1
  store i32 %inc46, i32* @current_index, align 4, !tbaa !49
  br label %if.end47

if.end47:                                         ; preds = %if.then45, %for.end
  call void @spin_unlock.936(%struct.spinlock* @cache_list_lock)
  %tobool48 = icmp ne %struct.cache_head* %31, null
  br i1 %tobool48, label %if.then49, label %cleanup

if.then49:                                        ; preds = %if.end47
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %31, i32 0, i32 4
  %call50 = call i32 @test_and_clear_bit.977(i32 2, i64* %flags)
  %tobool51 = icmp ne i32 %call50, 0
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.then49
  %44 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  call void @cache_dequeue(%struct.cache_detail* %44, %struct.cache_head* %31)
  br label %if.end53

if.end53:                                         ; preds = %if.then52, %if.then49
  call void @cache_revisit_request(%struct.cache_head* %31)
  call void @cache_put.954(%struct.cache_head* %31, %struct.cache_detail* %42)
  br label %cleanup

if.else55:                                        ; preds = %land.lhs.true21, %while.end19
  call void @spin_unlock.936(%struct.spinlock* @cache_list_lock)
  br label %cleanup

cleanup:                                          ; preds = %if.else55, %if.end53, %if.end47, %if.then4
  %retval.0 = phi i32 [ -1, %if.then4 ], [ 0, %if.else55 ], [ %rv.0, %if.end53 ], [ %rv.0, %if.end47 ]
  ret i32 %retval.0
}

declare i32 @_cond_resched() #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @get_int.986(i8** %bpp, i32* %anint) #2 {
entry:
  %buf = alloca [50 x i8], align 16
  %ep = alloca i8*, align 8
  %arraydecay = getelementptr inbounds [50 x i8], [50 x i8]* %buf, i32 0, i32 0
  %call = call i32 @qword_get(i8** %bpp, i8* %arraydecay, i32 50)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp eq i32 %call, 0
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %arraydecay4 = getelementptr inbounds [50 x i8], [50 x i8]* %buf, i32 0, i32 0
  %call5 = call i64 @simple_strtol(i8* %arraydecay4, i8** %ep, i32 0)
  %conv = trunc i64 %call5 to i32
  %0 = load i8*, i8** %ep, align 8, !tbaa !28
  %1 = load i8, i8* %0, align 1, !tbaa !166
  %tobool = icmp ne i8 %1, 0
  br i1 %tobool, label %cleanup, label %if.end7

if.end7:                                          ; preds = %if.end3
  store i32 %conv, i32* %anint, align 4, !tbaa !49
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %if.end3, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end7 ], [ -22, %entry ], [ -2, %if.end ], [ -22, %if.end3 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @qword_get(i8** %bpp, i8* %dest, i32 %bufsize) #0 {
entry:
  %0 = load i8*, i8** %bpp, align 8, !tbaa !28
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %bp.0 = phi i8* [ %0, %entry ], [ %incdec.ptr, %while.body ]
  %1 = load i8, i8* %bp.0, align 1, !tbaa !166
  %conv = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 32
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %incdec.ptr = getelementptr inbounds i8, i8* %bp.0, i32 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %arrayidx = getelementptr inbounds i8, i8* %bp.0, i64 0
  %2 = load i8, i8* %arrayidx, align 1, !tbaa !166
  %conv2 = sext i8 %2 to i32
  %cmp3 = icmp eq i32 %conv2, 92
  br i1 %cmp3, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %while.end
  %arrayidx5 = getelementptr inbounds i8, i8* %bp.0, i64 1
  %3 = load i8, i8* %arrayidx5, align 1, !tbaa !166
  %conv6 = sext i8 %3 to i32
  %cmp7 = icmp eq i32 %conv6, 120
  br i1 %cmp7, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %add.ptr = getelementptr inbounds i8, i8* %bp.0, i64 2
  br label %while.cond9

while.cond9:                                      ; preds = %cleanup.cont, %if.then
  %bp.1 = phi i8* [ %add.ptr, %if.then ], [ %bp.2, %cleanup.cont ]
  %len.0 = phi i32 [ 0, %if.then ], [ %len.1, %cleanup.cont ]
  %dest.addr.0 = phi i8* [ %dest, %if.then ], [ %dest.addr.1, %cleanup.cont ]
  %cmp10 = icmp slt i32 %len.0, %bufsize
  br i1 %cmp10, label %while.body12, label %if.end85

while.body12:                                     ; preds = %while.cond9
  %arrayidx13 = getelementptr inbounds i8, i8* %bp.1, i64 0
  %4 = load i8, i8* %arrayidx13, align 1, !tbaa !166
  %call = call i32 @hex_to_bin(i8 signext %4)
  %cmp14 = icmp slt i32 %call, 0
  br i1 %cmp14, label %LeafBlock, label %if.end

if.end:                                           ; preds = %while.body12
  %arrayidx17 = getelementptr inbounds i8, i8* %bp.1, i64 1
  %5 = load i8, i8* %arrayidx17, align 1, !tbaa !166
  %call18 = call i32 @hex_to_bin(i8 signext %5)
  %cmp19 = icmp slt i32 %call18, 0
  br i1 %cmp19, label %LeafBlock, label %if.end22

if.end22:                                         ; preds = %if.end
  %shl = shl i32 %call, 4
  %or = or i32 %shl, %call18
  %conv23 = trunc i32 %or to i8
  %incdec.ptr24 = getelementptr inbounds i8, i8* %dest.addr.0, i32 1
  store i8 %conv23, i8* %dest.addr.0, align 1, !tbaa !166
  %add.ptr25 = getelementptr inbounds i8, i8* %bp.1, i64 2
  %inc = add nsw i32 %len.0, 1
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end22, %if.end, %while.body12
  %bp.2 = phi i8* [ %add.ptr25, %if.end22 ], [ %bp.1, %while.body12 ], [ %bp.1, %if.end ]
  %len.1 = phi i32 [ %inc, %if.end22 ], [ %len.0, %while.body12 ], [ %len.0, %if.end ]
  %dest.addr.1 = phi i8* [ %incdec.ptr24, %if.end22 ], [ %dest.addr.0, %while.body12 ], [ %dest.addr.0, %if.end ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end22 ], [ 5, %while.body12 ], [ 5, %if.end ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 5
  br i1 %SwitchLeaf, label %if.end85, label %cleanup.cont

cleanup.cont:                                     ; preds = %LeafBlock
  br label %while.cond9

if.else:                                          ; preds = %land.lhs.true, %while.end
  br label %while.cond28

while.cond28:                                     ; preds = %if.end83, %if.else
  %bp.4 = phi i8* [ %bp.0, %if.else ], [ %bp.5, %if.end83 ]
  %len.3 = phi i32 [ 0, %if.else ], [ %inc82, %if.end83 ]
  %dest.addr.3 = phi i8* [ %dest, %if.else ], [ %incdec.ptr81, %if.end83 ]
  %6 = load i8, i8* %bp.4, align 1, !tbaa !166
  %conv29 = sext i8 %6 to i32
  %cmp30 = icmp ne i32 %conv29, 32
  br i1 %cmp30, label %land.lhs.true32, label %if.end85

land.lhs.true32:                                  ; preds = %while.cond28
  %7 = load i8, i8* %bp.4, align 1, !tbaa !166
  %conv33 = sext i8 %7 to i32
  %cmp34 = icmp ne i32 %conv33, 10
  br i1 %cmp34, label %land.lhs.true36, label %if.end85

land.lhs.true36:                                  ; preds = %land.lhs.true32
  %8 = load i8, i8* %bp.4, align 1, !tbaa !166
  %conv37 = sext i8 %8 to i32
  %tobool = icmp ne i32 %conv37, 0
  %sub = sub nsw i32 %bufsize, 1
  %cmp38 = icmp slt i32 %len.3, %sub
  %or.cond = and i1 %tobool, %cmp38
  br i1 %or.cond, label %while.body40, label %if.end85

while.body40:                                     ; preds = %land.lhs.true36
  %9 = load i8, i8* %bp.4, align 1, !tbaa !166
  %conv41 = sext i8 %9 to i32
  %cmp42 = icmp eq i32 %conv41, 92
  br i1 %cmp42, label %land.lhs.true44, label %if.else79

land.lhs.true44:                                  ; preds = %while.body40
  %arrayidx45 = getelementptr inbounds i8, i8* %bp.4, i64 1
  %10 = load i8, i8* %arrayidx45, align 1, !tbaa !166
  %call46 = call i32 @isodigit(i8 signext %10)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %land.lhs.true48, label %if.else79

land.lhs.true48:                                  ; preds = %land.lhs.true44
  %arrayidx49 = getelementptr inbounds i8, i8* %bp.4, i64 1
  %11 = load i8, i8* %arrayidx49, align 1, !tbaa !166
  %conv50 = sext i8 %11 to i32
  %cmp51 = icmp sle i32 %conv50, 51
  br i1 %cmp51, label %land.lhs.true53, label %if.else79

land.lhs.true53:                                  ; preds = %land.lhs.true48
  %arrayidx54 = getelementptr inbounds i8, i8* %bp.4, i64 2
  %12 = load i8, i8* %arrayidx54, align 1, !tbaa !166
  %call55 = call i32 @isodigit(i8 signext %12)
  %tobool56 = icmp ne i32 %call55, 0
  br i1 %tobool56, label %land.lhs.true57, label %if.else79

land.lhs.true57:                                  ; preds = %land.lhs.true53
  %arrayidx58 = getelementptr inbounds i8, i8* %bp.4, i64 3
  %13 = load i8, i8* %arrayidx58, align 1, !tbaa !166
  %call59 = call i32 @isodigit(i8 signext %13)
  %tobool60 = icmp ne i32 %call59, 0
  br i1 %tobool60, label %if.then61, label %if.else79

if.then61:                                        ; preds = %land.lhs.true57
  %incdec.ptr62 = getelementptr inbounds i8, i8* %bp.4, i32 1
  %14 = load i8, i8* %incdec.ptr62, align 1, !tbaa !166
  %conv63 = sext i8 %14 to i32
  %sub64 = sub nsw i32 %conv63, 48
  %incdec.ptr65 = getelementptr inbounds i8, i8* %incdec.ptr62, i32 1
  %shl66 = shl i32 %sub64, 3
  %incdec.ptr67 = getelementptr inbounds i8, i8* %incdec.ptr65, i32 1
  %15 = load i8, i8* %incdec.ptr65, align 1, !tbaa !166
  %conv68 = sext i8 %15 to i32
  %sub69 = sub nsw i32 %conv68, 48
  %or70 = or i32 %shl66, %sub69
  %shl71 = shl i32 %or70, 3
  %incdec.ptr72 = getelementptr inbounds i8, i8* %incdec.ptr67, i32 1
  %16 = load i8, i8* %incdec.ptr67, align 1, !tbaa !166
  %conv73 = sext i8 %16 to i32
  %sub74 = sub nsw i32 %conv73, 48
  %or75 = or i32 %shl71, %sub74
  %conv76 = trunc i32 %or75 to i8
  br label %if.end83

if.else79:                                        ; preds = %land.lhs.true57, %land.lhs.true53, %land.lhs.true48, %land.lhs.true44, %while.body40
  %incdec.ptr80 = getelementptr inbounds i8, i8* %bp.4, i32 1
  %17 = load i8, i8* %bp.4, align 1, !tbaa !166
  br label %if.end83

if.end83:                                         ; preds = %if.else79, %if.then61
  %.sink = phi i8 [ %17, %if.else79 ], [ %conv76, %if.then61 ]
  %bp.5 = phi i8* [ %incdec.ptr72, %if.then61 ], [ %incdec.ptr80, %if.else79 ]
  %incdec.ptr81 = getelementptr inbounds i8, i8* %dest.addr.3, i32 1
  store i8 %.sink, i8* %dest.addr.3, align 1, !tbaa !166
  %inc82 = add nsw i32 %len.3, 1
  br label %while.cond28

if.end85:                                         ; preds = %land.lhs.true36, %land.lhs.true32, %while.cond28, %LeafBlock, %while.cond9
  %bp.6 = phi i8* [ %bp.2, %LeafBlock ], [ %bp.1, %while.cond9 ], [ %bp.4, %while.cond28 ], [ %bp.4, %land.lhs.true32 ], [ %bp.4, %land.lhs.true36 ]
  %len.5 = phi i32 [ %len.1, %LeafBlock ], [ %len.0, %while.cond9 ], [ %len.3, %while.cond28 ], [ %len.3, %land.lhs.true32 ], [ %len.3, %land.lhs.true36 ]
  %dest.addr.5 = phi i8* [ %dest.addr.1, %LeafBlock ], [ %dest.addr.0, %while.cond9 ], [ %dest.addr.3, %while.cond28 ], [ %dest.addr.3, %land.lhs.true32 ], [ %dest.addr.3, %land.lhs.true36 ]
  %18 = load i8, i8* %bp.6, align 1, !tbaa !166
  %conv86 = sext i8 %18 to i32
  %cmp87 = icmp ne i32 %conv86, 32
  br i1 %cmp87, label %land.lhs.true89, label %if.end98

land.lhs.true89:                                  ; preds = %if.end85
  %19 = load i8, i8* %bp.6, align 1, !tbaa !166
  %conv90 = sext i8 %19 to i32
  %cmp91 = icmp ne i32 %conv90, 10
  br i1 %cmp91, label %land.lhs.true93, label %if.end98

land.lhs.true93:                                  ; preds = %land.lhs.true89
  %20 = load i8, i8* %bp.6, align 1, !tbaa !166
  %conv94 = sext i8 %20 to i32
  %cmp95 = icmp ne i32 %conv94, 0
  br i1 %cmp95, label %cleanup106, label %if.end98

if.end98:                                         ; preds = %land.lhs.true93, %land.lhs.true89, %if.end85
  br label %while.cond99

while.cond99:                                     ; preds = %while.body103, %if.end98
  %bp.7 = phi i8* [ %bp.6, %if.end98 ], [ %incdec.ptr104, %while.body103 ]
  %21 = load i8, i8* %bp.7, align 1, !tbaa !166
  %conv100 = sext i8 %21 to i32
  %cmp101 = icmp eq i32 %conv100, 32
  br i1 %cmp101, label %while.body103, label %while.end105

while.body103:                                    ; preds = %while.cond99
  %incdec.ptr104 = getelementptr inbounds i8, i8* %bp.7, i32 1
  br label %while.cond99

while.end105:                                     ; preds = %while.cond99
  store i8* %bp.7, i8** %bpp, align 8, !tbaa !28
  store i8 0, i8* %dest.addr.5, align 1, !tbaa !166
  br label %cleanup106

cleanup106:                                       ; preds = %while.end105, %land.lhs.true93
  %retval.0 = phi i32 [ %len.5, %while.end105 ], [ -1, %land.lhs.true93 ]
  ret i32 %retval.0
}

declare i32 @hex_to_bin(i8 signext) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @isodigit(i8 signext %c) #2 {
entry:
  %conv = sext i8 %c to i32
  %cmp = icmp sge i32 %conv, 48
  %conv2 = sext i8 %c to i32
  %cmp3 = icmp sle i32 %conv2, 55
  %0 = select i1 %cmp, i1 %cmp3, i1 false
  %land.ext = zext i1 %0 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define internal i64 @read_flush(i8* %buf, i64 %count, i64* %ppos, %struct.cache_detail* %cd) #0 {
entry:
  %tbuf = alloca [22 x i8], align 16
  %0 = load i64, i64* %ppos, align 8, !tbaa !291
  %arraydecay = getelementptr inbounds [22 x i8], [22 x i8]* %tbuf, i32 0, i32 0
  %flush_time = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 16
  %1 = load i64, i64* %flush_time, align 8, !tbaa !989
  %call = call i64 @convert_to_wallclock(i64 %1)
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 22, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.21.989, i32 0, i32 0), i64 %call)
  %arraydecay2 = getelementptr inbounds [22 x i8], [22 x i8]* %tbuf, i32 0, i32 0
  %call3 = call i64 @strlen(i8* %arraydecay2)
  %cmp = icmp uge i64 %0, %call3
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %sub = sub i64 %call3, %0
  %cmp4 = icmp ugt i64 %sub, %count
  %count.sub = select i1 %cmp4, i64 %count, i64 %sub
  %arraydecay7 = getelementptr inbounds [22 x i8], [22 x i8]* %tbuf, i32 0, i32 0
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay7, i64 %0
  %conv = trunc i64 %count.sub to i32
  call void @might_fault() #7
  %call.i = call i64 @_copy_to_user(i8* %buf, i8* %add.ptr, i32 %conv) #7
  %conv.i = trunc i64 %call.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end
  %2 = load i64, i64* %ppos, align 8, !tbaa !291
  %add = add i64 %2, %count.sub
  store i64 %add, i64* %ppos, align 8, !tbaa !291
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.end, %entry
  %retval.0 = phi i64 [ %count.sub, %if.end10 ], [ 0, %entry ], [ -14, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define void @sunrpc_cache_unregister_pipefs(%struct.cache_detail* %cd) #0 {
entry:
  %u = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %pipefs = bitcast %union.anon.71* %u to %struct.cache_detail_pipefs*
  %dir = getelementptr inbounds %struct.cache_detail_pipefs, %struct.cache_detail_pipefs* %pipefs, i32 0, i32 0
  %0 = load %struct.dentry*, %struct.dentry** %dir, align 8, !tbaa !166
  call void @rpc_remove_cache_dir(%struct.dentry* %0)
  %u1 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %pipefs2 = bitcast %union.anon.71* %u1 to %struct.cache_detail_pipefs*
  %dir3 = getelementptr inbounds %struct.cache_detail_pipefs, %struct.cache_detail_pipefs* %pipefs2, i32 0, i32 0
  store %struct.dentry* null, %struct.dentry** %dir3, align 8, !tbaa !166
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @sunrpc_cache_register_pipefs(%struct.dentry* %parent, i8* %name, i16 zeroext %umode, %struct.cache_detail* %cd) #0 {
entry:
  %q = alloca %struct.qstr, align 8
  %name1 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 1
  store i8* %name, i8** %name1, align 8, !tbaa !245
  %call = call i64 @strlen(i8* %name)
  %conv = trunc i64 %call to i32
  %0 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 0
  %1 = bitcast %struct.pgprot* %0 to %struct.exception_table_entry*
  %len = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %1, i32 0, i32 1
  store i32 %conv, i32* %len, align 4, !tbaa !166
  %name2 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 1
  %2 = load i8*, i8** %name2, align 8, !tbaa !245
  %3 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 0
  %4 = bitcast %struct.pgprot* %3 to %struct.exception_table_entry*
  %len3 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %4, i32 0, i32 1
  %5 = load i32, i32* %len3, align 4, !tbaa !166
  %call4 = call i32 @full_name_hash(i8* %2, i32 %5)
  %6 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 0
  %7 = bitcast %struct.pgprot* %6 to %struct.exception_table_entry*
  %hash = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %7, i32 0, i32 0
  store i32 %call4, i32* %hash, align 8, !tbaa !166
  %call5 = call %struct.dentry* @rpc_create_cache_dir(%struct.dentry* %parent, %struct.qstr* %q, i16 zeroext %umode, %struct.cache_detail* %cd)
  %8 = bitcast %struct.dentry* %call5 to i8*
  %call6 = call i64 @IS_ERR.991(i8* %8)
  %tobool = icmp ne i64 %call6, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %u = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %pipefs = bitcast %union.anon.71* %u to %struct.cache_detail_pipefs*
  %dir7 = getelementptr inbounds %struct.cache_detail_pipefs, %struct.cache_detail_pipefs* %pipefs, i32 0, i32 0
  store %struct.dentry* %call5, %struct.dentry** %dir7, align 8, !tbaa !166
  br label %if.end

if.else:                                          ; preds = %entry
  %9 = bitcast %struct.dentry* %call5 to i8*
  %call8 = call i64 @PTR_ERR.992(i8* %9)
  %conv9 = trunc i64 %call8 to i32
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %ret.0 = phi i32 [ %conv9, %if.else ], [ 0, %if.then ]
  ret i32 %ret.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR.991(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR.992(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define void @cache_destroy_net(%struct.cache_detail* %cd, %struct.net* %net) #0 {
entry:
  %hash_table = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 2
  %0 = load %struct.cache_head**, %struct.cache_head*** %hash_table, align 8, !tbaa !982
  %1 = bitcast %struct.cache_head** %0 to i8*
  call void @kfree(i8* %1)
  %2 = bitcast %struct.cache_detail* %cd to i8*
  call void @kfree(i8* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.cache_detail* @cache_create_net(%struct.cache_detail* %tmpl, %struct.net* %net) #0 {
entry:
  %0 = bitcast %struct.cache_detail* %tmpl to i8*
  %call = call i8* @kmemdup(i8* %0, i64 312, i32 208)
  %1 = bitcast i8* %call to %struct.cache_detail*
  %cmp = icmp eq %struct.cache_detail* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i8* @ERR_PTR.997(i64 -12)
  %2 = bitcast i8* %call1 to %struct.cache_detail*
  br label %cleanup

if.end:                                           ; preds = %entry
  %hash_size = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %1, i32 0, i32 1
  %3 = load i32, i32* %hash_size, align 8, !tbaa !983
  %conv = sext i32 %3 to i64
  %mul = mul i64 %conv, 8
  %call2 = call i8* @kzalloc.998(i64 %mul, i32 208)
  %4 = bitcast i8* %call2 to %struct.cache_head**
  %hash_table = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %1, i32 0, i32 2
  store %struct.cache_head** %4, %struct.cache_head*** %hash_table, align 8, !tbaa !982
  %hash_table3 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %1, i32 0, i32 2
  %5 = load %struct.cache_head**, %struct.cache_head*** %hash_table3, align 8, !tbaa !982
  %cmp4 = icmp eq %struct.cache_head** %5, null
  br i1 %cmp4, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %6 = bitcast %struct.cache_detail* %1 to i8*
  call void @kfree(i8* %6)
  %call7 = call i8* @ERR_PTR.997(i64 -12)
  %7 = bitcast i8* %call7 to %struct.cache_detail*
  br label %cleanup

if.end8:                                          ; preds = %if.end
  %net9 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %1, i32 0, i32 25
  store %struct.net* %net, %struct.net** %net9, align 8, !tbaa !846
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %if.then6, %if.then
  %retval.0 = phi %struct.cache_detail* [ %2, %if.then ], [ %7, %if.then6 ], [ %1, %if.end8 ]
  ret %struct.cache_detail* %retval.0
}

declare i8* @kmemdup(i8*, i64, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR.997(i64 %error) #2 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.998(i64 %size, i32 %flags) #2 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #7
  ret i8* %call.i
}

; Function Attrs: nounwind uwtable
define void @cache_unregister_net(%struct.cache_detail* %cd, %struct.net* %net) #0 {
entry:
  call void @remove_cache_proc_entries(%struct.cache_detail* %cd, %struct.net* %net)
  call void @sunrpc_destroy_cache_detail(%struct.cache_detail* %cd)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @remove_cache_proc_entries(%struct.cache_detail* %cd, %struct.net* %net) #0 {
entry:
  %u = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs = bitcast %union.anon.71* %u to %struct.cache_detail_procfs*
  %proc_ent = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs, i32 0, i32 0
  %0 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_ent, align 8, !tbaa !166
  %cmp = icmp eq %struct.proc_dir_entry* %0, null
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %u1 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs2 = bitcast %union.anon.71* %u1 to %struct.cache_detail_procfs*
  %flush_ent = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs2, i32 0, i32 1
  %1 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %flush_ent, align 8, !tbaa !166
  %tobool = icmp ne %struct.proc_dir_entry* %1, null
  br i1 %tobool, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.end
  %u4 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs5 = bitcast %union.anon.71* %u4 to %struct.cache_detail_procfs*
  %proc_ent6 = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs5, i32 0, i32 0
  %2 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_ent6, align 8, !tbaa !166
  call void @remove_proc_entry(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.25.1119, i32 0, i32 0), %struct.proc_dir_entry* %2)
  br label %if.end7

if.end7:                                          ; preds = %if.then3, %if.end
  %u8 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs9 = bitcast %union.anon.71* %u8 to %struct.cache_detail_procfs*
  %channel_ent = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs9, i32 0, i32 2
  %3 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %channel_ent, align 8, !tbaa !166
  %tobool10 = icmp ne %struct.proc_dir_entry* %3, null
  br i1 %tobool10, label %if.then11, label %if.end15

if.then11:                                        ; preds = %if.end7
  %u12 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs13 = bitcast %union.anon.71* %u12 to %struct.cache_detail_procfs*
  %proc_ent14 = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs13, i32 0, i32 0
  %4 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_ent14, align 8, !tbaa !166
  call void @remove_proc_entry(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23.1117, i32 0, i32 0), %struct.proc_dir_entry* %4)
  br label %if.end15

if.end15:                                         ; preds = %if.then11, %if.end7
  %u16 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs17 = bitcast %union.anon.71* %u16 to %struct.cache_detail_procfs*
  %content_ent = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs17, i32 0, i32 3
  %5 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %content_ent, align 8, !tbaa !166
  %tobool18 = icmp ne %struct.proc_dir_entry* %5, null
  br i1 %tobool18, label %if.then19, label %if.end23

if.then19:                                        ; preds = %if.end15
  %u20 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs21 = bitcast %union.anon.71* %u20 to %struct.cache_detail_procfs*
  %proc_ent22 = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs21, i32 0, i32 0
  %6 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_ent22, align 8, !tbaa !166
  call void @remove_proc_entry(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.24.1118, i32 0, i32 0), %struct.proc_dir_entry* %6)
  br label %if.end23

if.end23:                                         ; preds = %if.then19, %if.end15
  %u24 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs25 = bitcast %union.anon.71* %u24 to %struct.cache_detail_procfs*
  %proc_ent26 = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs25, i32 0, i32 0
  store %struct.proc_dir_entry* null, %struct.proc_dir_entry** %proc_ent26, align 8, !tbaa !166
  %7 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.1007(%struct.net* %net, i32 %7)
  %8 = bitcast i8* %call to %struct.sunrpc_net*
  %name = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 5
  %9 = load i8*, i8** %name, align 8, !tbaa !1008
  %proc_net_rpc = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %8, i32 0, i32 0
  %10 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_net_rpc, align 8, !tbaa !1009
  call void @remove_proc_entry(i8* %9, %struct.proc_dir_entry* %10)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end23, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @sunrpc_destroy_cache_detail(%struct.cache_detail* %cd) #0 {
entry:
  call void @cache_purge(%struct.cache_detail* %cd)
  call void @spin_lock.935(%struct.spinlock* @cache_list_lock)
  %hash_lock = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 3
  call void @_raw_write_lock(%struct.rwlock_t* %hash_lock)
  %entries = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 19
  %0 = load i32, i32* %entries, align 8, !tbaa !1007
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %inuse = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 4
  %call = call i32 @atomic_read.955(%struct.atomic_t* %inuse)
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %hash_lock2 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 3
  call void @_raw_write_unlock(%struct.rwlock_t* %hash_lock2)
  call void @spin_unlock.936(%struct.spinlock* @cache_list_lock)
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load %struct.cache_detail*, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  %cmp = icmp eq %struct.cache_detail* %2, %cd
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store %struct.cache_detail* null, %struct.cache_detail** @current_detail, align 8, !tbaa !28
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %others = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 17
  call void @list_del_init.969(%struct.list_head* %others)
  %hash_lock5 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 3
  call void @_raw_write_unlock(%struct.rwlock_t* %hash_lock5)
  call void @spin_unlock.936(%struct.spinlock* @cache_list_lock)
  %call6 = call i32 @list_empty.968(%struct.list_head* @cache_list)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %return

if.then8:                                         ; preds = %if.end4
  %call9 = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* @cache_cleaner)
  br label %return

return:                                           ; preds = %if.then8, %if.end4, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @cache_purge(%struct.cache_detail* %detail) #0 {
entry:
  %flush_time = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 16
  store i64 9223372036854775807, i64* %flush_time, align 8, !tbaa !989
  %call = call i64 @seconds_since_boot()
  %nextcheck = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 18
  store i64 %call, i64* %nextcheck, align 8, !tbaa !829
  call void @cache_flush()
  %flush_time1 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 16
  store i64 1, i64* %flush_time1, align 8, !tbaa !989
  ret void
}

declare void @remove_proc_entry(i8*, %struct.proc_dir_entry*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @net_generic.1007(%struct.net* %net, i32 %id) #2 {
entry:
  call void @rcu_read_lock.1008()
  %gen = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 37
  %0 = load volatile %struct.net_generic*, %struct.net_generic** %gen, align 16, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.body8

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @net_generic.__warned.1009, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %do.body8, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held.1010()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.body8, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @net_generic.__warned.1009, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 40, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.body8

do.body8:                                         ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %cmp = icmp eq i32 %id, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.body8
  %len = getelementptr inbounds %struct.net_generic, %struct.net_generic* %0, i32 0, i32 0
  %2 = load i32, i32* %len, align 8, !tbaa !176
  %cmp9 = icmp ugt i32 %id, %2
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %do.body8
  %3 = phi i1 [ true, %do.body8 ], [ %cmp9, %lor.rhs ]
  %lnot = xor i1 %3, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %do.body13, label %do.end21

do.body13:                                        ; preds = %lor.end
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 41, i64 12) #7, !srcloc !1010
  br label %do.body14

do.body14:                                        ; preds = %do.body14, %do.body13
  br label %do.body14

do.end21:                                         ; preds = %lor.end
  %ptr22 = getelementptr inbounds %struct.net_generic, %struct.net_generic* %0, i32 0, i32 2
  %sub = sub nsw i32 %id, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [0 x i8*], [0 x i8*]* %ptr22, i64 0, i64 %idxprom
  %4 = load i8*, i8** %arrayidx, align 8, !tbaa !28
  call void @rcu_read_unlock.1013()
  %tobool24 = icmp ne i8* %4, null
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %do.body35, label %do.end43

do.body35:                                        ; preds = %do.end21
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 45, i64 12) #7, !srcloc !1011
  br label %do.body36

do.body36:                                        ; preds = %do.body36, %do.body35
  br label %do.body36

do.end43:                                         ; preds = %do.end21
  ret i8* %4
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock.1008() #2 {
entry:
  call void @__rcu_read_lock.1020()
  call void @rcu_lock_acquire.1021(%struct.lockdep_map* @rcu_lock_map)
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_lock.__warned.1022, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_lock.__warned.1022, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 780, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.15.1329, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rcu_read_lock_held.1010() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call1 = call i32 @rcu_is_cpu_idle()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call zeroext i1 @rcu_lockdep_current_cpu_online()
  br i1 %call5, label %if.end7, label %return

if.end7:                                          ; preds = %if.end4
  %call8 = call i32 @lock_is_held(%struct.lockdep_map* @rcu_lock_map)
  br label %return

return:                                           ; preds = %if.end7, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call8, %if.end7 ], [ 1, %entry ], [ 0, %if.end ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_unlock.1013() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_unlock.__warned.1014, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_unlock.__warned.1014, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 801, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.16.1322, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  call void @rcu_lock_release.1017(%struct.lockdep_map* @rcu_lock_map)
  call void @__rcu_read_unlock.1018()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_release.1017(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_release(%struct.lockdep_map* %map, i32 1, i64 ptrtoint (i8* blockaddress(@rcu_lock_release.1017, %__here) to i64))
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_unlock.1018() #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !1012
  %call = call %struct.thread_info* @current_thread_info.1019()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !1013
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.1019() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !1014
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_lock.1020() #2 {
entry:
  %call = call %struct.thread_info* @current_thread_info.1019()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !1015
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_acquire.1021(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_acquire(%struct.lockdep_map* %map, i32 0, i32 0, i32 2, i32 1, %struct.lockdep_map* null, i64 ptrtoint (i8* blockaddress(@rcu_lock_acquire.1021, %__here) to i64))
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @cache_register_net(%struct.cache_detail* %cd, %struct.net* %net) #0 {
entry:
  call void @sunrpc_init_cache_detail(%struct.cache_detail* %cd)
  %call = call i32 @create_cache_proc_entries(%struct.cache_detail* %cd, %struct.net* %net)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @sunrpc_destroy_cache_detail(%struct.cache_detail* %cd)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define void @sunrpc_init_cache_detail(%struct.cache_detail* %cd) #0 {
entry:
  %hash_lock = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 3
  call void @__rwlock_init(%struct.rwlock_t* %hash_lock, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.1.1026, i32 0, i32 0), %struct.lock_class_key* @sunrpc_init_cache_detail.__key)
  %queue = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 20
  call void @INIT_LIST_HEAD.970(%struct.list_head* %queue)
  call void @spin_lock.935(%struct.spinlock* @cache_list_lock)
  %nextcheck = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 18
  store i64 0, i64* %nextcheck, align 8, !tbaa !829
  %entries = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 19
  store i32 0, i32* %entries, align 8, !tbaa !1007
  %readers = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 21
  call void @atomic_set.1027(%struct.atomic_t* %readers, i32 0)
  %last_close = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 22
  store i64 0, i64* %last_close, align 8, !tbaa !959
  %last_warn = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 23
  store i64 -1, i64* %last_warn, align 8, !tbaa !1004
  %others = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 17
  call void @list_add.941(%struct.list_head* %others, %struct.list_head* @cache_list)
  call void @spin_unlock.936(%struct.spinlock* @cache_list_lock)
  call void @schedule_delayed_work(%struct.delayed_work* @cache_cleaner, i64 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @create_cache_proc_entries(%struct.cache_detail* %cd, %struct.net* %net) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.1007(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %name = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 5
  %2 = load i8*, i8** %name, align 8, !tbaa !1008
  %proc_net_rpc = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 0
  %3 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_net_rpc, align 8, !tbaa !1009
  %call1 = call %struct.proc_dir_entry* @proc_mkdir(i8* %2, %struct.proc_dir_entry* %3)
  %u = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs = bitcast %union.anon.71* %u to %struct.cache_detail_procfs*
  %proc_ent = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs, i32 0, i32 0
  store %struct.proc_dir_entry* %call1, %struct.proc_dir_entry** %proc_ent, align 8, !tbaa !166
  %u2 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs3 = bitcast %union.anon.71* %u2 to %struct.cache_detail_procfs*
  %proc_ent4 = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs3, i32 0, i32 0
  %4 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_ent4, align 8, !tbaa !166
  %cmp = icmp eq %struct.proc_dir_entry* %4, null
  br i1 %cmp, label %out_nomem, label %if.end

if.end:                                           ; preds = %entry
  %u5 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs6 = bitcast %union.anon.71* %u5 to %struct.cache_detail_procfs*
  %channel_ent = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs6, i32 0, i32 2
  store %struct.proc_dir_entry* null, %struct.proc_dir_entry** %channel_ent, align 8, !tbaa !166
  %u7 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs8 = bitcast %union.anon.71* %u7 to %struct.cache_detail_procfs*
  %content_ent = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs8, i32 0, i32 3
  store %struct.proc_dir_entry* null, %struct.proc_dir_entry** %content_ent, align 8, !tbaa !166
  %u9 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs10 = bitcast %union.anon.71* %u9 to %struct.cache_detail_procfs*
  %proc_ent11 = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs10, i32 0, i32 0
  %5 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_ent11, align 8, !tbaa !166
  %6 = bitcast %struct.cache_detail* %cd to i8*
  %call12 = call %struct.proc_dir_entry* @proc_create_data(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.25.1119, i32 0, i32 0), i16 zeroext -32384, %struct.proc_dir_entry* %5, %struct.file_operations* @cache_flush_operations_procfs, i8* %6)
  %u13 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs14 = bitcast %union.anon.71* %u13 to %struct.cache_detail_procfs*
  %flush_ent = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs14, i32 0, i32 1
  store %struct.proc_dir_entry* %call12, %struct.proc_dir_entry** %flush_ent, align 8, !tbaa !166
  %cmp15 = icmp eq %struct.proc_dir_entry* %call12, null
  br i1 %cmp15, label %out_nomem, label %if.end17

if.end17:                                         ; preds = %if.end
  %cache_request = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 8
  %7 = load void (%struct.cache_detail*, %struct.cache_head*, i8**, i32*)*, void (%struct.cache_detail*, %struct.cache_head*, i8**, i32*)** %cache_request, align 8, !tbaa !976
  %tobool = icmp ne void (%struct.cache_detail*, %struct.cache_head*, i8**, i32*)* %7, null
  br i1 %tobool, label %if.then19, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end17
  %cache_parse = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 9
  %8 = load i32 (%struct.cache_detail*, i8*, i32)*, i32 (%struct.cache_detail*, i8*, i32)** %cache_parse, align 8, !tbaa !971
  %tobool18 = icmp ne i32 (%struct.cache_detail*, i8*, i32)* %8, null
  br i1 %tobool18, label %if.then19, label %if.end30

if.then19:                                        ; preds = %lor.lhs.false, %if.end17
  %u20 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs21 = bitcast %union.anon.71* %u20 to %struct.cache_detail_procfs*
  %proc_ent22 = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs21, i32 0, i32 0
  %9 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_ent22, align 8, !tbaa !166
  %10 = bitcast %struct.cache_detail* %cd to i8*
  %call23 = call %struct.proc_dir_entry* @proc_create_data(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23.1117, i32 0, i32 0), i16 zeroext -32384, %struct.proc_dir_entry* %9, %struct.file_operations* @cache_file_operations_procfs, i8* %10)
  %u24 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs25 = bitcast %union.anon.71* %u24 to %struct.cache_detail_procfs*
  %channel_ent26 = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs25, i32 0, i32 2
  store %struct.proc_dir_entry* %call23, %struct.proc_dir_entry** %channel_ent26, align 8, !tbaa !166
  %cmp27 = icmp eq %struct.proc_dir_entry* %call23, null
  br i1 %cmp27, label %out_nomem, label %if.end30

if.end30:                                         ; preds = %if.then19, %lor.lhs.false
  %cache_show = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 10
  %11 = load i32 (%struct.seq_file*, %struct.cache_detail*, %struct.cache_head*)*, i32 (%struct.seq_file*, %struct.cache_detail*, %struct.cache_head*)** %cache_show, align 8, !tbaa !985
  %tobool31 = icmp ne i32 (%struct.seq_file*, %struct.cache_detail*, %struct.cache_head*)* %11, null
  br i1 %tobool31, label %if.then32, label %cleanup

if.then32:                                        ; preds = %if.end30
  %u33 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs34 = bitcast %union.anon.71* %u33 to %struct.cache_detail_procfs*
  %proc_ent35 = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs34, i32 0, i32 0
  %12 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_ent35, align 8, !tbaa !166
  %13 = bitcast %struct.cache_detail* %cd to i8*
  %call36 = call %struct.proc_dir_entry* @proc_create_data(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.24.1118, i32 0, i32 0), i16 zeroext -32512, %struct.proc_dir_entry* %12, %struct.file_operations* @content_file_operations_procfs, i8* %13)
  %u37 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %cd, i32 0, i32 24
  %procfs38 = bitcast %union.anon.71* %u37 to %struct.cache_detail_procfs*
  %content_ent39 = getelementptr inbounds %struct.cache_detail_procfs, %struct.cache_detail_procfs* %procfs38, i32 0, i32 3
  store %struct.proc_dir_entry* %call36, %struct.proc_dir_entry** %content_ent39, align 8, !tbaa !166
  %cmp40 = icmp eq %struct.proc_dir_entry* %call36, null
  br i1 %cmp40, label %out_nomem, label %cleanup

out_nomem:                                        ; preds = %if.then32, %if.then19, %if.end, %entry
  call void @remove_cache_proc_entries(%struct.cache_detail* %cd, %struct.net* %net)
  br label %cleanup

cleanup:                                          ; preds = %out_nomem, %if.then32, %if.end30
  %retval.0 = phi i32 [ -12, %out_nomem ], [ 0, %if.then32 ], [ 0, %if.end30 ]
  ret i32 %retval.0
}

declare %struct.proc_dir_entry* @proc_mkdir(i8*, %struct.proc_dir_entry*) #4

declare %struct.proc_dir_entry* @proc_create_data(i8*, i16 zeroext, %struct.proc_dir_entry*, %struct.file_operations*, i8*) #4

; Function Attrs: nounwind uwtable
define internal i32 @content_open_procfs(%struct.inode* %inode, %struct.file* %filp) #0 {
entry:
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %0 = bitcast i8* %call to %struct.cache_detail*
  %call1 = call i32 @content_open(%struct.file* %filp, %struct.cache_detail* %0)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @content_release_procfs(%struct.inode* %inode, %struct.file* %filp) #0 {
entry:
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %0 = bitcast i8* %call to %struct.cache_detail*
  %call1 = call i32 @content_release(%struct.inode* %inode, %struct.file* %filp, %struct.cache_detail* %0)
  ret i32 %call1
}

declare i8* @PDE_DATA(%struct.inode*) #4

; Function Attrs: nounwind uwtable
define internal i64 @cache_read_procfs(%struct.file* %filp, i8* %buf, i64 %count, i64* %ppos) #0 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %filp)
  %call1 = call i8* @PDE_DATA(%struct.inode* %call)
  %0 = bitcast i8* %call1 to %struct.cache_detail*
  %call2 = call i64 @cache_read(%struct.file* %filp, i8* %buf, i64 %count, %struct.cache_detail* %0)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define internal i64 @cache_write_procfs(%struct.file* %filp, i8* %buf, i64 %count, i64* %ppos) #0 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %filp)
  %call1 = call i8* @PDE_DATA(%struct.inode* %call)
  %0 = bitcast i8* %call1 to %struct.cache_detail*
  %call2 = call i64 @cache_write(%struct.file* %filp, i8* %buf, i64 %count, %struct.cache_detail* %0)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @cache_poll_procfs(%struct.file* %filp, %struct.poll_table_struct* %wait) #0 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %filp)
  %call1 = call i8* @PDE_DATA(%struct.inode* %call)
  %0 = bitcast i8* %call1 to %struct.cache_detail*
  %call2 = call i32 @cache_poll(%struct.file* %filp, %struct.poll_table_struct* %wait, %struct.cache_detail* %0)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i64 @cache_ioctl_procfs(%struct.file* %filp, i32 %cmd, i64 %arg) #0 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %filp)
  %call1 = call i8* @PDE_DATA(%struct.inode* %call)
  %0 = bitcast i8* %call1 to %struct.cache_detail*
  %call2 = call i32 @cache_ioctl(%struct.file* %filp, i32 %cmd, i64 %arg, %struct.cache_detail* %0)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @cache_open_procfs(%struct.inode* %inode, %struct.file* %filp) #0 {
entry:
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %0 = bitcast i8* %call to %struct.cache_detail*
  %call1 = call i32 @cache_open(%struct.inode* %inode, %struct.file* %filp, %struct.cache_detail* %0)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @cache_release_procfs(%struct.inode* %inode, %struct.file* %filp) #0 {
entry:
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %0 = bitcast i8* %call to %struct.cache_detail*
  %call1 = call i32 @cache_release(%struct.file* %filp, %struct.cache_detail* %0)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i64 @read_flush_procfs(%struct.file* %filp, i8* %buf, i64 %count, i64* %ppos) #0 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %filp)
  %call1 = call i8* @PDE_DATA(%struct.inode* %call)
  %0 = bitcast i8* %call1 to %struct.cache_detail*
  %call2 = call i64 @read_flush(i8* %buf, i64 %count, i64* %ppos, %struct.cache_detail* %0)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define internal i64 @write_flush_procfs(%struct.file* %filp, i8* %buf, i64 %count, i64* %ppos) #0 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %filp)
  %call1 = call i8* @PDE_DATA(%struct.inode* %call)
  %0 = bitcast i8* %call1 to %struct.cache_detail*
  %call2 = call i64 @write_flush(i8* %buf, i64 %count, i64* %ppos, %struct.cache_detail* %0)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @open_flush_procfs(%struct.inode* %inode, %struct.file* %filp) #0 {
entry:
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %0 = bitcast i8* %call to %struct.cache_detail*
  %call1 = call i32 @open_flush(%struct.inode* %inode, %struct.file* %filp, %struct.cache_detail* %0)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @release_flush_procfs(%struct.inode* %inode, %struct.file* %filp) #0 {
entry:
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %0 = bitcast i8* %call to %struct.cache_detail*
  %call1 = call i32 @release_flush(%struct.cache_detail* %0)
  ret i32 %call1
}

declare void @__rwlock_init(%struct.rwlock_t*, i8*, %struct.lock_class_key*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set.1027(%struct.atomic_t* %v, i32 %i) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !240
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @schedule_delayed_work(%struct.delayed_work* %dwork, i64 %delay) #2 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8, !tbaa !28
  call void @queue_delayed_work.1028(%struct.workqueue_struct* %0, %struct.delayed_work* %dwork, i64 %delay)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_delayed_work.1028(%struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay) #2 {
entry:
  %call = call zeroext i1 @queue_delayed_work_on(i32 4096, %struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay)
  ret void
}

; Function Attrs: nounwind uwtable
define void @qword_addhex(i8** %bpp, i32* %lp, i8* %buf, i32 %blen) #0 {
entry:
  %0 = load i8*, i8** %bpp, align 8, !tbaa !28
  %1 = load i32, i32* %lp, align 4, !tbaa !49
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp sgt i32 %1, 2
  br i1 %cmp1, label %if.then2, label %if.end24

if.then2:                                         ; preds = %if.end
  %incdec.ptr = getelementptr inbounds i8, i8* %0, i32 1
  store i8 92, i8* %0, align 1, !tbaa !166
  %incdec.ptr3 = getelementptr inbounds i8, i8* %incdec.ptr, i32 1
  store i8 120, i8* %incdec.ptr, align 1, !tbaa !166
  %sub = sub nsw i32 %1, 2
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then2
  %bp.0 = phi i8* [ %incdec.ptr3, %if.then2 ], [ %incdec.ptr22, %while.body ]
  %blen.addr.0 = phi i32 [ %blen, %if.then2 ], [ %dec, %while.body ]
  %buf.addr.0 = phi i8* [ %buf, %if.then2 ], [ %incdec.ptr5, %while.body ]
  %len.0 = phi i32 [ %sub, %if.then2 ], [ %sub23, %while.body ]
  %tobool = icmp ne i32 %blen.addr.0, 0
  %cmp4 = icmp sge i32 %len.0, 2
  %cmp4. = select i1 %tobool, i1 %cmp4, i1 false
  br i1 %cmp4., label %while.body, label %if.end24

while.body:                                       ; preds = %while.cond
  %incdec.ptr5 = getelementptr inbounds i8, i8* %buf.addr.0, i32 1
  %2 = load i8, i8* %buf.addr.0, align 1, !tbaa !166
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %shr = ashr i32 %and, 4
  %add = add nsw i32 48, %shr
  %conv6 = zext i8 %2 to i32
  %cmp7 = icmp sge i32 %conv6, 160
  %conv8 = zext i1 %cmp7 to i32
  %mul = mul nsw i32 %conv8, 39
  %add9 = add nsw i32 %add, %mul
  %conv10 = trunc i32 %add9 to i8
  %incdec.ptr11 = getelementptr inbounds i8, i8* %bp.0, i32 1
  store i8 %conv10, i8* %bp.0, align 1, !tbaa !166
  %conv12 = zext i8 %2 to i32
  %and13 = and i32 %conv12, 15
  %add14 = add nsw i32 48, %and13
  %conv15 = zext i8 %2 to i32
  %and16 = and i32 %conv15, 15
  %cmp17 = icmp sge i32 %and16, 10
  %conv18 = zext i1 %cmp17 to i32
  %mul19 = mul nsw i32 %conv18, 39
  %add20 = add nsw i32 %add14, %mul19
  %conv21 = trunc i32 %add20 to i8
  %incdec.ptr22 = getelementptr inbounds i8, i8* %incdec.ptr11, i32 1
  store i8 %conv21, i8* %incdec.ptr11, align 1, !tbaa !166
  %sub23 = sub nsw i32 %len.0, 2
  %dec = add nsw i32 %blen.addr.0, -1
  br label %while.cond

if.end24:                                         ; preds = %while.cond, %if.end
  %bp.1 = phi i8* [ %0, %if.end ], [ %bp.0, %while.cond ]
  %blen.addr.1 = phi i32 [ %blen, %if.end ], [ %blen.addr.0, %while.cond ]
  %len.1 = phi i32 [ %1, %if.end ], [ %len.0, %while.cond ]
  %tobool25 = icmp ne i32 %blen.addr.1, 0
  %cmp26 = icmp slt i32 %len.1, 1
  %or.cond = or i1 %tobool25, %cmp26
  br i1 %or.cond, label %if.end31, label %if.else

if.else:                                          ; preds = %if.end24
  %incdec.ptr29 = getelementptr inbounds i8, i8* %bp.1, i32 1
  store i8 32, i8* %bp.1, align 1, !tbaa !166
  %dec30 = add nsw i32 %len.1, -1
  br label %if.end31

if.end31:                                         ; preds = %if.else, %if.end24
  %bp.2 = phi i8* [ %incdec.ptr29, %if.else ], [ %bp.1, %if.end24 ]
  %len.2 = phi i32 [ %dec30, %if.else ], [ -1, %if.end24 ]
  store i8* %bp.2, i8** %bpp, align 8, !tbaa !28
  store i32 %len.2, i32* %lp, align 4, !tbaa !49
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end31, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @qword_add(i8** %bpp, i32* %lp, i8* %str) #0 {
entry:
  %0 = load i8*, i8** %bpp, align 8, !tbaa !28
  %1 = load i32, i32* %lp, align 4, !tbaa !49
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %sw.epilog, %if.end
  %bp.0 = phi i8* [ %0, %if.end ], [ %bp.2, %sw.epilog ]
  %str.addr.0 = phi i8* [ %str, %if.end ], [ %incdec.ptr, %sw.epilog ]
  %len.0 = phi i32 [ %1, %if.end ], [ %len.1, %sw.epilog ]
  %incdec.ptr = getelementptr inbounds i8, i8* %str.addr.0, i32 1
  %2 = load i8, i8* %str.addr.0, align 1, !tbaa !166
  %conv = sext i8 %2 to i32
  %tobool = icmp ne i32 %conv, 0
  %tobool1 = icmp ne i32 %len.0, 0
  %tobool1. = select i1 %tobool, i1 %tobool1, i1 false
  %conv2 = sext i8 %2 to i32
  br i1 %tobool1., label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %Pivot6 = icmp slt i32 %conv2, 32
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %while.body
  %Pivot = icmp slt i32 %conv2, 92
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %conv2, 92
  br i1 %SwitchLeaf4, label %sw.bb, label %sw.default

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv2, 32
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.default

LeafBlock:                                        ; preds = %while.body
  %conv2.off = add i32 %conv2, -9
  %SwitchLeaf = icmp ule i32 %conv2.off, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  %cmp3 = icmp sge i32 %len.0, 4
  br i1 %cmp3, label %if.then5, label %if.end22

if.then5:                                         ; preds = %sw.bb
  %incdec.ptr6 = getelementptr inbounds i8, i8* %bp.0, i32 1
  store i8 92, i8* %bp.0, align 1, !tbaa !166
  %conv7 = sext i8 %2 to i32
  %and = and i32 %conv7, 192
  %shr = ashr i32 %and, 6
  %add = add nsw i32 48, %shr
  %conv8 = trunc i32 %add to i8
  %incdec.ptr9 = getelementptr inbounds i8, i8* %incdec.ptr6, i32 1
  store i8 %conv8, i8* %incdec.ptr6, align 1, !tbaa !166
  %conv10 = sext i8 %2 to i32
  %and11 = and i32 %conv10, 56
  %shr12 = ashr i32 %and11, 3
  %add13 = add nsw i32 48, %shr12
  %conv14 = trunc i32 %add13 to i8
  %incdec.ptr15 = getelementptr inbounds i8, i8* %incdec.ptr9, i32 1
  store i8 %conv14, i8* %incdec.ptr9, align 1, !tbaa !166
  %conv16 = sext i8 %2 to i32
  %and17 = and i32 %conv16, 7
  %shr18 = ashr i32 %and17, 0
  %add19 = add nsw i32 48, %shr18
  %conv20 = trunc i32 %add19 to i8
  %incdec.ptr21 = getelementptr inbounds i8, i8* %incdec.ptr15, i32 1
  store i8 %conv20, i8* %incdec.ptr15, align 1, !tbaa !166
  br label %if.end22

if.end22:                                         ; preds = %if.then5, %sw.bb
  %bp.1 = phi i8* [ %incdec.ptr21, %if.then5 ], [ %bp.0, %sw.bb ]
  %sub = sub nsw i32 %len.0, 4
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  %incdec.ptr23 = getelementptr inbounds i8, i8* %bp.0, i32 1
  store i8 %2, i8* %bp.0, align 1, !tbaa !166
  %dec = add nsw i32 %len.0, -1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end22
  %bp.2 = phi i8* [ %bp.1, %if.end22 ], [ %incdec.ptr23, %sw.default ]
  %len.1 = phi i32 [ %sub, %if.end22 ], [ %dec, %sw.default ]
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %tobool25 = icmp ne i32 %conv2, 0
  %cmp26 = icmp slt i32 %len.0, 1
  %or.cond = or i1 %tobool25, %cmp26
  br i1 %or.cond, label %if.end31, label %if.else

if.else:                                          ; preds = %while.end
  %incdec.ptr29 = getelementptr inbounds i8, i8* %bp.0, i32 1
  store i8 32, i8* %bp.0, align 1, !tbaa !166
  %dec30 = add nsw i32 %len.0, -1
  br label %if.end31

if.end31:                                         ; preds = %if.else, %while.end
  %bp.3 = phi i8* [ %incdec.ptr29, %if.else ], [ %bp.0, %while.end ]
  %len.2 = phi i32 [ %dec30, %if.else ], [ -1, %while.end ]
  store i8* %bp.3, i8** %bpp, align 8, !tbaa !28
  store i32 %len.2, i32* %lp, align 4, !tbaa !49
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end31, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.cache_head* @sunrpc_cache_update(%struct.cache_detail* %detail, %struct.cache_head* %new, %struct.cache_head* %old, i32 %hash) #0 {
entry:
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %old, i32 0, i32 4
  %0 = load volatile i64, i64* %flags, align 8, !tbaa !88
  %and.i7 = and i64 1, %0
  %cmp.i8 = icmp ne i64 %and.i7, 0
  %conv.i9 = zext i1 %cmp.i8 to i32
  %tobool = icmp ne i32 %conv.i9, 0
  br i1 %tobool, label %if.end26, label %if.then

if.then:                                          ; preds = %entry
  %hash_lock = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 3
  call void @_raw_write_lock(%struct.rwlock_t* %hash_lock)
  %flags5 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %old, i32 0, i32 4
  %1 = load volatile i64, i64* %flags5, align 8, !tbaa !88
  %and.i4 = and i64 1, %1
  %cmp.i5 = icmp ne i64 %and.i4, 0
  %conv.i6 = zext i1 %cmp.i5 to i32
  %tobool7 = icmp ne i32 %conv.i6, 0
  br i1 %tobool7, label %if.end24, label %cond.true13

cond.true13:                                      ; preds = %if.then
  %flags14 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %new, i32 0, i32 4
  %2 = load volatile i64, i64* %flags14, align 8, !tbaa !88
  %and.i1 = and i64 2, %2
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool16 = icmp ne i32 %conv.i3, 0
  br i1 %tobool16, label %if.then21, label %if.else

if.then21:                                        ; preds = %cond.true13
  %flags22 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %old, i32 0, i32 4
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags22, i32 1, i64* %flags22) #7, !srcloc !997
  br label %if.end

if.else:                                          ; preds = %cond.true13
  %update = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 15
  %3 = load void (%struct.cache_head*, %struct.cache_head*)*, void (%struct.cache_head*, %struct.cache_head*)** %update, align 8, !tbaa !1016
  call void %3(%struct.cache_head* %old, %struct.cache_head* %new)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then21
  %expiry_time = getelementptr inbounds %struct.cache_head, %struct.cache_head* %new, i32 0, i32 1
  %4 = load i64, i64* %expiry_time, align 8, !tbaa !828
  call void @cache_fresh_locked(%struct.cache_head* %old, i64 %4)
  %hash_lock23 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 3
  call void @_raw_write_unlock(%struct.rwlock_t* %hash_lock23)
  call void @cache_fresh_unlocked(%struct.cache_head* %old, %struct.cache_detail* %detail)
  br label %cleanup

if.end24:                                         ; preds = %if.then
  %hash_lock25 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 3
  call void @_raw_write_unlock(%struct.rwlock_t* %hash_lock25)
  br label %if.end26

if.end26:                                         ; preds = %if.end24, %entry
  %alloc = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 12
  %5 = load %struct.cache_head* ()*, %struct.cache_head* ()** %alloc, align 8, !tbaa !1017
  %call27 = call %struct.cache_head* %5()
  %tobool28 = icmp ne %struct.cache_head* %call27, null
  br i1 %tobool28, label %if.end30, label %if.then29

if.then29:                                        ; preds = %if.end26
  call void @cache_put.954(%struct.cache_head* %old, %struct.cache_detail* %detail)
  br label %cleanup

if.end30:                                         ; preds = %if.end26
  call void @cache_init(%struct.cache_head* %call27)
  %init = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 14
  %6 = load void (%struct.cache_head*, %struct.cache_head*)*, void (%struct.cache_head*, %struct.cache_head*)** %init, align 8, !tbaa !1018
  call void %6(%struct.cache_head* %call27, %struct.cache_head* %old)
  %hash_table = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 2
  %7 = load %struct.cache_head**, %struct.cache_head*** %hash_table, align 8, !tbaa !982
  %idxprom = sext i32 %hash to i64
  %arrayidx = getelementptr inbounds %struct.cache_head*, %struct.cache_head** %7, i64 %idxprom
  %hash_lock31 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 3
  call void @_raw_write_lock(%struct.rwlock_t* %hash_lock31)
  %flags33 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %new, i32 0, i32 4
  %8 = load volatile i64, i64* %flags33, align 8, !tbaa !88
  %and.i = and i64 2, %8
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool35 = icmp ne i32 %conv.i, 0
  br i1 %tobool35, label %if.then40, label %if.else42

if.then40:                                        ; preds = %if.end30
  %flags41 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %call27, i32 0, i32 4
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags41, i32 1, i64* %flags41) #7, !srcloc !997
  br label %if.end44

if.else42:                                        ; preds = %if.end30
  %update43 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 15
  %9 = load void (%struct.cache_head*, %struct.cache_head*)*, void (%struct.cache_head*, %struct.cache_head*)** %update43, align 8, !tbaa !1016
  call void %9(%struct.cache_head* %call27, %struct.cache_head* %new)
  br label %if.end44

if.end44:                                         ; preds = %if.else42, %if.then40
  %10 = load %struct.cache_head*, %struct.cache_head** %arrayidx, align 8, !tbaa !28
  %next = getelementptr inbounds %struct.cache_head, %struct.cache_head* %call27, i32 0, i32 0
  store %struct.cache_head* %10, %struct.cache_head** %next, align 8, !tbaa !984
  store %struct.cache_head* %call27, %struct.cache_head** %arrayidx, align 8, !tbaa !28
  %entries = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 19
  %11 = load i32, i32* %entries, align 8, !tbaa !1007
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %entries, align 8, !tbaa !1007
  %call45 = call %struct.cache_head* @cache_get.961(%struct.cache_head* %call27)
  %expiry_time46 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %new, i32 0, i32 1
  %12 = load i64, i64* %expiry_time46, align 8, !tbaa !828
  call void @cache_fresh_locked(%struct.cache_head* %call27, i64 %12)
  call void @cache_fresh_locked(%struct.cache_head* %old, i64 0)
  %hash_lock47 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 3
  call void @_raw_write_unlock(%struct.rwlock_t* %hash_lock47)
  call void @cache_fresh_unlocked(%struct.cache_head* %call27, %struct.cache_detail* %detail)
  call void @cache_fresh_unlocked(%struct.cache_head* %old, %struct.cache_detail* %detail)
  call void @cache_put.954(%struct.cache_head* %old, %struct.cache_detail* %detail)
  br label %cleanup

cleanup:                                          ; preds = %if.end44, %if.then29, %if.end
  %retval.0 = phi %struct.cache_head* [ %call27, %if.end44 ], [ null, %if.then29 ], [ %old, %if.end ]
  ret %struct.cache_head* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @cache_init(%struct.cache_head* %h) #0 {
entry:
  %call = call i64 @seconds_since_boot()
  %next = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 0
  store %struct.cache_head* null, %struct.cache_head** %next, align 8, !tbaa !984
  %flags = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 4
  store i64 0, i64* %flags, align 8, !tbaa !986
  %ref = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 3
  call void @kref_init.1033(%struct.arch_spinlock* %ref)
  %add = add nsw i64 %call, 120
  %expiry_time = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 1
  store i64 %add, i64* %expiry_time, align 8, !tbaa !828
  %last_refresh = getelementptr inbounds %struct.cache_head, %struct.cache_head* %h, i32 0, i32 2
  store i64 %call, i64* %last_refresh, align 8, !tbaa !987
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_init.1033(%struct.arch_spinlock* %kref) #2 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  call void @atomic_set.1027(%struct.atomic_t* %refcount, i32 1)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.cache_head* @sunrpc_cache_lookup(%struct.cache_detail* %detail, %struct.cache_head* %key, i32 %hash) #0 {
entry:
  %hash_table = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 2
  %0 = load %struct.cache_head**, %struct.cache_head*** %hash_table, align 8, !tbaa !982
  %idxprom = sext i32 %hash to i64
  %arrayidx = getelementptr inbounds %struct.cache_head*, %struct.cache_head** %0, i64 %idxprom
  %hash_lock = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 3
  call void @_raw_read_lock(%struct.rwlock_t* %hash_lock)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %hp.0 = phi %struct.cache_head** [ %arrayidx, %entry ], [ %next, %for.inc ]
  %retval.0 = phi %struct.cache_head* [ undef, %entry ], [ %retval.1, %for.inc ]
  %1 = load %struct.cache_head*, %struct.cache_head** %hp.0, align 8, !tbaa !28
  %cmp = icmp ne %struct.cache_head* %1, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.cache_head*, %struct.cache_head** %hp.0, align 8, !tbaa !28
  %match = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 13
  %3 = load i32 (%struct.cache_head*, %struct.cache_head*)*, i32 (%struct.cache_head*, %struct.cache_head*)** %match, align 8, !tbaa !1019
  %call = call i32 %3(%struct.cache_head* %2, %struct.cache_head* %key)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %NodeBlock

if.then:                                          ; preds = %for.body
  %call1 = call i32 @cache_is_expired(%struct.cache_detail* %detail, %struct.cache_head* %2)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %NodeBlock, label %if.end

if.end:                                           ; preds = %if.then
  %call4 = call %struct.cache_head* @cache_get.961(%struct.cache_head* %2)
  %hash_lock5 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 3
  call void @_raw_read_unlock(%struct.rwlock_t* %hash_lock5)
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end, %if.then, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.end ], [ 2, %if.then ], [ 0, %for.body ]
  %retval.1 = phi %struct.cache_head* [ %2, %if.end ], [ %retval.0, %if.then ], [ %retval.0, %for.body ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf2, label %for.end, label %cleanup43

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup43

for.inc:                                          ; preds = %LeafBlock
  %4 = load %struct.cache_head*, %struct.cache_head** %hp.0, align 8, !tbaa !28
  %next = getelementptr inbounds %struct.cache_head, %struct.cache_head* %4, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %LeafBlock1, %for.cond
  %retval.2 = phi %struct.cache_head* [ %retval.1, %LeafBlock1 ], [ %retval.0, %for.cond ]
  %hash_lock7 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 3
  call void @_raw_read_unlock(%struct.rwlock_t* %hash_lock7)
  %alloc = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 12
  %5 = load %struct.cache_head* ()*, %struct.cache_head* ()** %alloc, align 8, !tbaa !1017
  %call8 = call %struct.cache_head* %5()
  %tobool9 = icmp ne %struct.cache_head* %call8, null
  br i1 %tobool9, label %if.end11, label %cleanup43

if.end11:                                         ; preds = %for.end
  call void @cache_init(%struct.cache_head* %call8)
  %init = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 14
  %6 = load void (%struct.cache_head*, %struct.cache_head*)*, void (%struct.cache_head*, %struct.cache_head*)** %init, align 8, !tbaa !1018
  call void %6(%struct.cache_head* %call8, %struct.cache_head* %key)
  %hash_lock12 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 3
  call void @_raw_write_lock(%struct.rwlock_t* %hash_lock12)
  br label %for.cond13

for.cond13:                                       ; preds = %for.inc33, %if.end11
  %hp.1 = phi %struct.cache_head** [ %arrayidx, %if.end11 ], [ %next34, %for.inc33 ]
  %freeme.0 = phi %struct.cache_head* [ null, %if.end11 ], [ %freeme.1, %for.inc33 ]
  %retval.3 = phi %struct.cache_head* [ %retval.2, %if.end11 ], [ %retval.4, %for.inc33 ]
  %7 = load %struct.cache_head*, %struct.cache_head** %hp.1, align 8, !tbaa !28
  %cmp14 = icmp ne %struct.cache_head* %7, null
  br i1 %cmp14, label %for.body15, label %for.end35

for.body15:                                       ; preds = %for.cond13
  %8 = load %struct.cache_head*, %struct.cache_head** %hp.1, align 8, !tbaa !28
  %match17 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 13
  %9 = load i32 (%struct.cache_head*, %struct.cache_head*)*, i32 (%struct.cache_head*, %struct.cache_head*)** %match17, align 8, !tbaa !1019
  %call18 = call i32 %9(%struct.cache_head* %8, %struct.cache_head* %key)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.then20, label %NodeBlock8

if.then20:                                        ; preds = %for.body15
  %call21 = call i32 @cache_is_expired(%struct.cache_detail* %detail, %struct.cache_head* %8)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.then20
  %next24 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %8, i32 0, i32 0
  %10 = load %struct.cache_head*, %struct.cache_head** %next24, align 8, !tbaa !984
  store %struct.cache_head* %10, %struct.cache_head** %hp.1, align 8, !tbaa !28
  %next25 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %8, i32 0, i32 0
  store %struct.cache_head* null, %struct.cache_head** %next25, align 8, !tbaa !984
  %entries = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 19
  %11 = load i32, i32* %entries, align 8, !tbaa !1007
  %dec = add nsw i32 %11, -1
  store i32 %dec, i32* %entries, align 8, !tbaa !1007
  br label %NodeBlock8

if.end26:                                         ; preds = %if.then20
  %call27 = call %struct.cache_head* @cache_get.961(%struct.cache_head* %8)
  %hash_lock28 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 3
  call void @_raw_write_unlock(%struct.rwlock_t* %hash_lock28)
  call void @cache_put.954(%struct.cache_head* %call8, %struct.cache_detail* %detail)
  br label %NodeBlock8

NodeBlock8:                                       ; preds = %if.end26, %if.then23, %for.body15
  %freeme.1 = phi %struct.cache_head* [ %8, %if.then23 ], [ %freeme.0, %if.end26 ], [ %freeme.0, %for.body15 ]
  %cleanup.dest.slot.1 = phi i32 [ 5, %if.then23 ], [ 1, %if.end26 ], [ 0, %for.body15 ]
  %retval.4 = phi %struct.cache_head* [ %retval.3, %if.then23 ], [ %8, %if.end26 ], [ %retval.3, %for.body15 ]
  %Pivot9 = icmp slt i32 %cleanup.dest.slot.1, 5
  br i1 %Pivot9, label %LeafBlock4, label %LeafBlock6

LeafBlock6:                                       ; preds = %NodeBlock8
  %SwitchLeaf7 = icmp eq i32 %cleanup.dest.slot.1, 5
  br i1 %SwitchLeaf7, label %for.end35, label %cleanup43

LeafBlock4:                                       ; preds = %NodeBlock8
  %SwitchLeaf5 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf5, label %for.inc33, label %cleanup43

for.inc33:                                        ; preds = %LeafBlock4
  %12 = load %struct.cache_head*, %struct.cache_head** %hp.1, align 8, !tbaa !28
  %next34 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %12, i32 0, i32 0
  br label %for.cond13

for.end35:                                        ; preds = %LeafBlock6, %for.cond13
  %freeme.2 = phi %struct.cache_head* [ %freeme.1, %LeafBlock6 ], [ %freeme.0, %for.cond13 ]
  %13 = load %struct.cache_head*, %struct.cache_head** %arrayidx, align 8, !tbaa !28
  %next36 = getelementptr inbounds %struct.cache_head, %struct.cache_head* %call8, i32 0, i32 0
  store %struct.cache_head* %13, %struct.cache_head** %next36, align 8, !tbaa !984
  store %struct.cache_head* %call8, %struct.cache_head** %arrayidx, align 8, !tbaa !28
  %entries37 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 19
  %14 = load i32, i32* %entries37, align 8, !tbaa !1007
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %entries37, align 8, !tbaa !1007
  %call38 = call %struct.cache_head* @cache_get.961(%struct.cache_head* %call8)
  %hash_lock39 = getelementptr inbounds %struct.cache_detail, %struct.cache_detail* %detail, i32 0, i32 3
  call void @_raw_write_unlock(%struct.rwlock_t* %hash_lock39)
  %tobool40 = icmp ne %struct.cache_head* %freeme.2, null
  br i1 %tobool40, label %if.then41, label %cleanup43

if.then41:                                        ; preds = %for.end35
  call void @cache_put.954(%struct.cache_head* %freeme.2, %struct.cache_detail* %detail)
  br label %cleanup43

cleanup43:                                        ; preds = %if.then41, %for.end35, %LeafBlock4, %LeafBlock6, %for.end, %LeafBlock, %LeafBlock1
  %retval.5 = phi %struct.cache_head* [ null, %for.end ], [ %call8, %if.then41 ], [ %call8, %for.end35 ], [ %retval.1, %LeafBlock ], [ %retval.1, %LeafBlock1 ], [ %retval.4, %LeafBlock4 ], [ %retval.4, %LeafBlock6 ]
  ret %struct.cache_head* %retval.5
}

; Function Attrs: nounwind uwtable
define void @cache_clean_deferred(i8* %owner) #0 {
entry:
  %pending = alloca %struct.list_head, align 8
  call void @INIT_LIST_HEAD.970(%struct.list_head* %pending)
  call void @spin_lock.935(%struct.spinlock* @cache_defer_lock)
  %0 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.list_head, %struct.list_head* @cache_defer_list, i32 0, i32 0), align 8, !tbaa !164
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -16
  %2 = bitcast i8* %add.ptr to %struct.cache_deferred_req*
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %.sink = phi %struct.cache_deferred_req* [ %5, %for.inc ], [ %2, %entry ]
  %dreq.0 = phi %struct.cache_deferred_req* [ %2, %entry ], [ %5, %for.inc ]
  %recent10 = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %.sink, i32 0, i32 1
  %next11 = getelementptr inbounds %struct.list_head, %struct.list_head* %recent10, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next11, align 8, !tbaa !1020
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr13 = getelementptr inbounds i8, i8* %4, i64 -16
  %5 = bitcast i8* %add.ptr13 to %struct.cache_deferred_req*
  %recent5 = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %dreq.0, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %recent5, @cache_defer_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %owner6 = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %dreq.0, i32 0, i32 3
  %6 = load i8*, i8** %owner6, align 8, !tbaa !1021
  %cmp7 = icmp eq i8* %6, %owner
  br i1 %cmp7, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @__unhash_deferred_req(%struct.cache_deferred_req* %dreq.0)
  %recent8 = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %dreq.0, i32 0, i32 1
  call void @list_add.941(%struct.list_head* %recent8, %struct.list_head* %pending)
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @spin_unlock.936(%struct.spinlock* @cache_defer_lock)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %call = call i32 @list_empty.968(%struct.list_head* %pending)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %next15 = getelementptr inbounds %struct.list_head, %struct.list_head* %pending, i32 0, i32 0
  %7 = load %struct.list_head*, %struct.list_head** %next15, align 8, !tbaa !164
  %8 = bitcast %struct.list_head* %7 to i8*
  %add.ptr17 = getelementptr inbounds i8, i8* %8, i64 -16
  %9 = bitcast i8* %add.ptr17 to %struct.cache_deferred_req*
  %recent18 = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %9, i32 0, i32 1
  call void @list_del_init.969(%struct.list_head* %recent18)
  %revisit = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %9, i32 0, i32 4
  %10 = load void (%struct.cache_deferred_req*, i32)*, void (%struct.cache_deferred_req*, i32)** %revisit, align 8, !tbaa !996
  call void %10(%struct.cache_deferred_req* %9, i32 1)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define void @cache_initialize() #6 section ".init.text" {
entry:
  %.compoundliteral = alloca %struct.pgprot, align 8
  call void @__init_work(%struct.work_struct* getelementptr inbounds (%struct.delayed_work, %struct.delayed_work* @cache_cleaner, i32 0, i32 0), i32 0)
  %counter = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !339
  %0 = bitcast %struct.pgprot* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* bitcast (%struct.delayed_work* @cache_cleaner to i8*), i8* %0, i64 8, i32 8, i1 false), !tbaa.struct !340
  call void @lockdep_init_map(%struct.lockdep_map* getelementptr inbounds (%struct.delayed_work, %struct.delayed_work* @cache_cleaner, i32 0, i32 0, i32 3), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.4.1040, i32 0, i32 0), %struct.lock_class_key* @cache_initialize.__key, i32 0)
  call void @INIT_LIST_HEAD.970(%struct.list_head* getelementptr inbounds (%struct.delayed_work, %struct.delayed_work* @cache_cleaner, i32 0, i32 0, i32 1))
  store void (%struct.work_struct*)* @do_cache_clean, void (%struct.work_struct*)** getelementptr inbounds (%struct.delayed_work, %struct.delayed_work* @cache_cleaner, i32 0, i32 0, i32 2), align 8, !tbaa !341
  call void @init_timer_key(%struct.timer_list* getelementptr inbounds (%struct.delayed_work, %struct.delayed_work* @cache_cleaner, i32 0, i32 1), i32 3, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.6.1041, i32 0, i32 0), %struct.lock_class_key* @cache_initialize.__key.5)
  store void (i64)* @delayed_work_timer_fn, void (i64)** getelementptr inbounds (%struct.delayed_work, %struct.delayed_work* @cache_cleaner, i32 0, i32 1, i32 3), align 8, !tbaa !342
  store i64 ptrtoint (%struct.delayed_work* @cache_cleaner to i64), i64* getelementptr inbounds (%struct.delayed_work, %struct.delayed_work* @cache_cleaner, i32 0, i32 1, i32 4), align 8, !tbaa !343
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @do_cache_clean(%struct.work_struct* %work) #0 {
entry:
  %call = call i32 @cache_clean()
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i64 @round_jiffies_relative(i64 7500)
  %conv = trunc i64 %call1 to i32
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %delay.0 = phi i32 [ %conv, %if.then ], [ 5, %entry ]
  %call2 = call i32 @list_empty.968(%struct.list_head* @cache_list)
  %tobool = icmp ne i32 %call2, 0
  %.delay.0 = select i1 %tobool, i32 0, i32 %delay.0
  %tobool5 = icmp ne i32 %.delay.0, 0
  br i1 %tobool5, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.end
  %conv7 = sext i32 %.delay.0 to i64
  call void @schedule_delayed_work(%struct.delayed_work* @cache_cleaner, i64 %conv7)
  br label %if.end9

if.end9:                                          ; preds = %if.then6, %if.end
  ret void
}

declare i64 @round_jiffies_relative(i64) #4

; Function Attrs: nounwind uwtable
define void @rpc_put_sb_net(%struct.net* %net) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.1045(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %pipefs_sb = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 5
  %2 = load %struct.super_block*, %struct.super_block** %pipefs_sb, align 8, !tbaa !1022
  %cmp = icmp eq %struct.super_block* %2, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1.1046, i32 0, i32 0), i32 1101)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %pipefs_sb_lock = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 6
  call void @mutex_unlock(%struct.mutex* %pipefs_sb_lock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @net_generic.1045(%struct.net* %net, i32 %id) #2 {
entry:
  call void @rcu_read_lock.1047()
  %gen = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 37
  %0 = load volatile %struct.net_generic*, %struct.net_generic** %gen, align 16, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.body8

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @net_generic.__warned.1048, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %do.body8, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held.1049()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.body8, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @net_generic.__warned.1048, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 40, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.body8

do.body8:                                         ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %cmp = icmp eq i32 %id, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.body8
  %len = getelementptr inbounds %struct.net_generic, %struct.net_generic* %0, i32 0, i32 0
  %2 = load i32, i32* %len, align 8, !tbaa !176
  %cmp9 = icmp ugt i32 %id, %2
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %do.body8
  %3 = phi i1 [ true, %do.body8 ], [ %cmp9, %lor.rhs ]
  %lnot = xor i1 %3, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %do.body13, label %do.end21

do.body13:                                        ; preds = %lor.end
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 41, i64 12) #7, !srcloc !1023
  br label %do.body14

do.body14:                                        ; preds = %do.body14, %do.body13
  br label %do.body14

do.end21:                                         ; preds = %lor.end
  %ptr22 = getelementptr inbounds %struct.net_generic, %struct.net_generic* %0, i32 0, i32 2
  %sub = sub nsw i32 %id, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [0 x i8*], [0 x i8*]* %ptr22, i64 0, i64 %idxprom
  %4 = load i8*, i8** %arrayidx, align 8, !tbaa !28
  call void @rcu_read_unlock.1052()
  %tobool24 = icmp ne i8* %4, null
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %do.body35, label %do.end43

do.body35:                                        ; preds = %do.end21
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 45, i64 12) #7, !srcloc !1024
  br label %do.body36

do.body36:                                        ; preds = %do.body36, %do.body35
  br label %do.body36

do.end43:                                         ; preds = %do.end21
  ret i8* %4
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock.1047() #2 {
entry:
  call void @__rcu_read_lock.1059()
  call void @rcu_lock_acquire.1060(%struct.lockdep_map* @rcu_lock_map)
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_lock.__warned.1061, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_lock.__warned.1061, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 780, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.15.1329, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rcu_read_lock_held.1049() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call1 = call i32 @rcu_is_cpu_idle()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call zeroext i1 @rcu_lockdep_current_cpu_online()
  br i1 %call5, label %if.end7, label %return

if.end7:                                          ; preds = %if.end4
  %call8 = call i32 @lock_is_held(%struct.lockdep_map* @rcu_lock_map)
  br label %return

return:                                           ; preds = %if.end7, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call8, %if.end7 ], [ 1, %entry ], [ 0, %if.end ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_unlock.1052() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_unlock.__warned.1053, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_unlock.__warned.1053, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 801, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.16.1322, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  call void @rcu_lock_release.1056(%struct.lockdep_map* @rcu_lock_map)
  call void @__rcu_read_unlock.1057()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_release.1056(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_release(%struct.lockdep_map* %map, i32 1, i64 ptrtoint (i8* blockaddress(@rcu_lock_release.1056, %__here) to i64))
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_unlock.1057() #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !1025
  %call = call %struct.thread_info* @current_thread_info.1058()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !1026
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.1058() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !1027
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_lock.1059() #2 {
entry:
  %call = call %struct.thread_info* @current_thread_info.1058()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !1028
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_acquire.1060(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_acquire(%struct.lockdep_map* %map, i32 0, i32 0, i32 2, i32 1, %struct.lockdep_map* null, i64 ptrtoint (i8* blockaddress(@rcu_lock_acquire.1060, %__here) to i64))
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.super_block* @rpc_get_sb_net(%struct.net* %net) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.1045(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %pipefs_sb_lock = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 6
  call void @mutex_lock_nested(%struct.mutex* %pipefs_sb_lock, i32 0)
  %pipefs_sb = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 5
  %2 = load %struct.super_block*, %struct.super_block** %pipefs_sb, align 8, !tbaa !1022
  %tobool = icmp ne %struct.super_block* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %pipefs_sb1 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 5
  %3 = load %struct.super_block*, %struct.super_block** %pipefs_sb1, align 8, !tbaa !1022
  br label %cleanup

if.end:                                           ; preds = %entry
  %pipefs_sb_lock2 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 6
  call void @mutex_unlock(%struct.mutex* %pipefs_sb_lock2)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi %struct.super_block* [ %3, %if.then ], [ null, %if.end ]
  ret %struct.super_block* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.dentry* @rpc_d_lookup_sb(%struct.super_block* %sb, i8* %dir_name) #0 {
entry:
  %dir = alloca %struct.qstr, align 8
  %0 = getelementptr inbounds %struct.qstr, %struct.qstr* %dir, i32 0, i32 0
  %1 = bitcast %struct.pgprot* %0 to %struct.exception_table_entry*
  %hash = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %1, i32 0, i32 0
  store i32 0, i32* %hash, align 8, !tbaa !1029
  %len = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %1, i32 0, i32 1
  %call = call i64 @strlen(i8* %dir_name)
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %len, align 4, !tbaa !1030
  %name = getelementptr inbounds %struct.qstr, %struct.qstr* %dir, i32 0, i32 1
  store i8* %dir_name, i8** %name, align 8, !tbaa !245
  %name1 = getelementptr inbounds %struct.qstr, %struct.qstr* %dir, i32 0, i32 1
  %2 = load i8*, i8** %name1, align 8, !tbaa !245
  %3 = getelementptr inbounds %struct.qstr, %struct.qstr* %dir, i32 0, i32 0
  %4 = bitcast %struct.pgprot* %3 to %struct.exception_table_entry*
  %len2 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %4, i32 0, i32 1
  %5 = load i32, i32* %len2, align 4, !tbaa !166
  %call3 = call i32 @full_name_hash(i8* %2, i32 %5)
  %6 = getelementptr inbounds %struct.qstr, %struct.qstr* %dir, i32 0, i32 0
  %7 = bitcast %struct.pgprot* %6 to %struct.exception_table_entry*
  %hash4 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %7, i32 0, i32 0
  store i32 %call3, i32* %hash4, align 8, !tbaa !166
  %s_root = getelementptr inbounds %struct.super_block, %struct.super_block* %sb, i32 0, i32 12
  %8 = load %struct.dentry*, %struct.dentry** %s_root, align 32, !tbaa !1031
  %call5 = call %struct.dentry* @d_lookup(%struct.dentry* %8, %struct.qstr* %dir)
  ret %struct.dentry* %call5
}

declare %struct.dentry* @d_lookup(%struct.dentry*, %struct.qstr*) #4

; Function Attrs: nounwind uwtable
define i32 @rpc_unlink(%struct.dentry* %dentry) #0 {
entry:
  %call = call %struct.dentry* @dget_parent(%struct.dentry* %dentry)
  %d_inode = getelementptr inbounds %struct.dentry, %struct.dentry* %call, i32 0, i32 5
  %0 = load %struct.inode*, %struct.inode** %d_inode, align 8, !tbaa !1032
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 1)
  %call1 = call i32 @__rpc_rmpipe(%struct.inode* %0, %struct.dentry* %dentry)
  %i_mutex2 = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex2)
  call void @dput(%struct.dentry* %call)
  ret i32 %call1
}

declare %struct.dentry* @dget_parent(%struct.dentry*) #4

; Function Attrs: nounwind uwtable
define internal i32 @__rpc_rmpipe(%struct.inode* %dir, %struct.dentry* %dentry) #0 {
entry:
  %d_inode = getelementptr inbounds %struct.dentry, %struct.dentry* %dentry, i32 0, i32 5
  %0 = load %struct.inode*, %struct.inode** %d_inode, align 8, !tbaa !1032
  call void @rpc_close_pipes(%struct.inode* %0)
  %call = call i32 @__rpc_unlink(%struct.inode* %dir, %struct.dentry* %dentry)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @rpc_close_pipes(%struct.inode* %inode) #0 {
entry:
  %free_list = alloca %struct.list_head, align 8
  %call = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %inode)
  %pipe1 = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call, i32 0, i32 2
  %0 = load %struct.rpc_pipe*, %struct.rpc_pipe** %pipe1, align 8, !tbaa !1035
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %free_list, i32 0, i32 0
  store %struct.list_head* %free_list, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %free_list, i32 0, i32 1
  store %struct.list_head* %free_list, %struct.list_head** %prev, align 8, !tbaa !163
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 0)
  %lock = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 9
  call void @spin_lock.1067(%struct.spinlock* %lock)
  %nreaders = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 4
  %1 = load i32, i32* %nreaders, align 4, !tbaa !1036
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %nwriters = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 5
  %2 = load i32, i32* %nwriters, align 8, !tbaa !1038
  %cmp2 = icmp ne i32 %2, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  %lor.ext = zext i1 %3 to i32
  %nreaders3 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 4
  store i32 0, i32* %nreaders3, align 4, !tbaa !1036
  %in_upcall = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 1
  call void @list_splice_init.1070(%struct.list_head* %in_upcall, %struct.list_head* %free_list)
  %pipe4 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 0
  call void @list_splice_init.1070(%struct.list_head* %pipe4, %struct.list_head* %free_list)
  %pipelen = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 3
  store i32 0, i32* %pipelen, align 8, !tbaa !1039
  %dentry = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 10
  store %struct.dentry* null, %struct.dentry** %dentry, align 8, !tbaa !1040
  %lock5 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 9
  call void @spin_unlock.1068(%struct.spinlock* %lock5)
  %call6 = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %inode)
  %waitq = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call6, i32 0, i32 3
  %ops = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 8
  %4 = load %struct.rpc_pipe_ops*, %struct.rpc_pipe_ops** %ops, align 8, !tbaa !1041
  %destroy_msg = getelementptr inbounds %struct.rpc_pipe_ops, %struct.rpc_pipe_ops* %4, i32 0, i32 4
  %5 = load void (%struct.rpc_pipe_msg*)*, void (%struct.rpc_pipe_msg*)** %destroy_msg, align 8, !tbaa !1042
  call void @rpc_purge_list(%struct.__wait_queue_head* %waitq, %struct.list_head* %free_list, void (%struct.rpc_pipe_msg*)* %5, i32 -32)
  %nwriters7 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 5
  store i32 0, i32* %nwriters7, align 8, !tbaa !1038
  %tobool = icmp ne i32 %lor.ext, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.end
  %ops8 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 8
  %6 = load %struct.rpc_pipe_ops*, %struct.rpc_pipe_ops** %ops8, align 8, !tbaa !1041
  %release_pipe = getelementptr inbounds %struct.rpc_pipe_ops, %struct.rpc_pipe_ops* %6, i32 0, i32 2
  %7 = load void (%struct.inode*)*, void (%struct.inode*)** %release_pipe, align 8, !tbaa !1044
  %tobool9 = icmp ne void (%struct.inode*)* %7, null
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %ops10 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 8
  %8 = load %struct.rpc_pipe_ops*, %struct.rpc_pipe_ops** %ops10, align 8, !tbaa !1041
  %release_pipe11 = getelementptr inbounds %struct.rpc_pipe_ops, %struct.rpc_pipe_ops* %8, i32 0, i32 2
  %9 = load void (%struct.inode*)*, void (%struct.inode*)** %release_pipe11, align 8, !tbaa !1044
  call void %9(%struct.inode* %inode)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %lor.end
  %queue_timeout = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 7
  %call12 = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* %queue_timeout)
  call void @rpc_inode_setowner(%struct.inode* %inode, i8* null)
  %call13 = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %inode)
  %pipe14 = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call13, i32 0, i32 2
  store %struct.rpc_pipe* null, %struct.rpc_pipe** %pipe14, align 8, !tbaa !1035
  %i_mutex15 = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex15)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @__rpc_unlink(%struct.inode* %dir, %struct.dentry* %dentry) #0 {
entry:
  %call = call %struct.dentry* @dget(%struct.dentry* %dentry)
  %call1 = call i32 @simple_unlink(%struct.inode* %dir, %struct.dentry* %dentry)
  call void @d_delete(%struct.dentry* %dentry)
  call void @dput(%struct.dentry* %dentry)
  ret i32 %call1
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.dentry* @dget(%struct.dentry* %dentry) #2 {
entry:
  %tobool = icmp ne %struct.dentry* %dentry, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %d_lock = getelementptr inbounds %struct.dentry, %struct.dentry* %dentry, i32 0, i32 8
  call void @spin_lock.1067(%struct.spinlock* %d_lock)
  call void @dget_dlock(%struct.dentry* %dentry)
  %d_lock1 = getelementptr inbounds %struct.dentry, %struct.dentry* %dentry, i32 0, i32 8
  call void @spin_unlock.1068(%struct.spinlock* %d_lock1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.dentry* %dentry
}

declare i32 @simple_unlink(%struct.inode*, %struct.dentry*) #4

declare void @d_delete(%struct.dentry*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock.1067(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @dget_dlock(%struct.dentry* %dentry) #2 {
entry:
  %tobool = icmp ne %struct.dentry* %dentry, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %d_count = getelementptr inbounds %struct.dentry, %struct.dentry* %dentry, i32 0, i32 7
  %0 = load i32, i32* %d_count, align 8, !tbaa !1045
  %inc = add i32 %0, 1
  store i32 %inc, i32* %d_count, align 8, !tbaa !1045
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock.1068(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.rpc_inode* @RPC_I.1069(%struct.inode* %inode) #2 {
entry:
  %0 = bitcast %struct.inode* %inode to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.rpc_inode*
  ret %struct.rpc_inode* %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_splice_init.1070(%struct.list_head* %list, %struct.list_head* %head) #2 {
entry:
  %call = call i32 @list_empty.1071(%struct.list_head* %list)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  call void @__list_splice.1074(%struct.list_head* %list, %struct.list_head* %head, %struct.list_head* %0)
  call void @INIT_LIST_HEAD.1073(%struct.list_head* %list)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_purge_list(%struct.__wait_queue_head* %waitq, %struct.list_head* %head, void (%struct.rpc_pipe_msg*)* %destroy_msg, i32 %err) #0 {
entry:
  %call = call i32 @list_empty.1071(%struct.list_head* %head)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %do.body, %if.end
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.rpc_pipe_msg*
  %list = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %2, i32 0, i32 0
  call void @list_del_init.1072(%struct.list_head* %list)
  %errno = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %2, i32 0, i32 4
  store i32 %err, i32* %errno, align 8, !tbaa !1046
  call void %destroy_msg(%struct.rpc_pipe_msg* %2)
  %call1 = call i32 @list_empty.1071(%struct.list_head* %head)
  %tobool2 = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool2, true
  br i1 %lnot, label %do.body, label %do.end

do.end:                                           ; preds = %do.body
  %tobool3 = icmp ne %struct.__wait_queue_head* %waitq, null
  br i1 %tobool3, label %if.then4, label %cleanup.cont

if.then4:                                         ; preds = %do.end
  call void @__wake_up(%struct.__wait_queue_head* %waitq, i32 3, i32 1, i8* null)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then4, %do.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rpc_inode_setowner(%struct.inode* %inode, i8* %private) #2 {
entry:
  %call = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %inode)
  %private1 = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call, i32 0, i32 1
  store i8* %private, i8** %private1, align 8, !tbaa !941
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty.1071(%struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init.1072(%struct.list_head* %entry1) #2 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD.1073(%struct.list_head* %entry1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.1073(%struct.list_head* %list) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !163
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_splice.1074(%struct.list_head* %list, %struct.list_head* %prev, %struct.list_head* %next) #2 {
entry:
  %next1 = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next1, align 8, !tbaa !164
  %prev2 = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  %1 = load %struct.list_head*, %struct.list_head** %prev2, align 8, !tbaa !163
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !163
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  store %struct.list_head* %0, %struct.list_head** %next4, align 8, !tbaa !164
  %next5 = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next5, align 8, !tbaa !164
  %prev6 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %1, %struct.list_head** %prev6, align 8, !tbaa !163
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.dentry* @rpc_mkpipe_dentry(%struct.dentry* %parent, i8* %name, i8* %private, %struct.rpc_pipe* %pipe) #0 {
entry:
  %q = alloca %struct.qstr, align 8
  %d_inode = getelementptr inbounds %struct.dentry, %struct.dentry* %parent, i32 0, i32 5
  %0 = load %struct.inode*, %struct.inode** %d_inode, align 8, !tbaa !1032
  %ops = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 8
  %1 = load %struct.rpc_pipe_ops*, %struct.rpc_pipe_ops** %ops, align 8, !tbaa !1041
  %upcall = getelementptr inbounds %struct.rpc_pipe_ops, %struct.rpc_pipe_ops* %1, i32 0, i32 0
  %2 = load i64 (%struct.file*, %struct.rpc_pipe_msg*, i8*, i64)*, i64 (%struct.file*, %struct.rpc_pipe_msg*, i8*, i64)** %upcall, align 8, !tbaa !1048
  %cmp = icmp eq i64 (%struct.file*, %struct.rpc_pipe_msg*, i8*, i64)* %2, null
  %conv = zext i16 4480 to i32
  %and = and i32 %conv, -293
  %conv1 = trunc i32 %and to i16
  %umode.0 = select i1 %cmp, i16 %conv1, i16 4480
  %ops2 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 8
  %3 = load %struct.rpc_pipe_ops*, %struct.rpc_pipe_ops** %ops2, align 8, !tbaa !1041
  %downcall = getelementptr inbounds %struct.rpc_pipe_ops, %struct.rpc_pipe_ops* %3, i32 0, i32 1
  %4 = load i64 (%struct.file*, i8*, i64)*, i64 (%struct.file*, i8*, i64)** %downcall, align 8, !tbaa !1049
  %cmp3 = icmp eq i64 (%struct.file*, i8*, i64)* %4, null
  %conv6 = zext i16 %umode.0 to i32
  %and7 = and i32 %conv6, -147
  %conv8 = trunc i32 %and7 to i16
  %umode.1 = select i1 %cmp3, i16 %conv8, i16 %umode.0
  %name10 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 1
  store i8* %name, i8** %name10, align 8, !tbaa !245
  %call = call i64 @strlen(i8* %name)
  %conv11 = trunc i64 %call to i32
  %5 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 0
  %6 = bitcast %struct.pgprot* %5 to %struct.exception_table_entry*
  %len = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %6, i32 0, i32 1
  store i32 %conv11, i32* %len, align 4, !tbaa !166
  %name12 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 1
  %7 = load i8*, i8** %name12, align 8, !tbaa !245
  %8 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 0
  %9 = bitcast %struct.pgprot* %8 to %struct.exception_table_entry*
  %len13 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %9, i32 0, i32 1
  %10 = load i32, i32* %len13, align 4, !tbaa !166
  %call14 = call i32 @full_name_hash(i8* %7, i32 %10)
  %11 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 0
  %12 = bitcast %struct.pgprot* %11 to %struct.exception_table_entry*
  %hash = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %12, i32 0, i32 0
  store i32 %call14, i32* %hash, align 8, !tbaa !166
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 1)
  %call15 = call %struct.dentry* @__rpc_lookup_create_exclusive(%struct.dentry* %parent, %struct.qstr* %q)
  %13 = bitcast %struct.dentry* %call15 to i8*
  %call16 = call i64 @IS_ERR.1075(i8* %13)
  %tobool = icmp ne i64 %call16, 0
  br i1 %tobool, label %out, label %if.end18

if.end18:                                         ; preds = %entry
  %call19 = call i32 @__rpc_mkpipe_dentry(%struct.inode* %0, %struct.dentry* %call15, i16 zeroext %umode.1, %struct.file_operations* @rpc_pipe_fops, i8* %private, %struct.rpc_pipe* %pipe)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %out_err, label %out

out:                                              ; preds = %out_err, %if.end18, %entry
  %dentry.0 = phi %struct.dentry* [ %14, %out_err ], [ %call15, %entry ], [ %call15, %if.end18 ]
  %i_mutex23 = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex23)
  ret %struct.dentry* %dentry.0

out_err:                                          ; preds = %if.end18
  %conv24 = sext i32 %call19 to i64
  %call25 = call i8* @ERR_PTR.1076(i64 %conv24)
  %14 = bitcast i8* %call25 to %struct.dentry*
  %15 = call i32 (i8*, ...) @printk(i8* null)
  br label %out
}

; Function Attrs: nounwind uwtable
define internal %struct.dentry* @__rpc_lookup_create_exclusive(%struct.dentry* %parent, %struct.qstr* %name) #0 {
entry:
  %call = call %struct.dentry* @d_lookup(%struct.dentry* %parent, %struct.qstr* %name)
  %tobool = icmp ne %struct.dentry* %call, null
  br i1 %tobool, label %if.end5, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call %struct.dentry* @d_alloc(%struct.dentry* %parent, %struct.qstr* %name)
  %tobool2 = icmp ne %struct.dentry* %call1, null
  br i1 %tobool2, label %if.end5, label %if.then3

if.then3:                                         ; preds = %if.then
  %call4 = call i8* @ERR_PTR.1076(i64 -12)
  %0 = bitcast i8* %call4 to %struct.dentry*
  br label %cleanup

if.end5:                                          ; preds = %if.then, %entry
  %dentry.0 = phi %struct.dentry* [ %call, %entry ], [ %call1, %if.then ]
  %d_inode = getelementptr inbounds %struct.dentry, %struct.dentry* %dentry.0, i32 0, i32 5
  %1 = load %struct.inode*, %struct.inode** %d_inode, align 8, !tbaa !1032
  %cmp = icmp eq %struct.inode* %1, null
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end5
  call void @d_set_d_op(%struct.dentry* %dentry.0, %struct.dentry_operations* @rpc_dentry_operations)
  br label %cleanup

if.end7:                                          ; preds = %if.end5
  call void @dput(%struct.dentry* %dentry.0)
  %call8 = call i8* @ERR_PTR.1076(i64 -17)
  %2 = bitcast i8* %call8 to %struct.dentry*
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %if.then6, %if.then3
  %retval.0 = phi %struct.dentry* [ %dentry.0, %if.then6 ], [ %2, %if.end7 ], [ %0, %if.then3 ]
  ret %struct.dentry* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR.1075(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: nounwind uwtable
define internal i32 @__rpc_mkpipe_dentry(%struct.inode* %dir, %struct.dentry* %dentry, i16 zeroext %mode, %struct.file_operations* %i_fop, i8* %private, %struct.rpc_pipe* %pipe) #0 {
entry:
  %conv = zext i16 %mode to i32
  %or = or i32 4096, %conv
  %conv1 = trunc i32 %or to i16
  %call = call i32 @__rpc_create_common(%struct.inode* %dir, %struct.dentry* %dentry, i16 zeroext %conv1, %struct.file_operations* %i_fop, i8* %private)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %d_inode = getelementptr inbounds %struct.dentry, %struct.dentry* %dentry, i32 0, i32 5
  %0 = load %struct.inode*, %struct.inode** %d_inode, align 8, !tbaa !1032
  %call2 = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %0)
  %private3 = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call2, i32 0, i32 1
  store i8* %private, i8** %private3, align 8, !tbaa !941
  %pipe4 = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call2, i32 0, i32 2
  store %struct.rpc_pipe* %pipe, %struct.rpc_pipe** %pipe4, align 8, !tbaa !1035
  call void @fsnotify_create(%struct.inode* %dir, %struct.dentry* %dentry)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR.1076(i64 %error) #2 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @__rpc_create_common(%struct.inode* %dir, %struct.dentry* %dentry, i16 zeroext %mode, %struct.file_operations* %i_fop, i8* %private) #0 {
entry:
  call void @d_drop(%struct.dentry* %dentry)
  %i_sb = getelementptr inbounds %struct.inode, %struct.inode* %dir, i32 0, i32 8
  %0 = load %struct.super_block*, %struct.super_block** %i_sb, align 8, !tbaa !1050
  %call = call %struct.inode* @rpc_get_inode(%struct.super_block* %0, i16 zeroext %mode)
  %tobool = icmp ne %struct.inode* %call, null
  br i1 %tobool, label %if.end, label %out_err

if.end:                                           ; preds = %entry
  %i_sb1 = getelementptr inbounds %struct.inode, %struct.inode* %dir, i32 0, i32 8
  %1 = load %struct.super_block*, %struct.super_block** %i_sb1, align 8, !tbaa !1050
  %call2 = call i64 @iunique(%struct.super_block* %1, i64 100)
  %i_ino = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 11
  store i64 %call2, i64* %i_ino, align 8, !tbaa !1051
  %tobool3 = icmp ne %struct.file_operations* %i_fop, null
  br i1 %tobool3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %i_fop5 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 34
  store %struct.file_operations* %i_fop, %struct.file_operations** %i_fop5, align 8, !tbaa !1052
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end
  %tobool7 = icmp ne i8* %private, null
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  call void @rpc_inode_setowner(%struct.inode* %call, i8* %private)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  call void @d_add(%struct.dentry* %dentry, %struct.inode* %call)
  br label %cleanup

out_err:                                          ; preds = %entry
  %2 = call i32 (i8*, ...) @printk(i8* null)
  call void @dput(%struct.dentry* %dentry)
  br label %cleanup

cleanup:                                          ; preds = %out_err, %if.end9
  %retval.0 = phi i32 [ 0, %if.end9 ], [ -12, %out_err ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @fsnotify_create(%struct.inode* %inode, %struct.dentry* %dentry) #2 {
entry:
  call void @audit_inode_child(%struct.inode* %inode, %struct.dentry* %dentry, i8 zeroext 4)
  %d_inode = getelementptr inbounds %struct.dentry, %struct.dentry* %dentry, i32 0, i32 5
  %0 = load %struct.inode*, %struct.inode** %d_inode, align 8, !tbaa !1032
  %1 = bitcast %struct.inode* %0 to i8*
  %d_name = getelementptr inbounds %struct.dentry, %struct.dentry* %dentry, i32 0, i32 4
  %name = getelementptr inbounds %struct.qstr, %struct.qstr* %d_name, i32 0, i32 1
  %2 = load i8*, i8** %name, align 8, !tbaa !1053
  %call = call i32 @fsnotify(%struct.inode* %inode, i32 256, i8* %1, i32 2, i8* %2, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @audit_inode_child(%struct.inode* %parent, %struct.dentry* %dentry, i8 zeroext %type) #2 {
entry:
  %call = call i32 @audit_dummy_context()
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__audit_inode_child(%struct.inode* %parent, %struct.dentry* %dentry, i8 zeroext %type)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare i32 @fsnotify(%struct.inode*, i32, i8*, i32, i8*, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @audit_dummy_context() #2 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !1054
  %audit_context = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 87
  %1 = load %struct.audit_context*, %struct.audit_context** %audit_context, align 8, !tbaa !1055
  %2 = bitcast %struct.audit_context* %1 to i8*
  %tobool = icmp ne i8* %2, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %3 = bitcast i8* %2 to i32*
  %4 = load i32, i32* %3, align 4, !tbaa !49
  %tobool1 = icmp ne i32 %4, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %5 = phi i1 [ true, %entry ], [ %tobool1, %lor.rhs ]
  %lor.ext = zext i1 %5 to i32
  ret i32 %lor.ext
}

declare void @__audit_inode_child(%struct.inode*, %struct.dentry*, i8 zeroext) #4

declare void @d_drop(%struct.dentry*) #4

; Function Attrs: nounwind uwtable
define internal %struct.inode* @rpc_get_inode(%struct.super_block* %sb, i16 zeroext %mode) #0 {
entry:
  %coerce = alloca %struct.load_weight, align 8
  %call = call %struct.inode* @new_inode(%struct.super_block* %sb)
  %tobool = icmp ne %struct.inode* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @get_next_ino()
  %conv = zext i32 %call1 to i64
  %i_ino = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 11
  store i64 %conv, i64* %i_ino, align 8, !tbaa !1051
  %i_mode = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 0
  store i16 %mode, i16* %i_mode, align 8, !tbaa !1056
  %i_atime = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 15
  %i_mtime = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %i_ctime = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 17
  %call2 = call { i64, i64 } @current_kernel_time()
  %0 = bitcast %struct.load_weight* %coerce to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  %2 = extractvalue { i64, i64 } %call2, 0
  store i64 %2, i64* %1, align 8
  %3 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  %4 = extractvalue { i64, i64 } %call2, 1
  store i64 %4, i64* %3, align 8
  %5 = bitcast %struct.load_weight* %i_ctime to i8*
  %6 = bitcast %struct.load_weight* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 16, i32 8, i1 false), !tbaa.struct !1057
  %7 = bitcast %struct.load_weight* %i_mtime to i8*
  %8 = bitcast %struct.load_weight* %i_ctime to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 16, i32 8, i1 false), !tbaa.struct !1057
  %9 = bitcast %struct.load_weight* %i_atime to i8*
  %10 = bitcast %struct.load_weight* %i_mtime to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 16, i32 8, i1 false), !tbaa.struct !1057
  %conv3 = zext i16 %mode to i32
  %and = and i32 %conv3, 61440
  %SwitchLeaf = icmp eq i32 %and, 16384
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %if.end
  %i_fop = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 34
  store %struct.file_operations* @simple_dir_operations, %struct.file_operations** %i_fop, align 8, !tbaa !1052
  %i_op = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 7
  store %struct.inode_operations* @simple_dir_inode_operations, %struct.inode_operations** %i_op, align 8, !tbaa !1058
  call void @inc_nlink(%struct.inode* %call)
  br label %cleanup

cleanup:                                          ; preds = %sw.bb, %if.end, %entry
  %retval.0 = phi %struct.inode* [ null, %entry ], [ %call, %sw.bb ], [ %call, %if.end ]
  ret %struct.inode* %retval.0
}

declare i64 @iunique(%struct.super_block*, i64) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @d_add(%struct.dentry* %entry1, %struct.inode* %inode) #2 {
entry:
  call void @d_instantiate(%struct.dentry* %entry1, %struct.inode* %inode)
  call void @d_rehash(%struct.dentry* %entry1)
  ret void
}

declare void @d_instantiate(%struct.dentry*, %struct.inode*) #4

declare void @d_rehash(%struct.dentry*) #4

declare %struct.inode* @new_inode(%struct.super_block*) #4

declare i32 @get_next_ino() #4

declare { i64, i64 } @current_kernel_time() #4

declare void @inc_nlink(%struct.inode*) #4

; Function Attrs: nounwind uwtable
define internal i64 @rpc_pipe_read(%struct.file* %filp, i8* %buf, i64 %len, i64* %offset) #0 {
entry:
  %call = call %struct.inode* @file_inode.1080(%struct.file* %filp)
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 0)
  %call1 = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %call)
  %pipe2 = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call1, i32 0, i32 2
  %0 = load %struct.rpc_pipe*, %struct.rpc_pipe** %pipe2, align 8, !tbaa !1035
  %cmp = icmp eq %struct.rpc_pipe* %0, null
  br i1 %cmp, label %out_unlock, label %if.end

if.end:                                           ; preds = %entry
  %private_data = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 15
  %1 = load i8*, i8** %private_data, align 8, !tbaa !947
  %2 = bitcast i8* %1 to %struct.rpc_pipe_msg*
  %cmp3 = icmp eq %struct.rpc_pipe_msg* %2, null
  br i1 %cmp3, label %if.then4, label %if.end18

if.then4:                                         ; preds = %if.end
  %lock = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 9
  call void @spin_lock.1067(%struct.spinlock* %lock)
  %pipe5 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 0
  %call6 = call i32 @list_empty.1071(%struct.list_head* %pipe5)
  %tobool = icmp ne i32 %call6, 0
  br i1 %tobool, label %if.end12, label %if.then7

if.then7:                                         ; preds = %if.then4
  %pipe8 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %pipe8, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !1059
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr to %struct.rpc_pipe_msg*
  %list = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %5, i32 0, i32 0
  %in_upcall = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 1
  call void @list_move.1082(%struct.list_head* %list, %struct.list_head* %in_upcall)
  %len9 = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %5, i32 0, i32 2
  %6 = load i64, i64* %len9, align 8, !tbaa !1060
  %pipelen = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 3
  %7 = load i32, i32* %pipelen, align 8, !tbaa !1039
  %conv = sext i32 %7 to i64
  %sub = sub i64 %conv, %6
  %conv10 = trunc i64 %sub to i32
  store i32 %conv10, i32* %pipelen, align 8, !tbaa !1039
  %8 = bitcast %struct.rpc_pipe_msg* %5 to i8*
  %private_data11 = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 15
  store i8* %8, i8** %private_data11, align 8, !tbaa !947
  %copied = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %5, i32 0, i32 3
  store i64 0, i64* %copied, align 8, !tbaa !1061
  br label %if.end12

if.end12:                                         ; preds = %if.then7, %if.then4
  %msg.0 = phi %struct.rpc_pipe_msg* [ %2, %if.then4 ], [ %5, %if.then7 ]
  %lock13 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 9
  call void @spin_unlock.1068(%struct.spinlock* %lock13)
  %cmp14 = icmp eq %struct.rpc_pipe_msg* %msg.0, null
  br i1 %cmp14, label %out_unlock, label %if.end18

if.end18:                                         ; preds = %if.end12, %if.end
  %msg.1 = phi %struct.rpc_pipe_msg* [ %2, %if.end ], [ %msg.0, %if.end12 ]
  %ops = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 8
  %9 = load %struct.rpc_pipe_ops*, %struct.rpc_pipe_ops** %ops, align 8, !tbaa !1041
  %upcall = getelementptr inbounds %struct.rpc_pipe_ops, %struct.rpc_pipe_ops* %9, i32 0, i32 0
  %10 = load i64 (%struct.file*, %struct.rpc_pipe_msg*, i8*, i64)*, i64 (%struct.file*, %struct.rpc_pipe_msg*, i8*, i64)** %upcall, align 8, !tbaa !1048
  %call19 = call i64 %10(%struct.file* %filp, %struct.rpc_pipe_msg* %msg.1, i8* %buf, i64 %len)
  %conv20 = trunc i64 %call19 to i32
  %cmp21 = icmp slt i32 %conv20, 0
  br i1 %cmp21, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end18
  %len23 = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %msg.1, i32 0, i32 2
  %11 = load i64, i64* %len23, align 8, !tbaa !1060
  %copied24 = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %msg.1, i32 0, i32 3
  %12 = load i64, i64* %copied24, align 8, !tbaa !1061
  %cmp25 = icmp eq i64 %11, %12
  br i1 %cmp25, label %if.then27, label %out_unlock

if.then27:                                        ; preds = %lor.lhs.false, %if.end18
  %private_data28 = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 15
  store i8* null, i8** %private_data28, align 8, !tbaa !947
  %lock29 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 9
  call void @spin_lock.1067(%struct.spinlock* %lock29)
  %list30 = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %msg.1, i32 0, i32 0
  call void @list_del_init.1072(%struct.list_head* %list30)
  %lock31 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 9
  call void @spin_unlock.1068(%struct.spinlock* %lock31)
  %ops32 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 8
  %13 = load %struct.rpc_pipe_ops*, %struct.rpc_pipe_ops** %ops32, align 8, !tbaa !1041
  %destroy_msg = getelementptr inbounds %struct.rpc_pipe_ops, %struct.rpc_pipe_ops* %13, i32 0, i32 4
  %14 = load void (%struct.rpc_pipe_msg*)*, void (%struct.rpc_pipe_msg*)** %destroy_msg, align 8, !tbaa !1042
  call void %14(%struct.rpc_pipe_msg* %msg.1)
  br label %out_unlock

out_unlock:                                       ; preds = %if.then27, %lor.lhs.false, %if.end12, %entry
  %res.0 = phi i32 [ -32, %entry ], [ 0, %if.end12 ], [ %conv20, %if.then27 ], [ %conv20, %lor.lhs.false ]
  %i_mutex34 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex34)
  %conv35 = sext i32 %res.0 to i64
  ret i64 %conv35
}

; Function Attrs: nounwind uwtable
define internal i64 @rpc_pipe_write(%struct.file* %filp, i8* %buf, i64 %len, i64* %offset) #0 {
entry:
  %call = call %struct.inode* @file_inode.1080(%struct.file* %filp)
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 0)
  %call1 = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %call)
  %pipe = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call1, i32 0, i32 2
  %0 = load %struct.rpc_pipe*, %struct.rpc_pipe** %pipe, align 8, !tbaa !1035
  %cmp = icmp ne %struct.rpc_pipe* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %call)
  %pipe3 = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call2, i32 0, i32 2
  %1 = load %struct.rpc_pipe*, %struct.rpc_pipe** %pipe3, align 8, !tbaa !1035
  %ops = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %1, i32 0, i32 8
  %2 = load %struct.rpc_pipe_ops*, %struct.rpc_pipe_ops** %ops, align 8, !tbaa !1041
  %downcall = getelementptr inbounds %struct.rpc_pipe_ops, %struct.rpc_pipe_ops* %2, i32 0, i32 1
  %3 = load i64 (%struct.file*, i8*, i64)*, i64 (%struct.file*, i8*, i64)** %downcall, align 8, !tbaa !1049
  %call4 = call i64 %3(%struct.file* %filp, i8* %buf, i64 %len)
  %conv = trunc i64 %call4 to i32
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %res.0 = phi i32 [ %conv, %if.then ], [ -32, %entry ]
  %i_mutex5 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex5)
  %conv6 = sext i32 %res.0 to i64
  ret i64 %conv6
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_pipe_poll(%struct.file* %filp, %struct.poll_table_struct* %wait) #0 {
entry:
  %call = call %struct.inode* @file_inode.1080(%struct.file* %filp)
  %call1 = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %call)
  %waitq = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call1, i32 0, i32 3
  call void @poll_wait.1081(%struct.file* %filp, %struct.__wait_queue_head* %waitq, %struct.poll_table_struct* %wait)
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 0)
  %pipe = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call1, i32 0, i32 2
  %0 = load %struct.rpc_pipe*, %struct.rpc_pipe** %pipe, align 8, !tbaa !1035
  %cmp = icmp eq %struct.rpc_pipe* %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %or = or i32 260, 24
  br label %if.end8

if.else:                                          ; preds = %entry
  %private_data = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 15
  %1 = load i8*, i8** %private_data, align 8, !tbaa !947
  %tobool = icmp ne i8* %1, null
  br i1 %tobool, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %pipe2 = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call1, i32 0, i32 2
  %2 = load %struct.rpc_pipe*, %struct.rpc_pipe** %pipe2, align 8, !tbaa !1035
  %pipe3 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %2, i32 0, i32 0
  %call4 = call i32 @list_empty.1071(%struct.list_head* %pipe3)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.end8, label %if.then6

if.then6:                                         ; preds = %lor.lhs.false, %if.else
  %or7 = or i32 260, 65
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %lor.lhs.false, %if.then
  %mask.1 = phi i32 [ %or, %if.then ], [ %or7, %if.then6 ], [ 260, %lor.lhs.false ]
  %i_mutex9 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex9)
  ret i32 %mask.1
}

; Function Attrs: nounwind uwtable
define internal i64 @rpc_pipe_ioctl(%struct.file* %filp, i32 %cmd, i64 %arg) #0 {
entry:
  %call = call %struct.inode* @file_inode.1080(%struct.file* %filp)
  %SwitchLeaf = icmp eq i32 %cmd, 21531
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %entry
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 0)
  %call1 = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %call)
  %pipe2 = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call1, i32 0, i32 2
  %0 = load %struct.rpc_pipe*, %struct.rpc_pipe** %pipe2, align 8, !tbaa !1035
  %cmp = icmp eq %struct.rpc_pipe* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %i_mutex3 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex3)
  br label %cleanup

if.end:                                           ; preds = %sw.bb
  %lock = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 9
  call void @spin_lock.1067(%struct.spinlock* %lock)
  %pipelen = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 3
  %1 = load i32, i32* %pipelen, align 8, !tbaa !1039
  %private_data = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 15
  %2 = load i8*, i8** %private_data, align 8, !tbaa !947
  %tobool = icmp ne i8* %2, null
  br i1 %tobool, label %if.then4, label %if.end8

if.then4:                                         ; preds = %if.end
  %private_data5 = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 15
  %3 = load i8*, i8** %private_data5, align 8, !tbaa !947
  %4 = bitcast i8* %3 to %struct.rpc_pipe_msg*
  %len6 = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %4, i32 0, i32 2
  %5 = load i64, i64* %len6, align 8, !tbaa !1060
  %copied = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %4, i32 0, i32 3
  %6 = load i64, i64* %copied, align 8, !tbaa !1061
  %sub = sub i64 %5, %6
  %conv = sext i32 %1 to i64
  %add = add i64 %conv, %sub
  %conv7 = trunc i64 %add to i32
  br label %if.end8

if.end8:                                          ; preds = %if.then4, %if.end
  %len.0 = phi i32 [ %conv7, %if.then4 ], [ %1, %if.end ]
  %lock9 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 9
  call void @spin_unlock.1068(%struct.spinlock* %lock9)
  %i_mutex10 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex10)
  call void @might_fault()
  %7 = inttoptr i64 %arg to i32*
  %8 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %len.0, i32* %7) #7, !srcloc !1062
  %conv11 = sext i32 %8 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %if.then, %entry
  %retval.0 = phi i64 [ -32, %if.then ], [ %conv11, %if.end8 ], [ -22, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_pipe_open(%struct.inode* %inode, %struct.file* %filp) #0 {
entry:
  %i_sb = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 8
  %0 = load %struct.super_block*, %struct.super_block** %i_sb, align 8, !tbaa !1050
  %s_fs_info = getelementptr inbounds %struct.super_block, %struct.super_block* %0, i32 0, i32 36
  %1 = load i8*, i8** %s_fs_info, align 16, !tbaa !256
  %2 = bitcast i8* %1 to %struct.net*
  %3 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.1045(%struct.net* %2, i32 %3)
  %4 = bitcast i8* %call to %struct.sunrpc_net*
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 0)
  %gssd_running = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %4, i32 0, i32 20
  store i32 1, i32* %gssd_running, align 8, !tbaa !1063
  %call1 = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %inode)
  %pipe2 = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call1, i32 0, i32 2
  %5 = load %struct.rpc_pipe*, %struct.rpc_pipe** %pipe2, align 8, !tbaa !1035
  %cmp = icmp eq %struct.rpc_pipe* %5, null
  br i1 %cmp, label %out, label %if.end

if.end:                                           ; preds = %entry
  %nreaders = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %5, i32 0, i32 4
  %6 = load i32, i32* %nreaders, align 4, !tbaa !1036
  %cmp3 = icmp eq i32 %6, 0
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end
  %nwriters = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %5, i32 0, i32 5
  %7 = load i32, i32* %nwriters, align 8, !tbaa !1038
  %cmp4 = icmp eq i32 %7, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %8 = phi i1 [ false, %if.end ], [ %cmp4, %land.rhs ]
  %land.ext = zext i1 %8 to i32
  %tobool = icmp ne i32 %land.ext, 0
  br i1 %tobool, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %land.end
  %ops = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %5, i32 0, i32 8
  %9 = load %struct.rpc_pipe_ops*, %struct.rpc_pipe_ops** %ops, align 8, !tbaa !1041
  %open_pipe = getelementptr inbounds %struct.rpc_pipe_ops, %struct.rpc_pipe_ops* %9, i32 0, i32 3
  %10 = load i32 (%struct.inode*)*, i32 (%struct.inode*)** %open_pipe, align 8, !tbaa !1064
  %tobool5 = icmp ne i32 (%struct.inode*)* %10, null
  br i1 %tobool5, label %if.then6, label %if.end13

if.then6:                                         ; preds = %land.lhs.true
  %ops7 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %5, i32 0, i32 8
  %11 = load %struct.rpc_pipe_ops*, %struct.rpc_pipe_ops** %ops7, align 8, !tbaa !1041
  %open_pipe8 = getelementptr inbounds %struct.rpc_pipe_ops, %struct.rpc_pipe_ops* %11, i32 0, i32 3
  %12 = load i32 (%struct.inode*)*, i32 (%struct.inode*)** %open_pipe8, align 8, !tbaa !1064
  %call9 = call i32 %12(%struct.inode* %inode)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %out, label %if.end13

if.end13:                                         ; preds = %if.then6, %land.lhs.true, %land.end
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 8
  %13 = load i32, i32* %f_mode, align 4, !tbaa !962
  %and = and i32 %13, 1
  %tobool14 = icmp ne i32 %and, 0
  br i1 %tobool14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end13
  %nreaders16 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %5, i32 0, i32 4
  %14 = load i32, i32* %nreaders16, align 4, !tbaa !1036
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %nreaders16, align 4, !tbaa !1036
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.end13
  %f_mode18 = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 8
  %15 = load i32, i32* %f_mode18, align 4, !tbaa !962
  %and19 = and i32 %15, 2
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then21, label %out

if.then21:                                        ; preds = %if.end17
  %nwriters22 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %5, i32 0, i32 5
  %16 = load i32, i32* %nwriters22, align 8, !tbaa !1038
  %inc23 = add nsw i32 %16, 1
  store i32 %inc23, i32* %nwriters22, align 8, !tbaa !1038
  br label %out

out:                                              ; preds = %if.then21, %if.end17, %if.then6, %entry
  %res.0 = phi i32 [ -6, %entry ], [ %call9, %if.then6 ], [ 0, %if.then21 ], [ 0, %if.end17 ]
  %i_mutex25 = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex25)
  ret i32 %res.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_pipe_release(%struct.inode* %inode, %struct.file* %filp) #0 {
entry:
  %free_list = alloca %struct.list_head, align 8
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 0)
  %call = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %inode)
  %pipe1 = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call, i32 0, i32 2
  %0 = load %struct.rpc_pipe*, %struct.rpc_pipe** %pipe1, align 8, !tbaa !1035
  %cmp = icmp eq %struct.rpc_pipe* %0, null
  br i1 %cmp, label %out, label %if.end

if.end:                                           ; preds = %entry
  %private_data = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 15
  %1 = load i8*, i8** %private_data, align 8, !tbaa !947
  %2 = bitcast i8* %1 to %struct.rpc_pipe_msg*
  %cmp2 = icmp ne %struct.rpc_pipe_msg* %2, null
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %lock = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 9
  call void @spin_lock.1067(%struct.spinlock* %lock)
  %errno = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %2, i32 0, i32 4
  store i32 -11, i32* %errno, align 8, !tbaa !1046
  %list = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %2, i32 0, i32 0
  call void @list_del_init.1072(%struct.list_head* %list)
  %lock4 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 9
  call void @spin_unlock.1068(%struct.spinlock* %lock4)
  %ops = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 8
  %3 = load %struct.rpc_pipe_ops*, %struct.rpc_pipe_ops** %ops, align 8, !tbaa !1041
  %destroy_msg = getelementptr inbounds %struct.rpc_pipe_ops, %struct.rpc_pipe_ops* %3, i32 0, i32 4
  %4 = load void (%struct.rpc_pipe_msg*)*, void (%struct.rpc_pipe_msg*)** %destroy_msg, align 8, !tbaa !1042
  call void %4(%struct.rpc_pipe_msg* %2)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 8
  %5 = load i32, i32* %f_mode, align 4, !tbaa !962
  %and = and i32 %5, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end5
  %nwriters = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 5
  %6 = load i32, i32* %nwriters, align 8, !tbaa !1038
  %dec = add nsw i32 %6, -1
  store i32 %dec, i32* %nwriters, align 8, !tbaa !1038
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end5
  %f_mode8 = getelementptr inbounds %struct.file, %struct.file* %filp, i32 0, i32 8
  %7 = load i32, i32* %f_mode8, align 4, !tbaa !962
  %and9 = and i32 %7, 1
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end23

if.then11:                                        ; preds = %if.end7
  %nreaders = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 4
  %8 = load i32, i32* %nreaders, align 4, !tbaa !1036
  %dec12 = add nsw i32 %8, -1
  store i32 %dec12, i32* %nreaders, align 4, !tbaa !1036
  %nreaders13 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 4
  %9 = load i32, i32* %nreaders13, align 4, !tbaa !1036
  %cmp14 = icmp eq i32 %9, 0
  br i1 %cmp14, label %if.then15, label %if.end23

if.then15:                                        ; preds = %if.then11
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %free_list, i32 0, i32 0
  store %struct.list_head* %free_list, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %free_list, i32 0, i32 1
  store %struct.list_head* %free_list, %struct.list_head** %prev, align 8, !tbaa !163
  %lock16 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 9
  call void @spin_lock.1067(%struct.spinlock* %lock16)
  %pipe17 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 0
  call void @list_splice_init.1070(%struct.list_head* %pipe17, %struct.list_head* %free_list)
  %pipelen = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 3
  store i32 0, i32* %pipelen, align 8, !tbaa !1039
  %lock18 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 9
  call void @spin_unlock.1068(%struct.spinlock* %lock18)
  %call19 = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %inode)
  %waitq = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call19, i32 0, i32 3
  %ops20 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 8
  %10 = load %struct.rpc_pipe_ops*, %struct.rpc_pipe_ops** %ops20, align 8, !tbaa !1041
  %destroy_msg21 = getelementptr inbounds %struct.rpc_pipe_ops, %struct.rpc_pipe_ops* %10, i32 0, i32 4
  %11 = load void (%struct.rpc_pipe_msg*)*, void (%struct.rpc_pipe_msg*)** %destroy_msg21, align 8, !tbaa !1042
  call void @rpc_purge_list(%struct.__wait_queue_head* %waitq, %struct.list_head* %free_list, void (%struct.rpc_pipe_msg*)* %11, i32 -11)
  br label %if.end23

if.end23:                                         ; preds = %if.then15, %if.then11, %if.end7
  %nwriters24 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 5
  %12 = load i32, i32* %nwriters24, align 8, !tbaa !1038
  %cmp25 = icmp eq i32 %12, 0
  br i1 %cmp25, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end23
  %nreaders26 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 4
  %13 = load i32, i32* %nreaders26, align 4, !tbaa !1036
  %cmp27 = icmp eq i32 %13, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end23
  %14 = phi i1 [ false, %if.end23 ], [ %cmp27, %land.rhs ]
  %land.ext = zext i1 %14 to i32
  %tobool28 = icmp ne i32 %land.ext, 0
  br i1 %tobool28, label %land.lhs.true, label %out

land.lhs.true:                                    ; preds = %land.end
  %ops29 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 8
  %15 = load %struct.rpc_pipe_ops*, %struct.rpc_pipe_ops** %ops29, align 8, !tbaa !1041
  %release_pipe = getelementptr inbounds %struct.rpc_pipe_ops, %struct.rpc_pipe_ops* %15, i32 0, i32 2
  %16 = load void (%struct.inode*)*, void (%struct.inode*)** %release_pipe, align 8, !tbaa !1044
  %tobool30 = icmp ne void (%struct.inode*)* %16, null
  br i1 %tobool30, label %if.then31, label %out

if.then31:                                        ; preds = %land.lhs.true
  %ops32 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 8
  %17 = load %struct.rpc_pipe_ops*, %struct.rpc_pipe_ops** %ops32, align 8, !tbaa !1041
  %release_pipe33 = getelementptr inbounds %struct.rpc_pipe_ops, %struct.rpc_pipe_ops* %17, i32 0, i32 2
  %18 = load void (%struct.inode*)*, void (%struct.inode*)** %release_pipe33, align 8, !tbaa !1044
  call void %18(%struct.inode* %inode)
  br label %out

out:                                              ; preds = %if.then31, %land.lhs.true, %land.end, %entry
  %i_mutex35 = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex35)
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.inode* @file_inode.1080(%struct.file* %f) #2 {
entry:
  %f_inode = getelementptr inbounds %struct.file, %struct.file* %f, i32 0, i32 2
  %0 = load %struct.inode*, %struct.inode** %f_inode, align 8, !tbaa !965
  ret %struct.inode* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @poll_wait.1081(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #2 {
entry:
  %tobool = icmp ne %struct.poll_table_struct* %p, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %0 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8, !tbaa !968
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.__wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %1 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8, !tbaa !968
  call void %1(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_move.1082(%struct.list_head* %list, %struct.list_head* %head) #2 {
entry:
  call void @__list_del_entry(%struct.list_head* %list)
  call void @list_add.1083(%struct.list_head* %list, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add.1083(%struct.list_head* %new, %struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

declare %struct.dentry* @d_alloc(%struct.dentry*, %struct.qstr*) #4

declare void @d_set_d_op(%struct.dentry*, %struct.dentry_operations*) #4

; Function Attrs: nounwind uwtable
define internal i32 @rpc_delete_dentry(%struct.dentry* %dentry) #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind uwtable
define i32 @rpc_rmdir(%struct.dentry* %dentry) #0 {
entry:
  %call = call %struct.dentry* @dget_parent(%struct.dentry* %dentry)
  %d_inode = getelementptr inbounds %struct.dentry, %struct.dentry* %call, i32 0, i32 5
  %0 = load %struct.inode*, %struct.inode** %d_inode, align 8, !tbaa !1032
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 1)
  %call1 = call i32 @__rpc_rmdir(%struct.inode* %0, %struct.dentry* %dentry)
  %i_mutex2 = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex2)
  call void @dput(%struct.dentry* %call)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @__rpc_rmdir(%struct.inode* %dir, %struct.dentry* %dentry) #0 {
entry:
  %call = call %struct.dentry* @dget(%struct.dentry* %dentry)
  %call1 = call i32 @simple_rmdir(%struct.inode* %dir, %struct.dentry* %dentry)
  call void @d_delete(%struct.dentry* %dentry)
  call void @dput(%struct.dentry* %dentry)
  ret i32 %call1
}

declare i32 @simple_rmdir(%struct.inode*, %struct.dentry*) #4

; Function Attrs: nounwind uwtable
define %struct.rpc_pipe* @rpc_mkpipe_data(%struct.rpc_pipe_ops* %ops, i32 %flags) #0 {
entry:
  %call = call i8* @kzalloc.1084(i64 376, i32 208)
  %0 = bitcast i8* %call to %struct.rpc_pipe*
  %tobool = icmp ne %struct.rpc_pipe* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call i8* @ERR_PTR.1076(i64 -12)
  %1 = bitcast i8* %call1 to %struct.rpc_pipe*
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @init_pipe(%struct.rpc_pipe* %0)
  %ops2 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 8
  store %struct.rpc_pipe_ops* %ops, %struct.rpc_pipe_ops** %ops2, align 8, !tbaa !1041
  %flags3 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %0, i32 0, i32 6
  store i32 %flags, i32* %flags3, align 4, !tbaa !1065
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi %struct.rpc_pipe* [ %0, %if.end ], [ %1, %if.then ]
  ret %struct.rpc_pipe* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.1084(i64 %size, i32 %flags) #2 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #7
  ret i8* %call.i
}

; Function Attrs: nounwind uwtable
define internal void @init_pipe(%struct.rpc_pipe* %pipe) #0 {
entry:
  %.compoundliteral = alloca %struct.pgprot, align 8
  %nreaders = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 4
  store i32 0, i32* %nreaders, align 4, !tbaa !1036
  %nwriters = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 5
  store i32 0, i32* %nwriters, align 8, !tbaa !1038
  %in_upcall = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 1
  call void @INIT_LIST_HEAD.1073(%struct.list_head* %in_upcall)
  %in_downcall = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 2
  call void @INIT_LIST_HEAD.1073(%struct.list_head* %in_downcall)
  %pipe1 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 0
  call void @INIT_LIST_HEAD.1073(%struct.list_head* %pipe1)
  %pipelen = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 3
  store i32 0, i32* %pipelen, align 8, !tbaa !1039
  %queue_timeout = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 7
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %queue_timeout, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work, i32 0)
  %queue_timeout4 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 7
  %work5 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %queue_timeout4, i32 0, i32 0
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work5, i32 0, i32 0
  %counter = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !339
  %0 = bitcast %struct.pgprot* %data to i8*
  %1 = bitcast %struct.pgprot* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 8, i32 8, i1 false), !tbaa.struct !340
  %queue_timeout6 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 7
  %work7 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %queue_timeout6, i32 0, i32 0
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work7, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.6.1085, i32 0, i32 0), %struct.lock_class_key* @init_pipe.__key, i32 0)
  %queue_timeout8 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 7
  %work9 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %queue_timeout8, i32 0, i32 0
  %entry10 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work9, i32 0, i32 1
  call void @INIT_LIST_HEAD.1073(%struct.list_head* %entry10)
  %queue_timeout12 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 7
  %work13 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %queue_timeout12, i32 0, i32 0
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work13, i32 0, i32 2
  store void (%struct.work_struct*)* @rpc_timeout_upcall_queue, void (%struct.work_struct*)** %func, align 8, !tbaa !341
  %queue_timeout18 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 7
  %timer = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %queue_timeout18, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer, i32 2, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.8.1086, i32 0, i32 0), %struct.lock_class_key* @init_pipe.__key.7)
  %queue_timeout20 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 7
  %timer21 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %queue_timeout20, i32 0, i32 1
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer21, i32 0, i32 3
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function, align 8, !tbaa !342
  %queue_timeout22 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 7
  %2 = ptrtoint %struct.delayed_work* %queue_timeout22 to i64
  %queue_timeout23 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 7
  %timer24 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %queue_timeout23, i32 0, i32 1
  %data25 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer24, i32 0, i32 4
  store i64 %2, i64* %data25, align 8, !tbaa !343
  %ops = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 8
  store %struct.rpc_pipe_ops* null, %struct.rpc_pipe_ops** %ops, align 8, !tbaa !1041
  call void @spinlock_check.1087()
  %lock30 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 9
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock30, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %3 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.10.1088, i32 0, i32 0), %struct.lock_class_key* @init_pipe.__key.9)
  %dentry = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 10
  store %struct.dentry* null, %struct.dentry** %dentry, align 8, !tbaa !1040
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_timeout_upcall_queue(%struct.work_struct* %work) #0 {
entry:
  %free_list = alloca %struct.list_head, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %free_list, i32 0, i32 0
  store %struct.list_head* %free_list, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %free_list, i32 0, i32 1
  store %struct.list_head* %free_list, %struct.list_head** %prev, align 8, !tbaa !163
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -64
  %1 = bitcast i8* %add.ptr to %struct.rpc_pipe*
  %lock = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %1, i32 0, i32 9
  call void @spin_lock.1067(%struct.spinlock* %lock)
  %ops = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %1, i32 0, i32 8
  %2 = load %struct.rpc_pipe_ops*, %struct.rpc_pipe_ops** %ops, align 8, !tbaa !1041
  %destroy_msg1 = getelementptr inbounds %struct.rpc_pipe_ops, %struct.rpc_pipe_ops* %2, i32 0, i32 4
  %3 = load void (%struct.rpc_pipe_msg*)*, void (%struct.rpc_pipe_msg*)** %destroy_msg1, align 8, !tbaa !1042
  %nreaders = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %1, i32 0, i32 4
  %4 = load i32, i32* %nreaders, align 4, !tbaa !1036
  %cmp = icmp eq i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %pipe2 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %1, i32 0, i32 0
  call void @list_splice_init.1070(%struct.list_head* %pipe2, %struct.list_head* %free_list)
  %pipelen = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %1, i32 0, i32 3
  store i32 0, i32* %pipelen, align 8, !tbaa !1039
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %dentry3 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %1, i32 0, i32 10
  %5 = load %struct.dentry*, %struct.dentry** %dentry3, align 8, !tbaa !1040
  %call = call %struct.dentry* @dget(%struct.dentry* %5)
  %lock4 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %1, i32 0, i32 9
  call void @spin_unlock.1068(%struct.spinlock* %lock4)
  %tobool = icmp ne %struct.dentry* %call, null
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end
  %d_inode = getelementptr inbounds %struct.dentry, %struct.dentry* %call, i32 0, i32 5
  %6 = load %struct.inode*, %struct.inode** %d_inode, align 8, !tbaa !1032
  %call5 = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %6)
  %waitq = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call5, i32 0, i32 3
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.end
  %cond = phi %struct.__wait_queue_head* [ %waitq, %cond.true ], [ null, %if.end ]
  call void @rpc_purge_list(%struct.__wait_queue_head* %cond, %struct.list_head* %free_list, void (%struct.rpc_pipe_msg*)* %3, i32 -110)
  call void @dput(%struct.dentry* %call)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spinlock_check.1087() #2 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_destroy_pipe_data(%struct.rpc_pipe* %pipe) #0 {
entry:
  %0 = bitcast %struct.rpc_pipe* %pipe to i8*
  call void @kfree(i8* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @rpc_queue_upcall(%struct.rpc_pipe* %pipe, %struct.rpc_pipe_msg* %msg) #0 {
entry:
  %lock = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 9
  call void @spin_lock.1067(%struct.spinlock* %lock)
  %nreaders = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 4
  %0 = load i32, i32* %nreaders, align 4, !tbaa !1036
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %list = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %msg, i32 0, i32 0
  %pipe1 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 0
  call void @list_add_tail.1090(%struct.list_head* %list, %struct.list_head* %pipe1)
  br label %if.end17.sink.split

if.else:                                          ; preds = %entry
  %flags = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 6
  %1 = load i32, i32* %flags, align 4, !tbaa !1065
  %and = and i32 %1, 1
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.then4, label %if.end17

if.then4:                                         ; preds = %if.else
  %pipe5 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 0
  %call = call i32 @list_empty.1071(%struct.list_head* %pipe5)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then4
  %2 = load %struct.workqueue_struct*, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !28
  %queue_timeout = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 7
  call void @queue_delayed_work.1091(%struct.workqueue_struct* %2, %struct.delayed_work* %queue_timeout, i64 7500)
  br label %if.end

if.end:                                           ; preds = %if.then7, %if.then4
  %list9 = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %msg, i32 0, i32 0
  %pipe10 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 0
  call void @list_add_tail.1090(%struct.list_head* %list9, %struct.list_head* %pipe10)
  br label %if.end17.sink.split

if.end17.sink.split:                              ; preds = %if.end, %if.then
  %len = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %msg, i32 0, i32 2
  %3 = load i64, i64* %len, align 8, !tbaa !1060
  %pipelen = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 3
  %4 = load i32, i32* %pipelen, align 8, !tbaa !1039
  %conv13 = sext i32 %4 to i64
  %add14 = add i64 %conv13, %3
  %conv15 = trunc i64 %add14 to i32
  store i32 %conv15, i32* %pipelen, align 8, !tbaa !1039
  br label %if.end17

if.end17:                                         ; preds = %if.end17.sink.split, %if.else
  %res.1 = phi i32 [ -32, %if.else ], [ 0, %if.end17.sink.split ]
  %dentry18 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 10
  %5 = load %struct.dentry*, %struct.dentry** %dentry18, align 8, !tbaa !1040
  %call19 = call %struct.dentry* @dget(%struct.dentry* %5)
  %lock20 = getelementptr inbounds %struct.rpc_pipe, %struct.rpc_pipe* %pipe, i32 0, i32 9
  call void @spin_unlock.1068(%struct.spinlock* %lock20)
  %tobool21 = icmp ne %struct.dentry* %call19, null
  br i1 %tobool21, label %if.then22, label %if.end24

if.then22:                                        ; preds = %if.end17
  %d_inode = getelementptr inbounds %struct.dentry, %struct.dentry* %call19, i32 0, i32 5
  %6 = load %struct.inode*, %struct.inode** %d_inode, align 8, !tbaa !1032
  %call23 = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %6)
  %waitq = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call23, i32 0, i32 3
  call void @__wake_up(%struct.__wait_queue_head* %waitq, i32 3, i32 1, i8* null)
  call void @dput(%struct.dentry* %call19)
  br label %if.end24

if.end24:                                         ; preds = %if.then22, %if.end17
  ret i32 %res.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.1090(%struct.list_head* %new, %struct.list_head* %head) #2 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !163
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_delayed_work.1091(%struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay) #2 {
entry:
  %call = call zeroext i1 @queue_delayed_work_on(i32 4096, %struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay)
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @rpc_pipe_generic_upcall(%struct.file* %filp, %struct.rpc_pipe_msg* %msg, i8* %dst, i64 %buflen) #0 {
entry:
  %_min1 = alloca i64, align 8
  %_min2 = alloca i64, align 8
  %data1 = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %msg, i32 0, i32 1
  %0 = load i8*, i8** %data1, align 8, !tbaa !1066
  %copied = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %msg, i32 0, i32 3
  %1 = load i64, i64* %copied, align 8, !tbaa !1061
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 %1
  %len = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %msg, i32 0, i32 2
  %2 = load i64, i64* %len, align 8, !tbaa !1060
  %copied2 = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %msg, i32 0, i32 3
  %3 = load i64, i64* %copied2, align 8, !tbaa !1061
  %sub = sub i64 %2, %3
  store i64 %sub, i64* %_min1, align 8, !tbaa !88
  store i64 %buflen, i64* %_min2, align 8, !tbaa !88
  %4 = load i64, i64* %_min1, align 8, !tbaa !88
  %5 = load i64, i64* %_min2, align 8, !tbaa !88
  %cmp3 = icmp ult i64 %4, %5
  %6 = load i64, i64* %_min1, align 8
  %7 = load i64, i64* %_min2, align 8
  %cond = select i1 %cmp3, i64 %6, i64 %7
  %conv5 = trunc i64 %cond to i32
  call void @might_fault() #7
  %call.i = call i64 @_copy_to_user(i8* %dst, i8* %add.ptr, i32 %conv5) #7
  %conv.i = trunc i64 %call.i to i32
  %conv6 = sext i32 %conv.i to i64
  %cmp7 = icmp eq i64 %conv6, %cond
  br i1 %cmp7, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %sub9 = sub i64 %cond, %conv6
  %copied10 = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %msg, i32 0, i32 3
  %8 = load i64, i64* %copied10, align 8, !tbaa !1061
  %add = add i64 %8, %sub9
  store i64 %add, i64* %copied10, align 8, !tbaa !1061
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %.sink = phi i32 [ 0, %if.end ], [ -14, %entry ]
  %retval.0 = phi i64 [ %sub9, %if.end ], [ -14, %entry ]
  %errno11 = getelementptr inbounds %struct.rpc_pipe_msg, %struct.rpc_pipe_msg* %msg, i32 0, i32 4
  store i32 %.sink, i32* %errno11, align 8, !tbaa !1046
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define void @rpc_pipefs_notifier_unregister(%struct.notifier_block* %nb) #0 {
entry:
  %call = call i32 @blocking_notifier_chain_unregister(%struct.blocking_notifier_head* @rpc_pipefs_notifier_list, %struct.notifier_block* %nb)
  ret void
}

declare i32 @blocking_notifier_chain_unregister(%struct.blocking_notifier_head*, %struct.notifier_block*) #4

; Function Attrs: nounwind uwtable
define i32 @rpc_pipefs_notifier_register(%struct.notifier_block* %nb) #0 {
entry:
  %call = call i32 @blocking_notifier_chain_cond_register(%struct.blocking_notifier_head* @rpc_pipefs_notifier_list, %struct.notifier_block* %nb)
  ret i32 %call
}

declare i32 @blocking_notifier_chain_cond_register(%struct.blocking_notifier_head*, %struct.notifier_block*) #4

; Function Attrs: nounwind uwtable
define %struct.dentry* @rpc_create_client_dir(%struct.dentry* %dentry, %struct.qstr* %name, %struct.rpc_clnt* %rpc_client) #0 {
entry:
  %0 = bitcast %struct.rpc_clnt* %rpc_client to i8*
  %call = call %struct.dentry* @rpc_mkdir_populate(%struct.dentry* %dentry, %struct.qstr* %name, i16 zeroext 365, i8* null, i32 (%struct.dentry*, i8*)* @rpc_clntdir_populate, i8* %0)
  ret %struct.dentry* %call
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_clntdir_populate(%struct.dentry* %dentry, i8* %private) #0 {
entry:
  %call = call i32 @rpc_populate(%struct.dentry* %dentry, %struct.rpc_filelist* getelementptr inbounds ([1 x %struct.rpc_filelist], [1 x %struct.rpc_filelist]* @authfiles, i32 0, i32 0), i32 0, i32 1, i8* %private)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal %struct.dentry* @rpc_mkdir_populate(%struct.dentry* %parent, %struct.qstr* %name, i16 zeroext %mode, i8* %private, i32 (%struct.dentry*, i8*)* %populate, i8* %args_populate) #0 {
entry:
  %d_inode = getelementptr inbounds %struct.dentry, %struct.dentry* %parent, i32 0, i32 5
  %0 = load %struct.inode*, %struct.inode** %d_inode, align 8, !tbaa !1032
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 1)
  %call = call %struct.dentry* @__rpc_lookup_create_exclusive(%struct.dentry* %parent, %struct.qstr* %name)
  %1 = bitcast %struct.dentry* %call to i8*
  %call1 = call i64 @IS_ERR.1075(i8* %1)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %out, label %if.end

if.end:                                           ; preds = %entry
  %call2 = call i32 @__rpc_mkdir(%struct.inode* %0, %struct.dentry* %call, i16 zeroext %mode, %struct.file_operations* null, i8* %private)
  %cmp = icmp ne i32 %call2, 0
  br i1 %cmp, label %out_err, label %if.end4

if.end4:                                          ; preds = %if.end
  %cmp5 = icmp ne i32 (%struct.dentry*, i8*)* %populate, null
  br i1 %cmp5, label %if.then6, label %out

if.then6:                                         ; preds = %if.end4
  %call7 = call i32 %populate(%struct.dentry* %call, i8* %args_populate)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %err_rmdir, label %out

out:                                              ; preds = %out_err, %if.then6, %if.end4, %entry
  %dentry.0 = phi %struct.dentry* [ %2, %out_err ], [ %call, %entry ], [ %call, %if.then6 ], [ %call, %if.end4 ]
  %i_mutex12 = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex12)
  ret %struct.dentry* %dentry.0

err_rmdir:                                        ; preds = %if.then6
  %call13 = call i32 @__rpc_rmdir(%struct.inode* %0, %struct.dentry* %call)
  br label %out_err

out_err:                                          ; preds = %err_rmdir, %if.end
  %error.0 = phi i32 [ %call7, %err_rmdir ], [ %call2, %if.end ]
  %conv = sext i32 %error.0 to i64
  %call14 = call i8* @ERR_PTR.1076(i64 %conv)
  %2 = bitcast i8* %call14 to %struct.dentry*
  br label %out
}

; Function Attrs: nounwind uwtable
define internal i32 @__rpc_mkdir(%struct.inode* %dir, %struct.dentry* %dentry, i16 zeroext %mode, %struct.file_operations* %i_fop, i8* %private) #0 {
entry:
  %conv = zext i16 %mode to i32
  %or = or i32 16384, %conv
  %conv1 = trunc i32 %or to i16
  %call = call i32 @__rpc_create_common(%struct.inode* %dir, %struct.dentry* %dentry, i16 zeroext %conv1, %struct.file_operations* %i_fop, i8* %private)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @inc_nlink(%struct.inode* %dir)
  call void @fsnotify_mkdir(%struct.inode* %dir, %struct.dentry* %dentry)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @fsnotify_mkdir(%struct.inode* %inode, %struct.dentry* %dentry) #2 {
entry:
  %d_inode1 = getelementptr inbounds %struct.dentry, %struct.dentry* %dentry, i32 0, i32 5
  %0 = load %struct.inode*, %struct.inode** %d_inode1, align 8, !tbaa !1032
  call void @audit_inode_child(%struct.inode* %inode, %struct.dentry* %dentry, i8 zeroext 4)
  %1 = bitcast %struct.inode* %0 to i8*
  %d_name = getelementptr inbounds %struct.dentry, %struct.dentry* %dentry, i32 0, i32 4
  %name = getelementptr inbounds %struct.qstr, %struct.qstr* %d_name, i32 0, i32 1
  %2 = load i8*, i8** %name, align 8, !tbaa !1053
  %call = call i32 @fsnotify(%struct.inode* %inode, i32 1073742080, i8* %1, i32 2, i8* %2, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_populate(%struct.dentry* %parent, %struct.rpc_filelist* %files, i32 %start, i32 %eof, i8* %private) #0 {
entry:
  %q = alloca %struct.qstr, align 8
  %d_inode = getelementptr inbounds %struct.dentry, %struct.dentry* %parent, i32 0, i32 5
  %0 = load %struct.inode*, %struct.inode** %d_inode, align 8, !tbaa !1032
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ %start, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, %eof
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.rpc_filelist, %struct.rpc_filelist* %files, i64 %idxprom
  %name = getelementptr inbounds %struct.rpc_filelist, %struct.rpc_filelist* %arrayidx, i32 0, i32 0
  %1 = load i8*, i8** %name, align 8, !tbaa !1067
  %name1 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 1
  store i8* %1, i8** %name1, align 8, !tbaa !245
  %idxprom2 = sext i32 %i.0 to i64
  %arrayidx3 = getelementptr inbounds %struct.rpc_filelist, %struct.rpc_filelist* %files, i64 %idxprom2
  %name4 = getelementptr inbounds %struct.rpc_filelist, %struct.rpc_filelist* %arrayidx3, i32 0, i32 0
  %2 = load i8*, i8** %name4, align 8, !tbaa !1067
  %call = call i64 @strlen(i8* %2)
  %conv = trunc i64 %call to i32
  %3 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 0
  %4 = bitcast %struct.pgprot* %3 to %struct.exception_table_entry*
  %len = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %4, i32 0, i32 1
  store i32 %conv, i32* %len, align 4, !tbaa !166
  %name5 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 1
  %5 = load i8*, i8** %name5, align 8, !tbaa !245
  %6 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 0
  %7 = bitcast %struct.pgprot* %6 to %struct.exception_table_entry*
  %len6 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %7, i32 0, i32 1
  %8 = load i32, i32* %len6, align 4, !tbaa !166
  %call7 = call i32 @full_name_hash(i8* %5, i32 %8)
  %9 = getelementptr inbounds %struct.qstr, %struct.qstr* %q, i32 0, i32 0
  %10 = bitcast %struct.pgprot* %9 to %struct.exception_table_entry*
  %hash = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %10, i32 0, i32 0
  store i32 %call7, i32* %hash, align 8, !tbaa !166
  %call8 = call %struct.dentry* @__rpc_lookup_create_exclusive(%struct.dentry* %parent, %struct.qstr* %q)
  %11 = bitcast %struct.dentry* %call8 to i8*
  %call9 = call i64 @PTR_ERR.1101(i8* %11)
  %conv10 = trunc i64 %call9 to i32
  %12 = bitcast %struct.dentry* %call8 to i8*
  %call11 = call i64 @IS_ERR.1075(i8* %12)
  %tobool = icmp ne i64 %call11, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %for.body
  %idxprom12 = sext i32 %i.0 to i64
  %arrayidx13 = getelementptr inbounds %struct.rpc_filelist, %struct.rpc_filelist* %files, i64 %idxprom12
  %mode = getelementptr inbounds %struct.rpc_filelist, %struct.rpc_filelist* %arrayidx13, i32 0, i32 2
  %13 = load i16, i16* %mode, align 8, !tbaa !1069
  %conv14 = zext i16 %13 to i32
  %and = and i32 %conv14, 61440
  %Pivot = icmp slt i32 %and, 32768
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end
  %SwitchLeaf2 = icmp eq i32 %and, 32768
  br i1 %SwitchLeaf2, label %sw.bb, label %do.body

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %and, 16384
  br i1 %SwitchLeaf, label %sw.bb24, label %do.body

do.body:                                          ; preds = %LeafBlock, %LeafBlock1
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1.1046, i32 0, i32 0), i32 746, i64 12) #7, !srcloc !1070
  br label %do.body15

do.body15:                                        ; preds = %do.body15, %do.body
  br label %do.body15

sw.bb:                                            ; preds = %LeafBlock1
  %idxprom18 = sext i32 %i.0 to i64
  %arrayidx19 = getelementptr inbounds %struct.rpc_filelist, %struct.rpc_filelist* %files, i64 %idxprom18
  %mode20 = getelementptr inbounds %struct.rpc_filelist, %struct.rpc_filelist* %arrayidx19, i32 0, i32 2
  %14 = load i16, i16* %mode20, align 8, !tbaa !1069
  %idxprom21 = sext i32 %i.0 to i64
  %arrayidx22 = getelementptr inbounds %struct.rpc_filelist, %struct.rpc_filelist* %files, i64 %idxprom21
  %i_fop = getelementptr inbounds %struct.rpc_filelist, %struct.rpc_filelist* %arrayidx22, i32 0, i32 1
  %15 = load %struct.file_operations*, %struct.file_operations** %i_fop, align 8, !tbaa !1071
  %call23 = call i32 @__rpc_create(%struct.inode* %0, %struct.dentry* %call8, i16 zeroext %14, %struct.file_operations* %15, i8* %private)
  br label %sw.epilog

sw.bb24:                                          ; preds = %LeafBlock
  %idxprom25 = sext i32 %i.0 to i64
  %arrayidx26 = getelementptr inbounds %struct.rpc_filelist, %struct.rpc_filelist* %files, i64 %idxprom25
  %mode27 = getelementptr inbounds %struct.rpc_filelist, %struct.rpc_filelist* %arrayidx26, i32 0, i32 2
  %16 = load i16, i16* %mode27, align 8, !tbaa !1069
  %call28 = call i32 @__rpc_mkdir(%struct.inode* %0, %struct.dentry* %call8, i16 zeroext %16, %struct.file_operations* null, i8* %private)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb24, %sw.bb
  %err.0 = phi i32 [ %call28, %sw.bb24 ], [ %call23, %sw.bb ]
  %cmp29 = icmp ne i32 %err.0, 0
  %. = select i1 %cmp29, i32 5, i32 0
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %for.body
  %err.1 = phi i32 [ %conv10, %for.body ], [ %err.0, %sw.epilog ]
  %cleanup.dest.slot.0 = phi i32 [ 5, %for.body ], [ %., %sw.epilog ]
  %Pivot9 = icmp slt i32 %cleanup.dest.slot.0, 5
  br i1 %Pivot9, label %LeafBlock4, label %LeafBlock6

LeafBlock6:                                       ; preds = %cleanup
  %SwitchLeaf7 = icmp eq i32 %cleanup.dest.slot.0, 5
  br i1 %SwitchLeaf7, label %out_bad, label %cleanup37

LeafBlock4:                                       ; preds = %cleanup
  %SwitchLeaf5 = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf5, label %for.inc, label %cleanup37

for.inc:                                          ; preds = %LeafBlock4
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %i_mutex33 = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex33)
  br label %cleanup37

out_bad:                                          ; preds = %LeafBlock6
  call void @__rpc_depopulate(%struct.dentry* %parent, %struct.rpc_filelist* %files, i32 %start, i32 %eof)
  %i_mutex34 = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex34)
  %17 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup37

cleanup37:                                        ; preds = %out_bad, %for.end, %LeafBlock4, %LeafBlock6
  %retval.0 = phi i32 [ %err.1, %out_bad ], [ 0, %for.end ], [ undef, %LeafBlock4 ], [ undef, %LeafBlock6 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR.1101(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @__rpc_create(%struct.inode* %dir, %struct.dentry* %dentry, i16 zeroext %mode, %struct.file_operations* %i_fop, i8* %private) #0 {
entry:
  %conv = zext i16 %mode to i32
  %or = or i32 32768, %conv
  %conv1 = trunc i32 %or to i16
  %call = call i32 @__rpc_create_common(%struct.inode* %dir, %struct.dentry* %dentry, i16 zeroext %conv1, %struct.file_operations* %i_fop, i8* %private)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @fsnotify_create(%struct.inode* %dir, %struct.dentry* %dentry)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @__rpc_depopulate(%struct.dentry* %parent, %struct.rpc_filelist* %files, i32 %start, i32 %eof) #0 {
entry:
  %name = alloca %struct.qstr, align 8
  %d_inode = getelementptr inbounds %struct.dentry, %struct.dentry* %parent, i32 0, i32 5
  %0 = load %struct.inode*, %struct.inode** %d_inode, align 8, !tbaa !1032
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ %start, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, %eof
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.rpc_filelist, %struct.rpc_filelist* %files, i64 %idxprom
  %name1 = getelementptr inbounds %struct.rpc_filelist, %struct.rpc_filelist* %arrayidx, i32 0, i32 0
  %1 = load i8*, i8** %name1, align 8, !tbaa !1067
  %name2 = getelementptr inbounds %struct.qstr, %struct.qstr* %name, i32 0, i32 1
  store i8* %1, i8** %name2, align 8, !tbaa !245
  %idxprom3 = sext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds %struct.rpc_filelist, %struct.rpc_filelist* %files, i64 %idxprom3
  %name5 = getelementptr inbounds %struct.rpc_filelist, %struct.rpc_filelist* %arrayidx4, i32 0, i32 0
  %2 = load i8*, i8** %name5, align 8, !tbaa !1067
  %call = call i64 @strlen(i8* %2)
  %conv = trunc i64 %call to i32
  %3 = getelementptr inbounds %struct.qstr, %struct.qstr* %name, i32 0, i32 0
  %4 = bitcast %struct.pgprot* %3 to %struct.exception_table_entry*
  %len = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %4, i32 0, i32 1
  store i32 %conv, i32* %len, align 4, !tbaa !166
  %name6 = getelementptr inbounds %struct.qstr, %struct.qstr* %name, i32 0, i32 1
  %5 = load i8*, i8** %name6, align 8, !tbaa !245
  %6 = getelementptr inbounds %struct.qstr, %struct.qstr* %name, i32 0, i32 0
  %7 = bitcast %struct.pgprot* %6 to %struct.exception_table_entry*
  %len7 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %7, i32 0, i32 1
  %8 = load i32, i32* %len7, align 4, !tbaa !166
  %call8 = call i32 @full_name_hash(i8* %5, i32 %8)
  %9 = getelementptr inbounds %struct.qstr, %struct.qstr* %name, i32 0, i32 0
  %10 = bitcast %struct.pgprot* %9 to %struct.exception_table_entry*
  %hash = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %10, i32 0, i32 0
  store i32 %call8, i32* %hash, align 8, !tbaa !166
  %call9 = call %struct.dentry* @d_lookup(%struct.dentry* %parent, %struct.qstr* %name)
  %cmp10 = icmp eq %struct.dentry* %call9, null
  br i1 %cmp10, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %d_inode12 = getelementptr inbounds %struct.dentry, %struct.dentry* %call9, i32 0, i32 5
  %11 = load %struct.inode*, %struct.inode** %d_inode12, align 8, !tbaa !1032
  %cmp13 = icmp eq %struct.inode* %11, null
  br i1 %cmp13, label %next, label %if.end16

if.end16:                                         ; preds = %if.end
  %d_inode17 = getelementptr inbounds %struct.dentry, %struct.dentry* %call9, i32 0, i32 5
  %12 = load %struct.inode*, %struct.inode** %d_inode17, align 8, !tbaa !1032
  %i_mode = getelementptr inbounds %struct.inode, %struct.inode* %12, i32 0, i32 0
  %13 = load i16, i16* %i_mode, align 8, !tbaa !1056
  %conv18 = zext i16 %13 to i32
  %and = and i32 %conv18, 61440
  %Pivot = icmp slt i32 %and, 32768
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end16
  %SwitchLeaf2 = icmp eq i32 %and, 32768
  br i1 %SwitchLeaf2, label %sw.bb, label %do.body

LeafBlock:                                        ; preds = %if.end16
  %SwitchLeaf = icmp eq i32 %and, 16384
  br i1 %SwitchLeaf, label %sw.bb23, label %do.body

do.body:                                          ; preds = %LeafBlock, %LeafBlock1
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1.1046, i32 0, i32 0), i32 701, i64 12) #7, !srcloc !1072
  br label %do.body19

do.body19:                                        ; preds = %do.body19, %do.body
  br label %do.body19

sw.bb:                                            ; preds = %LeafBlock1
  %call22 = call i32 @__rpc_unlink(%struct.inode* %0, %struct.dentry* %call9)
  br label %next

sw.bb23:                                          ; preds = %LeafBlock
  %call24 = call i32 @__rpc_rmdir(%struct.inode* %0, %struct.dentry* %call9)
  br label %next

next:                                             ; preds = %sw.bb23, %sw.bb, %if.end
  call void @dput(%struct.dentry* %call9)
  br label %for.inc

for.inc:                                          ; preds = %next, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_info_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %call = call i32 @single_open(%struct.file* %file, i32 (%struct.seq_file*, i8*)* @rpc_show_info, i8* null)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end19, label %if.then

if.then:                                          ; preds = %entry
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !947
  %1 = bitcast i8* %0 to %struct.seq_file*
  %f_path = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 1
  %dentry = getelementptr inbounds %struct.path, %struct.path* %f_path, i32 0, i32 1
  %2 = load %struct.dentry*, %struct.dentry** %dentry, align 8, !tbaa !1073
  %d_lock = getelementptr inbounds %struct.dentry, %struct.dentry* %2, i32 0, i32 8
  call void @spin_lock.1067(%struct.spinlock* %d_lock)
  %f_path1 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 1
  %dentry2 = getelementptr inbounds %struct.path, %struct.path* %f_path1, i32 0, i32 1
  %3 = load %struct.dentry*, %struct.dentry** %dentry2, align 8, !tbaa !1073
  %call3 = call i32 @d_unhashed(%struct.dentry* %3)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end, label %if.then5

if.then5:                                         ; preds = %if.then
  %call6 = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %inode)
  %private = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %call6, i32 0, i32 1
  %4 = load i8*, i8** %private, align 8, !tbaa !941
  %5 = bitcast i8* %4 to %struct.rpc_clnt*
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.then
  %clnt.0 = phi %struct.rpc_clnt* [ null, %if.then ], [ %5, %if.then5 ]
  %cmp = icmp ne %struct.rpc_clnt* %clnt.0, null
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %cl_count = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt.0, i32 0, i32 0
  %call7 = call i32 @atomic_add_unless.1104(%struct.atomic_t* %cl_count, i32 1, i32 0)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.then9, label %if.else

if.then9:                                         ; preds = %land.lhs.true
  %f_path10 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 1
  %dentry11 = getelementptr inbounds %struct.path, %struct.path* %f_path10, i32 0, i32 1
  %6 = load %struct.dentry*, %struct.dentry** %dentry11, align 8, !tbaa !1073
  %d_lock12 = getelementptr inbounds %struct.dentry, %struct.dentry* %6, i32 0, i32 8
  call void @spin_unlock.1068(%struct.spinlock* %d_lock12)
  %7 = bitcast %struct.rpc_clnt* %clnt.0 to i8*
  %private13 = getelementptr inbounds %struct.seq_file, %struct.seq_file* %1, i32 0, i32 10
  store i8* %7, i8** %private13, align 8, !tbaa !980
  br label %if.end19

if.else:                                          ; preds = %land.lhs.true, %if.end
  %f_path14 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 1
  %dentry15 = getelementptr inbounds %struct.path, %struct.path* %f_path14, i32 0, i32 1
  %8 = load %struct.dentry*, %struct.dentry** %dentry15, align 8, !tbaa !1073
  %d_lock16 = getelementptr inbounds %struct.dentry, %struct.dentry* %8, i32 0, i32 8
  call void @spin_unlock.1068(%struct.spinlock* %d_lock16)
  %call17 = call i32 @single_release(%struct.inode* %inode, %struct.file* %file)
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then9, %entry
  %ret.1 = phi i32 [ %call, %entry ], [ %call, %if.then9 ], [ -22, %if.else ]
  ret i32 %ret.1
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_info_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !947
  %1 = bitcast i8* %0 to %struct.seq_file*
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %1, i32 0, i32 10
  %2 = load i8*, i8** %private, align 8, !tbaa !980
  %3 = bitcast i8* %2 to %struct.rpc_clnt*
  %tobool = icmp ne %struct.rpc_clnt* %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @rpc_release_client(%struct.rpc_clnt* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call = call i32 @single_release(%struct.inode* %inode, %struct.file* %file)
  ret i32 %call
}

declare i32 @single_release(%struct.inode*, %struct.file*) #4

; Function Attrs: nounwind uwtable
define internal i32 @rpc_show_info(%struct.seq_file* %m, i8* %v) #0 {
entry:
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %m, i32 0, i32 10
  %0 = load i8*, i8** %private, align 8, !tbaa !980
  %1 = bitcast i8* %0 to %struct.rpc_clnt*
  call void @rcu_read_lock.1047()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %1, i32 0, i32 4
  %2 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end7

land.lhs.true:                                    ; preds = %entry
  %3 = load i8, i8* @rpc_show_info.__warned, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %3 to i1
  br i1 %tobool1, label %do.end7, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held.1049()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.end7, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rpc_show_info.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1.1046, i32 0, i32 0), i32 411, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end7

do.end7:                                          ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %servername = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %2, i32 0, i32 41
  %4 = load i8*, i8** %servername, align 8, !tbaa !216
  %call8 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.14.1108, i32 0, i32 0), i8* %4)
  %cl_protname = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %1, i32 0, i32 9
  %5 = load i8*, i8** %cl_protname, align 8, !tbaa !233
  %cl_prog = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %1, i32 0, i32 6
  %6 = load i32, i32* %cl_prog, align 8, !tbaa !155
  %cl_vers = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %1, i32 0, i32 7
  %7 = load i32, i32* %cl_vers, align 4, !tbaa !156
  %call9 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.16.1109, i32 0, i32 0), i8* %5, i32 %6, i32 %7)
  %call10 = call i8* @rpc_peeraddr2str(%struct.rpc_clnt* %1, i32 0)
  %call11 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.17.1110, i32 0, i32 0), i8* %call10)
  %call12 = call i8* @rpc_peeraddr2str(%struct.rpc_clnt* %1, i32 2)
  %call13 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.18.1111, i32 0, i32 0), i8* %call12)
  %call14 = call i8* @rpc_peeraddr2str(%struct.rpc_clnt* %1, i32 1)
  %call15 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.19.1112, i32 0, i32 0), i8* %call14)
  call void @rcu_read_unlock.1052()
  ret i32 0
}

declare i32 @single_open(%struct.file*, i32 (%struct.seq_file*, i8*)*, i8*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @d_unhashed(%struct.dentry* %dentry) #2 {
entry:
  %d_hash = getelementptr inbounds %struct.dentry, %struct.dentry* %dentry, i32 0, i32 2
  %call = call i32 @hlist_bl_unhashed(%struct.hlist_bl_node* %d_hash)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_unless.1104(%struct.atomic_t* %v, i32 %a, i32 %u) #2 {
entry:
  %call = call i32 @__atomic_add_unless.1105(%struct.atomic_t* %v, i32 %a, i32 %u)
  %cmp = icmp ne i32 %call, %u
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__atomic_add_unless.1105(%struct.atomic_t* %v, i32 %a, i32 %u) #2 {
entry:
  %call = call i32 @atomic_read.1106(%struct.atomic_t* %v)
  br label %for.cond

for.cond:                                         ; preds = %if.end13, %entry
  %c.0 = phi i32 [ %call, %entry ], [ %call2, %if.end13 ]
  %cmp = icmp eq i32 %c.0, %u
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %for.end, label %if.end

if.end:                                           ; preds = %for.cond
  %add = add nsw i32 %c.0, %a
  %call2 = call i32 @atomic_cmpxchg.1107(%struct.atomic_t* %v, i32 %c.0, i32 %add)
  %cmp3 = icmp eq i32 %call2, %c.0
  %lnot5 = xor i1 %cmp3, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %expval10 = call i64 @llvm.expect.i64(i64 %conv9, i64 1)
  %tobool11 = icmp ne i64 %expval10, 0
  br i1 %tobool11, label %for.end, label %if.end13

if.end13:                                         ; preds = %if.end
  br label %for.cond

for.end:                                          ; preds = %if.end, %for.cond
  ret i32 %c.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read.1106(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !49
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_cmpxchg.1107(%struct.atomic_t* %v, i32 %old, i32 %new) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; cmpxchgl $2,$1", "={ax},=*m,r,0,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %new, i32 %old, i32* %counter) #7, !srcloc !1074
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @hlist_bl_unhashed(%struct.hlist_bl_node* %h) #2 {
entry:
  %pprev = getelementptr inbounds %struct.hlist_bl_node, %struct.hlist_bl_node* %h, i32 0, i32 1
  %0 = load %struct.hlist_bl_node**, %struct.hlist_bl_node*** %pprev, align 8, !tbaa !1075
  %tobool = icmp ne %struct.hlist_bl_node** %0, null
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: nounwind uwtable
define i32 @rpc_remove_client_dir(%struct.dentry* %dentry) #0 {
entry:
  %call = call i32 @rpc_rmdir_depopulate(%struct.dentry* %dentry, void (%struct.dentry*)* @rpc_clntdir_depopulate)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @rpc_clntdir_depopulate(%struct.dentry* %dentry) #0 {
entry:
  call void @rpc_depopulate(%struct.dentry* %dentry, %struct.rpc_filelist* getelementptr inbounds ([1 x %struct.rpc_filelist], [1 x %struct.rpc_filelist]* @authfiles, i32 0, i32 0), i32 0, i32 1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_rmdir_depopulate(%struct.dentry* %dentry, void (%struct.dentry*)* %depopulate) #0 {
entry:
  %call = call %struct.dentry* @dget_parent(%struct.dentry* %dentry)
  %d_inode = getelementptr inbounds %struct.dentry, %struct.dentry* %call, i32 0, i32 5
  %0 = load %struct.inode*, %struct.inode** %d_inode, align 8, !tbaa !1032
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 1)
  %cmp = icmp ne void (%struct.dentry*)* %depopulate, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void %depopulate(%struct.dentry* %dentry)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call1 = call i32 @__rpc_rmdir(%struct.inode* %0, %struct.dentry* %dentry)
  %i_mutex2 = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex2)
  call void @dput(%struct.dentry* %call)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal void @rpc_depopulate(%struct.dentry* %parent, %struct.rpc_filelist* %files, i32 %start, i32 %eof) #0 {
entry:
  %d_inode = getelementptr inbounds %struct.dentry, %struct.dentry* %parent, i32 0, i32 5
  %0 = load %struct.inode*, %struct.inode** %d_inode, align 8, !tbaa !1032
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 23
  call void @mutex_lock_nested(%struct.mutex* %i_mutex, i32 2)
  call void @__rpc_depopulate(%struct.dentry* %parent, %struct.rpc_filelist* %files, i32 %start, i32 %eof)
  %i_mutex1 = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex1)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.dentry* @rpc_create_cache_dir(%struct.dentry* %parent, %struct.qstr* %name, i16 zeroext %umode, %struct.cache_detail* %cd) #0 {
entry:
  %0 = bitcast %struct.cache_detail* %cd to i8*
  %call = call %struct.dentry* @rpc_mkdir_populate(%struct.dentry* %parent, %struct.qstr* %name, i16 zeroext %umode, i8* null, i32 (%struct.dentry*, i8*)* @rpc_cachedir_populate, i8* %0)
  ret %struct.dentry* %call
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_cachedir_populate(%struct.dentry* %dentry, i8* %private) #0 {
entry:
  %call = call i32 @rpc_populate(%struct.dentry* %dentry, %struct.rpc_filelist* getelementptr inbounds ([3 x %struct.rpc_filelist], [3 x %struct.rpc_filelist]* @cache_pipefs_files, i32 0, i32 0), i32 0, i32 3, i8* %private)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define void @rpc_remove_cache_dir(%struct.dentry* %dentry) #0 {
entry:
  %call = call i32 @rpc_rmdir_depopulate(%struct.dentry* %dentry, void (%struct.dentry*)* @rpc_cachedir_depopulate)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rpc_cachedir_depopulate(%struct.dentry* %dentry) #0 {
entry:
  call void @rpc_depopulate(%struct.dentry* %dentry, %struct.rpc_filelist* getelementptr inbounds ([3 x %struct.rpc_filelist], [3 x %struct.rpc_filelist]* @cache_pipefs_files, i32 0, i32 0), i32 0, i32 3)
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_pipefs_init_net(%struct.net* %net) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.1045(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %pipefs_sb_lock = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 6
  call void @__mutex_init(%struct.mutex* %pipefs_sb_lock, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.2.1124, i32 0, i32 0), %struct.lock_class_key* @rpc_pipefs_init_net.__key)
  %gssd_running = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 20
  store i32 1, i32* %gssd_running, align 8, !tbaa !1063
  %pipe_version = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 17
  store i32 -1, i32* %pipe_version, align 4, !tbaa !1076
  ret void
}

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #4

; Function Attrs: nounwind uwtable
define i32 @register_rpc_pipefs() #0 {
entry:
  %call = call %struct.kmem_cache* @kmem_cache_create(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.3.1127, i32 0, i32 0), i64 1136, i64 0, i64 1187840, void (i8*)* @init_once)
  store %struct.kmem_cache* %call, %struct.kmem_cache** @rpc_inode_cachep, align 8, !tbaa !28
  %0 = load %struct.kmem_cache*, %struct.kmem_cache** @rpc_inode_cachep, align 8, !tbaa !28
  %tobool = icmp ne %struct.kmem_cache* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @rpc_clients_notifier_register()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %err_notifier, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @register_filesystem(%struct.file_system_type* @rpc_pipe_fs_type)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %err_register, label %cleanup

err_register:                                     ; preds = %if.end4
  call void @rpc_clients_notifier_unregister()
  br label %err_notifier

err_notifier:                                     ; preds = %err_register, %if.end
  %err.0 = phi i32 [ %call5, %err_register ], [ %call1, %if.end ]
  %1 = load %struct.kmem_cache*, %struct.kmem_cache** @rpc_inode_cachep, align 8, !tbaa !28
  call void @kmem_cache_destroy(%struct.kmem_cache* %1)
  br label %cleanup

cleanup:                                          ; preds = %err_notifier, %if.end4, %entry
  %retval.0 = phi i32 [ %err.0, %err_notifier ], [ -12, %entry ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @init_once(i8* %foo) #0 {
entry:
  %0 = bitcast i8* %foo to %struct.rpc_inode*
  %vfs_inode = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %0, i32 0, i32 0
  call void @inode_init_once(%struct.inode* %vfs_inode)
  %private = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %0, i32 0, i32 1
  store i8* null, i8** %private, align 8, !tbaa !941
  %pipe = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %0, i32 0, i32 2
  store %struct.rpc_pipe* null, %struct.rpc_pipe** %pipe, align 8, !tbaa !1035
  %waitq = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %0, i32 0, i32 3
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %waitq, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.27.1145, i32 0, i32 0), %struct.lock_class_key* @init_once.__key)
  ret void
}

declare i32 @register_filesystem(%struct.file_system_type*) #4

; Function Attrs: nounwind uwtable
define internal %struct.dentry* @rpc_mount(%struct.file_system_type* %fs_type, i32 %flags, i8* %dev_name, i8* %data) #0 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !1054
  %nsproxy = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 74
  %1 = load %struct.nsproxy*, %struct.nsproxy** %nsproxy, align 8, !tbaa !241
  %net_ns = getelementptr inbounds %struct.nsproxy, %struct.nsproxy* %1, i32 0, i32 5
  %2 = load %struct.net*, %struct.net** %net_ns, align 8, !tbaa !1077
  %3 = bitcast %struct.net* %2 to i8*
  %call1 = call %struct.dentry* @mount_ns(%struct.file_system_type* %fs_type, i32 %flags, i8* %3, i32 (%struct.super_block*, i8*, i32)* @rpc_fill_super)
  ret %struct.dentry* %call1
}

; Function Attrs: nounwind uwtable
define internal void @rpc_kill_sb(%struct.super_block* %sb) #0 {
entry:
  %s_fs_info = getelementptr inbounds %struct.super_block, %struct.super_block* %sb, i32 0, i32 36
  %0 = load i8*, i8** %s_fs_info, align 16, !tbaa !256
  %1 = bitcast i8* %0 to %struct.net*
  %2 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.1045(%struct.net* %1, i32 %2)
  %3 = bitcast i8* %call to %struct.sunrpc_net*
  %pipefs_sb_lock = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %3, i32 0, i32 6
  call void @mutex_lock_nested(%struct.mutex* %pipefs_sb_lock, i32 0)
  %pipefs_sb = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %3, i32 0, i32 5
  %4 = load %struct.super_block*, %struct.super_block** %pipefs_sb, align 8, !tbaa !1022
  %cmp = icmp ne %struct.super_block* %4, %sb
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %pipefs_sb_lock1 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %3, i32 0, i32 6
  call void @mutex_unlock(%struct.mutex* %pipefs_sb_lock1)
  br label %out

if.end:                                           ; preds = %entry
  %pipefs_sb2 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %3, i32 0, i32 5
  store %struct.super_block* null, %struct.super_block** %pipefs_sb2, align 8, !tbaa !1022
  %pipefs_sb_lock3 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %3, i32 0, i32 6
  call void @mutex_unlock(%struct.mutex* %pipefs_sb_lock3)
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %5, 4
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then6, label %do.end

if.then6:                                         ; preds = %if.end
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then6, %if.end
  %7 = bitcast %struct.super_block* %sb to i8*
  %call11 = call i32 @blocking_notifier_call_chain(%struct.blocking_notifier_head* @rpc_pipefs_notifier_list, i64 1, i8* %7)
  call void @put_net.1132(%struct.net* %1)
  br label %out

out:                                              ; preds = %do.end, %if.then
  call void @kill_litter_super(%struct.super_block* %sb)
  ret void
}

declare i32 @blocking_notifier_call_chain(%struct.blocking_notifier_head*, i64, i8*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @put_net.1132(%struct.net* %net) #2 {
entry:
  %count = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 1
  %call = call i32 @atomic_dec_and_test.1133(%struct.atomic_t* %count)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__put_net(%struct.net* %net)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @kill_litter_super(%struct.super_block*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_dec_and_test.1133(%struct.atomic_t* %v) #2 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0; sete $1", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32* %counter) #7, !srcloc !1078
  %0 = load i8, i8* %c, align 1, !tbaa !166
  %conv = zext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_fill_super(%struct.super_block* %sb, i8* %data, i32 %silent) #0 {
entry:
  %0 = bitcast i8* %data to %struct.net*
  %1 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.1045(%struct.net* %0, i32 %1)
  %2 = bitcast i8* %call to %struct.sunrpc_net*
  %s_blocksize = getelementptr inbounds %struct.super_block, %struct.super_block* %sb, i32 0, i32 3
  store i64 4096, i64* %s_blocksize, align 8, !tbaa !1079
  %s_blocksize_bits = getelementptr inbounds %struct.super_block, %struct.super_block* %sb, i32 0, i32 2
  store i8 12, i8* %s_blocksize_bits, align 4, !tbaa !1080
  %s_magic = getelementptr inbounds %struct.super_block, %struct.super_block* %sb, i32 0, i32 11
  store i64 1733912937, i64* %s_magic, align 8, !tbaa !1081
  %s_op = getelementptr inbounds %struct.super_block, %struct.super_block* %sb, i32 0, i32 6
  store %struct.super_operations* @s_ops, %struct.super_operations** %s_op, align 16, !tbaa !1082
  %s_time_gran = getelementptr inbounds %struct.super_block, %struct.super_block* %sb, i32 0, i32 39
  store i32 1, i32* %s_time_gran, align 32, !tbaa !1083
  %call1 = call %struct.inode* @rpc_get_inode(%struct.super_block* %sb, i16 zeroext 16749)
  %call2 = call %struct.dentry* @d_make_root(%struct.inode* %call1)
  %s_root = getelementptr inbounds %struct.super_block, %struct.super_block* %sb, i32 0, i32 12
  store %struct.dentry* %call2, %struct.dentry** %s_root, align 32, !tbaa !1031
  %tobool = icmp ne %struct.dentry* %call2, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call3 = call i32 @rpc_populate(%struct.dentry* %call2, %struct.rpc_filelist* getelementptr inbounds ([8 x %struct.rpc_filelist], [8 x %struct.rpc_filelist]* @files, i32 0, i32 0), i32 0, i32 8, i8* null)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %cleanup, label %do.body

do.body:                                          ; preds = %if.end
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %3, 4
  %tobool7 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool7, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %do.end

if.then10:                                        ; preds = %do.body
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then10, %do.body
  %pipefs_sb = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %2, i32 0, i32 5
  store %struct.super_block* %sb, %struct.super_block** %pipefs_sb, align 8, !tbaa !1022
  %5 = bitcast %struct.super_block* %sb to i8*
  %call14 = call i32 @blocking_notifier_call_chain(%struct.blocking_notifier_head* @rpc_pipefs_notifier_list, i64 0, i8* %5)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %err_depopulate, label %if.end17

if.end17:                                         ; preds = %do.end
  %call18 = call %struct.net* @get_net.1135(%struct.net* %0)
  %6 = bitcast %struct.net* %call18 to i8*
  %s_fs_info = getelementptr inbounds %struct.super_block, %struct.super_block* %sb, i32 0, i32 36
  store i8* %6, i8** %s_fs_info, align 16, !tbaa !256
  br label %cleanup

err_depopulate:                                   ; preds = %do.end
  %7 = bitcast %struct.super_block* %sb to i8*
  %call19 = call i32 @blocking_notifier_call_chain(%struct.blocking_notifier_head* @rpc_pipefs_notifier_list, i64 1, i8* %7)
  %pipefs_sb20 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %2, i32 0, i32 5
  store %struct.super_block* null, %struct.super_block** %pipefs_sb20, align 8, !tbaa !1022
  call void @__rpc_depopulate(%struct.dentry* %call2, %struct.rpc_filelist* getelementptr inbounds ([8 x %struct.rpc_filelist], [8 x %struct.rpc_filelist]* @files, i32 0, i32 0), i32 0, i32 8)
  br label %cleanup

cleanup:                                          ; preds = %err_depopulate, %if.end17, %if.end, %entry
  %retval.0 = phi i32 [ %call14, %err_depopulate ], [ 0, %if.end17 ], [ -12, %entry ], [ -12, %if.end ]
  ret i32 %retval.0
}

declare %struct.dentry* @mount_ns(%struct.file_system_type*, i32, i8*, i32 (%struct.super_block*, i8*, i32)*) #4

declare %struct.dentry* @d_make_root(%struct.inode*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.net* @get_net.1135(%struct.net* %net) #2 {
entry:
  %count = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 1
  call void @atomic_inc.1136(%struct.atomic_t* %count)
  ret %struct.net* %net
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.1136(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !1084
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.inode* @rpc_alloc_inode(%struct.super_block* %sb) #0 {
entry:
  %0 = load %struct.kmem_cache*, %struct.kmem_cache** @rpc_inode_cachep, align 8, !tbaa !28
  %call = call i8* @kmem_cache_alloc(%struct.kmem_cache* %0, i32 208)
  %1 = bitcast i8* %call to %struct.rpc_inode*
  %tobool = icmp ne %struct.rpc_inode* %1, null
  %vfs_inode = getelementptr inbounds %struct.rpc_inode, %struct.rpc_inode* %1, i32 0, i32 0
  %retval.0 = select i1 %tobool, %struct.inode* %vfs_inode, %struct.inode* null
  ret %struct.inode* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @rpc_destroy_inode(%struct.inode* %inode) #0 {
entry:
  %0 = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 29
  %i_rcu = bitcast %union.anon.36* %0 to %struct.callback_head*
  call void @call_rcu_sched(%struct.callback_head* %i_rcu, void (%struct.callback_head*)* @rpc_i_callback)
  ret void
}

declare i32 @simple_statfs(%struct.dentry*, %struct.kstatfs*) #4

; Function Attrs: nounwind uwtable
define internal void @rpc_i_callback(%struct.callback_head* %head) #0 {
entry:
  %0 = bitcast %struct.callback_head* %head to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -472
  %1 = bitcast i8* %add.ptr to %struct.inode*
  %2 = load %struct.kmem_cache*, %struct.kmem_cache** @rpc_inode_cachep, align 8, !tbaa !28
  %call = call %struct.rpc_inode* @RPC_I.1069(%struct.inode* %1)
  %3 = bitcast %struct.rpc_inode* %call to i8*
  call void @kmem_cache_free(%struct.kmem_cache* %2, i8* %3)
  ret void
}

declare void @kmem_cache_free(%struct.kmem_cache*, i8*) #4

declare i8* @kmem_cache_alloc(%struct.kmem_cache*, i32) #4

declare void @inode_init_once(%struct.inode*) #4

; Function Attrs: nounwind uwtable
define void @unregister_rpc_pipefs() #0 {
entry:
  call void @rpc_clients_notifier_unregister()
  %0 = load %struct.kmem_cache*, %struct.kmem_cache** @rpc_inode_cachep, align 8, !tbaa !28
  call void @kmem_cache_destroy(%struct.kmem_cache* %0)
  %call = call i32 @unregister_filesystem(%struct.file_system_type* @rpc_pipe_fs_type)
  ret void
}

declare i32 @unregister_filesystem(%struct.file_system_type*) #4

; Function Attrs: nounwind uwtable
define i32 @svc_pool_stats_open(%struct.svc_serv* %serv, %struct.file* %file) #0 {
entry:
  %call = call i32 @seq_open(%struct.file* %file, %struct.seq_operations* @svc_pool_stats_seq_ops)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.svc_serv* %serv to i8*
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %1 = load i8*, i8** %private_data, align 8, !tbaa !947
  %2 = bitcast i8* %1 to %struct.seq_file*
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %2, i32 0, i32 10
  store i8* %0, i8** %private, align 8, !tbaa !980
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 %call
}

declare i32 @seq_open(%struct.file*, %struct.seq_operations*) #4

; Function Attrs: nounwind uwtable
define internal i8* @svc_pool_stats_start(%struct.seq_file* %m, i64* %pos) #0 {
entry:
  %0 = load i64, i64* %pos, align 8, !tbaa !291
  %conv = trunc i64 %0 to i32
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %m, i32 0, i32 10
  %1 = load i8*, i8** %private, align 8, !tbaa !980
  %2 = bitcast i8* %1 to %struct.svc_serv*
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %3, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv2 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv2, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %tobool4 = icmp ne i32 %conv, 0
  br i1 %tobool4, label %if.end6, label %cleanup

if.end6:                                          ; preds = %do.end
  %sv_nrpools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %2, i32 0, i32 13
  %5 = load i32, i32* %sv_nrpools, align 8, !tbaa !721
  %cmp = icmp ugt i32 %conv, %5
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end6
  %sv_pools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %2, i32 0, i32 14
  %6 = load %struct.svc_pool*, %struct.svc_pool** %sv_pools, align 8, !tbaa !711
  %sub = sub i32 %conv, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %6, i64 %idxprom
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %if.end6
  %cond = phi %struct.svc_pool* [ %arrayidx, %cond.false ], [ null, %if.end6 ]
  %7 = bitcast %struct.svc_pool* %cond to i8*
  br label %cleanup

cleanup:                                          ; preds = %cond.end, %do.end
  %retval.0 = phi i8* [ %7, %cond.end ], [ inttoptr (i64 1 to i8*), %do.end ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @svc_pool_stats_stop(%struct.seq_file* %m, i8* %p) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @svc_pool_stats_next(%struct.seq_file* %m, i8* %p, i64* %pos) #0 {
entry:
  %0 = bitcast i8* %p to %struct.svc_pool*
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %m, i32 0, i32 10
  %1 = load i8*, i8** %private, align 8, !tbaa !980
  %2 = bitcast i8* %1 to %struct.svc_serv*
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %3, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %cmp = icmp eq i8* %p, inttoptr (i64 1 to i8*)
  %sv_pools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %2, i32 0, i32 14
  %5 = load %struct.svc_pool*, %struct.svc_pool** %sv_pools, align 8, !tbaa !711
  %arrayidx = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %5, i64 0
  br i1 %cmp, label %if.end15, label %if.else

if.else:                                          ; preds = %do.end
  %sub.ptr.lhs.cast = ptrtoint %struct.svc_pool* %0 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.svc_pool* %arrayidx to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 192
  %conv7 = trunc i64 %sub.ptr.div to i32
  %sv_nrpools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %2, i32 0, i32 13
  %6 = load i32, i32* %sv_nrpools, align 8, !tbaa !721
  %sub = sub i32 %6, 1
  %cmp8 = icmp ult i32 %conv7, %sub
  br i1 %cmp8, label %if.then10, label %if.end15

if.then10:                                        ; preds = %if.else
  %sv_pools11 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %2, i32 0, i32 14
  %7 = load %struct.svc_pool*, %struct.svc_pool** %sv_pools11, align 8, !tbaa !711
  %add = add i32 %conv7, 1
  %idxprom = zext i32 %add to i64
  %arrayidx12 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %7, i64 %idxprom
  br label %if.end15

if.end15:                                         ; preds = %if.then10, %if.else, %do.end
  %pool.1 = phi %struct.svc_pool* [ %arrayidx, %do.end ], [ %arrayidx12, %if.then10 ], [ null, %if.else ]
  %8 = load i64, i64* %pos, align 8, !tbaa !291
  %inc = add nsw i64 %8, 1
  store i64 %inc, i64* %pos, align 8, !tbaa !291
  %9 = bitcast %struct.svc_pool* %pool.1 to i8*
  ret i8* %9
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_pool_stats_show(%struct.seq_file* %m, i8* %p) #0 {
entry:
  %0 = bitcast i8* %p to %struct.svc_pool*
  %cmp = icmp eq i8* %p, inttoptr (i64 1 to i8*)
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @seq_puts(%struct.seq_file* %m, i8* getelementptr inbounds ([72 x i8], [72 x i8]* @.str.45.1149, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %entry
  %sp_id = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i32 0, i32 0
  %1 = load i32, i32* %sp_id, align 64, !tbaa !717
  %sp_stats = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i32 0, i32 6
  %packets = getelementptr inbounds %struct.sched_info, %struct.sched_info* %sp_stats, i32 0, i32 0
  %2 = load i64, i64* %packets, align 8, !tbaa !1085
  %sp_stats1 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i32 0, i32 6
  %sockets_queued = getelementptr inbounds %struct.sched_info, %struct.sched_info* %sp_stats1, i32 0, i32 1
  %3 = load i64, i64* %sockets_queued, align 8, !tbaa !1086
  %sp_stats2 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i32 0, i32 6
  %threads_woken = getelementptr inbounds %struct.sched_info, %struct.sched_info* %sp_stats2, i32 0, i32 2
  %4 = load i64, i64* %threads_woken, align 8, !tbaa !1087
  %sp_stats3 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i32 0, i32 6
  %threads_timedout = getelementptr inbounds %struct.sched_info, %struct.sched_info* %sp_stats3, i32 0, i32 3
  %5 = load i64, i64* %threads_timedout, align 8, !tbaa !1088
  %call4 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.46.1150, i32 0, i32 0), i32 %1, i64 %2, i64 %3, i64 %4, i64 %5)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @svc_xprt_names(%struct.svc_serv* %serv, i8* %buf, i32 %buflen) #0 {
entry:
  %tobool = icmp ne %struct.svc_serv* %serv, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %sv_lock = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 2
  call void @spin_lock_bh.1153(%struct.spinlock* %sv_lock)
  %sv_permsocks = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 8
  br label %for.cond

for.cond:                                         ; preds = %if.end7, %if.end
  %xpt_list10.sink = phi %struct.list_head* [ %xpt_list10, %if.end7 ], [ %sv_permsocks, %if.end ]
  %totlen.0 = phi i32 [ 0, %if.end ], [ %add, %if.end7 ]
  %pos.0 = phi i8* [ %buf, %if.end ], [ %add.ptr8, %if.end7 ]
  %next11 = getelementptr inbounds %struct.list_head, %struct.list_head* %xpt_list10.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next11, align 8, !tbaa !28
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr13 = getelementptr inbounds i8, i8* %1, i64 -24
  %2 = bitcast i8* %add.ptr13 to %struct.svc_xprt*
  %xpt_list = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 3
  %sv_permsocks1 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 8
  %cmp = icmp ne %struct.list_head* %xpt_list, %sv_permsocks1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %sub = sub nsw i32 %buflen, %totlen.0
  %call = call i32 @svc_one_xprt_name(%struct.svc_xprt* %2, i8* %pos.0, i32 %sub)
  %cmp2 = icmp slt i32 %call, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %for.body
  store i8 0, i8* %buf, align 1, !tbaa !166
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %for.body
  %totlen.1 = phi i32 [ %call, %if.then3 ], [ %totlen.0, %for.body ]
  %cmp5 = icmp sle i32 %call, 0
  br i1 %cmp5, label %for.end, label %if.end7

if.end7:                                          ; preds = %if.end4
  %idx.ext = sext i32 %call to i64
  %add.ptr8 = getelementptr inbounds i8, i8* %pos.0, i64 %idx.ext
  %add = add nsw i32 %totlen.1, %call
  %xpt_list10 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 3
  br label %for.cond

for.end:                                          ; preds = %if.end4, %for.cond
  %totlen.2 = phi i32 [ %totlen.1, %if.end4 ], [ %totlen.0, %for.cond ]
  %sv_lock14 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 2
  call void @spin_unlock_bh.1154(%struct.spinlock* %sv_lock14)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %entry
  %retval.0 = phi i32 [ %totlen.2, %for.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_bh.1153(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_one_xprt_name(%struct.svc_xprt* %xprt, i8* %pos, i32 %remaining) #0 {
entry:
  %conv = sext i32 %remaining to i64
  %xpt_class = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 0
  %0 = load %struct.svc_xprt_class*, %struct.svc_xprt_class** %xpt_class, align 8, !tbaa !639
  %xcl_name = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %0, i32 0, i32 0
  %1 = load i8*, i8** %xcl_name, align 8, !tbaa !1089
  %call = call zeroext i16 @svc_xprt_local_port(%struct.svc_xprt* %xprt)
  %conv1 = zext i16 %call to i32
  %call2 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %pos, i64 %conv, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.42.1155, i32 0, i32 0), i8* %1, i32 %conv1)
  %cmp = icmp sge i32 %call2, %remaining
  %.call2 = select i1 %cmp, i32 -36, i32 %call2
  ret i32 %.call2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_bh.1154(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @svc_xprt_local_port(%struct.svc_xprt* %xprt) #2 {
entry:
  %xpt_local = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 12
  %0 = bitcast %struct.__kernel_sockaddr_storage* %xpt_local to %struct.sockaddr*
  %call = call zeroext i16 @svc_addr_port(%struct.sockaddr* %0)
  ret i16 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @svc_addr_port(%struct.sockaddr* %sa) #2 {
entry:
  %0 = bitcast %struct.sockaddr* %sa to %struct.sockaddr_in*
  %1 = bitcast %struct.sockaddr* %sa to %struct.sockaddr_in6*
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sa, i32 0, i32 0
  %2 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %2 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb3, label %cleanup

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %LeafBlock
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %0, i32 0, i32 1
  %3 = load i16, i16* %sin_port, align 2, !tbaa !191
  %call = call zeroext i16 @__fswab16.1156(i16 zeroext %3) #3
  %conv1 = zext i16 %call to i32
  %conv2 = trunc i32 %conv1 to i16
  br label %cleanup

sw.bb3:                                           ; preds = %LeafBlock1
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %1, i32 0, i32 1
  %4 = load i16, i16* %sin6_port, align 2, !tbaa !194
  %call4 = call zeroext i16 @__fswab16.1156(i16 zeroext %4) #3
  %conv5 = zext i16 %call4 to i32
  %conv6 = trunc i32 %conv5 to i16
  br label %cleanup

cleanup:                                          ; preds = %sw.bb3, %sw.bb, %LeafBlock, %LeafBlock1
  %retval.0 = phi i16 [ %conv2, %sw.bb ], [ %conv6, %sw.bb3 ], [ 0, %LeafBlock ], [ 0, %LeafBlock1 ]
  ret i16 %retval.0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal zeroext i16 @__fswab16.1156(i16 zeroext %val) #5 {
entry:
  %conv = zext i16 %val to i32
  %and = and i32 %conv, 255
  %shl = shl i32 %and, 8
  %conv1 = zext i16 %val to i32
  %and2 = and i32 %conv1, 65280
  %shr = ashr i32 %and2, 8
  %or = or i32 %shl, %shr
  %conv3 = trunc i32 %or to i16
  ret i16 %conv3
}

; Function Attrs: nounwind uwtable
define %struct.svc_xprt* @svc_find_xprt(%struct.svc_serv* %serv, i8* %xcl_name, %struct.net* %net, i16 zeroext %af, i16 zeroext %port) #0 {
entry:
  %cmp = icmp eq %struct.svc_serv* %serv, null
  %cmp1 = icmp eq i8* %xcl_name, null
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %sv_lock = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 2
  call void @spin_lock_bh.1153(%struct.spinlock* %sv_lock)
  %sv_permsocks = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %xpt_list30.sink = phi %struct.list_head* [ %xpt_list30, %for.inc ], [ %sv_permsocks, %if.end ]
  %next31 = getelementptr inbounds %struct.list_head, %struct.list_head* %xpt_list30.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next31, align 8, !tbaa !28
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr33 = getelementptr inbounds i8, i8* %1, i64 -24
  %2 = bitcast i8* %add.ptr33 to %struct.svc_xprt*
  %xpt_list = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 3
  %sv_permsocks2 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 8
  %cmp3 = icmp ne %struct.list_head* %xpt_list, %sv_permsocks2
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %xpt_net = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 18
  %3 = load %struct.net*, %struct.net** %xpt_net, align 8, !tbaa !810
  %cmp4 = icmp ne %struct.net* %3, %net
  br i1 %cmp4, label %for.inc, label %if.end6

if.end6:                                          ; preds = %for.body
  %xpt_class = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 0
  %4 = load %struct.svc_xprt_class*, %struct.svc_xprt_class** %xpt_class, align 8, !tbaa !639
  %xcl_name7 = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %4, i32 0, i32 0
  %5 = load i8*, i8** %xcl_name7, align 8, !tbaa !1089
  %call = call i32 @strcmp(i8* %5, i8* %xcl_name)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %for.inc, label %if.end9

if.end9:                                          ; preds = %if.end6
  %conv = zext i16 %af to i32
  %cmp10 = icmp ne i32 %conv, 0
  br i1 %cmp10, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.end9
  %conv12 = zext i16 %af to i32
  %xpt_local = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 12
  %ss_family = getelementptr inbounds %struct.__kernel_sockaddr_storage, %struct.__kernel_sockaddr_storage* %xpt_local, i32 0, i32 0
  %6 = load i16, i16* %ss_family, align 8, !tbaa !1090
  %conv13 = zext i16 %6 to i32
  %cmp14 = icmp ne i32 %conv12, %conv13
  br i1 %cmp14, label %for.inc, label %if.end17

if.end17:                                         ; preds = %land.lhs.true, %if.end9
  %conv18 = zext i16 %port to i32
  %cmp19 = icmp ne i32 %conv18, 0
  br i1 %cmp19, label %land.lhs.true21, label %if.end28

land.lhs.true21:                                  ; preds = %if.end17
  %conv22 = zext i16 %port to i32
  %call23 = call zeroext i16 @svc_xprt_local_port(%struct.svc_xprt* %2)
  %conv24 = zext i16 %call23 to i32
  %cmp25 = icmp ne i32 %conv22, %conv24
  br i1 %cmp25, label %for.inc, label %if.end28

if.end28:                                         ; preds = %land.lhs.true21, %if.end17
  call void @svc_xprt_get(%struct.svc_xprt* %2)
  br label %for.end

for.inc:                                          ; preds = %land.lhs.true21, %land.lhs.true, %if.end6, %for.body
  %xpt_list30 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 3
  br label %for.cond

for.end:                                          ; preds = %if.end28, %for.cond
  %found.0 = phi %struct.svc_xprt* [ %2, %if.end28 ], [ null, %for.cond ]
  %sv_lock34 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 2
  call void @spin_unlock_bh.1154(%struct.spinlock* %sv_lock34)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %entry
  %retval.0 = phi %struct.svc_xprt* [ %found.0, %for.end ], [ null, %entry ]
  ret %struct.svc_xprt* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @svc_xprt_get(%struct.svc_xprt* %xprt) #2 {
entry:
  %xpt_ref = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 2
  call void @kref_get.1157(%struct.arch_spinlock* %xpt_ref)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_get.1157(%struct.arch_spinlock* %kref) #2 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_add_return.1158(i32 1, %struct.atomic_t* %refcount)
  %cmp = icmp slt i32 %call, 2
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  %0 = load i8, i8* @kref_get.__warned.1159, align 1, !tbaa !29, !range !31
  %tobool7 = trunc i8 %0 to i1
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %tobool14 = icmp ne i32 %lnot.ext13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.23.1160, i32 0, i32 0), i32 47)
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then
  %tobool23 = icmp ne i32 %lnot.ext13, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end
  store i8 1, i8* @kref_get.__warned.1159, align 1, !tbaa !29
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_return.1158(i32 %i, %struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #7, !srcloc !1091
  %add = add nsw i32 %i, %0
  ret i32 %add
}

; Function Attrs: nounwind uwtable
define void @svc_close_xprt(%struct.svc_xprt* %xprt) #0 {
entry:
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 2, i64* %xpt_flags) #7, !srcloc !1092
  %xpt_flags1 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  %call = call i32 @test_and_set_bit.1164(i32 0, i64* %xpt_flags1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @svc_delete_xprt(%struct.svc_xprt* %xprt)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_and_set_bit.1164(i32 %nr, i64* %addr) #2 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !1093
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal void @svc_delete_xprt(%struct.svc_xprt* %xprt) #0 {
entry:
  %xpt_server = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 6
  %0 = load %struct.svc_serv*, %struct.svc_serv** %xpt_server, align 8, !tbaa !782
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  %call = call i32 @test_and_set_bit.1164(i32 6, i64* %xpt_flags)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %do.body, label %do.body4

do.body:                                          ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.15.1165, i32 0, i32 0), i32 922, i64 12) #7, !srcloc !1094
  br label %do.body1

do.body1:                                         ; preds = %do.body1, %do.body
  br label %do.body1

do.body4:                                         ; preds = %entry
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 256
  %tobool5 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool5, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then8, label %do.end12

if.then8:                                         ; preds = %do.body4
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end12

do.end12:                                         ; preds = %if.then8, %do.body4
  %xpt_ops = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 1
  %3 = load %struct.svc_xprt_ops*, %struct.svc_xprt_ops** %xpt_ops, align 8, !tbaa !653
  %xpo_detach = getelementptr inbounds %struct.svc_xprt_ops, %struct.svc_xprt_ops* %3, i32 0, i32 7
  %4 = load void (%struct.svc_xprt*)*, void (%struct.svc_xprt*)** %xpo_detach, align 8, !tbaa !1095
  call void %4(%struct.svc_xprt* %xprt)
  %sv_lock = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 2
  call void @spin_lock_bh.1153(%struct.spinlock* %sv_lock)
  %xpt_flags13 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  %call14 = call i32 @test_and_set_bit.1164(i32 10, i64* %xpt_flags13)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %do.end12
  %xpt_list = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 3
  call void @list_del_init.1167(%struct.list_head* %xpt_list)
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %do.end12
  %xpt_ready = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 4
  %call18 = call i32 @list_empty.1168(%struct.list_head* %xpt_ready)
  %tobool19 = icmp ne i32 %call18, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot24 = xor i1 %lnot22, true
  %lnot.ext25 = zext i1 %lnot24 to i32
  %tobool26 = icmp ne i32 %lnot.ext25, 0
  %lnot27 = xor i1 %tobool26, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %if.then34, label %if.end62

if.then34:                                        ; preds = %if.end17
  %5 = load i8, i8* @svc_delete_xprt.__warned, align 1, !tbaa !29, !range !31
  %tobool35 = trunc i8 %5 to i1
  %lnot36 = xor i1 %tobool35, true
  %lnot38 = xor i1 %lnot36, true
  %lnot40 = xor i1 %lnot38, true
  %lnot.ext41 = zext i1 %lnot40 to i32
  %tobool42 = icmp ne i32 %lnot.ext41, 0
  %lnot43 = xor i1 %tobool42, true
  %lnot45 = xor i1 %lnot43, true
  %lnot.ext46 = zext i1 %lnot45 to i32
  %conv47 = sext i32 %lnot.ext46 to i64
  %expval48 = call i64 @llvm.expect.i64(i64 %conv47, i64 0)
  %tobool49 = icmp ne i64 %expval48, 0
  br i1 %tobool49, label %if.then50, label %if.end51

if.then50:                                        ; preds = %if.then34
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.15.1165, i32 0, i32 0), i32 930)
  br label %if.end51

if.end51:                                         ; preds = %if.then50, %if.then34
  %tobool52 = icmp ne i32 %lnot.ext41, 0
  %lnot53 = xor i1 %tobool52, true
  %lnot55 = xor i1 %lnot53, true
  %lnot.ext56 = zext i1 %lnot55 to i32
  %conv57 = sext i32 %lnot.ext56 to i64
  %expval58 = call i64 @llvm.expect.i64(i64 %conv57, i64 0)
  %tobool59 = icmp ne i64 %expval58, 0
  br i1 %tobool59, label %if.then60, label %if.end62

if.then60:                                        ; preds = %if.end51
  store i8 1, i8* @svc_delete_xprt.__warned, align 1, !tbaa !29
  br label %if.end62

if.end62:                                         ; preds = %if.then60, %if.end51, %if.end17
  %xpt_flags71 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  %6 = load volatile i64, i64* %xpt_flags71, align 8, !tbaa !88
  %and.i = and i64 16, %6
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool73 = icmp ne i32 %conv.i, 0
  br i1 %tobool73, label %if.then77, label %if.end78

if.then77:                                        ; preds = %if.end62
  %sv_tmpcnt = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 10
  %7 = load i32, i32* %sv_tmpcnt, align 8, !tbaa !1096
  %dec = add nsw i32 %7, -1
  store i32 %dec, i32* %sv_tmpcnt, align 8, !tbaa !1096
  br label %if.end78

if.end78:                                         ; preds = %if.then77, %if.end62
  %sv_lock79 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 2
  call void @spin_unlock_bh.1154(%struct.spinlock* %sv_lock79)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end78
  %call80 = call %struct.svc_deferred_req* @svc_deferred_dequeue(%struct.svc_xprt* %xprt)
  %cmp = icmp ne %struct.svc_deferred_req* %call80, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %8 = bitcast %struct.svc_deferred_req* %call80 to i8*
  call void @kfree(i8* %8)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  call void @call_xpt_users(%struct.svc_xprt* %xprt)
  call void @svc_xprt_put(%struct.svc_xprt* %xprt)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init.1167(%struct.list_head* %entry1) #2 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD.1178(%struct.list_head* %entry1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty.1168(%struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal %struct.svc_deferred_req* @svc_deferred_dequeue(%struct.svc_xprt* %xprt) #0 {
entry:
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  %0 = load volatile i64, i64* %xpt_flags, align 8, !tbaa !88
  %and.i = and i64 256, %0
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %xpt_lock = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 9
  call void @spin_lock.1175(%struct.spinlock* %xpt_lock)
  %xpt_deferred = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 11
  %call4 = call i32 @list_empty.1168(%struct.list_head* %xpt_deferred)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.else, label %if.then6

if.then6:                                         ; preds = %if.end
  %xpt_deferred7 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 11
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %xpt_deferred7, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !1097
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -304
  %3 = bitcast i8* %add.ptr to %struct.svc_deferred_req*
  %handle = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %3, i32 0, i32 6
  %recent = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %handle, i32 0, i32 1
  call void @list_del_init.1167(%struct.list_head* %recent)
  br label %if.end9

if.else:                                          ; preds = %if.end
  %xpt_flags8 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags8, i32 8, i64* %xpt_flags8) #7, !srcloc !1098
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then6
  %dr.0 = phi %struct.svc_deferred_req* [ null, %if.else ], [ %3, %if.then6 ]
  %xpt_lock10 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 9
  call void @spin_unlock.1176(%struct.spinlock* %xpt_lock10)
  br label %cleanup

cleanup:                                          ; preds = %if.end9, %entry
  %retval.0 = phi %struct.svc_deferred_req* [ %dr.0, %if.end9 ], [ null, %entry ]
  ret %struct.svc_deferred_req* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @call_xpt_users(%struct.svc_xprt* %xprt) #0 {
entry:
  %xpt_lock = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 9
  call void @spin_lock.1175(%struct.spinlock* %xpt_lock)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %xpt_users = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 17
  %call = call i32 @list_empty.1168(%struct.list_head* %xpt_users)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %xpt_users1 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 17
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %xpt_users1, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.svc_xpt_user*
  %list = getelementptr inbounds %struct.svc_xpt_user, %struct.svc_xpt_user* %2, i32 0, i32 0
  call void @list_del(%struct.list_head* %list)
  %callback = getelementptr inbounds %struct.svc_xpt_user, %struct.svc_xpt_user* %2, i32 0, i32 1
  %3 = load void (%struct.svc_xpt_user*)*, void (%struct.svc_xpt_user*)** %callback, align 8, !tbaa !1099
  call void %3(%struct.svc_xpt_user* %2)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %xpt_lock2 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 9
  call void @spin_unlock.1176(%struct.spinlock* %xpt_lock2)
  ret void
}

; Function Attrs: nounwind uwtable
define void @svc_xprt_put(%struct.svc_xprt* %xprt) #0 {
entry:
  %xpt_ref = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 2
  call void @kref_put.1170(%struct.arch_spinlock* %xpt_ref, void (%struct.arch_spinlock*)* @svc_xprt_free)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_xprt_free(%struct.arch_spinlock* %kref) #0 {
entry:
  %0 = bitcast %struct.arch_spinlock* %kref to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.svc_xprt*
  %xpt_class = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %1, i32 0, i32 0
  %2 = load %struct.svc_xprt_class*, %struct.svc_xprt_class** %xpt_class, align 8, !tbaa !639
  %xcl_owner = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %2, i32 0, i32 1
  %3 = load %struct.module*, %struct.module** %xcl_owner, align 8, !tbaa !1101
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %1, i32 0, i32 5
  %4 = load volatile i64, i64* %xpt_flags, align 8, !tbaa !88
  %and.i = and i64 4096, %4
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void bitcast (void (%struct.svc_xprt.5727*)* @svcauth_unix_info_release to void (%struct.svc_xprt*)*)(%struct.svc_xprt* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %xpt_net = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %1, i32 0, i32 18
  %5 = load %struct.net*, %struct.net** %xpt_net, align 8, !tbaa !810
  call void @put_net.1173(%struct.net* %5)
  %xpt_bc_xprt = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %1, i32 0, i32 19
  %6 = load %struct.rpc_xprt*, %struct.rpc_xprt** %xpt_bc_xprt, align 8, !tbaa !364
  %tobool4 = icmp ne %struct.rpc_xprt* %6, null
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %xpt_bc_xprt6 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %1, i32 0, i32 19
  %7 = load %struct.rpc_xprt*, %struct.rpc_xprt** %xpt_bc_xprt6, align 8, !tbaa !364
  call void @xprt_put(%struct.rpc_xprt* %7)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end
  %xpt_ops = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %1, i32 0, i32 1
  %8 = load %struct.svc_xprt_ops*, %struct.svc_xprt_ops** %xpt_ops, align 8, !tbaa !653
  %xpo_free = getelementptr inbounds %struct.svc_xprt_ops, %struct.svc_xprt_ops* %8, i32 0, i32 8
  %9 = load void (%struct.svc_xprt*)*, void (%struct.svc_xprt*)** %xpo_free, align 8, !tbaa !1102
  call void %9(%struct.svc_xprt* %1)
  call void @module_put(%struct.module* %3)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_put.1170(%struct.arch_spinlock* %kref, void (%struct.arch_spinlock*)* %release) #2 {
entry:
  call void @kref_sub.1171(%struct.arch_spinlock* %kref, i32 1, void (%struct.arch_spinlock*)* %release)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_sub.1171(%struct.arch_spinlock* %kref, i32 %count, void (%struct.arch_spinlock*)* %release) #2 {
entry:
  %cmp = icmp eq void (%struct.arch_spinlock*)* %release, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.23.1160, i32 0, i32 0), i32 71)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  %call = call i32 @atomic_sub_and_test.1172(i32 %count, %struct.atomic_t* %refcount)
  %tobool14 = icmp ne i32 %call, 0
  br i1 %tobool14, label %if.then15, label %return

if.then15:                                        ; preds = %if.end
  call void %release(%struct.arch_spinlock* %kref)
  br label %return

return:                                           ; preds = %if.then15, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_sub_and_test.1172(i32 %i, %struct.atomic_t* %v) #2 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subl $2,$0; sete $1", "=*m,=*qm,ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32 %i, i32* %counter) #7, !srcloc !1103
  %0 = load i8, i8* %c, align 1, !tbaa !166
  %conv = zext i8 %0 to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @put_net.1173(%struct.net* %net) #2 {
entry:
  %count = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 1
  %call = call i32 @atomic_dec_and_test.1174(%struct.atomic_t* %count)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__put_net(%struct.net* %net)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_dec_and_test.1174(%struct.atomic_t* %v) #2 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0; sete $1", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32* %counter) #7, !srcloc !1104
  %0 = load i8, i8* %c, align 1, !tbaa !166
  %conv = zext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock.1175(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock.1176(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.1178(%struct.list_head* %list) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !163
  ret void
}

; Function Attrs: nounwind uwtable
define void @svc_drop(%struct.svc_rqst* %rqstp) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  call void @svc_xprt_release(%struct.svc_rqst* %rqstp)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_xprt_release(%struct.svc_rqst* %rqstp) #0 {
entry:
  %rq_xprt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %0 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt, align 8, !tbaa !635
  %rq_xprt1 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %1 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt1, align 8, !tbaa !635
  %xpt_ops = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %1, i32 0, i32 1
  %2 = load %struct.svc_xprt_ops*, %struct.svc_xprt_ops** %xpt_ops, align 8, !tbaa !653
  %xpo_release_rqst = getelementptr inbounds %struct.svc_xprt_ops, %struct.svc_xprt_ops* %2, i32 0, i32 6
  %3 = load void (%struct.svc_rqst*)*, void (%struct.svc_rqst*)** %xpo_release_rqst, align 8, !tbaa !1105
  call void %3(%struct.svc_rqst* %rqstp)
  %rq_deferred = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 13
  %4 = load %struct.svc_deferred_req*, %struct.svc_deferred_req** %rq_deferred, align 8, !tbaa !1106
  %5 = bitcast %struct.svc_deferred_req* %4 to i8*
  call void @kfree(i8* %5)
  %rq_deferred2 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 13
  store %struct.svc_deferred_req* null, %struct.svc_deferred_req** %rq_deferred2, align 8, !tbaa !1106
  call void @svc_free_res_pages(%struct.svc_rqst* %rqstp)
  %rq_res = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res, i32 0, i32 4
  store i32 0, i32* %page_len, align 4, !tbaa !700
  %rq_res3 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res3, i32 0, i32 3
  store i32 0, i32* %page_base, align 8, !tbaa !699
  %rq_res4 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res4, i32 0, i32 7
  %6 = load i32, i32* %len, align 8, !tbaa !698
  %rq_reserved = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 32
  %7 = load i32, i32* %rq_reserved, align 8, !tbaa !1107
  %cmp = icmp ugt i32 %6, %7
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rq_res8 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res8, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  store i64 0, i64* %iov_len, align 8, !tbaa !149
  call void @svc_reserve(%struct.svc_rqst* %rqstp, i32 0)
  %rq_xprt9 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  store %struct.svc_xprt* null, %struct.svc_xprt** %rq_xprt9, align 8, !tbaa !635
  call void @svc_xprt_put(%struct.svc_xprt* %0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @svc_free_res_pages(%struct.svc_rqst* %rqstp) #2 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %rq_next_page = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 21
  %0 = load %struct.page**, %struct.page*** %rq_next_page, align 8, !tbaa !696
  %rq_respages = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 19
  %1 = load %struct.page**, %struct.page*** %rq_respages, align 8, !tbaa !695
  %cmp = icmp ne %struct.page** %0, %1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %rq_next_page1 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 21
  %2 = load %struct.page**, %struct.page*** %rq_next_page1, align 8, !tbaa !696
  %incdec.ptr = getelementptr inbounds %struct.page*, %struct.page** %2, i32 -1
  store %struct.page** %incdec.ptr, %struct.page*** %rq_next_page1, align 8, !tbaa !696
  %3 = load %struct.page*, %struct.page** %incdec.ptr, align 8, !tbaa !28
  %tobool = icmp ne %struct.page* %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %4 = load %struct.page*, %struct.page** %incdec.ptr, align 8, !tbaa !28
  call void @put_page(%struct.page* %4)
  store %struct.page* null, %struct.page** %incdec.ptr, align 8, !tbaa !28
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define void @svc_reserve(%struct.svc_rqst* %rqstp, i32 %space) #0 {
entry:
  %rq_res = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %0 = load i64, i64* %iov_len, align 8, !tbaa !149
  %conv = sext i32 %space to i64
  %add = add i64 %conv, %0
  %conv1 = trunc i64 %add to i32
  %rq_reserved = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 32
  %1 = load i32, i32* %rq_reserved, align 8, !tbaa !1107
  %cmp = icmp slt i32 %conv1, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %rq_xprt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %2 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt, align 8, !tbaa !635
  %rq_reserved3 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 32
  %3 = load i32, i32* %rq_reserved3, align 8, !tbaa !1107
  %sub = sub nsw i32 %3, %conv1
  %xpt_reserved = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 7
  call void @atomic_sub(i32 %sub, %struct.atomic_t* %xpt_reserved)
  %rq_reserved4 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 32
  store i32 %conv1, i32* %rq_reserved4, align 8, !tbaa !1107
  call void @svc_xprt_enqueue(%struct.svc_xprt* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_sub(i32 %i, %struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subl $1,$0", "=*m,ir,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #7, !srcloc !1108
  ret void
}

; Function Attrs: nounwind uwtable
define void @svc_xprt_enqueue(%struct.svc_xprt* %xprt) #0 {
entry:
  %call = call zeroext i1 @svc_xprt_has_something_to_do(%struct.svc_xprt* %xprt)
  br i1 %call, label %do.body1, label %cleanup.cont

do.body1:                                         ; preds = %entry
  %call2 = call %struct.thread_info* @current_thread_info.1187()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call2, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !1109
  %1 = call i32 asm "movl %gs:${1:P},$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @cpu_number) #9, !srcloc !1110
  %xpt_server = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 6
  %2 = load %struct.svc_serv*, %struct.svc_serv** %xpt_server, align 8, !tbaa !782
  %call10 = call %struct.svc_pool* @svc_pool_for_cpu(%struct.svc_serv* %2, i32 %1)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !1111
  %call14 = call %struct.thread_info* @current_thread_info.1187()
  %preempt_count15 = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call14, i32 0, i32 5
  %3 = load i32, i32* %preempt_count15, align 4, !tbaa !127
  %sub = sub nsw i32 %3, 1
  store i32 %sub, i32* %preempt_count15, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !1112
  %sp_lock = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %call10, i32 0, i32 1
  call void @spin_lock_bh.1153(%struct.spinlock* %sp_lock)
  %sp_threads = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %call10, i32 0, i32 2
  %call25 = call i32 @list_empty.1168(%struct.list_head* %sp_threads)
  %tobool = icmp ne i32 %call25, 0
  br i1 %tobool, label %if.end30, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body1
  %sp_sockets = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %call10, i32 0, i32 3
  %call26 = call i32 @list_empty.1168(%struct.list_head* %sp_sockets)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %if.end30, label %if.then28

if.then28:                                        ; preds = %land.lhs.true
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %land.lhs.true, %do.body1
  %sp_stats = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %call10, i32 0, i32 6
  %packets = getelementptr inbounds %struct.sched_info, %struct.sched_info* %sp_stats, i32 0, i32 0
  %5 = load i64, i64* %packets, align 8, !tbaa !1085
  %inc = add i64 %5, 1
  store i64 %inc, i64* %packets, align 8, !tbaa !1085
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  %call31 = call i32 @test_and_set_bit.1164(i32 0, i64* %xpt_flags)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %do.body34, label %if.end43

do.body34:                                        ; preds = %if.end30
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %6, 256
  %tobool35 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool35, true
  %lnot36 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot36 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool37 = icmp ne i64 %expval, 0
  br i1 %tobool37, label %if.then38, label %out_unlock

if.then38:                                        ; preds = %do.body34
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_unlock

if.end43:                                         ; preds = %if.end30
  %sp_threads44 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %call10, i32 0, i32 2
  %call45 = call i32 @list_empty.1168(%struct.list_head* %sp_threads44)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %do.body73, label %if.then47

if.then47:                                        ; preds = %if.end43
  %sp_threads48 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %call10, i32 0, i32 2
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %sp_threads48, i32 0, i32 0
  %8 = load %struct.list_head*, %struct.list_head** %next, align 16, !tbaa !1113
  %9 = bitcast %struct.list_head* %8 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %9, i64 0
  %10 = bitcast i8* %add.ptr to %struct.svc_rqst*
  %11 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and51 = and i32 %11, 256
  %tobool52 = icmp ne i32 %and51, 0
  %lnot53 = xor i1 %tobool52, true
  %lnot55 = xor i1 %lnot53, true
  %lnot.ext56 = zext i1 %lnot55 to i32
  %conv57 = sext i32 %lnot.ext56 to i64
  %expval58 = call i64 @llvm.expect.i64(i64 %conv57, i64 0)
  %tobool59 = icmp ne i64 %expval58, 0
  br i1 %tobool59, label %if.then60, label %do.end64

if.then60:                                        ; preds = %if.then47
  %12 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end64

do.end64:                                         ; preds = %if.then60, %if.then47
  call void @svc_thread_dequeue(%struct.svc_rqst* %10)
  %rq_xprt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %10, i32 0, i32 2
  %13 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt, align 8, !tbaa !635
  %tobool65 = icmp ne %struct.svc_xprt* %13, null
  br i1 %tobool65, label %if.then66, label %if.end69

if.then66:                                        ; preds = %do.end64
  %14 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end69

if.end69:                                         ; preds = %if.then66, %do.end64
  %rq_xprt70 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %10, i32 0, i32 2
  store %struct.svc_xprt* %xprt, %struct.svc_xprt** %rq_xprt70, align 8, !tbaa !635
  call void @svc_xprt_get(%struct.svc_xprt* %xprt)
  %sp_stats71 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %call10, i32 0, i32 6
  %threads_woken = getelementptr inbounds %struct.sched_info, %struct.sched_info* %sp_stats71, i32 0, i32 2
  %15 = load i64, i64* %threads_woken, align 8, !tbaa !1087
  %inc72 = add i64 %15, 1
  store i64 %inc72, i64* %threads_woken, align 8, !tbaa !1087
  %rq_wait = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %10, i32 0, i32 40
  call void @__wake_up(%struct.__wait_queue_head* %rq_wait, i32 3, i32 1, i8* null)
  br label %out_unlock

do.body73:                                        ; preds = %if.end43
  %16 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and74 = and i32 %16, 256
  %tobool75 = icmp ne i32 %and74, 0
  %lnot76 = xor i1 %tobool75, true
  %lnot78 = xor i1 %lnot76, true
  %lnot.ext79 = zext i1 %lnot78 to i32
  %conv80 = sext i32 %lnot.ext79 to i64
  %expval81 = call i64 @llvm.expect.i64(i64 %conv80, i64 0)
  %tobool82 = icmp ne i64 %expval81, 0
  br i1 %tobool82, label %if.then83, label %do.end87

if.then83:                                        ; preds = %do.body73
  %17 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end87

do.end87:                                         ; preds = %if.then83, %do.body73
  %xpt_ready = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 4
  %sp_sockets88 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %call10, i32 0, i32 3
  call void @list_add_tail.1193(%struct.list_head* %xpt_ready, %struct.list_head* %sp_sockets88)
  %sp_stats89 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %call10, i32 0, i32 6
  %sockets_queued = getelementptr inbounds %struct.sched_info, %struct.sched_info* %sp_stats89, i32 0, i32 1
  %18 = load i64, i64* %sockets_queued, align 8, !tbaa !1086
  %inc90 = add i64 %18, 1
  store i64 %inc90, i64* %sockets_queued, align 8, !tbaa !1086
  br label %out_unlock

out_unlock:                                       ; preds = %do.end87, %if.end69, %if.then38, %do.body34
  %sp_lock92 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %call10, i32 0, i32 1
  call void @spin_unlock_bh.1154(%struct.spinlock* %sp_lock92)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %out_unlock, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @svc_xprt_has_something_to_do(%struct.svc_xprt* %xprt) #0 {
entry:
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  %0 = load i64, i64* %xpt_flags, align 8, !tbaa !1114
  %and = and i64 %0, 6
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %xpt_flags1 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  %1 = load i64, i64* %xpt_flags1, align 8, !tbaa !1114
  %and2 = and i64 %1, 264
  %tobool3 = icmp ne i64 %and2, 0
  br i1 %tobool3, label %if.then4, label %return

if.then4:                                         ; preds = %if.end
  %xpt_ops = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 1
  %2 = load %struct.svc_xprt_ops*, %struct.svc_xprt_ops** %xpt_ops, align 8, !tbaa !653
  %xpo_has_wspace = getelementptr inbounds %struct.svc_xprt_ops, %struct.svc_xprt_ops* %2, i32 0, i32 2
  %3 = load i32 (%struct.svc_xprt*)*, i32 (%struct.svc_xprt*)** %xpo_has_wspace, align 8, !tbaa !1115
  %call = call i32 %3(%struct.svc_xprt* %xprt)
  %tobool5 = icmp ne i32 %call, 0
  br label %return

return:                                           ; preds = %if.then4, %if.end, %entry
  %retval.0 = phi i1 [ %tobool5, %if.then4 ], [ true, %entry ], [ false, %if.end ]
  ret i1 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.1187() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !1116
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: nounwind uwtable
define internal void @svc_thread_dequeue(%struct.svc_rqst* %rqstp) #0 {
entry:
  %rq_list = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 0
  call void @list_del(%struct.list_head* %rq_list)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.1193(%struct.list_head* %new, %struct.list_head* %head) #2 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !163
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @svc_recv(%struct.svc_rqst* %rqstp, i64 %timeout) #0 {
entry:
  %rq_server = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 7
  %0 = load %struct.svc_serv*, %struct.svc_serv** %rq_server, align 8, !tbaa !642
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %rq_xprt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %3 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt, align 8, !tbaa !635
  %tobool3 = icmp ne %struct.svc_xprt* %3, null
  br i1 %tobool3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %do.end
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %do.end
  %rq_wait = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 40
  %call7 = call i32 @waitqueue_active.1196(%struct.__wait_queue_head* %rq_wait)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end6
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end6
  %call12 = call i32 @svc_alloc_arg(%struct.svc_rqst* %rqstp)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %cleanup, label %if.end15

if.end15:                                         ; preds = %if.end11
  call void @try_to_freeze.1198()
  call void @__might_sleep(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.15.1165, i32 0, i32 0), i32 780, i32 0)
  %call17 = call i32 @_cond_resched()
  %6 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !1117
  %call19 = call i32 @signal_pending.1200(%struct.task_struct* %6)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end15
  %call21 = call zeroext i1 @kthread_should_stop()
  br i1 %call21, label %cleanup, label %if.end24

if.end24:                                         ; preds = %lor.lhs.false
  %call25 = call %struct.svc_xprt* @svc_get_next_xprt(%struct.svc_rqst* %rqstp, i64 %timeout)
  %7 = bitcast %struct.svc_xprt* %call25 to i8*
  %call26 = call i64 @IS_ERR.1201(i8* %7)
  %tobool27 = icmp ne i64 %call26, 0
  br i1 %tobool27, label %if.then28, label %if.end31

if.then28:                                        ; preds = %if.end24
  %8 = bitcast %struct.svc_xprt* %call25 to i8*
  %call29 = call i64 @PTR_ERR.1202(i8* %8)
  %conv30 = trunc i64 %call29 to i32
  br label %cleanup

if.end31:                                         ; preds = %if.end24
  %call32 = call i32 @svc_handle_xprt(%struct.svc_rqst* %rqstp, %struct.svc_xprt* %call25)
  %cmp = icmp sle i32 %call32, 0
  br i1 %cmp, label %out, label %if.end35

if.end35:                                         ; preds = %if.end31
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %call25, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 9, i64* %xpt_flags) #7, !srcloc !1098
  %call36 = call %struct.sockaddr* @svc_addr.1203(%struct.svc_rqst* %rqstp)
  %call37 = call i32 @svc_port_is_privileged(%struct.sockaddr* %call36)
  %conv38 = trunc i32 %call37 to i16
  %rq_secure = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 28
  %9 = trunc i16 %conv38 to i8
  %bf.load = load i8, i8* %rq_secure, align 4
  %bf.value = and i8 %9, 1
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, %bf.value
  store i8 %bf.set, i8* %rq_secure, align 4
  %rq_chandle = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 33
  %defer = getelementptr inbounds %struct.cache_req, %struct.cache_req* %rq_chandle, i32 0, i32 0
  store %struct.cache_deferred_req* (%struct.cache_req*)* @svc_defer, %struct.cache_deferred_req* (%struct.cache_req*)** %defer, align 8, !tbaa !1118
  %sv_stats = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 1
  %10 = load %struct.svc_stat*, %struct.svc_stat** %sv_stats, align 8, !tbaa !670
  %tobool39 = icmp ne %struct.svc_stat* %10, null
  br i1 %tobool39, label %if.then40, label %cleanup

if.then40:                                        ; preds = %if.end35
  %sv_stats41 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 1
  %11 = load %struct.svc_stat*, %struct.svc_stat** %sv_stats41, align 8, !tbaa !670
  %netcnt = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %11, i32 0, i32 1
  %12 = load i32, i32* %netcnt, align 8, !tbaa !1119
  %inc = add i32 %12, 1
  store i32 %inc, i32* %netcnt, align 8, !tbaa !1119
  br label %cleanup

out:                                              ; preds = %if.end31
  %rq_res = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %len43 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res, i32 0, i32 7
  store i32 0, i32* %len43, align 8, !tbaa !698
  call void @svc_xprt_release(%struct.svc_rqst* %rqstp)
  br label %cleanup

cleanup:                                          ; preds = %out, %if.then40, %if.end35, %if.then28, %lor.lhs.false, %if.end15, %if.end11
  %retval.0 = phi i32 [ %conv30, %if.then28 ], [ -11, %out ], [ %call12, %if.end11 ], [ -4, %lor.lhs.false ], [ -4, %if.end15 ], [ %call32, %if.then40 ], [ %call32, %if.end35 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @waitqueue_active.1196(%struct.__wait_queue_head* %q) #2 {
entry:
  %task_list = getelementptr inbounds %struct.__wait_queue_head, %struct.__wait_queue_head* %q, i32 0, i32 1
  %call = call i32 @list_empty.1168(%struct.list_head* %task_list)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: nounwind uwtable
define i32 @svc_alloc_arg(%struct.svc_rqst* %rqstp) #0 {
entry:
  %__ret = alloca i64, align 8
  %__ret66 = alloca i64, align 8
  %rq_server = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 7
  %0 = load %struct.svc_serv*, %struct.svc_serv** %rq_server, align 8, !tbaa !642
  %sv_max_mesg = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 6
  %1 = load i32, i32* %sv_max_mesg, align 4, !tbaa !724
  %conv = zext i32 %1 to i64
  %add = add i64 %conv, 4096
  %div = udiv i64 %add, 4096
  %conv1 = trunc i64 %div to i32
  %conv2 = sext i32 %conv1 to i64
  %cmp = icmp uge i64 %conv2, 259
  %lnot = xor i1 %cmp, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv9, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then, label %if.end37

if.then:                                          ; preds = %entry
  %2 = load i8, i8* @svc_alloc_arg.__warned, align 1, !tbaa !29, !range !31
  %tobool11 = trunc i8 %2 to i1
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %tobool18 = icmp ne i32 %lnot.ext17, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %if.then26, label %if.end

if.then26:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.15.1165, i32 0, i32 0), i32 583)
  br label %if.end

if.end:                                           ; preds = %if.then26, %if.then
  %tobool27 = icmp ne i32 %lnot.ext17, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.end
  store i8 1, i8* @svc_alloc_arg.__warned, align 1, !tbaa !29
  br label %if.end37

if.end37:                                         ; preds = %if.then35, %if.end, %entry
  %conv46 = sext i32 %conv1 to i64
  %cmp47 = icmp uge i64 %conv46, 259
  %.conv1 = select i1 %cmp47, i32 258, i32 %conv1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end37
  %i.0 = phi i32 [ 0, %if.end37 ], [ %inc, %for.inc ]
  %retval.0 = phi i32 [ undef, %if.end37 ], [ %retval.1, %for.inc ]
  %cmp51 = icmp slt i32 %i.0, %.conv1
  br i1 %cmp51, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %for.body
  %retval.1 = phi i32 [ %retval.0, %for.body ], [ %retval.2, %cleanup.cont ]
  %rq_pages = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages, i64 0, i64 %idxprom
  %3 = load %struct.page*, %struct.page** %arrayidx, align 8, !tbaa !28
  %cmp53 = icmp eq %struct.page* %3, null
  br i1 %cmp53, label %while.body, label %for.inc

while.body:                                       ; preds = %while.cond
  %call = call %struct.page* @alloc_pages.1229(i32 208, i32 0)
  %tobool55 = icmp ne %struct.page* %call, null
  br i1 %tobool55, label %if.end75, label %do.body

do.body:                                          ; preds = %while.body
  store volatile i64 1, i64* %__ret, align 8, !tbaa !88
  %4 = load volatile i64, i64* %__ret, align 8, !tbaa !88
  %5 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !1117
  %state = getelementptr inbounds %struct.task_struct, %struct.task_struct* %5, i32 0, i32 0
  %6 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %state, i64 %4, i64* %state) #7, !srcloc !1120
  store volatile i64 %6, i64* %__ret, align 8, !tbaa !88
  %7 = load volatile i64, i64* %__ret, align 8, !tbaa !88
  %8 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !1117
  %call60 = call i32 @signal_pending.1200(%struct.task_struct* %8)
  %tobool61 = icmp ne i32 %call60, 0
  br i1 %tobool61, label %do.body65, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body
  %call62 = call zeroext i1 @kthread_should_stop()
  br i1 %call62, label %do.body65, label %if.end72

do.body65:                                        ; preds = %lor.lhs.false, %do.body
  store volatile i64 0, i64* %__ret66, align 8, !tbaa !88
  %9 = load volatile i64, i64* %__ret66, align 8, !tbaa !88
  %10 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !1117
  %state68 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %10, i32 0, i32 0
  %11 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %state68, i64 %9, i64* %state68) #7, !srcloc !1121
  store volatile i64 %11, i64* %__ret66, align 8, !tbaa !88
  %12 = load volatile i64, i64* %__ret66, align 8, !tbaa !88
  br label %LeafBlock

if.end72:                                         ; preds = %lor.lhs.false
  %call73 = call i64 @msecs_to_jiffies(i32 500)
  %call74 = call i64 @schedule_timeout(i64 %call73)
  br label %if.end75

if.end75:                                         ; preds = %if.end72, %while.body
  %rq_pages76 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %idxprom77 = sext i32 %i.0 to i64
  %arrayidx78 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages76, i64 0, i64 %idxprom77
  store %struct.page* %call, %struct.page** %arrayidx78, align 8, !tbaa !28
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end75, %do.body65
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end75 ], [ 1, %do.body65 ]
  %retval.2 = phi i32 [ %retval.1, %if.end75 ], [ -4, %do.body65 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %cleanup.cont, label %cleanup99

cleanup.cont:                                     ; preds = %LeafBlock
  br label %while.cond

for.inc:                                          ; preds = %while.cond
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %rq_pages79 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %idxprom81 = sext i32 %i.0 to i64
  %arrayidx82 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages79, i64 0, i64 %idxprom81
  store %struct.page* null, %struct.page** %arrayidx82, align 8, !tbaa !28
  %rq_arg = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %rq_pages83 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %arrayidx84 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages83, i64 0, i64 0
  %13 = load %struct.page*, %struct.page** %arrayidx84, align 8, !tbaa !28
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %13 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %14 = inttoptr i64 %add.i to i8*
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 0
  %arrayidx86 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx86, i32 0, i32 0
  store i8* %14, i8** %iov_base, align 8, !tbaa !147
  %head87 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 0
  %arrayidx88 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head87, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx88, i32 0, i32 1
  store i64 4096, i64* %iov_len, align 8, !tbaa !149
  %rq_pages89 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %arraydecay = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages89, i32 0, i32 0
  %add.ptr = getelementptr inbounds %struct.page*, %struct.page** %arraydecay, i64 1
  %pages90 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 2
  store %struct.page** %add.ptr, %struct.page*** %pages90, align 8, !tbaa !354
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 3
  store i32 0, i32* %page_base, align 8, !tbaa !355
  %sub = sub nsw i32 %.conv1, 2
  %conv91 = sext i32 %sub to i64
  %mul = mul i64 %conv91, 4096
  %conv92 = trunc i64 %mul to i32
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 4
  store i32 %conv92, i32* %page_len, align 4, !tbaa !150
  %sub93 = sub nsw i32 %.conv1, 1
  %conv94 = sext i32 %sub93 to i64
  %mul95 = mul i64 %conv94, 4096
  %conv96 = trunc i64 %mul95 to i32
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 7
  store i32 %conv96, i32* %len, align 8, !tbaa !152
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 1
  %arrayidx97 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_len98 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx97, i32 0, i32 1
  store i64 0, i64* %iov_len98, align 8, !tbaa !149
  br label %cleanup99

cleanup99:                                        ; preds = %for.end, %LeafBlock
  %retval.3 = phi i32 [ 0, %for.end ], [ %retval.2, %LeafBlock ]
  ret i32 %retval.3
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @try_to_freeze.1198() #2 {
entry:
  call void @__might_sleep(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.28.1227, i32 0, i32 0), i32 51, i32 0)
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !1117
  %call3 = call zeroext i1 @freezing.1228(%struct.task_struct* %0)
  %lnot = xor i1 %call3, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call6 = call zeroext i1 @__refrigerator(i1 zeroext false)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @signal_pending.1200(%struct.task_struct* %p) #2 {
entry:
  %call = call i32 @test_tsk_thread_flag.1224(%struct.task_struct* %p, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

declare zeroext i1 @kthread_should_stop() #4

; Function Attrs: nounwind uwtable
define %struct.svc_xprt* @svc_get_next_xprt(%struct.svc_rqst* %rqstp, i64 %timeout) #0 {
entry:
  %wait = alloca %struct.__wait_queue, align 8
  %__ret = alloca i64, align 8
  %__ret14 = alloca i64, align 8
  %rq_pool = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 8
  %0 = load %struct.svc_pool*, %struct.svc_pool** %rq_pool, align 8, !tbaa !702
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !218
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 1
  %1 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !1117
  %2 = bitcast %struct.task_struct* %1 to i8*
  store i8* %2, i8** %private, align 8, !tbaa !220
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @default_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !221
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  store %struct.list_head* null, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  store %struct.list_head* null, %struct.list_head** %prev, align 8, !tbaa !163
  %rq_chandle = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 33
  %thread_wait = getelementptr inbounds %struct.cache_req, %struct.cache_req* %rq_chandle, i32 0, i32 1
  store i32 1250, i32* %thread_wait, align 8, !tbaa !1122
  %sp_lock = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i32 0, i32 1
  call void @spin_lock_bh.1153(%struct.spinlock* %sp_lock)
  %call1 = call %struct.svc_xprt* @svc_xprt_dequeue(%struct.svc_pool* %0)
  %tobool = icmp ne %struct.svc_xprt* %call1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %rq_xprt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  store %struct.svc_xprt* %call1, %struct.svc_xprt** %rq_xprt, align 8, !tbaa !635
  call void @svc_xprt_get(%struct.svc_xprt* %call1)
  %rq_chandle2 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 33
  %thread_wait3 = getelementptr inbounds %struct.cache_req, %struct.cache_req* %rq_chandle2, i32 0, i32 1
  store i32 250, i32* %thread_wait3, align 8, !tbaa !1122
  %sp_task_pending = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i32 0, i32 7
  store i32 0, i32* %sp_task_pending, align 8, !tbaa !1123
  br label %if.end54

if.else:                                          ; preds = %entry
  %sp_task_pending4 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i32 0, i32 7
  %3 = load i32, i32* %sp_task_pending4, align 8, !tbaa !1123
  %tobool5 = icmp ne i32 %3, 0
  br i1 %tobool5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.else
  %sp_task_pending7 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i32 0, i32 7
  store i32 0, i32* %sp_task_pending7, align 8, !tbaa !1123
  %sp_lock8 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i32 0, i32 1
  call void @spin_unlock_bh.1154(%struct.spinlock* %sp_lock8)
  %call9 = call i8* @ERR_PTR.1221(i64 -11)
  %4 = bitcast i8* %call9 to %struct.svc_xprt*
  br label %cleanup

if.end:                                           ; preds = %if.else
  call void @svc_thread_enqueue(%struct.svc_pool* %0, %struct.svc_rqst* %rqstp)
  store volatile i64 1, i64* %__ret, align 8, !tbaa !88
  %5 = load volatile i64, i64* %__ret, align 8, !tbaa !88
  %6 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !1117
  %state = getelementptr inbounds %struct.task_struct, %struct.task_struct* %6, i32 0, i32 0
  %7 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %state, i64 %5, i64* %state) #7, !srcloc !1124
  store volatile i64 %7, i64* %__ret, align 8, !tbaa !88
  %8 = load volatile i64, i64* %__ret, align 8, !tbaa !88
  %call11 = call zeroext i1 @kthread_should_stop()
  br i1 %call11, label %do.body13, label %if.end22

do.body13:                                        ; preds = %if.end
  store volatile i64 0, i64* %__ret14, align 8, !tbaa !88
  %9 = load volatile i64, i64* %__ret14, align 8, !tbaa !88
  %10 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !1117
  %state16 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %10, i32 0, i32 0
  %11 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %state16, i64 %9, i64* %state16) #7, !srcloc !1125
  store volatile i64 %11, i64* %__ret14, align 8, !tbaa !88
  %12 = load volatile i64, i64* %__ret14, align 8, !tbaa !88
  %sp_lock20 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i32 0, i32 1
  call void @spin_unlock_bh.1154(%struct.spinlock* %sp_lock20)
  %call21 = call i8* @ERR_PTR.1221(i64 -4)
  %13 = bitcast i8* %call21 to %struct.svc_xprt*
  br label %cleanup

if.end22:                                         ; preds = %if.end
  %rq_wait = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 40
  call void @add_wait_queue(%struct.__wait_queue_head* %rq_wait, %struct.__wait_queue* %wait)
  %sp_lock23 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i32 0, i32 1
  call void @spin_unlock_bh.1154(%struct.spinlock* %sp_lock23)
  %call24 = call i64 @schedule_timeout(i64 %timeout)
  call void @try_to_freeze.1198()
  %sp_lock26 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i32 0, i32 1
  call void @spin_lock_bh.1153(%struct.spinlock* %sp_lock26)
  %rq_wait27 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 40
  call void @remove_wait_queue(%struct.__wait_queue_head* %rq_wait27, %struct.__wait_queue* %wait)
  %tobool28 = icmp ne i64 %call24, 0
  br i1 %tobool28, label %if.end30, label %if.then29

if.then29:                                        ; preds = %if.end22
  %sp_stats = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i32 0, i32 6
  %threads_timedout = getelementptr inbounds %struct.sched_info, %struct.sched_info* %sp_stats, i32 0, i32 3
  %14 = load i64, i64* %threads_timedout, align 8, !tbaa !1088
  %inc = add i64 %14, 1
  store i64 %inc, i64* %threads_timedout, align 8, !tbaa !1088
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %if.end22
  %rq_xprt31 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %15 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt31, align 8, !tbaa !635
  %tobool32 = icmp ne %struct.svc_xprt* %15, null
  br i1 %tobool32, label %if.end54, label %if.then33

if.then33:                                        ; preds = %if.end30
  call void @svc_thread_dequeue(%struct.svc_rqst* %rqstp)
  %sp_lock34 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i32 0, i32 1
  call void @spin_unlock_bh.1154(%struct.spinlock* %sp_lock34)
  %16 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %16, 256
  %tobool36 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool36, true
  %lnot37 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot37 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool38 = icmp ne i64 %expval, 0
  br i1 %tobool38, label %if.then39, label %do.end43

if.then39:                                        ; preds = %if.then33
  %17 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end43

do.end43:                                         ; preds = %if.then39, %if.then33
  %18 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #3, !srcloc !1117
  %call45 = call i32 @signal_pending.1200(%struct.task_struct* %18)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %if.then49, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end43
  %call47 = call zeroext i1 @kthread_should_stop()
  br i1 %call47, label %if.then49, label %if.else51

if.then49:                                        ; preds = %lor.lhs.false, %do.end43
  %call50 = call i8* @ERR_PTR.1221(i64 -4)
  %19 = bitcast i8* %call50 to %struct.svc_xprt*
  br label %cleanup

if.else51:                                        ; preds = %lor.lhs.false
  %call52 = call i8* @ERR_PTR.1221(i64 -11)
  %20 = bitcast i8* %call52 to %struct.svc_xprt*
  br label %cleanup

if.end54:                                         ; preds = %if.end30, %if.then
  %xprt.0 = phi %struct.svc_xprt* [ %call1, %if.then ], [ %15, %if.end30 ]
  %sp_lock55 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %0, i32 0, i32 1
  call void @spin_unlock_bh.1154(%struct.spinlock* %sp_lock55)
  br label %cleanup

cleanup:                                          ; preds = %if.end54, %if.else51, %if.then49, %do.body13, %if.then6
  %retval.0 = phi %struct.svc_xprt* [ %xprt.0, %if.end54 ], [ %4, %if.then6 ], [ %13, %do.body13 ], [ %19, %if.then49 ], [ %20, %if.else51 ]
  ret %struct.svc_xprt* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR.1201(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR.1202(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_handle_xprt(%struct.svc_rqst* %rqstp, %struct.svc_xprt* %xprt) #0 {
entry:
  %rq_server = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 7
  %0 = load %struct.svc_serv*, %struct.svc_serv** %rq_server, align 8, !tbaa !642
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  %1 = load volatile i64, i64* %xpt_flags, align 8, !tbaa !88
  %and.i1 = and i64 4, %1
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool = icmp ne i32 %conv.i3, 0
  br i1 %tobool, label %do.body, label %cond.true10

do.body:                                          ; preds = %entry
  %2 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %2, 256
  %tobool4 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool4, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then7, label %do.end

if.then7:                                         ; preds = %do.body
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then7, %do.body
  call void @svc_delete_xprt(%struct.svc_xprt* %xprt)
  br label %cleanup

cond.true10:                                      ; preds = %entry
  %xpt_flags11 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  %4 = load volatile i64, i64* %xpt_flags11, align 8, !tbaa !88
  %and.i = and i64 2048, %4
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool13 = icmp ne i32 %conv.i, 0
  br i1 %tobool13, label %if.then18, label %if.else

if.then18:                                        ; preds = %cond.true10
  %xpt_class = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 0
  %5 = load %struct.svc_xprt_class*, %struct.svc_xprt_class** %xpt_class, align 8, !tbaa !639
  %xcl_owner = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %5, i32 0, i32 1
  %6 = load %struct.module*, %struct.module** %xcl_owner, align 8, !tbaa !1101
  call void @__module_get(%struct.module* %6)
  %xpt_server = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 6
  %7 = load %struct.svc_serv*, %struct.svc_serv** %xpt_server, align 8, !tbaa !782
  call void @svc_check_conn_limits(%struct.svc_serv* %7)
  %xpt_ops = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 1
  %8 = load %struct.svc_xprt_ops*, %struct.svc_xprt_ops** %xpt_ops, align 8, !tbaa !653
  %xpo_accept = getelementptr inbounds %struct.svc_xprt_ops, %struct.svc_xprt_ops* %8, i32 0, i32 1
  %9 = load %struct.svc_xprt* (%struct.svc_xprt*)*, %struct.svc_xprt* (%struct.svc_xprt*)** %xpo_accept, align 8, !tbaa !1126
  %call19 = call %struct.svc_xprt* %9(%struct.svc_xprt* %xprt)
  %tobool20 = icmp ne %struct.svc_xprt* %call19, null
  br i1 %tobool20, label %if.then21, label %if.end69

if.then21:                                        ; preds = %if.then18
  call void @svc_add_new_temp_xprt(%struct.svc_serv* %0, %struct.svc_xprt* %call19)
  br label %if.end69

if.else:                                          ; preds = %cond.true10
  %xpt_ops23 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 1
  %10 = load %struct.svc_xprt_ops*, %struct.svc_xprt_ops** %xpt_ops23, align 8, !tbaa !653
  %xpo_has_wspace = getelementptr inbounds %struct.svc_xprt_ops, %struct.svc_xprt_ops* %10, i32 0, i32 2
  %11 = load i32 (%struct.svc_xprt*)*, i32 (%struct.svc_xprt*)** %xpo_has_wspace, align 8, !tbaa !1115
  %call24 = call i32 %11(%struct.svc_xprt* %xprt)
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %do.body27, label %if.end69

do.body27:                                        ; preds = %if.else
  %12 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and28 = and i32 %12, 256
  %tobool29 = icmp ne i32 %and28, 0
  %lnot30 = xor i1 %tobool29, true
  %lnot32 = xor i1 %lnot30, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %expval35 = call i64 @llvm.expect.i64(i64 %conv34, i64 0)
  %tobool36 = icmp ne i64 %expval35, 0
  br i1 %tobool36, label %if.then37, label %do.end42

if.then37:                                        ; preds = %do.body27
  %xpt_ref = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 2
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %xpt_ref, i32 0, i32 0
  %call38 = call i32 @atomic_read.1211(%struct.atomic_t* %refcount)
  %13 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end42

do.end42:                                         ; preds = %if.then37, %do.body27
  %call43 = call %struct.svc_deferred_req* @svc_deferred_dequeue(%struct.svc_xprt* %xprt)
  %rq_deferred = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 13
  store %struct.svc_deferred_req* %call43, %struct.svc_deferred_req** %rq_deferred, align 8, !tbaa !1106
  %rq_deferred44 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 13
  %14 = load %struct.svc_deferred_req*, %struct.svc_deferred_req** %rq_deferred44, align 8, !tbaa !1106
  %tobool45 = icmp ne %struct.svc_deferred_req* %14, null
  br i1 %tobool45, label %if.then46, label %if.else48

if.then46:                                        ; preds = %do.end42
  %call47 = call i32 @svc_deferred_recv(%struct.svc_rqst* %rqstp)
  br label %do.body52

if.else48:                                        ; preds = %do.end42
  %xpt_ops49 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 1
  %15 = load %struct.svc_xprt_ops*, %struct.svc_xprt_ops** %xpt_ops49, align 8, !tbaa !653
  %xpo_recvfrom = getelementptr inbounds %struct.svc_xprt_ops, %struct.svc_xprt_ops* %15, i32 0, i32 3
  %16 = load i32 (%struct.svc_rqst*)*, i32 (%struct.svc_rqst*)** %xpo_recvfrom, align 8, !tbaa !1127
  %call50 = call i32 %16(%struct.svc_rqst* %rqstp)
  br label %do.body52

do.body52:                                        ; preds = %if.else48, %if.then46
  %len.0 = phi i32 [ %call47, %if.then46 ], [ %call50, %if.else48 ]
  %17 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and53 = and i32 %17, 256
  %tobool54 = icmp ne i32 %and53, 0
  %lnot55 = xor i1 %tobool54, true
  %lnot57 = xor i1 %lnot55, true
  %lnot.ext58 = zext i1 %lnot57 to i32
  %conv59 = sext i32 %lnot.ext58 to i64
  %expval60 = call i64 @llvm.expect.i64(i64 %conv59, i64 0)
  %tobool61 = icmp ne i64 %expval60, 0
  br i1 %tobool61, label %if.then62, label %do.end66

if.then62:                                        ; preds = %do.body52
  %18 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end66

do.end66:                                         ; preds = %if.then62, %do.body52
  %sv_max_mesg = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 6
  %19 = load i32, i32* %sv_max_mesg, align 4, !tbaa !724
  %rq_reserved = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 32
  store i32 %19, i32* %rq_reserved, align 8, !tbaa !1107
  %rq_reserved67 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 32
  %20 = load i32, i32* %rq_reserved67, align 8, !tbaa !1107
  %xpt_reserved = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 7
  call void @atomic_add(i32 %20, %struct.atomic_t* %xpt_reserved)
  br label %if.end69

if.end69:                                         ; preds = %do.end66, %if.else, %if.then21, %if.then18
  %len.2 = phi i32 [ 0, %if.then21 ], [ 0, %if.then18 ], [ %len.0, %do.end66 ], [ 0, %if.else ]
  call void @svc_xprt_received(%struct.svc_xprt* %xprt)
  br label %cleanup

cleanup:                                          ; preds = %if.end69, %do.end
  %retval.0 = phi i32 [ 0, %do.end ], [ %len.2, %if.end69 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr* @svc_addr.1203(%struct.svc_rqst* %rqst) #2 {
entry:
  %rq_addr = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqst, i32 0, i32 3
  %0 = bitcast %struct.__kernel_sockaddr_storage* %rq_addr to %struct.sockaddr*
  ret %struct.sockaddr* %0
}

; Function Attrs: nounwind uwtable
define i32 @svc_port_is_privileged(%struct.sockaddr* %sin) #0 {
entry:
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sin, i32 0, i32 0
  %0 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %0 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb3, label %return

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %return

sw.bb:                                            ; preds = %LeafBlock
  %1 = bitcast %struct.sockaddr* %sin to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %1, i32 0, i32 1
  %2 = load i16, i16* %sin_port, align 2, !tbaa !191
  %call = call zeroext i16 @__fswab16.1156(i16 zeroext %2) #3
  %conv1 = zext i16 %call to i32
  %cmp = icmp slt i32 %conv1, 1024
  %conv2 = zext i1 %cmp to i32
  br label %return

sw.bb3:                                           ; preds = %LeafBlock1
  %3 = bitcast %struct.sockaddr* %sin to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %3, i32 0, i32 1
  %4 = load i16, i16* %sin6_port, align 2, !tbaa !194
  %call4 = call zeroext i16 @__fswab16.1156(i16 zeroext %4) #3
  %conv5 = zext i16 %call4 to i32
  %cmp6 = icmp slt i32 %conv5, 1024
  %conv7 = zext i1 %cmp6 to i32
  br label %return

return:                                           ; preds = %sw.bb3, %sw.bb, %LeafBlock, %LeafBlock1
  %retval.0 = phi i32 [ %conv2, %sw.bb ], [ %conv7, %sw.bb3 ], [ 0, %LeafBlock ], [ 0, %LeafBlock1 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.cache_deferred_req* @svc_defer(%struct.cache_req* %req) #0 {
entry:
  %0 = bitcast %struct.cache_req* %req to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -6832
  %1 = bitcast i8* %add.ptr to %struct.svc_rqst*
  %rq_arg = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 16
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 4
  %2 = load i32, i32* %page_len, align 4, !tbaa !761
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %cleanup32, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %rq_usedeferral = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 14
  %3 = load i32, i32* %rq_usedeferral, align 8, !tbaa !651
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.end, label %cleanup32

if.end:                                           ; preds = %lor.lhs.false
  %rq_deferred = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 13
  %4 = load %struct.svc_deferred_req*, %struct.svc_deferred_req** %rq_deferred, align 8, !tbaa !1106
  %tobool2 = icmp ne %struct.svc_deferred_req* %4, null
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %rq_deferred4 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 13
  %5 = load %struct.svc_deferred_req*, %struct.svc_deferred_req** %rq_deferred4, align 8, !tbaa !1106
  %rq_deferred5 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 13
  store %struct.svc_deferred_req* null, %struct.svc_deferred_req** %rq_deferred5, align 8, !tbaa !1106
  br label %if.end28

if.else:                                          ; preds = %if.end
  %rq_arg6 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 16
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg6, i32 0, i32 7
  %6 = load i32, i32* %len, align 8, !tbaa !759
  %conv = zext i32 %6 to i64
  %add = add i64 360, %conv
  %call.i = call i8* @__kmalloc(i64 %add, i32 208) #7
  %7 = bitcast i8* %call.i to %struct.svc_deferred_req*
  %cmp = icmp eq %struct.svc_deferred_req* %7, null
  br i1 %cmp, label %LeafBlock, label %if.end9

if.end9:                                          ; preds = %if.else
  %rq_server = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 7
  %8 = load %struct.svc_serv*, %struct.svc_serv** %rq_server, align 8, !tbaa !642
  %9 = bitcast %struct.svc_serv* %8 to i8*
  %handle = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %7, i32 0, i32 6
  %owner = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %handle, i32 0, i32 3
  store i8* %9, i8** %owner, align 8, !tbaa !1128
  %rq_prot = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 27
  %10 = load i32, i32* %rq_prot, align 8, !tbaa !647
  %prot = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %7, i32 0, i32 0
  store i32 %10, i32* %prot, align 8, !tbaa !1130
  %rq_addrlen = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 4
  %11 = load i64, i64* %rq_addrlen, align 8, !tbaa !648
  %addr = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %7, i32 0, i32 2
  %12 = bitcast %struct.__kernel_sockaddr_storage* %addr to i8*
  %rq_addr = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 3
  %13 = bitcast %struct.__kernel_sockaddr_storage* %rq_addr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 %11, i32 8, i1 false)
  %rq_addrlen11 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 4
  %14 = load i64, i64* %rq_addrlen11, align 8, !tbaa !648
  %addrlen = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %7, i32 0, i32 3
  store i64 %14, i64* %addrlen, align 8, !tbaa !1131
  %daddr = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %7, i32 0, i32 4
  %rq_daddr = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 5
  %15 = bitcast %struct.__kernel_sockaddr_storage* %daddr to i8*
  %16 = bitcast %struct.__kernel_sockaddr_storage* %rq_daddr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 128, i32 8, i1 false), !tbaa.struct !1132
  %rq_arg12 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 16
  %len13 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg12, i32 0, i32 7
  %17 = load i32, i32* %len13, align 8, !tbaa !759
  %shr = lshr i32 %17, 2
  %argslen = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %7, i32 0, i32 8
  store i32 %shr, i32* %argslen, align 8, !tbaa !1133
  %rq_xprt_hlen = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 15
  %18 = load i64, i64* %rq_xprt_hlen, align 8, !tbaa !778
  %xprt_hlen = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %7, i32 0, i32 7
  store i64 %18, i64* %xprt_hlen, align 8, !tbaa !1134
  %rq_arg14 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 16
  %len15 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg14, i32 0, i32 7
  %19 = load i32, i32* %len15, align 8, !tbaa !759
  %conv16 = zext i32 %19 to i64
  %rq_arg17 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 16
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg17, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %20 = load i64, i64* %iov_len, align 8, !tbaa !149
  %sub = sub i64 %conv16, %20
  %argslen19 = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %7, i32 0, i32 8
  %21 = load i32, i32* %argslen19, align 8, !tbaa !1133
  %shl = shl i32 %21, 2
  %conv20 = sext i32 %shl to i64
  %args = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %7, i32 0, i32 9
  %arraydecay = getelementptr inbounds [0 x i32], [0 x i32]* %args, i32 0, i32 0
  %22 = bitcast i32* %arraydecay to i8*
  %rq_arg22 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 16
  %head23 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg22, i32 0, i32 0
  %arrayidx24 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head23, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx24, i32 0, i32 0
  %23 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %idx.neg = sub i64 0, %sub
  %add.ptr25 = getelementptr i8, i8* %23, i64 %idx.neg
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %22, i8* %add.ptr25, i64 %conv20, i32 1, i1 false)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end9, %if.else
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end9 ], [ 1, %if.else ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end28, label %cleanup32

if.end28:                                         ; preds = %LeafBlock, %if.then3
  %dr.0 = phi %struct.svc_deferred_req* [ %5, %if.then3 ], [ %7, %LeafBlock ]
  %rq_xprt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 2
  %24 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt, align 8, !tbaa !635
  call void @svc_xprt_get(%struct.svc_xprt* %24)
  %rq_xprt29 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 2
  %25 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt29, align 8, !tbaa !635
  %xprt = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %dr.0, i32 0, i32 1
  store %struct.svc_xprt* %25, %struct.svc_xprt** %xprt, align 8, !tbaa !1135
  %rq_dropme = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %1, i32 0, i32 34
  store i8 1, i8* %rq_dropme, align 8, !tbaa !652
  %handle30 = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %dr.0, i32 0, i32 6
  %revisit = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %handle30, i32 0, i32 4
  store void (%struct.cache_deferred_req*, i32)* @svc_revisit, void (%struct.cache_deferred_req*, i32)** %revisit, align 8, !tbaa !1136
  %handle31 = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %dr.0, i32 0, i32 6
  br label %cleanup32

cleanup32:                                        ; preds = %if.end28, %LeafBlock, %lor.lhs.false, %entry
  %retval.1 = phi %struct.cache_deferred_req* [ %handle31, %if.end28 ], [ null, %lor.lhs.false ], [ null, %entry ], [ null, %LeafBlock ]
  ret %struct.cache_deferred_req* %retval.1
}

; Function Attrs: nounwind uwtable
define internal void @svc_revisit(%struct.cache_deferred_req* %dreq, i32 %too_many) #0 {
entry:
  %0 = bitcast %struct.cache_deferred_req* %dreq to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -288
  %1 = bitcast i8* %add.ptr to %struct.svc_deferred_req*
  %xprt1 = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %1, i32 0, i32 1
  %2 = load %struct.svc_xprt*, %struct.svc_xprt** %xprt1, align 8, !tbaa !1135
  %xpt_lock = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 9
  call void @spin_lock.1175(%struct.spinlock* %xpt_lock)
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 8, i64* %xpt_flags) #7, !srcloc !1092
  %tobool = icmp ne i32 %too_many, 0
  br i1 %tobool, label %if.then, label %cond.true

cond.true:                                        ; preds = %entry
  %xpt_flags2 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 5
  %3 = load volatile i64, i64* %xpt_flags2, align 8, !tbaa !88
  %and.i = and i64 64, %3
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool3 = icmp ne i32 %conv.i, 0
  br i1 %tobool3, label %if.then, label %do.body14

if.then:                                          ; preds = %cond.true, %entry
  %xpt_lock7 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 9
  call void @spin_unlock.1176(%struct.spinlock* %xpt_lock7)
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %4, 256
  %tobool8 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool8, true
  %lnot9 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then11, label %do.end

if.then11:                                        ; preds = %if.then
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then11, %if.then
  call void @svc_xprt_put(%struct.svc_xprt* %2)
  %6 = bitcast %struct.svc_deferred_req* %1 to i8*
  call void @kfree(i8* %6)
  br label %cleanup.cont

do.body14:                                        ; preds = %cond.true
  %7 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and15 = and i32 %7, 256
  %tobool16 = icmp ne i32 %and15, 0
  %lnot17 = xor i1 %tobool16, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool23 = icmp ne i64 %expval22, 0
  br i1 %tobool23, label %if.then24, label %do.end28

if.then24:                                        ; preds = %do.body14
  %8 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end28

do.end28:                                         ; preds = %if.then24, %do.body14
  %xprt29 = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %1, i32 0, i32 1
  store %struct.svc_xprt* null, %struct.svc_xprt** %xprt29, align 8, !tbaa !1135
  %handle = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %1, i32 0, i32 6
  %recent = getelementptr inbounds %struct.cache_deferred_req, %struct.cache_deferred_req* %handle, i32 0, i32 1
  %xpt_deferred = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 11
  call void @list_add.1209(%struct.list_head* %recent, %struct.list_head* %xpt_deferred)
  %xpt_lock30 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 9
  call void @spin_unlock.1176(%struct.spinlock* %xpt_lock30)
  call void @svc_xprt_enqueue(%struct.svc_xprt* %2)
  call void @svc_xprt_put(%struct.svc_xprt* %2)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %do.end28, %do.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add.1209(%struct.list_head* %new, %struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_check_conn_limits(%struct.svc_serv* %serv) #0 {
entry:
  %sv_maxconn = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 4
  %0 = load i32, i32* %sv_maxconn, align 4, !tbaa !1137
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %sv_maxconn1 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 4
  %1 = load i32, i32* %sv_maxconn1, align 4, !tbaa !1137
  br label %cond.end

cond.false:                                       ; preds = %entry
  %sv_nrthreads = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 3
  %2 = load i32, i32* %sv_nrthreads, align 8, !tbaa !707
  %add = add i32 %2, 3
  %mul = mul i32 %add, 20
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %1, %cond.true ], [ %mul, %cond.false ]
  %sv_tmpcnt = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 10
  %3 = load i32, i32* %sv_tmpcnt, align 8, !tbaa !1096
  %cmp = icmp ugt i32 %3, %cond
  br i1 %cmp, label %if.then, label %if.end17

if.then:                                          ; preds = %cond.end
  %sv_lock = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 2
  call void @spin_lock_bh.1153(%struct.spinlock* %sv_lock)
  %sv_tempsocks = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 9
  %call = call i32 @list_empty.1168(%struct.list_head* %sv_tempsocks)
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %if.end12, label %do.body

do.body:                                          ; preds = %if.then
  %call4 = call i32 @net_ratelimit()
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %do.end

if.then6:                                         ; preds = %do.body
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then6, %do.body
  %sv_tempsocks11 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 9
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %sv_tempsocks11, i32 0, i32 1
  %5 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !1138
  %6 = bitcast %struct.list_head* %5 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 -24
  %7 = bitcast i8* %add.ptr to %struct.svc_xprt*
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %7, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 2, i64* %xpt_flags) #7, !srcloc !1092
  call void @svc_xprt_get(%struct.svc_xprt* %7)
  br label %if.end12

if.end12:                                         ; preds = %do.end, %if.then
  %xprt.0 = phi %struct.svc_xprt* [ null, %if.then ], [ %7, %do.end ]
  %sv_lock13 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 2
  call void @spin_unlock_bh.1154(%struct.spinlock* %sv_lock13)
  %tobool14 = icmp ne %struct.svc_xprt* %xprt.0, null
  br i1 %tobool14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end12
  call void @svc_xprt_enqueue(%struct.svc_xprt* %xprt.0)
  call void @svc_xprt_put(%struct.svc_xprt* %xprt.0)
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.end12, %cond.end
  ret void
}

; Function Attrs: nounwind uwtable
define void @svc_add_new_temp_xprt(%struct.svc_serv* %serv, %struct.svc_xprt* %newxpt) #0 {
entry:
  %sv_lock = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 2
  call void @spin_lock_bh.1153(%struct.spinlock* %sv_lock)
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %newxpt, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 4, i64* %xpt_flags) #7, !srcloc !1092
  %xpt_list = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %newxpt, i32 0, i32 3
  %sv_tempsocks = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 9
  call void @list_add.1209(%struct.list_head* %xpt_list, %struct.list_head* %sv_tempsocks)
  %sv_tmpcnt = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 10
  %0 = load i32, i32* %sv_tmpcnt, align 8, !tbaa !1096
  %inc = add nsw i32 %0, 1
  store i32 %inc, i32* %sv_tmpcnt, align 8, !tbaa !1096
  %sv_temptimer = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 11
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %sv_temptimer, i32 0, i32 3
  %1 = load void (i64)*, void (i64)** %function, align 8, !tbaa !1139
  %cmp = icmp eq void (i64)* %1, null
  br i1 %cmp, label %do.body1, label %if.end

do.body1:                                         ; preds = %entry
  %sv_temptimer2 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 11
  call void @init_timer_key(%struct.timer_list* %sv_temptimer2, i32 0, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.17.1214, i32 0, i32 0), %struct.lock_class_key* @svc_add_new_temp_xprt.__key)
  %sv_temptimer3 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 11
  %function4 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %sv_temptimer3, i32 0, i32 3
  store void (i64)* @svc_age_temp_xprts, void (i64)** %function4, align 8, !tbaa !342
  %2 = ptrtoint %struct.svc_serv* %serv to i64
  %sv_temptimer5 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 11
  %data = getelementptr inbounds %struct.timer_list, %struct.timer_list* %sv_temptimer5, i32 0, i32 4
  store i64 %2, i64* %data, align 8, !tbaa !343
  %sv_temptimer7 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 11
  %3 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %4 = load i32, i32* @svc_conn_age_period, align 4, !tbaa !49
  %mul = mul nsw i32 %4, 250
  %conv = sext i32 %mul to i64
  %add = add i64 %3, %conv
  %call = call i32 @mod_timer(%struct.timer_list* %sv_temptimer7, i64 %add)
  br label %if.end

if.end:                                           ; preds = %do.body1, %entry
  %sv_lock8 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 2
  call void @spin_unlock_bh.1154(%struct.spinlock* %sv_lock8)
  call void @svc_xprt_received(%struct.svc_xprt* %newxpt)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read.1211(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !49
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_deferred_recv(%struct.svc_rqst* %rqstp) #0 {
entry:
  %rq_deferred = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 13
  %0 = load %struct.svc_deferred_req*, %struct.svc_deferred_req** %rq_deferred, align 8, !tbaa !1106
  %args = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %0, i32 0, i32 9
  %arraydecay = getelementptr inbounds [0 x i32], [0 x i32]* %args, i32 0, i32 0
  %xprt_hlen = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %0, i32 0, i32 7
  %1 = load i64, i64* %xprt_hlen, align 8, !tbaa !1134
  %shr = lshr i64 %1, 2
  %add.ptr = getelementptr inbounds i32, i32* %arraydecay, i64 %shr
  %2 = bitcast i32* %add.ptr to i8*
  %rq_arg = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  store i8* %2, i8** %iov_base, align 8, !tbaa !147
  %argslen = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %0, i32 0, i32 8
  %3 = load i32, i32* %argslen, align 8, !tbaa !1133
  %shl = shl i32 %3, 2
  %conv = sext i32 %shl to i64
  %xprt_hlen1 = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %0, i32 0, i32 7
  %4 = load i64, i64* %xprt_hlen1, align 8, !tbaa !1134
  %sub = sub i64 %conv, %4
  %rq_arg2 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %head3 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg2, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head3, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx4, i32 0, i32 1
  store i64 %sub, i64* %iov_len, align 8, !tbaa !149
  %rq_arg5 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg5, i32 0, i32 4
  store i32 0, i32* %page_len, align 4, !tbaa !761
  %argslen6 = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %0, i32 0, i32 8
  %5 = load i32, i32* %argslen6, align 8, !tbaa !1133
  %shl7 = shl i32 %5, 2
  %rq_arg8 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 16
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_arg8, i32 0, i32 7
  store i32 %shl7, i32* %len, align 8, !tbaa !759
  %prot = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %0, i32 0, i32 0
  %6 = load i32, i32* %prot, align 8, !tbaa !1130
  %rq_prot = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 27
  store i32 %6, i32* %rq_prot, align 8, !tbaa !647
  %addrlen = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %0, i32 0, i32 3
  %7 = load i64, i64* %addrlen, align 8, !tbaa !1131
  %rq_addr = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 3
  %8 = bitcast %struct.__kernel_sockaddr_storage* %rq_addr to i8*
  %addr = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %0, i32 0, i32 2
  %9 = bitcast %struct.__kernel_sockaddr_storage* %addr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %9, i64 %7, i32 8, i1 false)
  %addrlen9 = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %0, i32 0, i32 3
  %10 = load i64, i64* %addrlen9, align 8, !tbaa !1131
  %rq_addrlen = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 4
  store i64 %10, i64* %rq_addrlen, align 8, !tbaa !648
  %xprt_hlen10 = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %0, i32 0, i32 7
  %11 = load i64, i64* %xprt_hlen10, align 8, !tbaa !1134
  %rq_xprt_hlen = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 15
  store i64 %11, i64* %rq_xprt_hlen, align 8, !tbaa !778
  %rq_daddr = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 5
  %daddr = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %0, i32 0, i32 4
  %12 = bitcast %struct.__kernel_sockaddr_storage* %rq_daddr to i8*
  %13 = bitcast %struct.__kernel_sockaddr_storage* %daddr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 128, i32 8, i1 false), !tbaa.struct !1132
  %rq_pages = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 18
  %arraydecay11 = getelementptr inbounds [259 x %struct.page*], [259 x %struct.page*]* %rq_pages, i32 0, i32 0
  %rq_respages = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 19
  store %struct.page** %arraydecay11, %struct.page*** %rq_respages, align 8, !tbaa !695
  %argslen12 = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %0, i32 0, i32 8
  %14 = load i32, i32* %argslen12, align 8, !tbaa !1133
  %shl13 = shl i32 %14, 2
  %conv14 = sext i32 %shl13 to i64
  %xprt_hlen15 = getelementptr inbounds %struct.svc_deferred_req, %struct.svc_deferred_req* %0, i32 0, i32 7
  %15 = load i64, i64* %xprt_hlen15, align 8, !tbaa !1134
  %sub16 = sub i64 %conv14, %15
  %conv17 = trunc i64 %sub16 to i32
  ret i32 %conv17
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_add(i32 %i, %struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; addl $1,$0", "=*m,ir,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #7, !srcloc !1140
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_xprt_received(%struct.svc_xprt* %xprt) #0 {
entry:
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  %0 = load volatile i64, i64* %xpt_flags, align 8, !tbaa !88
  %and.i1 = and i64 1, %0
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool = icmp ne i32 %conv.i3, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end35

if.then:                                          ; preds = %entry
  %1 = load i8, i8* @svc_xprt_received.__warned, align 1, !tbaa !29, !range !31
  %tobool9 = trunc i8 %1 to i1
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %tobool16 = icmp ne i32 %lnot.ext15, 0
  %lnot17 = xor i1 %tobool16, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool23 = icmp ne i64 %expval22, 0
  br i1 %tobool23, label %if.then24, label %if.end

if.then24:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.15.1165, i32 0, i32 0), i32 221)
  br label %if.end

if.end:                                           ; preds = %if.then24, %if.then
  %tobool25 = icmp ne i32 %lnot.ext15, 0
  %lnot26 = xor i1 %tobool25, true
  %lnot28 = xor i1 %lnot26, true
  %lnot.ext29 = zext i1 %lnot28 to i32
  %conv30 = sext i32 %lnot.ext29 to i64
  %expval31 = call i64 @llvm.expect.i64(i64 %conv30, i64 0)
  %tobool32 = icmp ne i64 %expval31, 0
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %if.end
  store i8 1, i8* @svc_xprt_received.__warned, align 1, !tbaa !29
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %if.end, %entry
  %xpt_flags44 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  %2 = load volatile i64, i64* %xpt_flags44, align 8, !tbaa !88
  %and.i = and i64 1, %2
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool46 = icmp ne i32 %conv.i, 0
  br i1 %tobool46, label %if.end51, label %return

if.end51:                                         ; preds = %if.end35
  call void @svc_xprt_get(%struct.svc_xprt* %xprt)
  %xpt_flags52 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags52, i32 0, i64* %xpt_flags52) #7, !srcloc !1098
  call void @svc_xprt_enqueue(%struct.svc_xprt* %xprt)
  call void @svc_xprt_put(%struct.svc_xprt* %xprt)
  br label %return

return:                                           ; preds = %if.end51, %if.end35
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @svc_age_temp_xprts(i64 %closure) #0 {
entry:
  %0 = inttoptr i64 %closure to %struct.svc_serv*
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %sv_lock = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 2
  %call3 = call i32 @spin_trylock_bh(%struct.spinlock* %sv_lock)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end22, label %do.body6

do.body6:                                         ; preds = %do.end
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and7 = and i32 %3, 256
  %tobool8 = icmp ne i32 %and7, 0
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  br i1 %tobool15, label %if.then16, label %do.end20

if.then16:                                        ; preds = %do.body6
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end20

do.end20:                                         ; preds = %if.then16, %do.body6
  %sv_temptimer = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 11
  %5 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %add = add i64 %5, 250
  %call21 = call i32 @mod_timer(%struct.timer_list* %sv_temptimer, i64 %add)
  br label %cleanup.cont

if.end22:                                         ; preds = %do.end
  %sv_tempsocks = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 9
  %next23 = getelementptr inbounds %struct.list_head, %struct.list_head* %sv_tempsocks, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next23, align 8, !tbaa !164
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end22
  %.sink = phi %struct.list_head* [ %7, %for.inc ], [ %6, %if.end22 ]
  %le.0 = phi %struct.list_head* [ %6, %if.end22 ], [ %7, %for.inc ]
  %next59 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink, i32 0, i32 0
  %7 = load %struct.list_head*, %struct.list_head** %next59, align 8, !tbaa !164
  %sv_tempsocks25 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 9
  %cmp = icmp ne %struct.list_head* %le.0, %sv_tempsocks25
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = bitcast %struct.list_head* %le.0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 -24
  %9 = bitcast i8* %add.ptr to %struct.svc_xprt*
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %9, i32 0, i32 5
  %call27 = call i32 @test_and_set_bit.1164(i32 9, i64* %xpt_flags)
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %if.end30, label %for.inc

if.end30:                                         ; preds = %for.body
  %xpt_ref = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %9, i32 0, i32 2
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %xpt_ref, i32 0, i32 0
  %call31 = call i32 @atomic_read.1211(%struct.atomic_t* %refcount)
  %cmp32 = icmp sgt i32 %call31, 1
  br i1 %cmp32, label %for.inc, label %cond.true

cond.true:                                        ; preds = %if.end30
  %xpt_flags34 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %9, i32 0, i32 5
  %10 = load volatile i64, i64* %xpt_flags34, align 8, !tbaa !88
  %and.i = and i64 1, %10
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool36 = icmp ne i32 %conv.i, 0
  br i1 %tobool36, label %for.inc, label %if.end41

if.end41:                                         ; preds = %cond.true
  call void @list_del_init.1167(%struct.list_head* %le.0)
  %xpt_flags42 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %9, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags42, i32 2, i64* %xpt_flags42) #7, !srcloc !1092
  %xpt_flags43 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %9, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags43, i32 10, i64* %xpt_flags43) #7, !srcloc !1092
  %11 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and45 = and i32 %11, 256
  %tobool46 = icmp ne i32 %and45, 0
  %lnot47 = xor i1 %tobool46, true
  %lnot49 = xor i1 %lnot47, true
  %lnot.ext50 = zext i1 %lnot49 to i32
  %conv51 = sext i32 %lnot.ext50 to i64
  %expval52 = call i64 @llvm.expect.i64(i64 %conv51, i64 0)
  %tobool53 = icmp ne i64 %expval52, 0
  br i1 %tobool53, label %if.then54, label %do.end58

if.then54:                                        ; preds = %if.end41
  %12 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end58

do.end58:                                         ; preds = %if.then54, %if.end41
  call void @svc_xprt_enqueue(%struct.svc_xprt* %9)
  br label %for.inc

for.inc:                                          ; preds = %do.end58, %cond.true, %if.end30, %for.body
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %sv_lock60 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 2
  call void @spin_unlock_bh.1154(%struct.spinlock* %sv_lock60)
  %sv_temptimer61 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %0, i32 0, i32 11
  %13 = load volatile i64, i64* @jiffies, align 8, !tbaa !88
  %14 = load i32, i32* @svc_conn_age_period, align 4, !tbaa !49
  %mul = mul nsw i32 %14, 250
  %conv62 = sext i32 %mul to i64
  %add63 = add i64 %13, %conv62
  %call64 = call i32 @mod_timer(%struct.timer_list* %sv_temptimer61, i64 %add63)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %do.end20
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @spin_trylock_bh(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  %call = call i32 @_raw_spin_trylock_bh(%struct.raw_spinlock* %rlock)
  ret i32 %call
}

declare i32 @_raw_spin_trylock_bh(%struct.raw_spinlock*) #4 section ".spinlock.text"

declare i32 @default_wake_function(%struct.__wait_queue*, i32, i32, i8*) #4

; Function Attrs: nounwind uwtable
define internal %struct.svc_xprt* @svc_xprt_dequeue(%struct.svc_pool* %pool) #0 {
entry:
  %sp_sockets = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %pool, i32 0, i32 3
  %call = call i32 @list_empty.1168(%struct.list_head* %sp_sockets)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %sp_sockets1 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %pool, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %sp_sockets1, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 32, !tbaa !1141
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -40
  %2 = bitcast i8* %add.ptr to %struct.svc_xprt*
  %xpt_ready = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 4
  call void @list_del_init.1167(%struct.list_head* %xpt_ready)
  %3 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %3, 256
  %tobool2 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then5, label %cleanup

if.then5:                                         ; preds = %if.end
  %xpt_ref = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 2
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %xpt_ref, i32 0, i32 0
  %call6 = call i32 @atomic_read.1211(%struct.atomic_t* %refcount)
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then5, %if.end, %entry
  %retval.0 = phi %struct.svc_xprt* [ null, %entry ], [ %2, %if.then5 ], [ %2, %if.end ]
  ret %struct.svc_xprt* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR.1221(i64 %error) #2 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal void @svc_thread_enqueue(%struct.svc_pool* %pool, %struct.svc_rqst* %rqstp) #0 {
entry:
  %rq_list = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 0
  %sp_threads = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %pool, i32 0, i32 2
  call void @list_add.1209(%struct.list_head* %rq_list, %struct.list_head* %sp_threads)
  ret void
}

declare void @add_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #4

declare void @remove_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_tsk_thread_flag.1224(%struct.task_struct* %tsk, i32 %flag) #2 {
entry:
  %stack = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i32 0, i32 1
  %0 = load i8*, i8** %stack, align 8, !tbaa !89
  %1 = bitcast i8* %0 to %struct.thread_info*
  %call = call i32 @test_ti_thread_flag.1225(%struct.thread_info* %1, i32 %flag)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_ti_thread_flag.1225(%struct.thread_info* %ti, i32 %flag) #2 {
entry:
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i32 0, i32 2
  %0 = bitcast i32* %flags to i64*
  %call = call i32 @variable_test_bit.1226(i32 %flag, i64* %0)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @variable_test_bit.1226(i32 %nr, i64* %addr) #2 {
entry:
  %0 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr) #7, !srcloc !1142
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @freezing.1228(%struct.task_struct* %p) #2 {
entry:
  %call = call i32 @atomic_read.1211(%struct.atomic_t* @system_freezing_cnt)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call4 = call zeroext i1 @freezing_slow_path(%struct.task_struct* %p)
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i1 [ %call4, %if.end ], [ false, %entry ]
  ret i1 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.page* @alloc_pages.1229(i32 %gfp_mask, i32 %order) #2 {
entry:
  %call = call %struct.page* @alloc_pages_current(i32 %gfp_mask, i32 %order)
  ret %struct.page* %call
}

declare i64 @msecs_to_jiffies(i32) #4

; Function Attrs: nounwind uwtable
define void @svc_wake_up(%struct.svc_serv* %serv) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %if.end7, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %if.end7 ]
  %sv_nrpools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 13
  %0 = load i32, i32* %sv_nrpools, align 8, !tbaa !721
  %cmp = icmp ult i32 %i.0, %0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %sv_pools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 14
  %1 = load %struct.svc_pool*, %struct.svc_pool** %sv_pools, align 8, !tbaa !711
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %1, i64 %idxprom
  %sp_lock = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx, i32 0, i32 1
  call void @spin_lock_bh.1153(%struct.spinlock* %sp_lock)
  %sp_threads = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx, i32 0, i32 2
  %call = call i32 @list_empty.1168(%struct.list_head* %sp_threads)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %for.body
  %sp_threads1 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx, i32 0, i32 2
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %sp_threads1, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next, align 16, !tbaa !1113
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.svc_rqst*
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %5, 256
  %tobool2 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then5, label %do.end

if.then5:                                         ; preds = %if.then
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then5, %if.then
  %rq_wait = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %4, i32 0, i32 40
  call void @__wake_up(%struct.__wait_queue_head* %rq_wait, i32 3, i32 1, i8* null)
  br label %if.end7

if.else:                                          ; preds = %for.body
  %sp_task_pending = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx, i32 0, i32 7
  store i32 1, i32* %sp_task_pending, align 8, !tbaa !1123
  br label %if.end7

if.end7:                                          ; preds = %if.else, %do.end
  %sp_lock8 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx, i32 0, i32 1
  call void @spin_unlock_bh.1154(%struct.spinlock* %sp_lock8)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @svc_print_addr(%struct.svc_rqst* %rqstp, i8* %buf, i64 %len) #0 {
entry:
  %call = call %struct.sockaddr* @svc_addr.1203(%struct.svc_rqst* %rqstp)
  %call1 = call i8* @__svc_print_addr.1234(%struct.sockaddr* %call, i8* %buf, i64 %len)
  ret i8* %call1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @__svc_print_addr.1234(%struct.sockaddr* %addr, i8* %buf, i64 %len) #2 {
entry:
  %0 = bitcast %struct.sockaddr* %addr to %struct.sockaddr_in*
  %1 = bitcast %struct.sockaddr* %addr to %struct.sockaddr_in6*
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %addr, i32 0, i32 0
  %2 = load i16, i16* %sa_family, align 2, !tbaa !189
  %conv = zext i16 %2 to i32
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb3, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %0, i32 0, i32 2
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %0, i32 0, i32 1
  %3 = load i16, i16* %sin_port, align 2, !tbaa !191
  %call = call zeroext i16 @__fswab16.1156(i16 zeroext %3) #3
  %conv1 = zext i16 %call to i32
  %call2 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 %len, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.24.1235, i32 0, i32 0), %struct.atomic_t* %sin_addr, i32 %conv1)
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock1
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %1, i32 0, i32 3
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %1, i32 0, i32 1
  %4 = load i16, i16* %sin6_port, align 2, !tbaa !194
  %call4 = call zeroext i16 @__fswab16.1156(i16 zeroext %4) #3
  %conv5 = zext i16 %call4 to i32
  %call6 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 %len, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.25.1236, i32 0, i32 0), %struct.in6_addr* %sin6_addr, i32 %conv5)
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %sa_family7 = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %addr, i32 0, i32 0
  %5 = load i16, i16* %sa_family7, align 2, !tbaa !189
  %conv8 = zext i16 %5 to i32
  %call9 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 %len, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.26.1237, i32 0, i32 0), i32 %conv8)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb
  ret i8* %buf
}

; Function Attrs: nounwind uwtable
define void @svc_xprt_copy_addrs(%struct.svc_rqst* %rqstp, %struct.svc_xprt* %xprt) #0 {
entry:
  %xpt_remotelen = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 15
  %0 = load i64, i64* %xpt_remotelen, align 8, !tbaa !779
  %rq_addr = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 3
  %1 = bitcast %struct.__kernel_sockaddr_storage* %rq_addr to i8*
  %xpt_remote = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 14
  %2 = bitcast %struct.__kernel_sockaddr_storage* %xpt_remote to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 %0, i32 8, i1 false)
  %xpt_remotelen1 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 15
  %3 = load i64, i64* %xpt_remotelen1, align 8, !tbaa !779
  %rq_addrlen = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 4
  store i64 %3, i64* %rq_addrlen, align 8, !tbaa !648
  %xpt_locallen = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 13
  %4 = load i64, i64* %xpt_locallen, align 8, !tbaa !748
  %rq_daddr = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 5
  %5 = bitcast %struct.__kernel_sockaddr_storage* %rq_daddr to i8*
  %xpt_local = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 12
  %6 = bitcast %struct.__kernel_sockaddr_storage* %xpt_local to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 %4, i32 8, i1 false)
  %xpt_locallen5 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 13
  %7 = load i64, i64* %xpt_locallen5, align 8, !tbaa !748
  %rq_daddrlen = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 6
  store i64 %7, i64* %rq_daddrlen, align 8, !tbaa !783
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @svc_create_xprt(%struct.svc_serv* %serv, i8* %xprt_name, %struct.net* %net, i32 %family, i16 zeroext %port, i32 %flags) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  call void @spin_lock.1175(%struct.spinlock* @svc_xprt_class_lock)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @svc_xprt_class_list, i32 0, i32 0), %do.end ]
  %retval.0 = phi i32 [ undef, %do.end ], [ %retval.1, %for.inc ]
  %2 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !28
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr26 = getelementptr inbounds i8, i8* %3, i64 -24
  %4 = bitcast i8* %add.ptr26 to %struct.svc_xprt_class*
  %xcl_list = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %4, i32 0, i32 3
  %cmp = icmp ne %struct.list_head* %xcl_list, @svc_xprt_class_list
  br i1 %cmp, label %for.body, label %err

for.body:                                         ; preds = %for.cond
  %xcl_name = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %4, i32 0, i32 0
  %5 = load i8*, i8** %xcl_name, align 8, !tbaa !1089
  %call5 = call i32 @strcmp(i8* %xprt_name, i8* %5)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %NodeBlock, label %if.end8

if.end8:                                          ; preds = %for.body
  %xcl_owner = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %4, i32 0, i32 1
  %6 = load %struct.module*, %struct.module** %xcl_owner, align 8, !tbaa !1101
  %call9 = call zeroext i1 @try_module_get(%struct.module* %6)
  br i1 %call9, label %if.end11, label %NodeBlock

if.end11:                                         ; preds = %if.end8
  call void @spin_unlock.1176(%struct.spinlock* @svc_xprt_class_lock)
  %call12 = call %struct.svc_xprt* @__svc_xpo_create(%struct.svc_xprt_class* %4, %struct.svc_serv* %serv, %struct.net* %net, i32 %family, i16 zeroext %port, i32 %flags)
  %7 = bitcast %struct.svc_xprt* %call12 to i8*
  %call13 = call i64 @IS_ERR.1201(i8* %7)
  %tobool14 = icmp ne i64 %call13, 0
  br i1 %tobool14, label %if.then15, label %if.end19

if.then15:                                        ; preds = %if.end11
  %xcl_owner16 = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %4, i32 0, i32 1
  %8 = load %struct.module*, %struct.module** %xcl_owner16, align 8, !tbaa !1101
  call void @module_put(%struct.module* %8)
  %9 = bitcast %struct.svc_xprt* %call12 to i8*
  %call17 = call i64 @PTR_ERR.1202(i8* %9)
  %conv18 = trunc i64 %call17 to i32
  br label %NodeBlock

if.end19:                                         ; preds = %if.end11
  call void @svc_add_new_perm_xprt(%struct.svc_serv* %serv, %struct.svc_xprt* %call12)
  %call20 = call zeroext i16 @svc_xprt_local_port(%struct.svc_xprt* %call12)
  %conv21 = zext i16 %call20 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end19, %if.then15, %if.end8, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then15 ], [ 1, %if.end19 ], [ 6, %for.body ], [ 7, %if.end8 ]
  %retval.1 = phi i32 [ %conv18, %if.then15 ], [ %conv21, %if.end19 ], [ %retval.0, %for.body ], [ %retval.0, %if.end8 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 7
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 7
  br i1 %SwitchLeaf2, label %err, label %cleanup42

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 6
  br i1 %SwitchLeaf, label %for.inc, label %cleanup42

for.inc:                                          ; preds = %LeafBlock
  %xcl_list24 = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %4, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %xcl_list24, i32 0, i32 0
  br label %for.cond

err:                                              ; preds = %LeafBlock1, %for.cond
  call void @spin_unlock.1176(%struct.spinlock* @svc_xprt_class_lock)
  %10 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and28 = and i32 %10, 256
  %tobool29 = icmp ne i32 %and28, 0
  %lnot30 = xor i1 %tobool29, true
  %lnot32 = xor i1 %lnot30, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %expval35 = call i64 @llvm.expect.i64(i64 %conv34, i64 0)
  %tobool36 = icmp ne i64 %expval35, 0
  br i1 %tobool36, label %if.then37, label %cleanup42

if.then37:                                        ; preds = %err
  %11 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup42

cleanup42:                                        ; preds = %if.then37, %err, %LeafBlock, %LeafBlock1
  %retval.2 = phi i32 [ -93, %if.then37 ], [ -93, %err ], [ %retval.1, %LeafBlock ], [ %retval.1, %LeafBlock1 ]
  ret i32 %retval.2
}

; Function Attrs: nounwind uwtable
define internal %struct.svc_xprt* @__svc_xpo_create(%struct.svc_xprt_class* %xcl, %struct.svc_serv* %serv, %struct.net* %net, i32 %family, i16 zeroext %port, i32 %flags) #0 {
entry:
  %sin = alloca %struct.sockaddr_in, align 4
  %sin6 = alloca %struct.sockaddr_in6, align 4
  %sin_family = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %sin, i32 0, i32 0
  store i16 2, i16* %sin_family, align 4, !tbaa !738
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %sin, i32 0, i32 1
  %call = call zeroext i16 @__fswab16.1156(i16 zeroext %port) #3
  %conv = zext i16 %call to i32
  %conv1 = trunc i32 %conv to i16
  store i16 %conv1, i16* %sin_port, align 2, !tbaa !191
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %sin, i32 0, i32 2
  %s_addr = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %sin_addr, i32 0, i32 0
  store i32 0, i32* %s_addr, align 4, !tbaa !739
  %__pad = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %sin, i32 0, i32 3
  %0 = bitcast [8 x i8]* %__pad to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 8, i32 4, i1 false)
  %sin6_family = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6, i32 0, i32 0
  store i16 10, i16* %sin6_family, align 4, !tbaa !740
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6, i32 0, i32 1
  %call2 = call zeroext i16 @__fswab16.1156(i16 zeroext %port) #3
  %conv3 = zext i16 %call2 to i32
  %conv4 = trunc i32 %conv3 to i16
  store i16 %conv4, i16* %sin6_port, align 2, !tbaa !194
  %sin6_flowinfo = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6, i32 0, i32 2
  store i32 0, i32* %sin6_flowinfo, align 4, !tbaa !741
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6, i32 0, i32 3
  %in6_u = getelementptr inbounds %struct.in6_addr, %struct.in6_addr* %sin6_addr, i32 0, i32 0
  %u6_addr8 = bitcast %union.anon.68* %in6_u to [16 x i8]*
  %arrayinit.begin = getelementptr inbounds [16 x i8], [16 x i8]* %u6_addr8, i64 0, i64 0
  store i8 0, i8* %arrayinit.begin, align 1, !tbaa !166
  %arrayinit.element = getelementptr inbounds i8, i8* %arrayinit.begin, i64 1
  store i8 0, i8* %arrayinit.element, align 1, !tbaa !166
  %arrayinit.element5 = getelementptr inbounds i8, i8* %arrayinit.element, i64 1
  store i8 0, i8* %arrayinit.element5, align 1, !tbaa !166
  %arrayinit.element6 = getelementptr inbounds i8, i8* %arrayinit.element5, i64 1
  store i8 0, i8* %arrayinit.element6, align 1, !tbaa !166
  %arrayinit.element7 = getelementptr inbounds i8, i8* %arrayinit.element6, i64 1
  store i8 0, i8* %arrayinit.element7, align 1, !tbaa !166
  %arrayinit.element8 = getelementptr inbounds i8, i8* %arrayinit.element7, i64 1
  store i8 0, i8* %arrayinit.element8, align 1, !tbaa !166
  %arrayinit.element9 = getelementptr inbounds i8, i8* %arrayinit.element8, i64 1
  store i8 0, i8* %arrayinit.element9, align 1, !tbaa !166
  %arrayinit.element10 = getelementptr inbounds i8, i8* %arrayinit.element9, i64 1
  store i8 0, i8* %arrayinit.element10, align 1, !tbaa !166
  %arrayinit.element11 = getelementptr inbounds i8, i8* %arrayinit.element10, i64 1
  store i8 0, i8* %arrayinit.element11, align 1, !tbaa !166
  %arrayinit.element12 = getelementptr inbounds i8, i8* %arrayinit.element11, i64 1
  store i8 0, i8* %arrayinit.element12, align 1, !tbaa !166
  %arrayinit.element13 = getelementptr inbounds i8, i8* %arrayinit.element12, i64 1
  store i8 0, i8* %arrayinit.element13, align 1, !tbaa !166
  %arrayinit.element14 = getelementptr inbounds i8, i8* %arrayinit.element13, i64 1
  store i8 0, i8* %arrayinit.element14, align 1, !tbaa !166
  %arrayinit.element15 = getelementptr inbounds i8, i8* %arrayinit.element14, i64 1
  store i8 0, i8* %arrayinit.element15, align 1, !tbaa !166
  %arrayinit.element16 = getelementptr inbounds i8, i8* %arrayinit.element15, i64 1
  store i8 0, i8* %arrayinit.element16, align 1, !tbaa !166
  %arrayinit.element17 = getelementptr inbounds i8, i8* %arrayinit.element16, i64 1
  store i8 0, i8* %arrayinit.element17, align 1, !tbaa !166
  %arrayinit.element18 = getelementptr inbounds i8, i8* %arrayinit.element17, i64 1
  store i8 0, i8* %arrayinit.element18, align 1, !tbaa !166
  %sin6_scope_id = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %sin6, i32 0, i32 4
  store i32 0, i32* %sin6_scope_id, align 4, !tbaa !197
  %Pivot = icmp slt i32 %family, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %family, 10
  br i1 %SwitchLeaf2, label %sw.bb19, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %family, 2
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %1 = bitcast %struct.sockaddr_in* %sin to %struct.sockaddr*
  br label %sw.epilog

sw.bb19:                                          ; preds = %LeafBlock1
  %2 = bitcast %struct.sockaddr_in6* %sin6 to %struct.sockaddr*
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %call20 = call i8* @ERR_PTR.1221(i64 -97)
  %3 = bitcast i8* %call20 to %struct.svc_xprt*
  br label %cleanup

sw.epilog:                                        ; preds = %sw.bb19, %sw.bb
  %sap.0 = phi %struct.sockaddr* [ %1, %sw.bb ], [ %2, %sw.bb19 ]
  %len.0 = phi i64 [ 16, %sw.bb ], [ 28, %sw.bb19 ]
  %xcl_ops = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %xcl, i32 0, i32 2
  %4 = load %struct.svc_xprt_ops*, %struct.svc_xprt_ops** %xcl_ops, align 8, !tbaa !1143
  %xpo_create = getelementptr inbounds %struct.svc_xprt_ops, %struct.svc_xprt_ops* %4, i32 0, i32 0
  %5 = load %struct.svc_xprt* (%struct.svc_serv*, %struct.net*, %struct.sockaddr*, i32, i32)*, %struct.svc_xprt* (%struct.svc_serv*, %struct.net*, %struct.sockaddr*, i32, i32)** %xpo_create, align 8, !tbaa !1144
  %conv21 = trunc i64 %len.0 to i32
  %call22 = call %struct.svc_xprt* %5(%struct.svc_serv* %serv, %struct.net* %net, %struct.sockaddr* %sap.0, i32 %conv21, i32 %flags)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %sw.default
  %retval.0 = phi %struct.svc_xprt* [ %call22, %sw.epilog ], [ %3, %sw.default ]
  ret %struct.svc_xprt* %retval.0
}

; Function Attrs: nounwind uwtable
define void @svc_add_new_perm_xprt(%struct.svc_serv* %serv, %struct.svc_xprt* %new) #0 {
entry:
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %new, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 4, i64* %xpt_flags) #7, !srcloc !1098
  %sv_lock = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 2
  call void @spin_lock_bh.1153(%struct.spinlock* %sv_lock)
  %xpt_list = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %new, i32 0, i32 3
  %sv_permsocks = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 8
  call void @list_add.1209(%struct.list_head* %xpt_list, %struct.list_head* %sv_permsocks)
  %sv_lock1 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 2
  call void @spin_unlock_bh.1154(%struct.spinlock* %sv_lock1)
  call void @svc_xprt_received(%struct.svc_xprt* %new)
  ret void
}

; Function Attrs: nounwind uwtable
define void @svc_xprt_init(%struct.net* %net, %struct.svc_xprt_class* %xcl, %struct.svc_xprt* %xprt, %struct.svc_serv* %serv) #0 {
entry:
  %0 = bitcast %struct.svc_xprt* %xprt to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 960, i32 8, i1 false)
  %xpt_class = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 0
  store %struct.svc_xprt_class* %xcl, %struct.svc_xprt_class** %xpt_class, align 8, !tbaa !639
  %xcl_ops = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %xcl, i32 0, i32 2
  %1 = load %struct.svc_xprt_ops*, %struct.svc_xprt_ops** %xcl_ops, align 8, !tbaa !1143
  %xpt_ops = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 1
  store %struct.svc_xprt_ops* %1, %struct.svc_xprt_ops** %xpt_ops, align 8, !tbaa !653
  %xpt_ref = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 2
  call void @kref_init.1247(%struct.arch_spinlock* %xpt_ref)
  %xpt_server = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 6
  store %struct.svc_serv* %serv, %struct.svc_serv** %xpt_server, align 8, !tbaa !782
  %xpt_list = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 3
  call void @INIT_LIST_HEAD.1178(%struct.list_head* %xpt_list)
  %xpt_ready = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 4
  call void @INIT_LIST_HEAD.1178(%struct.list_head* %xpt_ready)
  %xpt_deferred = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 11
  call void @INIT_LIST_HEAD.1178(%struct.list_head* %xpt_deferred)
  %xpt_users = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 17
  call void @INIT_LIST_HEAD.1178(%struct.list_head* %xpt_users)
  %xpt_mutex = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 8
  call void @__mutex_init(%struct.mutex* %xpt_mutex, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.3.1248, i32 0, i32 0), %struct.lock_class_key* @svc_xprt_init.__key)
  call void @spinlock_check.1249()
  %xpt_lock3 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 9
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %xpt_lock3, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %2 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.5.1250, i32 0, i32 0), %struct.lock_class_key* @svc_xprt_init.__key.4)
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 0, i64* %xpt_flags) #7, !srcloc !1092
  %xpt_bc_pending = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 16
  call void @rpc_init_wait_queue(%struct.rpc_wait_queue* %xpt_bc_pending, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.6.1251, i32 0, i32 0))
  %call6 = call %struct.net* @get_net.1252(%struct.net* %net)
  %xpt_net = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt, i32 0, i32 18
  store %struct.net* %call6, %struct.net** %xpt_net, align 8, !tbaa !810
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @kref_init.1247(%struct.arch_spinlock* %kref) #2 {
entry:
  %refcount = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %kref, i32 0, i32 0
  call void @atomic_set.1254(%struct.atomic_t* %refcount, i32 1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spinlock_check.1249() #2 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.net* @get_net.1252(%struct.net* %net) #2 {
entry:
  %count = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 1
  call void @atomic_inc.1253(%struct.atomic_t* %count)
  ret %struct.net* %net
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.1253(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !1145
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set.1254(%struct.atomic_t* %v, i32 %i) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !240
  ret void
}

; Function Attrs: nounwind uwtable
define void @svc_unreg_xprt_class(%struct.svc_xprt_class* %xcl) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  call void @spin_lock.1175(%struct.spinlock* @svc_xprt_class_lock)
  %xcl_list = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %xcl, i32 0, i32 3
  call void @list_del_init.1167(%struct.list_head* %xcl_list)
  call void @spin_unlock.1176(%struct.spinlock* @svc_xprt_class_lock)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @svc_reg_xprt_class(%struct.svc_xprt_class* %xcl) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 256
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %xcl_list = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %xcl, i32 0, i32 3
  call void @INIT_LIST_HEAD.1178(%struct.list_head* %xcl_list)
  call void @spin_lock.1175(%struct.spinlock* @svc_xprt_class_lock)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @svc_xprt_class_list, i32 0, i32 0), %do.end ]
  %2 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !28
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr15 = getelementptr inbounds i8, i8* %3, i64 -24
  %4 = bitcast i8* %add.ptr15 to %struct.svc_xprt_class*
  %xcl_list3 = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %4, i32 0, i32 3
  %cmp = icmp ne %struct.list_head* %xcl_list3, @svc_xprt_class_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %xcl_name5 = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %xcl, i32 0, i32 0
  %5 = load i8*, i8** %xcl_name5, align 8, !tbaa !1089
  %xcl_name6 = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %4, i32 0, i32 0
  %6 = load i8*, i8** %xcl_name6, align 8, !tbaa !1089
  %call7 = call i32 @strcmp(i8* %5, i8* %6)
  %cmp8 = icmp eq i32 %call7, 0
  br i1 %cmp8, label %out, label %for.inc

for.inc:                                          ; preds = %for.body
  %xcl_list13 = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %4, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %xcl_list13, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %xcl_list16 = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %xcl, i32 0, i32 3
  call void @list_add_tail.1193(%struct.list_head* %xcl_list16, %struct.list_head* @svc_xprt_class_list)
  br label %out

out:                                              ; preds = %for.end, %for.body
  %res.0 = phi i32 [ 0, %for.end ], [ -17, %for.body ]
  call void @spin_unlock.1176(%struct.spinlock* @svc_xprt_class_lock)
  ret i32 %res.0
}

; Function Attrs: nounwind uwtable
define i32 @svc_print_xprts(i8* %buf, i32 %maxlen) #0 {
entry:
  %tmpstr = alloca [80 x i8], align 16
  %arrayidx = getelementptr inbounds i8, i8* %buf, i64 0
  store i8 0, i8* %arrayidx, align 1, !tbaa !166
  call void @spin_lock.1175(%struct.spinlock* @svc_xprt_class_lock)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @svc_xprt_class_list, i32 0, i32 0), %entry ]
  %len.0 = phi i32 [ 0, %entry ], [ %len.1, %for.inc ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !28
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr11 = getelementptr inbounds i8, i8* %1, i64 -24
  %2 = bitcast i8* %add.ptr11 to %struct.svc_xprt_class*
  %xcl_list = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %2, i32 0, i32 3
  %cmp = icmp ne %struct.list_head* %xcl_list, @svc_xprt_class_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %arraydecay1 = getelementptr inbounds [80 x i8], [80 x i8]* %tmpstr, i32 0, i32 0
  %call2 = call i64 @strlen(i8* %arraydecay1)
  %conv = trunc i64 %call2 to i32
  %add = add nsw i32 %len.0, %conv
  %cmp3 = icmp sgt i32 %add, %maxlen
  br i1 %cmp3, label %LeafBlock, label %if.end

if.end:                                           ; preds = %for.body
  %arraydecay6 = getelementptr inbounds [80 x i8], [80 x i8]* %tmpstr, i32 0, i32 0
  %call7 = call i8* @strcat(i8* %buf, i8* %arraydecay6)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end, %for.body
  %len.1 = phi i32 [ %add, %if.end ], [ %len.0, %for.body ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end ], [ 2, %for.body ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf, label %for.end, label %for.inc

for.inc:                                          ; preds = %LeafBlock
  %xcl_list9 = getelementptr inbounds %struct.svc_xprt_class, %struct.svc_xprt_class* %2, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %xcl_list9, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %LeafBlock, %for.cond
  %len.2 = phi i32 [ %len.1, %LeafBlock ], [ %len.0, %for.cond ]
  call void @spin_unlock.1176(%struct.spinlock* @svc_xprt_class_lock)
  ret i32 %len.2
}

; Function Attrs: nounwind uwtable
define i32 @svc_send(%struct.svc_rqst* %rqstp) #0 {
entry:
  %rq_xprt = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %0 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt, align 8, !tbaa !635
  %tobool = icmp ne %struct.svc_xprt* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %rq_xprt1 = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 2
  %1 = load %struct.svc_xprt*, %struct.svc_xprt** %rq_xprt1, align 8, !tbaa !635
  %xpt_ops = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %1, i32 0, i32 1
  %2 = load %struct.svc_xprt_ops*, %struct.svc_xprt_ops** %xpt_ops, align 8, !tbaa !653
  %xpo_release_rqst = getelementptr inbounds %struct.svc_xprt_ops, %struct.svc_xprt_ops* %2, i32 0, i32 6
  %3 = load void (%struct.svc_rqst*)*, void (%struct.svc_rqst*)** %xpo_release_rqst, align 8, !tbaa !1105
  call void %3(%struct.svc_rqst* %rqstp)
  %rq_res = getelementptr inbounds %struct.svc_rqst, %struct.svc_rqst* %rqstp, i32 0, i32 17
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 1
  %4 = load i64, i64* %iov_len, align 8, !tbaa !149
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res, i32 0, i32 4
  %5 = load i32, i32* %page_len, align 4, !tbaa !150
  %conv = zext i32 %5 to i64
  %add = add i64 %4, %conv
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res, i32 0, i32 1
  %arrayidx2 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_len3 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx2, i32 0, i32 1
  %6 = load i64, i64* %iov_len3, align 8, !tbaa !149
  %add4 = add i64 %add, %6
  %conv5 = trunc i64 %add4 to i32
  %len6 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_res, i32 0, i32 7
  store i32 %conv5, i32* %len6, align 8, !tbaa !152
  %xpt_mutex = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %0, i32 0, i32 8
  call void @mutex_lock_nested(%struct.mutex* %xpt_mutex, i32 0)
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %0, i32 0, i32 5
  %7 = load volatile i64, i64* %xpt_flags, align 8, !tbaa !88
  %and.i1 = and i64 64, %7
  %cmp.i2 = icmp ne i64 %and.i1, 0
  %conv.i3 = zext i1 %cmp.i2 to i32
  %tobool7 = icmp ne i32 %conv.i3, 0
  br i1 %tobool7, label %if.end22, label %cond.true11

cond.true11:                                      ; preds = %if.end
  %xpt_flags12 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %0, i32 0, i32 5
  %8 = load volatile i64, i64* %xpt_flags12, align 8, !tbaa !88
  %and.i = and i64 4, %8
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool14 = icmp ne i32 %conv.i, 0
  br i1 %tobool14, label %if.end22, label %if.else

if.else:                                          ; preds = %cond.true11
  %xpt_ops20 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %0, i32 0, i32 1
  %9 = load %struct.svc_xprt_ops*, %struct.svc_xprt_ops** %xpt_ops20, align 8, !tbaa !653
  %xpo_sendto = getelementptr inbounds %struct.svc_xprt_ops, %struct.svc_xprt_ops* %9, i32 0, i32 5
  %10 = load i32 (%struct.svc_rqst*)*, i32 (%struct.svc_rqst*)** %xpo_sendto, align 8, !tbaa !1146
  %call21 = call i32 %10(%struct.svc_rqst* %rqstp)
  br label %if.end22

if.end22:                                         ; preds = %if.else, %cond.true11, %if.end
  %len.0 = phi i32 [ %call21, %if.else ], [ -107, %cond.true11 ], [ -107, %if.end ]
  %xpt_mutex23 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %0, i32 0, i32 8
  call void @mutex_unlock(%struct.mutex* %xpt_mutex23)
  %xpt_bc_pending = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %0, i32 0, i32 16
  call void @rpc_wake_up(%struct.rpc_wait_queue* %xpt_bc_pending)
  call void @svc_xprt_release(%struct.svc_rqst* %rqstp)
  switch i32 %len.0, label %if.end32 [
    i32 -111, label %cleanup
    i32 -107, label %cleanup
    i32 -11, label %cleanup
  ]

if.end32:                                         ; preds = %if.end22
  br label %cleanup

cleanup:                                          ; preds = %if.end32, %if.end22, %if.end22, %if.end22, %entry
  %retval.0 = phi i32 [ %len.0, %if.end32 ], [ -14, %entry ], [ 0, %if.end22 ], [ 0, %if.end22 ], [ 0, %if.end22 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @svc_close_net(%struct.svc_serv* %serv, %struct.net* %net) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %delay.0 = phi i32 [ 0, %entry ], [ %inc, %while.body ]
  %sv_permsocks = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 8
  %call = call i32 @svc_close_list(%struct.svc_serv* %serv, %struct.list_head* %sv_permsocks, %struct.net* %net)
  %sv_tempsocks = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 9
  %call1 = call i32 @svc_close_list(%struct.svc_serv* %serv, %struct.list_head* %sv_tempsocks, %struct.net* %net)
  %add = add nsw i32 %call, %call1
  %tobool = icmp ne i32 %add, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @svc_clean_up_xprts(%struct.svc_serv* %serv, %struct.net* %net)
  %inc = add nsw i32 %delay.0, 1
  call void @msleep(i32 %delay.0)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @svc_close_list(%struct.svc_serv* %serv, %struct.list_head* %xprt_list, %struct.net* %net) #0 {
entry:
  %sv_lock = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 2
  call void @spin_lock.1175(%struct.spinlock* %sv_lock)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %xpt_list3.sink = phi %struct.list_head* [ %xpt_list3, %for.inc ], [ %xprt_list, %entry ]
  %ret.0 = phi i32 [ 0, %entry ], [ %ret.1, %for.inc ]
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %xpt_list3.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next4, align 8, !tbaa !28
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr6 = getelementptr inbounds i8, i8* %1, i64 -24
  %2 = bitcast i8* %add.ptr6 to %struct.svc_xprt*
  %xpt_list = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 3
  %cmp = icmp ne %struct.list_head* %xpt_list, %xprt_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %xpt_net = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 18
  %3 = load %struct.net*, %struct.net** %xpt_net, align 8, !tbaa !810
  %cmp1 = icmp ne %struct.net* %3, %net
  br i1 %cmp1, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %inc = add nsw i32 %ret.0, 1
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 2, i64* %xpt_flags) #7, !srcloc !1092
  call void @svc_xprt_enqueue(%struct.svc_xprt* %2)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %for.body
  %ret.1 = phi i32 [ %inc, %if.end ], [ %ret.0, %for.body ]
  %xpt_list3 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 3
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %sv_lock7 = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 2
  call void @spin_unlock.1176(%struct.spinlock* %sv_lock7)
  ret i32 %ret.0
}

; Function Attrs: nounwind uwtable
define internal void @svc_clean_up_xprts(%struct.svc_serv* %serv, %struct.net* %net) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call %struct.svc_xprt* @svc_dequeue_net(%struct.svc_serv* %serv, %struct.net* %net)
  %tobool = icmp ne %struct.svc_xprt* %call, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %call, i32 0, i32 5
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %xpt_flags, i32 2, i64* %xpt_flags) #7, !srcloc !1092
  call void @svc_delete_xprt(%struct.svc_xprt* %call)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

declare void @msleep(i32) #4

; Function Attrs: nounwind uwtable
define internal %struct.svc_xprt* @svc_dequeue_net(%struct.svc_serv* %serv, %struct.net* %net) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.end, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.end ]
  %sv_nrpools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 13
  %0 = load i32, i32* %sv_nrpools, align 8, !tbaa !721
  %cmp = icmp ult i32 %i.0, %0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %sv_pools = getelementptr inbounds %struct.svc_serv, %struct.svc_serv* %serv, i32 0, i32 14
  %1 = load %struct.svc_pool*, %struct.svc_pool** %sv_pools, align 8, !tbaa !711
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %1, i64 %idxprom
  %sp_lock = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx, i32 0, i32 1
  call void @spin_lock_bh.1153(%struct.spinlock* %sp_lock)
  %sp_sockets = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %sp_sockets, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next, align 32, !tbaa !164
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr to %struct.svc_xprt*
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %.sink = phi %struct.svc_xprt* [ %7, %for.inc ], [ %4, %for.body ]
  %xprt.0 = phi %struct.svc_xprt* [ %4, %for.body ], [ %7, %for.inc ]
  %xpt_ready15 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %.sink, i32 0, i32 4
  %next16 = getelementptr inbounds %struct.list_head, %struct.list_head* %xpt_ready15, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next16, align 8, !tbaa !1147
  %6 = bitcast %struct.list_head* %5 to i8*
  %add.ptr18 = getelementptr inbounds i8, i8* %6, i64 -40
  %7 = bitcast i8* %add.ptr18 to %struct.svc_xprt*
  %xpt_ready7 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt.0, i32 0, i32 4
  %sp_sockets8 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx, i32 0, i32 3
  %cmp9 = icmp ne %struct.list_head* %xpt_ready7, %sp_sockets8
  br i1 %cmp9, label %for.body10, label %for.end

for.body10:                                       ; preds = %for.cond6
  %xpt_net = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt.0, i32 0, i32 18
  %8 = load %struct.net*, %struct.net** %xpt_net, align 8, !tbaa !810
  %cmp11 = icmp ne %struct.net* %8, %net
  br i1 %cmp11, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body10
  %xpt_ready12 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %xprt.0, i32 0, i32 4
  call void @list_del_init.1167(%struct.list_head* %xpt_ready12)
  %sp_lock13 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx, i32 0, i32 1
  call void @spin_unlock_bh.1154(%struct.spinlock* %sp_lock13)
  br label %cleanup

for.inc:                                          ; preds = %for.body10
  br label %for.cond6

for.end:                                          ; preds = %for.cond6
  %sp_lock19 = getelementptr inbounds %struct.svc_pool, %struct.svc_pool* %arrayidx, i32 0, i32 1
  call void @spin_unlock_bh.1154(%struct.spinlock* %sp_lock19)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.end, %for.cond
  %retval.0 = phi %struct.svc_xprt* [ %xprt.0, %if.end ], [ null, %for.cond ]
  ret %struct.svc_xprt* %retval.0
}

; Function Attrs: nounwind uwtable
define void @xprt_destroy_backchannel(%struct.rpc_xprt* %xprt, i32 %max_reqs) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %cmp = icmp eq i32 %max_reqs, 0
  br i1 %cmp, label %do.body41, label %if.end5

if.end5:                                          ; preds = %do.end
  %bc_pa_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 36
  call void @spin_lock_bh.1268(%struct.spinlock* %bc_pa_lock)
  call void @xprt_dec_alloc_count(%struct.rpc_xprt* %xprt, i32 %max_reqs)
  %bc_pa_list = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 37
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %bc_pa_list, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -384
  %4 = bitcast i8* %add.ptr to %struct.rpc_rqst*
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %.sink = phi %struct.rpc_rqst* [ %7, %for.inc ], [ %4, %if.end5 ]
  %req.0 = phi %struct.rpc_rqst* [ %4, %if.end5 ], [ %7, %for.inc ]
  %max_reqs.addr.0 = phi i32 [ %max_reqs, %if.end5 ], [ %dec, %for.inc ]
  %rq_bc_pa_list36 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %.sink, i32 0, i32 28
  %next37 = getelementptr inbounds %struct.list_head, %struct.list_head* %rq_bc_pa_list36, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next37, align 8, !tbaa !1148
  %6 = bitcast %struct.list_head* %5 to i8*
  %add.ptr39 = getelementptr inbounds i8, i8* %6, i64 -384
  %7 = bitcast i8* %add.ptr39 to %struct.rpc_rqst*
  %rq_bc_pa_list12 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req.0, i32 0, i32 28
  %bc_pa_list13 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 37
  %cmp14 = icmp ne %struct.list_head* %rq_bc_pa_list12, %bc_pa_list13
  br i1 %cmp14, label %do.body16, label %for.end

do.body16:                                        ; preds = %for.cond
  %8 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and17 = and i32 %8, 128
  %tobool18 = icmp ne i32 %and17, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %if.then26, label %do.end30

if.then26:                                        ; preds = %do.body16
  %9 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end30

do.end30:                                         ; preds = %if.then26, %do.body16
  call void @xprt_free_allocation(%struct.rpc_rqst* %req.0)
  %dec = add i32 %max_reqs.addr.0, -1
  %cmp31 = icmp eq i32 %dec, 0
  br i1 %cmp31, label %for.end, label %for.inc

for.inc:                                          ; preds = %do.end30
  br label %for.cond

for.end:                                          ; preds = %do.end30, %for.cond
  %bc_pa_lock40 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 36
  call void @spin_unlock_bh.1270(%struct.spinlock* %bc_pa_lock40)
  br label %do.body41

do.body41:                                        ; preds = %for.end, %do.end
  %10 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and42 = and i32 %10, 128
  %tobool43 = icmp ne i32 %and42, 0
  %lnot44 = xor i1 %tobool43, true
  %lnot46 = xor i1 %lnot44, true
  %lnot.ext47 = zext i1 %lnot46 to i32
  %conv48 = sext i32 %lnot.ext47 to i64
  %expval49 = call i64 @llvm.expect.i64(i64 %conv48, i64 0)
  %tobool50 = icmp ne i64 %expval49, 0
  br i1 %tobool50, label %if.then51, label %do.end58

if.then51:                                        ; preds = %do.body41
  %bc_pa_list52 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 37
  %call53 = call i32 @list_empty.1271(%struct.list_head* %bc_pa_list52)
  %11 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end58

do.end58:                                         ; preds = %if.then51, %do.body41
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_bh.1268(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_dec_alloc_count(%struct.rpc_xprt* %xprt, i32 %n) #2 {
entry:
  %bc_alloc_count = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %0 = load i32, i32* %bc_alloc_count, align 8, !tbaa !1149
  %sub = sub i32 %0, %n
  store i32 %sub, i32* %bc_alloc_count, align 8, !tbaa !1149
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xprt_free_allocation(%struct.rpc_rqst* %req) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %rq_bc_pa_state = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 27
  %2 = load volatile i64, i64* %rq_bc_pa_state, align 8, !tbaa !88
  %and.i = and i64 2, %2
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool4 = icmp ne i32 %conv.i, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %tobool9 = icmp ne i32 %lnot.ext8, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %if.then17, label %if.end45

if.then17:                                        ; preds = %do.end
  %3 = load i8, i8* @xprt_free_allocation.__warned, align 1, !tbaa !29, !range !31
  %tobool18 = trunc i8 %3 to i1
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot23 = xor i1 %lnot21, true
  %lnot.ext24 = zext i1 %lnot23 to i32
  %tobool25 = icmp ne i32 %lnot.ext24, 0
  %lnot26 = xor i1 %tobool25, true
  %lnot28 = xor i1 %lnot26, true
  %lnot.ext29 = zext i1 %lnot28 to i32
  %conv30 = sext i32 %lnot.ext29 to i64
  %expval31 = call i64 @llvm.expect.i64(i64 %conv30, i64 0)
  %tobool32 = icmp ne i64 %expval31, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.then17
  call void @warn_slowpath_null(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.15.1277, i32 0, i32 0), i32 62)
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.then17
  %tobool35 = icmp ne i32 %lnot.ext24, 0
  %lnot36 = xor i1 %tobool35, true
  %lnot38 = xor i1 %lnot36, true
  %lnot.ext39 = zext i1 %lnot38 to i32
  %conv40 = sext i32 %lnot.ext39 to i64
  %expval41 = call i64 @llvm.expect.i64(i64 %conv40, i64 0)
  %tobool42 = icmp ne i64 %expval41, 0
  br i1 %tobool42, label %if.then43, label %if.end45

if.then43:                                        ; preds = %if.end34
  store i8 1, i8* @xprt_free_allocation.__warned, align 1, !tbaa !29
  br label %if.end45

if.end45:                                         ; preds = %if.then43, %if.end34, %do.end
  %rq_private_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 17
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  %4 = load i8*, i8** %iov_base, align 8, !tbaa !147
  %5 = ptrtoint i8* %4 to i64
  call void @free_pages(i64 %5, i32 0)
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 1
  %head54 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 0
  %arrayidx55 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head54, i64 0, i64 0
  %iov_base56 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx55, i32 0, i32 0
  %6 = load i8*, i8** %iov_base56, align 8, !tbaa !147
  %7 = ptrtoint i8* %6 to i64
  call void @free_pages(i64 %7, i32 0)
  %rq_bc_pa_list = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 28
  call void @list_del(%struct.list_head* %rq_bc_pa_list)
  %8 = bitcast %struct.rpc_rqst* %req to i8*
  call void @kfree(i8* %8)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_bh.1270(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty.1271(%struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @xprt_setup_backchannel(%struct.rpc_xprt* %xprt, i32 %min_reqs) #0 {
entry:
  %tmp_list = alloca %struct.list_head, align 8
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  call void @INIT_LIST_HEAD.1279(%struct.list_head* %tmp_list)
  br label %for.cond

for.cond:                                         ; preds = %if.end44, %do.end
  %i.0 = phi i32 [ 0, %do.end ], [ %inc, %if.end44 ]
  %cmp = icmp ult i32 %i.0, %min_reqs
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call4 = call i8* @kzalloc.1280(i64 400, i32 208)
  %2 = bitcast i8* %call4 to %struct.rpc_rqst*
  %cmp5 = icmp eq %struct.rpc_rqst* %2, null
  br i1 %cmp5, label %if.then7, label %do.body10

if.then7:                                         ; preds = %for.body
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_free

do.body10:                                        ; preds = %for.body
  %4 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and11 = and i32 %4, 128
  %tobool12 = icmp ne i32 %and11, 0
  %lnot13 = xor i1 %tobool12, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv17 = sext i32 %lnot.ext16 to i64
  %expval18 = call i64 @llvm.expect.i64(i64 %conv17, i64 0)
  %tobool19 = icmp ne i64 %expval18, 0
  br i1 %tobool19, label %if.then20, label %do.end24

if.then20:                                        ; preds = %do.body10
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end24

do.end24:                                         ; preds = %if.then20, %do.body10
  %rq_bc_pa_list = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %2, i32 0, i32 28
  call void @list_add.1283(%struct.list_head* %rq_bc_pa_list, %struct.list_head* %tmp_list)
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %2, i32 0, i32 0
  store %struct.rpc_xprt* %xprt, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %rq_list = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %2, i32 0, i32 11
  call void @INIT_LIST_HEAD.1279(%struct.list_head* %rq_list)
  %rq_bc_list = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %2, i32 0, i32 26
  call void @INIT_LIST_HEAD.1279(%struct.list_head* %rq_bc_list)
  %call25 = call %struct.page* @alloc_pages.1284(i32 208, i32 0)
  %cmp26 = icmp eq %struct.page* %call25, null
  br i1 %cmp26, label %if.then28, label %if.end30

if.then28:                                        ; preds = %do.end24
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_free

if.end30:                                         ; preds = %do.end24
  %rq_rcv_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %2, i32 0, i32 2
  %sub.ptr.lhs.cast.i1 = ptrtoint %struct.page* %call25 to i64
  %sub.ptr.sub.i2 = sub i64 %sub.ptr.lhs.cast.i1, -24189255811072
  %sub.ptr.div.i3 = sdiv exact i64 %sub.ptr.sub.i2, 64
  %shl.i4 = shl i64 %sub.ptr.div.i3, 12
  %add.i5 = add i64 %shl.i4, -131941395333120
  %7 = inttoptr i64 %add.i5 to i8*
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_rcv_buf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx, i32 0, i32 0
  store i8* %7, i8** %iov_base, align 8, !tbaa !147
  %head32 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_rcv_buf, i32 0, i32 0
  %arrayidx33 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head32, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx33, i32 0, i32 1
  store i64 4096, i64* %iov_len, align 8, !tbaa !149
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_rcv_buf, i32 0, i32 1
  %arrayidx34 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail, i64 0, i64 0
  %iov_base35 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx34, i32 0, i32 0
  store i8* null, i8** %iov_base35, align 8, !tbaa !147
  %tail36 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_rcv_buf, i32 0, i32 1
  %arrayidx37 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail36, i64 0, i64 0
  %iov_len38 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx37, i32 0, i32 1
  store i64 0, i64* %iov_len38, align 8, !tbaa !149
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_rcv_buf, i32 0, i32 4
  store i32 0, i32* %page_len, align 4, !tbaa !150
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_rcv_buf, i32 0, i32 7
  store i32 4096, i32* %len, align 8, !tbaa !152
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_rcv_buf, i32 0, i32 6
  store i32 4096, i32* %buflen, align 4, !tbaa !153
  %call39 = call %struct.page* @alloc_pages.1284(i32 208, i32 0)
  %cmp40 = icmp eq %struct.page* %call39, null
  br i1 %cmp40, label %if.then42, label %if.end44

if.then42:                                        ; preds = %if.end30
  %8 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_free

if.end44:                                         ; preds = %if.end30
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %2, i32 0, i32 1
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %call39 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %9 = inttoptr i64 %add.i to i8*
  %head46 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 0
  %arrayidx47 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head46, i64 0, i64 0
  %iov_base48 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx47, i32 0, i32 0
  store i8* %9, i8** %iov_base48, align 8, !tbaa !147
  %head49 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 0
  %arrayidx50 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %head49, i64 0, i64 0
  %iov_len51 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx50, i32 0, i32 1
  store i64 0, i64* %iov_len51, align 8, !tbaa !149
  %tail52 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 1
  %arrayidx53 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail52, i64 0, i64 0
  %iov_base54 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx53, i32 0, i32 0
  store i8* null, i8** %iov_base54, align 8, !tbaa !147
  %tail55 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 1
  %arrayidx56 = getelementptr inbounds [1 x %struct.iovec], [1 x %struct.iovec]* %tail55, i64 0, i64 0
  %iov_len57 = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx56, i32 0, i32 1
  store i64 0, i64* %iov_len57, align 8, !tbaa !149
  %page_len58 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 4
  store i32 0, i32* %page_len58, align 4, !tbaa !150
  %len59 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 7
  store i32 0, i32* %len59, align 8, !tbaa !152
  %buflen60 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 6
  store i32 4096, i32* %buflen60, align 4, !tbaa !153
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %bc_pa_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 36
  call void @spin_lock_bh.1268(%struct.spinlock* %bc_pa_lock)
  %bc_pa_list = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 37
  call void @list_splice(%struct.list_head* %tmp_list, %struct.list_head* %bc_pa_list)
  call void @xprt_inc_alloc_count(%struct.rpc_xprt* %xprt, i32 %min_reqs)
  %bc_pa_lock61 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 36
  call void @spin_unlock_bh.1270(%struct.spinlock* %bc_pa_lock61)
  %10 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and63 = and i32 %10, 128
  %tobool64 = icmp ne i32 %and63, 0
  %lnot65 = xor i1 %tobool64, true
  %lnot67 = xor i1 %lnot65, true
  %lnot.ext68 = zext i1 %lnot67 to i32
  %conv69 = sext i32 %lnot.ext68 to i64
  %expval70 = call i64 @llvm.expect.i64(i64 %conv69, i64 0)
  %tobool71 = icmp ne i64 %expval70, 0
  br i1 %tobool71, label %if.then72, label %cleanup

if.then72:                                        ; preds = %for.end
  %11 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

out_free:                                         ; preds = %if.then42, %if.then28, %if.then7
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %tmp_list, i32 0, i32 0
  %12 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %13 = bitcast %struct.list_head* %12 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %13, i64 -384
  %14 = bitcast i8* %add.ptr to %struct.rpc_rqst*
  br label %for.cond83

for.cond83:                                       ; preds = %for.body87, %out_free
  %.sink = phi %struct.rpc_rqst* [ %17, %for.body87 ], [ %14, %out_free ]
  %req.0 = phi %struct.rpc_rqst* [ %14, %out_free ], [ %17, %for.body87 ]
  %rq_bc_pa_list90 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %.sink, i32 0, i32 28
  %next91 = getelementptr inbounds %struct.list_head, %struct.list_head* %rq_bc_pa_list90, i32 0, i32 0
  %15 = load %struct.list_head*, %struct.list_head** %next91, align 8, !tbaa !1148
  %16 = bitcast %struct.list_head* %15 to i8*
  %add.ptr93 = getelementptr inbounds i8, i8* %16, i64 -384
  %17 = bitcast i8* %add.ptr93 to %struct.rpc_rqst*
  %rq_bc_pa_list84 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req.0, i32 0, i32 28
  %cmp85 = icmp ne %struct.list_head* %rq_bc_pa_list84, %tmp_list
  br i1 %cmp85, label %for.body87, label %do.body95

for.body87:                                       ; preds = %for.cond83
  call void @xprt_free_allocation(%struct.rpc_rqst* %req.0)
  br label %for.cond83

do.body95:                                        ; preds = %for.cond83
  %18 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and96 = and i32 %18, 128
  %tobool97 = icmp ne i32 %and96, 0
  %lnot98 = xor i1 %tobool97, true
  %lnot100 = xor i1 %lnot98, true
  %lnot.ext101 = zext i1 %lnot100 to i32
  %conv102 = sext i32 %lnot.ext101 to i64
  %expval103 = call i64 @llvm.expect.i64(i64 %conv102, i64 0)
  %tobool104 = icmp ne i64 %expval103, 0
  br i1 %tobool104, label %if.then105, label %cleanup

if.then105:                                       ; preds = %do.body95
  %19 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then105, %do.body95, %if.then72, %for.end
  %retval.0 = phi i32 [ 0, %if.then72 ], [ 0, %for.end ], [ -12, %if.then105 ], [ -12, %do.body95 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.1279(%struct.list_head* %list) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !164
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !163
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.1280(i64 %size, i32 %flags) #2 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #7
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add.1283(%struct.list_head* %new, %struct.list_head* %head) #2 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.page* @alloc_pages.1284(i32 %gfp_mask, i32 %order) #2 {
entry:
  %call = call %struct.page* @alloc_pages_current(i32 %gfp_mask, i32 %order)
  ret %struct.page* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_splice(%struct.list_head* %list, %struct.list_head* %head) #2 {
entry:
  %call = call i32 @list_empty.1271(%struct.list_head* %list)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  call void @__list_splice.1290(%struct.list_head* %list, %struct.list_head* %head, %struct.list_head* %0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_inc_alloc_count(%struct.rpc_xprt* %xprt, i32 %n) #2 {
entry:
  %bc_alloc_count = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %0 = load i32, i32* %bc_alloc_count, align 8, !tbaa !1149
  %add = add i32 %0, %n
  store i32 %add, i32* %bc_alloc_count, align 8, !tbaa !1149
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_splice.1290(%struct.list_head* %list, %struct.list_head* %prev, %struct.list_head* %next) #2 {
entry:
  %next1 = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next1, align 8, !tbaa !164
  %prev2 = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  %1 = load %struct.list_head*, %struct.list_head** %prev2, align 8, !tbaa !163
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !163
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  store %struct.list_head* %0, %struct.list_head** %next4, align 8, !tbaa !164
  %next5 = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next5, align 8, !tbaa !164
  %prev6 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %1, %struct.list_head** %prev6, align 8, !tbaa !163
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.rpc_rqst* @xprt_alloc_bc_request(%struct.rpc_xprt* %xprt) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %bc_pa_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 36
  call void @spin_lock.1295(%struct.spinlock* %bc_pa_lock)
  %bc_pa_list = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 37
  %call3 = call i32 @list_empty.1271(%struct.list_head* %bc_pa_list)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end7, label %if.then5

if.then5:                                         ; preds = %do.end
  %bc_pa_list6 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 37
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %bc_pa_list6, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !164
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -384
  %4 = bitcast i8* %add.ptr to %struct.rpc_rqst*
  %rq_bc_pa_list = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %4, i32 0, i32 28
  call void @list_del(%struct.list_head* %rq_bc_pa_list)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %do.end
  %req.0 = phi %struct.rpc_rqst* [ %4, %if.then5 ], [ null, %do.end ]
  %bc_pa_lock8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 36
  call void @spin_unlock.1296(%struct.spinlock* %bc_pa_lock8)
  %cmp = icmp ne %struct.rpc_rqst* %req.0, null
  br i1 %cmp, label %if.then10, label %do.body21

if.then10:                                        ; preds = %if.end7
  %rq_bc_pa_state = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req.0, i32 0, i32 27
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %rq_bc_pa_state, i32 1, i64* %rq_bc_pa_state) #7, !srcloc !1150
  %rq_reply_bytes_recvd = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req.0, i32 0, i32 16
  store i64 0, i64* %rq_reply_bytes_recvd, align 8, !tbaa !142
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req.0, i32 0, i32 23
  store i32 0, i32* %rq_bytes_sent, align 8, !tbaa !143
  %cmp11 = icmp uge i64 64, 64
  %rq_private_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req.0, i32 0, i32 17
  %5 = bitcast %struct.xdr_buf* %rq_private_buf to i8*
  %rq_rcv_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req.0, i32 0, i32 2
  %6 = bitcast %struct.xdr_buf* %rq_rcv_buf to i8*
  br i1 %cmp11, label %if.then13, label %if.else15

if.then13:                                        ; preds = %if.then10
  %call14 = call i8* @__memcpy(i8* %5, i8* %6, i64 64)
  br label %do.body21

if.else15:                                        ; preds = %if.then10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 64, i32 8, i1 false)
  br label %do.body21

do.body21:                                        ; preds = %if.else15, %if.then13, %if.end7
  %7 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and22 = and i32 %7, 128
  %tobool23 = icmp ne i32 %and22, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %do.end35

if.then31:                                        ; preds = %do.body21
  %8 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end35

do.end35:                                         ; preds = %if.then31, %do.body21
  ret %struct.rpc_rqst* %req.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock.1295(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock.1296(%struct.spinlock* %lock) #2 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define void @xprt_free_bc_request(%struct.rpc_rqst* %req) #0 {
entry:
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 0
  %0 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !71
  %1 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %1, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !1151
  %rq_bc_pa_state = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 27
  %3 = load volatile i64, i64* %rq_bc_pa_state, align 8, !tbaa !88
  %and.i = and i64 2, %3
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool4 = icmp ne i32 %conv.i, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %tobool11 = icmp ne i32 %lnot.ext10, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %if.then19, label %if.end47

if.then19:                                        ; preds = %do.end
  %4 = load i8, i8* @xprt_free_bc_request.__warned, align 1, !tbaa !29, !range !31
  %tobool20 = trunc i8 %4 to i1
  %lnot21 = xor i1 %tobool20, true
  %lnot23 = xor i1 %lnot21, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %tobool27 = icmp ne i32 %lnot.ext26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.then19
  call void @warn_slowpath_null(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.15.1277, i32 0, i32 0), i32 261)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.then19
  %tobool37 = icmp ne i32 %lnot.ext26, 0
  %lnot38 = xor i1 %tobool37, true
  %lnot40 = xor i1 %lnot38, true
  %lnot.ext41 = zext i1 %lnot40 to i32
  %conv42 = sext i32 %lnot.ext41 to i64
  %expval43 = call i64 @llvm.expect.i64(i64 %conv42, i64 0)
  %tobool44 = icmp ne i64 %expval43, 0
  br i1 %tobool44, label %if.then45, label %if.end47

if.then45:                                        ; preds = %if.end36
  store i8 1, i8* @xprt_free_bc_request.__warned, align 1, !tbaa !29
  br label %if.end47

if.end47:                                         ; preds = %if.then45, %if.end36, %do.end
  %rq_bc_pa_state56 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 27
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %rq_bc_pa_state56, i32 1, i64* %rq_bc_pa_state56) #7, !srcloc !1152
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !1153
  %call57 = call i32 @xprt_need_to_requeue(%struct.rpc_xprt* %0)
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.end75, label %do.body60

do.body60:                                        ; preds = %if.end47
  %5 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and61 = and i32 %5, 128
  %tobool62 = icmp ne i32 %and61, 0
  %lnot63 = xor i1 %tobool62, true
  %lnot65 = xor i1 %lnot63, true
  %lnot.ext66 = zext i1 %lnot65 to i32
  %conv67 = sext i32 %lnot.ext66 to i64
  %expval68 = call i64 @llvm.expect.i64(i64 %conv67, i64 0)
  %tobool69 = icmp ne i64 %expval68, 0
  br i1 %tobool69, label %if.then70, label %do.end74

if.then70:                                        ; preds = %do.body60
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end74

do.end74:                                         ; preds = %if.then70, %do.body60
  call void @xprt_free_allocation(%struct.rpc_rqst* %req)
  br label %cleanup.cont

if.end75:                                         ; preds = %if.end47
  %bc_pa_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 36
  call void @spin_lock_bh.1268(%struct.spinlock* %bc_pa_lock)
  %rq_bc_pa_list = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 28
  %bc_pa_list = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 37
  call void @list_add.1283(%struct.list_head* %rq_bc_pa_list, %struct.list_head* %bc_pa_list)
  %bc_pa_lock76 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %0, i32 0, i32 36
  call void @spin_unlock_bh.1270(%struct.spinlock* %bc_pa_lock76)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end75, %do.end74
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_need_to_requeue(%struct.rpc_xprt* %xprt) #2 {
entry:
  %bc_alloc_count = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %0 = load i32, i32* %bc_alloc_count, align 8, !tbaa !1149
  %cmp = icmp ugt i32 %0, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @bc_send(%struct.rpc_rqst* %req) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 512
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %call3 = call %struct.rpc_task* @rpc_run_bc_task(%struct.rpc_rqst* %req, %struct.rpc_call_ops* @nfs41_callback_ops)
  %2 = bitcast %struct.rpc_task* %call3 to i8*
  %call4 = call i64 @IS_ERR.1307(i8* %2)
  %tobool5 = icmp ne i64 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.else

if.then6:                                         ; preds = %do.end
  %3 = bitcast %struct.rpc_task* %call3 to i8*
  %call7 = call i64 @PTR_ERR.1308(i8* %3)
  %conv8 = trunc i64 %call7 to i32
  br label %do.body61

if.else:                                          ; preds = %do.end
  %tk_count = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %call3, i32 0, i32 0
  %call9 = call i32 @atomic_read.1309(%struct.atomic_t* %tk_count)
  %cmp = icmp ne i32 %call9, 1
  %lnot11 = xor i1 %cmp, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %tobool15 = icmp ne i32 %lnot.ext14, 0
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot.ext19 = zext i1 %lnot18 to i32
  %conv20 = sext i32 %lnot.ext19 to i64
  %expval21 = call i64 @llvm.expect.i64(i64 %conv20, i64 0)
  %tobool22 = icmp ne i64 %expval21, 0
  br i1 %tobool22, label %if.then23, label %if.end51

if.then23:                                        ; preds = %if.else
  %4 = load i8, i8* @bc_send.__warned, align 1, !tbaa !29, !range !31
  %tobool24 = trunc i8 %4 to i1
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %tobool31 = icmp ne i32 %lnot.ext30, 0
  %lnot32 = xor i1 %tobool31, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  %conv36 = sext i32 %lnot.ext35 to i64
  %expval37 = call i64 @llvm.expect.i64(i64 %conv36, i64 0)
  %tobool38 = icmp ne i64 %expval37, 0
  br i1 %tobool38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.then23
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.1.1310, i32 0, i32 0), i32 56)
  br label %if.end40

if.end40:                                         ; preds = %if.then39, %if.then23
  %tobool41 = icmp ne i32 %lnot.ext30, 0
  %lnot42 = xor i1 %tobool41, true
  %lnot44 = xor i1 %lnot42, true
  %lnot.ext45 = zext i1 %lnot44 to i32
  %conv46 = sext i32 %lnot.ext45 to i64
  %expval47 = call i64 @llvm.expect.i64(i64 %conv46, i64 0)
  %tobool48 = icmp ne i64 %expval47, 0
  br i1 %tobool48, label %if.then49, label %if.end51

if.then49:                                        ; preds = %if.end40
  store i8 1, i8* @bc_send.__warned, align 1, !tbaa !29
  br label %if.end51

if.end51:                                         ; preds = %if.then49, %if.end40, %if.else
  %tk_status = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %call3, i32 0, i32 16
  %5 = load i32, i32* %tk_status, align 4, !tbaa !59
  call void @rpc_put_task(%struct.rpc_task* %call3)
  br label %do.body61

do.body61:                                        ; preds = %if.end51, %if.then6
  %ret.0 = phi i32 [ %conv8, %if.then6 ], [ %5, %if.end51 ]
  %6 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and62 = and i32 %6, 512
  %tobool63 = icmp ne i32 %and62, 0
  %lnot64 = xor i1 %tobool63, true
  %lnot66 = xor i1 %lnot64, true
  %lnot.ext67 = zext i1 %lnot66 to i32
  %conv68 = sext i32 %lnot.ext67 to i64
  %expval69 = call i64 @llvm.expect.i64(i64 %conv68, i64 0)
  %tobool70 = icmp ne i64 %expval69, 0
  br i1 %tobool70, label %if.then71, label %do.end75

if.then71:                                        ; preds = %do.body61
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end75

do.end75:                                         ; preds = %if.then71, %do.body61
  ret i32 %ret.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR.1307(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR.1308(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read.1309(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !49
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define void @svc_proc_unregister(%struct.net* %net, i8* %name) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.1313(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %proc_net_rpc = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 0
  %2 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_net_rpc, align 8, !tbaa !1009
  call void @remove_proc_entry(i8* %name, %struct.proc_dir_entry* %2)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @net_generic.1313(%struct.net* %net, i32 %id) #2 {
entry:
  call void @rcu_read_lock.1314()
  %gen = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 37
  %0 = load volatile %struct.net_generic*, %struct.net_generic** %gen, align 16, !tbaa !28
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.body8

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @net_generic.__warned.1315, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %do.body8, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_read_lock_held.1316()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %do.body8, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @net_generic.__warned.1315, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 40, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.body8

do.body8:                                         ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  %cmp = icmp eq i32 %id, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.body8
  %len = getelementptr inbounds %struct.net_generic, %struct.net_generic* %0, i32 0, i32 0
  %2 = load i32, i32* %len, align 8, !tbaa !176
  %cmp9 = icmp ugt i32 %id, %2
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %do.body8
  %3 = phi i1 [ true, %do.body8 ], [ %cmp9, %lor.rhs ]
  %lnot = xor i1 %3, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %do.body13, label %do.end21

do.body13:                                        ; preds = %lor.end
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 41, i64 12) #7, !srcloc !1154
  br label %do.body14

do.body14:                                        ; preds = %do.body14, %do.body13
  br label %do.body14

do.end21:                                         ; preds = %lor.end
  %ptr22 = getelementptr inbounds %struct.net_generic, %struct.net_generic* %0, i32 0, i32 2
  %sub = sub nsw i32 %id, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [0 x i8*], [0 x i8*]* %ptr22, i64 0, i64 %idxprom
  %4 = load i8*, i8** %arrayidx, align 8, !tbaa !28
  call void @rcu_read_unlock.1319()
  %tobool24 = icmp ne i8* %4, null
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %expval32 = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool33 = icmp ne i64 %expval32, 0
  br i1 %tobool33, label %do.body35, label %do.end43

do.body35:                                        ; preds = %do.end21
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.23.1317, i32 0, i32 0), i32 45, i64 12) #7, !srcloc !1155
  br label %do.body36

do.body36:                                        ; preds = %do.body36, %do.body35
  br label %do.body36

do.end43:                                         ; preds = %do.end21
  ret i8* %4
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock.1314() #2 {
entry:
  call void @__rcu_read_lock.1326()
  call void @rcu_lock_acquire.1327(%struct.lockdep_map* @rcu_lock_map)
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_lock.__warned.1328, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_lock.__warned.1328, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 780, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.15.1329, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @rcu_read_lock_held.1316() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call1 = call i32 @rcu_is_cpu_idle()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call zeroext i1 @rcu_lockdep_current_cpu_online()
  br i1 %call5, label %if.end7, label %return

if.end7:                                          ; preds = %if.end4
  %call8 = call i32 @lock_is_held(%struct.lockdep_map* @rcu_lock_map)
  br label %return

return:                                           ; preds = %if.end7, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call8, %if.end7 ], [ 1, %entry ], [ 0, %if.end ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_unlock.1319() #2 {
entry:
  %call = call i32 @debug_lockdep_rcu_enabled()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @rcu_read_unlock.__warned.1320, align 1, !tbaa !29, !range !31
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %do.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %call3 = call i32 @rcu_is_cpu_idle()
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %do.end

if.then:                                          ; preds = %land.lhs.true2
  store i8 1, i8* @rcu_read_unlock.__warned.1320, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14.1321, i32 0, i32 0), i32 801, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.16.1322, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  call void @rcu_lock_release.1323(%struct.lockdep_map* @rcu_lock_map)
  call void @__rcu_read_unlock.1324()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_release.1323(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_release(%struct.lockdep_map* %map, i32 1, i64 ptrtoint (i8* blockaddress(@rcu_lock_release.1323, %__here) to i64))
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_unlock.1324() #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !1156
  %call = call %struct.thread_info* @current_thread_info.1325()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %sub = sub nsw i32 %0, 1
  store i32 %sub, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !1157
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.1325() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !1158
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_lock.1326() #2 {
entry:
  %call = call %struct.thread_info* @current_thread_info.1325()
  %preempt_count = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 5
  %0 = load i32, i32* %preempt_count, align 4, !tbaa !127
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %preempt_count, align 4, !tbaa !127
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !1159
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_lock_acquire.1327(%struct.lockdep_map* %map) #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @lock_acquire(%struct.lockdep_map* %map, i32 0, i32 0, i32 2, i32 1, %struct.lockdep_map* null, i64 ptrtoint (i8* blockaddress(@rcu_lock_acquire.1327, %__here) to i64))
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.proc_dir_entry* @svc_proc_register(%struct.net* %net, %struct.svc_stat* %statp, %struct.file_operations* %fops) #0 {
entry:
  %program = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %statp, i32 0, i32 0
  %0 = load %struct.svc_program*, %struct.svc_program** %program, align 8, !tbaa !1160
  %pg_name = getelementptr inbounds %struct.svc_program, %struct.svc_program* %0, i32 0, i32 6
  %1 = load i8*, i8** %pg_name, align 8, !tbaa !685
  %2 = bitcast %struct.svc_stat* %statp to i8*
  %call = call %struct.proc_dir_entry* @do_register(%struct.net* %net, i8* %1, i8* %2, %struct.file_operations* %fops)
  ret %struct.proc_dir_entry* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.proc_dir_entry* @do_register(%struct.net* %net, i8* %name, i8* %data, %struct.file_operations* %fops) #2 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 1024
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %2 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call3 = call i8* @net_generic.1313(%struct.net* %net, i32 %2)
  %3 = bitcast i8* %call3 to %struct.sunrpc_net*
  %proc_net_rpc = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %3, i32 0, i32 0
  %4 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_net_rpc, align 8, !tbaa !1009
  %call4 = call %struct.proc_dir_entry* @proc_create_data(i8* %name, i16 zeroext 0, %struct.proc_dir_entry* %4, %struct.file_operations* %fops, i8* %data)
  ret %struct.proc_dir_entry* %call4
}

; Function Attrs: nounwind uwtable
define void @rpc_proc_unregister(%struct.net* %net, i8* %name) #0 {
entry:
  %0 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call = call i8* @net_generic.1313(%struct.net* %net, i32 %0)
  %1 = bitcast i8* %call to %struct.sunrpc_net*
  %proc_net_rpc = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %1, i32 0, i32 0
  %2 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_net_rpc, align 8, !tbaa !1009
  call void @remove_proc_entry(i8* %name, %struct.proc_dir_entry* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.proc_dir_entry* @rpc_proc_register(%struct.net* %net, %struct.rpc_stat* %statp) #0 {
entry:
  %program = getelementptr inbounds %struct.rpc_stat, %struct.rpc_stat* %statp, i32 0, i32 0
  %0 = load %struct.rpc_program*, %struct.rpc_program** %program, align 8, !tbaa !1161
  %name = getelementptr inbounds %struct.rpc_program, %struct.rpc_program* %0, i32 0, i32 0
  %1 = load i8*, i8** %name, align 8, !tbaa !232
  %2 = bitcast %struct.rpc_stat* %statp to i8*
  %call = call %struct.proc_dir_entry* @do_register(%struct.net* %net, i8* %1, i8* %2, %struct.file_operations* @rpc_proc_fops)
  ret %struct.proc_dir_entry* %call
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_proc_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %call1 = call i32 @single_open(%struct.file* %file, i32 (%struct.seq_file*, i8*)* @rpc_proc_show, i8* %call)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @rpc_proc_show(%struct.seq_file* %seq, i8* %v) #0 {
entry:
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %seq, i32 0, i32 10
  %0 = load i8*, i8** %private, align 8, !tbaa !980
  %1 = bitcast i8* %0 to %struct.rpc_stat*
  %program = getelementptr inbounds %struct.rpc_stat, %struct.rpc_stat* %1, i32 0, i32 0
  %2 = load %struct.rpc_program*, %struct.rpc_program** %program, align 8, !tbaa !1161
  %netcnt = getelementptr inbounds %struct.rpc_stat, %struct.rpc_stat* %1, i32 0, i32 1
  %3 = load i32, i32* %netcnt, align 8, !tbaa !1162
  %netudpcnt = getelementptr inbounds %struct.rpc_stat, %struct.rpc_stat* %1, i32 0, i32 2
  %4 = load i32, i32* %netudpcnt, align 4, !tbaa !1163
  %nettcpcnt = getelementptr inbounds %struct.rpc_stat, %struct.rpc_stat* %1, i32 0, i32 3
  %5 = load i32, i32* %nettcpcnt, align 8, !tbaa !1164
  %nettcpconn = getelementptr inbounds %struct.rpc_stat, %struct.rpc_stat* %1, i32 0, i32 4
  %6 = load i32, i32* %nettcpconn, align 4, !tbaa !1165
  %call = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1331, i32 0, i32 0), i32 %3, i32 %4, i32 %5, i32 %6)
  %rpccnt = getelementptr inbounds %struct.rpc_stat, %struct.rpc_stat* %1, i32 0, i32 6
  %7 = load i32, i32* %rpccnt, align 4, !tbaa !56
  %rpcretrans = getelementptr inbounds %struct.rpc_stat, %struct.rpc_stat* %1, i32 0, i32 7
  %8 = load i32, i32* %rpcretrans, align 8, !tbaa !124
  %rpcauthrefresh = getelementptr inbounds %struct.rpc_stat, %struct.rpc_stat* %1, i32 0, i32 8
  %9 = load i32, i32* %rpcauthrefresh, align 4, !tbaa !61
  %call1 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.21.1332, i32 0, i32 0), i32 %7, i32 %8, i32 %9)
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc12, %LeafBlock ]
  %nrvers = getelementptr inbounds %struct.rpc_program, %struct.rpc_program* %2, i32 0, i32 2
  %10 = load i32, i32* %nrvers, align 4, !tbaa !223
  %cmp = icmp ult i32 %i.0, %10
  br i1 %cmp, label %for.body, label %for.end13

for.body:                                         ; preds = %for.cond
  %version = getelementptr inbounds %struct.rpc_program, %struct.rpc_program* %2, i32 0, i32 3
  %11 = load %struct.rpc_version**, %struct.rpc_version*** %version, align 8, !tbaa !224
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.rpc_version*, %struct.rpc_version** %11, i64 %idxprom
  %12 = load %struct.rpc_version*, %struct.rpc_version** %arrayidx, align 8, !tbaa !28
  %tobool = icmp ne %struct.rpc_version* %12, null
  br i1 %tobool, label %if.end, label %LeafBlock

if.end:                                           ; preds = %for.body
  %number = getelementptr inbounds %struct.rpc_version, %struct.rpc_version* %12, i32 0, i32 0
  %13 = load i32, i32* %number, align 8, !tbaa !234
  %nrprocs = getelementptr inbounds %struct.rpc_version, %struct.rpc_version* %12, i32 0, i32 1
  %14 = load i32, i32* %nrprocs, align 4, !tbaa !230
  %call2 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.22.1333, i32 0, i32 0), i32 %13, i32 %14)
  br label %for.cond3

for.cond3:                                        ; preds = %for.body6, %if.end
  %j.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body6 ]
  %nrprocs4 = getelementptr inbounds %struct.rpc_version, %struct.rpc_version* %12, i32 0, i32 1
  %15 = load i32, i32* %nrprocs4, align 4, !tbaa !230
  %cmp5 = icmp ult i32 %j.0, %15
  br i1 %cmp5, label %for.body6, label %for.end

for.body6:                                        ; preds = %for.cond3
  %procs = getelementptr inbounds %struct.rpc_version, %struct.rpc_version* %12, i32 0, i32 2
  %16 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %procs, align 8, !tbaa !227
  %idxprom7 = zext i32 %j.0 to i64
  %arrayidx8 = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %16, i64 %idxprom7
  %p_count = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %arrayidx8, i32 0, i32 5
  %17 = load i32, i32* %p_count, align 8, !tbaa !50
  %call9 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.3.1334, i32 0, i32 0), i32 %17)
  %inc = add i32 %j.0, 1
  br label %for.cond3

for.end:                                          ; preds = %for.cond3
  %call10 = call i32 @seq_putc(%struct.seq_file* %seq, i8 signext 10)
  br label %LeafBlock

LeafBlock:                                        ; preds = %for.end, %for.body
  %inc12 = add i32 %i.0, 1
  br label %for.cond

for.end13:                                        ; preds = %for.cond
  ret i32 0
}

declare i32 @seq_putc(%struct.seq_file*, i8 signext) #4

; Function Attrs: nounwind uwtable
define void @rpc_print_iostats(%struct.seq_file* %seq, %struct.rpc_clnt* %clnt) #0 {
entry:
  %cl_metrics = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 12
  %0 = load %struct.rpc_iostats*, %struct.rpc_iostats** %cl_metrics, align 8, !tbaa !169
  %cl_maxproc = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 8
  %1 = load i32, i32* %cl_maxproc, align 8, !tbaa !231
  %tobool = icmp ne %struct.rpc_iostats* %0, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %call = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.4.1335, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.1336, i32 0, i32 0))
  %cl_prog = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 6
  %2 = load i32, i32* %cl_prog, align 8, !tbaa !155
  %cl_vers = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 7
  %3 = load i32, i32* %cl_vers, align 4, !tbaa !156
  %cl_protname = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 9
  %4 = load i8*, i8** %cl_protname, align 8, !tbaa !233
  %call1 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.6.1337, i32 0, i32 0), i32 %2, i32 %3, i8* %4)
  call void @rcu_read_lock.1314()
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 4
  %5 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !28
  %call2 = call i32 @debug_lockdep_rcu_enabled()
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %land.lhs.true, label %do.end12

land.lhs.true:                                    ; preds = %if.end
  %6 = load i8, i8* @rpc_print_iostats.__warned, align 1, !tbaa !29, !range !31
  %tobool4 = trunc i8 %6 to i1
  br i1 %tobool4, label %do.end12, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call6 = call i32 @rcu_read_lock_held.1316()
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %do.end12, label %if.then8

if.then8:                                         ; preds = %land.lhs.true5
  store i8 1, i8* @rpc_print_iostats.__warned, align 1, !tbaa !29
  call void @lockdep_rcu_suspicious(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.7.1338, i32 0, i32 0), i32 194, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.8.1318, i32 0, i32 0))
  br label %do.end12

do.end12:                                         ; preds = %if.then8, %land.lhs.true5, %land.lhs.true, %if.end
  %tobool13 = icmp ne %struct.rpc_xprt* %5, null
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %do.end12
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %5, i32 0, i32 1
  %7 = load %struct.rpc_xprt_ops*, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !81
  %print_stats = getelementptr inbounds %struct.rpc_xprt_ops, %struct.rpc_xprt_ops* %7, i32 0, i32 15
  %8 = load void (%struct.rpc_xprt*, %struct.seq_file*)*, void (%struct.rpc_xprt*, %struct.seq_file*)** %print_stats, align 8, !tbaa !1166
  call void %8(%struct.rpc_xprt* %5, %struct.seq_file* %seq)
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %do.end12
  call void @rcu_read_unlock.1319()
  %call16 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.9.1339, i32 0, i32 0))
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end15
  %op.0 = phi i32 [ 0, %if.end15 ], [ %inc, %for.body ]
  %cmp = icmp ult i32 %op.0, %1
  br i1 %cmp, label %for.body, label %cleanup.cont

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %op.0 to i64
  %arrayidx = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %0, i64 %idxprom
  %cl_procinfo = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 5
  %9 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %cl_procinfo, align 8, !tbaa !229
  call void @_print_name(%struct.seq_file* %seq, i32 %op.0, %struct.rpc_procinfo* %9)
  %om_ops = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 0
  %10 = load i64, i64* %om_ops, align 64, !tbaa !1167
  %om_ntrans = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 1
  %11 = load i64, i64* %om_ntrans, align 8, !tbaa !1169
  %om_timeouts = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 2
  %12 = load i64, i64* %om_timeouts, align 16, !tbaa !1170
  %om_bytes_sent = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 3
  %13 = load i64, i64* %om_bytes_sent, align 8, !tbaa !1171
  %om_bytes_recv = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 4
  %14 = load i64, i64* %om_bytes_recv, align 32, !tbaa !1172
  %om_queue = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 5
  %coerce.dive = getelementptr inbounds %struct.pgprot, %struct.pgprot* %om_queue, i32 0, i32 0
  %15 = load i64, i64* %coerce.dive, align 8
  %call17 = call i64 @ktime_to_ms(i64 %15)
  %om_rtt = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 6
  %coerce.dive18 = getelementptr inbounds %struct.pgprot, %struct.pgprot* %om_rtt, i32 0, i32 0
  %16 = load i64, i64* %coerce.dive18, align 16
  %call19 = call i64 @ktime_to_ms(i64 %16)
  %om_execute = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 7
  %coerce.dive20 = getelementptr inbounds %struct.pgprot, %struct.pgprot* %om_execute, i32 0, i32 0
  %17 = load i64, i64* %coerce.dive20, align 8
  %call21 = call i64 @ktime_to_ms(i64 %17)
  %call22 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.10.1340, i32 0, i32 0), i64 %10, i64 %11, i64 %12, i64 %13, i64 %14, i64 %call17, i64 %call19, i64 %call21)
  %inc = add i32 %op.0, 1
  br label %for.cond

cleanup.cont:                                     ; preds = %for.cond, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @_print_name(%struct.seq_file* %seq, i32 %op, %struct.rpc_procinfo* %procs) #0 {
entry:
  %idxprom = zext i32 %op to i64
  %arrayidx = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %procs, i64 %idxprom
  %p_name = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %arrayidx, i32 0, i32 8
  %0 = load i8*, i8** %p_name, align 8, !tbaa !58
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %idxprom1 = zext i32 %op to i64
  %arrayidx2 = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %procs, i64 %idxprom1
  %p_name3 = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %arrayidx2, i32 0, i32 8
  %1 = load i8*, i8** %p_name3, align 8, !tbaa !58
  %call = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.17.1341, i32 0, i32 0), i8* %1)
  br label %if.end8

if.else:                                          ; preds = %entry
  %cmp = icmp eq i32 %op, 0
  br i1 %cmp, label %if.then4, label %if.else6

if.then4:                                         ; preds = %if.else
  %call5 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.18.1342, i32 0, i32 0))
  br label %if.end8

if.else6:                                         ; preds = %if.else
  %call7 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.19.1343, i32 0, i32 0), i32 %op)
  br label %if.end8

if.end8:                                          ; preds = %if.else6, %if.then4, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @ktime_to_ms(i64 %kt.coerce) #2 {
entry:
  %kt = alloca %struct.pgprot, align 8
  %tv = alloca %struct.load_weight, align 8
  %coerce.dive = getelementptr inbounds %struct.pgprot, %struct.pgprot* %kt, i32 0, i32 0
  store i64 %kt.coerce, i64* %coerce.dive, align 8
  %tv64 = bitcast %struct.pgprot* %kt to i64*
  %0 = load i64, i64* %tv64, align 8, !tbaa !166
  %call = call { i64, i64 } @ns_to_timeval(i64 %0)
  %1 = bitcast %struct.load_weight* %tv to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = extractvalue { i64, i64 } %call, 0
  store i64 %3, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = extractvalue { i64, i64 } %call, 1
  store i64 %5, i64* %4, align 8
  %tv_sec = getelementptr inbounds %struct.load_weight, %struct.load_weight* %tv, i32 0, i32 0
  %6 = load i64, i64* %tv_sec, align 8, !tbaa !296
  %mul = mul nsw i64 %6, 1000
  %tv_usec = getelementptr inbounds %struct.load_weight, %struct.load_weight* %tv, i32 0, i32 1
  %7 = load i64, i64* %tv_usec, align 8, !tbaa !298
  %div = sdiv i64 %7, 1000
  %add = add nsw i64 %mul, %div
  ret i64 %add
}

; Function Attrs: nounwind uwtable
define void @rpc_count_iostats(%struct.rpc_task* %task, %struct.rpc_iostats* %stats) #0 {
entry:
  %delta = alloca %struct.pgprot, align 8
  %.compoundliteral = alloca %struct.pgprot, align 8
  %.compoundliteral8 = alloca %struct.pgprot, align 8
  %.compoundliteral14 = alloca %struct.pgprot, align 8
  %.compoundliteral20 = alloca %struct.pgprot, align 8
  %coerce = alloca %struct.pgprot, align 8
  %.compoundliteral26 = alloca %struct.pgprot, align 8
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !60
  %tobool = icmp ne %struct.rpc_iostats* %stats, null
  %tobool1 = icmp ne %struct.rpc_rqst* %0, null
  %or.cond = and i1 %tobool, %tobool1
  br i1 %or.cond, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %tk_msg = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 4
  %rpc_proc = getelementptr inbounds %struct.rpc_message, %struct.rpc_message* %tk_msg, i32 0, i32 0
  %1 = load %struct.rpc_procinfo*, %struct.rpc_procinfo** %rpc_proc, align 8, !tbaa !44
  %p_statidx = getelementptr inbounds %struct.rpc_procinfo, %struct.rpc_procinfo* %1, i32 0, i32 7
  %2 = load i32, i32* %p_statidx, align 8, !tbaa !1173
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %stats, i64 %idxprom
  %om_ops = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 0
  %3 = load i64, i64* %om_ops, align 64, !tbaa !1167
  %inc = add i64 %3, 1
  store i64 %inc, i64* %om_ops, align 64, !tbaa !1167
  %rq_ntrans = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 25
  %4 = load i32, i32* %rq_ntrans, align 8, !tbaa !295
  %conv = sext i32 %4 to i64
  %om_ntrans = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 1
  %5 = load i64, i64* %om_ntrans, align 8, !tbaa !1169
  %add = add i64 %5, %conv
  store i64 %add, i64* %om_ntrans, align 8, !tbaa !1169
  %tk_timeouts = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 18
  %6 = load i16, i16* %tk_timeouts, align 2, !tbaa !123
  %conv2 = zext i16 %6 to i64
  %om_timeouts = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 2
  %7 = load i64, i64* %om_timeouts, align 16, !tbaa !1170
  %add3 = add i64 %7, %conv2
  store i64 %add3, i64* %om_timeouts, align 16, !tbaa !1170
  %rq_xmit_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 15
  %8 = load i64, i64* %rq_xmit_bytes_sent, align 8, !tbaa !447
  %om_bytes_sent = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 3
  %9 = load i64, i64* %om_bytes_sent, align 8, !tbaa !1171
  %add4 = add i64 %9, %8
  store i64 %add4, i64* %om_bytes_sent, align 8, !tbaa !1171
  %rq_reply_bytes_recvd = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 16
  %10 = load i64, i64* %rq_reply_bytes_recvd, align 8, !tbaa !142
  %om_bytes_recv = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 4
  %11 = load i64, i64* %om_bytes_recv, align 32, !tbaa !1172
  %add5 = add i64 %11, %10
  store i64 %add5, i64* %om_bytes_recv, align 32, !tbaa !1172
  %tv64 = bitcast %struct.pgprot* %.compoundliteral to i64*
  %rq_xtime = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 24
  %tv646 = bitcast %struct.pgprot* %rq_xtime to i64*
  %12 = load i64, i64* %tv646, align 8, !tbaa !166
  %tk_start = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 14
  %tv647 = bitcast %struct.pgprot* %tk_start to i64*
  %13 = load i64, i64* %tv647, align 8, !tbaa !166
  %sub = sub nsw i64 %12, %13
  store i64 %sub, i64* %tv64, align 8, !tbaa !166
  %14 = bitcast %struct.pgprot* %delta to i8*
  %15 = bitcast %struct.pgprot* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %15, i64 8, i32 8, i1 false), !tbaa.struct !290
  %om_queue = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 5
  %tv649 = bitcast %struct.pgprot* %.compoundliteral8 to i64*
  %om_queue10 = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 5
  %tv6411 = bitcast %struct.pgprot* %om_queue10 to i64*
  %16 = load i64, i64* %tv6411, align 8, !tbaa !166
  %tv6412 = bitcast %struct.pgprot* %delta to i64*
  %17 = load i64, i64* %tv6412, align 8, !tbaa !166
  %add13 = add nsw i64 %16, %17
  store i64 %add13, i64* %tv649, align 8, !tbaa !166
  %18 = bitcast %struct.pgprot* %om_queue to i8*
  %19 = bitcast %struct.pgprot* %.compoundliteral8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %18, i8* %19, i64 8, i32 8, i1 false), !tbaa.struct !290
  %om_rtt = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 6
  %tv6415 = bitcast %struct.pgprot* %.compoundliteral14 to i64*
  %om_rtt16 = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 6
  %tv6417 = bitcast %struct.pgprot* %om_rtt16 to i64*
  %20 = load i64, i64* %tv6417, align 16, !tbaa !166
  %rq_rtt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 20
  %tv6418 = bitcast %struct.pgprot* %rq_rtt to i64*
  %21 = load i64, i64* %tv6418, align 8, !tbaa !166
  %add19 = add nsw i64 %20, %21
  store i64 %add19, i64* %tv6415, align 8, !tbaa !166
  %22 = bitcast %struct.pgprot* %om_rtt to i8*
  %23 = bitcast %struct.pgprot* %.compoundliteral14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %22, i8* %23, i64 8, i32 8, i1 false), !tbaa.struct !290
  %tv6421 = bitcast %struct.pgprot* %.compoundliteral20 to i64*
  %call = call i64 @ktime_get()
  %coerce.dive = getelementptr inbounds %struct.pgprot, %struct.pgprot* %coerce, i32 0, i32 0
  store i64 %call, i64* %coerce.dive, align 8
  %tv6422 = bitcast %struct.pgprot* %coerce to i64*
  %24 = load i64, i64* %tv6422, align 8, !tbaa !166
  %tk_start23 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 14
  %tv6424 = bitcast %struct.pgprot* %tk_start23 to i64*
  %25 = load i64, i64* %tv6424, align 8, !tbaa !166
  %sub25 = sub nsw i64 %24, %25
  store i64 %sub25, i64* %tv6421, align 8, !tbaa !166
  %26 = bitcast %struct.pgprot* %delta to i8*
  %27 = bitcast %struct.pgprot* %.compoundliteral20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %26, i8* %27, i64 8, i32 8, i1 false), !tbaa.struct !290
  %om_execute = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 7
  %tv6427 = bitcast %struct.pgprot* %.compoundliteral26 to i64*
  %om_execute28 = getelementptr inbounds %struct.rpc_iostats, %struct.rpc_iostats* %arrayidx, i32 0, i32 7
  %tv6429 = bitcast %struct.pgprot* %om_execute28 to i64*
  %28 = load i64, i64* %tv6429, align 8, !tbaa !166
  %tv6430 = bitcast %struct.pgprot* %delta to i64*
  %29 = load i64, i64* %tv6430, align 8, !tbaa !166
  %add31 = add nsw i64 %28, %29
  store i64 %add31, i64* %tv6427, align 8, !tbaa !166
  %30 = bitcast %struct.pgprot* %om_execute to i8*
  %31 = bitcast %struct.pgprot* %.compoundliteral26 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %30, i8* %31, i64 8, i32 8, i1 false), !tbaa.struct !290
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_free_iostats(%struct.rpc_iostats* %stats) #0 {
entry:
  %0 = bitcast %struct.rpc_iostats* %stats to i8*
  call void @kfree(i8* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.rpc_iostats* @rpc_alloc_iostats(%struct.rpc_clnt* %clnt) #0 {
entry:
  %cl_maxproc = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %clnt, i32 0, i32 8
  %0 = load i32, i32* %cl_maxproc, align 8, !tbaa !231
  %conv = zext i32 %0 to i64
  %call = call i8* @kcalloc.1350(i64 %conv, i64 64, i32 208)
  %1 = bitcast i8* %call to %struct.rpc_iostats*
  ret %struct.rpc_iostats* %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kcalloc.1350(i64 %n, i64 %size, i32 %flags) #2 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc_array.1351(i64 %n, i64 %size, i32 %or)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kmalloc_array.1351(i64 %n, i64 %size, i32 %flags) #2 {
entry:
  %cmp = icmp ne i64 %size, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %div = udiv i64 -1, %size
  %cmp1 = icmp ugt i64 %n, %div
  br i1 %cmp1, label %return, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %mul = mul i64 %n, %size
  %call = call i8* @__kmalloc(i64 %mul, i32 %flags)
  br label %return

return:                                           ; preds = %if.end, %land.lhs.true
  %retval.0 = phi i8* [ %call, %if.end ], [ null, %land.lhs.true ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define void @svc_seq_show(%struct.seq_file* %seq, %struct.svc_stat* %statp) #0 {
entry:
  %program = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %statp, i32 0, i32 0
  %0 = load %struct.svc_program*, %struct.svc_program** %program, align 8, !tbaa !1160
  %netcnt = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %statp, i32 0, i32 1
  %1 = load i32, i32* %netcnt, align 8, !tbaa !1119
  %netudpcnt = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %statp, i32 0, i32 2
  %2 = load i32, i32* %netudpcnt, align 4, !tbaa !784
  %nettcpcnt = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %statp, i32 0, i32 3
  %3 = load i32, i32* %nettcpcnt, align 8, !tbaa !763
  %nettcpconn = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %statp, i32 0, i32 4
  %4 = load i32, i32* %nettcpconn, align 4, !tbaa !758
  %call = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1331, i32 0, i32 0), i32 %1, i32 %2, i32 %3, i32 %4)
  %rpccnt = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %statp, i32 0, i32 5
  %5 = load i32, i32* %rpccnt, align 8, !tbaa !671
  %rpcbadfmt = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %statp, i32 0, i32 6
  %6 = load i32, i32* %rpcbadfmt, align 4, !tbaa !683
  %rpcbadauth = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %statp, i32 0, i32 7
  %7 = load i32, i32* %rpcbadauth, align 8, !tbaa !684
  %add = add i32 %6, %7
  %rpcbadclnt = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %statp, i32 0, i32 8
  %8 = load i32, i32* %rpcbadclnt, align 4, !tbaa !1174
  %add1 = add i32 %add, %8
  %rpcbadfmt2 = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %statp, i32 0, i32 6
  %9 = load i32, i32* %rpcbadfmt2, align 4, !tbaa !683
  %rpcbadauth3 = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %statp, i32 0, i32 7
  %10 = load i32, i32* %rpcbadauth3, align 8, !tbaa !684
  %rpcbadclnt4 = getelementptr inbounds %struct.svc_stat, %struct.svc_stat* %statp, i32 0, i32 8
  %11 = load i32, i32* %rpcbadclnt4, align 4, !tbaa !1174
  %call5 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.1.1352, i32 0, i32 0), i32 %5, i32 %add1, i32 %9, i32 %10, i32 %11)
  br label %for.cond

for.cond:                                         ; preds = %for.inc14, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc15, %for.inc14 ]
  %pg_nvers = getelementptr inbounds %struct.svc_program, %struct.svc_program* %0, i32 0, i32 4
  %12 = load i32, i32* %pg_nvers, align 4, !tbaa !662
  %cmp = icmp ult i32 %i.0, %12
  br i1 %cmp, label %for.body, label %for.end16

for.body:                                         ; preds = %for.cond
  %pg_vers = getelementptr inbounds %struct.svc_program, %struct.svc_program* %0, i32 0, i32 5
  %13 = load %struct.svc_version**, %struct.svc_version*** %pg_vers, align 8, !tbaa !663
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.svc_version*, %struct.svc_version** %13, i64 %idxprom
  %14 = load %struct.svc_version*, %struct.svc_version** %arrayidx, align 8, !tbaa !28
  %tobool = icmp ne %struct.svc_version* %14, null
  br i1 %tobool, label %lor.lhs.false, label %for.inc14

lor.lhs.false:                                    ; preds = %for.body
  %vs_proc = getelementptr inbounds %struct.svc_version, %struct.svc_version* %14, i32 0, i32 2
  %15 = load %struct.svc_procedure*, %struct.svc_procedure** %vs_proc, align 8, !tbaa !664
  %tobool6 = icmp ne %struct.svc_procedure* %15, null
  br i1 %tobool6, label %if.end, label %for.inc14

if.end:                                           ; preds = %lor.lhs.false
  %vs_nproc = getelementptr inbounds %struct.svc_version, %struct.svc_version* %14, i32 0, i32 1
  %16 = load i32, i32* %vs_nproc, align 4, !tbaa !666
  %call7 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2.1353, i32 0, i32 0), i32 %i.0, i32 %16)
  br label %for.cond8

for.cond8:                                        ; preds = %for.body11, %if.end
  %proc.0 = phi %struct.svc_procedure* [ %15, %if.end ], [ %incdec.ptr, %for.body11 ]
  %j.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body11 ]
  %vs_nproc9 = getelementptr inbounds %struct.svc_version, %struct.svc_version* %14, i32 0, i32 1
  %17 = load i32, i32* %vs_nproc9, align 4, !tbaa !666
  %cmp10 = icmp ult i32 %j.0, %17
  br i1 %cmp10, label %for.body11, label %for.end

for.body11:                                       ; preds = %for.cond8
  %pc_count = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %proc.0, i32 0, i32 6
  %18 = load i32, i32* %pc_count, align 8, !tbaa !673
  %call12 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.3.1334, i32 0, i32 0), i32 %18)
  %inc = add i32 %j.0, 1
  %incdec.ptr = getelementptr inbounds %struct.svc_procedure, %struct.svc_procedure* %proc.0, i32 1
  br label %for.cond8

for.end:                                          ; preds = %for.cond8
  %call13 = call i32 @seq_putc(%struct.seq_file* %seq, i8 signext 10)
  br label %for.inc14

for.inc14:                                        ; preds = %for.end, %lor.lhs.false, %for.body
  %inc15 = add i32 %i.0, 1
  br label %for.cond

for.end16:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @rpc_proc_init(%struct.net* %net) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 1024
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %2 = load i32, i32* @sunrpc_net_id, align 4, !tbaa !49
  %call3 = call i8* @net_generic.1313(%struct.net* %net, i32 %2)
  %3 = bitcast i8* %call3 to %struct.sunrpc_net*
  %proc_net = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 8
  %4 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_net, align 16, !tbaa !1175
  %call4 = call %struct.proc_dir_entry* @proc_mkdir(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12.1357, i32 0, i32 0), %struct.proc_dir_entry* %4)
  %proc_net_rpc = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %3, i32 0, i32 0
  store %struct.proc_dir_entry* %call4, %struct.proc_dir_entry** %proc_net_rpc, align 8, !tbaa !1009
  %proc_net_rpc5 = getelementptr inbounds %struct.sunrpc_net, %struct.sunrpc_net* %3, i32 0, i32 0
  %5 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_net_rpc5, align 8, !tbaa !1009
  %cmp = icmp eq %struct.proc_dir_entry* %5, null
  %. = select i1 %cmp, i32 -12, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define void @rpc_proc_exit(%struct.net* %net) #0 {
entry:
  %0 = load i32, i32* @rpc_debug, align 4, !tbaa !49
  %and = and i32 %0, 1024
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %proc_net = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 8
  %2 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_net, align 16, !tbaa !1175
  call void @remove_proc_entry(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12.1357, i32 0, i32 0), %struct.proc_dir_entry* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define void @rpc_register_sysctl() #0 {
entry:
  %0 = load %struct.ctl_table_header*, %struct.ctl_table_header** @sunrpc_table_header.1366, align 8, !tbaa !28
  %tobool = icmp ne %struct.ctl_table_header* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call %struct.ctl_table_header* @register_sysctl_table(%struct.ctl_table* getelementptr inbounds ([2 x %struct.ctl_table], [2 x %struct.ctl_table]* @sunrpc_table.1367, i32 0, i32 0))
  store %struct.ctl_table_header* %call, %struct.ctl_table_header** @sunrpc_table_header.1366, align 8, !tbaa !28
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_dodebug(%struct.ctl_table* %table, i32 %write, i8* %buffer, i64* %lenp, i64* %ppos) #0 {
entry:
  %tmpbuf = alloca [20 x i8], align 16
  %0 = load i64, i64* %ppos, align 8, !tbaa !291
  %tobool = icmp eq i64 %0, 0
  %tobool1 = icmp ne i32 %write, 0
  %or.cond = or i1 %tobool, %tobool1
  br i1 %or.cond, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, i64* %lenp, align 8, !tbaa !88
  %tobool2 = icmp ne i64 %1, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i64 0, i64* %lenp, align 8, !tbaa !88
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i64, i64* %lenp, align 8, !tbaa !88
  %tobool3 = icmp ne i32 %write, 0
  %call = call %struct.thread_info* @current_thread_info.1374()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 6
  %seg = getelementptr inbounds %struct.pgprot, %struct.pgprot* %addr_limit, i32 0, i32 0
  %3 = load i64, i64* %seg, align 8, !tbaa !1204
  %4 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(i8* %buffer, i64 %2, i64 %3) #9
  %asmresult = extractvalue { i64, i64 } %4, 0
  %cmp = icmp eq i64 %asmresult, 0
  %lnot = xor i1 %cmp, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  br i1 %tobool7, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.then4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end9
  %p.0 = phi i8* [ %buffer, %if.end9 ], [ %incdec.ptr, %while.body ]
  %left.0 = phi i64 [ %2, %if.end9 ], [ %dec, %while.body ]
  %cond = icmp eq i64 %left.0, 0
  br i1 %cond, label %done, label %do.body

do.body:                                          ; preds = %while.cond
  %5 = bitcast i8* %p.0 to %struct.__large_struct*
  %6 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movb $2,${1:b}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorb ${1:b},${1:b}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=q,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %5, i32 -14, i32 0) #7, !srcloc !1205
  %asmresult12 = extractvalue { i32, i64 } %6, 0
  %asmresult13 = extractvalue { i32, i64 } %6, 1
  %conv14 = trunc i64 %asmresult13 to i8
  %cmp16 = icmp sge i32 %asmresult12, 0
  br i1 %cmp16, label %land.rhs, label %while.end

land.rhs:                                         ; preds = %do.body
  %conv18 = zext i8 %conv14 to i32
  %idxprom = sext i32 %conv18 to i64
  %arrayidx = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom
  %7 = load i8, i8* %arrayidx, align 1, !tbaa !166
  %conv19 = zext i8 %7 to i32
  %and = and i32 %conv19, 32
  %cmp20 = icmp ne i32 %and, 0
  br i1 %cmp20, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  %dec = add i64 %left.0, -1
  %incdec.ptr = getelementptr inbounds i8, i8* %p.0, i32 1
  br label %while.cond

while.end:                                        ; preds = %land.rhs, %do.body
  %tobool22 = icmp ne i64 %left.0, 0
  br i1 %tobool22, label %if.end24, label %done

if.end24:                                         ; preds = %while.end
  %cmp25 = icmp ugt i64 %left.0, 19
  br i1 %cmp25, label %cleanup, label %if.end28

if.end28:                                         ; preds = %if.end24
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %tmpbuf, i32 0, i32 0
  %call29 = call i64 @copy_from_user.1375(i8* %arraydecay, i8* %p.0, i64 %left.0)
  %tobool30 = icmp ne i64 %call29, 0
  br i1 %tobool30, label %cleanup, label %if.end32

if.end32:                                         ; preds = %if.end28
  %arrayidx33 = getelementptr inbounds [20 x i8], [20 x i8]* %tmpbuf, i64 0, i64 %left.0
  store i8 0, i8* %arrayidx33, align 1, !tbaa !166
  %arraydecay34 = getelementptr inbounds [20 x i8], [20 x i8]* %tmpbuf, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end32
  %s.0 = phi i8* [ %arraydecay34, %if.end32 ], [ %incdec.ptr44, %for.body ]
  %value.0 = phi i32 [ 0, %if.end32 ], [ %add, %for.body ]
  %left.1 = phi i64 [ %left.0, %if.end32 ], [ %dec45, %for.body ]
  %8 = load i8, i8* %s.0, align 1, !tbaa !166
  %conv35 = sext i8 %8 to i32
  %cmp36 = icmp sle i32 48, %conv35
  br i1 %cmp36, label %land.rhs38, label %for.end

land.rhs38:                                       ; preds = %for.cond
  %9 = load i8, i8* %s.0, align 1, !tbaa !166
  %conv39 = sext i8 %9 to i32
  %cmp40 = icmp sle i32 %conv39, 57
  br i1 %cmp40, label %for.body, label %for.end

for.body:                                         ; preds = %land.rhs38
  %mul = mul i32 10, %value.0
  %10 = load i8, i8* %s.0, align 1, !tbaa !166
  %conv43 = sext i8 %10 to i32
  %sub = sub nsw i32 %conv43, 48
  %add = add i32 %mul, %sub
  %incdec.ptr44 = getelementptr inbounds i8, i8* %s.0, i32 1
  %dec45 = add i64 %left.1, -1
  br label %for.cond

for.end:                                          ; preds = %land.rhs38, %for.cond
  %11 = load i8, i8* %s.0, align 1, !tbaa !166
  %conv46 = sext i8 %11 to i32
  %tobool47 = icmp ne i32 %conv46, 0
  br i1 %tobool47, label %land.lhs.true48, label %if.end57

land.lhs.true48:                                  ; preds = %for.end
  %12 = load i8, i8* %s.0, align 1, !tbaa !166
  %conv49 = zext i8 %12 to i32
  %idxprom50 = sext i32 %conv49 to i64
  %arrayidx51 = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom50
  %13 = load i8, i8* %arrayidx51, align 1, !tbaa !166
  %conv52 = zext i8 %13 to i32
  %and53 = and i32 %conv52, 32
  %cmp54 = icmp ne i32 %and53, 0
  br i1 %cmp54, label %if.end57, label %cleanup

if.end57:                                         ; preds = %land.lhs.true48, %for.end
  br label %while.cond58

while.cond58:                                     ; preds = %while.body69, %if.end57
  %s.1 = phi i8* [ %s.0, %if.end57 ], [ %incdec.ptr71, %while.body69 ]
  %left.2 = phi i64 [ %left.1, %if.end57 ], [ %dec70, %while.body69 ]
  %tobool59 = icmp ne i64 %left.2, 0
  br i1 %tobool59, label %land.rhs60, label %while.end72

land.rhs60:                                       ; preds = %while.cond58
  %14 = load i8, i8* %s.1, align 1, !tbaa !166
  %conv61 = zext i8 %14 to i32
  %idxprom62 = sext i32 %conv61 to i64
  %arrayidx63 = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom62
  %15 = load i8, i8* %arrayidx63, align 1, !tbaa !166
  %conv64 = zext i8 %15 to i32
  %and65 = and i32 %conv64, 32
  %cmp66 = icmp ne i32 %and65, 0
  br i1 %cmp66, label %while.body69, label %while.end72

while.body69:                                     ; preds = %land.rhs60
  %dec70 = add i64 %left.2, -1
  %incdec.ptr71 = getelementptr inbounds i8, i8* %s.1, i32 1
  br label %while.cond58

while.end72:                                      ; preds = %land.rhs60, %while.cond58
  %data = getelementptr inbounds %struct.ctl_table, %struct.ctl_table* %table, i32 0, i32 1
  %16 = load i8*, i8** %data, align 8, !tbaa !1206
  %17 = bitcast i8* %16 to i32*
  store i32 %value.0, i32* %17, align 4, !tbaa !49
  %procname = getelementptr inbounds %struct.ctl_table, %struct.ctl_table* %table, i32 0, i32 0
  %18 = load i8*, i8** %procname, align 8, !tbaa !1208
  %call73 = call i32 @strcmp(i8* %18, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2.1369, i32 0, i32 0))
  %cmp74 = icmp eq i32 %call73, 0
  br i1 %cmp74, label %if.then76, label %done

if.then76:                                        ; preds = %while.end72
  call void @rpc_show_tasks(%struct.net* @init_net)
  br label %done

if.else:                                          ; preds = %if.end
  br i1 %tobool7, label %if.end96, label %cleanup

if.end96:                                         ; preds = %if.else
  %19 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv100 = sext i32 %19 to i64
  %cmp101 = icmp ugt i64 %conv100, %2
  %.conv100 = select i1 %cmp101, i64 %2, i64 %conv100
  %arraydecay105 = getelementptr inbounds [20 x i8], [20 x i8]* %tmpbuf, i32 0, i32 0
  %conv106 = trunc i64 %.conv100 to i32
  call void @might_fault() #7
  %20 = call { i32, i8*, i8*, i32 } asm sideeffect "661:\0A\09call ${4:P}\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (3*32+16)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A .long 661b - .\0A .long 6632f - .\0A .word (9*32+ 9)\0A .byte 662b-661b\0A .byte 6642f-6632f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A .byte 0xff + (6642f-6632f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09call ${5:P}\0A6641:\0A\096632:\0A\09call ${6:P}\0A6642:\0A\09.popsection", "={ax},={di},={si},={dx},i,i,i,1,2,3,~{memory},~{rcx},~{r8},~{r9},~{r10},~{r11},~{dirflag},~{fpsr},~{flags}"(i64 (i8*, i8*, i32)* @copy_user_generic_unrolled, i64 (i8*, i8*, i32)* @copy_user_generic_string, i64 (i8*, i8*, i32)* @copy_user_enhanced_fast_string, i8* %buffer, i8* %arraydecay105, i32 %conv106) #7, !srcloc !1209
  %asmresult.i = extractvalue { i32, i8*, i8*, i32 } %20, 0
  %conv.i1 = zext i32 %asmresult.i to i64
  %conv.i = trunc i64 %conv.i1 to i32
  %tobool108 = icmp ne i32 %conv.i, 0
  br i1 %tobool108, label %cleanup, label %if.end110

if.end110:                                        ; preds = %if.end96
  %sub111 = sub i64 %2, %.conv100
  %cmp112 = icmp ugt i64 %sub111, 0
  br i1 %cmp112, label %if.then114, label %done

if.then114:                                       ; preds = %if.end110
  call void @might_fault()
  %21 = zext i8 10 to i32
  %add.ptr = getelementptr inbounds i8, i8* %buffer, i64 %.conv100
  %22 = call i32 asm sideeffect "call __put_user_1", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %21, i8* %add.ptr) #7, !srcloc !1210
  %tobool116 = icmp ne i32 %22, 0
  br i1 %tobool116, label %cleanup, label %if.end118

if.end118:                                        ; preds = %if.then114
  %dec119 = add i64 %sub111, -1
  br label %done

done:                                             ; preds = %if.end118, %if.end110, %if.then76, %while.end72, %while.end, %while.cond
  %left.5 = phi i64 [ %left.0, %while.cond ], [ %left.0, %while.end ], [ %left.2, %if.then76 ], [ %left.2, %while.end72 ], [ %dec119, %if.end118 ], [ %sub111, %if.end110 ]
  %23 = load i64, i64* %lenp, align 8, !tbaa !88
  %sub122 = sub i64 %23, %left.5
  store i64 %sub122, i64* %lenp, align 8, !tbaa !88
  %24 = load i64, i64* %lenp, align 8, !tbaa !88
  %25 = load i64, i64* %ppos, align 8, !tbaa !291
  %add123 = add i64 %25, %24
  store i64 %add123, i64* %ppos, align 8, !tbaa !291
  br label %cleanup

cleanup:                                          ; preds = %done, %if.then114, %if.end96, %if.else, %land.lhs.true48, %if.end28, %if.end24, %if.then4, %if.then
  %retval.0 = phi i32 [ 0, %done ], [ 0, %if.then ], [ -14, %if.then4 ], [ -22, %if.end24 ], [ -14, %if.end28 ], [ -22, %land.lhs.true48 ], [ -14, %if.else ], [ -14, %if.end96 ], [ -14, %if.then114 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_do_xprt(%struct.ctl_table* %table, i32 %write, i8* %buffer, i64* %lenp, i64* %ppos) #0 {
entry:
  %tmpbuf = alloca [256 x i8], align 16
  %0 = load i64, i64* %ppos, align 8, !tbaa !291
  %tobool = icmp eq i64 %0, 0
  %tobool1 = icmp ne i32 %write, 0
  %or.cond = or i1 %tobool, %tobool1
  br i1 %or.cond, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, i64* %lenp, align 8, !tbaa !88
  %tobool2 = icmp ne i64 %1, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i64 0, i64* %lenp, align 8, !tbaa !88
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %tmpbuf, i32 0, i32 0
  %call = call i32 @svc_print_xprts(i8* %arraydecay, i32 256)
  %conv = sext i32 %call to i64
  %2 = load i64, i64* %lenp, align 8, !tbaa !88
  %arraydecay3 = getelementptr inbounds [256 x i8], [256 x i8]* %tmpbuf, i32 0, i32 0
  %call4 = call i64 @simple_read_from_buffer(i8* %buffer, i64 %2, i64* %ppos, i8* %arraydecay3, i64 %conv)
  %conv5 = trunc i64 %call4 to i32
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %conv5, %if.end ], [ 0, %if.then ]
  ret i32 %retval.0
}

declare i64 @simple_read_from_buffer(i8*, i64, i64*, i8*, i64) #4

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info.1374() #2 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #3, !srcloc !1211
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @copy_from_user.1375(i8* %to, i8* %from, i64 %n) #2 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %cmp = icmp eq i32 %conv, -1
  %conv2 = sext i32 %conv to i64
  %cmp3 = icmp uge i64 %conv2, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp3
  %lnot = xor i1 %1, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %conv7 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv7)
  br label %if.end24

if.else:                                          ; preds = %entry
  %tobool8 = icmp ne i32 1, 0
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  br i1 %tobool15, label %if.then16, label %if.end

if.then16:                                        ; preds = %if.else
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.8.1377, i32 0, i32 0), i32 66, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.9.1378, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then16, %if.else
  br label %if.end24

if.end24:                                         ; preds = %if.end, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.end ]
  ret i64 %n.addr.0
}

declare i64 @copy_user_generic_unrolled(i8*, i8*, i32) #4

declare i64 @copy_user_generic_string(i8*, i8*, i32) #4

declare i64 @copy_user_enhanced_fast_string(i8*, i8*, i32) #4

; Function Attrs: nounwind uwtable
define void @rpc_unregister_sysctl() #0 {
entry:
  %0 = load %struct.ctl_table_header*, %struct.ctl_table_header** @sunrpc_table_header.1366, align 8, !tbaa !28
  %tobool = icmp ne %struct.ctl_table_header* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.ctl_table_header*, %struct.ctl_table_header** @sunrpc_table_header.1366, align 8, !tbaa !28
  call void @unregister_sysctl_table(%struct.ctl_table_header* %1)
  store %struct.ctl_table_header* null, %struct.ctl_table_header** @sunrpc_table_header.1366, align 8, !tbaa !28
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readnone }
attributes #4 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { inlinehint nounwind readnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind }
attributes #8 = { nounwind readnone speculatable }
attributes #9 = { nounwind readonly }

!llvm.ident = !{!0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{!3, !4, i64 0}
!3 = !{!"rpc_message", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!3, !4, i64 8}
!8 = !{!3, !4, i64 16}
!9 = !{!3, !4, i64 24}
!10 = !{!11, !4, i64 0}
!11 = !{!"rpc_task_setup", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !12, i64 48, !5, i64 50}
!12 = !{!"short", !5, i64 0}
!13 = !{!11, !4, i64 8}
!14 = !{!11, !4, i64 16}
!15 = !{!11, !4, i64 24}
!16 = !{!11, !4, i64 32}
!17 = !{!11, !4, i64 40}
!18 = !{!11, !12, i64 48}
!19 = !{!11, !5, i64 50}
!20 = !{!21, !4, i64 80}
!21 = !{!"rpc_task", !22, i64 0, !24, i64 8, !4, i64 24, !4, i64 32, !3, i64 40, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !25, i64 104, !25, i64 112, !4, i64 120, !4, i64 128, !5, i64 136, !5, i64 216, !23, i64 224, !23, i64 228, !12, i64 232, !12, i64 234, !12, i64 236, !5, i64 238, !5, i64 238, !5, i64 238, !5, i64 238}
!22 = !{!"", !23, i64 0}
!23 = !{!"int", !5, i64 0}
!24 = !{!"list_head", !4, i64 0, !4, i64 8}
!25 = !{!"long", !5, i64 0}
!26 = !{!21, !4, i64 24}
!27 = !{!21, !12, i64 232}
!28 = !{!4, !4, i64 0}
!29 = !{!30, !30, i64 0}
!30 = !{!"_Bool", !5, i64 0}
!31 = !{i8 0, i8 2}
!32 = !{!33, !23, i64 1492}
!33 = !{!"rpc_xprt", !22, i64 0, !4, i64 8, !4, i64 16, !34, i64 24, !25, i64 152, !23, i64 160, !25, i64 168, !25, i64 176, !25, i64 184, !23, i64 192, !35, i64 200, !35, i64 512, !35, i64 824, !35, i64 1136, !24, i64 1448, !23, i64 1464, !23, i64 1468, !22, i64 1472, !25, i64 1480, !5, i64 1488, !23, i64 1492, !23, i64 1496, !25, i64 1504, !25, i64 1512, !23, i64 1520, !40, i64 1528, !38, i64 1608, !25, i64 1736, !25, i64 1744, !36, i64 1752, !36, i64 1824, !23, i64 1896, !4, i64 1904, !4, i64 1912, !4, i64 1920, !23, i64 1928, !36, i64 1936, !24, i64 2008, !24, i64 2024, !42, i64 2040, !4, i64 2136, !4, i64 2144, !5, i64 2152}
!34 = !{!"__kernel_sockaddr_storage", !12, i64 0, !5, i64 2}
!35 = !{!"rpc_wait_queue", !36, i64 0, !5, i64 72, !23, i64 136, !5, i64 140, !5, i64 141, !5, i64 142, !12, i64 144, !37, i64 152, !4, i64 304}
!36 = !{!"spinlock", !5, i64 0}
!37 = !{!"rpc_timer", !38, i64 0, !24, i64 128, !25, i64 144}
!38 = !{!"timer_list", !24, i64 0, !25, i64 16, !4, i64 24, !4, i64 32, !25, i64 40, !23, i64 48, !23, i64 52, !4, i64 56, !5, i64 64, !39, i64 80}
!39 = !{!"lockdep_map", !4, i64 0, !5, i64 8, !4, i64 24, !23, i64 32, !25, i64 40}
!40 = !{!"work_struct", !41, i64 0, !24, i64 8, !4, i64 24, !39, i64 32}
!41 = !{!"", !25, i64 0}
!42 = !{!"", !25, i64 0, !25, i64 8, !25, i64 16, !25, i64 24, !25, i64 32, !25, i64 40, !25, i64 48, !25, i64 56, !43, i64 64, !43, i64 72, !43, i64 80, !43, i64 88}
!43 = !{!"long long", !5, i64 0}
!44 = !{!21, !4, i64 40}
!45 = !{!21, !4, i64 48}
!46 = !{!21, !4, i64 56}
!47 = !{!21, !4, i64 64}
!48 = !{i32 -2146167195, i32 -2146167156, i32 -2146167135, i32 -2146167098, i32 -2146167075, i32 -2146167205}
!49 = !{!23, !23, i64 0}
!50 = !{!51, !23, i64 32}
!51 = !{!"rpc_procinfo", !23, i64 0, !4, i64 8, !4, i64 16, !23, i64 24, !23, i64 28, !23, i64 32, !23, i64 36, !23, i64 40, !4, i64 48}
!52 = !{!53, !4, i64 160}
!53 = !{!"rpc_clnt", !22, i64 0, !24, i64 8, !24, i64 24, !36, i64 40, !4, i64 112, !4, i64 120, !23, i64 128, !23, i64 132, !23, i64 136, !4, i64 144, !4, i64 152, !4, i64 160, !4, i64 168, !23, i64 176, !23, i64 176, !23, i64 176, !23, i64 176, !4, i64 184, !4, i64 192, !23, i64 200, !5, i64 204, !4, i64 240, !4, i64 248, !54, i64 256, !55, i64 368, !4, i64 400, !4, i64 408}
!54 = !{!"rpc_rtt", !25, i64 0, !5, i64 8, !5, i64 48, !5, i64 88}
!55 = !{!"rpc_timeout", !25, i64 0, !25, i64 8, !25, i64 16, !23, i64 24, !5, i64 28}
!56 = !{!57, !23, i64 28}
!57 = !{!"rpc_stat", !4, i64 0, !23, i64 8, !23, i64 12, !23, i64 16, !23, i64 20, !23, i64 24, !23, i64 28, !23, i64 32, !23, i64 36, !23, i64 40}
!58 = !{!51, !4, i64 48}
!59 = !{!21, !23, i64 228}
!60 = !{!21, !4, i64 32}
!61 = !{!57, !23, i64 36}
!62 = !{!63, !4, i64 144}
!63 = !{!"rpc_rqst", !4, i64 0, !64, i64 8, !64, i64 72, !4, i64 136, !4, i64 144, !23, i64 152, !23, i64 156, !23, i64 160, !23, i64 164, !4, i64 168, !4, i64 176, !24, i64 184, !4, i64 200, !25, i64 208, !25, i64 216, !25, i64 224, !25, i64 232, !64, i64 240, !25, i64 304, !25, i64 312, !5, i64 320, !23, i64 328, !23, i64 332, !23, i64 336, !5, i64 344, !23, i64 352, !24, i64 360, !25, i64 376, !24, i64 384}
!64 = !{!"xdr_buf", !5, i64 0, !5, i64 16, !4, i64 32, !23, i64 40, !23, i64 44, !23, i64 48, !23, i64 52, !23, i64 56}
!65 = !{!66, !4, i64 48}
!66 = !{!"rpc_cred", !67, i64 0, !24, i64 16, !68, i64 32, !4, i64 48, !4, i64 56, !25, i64 64, !25, i64 72, !25, i64 80, !22, i64 88, !23, i64 92}
!67 = !{!"hlist_node", !4, i64 0, !4, i64 8}
!68 = !{!"callback_head", !4, i64 0, !4, i64 8}
!69 = !{!70, !23, i64 0}
!70 = !{!"rpc_auth", !23, i64 0, !23, i64 4, !23, i64 8, !23, i64 12, !4, i64 16, !23, i64 24, !22, i64 28, !4, i64 32}
!71 = !{!63, !4, i64 0}
!72 = !{!63, !4, i64 200}
!73 = !{!51, !23, i64 0}
!74 = !{!51, !23, i64 24}
!75 = !{i32 -2142311834, i32 -2142311809, i32 -2142311539, i32 -2142311742, i32 -2142311711, i32 -2142311681}
!76 = !{!51, !4, i64 16}
!77 = !{!51, !23, i64 28}
!78 = !{i32 -2142311309, i32 -2142311284, i32 -2142311014, i32 -2142311217, i32 -2142311186, i32 -2142311156}
!79 = !{!63, !25, i64 208}
!80 = !{!63, !25, i64 216}
!81 = !{!33, !4, i64 8}
!82 = !{!83, !4, i64 56}
!83 = !{!"rpc_xprt_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112, !4, i64 120}
!84 = !{i32 -2146707204}
!85 = !{!33, !25, i64 1504}
!86 = !{!21, !25, i64 104}
!87 = !{!83, !4, i64 32}
!88 = !{!25, !25, i64 0}
!89 = !{!90, !4, i64 8}
!90 = !{!"task_struct", !25, i64 0, !4, i64 8, !22, i64 16, !23, i64 20, !23, i64 24, !91, i64 32, !23, i64 40, !23, i64 44, !23, i64 48, !23, i64 52, !23, i64 56, !23, i64 60, !4, i64 64, !92, i64 72, !97, i64 448, !4, i64 520, !98, i64 528, !5, i64 536, !23, i64 540, !23, i64 544, !23, i64 548, !99, i64 552, !100, i64 1064, !24, i64 1096, !101, i64 1112, !4, i64 1152, !4, i64 1160, !23, i64 1168, !23, i64 1172, !23, i64 1176, !23, i64 1180, !23, i64 1184, !23, i64 1188, !23, i64 1192, !23, i64 1196, !23, i64 1196, !23, i64 1196, !23, i64 1196, !23, i64 1196, !23, i64 1196, !23, i64 1200, !23, i64 1204, !25, i64 1208, !4, i64 1216, !4, i64 1224, !24, i64 1232, !24, i64 1248, !4, i64 1264, !24, i64 1272, !24, i64 1288, !5, i64 1304, !24, i64 1376, !4, i64 1392, !4, i64 1400, !4, i64 1408, !25, i64 1416, !25, i64 1424, !25, i64 1432, !25, i64 1440, !25, i64 1448, !102, i64 1456, !25, i64 1472, !25, i64 1480, !103, i64 1488, !103, i64 1504, !25, i64 1520, !25, i64 1528, !104, i64 1536, !5, i64 1560, !4, i64 1608, !4, i64 1616, !5, i64 1624, !23, i64 1640, !23, i64 1644, !105, i64 1648, !25, i64 1656, !106, i64 1664, !4, i64 1848, !4, i64 1856, !4, i64 1864, !4, i64 1872, !4, i64 1880, !108, i64 1888, !108, i64 1896, !108, i64 1904, !109, i64 1912, !25, i64 1936, !25, i64 1944, !4, i64 1952, !4, i64 1960, !4, i64 1968, !4, i64 1976, !4, i64 1984, !23, i64 1992, !23, i64 1996, !110, i64 2000, !23, i64 2016, !23, i64 2020, !36, i64 2024, !111, i64 2096, !113, i64 2168, !4, i64 2184, !4, i64 2192, !23, i64 2200, !25, i64 2208, !25, i64 2216, !23, i64 2224, !23, i64 2228, !23, i64 2232, !23, i64 2236, !25, i64 2240, !25, i64 2248, !23, i64 2256, !23, i64 2260, !23, i64 2264, !23, i64 2268, !43, i64 2272, !23, i64 2280, !23, i64 2284, !5, i64 2288, !23, i64 4976, !4, i64 4984, !4, i64 4992, !4, i64 5000, !4, i64 5008, !4, i64 5016, !4, i64 5024, !25, i64 5032, !4, i64 5040, !114, i64 5048, !43, i64 5104, !43, i64 5112, !25, i64 5120, !108, i64 5128, !115, i64 5256, !23, i64 5260, !23, i64 5264, !4, i64 5272, !24, i64 5280, !4, i64 5296, !4, i64 5304, !24, i64 5312, !4, i64 5328, !5, i64 5336, !116, i64 5352, !24, i64 5520, !4, i64 5536, !12, i64 5544, !12, i64 5546, !23, i64 5548, !23, i64 5552, !23, i64 5556, !43, i64 5560, !68, i64 5568, !68, i64 5584, !4, i64 5600, !117, i64 5608, !4, i64 5624, !23, i64 5632, !23, i64 5636, !23, i64 5640, !25, i64 5648, !23, i64 5656, !5, i64 5664, !25, i64 9504, !25, i64 9512, !23, i64 9520, !4, i64 9528, !43, i64 9536, !22, i64 9544, !22, i64 9548, !25, i64 9552, !25, i64 9560, !118, i64 9568, !23, i64 9600, !22, i64 9604, !4, i64 9608, !23, i64 9616, !23, i64 9620}
!91 = !{!"llist_node", !4, i64 0}
!92 = !{!"sched_entity", !93, i64 0, !94, i64 16, !24, i64 40, !23, i64 56, !43, i64 64, !43, i64 72, !43, i64 80, !43, i64 88, !43, i64 96, !95, i64 104, !4, i64 320, !4, i64 328, !4, i64 336, !96, i64 344}
!93 = !{!"load_weight", !25, i64 0, !25, i64 8}
!94 = !{!"rb_node", !25, i64 0, !4, i64 8, !4, i64 16}
!95 = !{!"sched_statistics", !43, i64 0, !43, i64 8, !43, i64 16, !43, i64 24, !43, i64 32, !43, i64 40, !43, i64 48, !43, i64 56, !43, i64 64, !43, i64 72, !43, i64 80, !43, i64 88, !43, i64 96, !43, i64 104, !43, i64 112, !43, i64 120, !43, i64 128, !43, i64 136, !43, i64 144, !43, i64 152, !43, i64 160, !43, i64 168, !43, i64 176, !43, i64 184, !43, i64 192, !43, i64 200, !43, i64 208}
!96 = !{!"sched_avg", !23, i64 0, !23, i64 4, !43, i64 8, !43, i64 16, !25, i64 24}
!97 = !{!"sched_rt_entity", !24, i64 0, !25, i64 16, !25, i64 24, !23, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64}
!98 = !{!"hlist_head", !4, i64 0}
!99 = !{!"cpumask", !5, i64 0}
!100 = !{!"sched_info", !25, i64 0, !43, i64 8, !43, i64 16, !43, i64 24}
!101 = !{!"plist_node", !23, i64 0, !24, i64 8, !24, i64 24}
!102 = !{!"cputime", !25, i64 0, !25, i64 8}
!103 = !{!"timespec", !25, i64 0, !25, i64 8}
!104 = !{!"task_cputime", !25, i64 0, !25, i64 8, !43, i64 16}
!105 = !{!"sysv_sem", !4, i64 0}
!106 = !{!"thread_struct", !5, i64 0, !25, i64 24, !25, i64 32, !25, i64 40, !12, i64 48, !12, i64 50, !12, i64 52, !12, i64 54, !25, i64 56, !25, i64 64, !5, i64 72, !25, i64 104, !25, i64 112, !25, i64 120, !25, i64 128, !25, i64 136, !107, i64 144, !4, i64 160, !25, i64 168, !23, i64 176}
!107 = !{!"fpu", !23, i64 0, !23, i64 4, !4, i64 8}
!108 = !{!"", !5, i64 0}
!109 = !{!"sigpending", !24, i64 0, !108, i64 16}
!110 = !{!"seccomp", !23, i64 0, !4, i64 8}
!111 = !{!"raw_spinlock", !112, i64 0, !23, i64 4, !23, i64 8, !4, i64 16, !39, i64 24}
!112 = !{!"arch_spinlock", !5, i64 0}
!113 = !{!"plist_head", !24, i64 0}
!114 = !{!"task_io_accounting", !43, i64 0, !43, i64 8, !43, i64 16, !43, i64 24, !43, i64 32, !43, i64 40, !43, i64 48}
!115 = !{!"seqcount", !23, i64 0}
!116 = !{!"mutex", !22, i64 0, !36, i64 8, !24, i64 80, !4, i64 96, !4, i64 104, !4, i64 112, !39, i64 120}
!117 = !{!"page_frag", !4, i64 0, !23, i64 8, !23, i64 12}
!118 = !{!"memcg_batch_info", !23, i64 0, !4, i64 8, !25, i64 16, !25, i64 24}
!119 = !{i32 436420, i32 436431}
!120 = !{!121, !4, i64 0}
!121 = !{!"tracepoint_func", !4, i64 0, !4, i64 8}
!122 = !{!121, !4, i64 8}
!123 = !{!21, !12, i64 234}
!124 = !{!57, !23, i64 32}
!125 = !{i32 -2147002760, i32 -2147002721, i32 -2147002700, i32 -2147002663, i32 -2147002640, i32 -2147002770}
!126 = !{i32 -2145779569}
!127 = !{!128, !23, i64 28}
!128 = !{!"thread_info", !4, i64 0, !4, i64 8, !23, i64 16, !23, i64 20, !23, i64 24, !23, i64 28, !41, i64 32, !129, i64 40, !4, i64 88, !23, i64 96, !23, i64 96}
!129 = !{!"restart_block", !4, i64 0, !5, i64 8}
!130 = !{i32 -2145779426}
!131 = !{i32 -2146139076}
!132 = !{i32 -2145779851}
!133 = !{i32 -2145771571}
!134 = !{i32 -2145766350}
!135 = !{i32 -2145766199}
!136 = !{!137, !4, i64 0}
!137 = !{!"pv_irq_ops", !138, i64 0, !138, i64 8, !138, i64 16, !138, i64 24, !4, i64 32, !4, i64 40, !4, i64 48}
!138 = !{!"paravirt_callee_save", !4, i64 0}
!139 = !{i32 -2146238141, i32 -2146238116, i32 -2146237846, i32 -2146238049, i32 -2146238018, i32 -2146237988}
!140 = !{i32 -2146238561, i32 -2146236583, i32 -2146236561, i32 -2146236548, i32 -2146236225, i32 -2146236158, i32 -2146236456, i32 -2146236429, i32 -2146236401, i32 -2146236371}
!141 = !{!57, !23, i64 24}
!142 = !{!63, !25, i64 232}
!143 = !{!63, !23, i64 336}
!144 = !{!63, !23, i64 332}
!145 = !{!63, !23, i64 64}
!146 = !{!51, !4, i64 8}
!147 = !{!148, !4, i64 0}
!148 = !{!"kvec", !4, i64 0, !25, i64 8}
!149 = !{!148, !25, i64 8}
!150 = !{!64, !23, i64 44}
!151 = !{!64, !23, i64 48}
!152 = !{!64, !23, i64 56}
!153 = !{!64, !23, i64 52}
!154 = !{!63, !23, i64 152}
!155 = !{!53, !23, i64 128}
!156 = !{!53, !23, i64 132}
!157 = !{!33, !23, i64 192}
!158 = !{i32 505601}
!159 = !{i32 -2142297346}
!160 = !{!63, !23, i64 296}
!161 = !{!63, !23, i64 128}
!162 = !{!57, !23, i64 40}
!163 = !{!24, !4, i64 8}
!164 = !{!24, !4, i64 0}
!165 = !{i32 -2146166771, i32 -2146166732, i32 -2146166711, i32 -2146166674, i32 -2146166651, i32 -2146166781}
!166 = !{!5, !5, i64 0}
!167 = !{!53, !4, i64 152}
!168 = !{!53, !4, i64 248}
!169 = !{!53, !4, i64 168}
!170 = !{!53, !4, i64 408}
!171 = !{!33, !4, i64 2136}
!172 = !{!53, !4, i64 240}
!173 = !{!70, !4, i64 16}
!174 = !{!175, !4, i64 64}
!175 = !{!"rpc_authops", !4, i64 0, !23, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88}
!176 = !{!177, !23, i64 0}
!177 = !{!"net_generic", !23, i64 0, !68, i64 8, !5, i64 24}
!178 = !{i32 -2142383728, i32 -2142383703, i32 -2142383433, i32 -2142383636, i32 -2142383605, i32 -2142383575}
!179 = !{i32 -2142383237, i32 -2142383212, i32 -2142382942, i32 -2142383145, i32 -2142383114, i32 -2142383084}
!180 = !{!21, !4, i64 88}
!181 = !{!182, !4, i64 0}
!182 = !{!"rpc_call_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24}
!183 = !{!33, !4, i64 16}
!184 = !{!55, !25, i64 0}
!185 = !{!33, !25, i64 184}
!186 = !{!33, !23, i64 160}
!187 = !{!83, !4, i64 0}
!188 = !{!33, !25, i64 152}
!189 = !{!190, !12, i64 0}
!190 = !{!"sockaddr", !12, i64 0, !5, i64 2}
!191 = !{!192, !12, i64 2}
!192 = !{!"sockaddr_in", !12, i64 0, !12, i64 2, !193, i64 4, !5, i64 8}
!193 = !{!"in_addr", !23, i64 0}
!194 = !{!195, !12, i64 2}
!195 = !{!"sockaddr_in6", !12, i64 0, !12, i64 2, !23, i64 4, !196, i64 8, !23, i64 24}
!196 = !{!"in6_addr", !5, i64 0}
!197 = !{!195, !23, i64 24}
!198 = !{!199, !4, i64 0}
!199 = !{!"rpc_create_args", !4, i64 0, !23, i64 8, !4, i64 16, !25, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !23, i64 64, !23, i64 68, !23, i64 72, !25, i64 80, !4, i64 88, !4, i64 96}
!200 = !{!199, !23, i64 8}
!201 = !{!199, !4, i64 16}
!202 = !{!199, !25, i64 24}
!203 = !{!199, !4, i64 32}
!204 = !{!199, !4, i64 40}
!205 = !{!199, !4, i64 48}
!206 = !{!199, !4, i64 56}
!207 = !{!208, !23, i64 8}
!208 = !{!"rpc_program", !4, i64 0, !23, i64 8, !23, i64 12, !4, i64 16, !4, i64 24, !4, i64 32}
!209 = !{!199, !23, i64 64}
!210 = !{!199, !23, i64 68}
!211 = !{!70, !23, i64 24}
!212 = !{!199, !23, i64 72}
!213 = !{!199, !25, i64 80}
!214 = !{!199, !4, i64 88}
!215 = !{!199, !4, i64 96}
!216 = !{!33, !4, i64 2144}
!217 = !{!175, !4, i64 40}
!218 = !{!219, !23, i64 0}
!219 = !{!"__wait_queue", !23, i64 0, !4, i64 8, !4, i64 16, !24, i64 24}
!220 = !{!219, !4, i64 8}
!221 = !{!219, !4, i64 16}
!222 = !{!21, !4, i64 128}
!223 = !{!208, !23, i64 12}
!224 = !{!208, !4, i64 16}
!225 = !{i32 -2142379546}
!226 = !{!53, !4, i64 112}
!227 = !{!228, !4, i64 8}
!228 = !{!"rpc_version", !23, i64 0, !23, i64 4, !4, i64 8}
!229 = !{!53, !4, i64 120}
!230 = !{!228, !23, i64 4}
!231 = !{!53, !23, i64 136}
!232 = !{!208, !4, i64 0}
!233 = !{!53, !4, i64 144}
!234 = !{!228, !23, i64 0}
!235 = !{!208, !4, i64 24}
!236 = !{!53, !4, i64 400}
!237 = !{!53, !4, i64 192}
!238 = !{!53, !4, i64 184}
!239 = !{!208, !4, i64 32}
!240 = !{!22, !23, i64 0}
!241 = !{!90, !4, i64 1864}
!242 = !{!243, !4, i64 8}
!243 = !{!"nsproxy", !22, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40}
!244 = !{!53, !23, i64 200}
!245 = !{!246, !4, i64 8}
!246 = !{!"qstr", !5, i64 0, !4, i64 8}
!247 = !{!248, !23, i64 0}
!248 = !{!"xprt_create", !23, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !25, i64 32, !4, i64 40, !4, i64 48, !23, i64 56}
!249 = !{!248, !4, i64 8}
!250 = !{!248, !4, i64 16}
!251 = !{!248, !4, i64 24}
!252 = !{!248, !25, i64 32}
!253 = !{!248, !4, i64 40}
!254 = !{!248, !4, i64 48}
!255 = !{!248, !23, i64 56}
!256 = !{!257, !4, i64 1872}
!257 = !{!"super_block", !24, i64 0, !23, i64 16, !5, i64 20, !25, i64 24, !43, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !25, i64 80, !25, i64 88, !4, i64 96, !258, i64 104, !23, i64 248, !22, i64 252, !4, i64 256, !4, i64 264, !24, i64 272, !259, i64 288, !4, i64 296, !24, i64 304, !24, i64 320, !23, i64 336, !36, i64 384, !24, i64 456, !23, i64 472, !4, i64 480, !4, i64 488, !4, i64 496, !67, i64 504, !260, i64 520, !261, i64 1184, !5, i64 1824, !5, i64 1856, !4, i64 1872, !23, i64 1880, !23, i64 1884, !23, i64 1888, !116, i64 1896, !4, i64 2064, !4, i64 2072, !4, i64 2080, !23, i64 2088, !263, i64 2096, !41, i64 2144, !23, i64 2152}
!258 = !{!"rw_semaphore", !25, i64 0, !111, i64 8, !24, i64 80, !39, i64 96}
!259 = !{!"hlist_bl_head", !4, i64 0}
!260 = !{!"quota_info", !23, i64 0, !116, i64 8, !116, i64 176, !258, i64 344, !5, i64 488, !5, i64 504, !5, i64 648}
!261 = !{!"sb_writers", !5, i64 0, !262, i64 312, !23, i64 400, !262, i64 408, !5, i64 496}
!262 = !{!"__wait_queue_head", !36, i64 0, !24, i64 72}
!263 = !{!"shrinker", !4, i64 0, !23, i64 8, !25, i64 16, !24, i64 24, !41, i64 40}
!264 = !{!175, !4, i64 56}
!265 = !{i32 -2146162057, i32 -2146162018, i32 -2146161997, i32 -2146161960, i32 -2146161937, i32 -2146161928}
!266 = !{!35, !4, i64 304}
!267 = !{i32 -2146186078, i32 -2146186039, i32 -2146186018, i32 -2146185981, i32 -2146185958, i32 -2146186088}
!268 = !{!33, !23, i64 1464}
!269 = !{!33, !23, i64 1468}
!270 = !{!33, !25, i64 1736}
!271 = !{!33, !25, i64 176}
!272 = !{!33, !23, i64 1496}
!273 = !{!33, !23, i64 1896}
!274 = !{i32 -2146186502, i32 -2146186463, i32 -2146186442, i32 -2146186405, i32 -2146186382, i32 -2146186512}
!275 = !{!83, !4, i64 8}
!276 = !{!33, !4, i64 1448}
!277 = !{!83, !4, i64 16}
!278 = !{i32 -2147022775, i32 -2147022736, i32 -2147022715, i32 -2147022678, i32 -2147022655, i32 -2147022785}
!279 = !{!63, !25, i64 312}
!280 = !{!63, !4, i64 136}
!281 = !{!63, !4, i64 176}
!282 = !{!63, !25, i64 304}
!283 = !{!55, !5, i64 28}
!284 = !{!55, !23, i64 24}
!285 = !{!55, !25, i64 16}
!286 = !{!55, !25, i64 8}
!287 = !{i32 -2146186290, i32 -2146186251, i32 -2146186230, i32 -2146186193, i32 -2146186170, i32 -2146186300}
!288 = !{i32 -2146181364, i32 -2146181325, i32 -2146181304, i32 -2146181267, i32 -2146181244, i32 -2146181235}
!289 = !{!33, !25, i64 2080}
!290 = !{i64 0, i64 8, !291}
!291 = !{!43, !43, i64 0}
!292 = !{!83, !4, i64 88}
!293 = !{i32 -2142419449}
!294 = !{!51, !23, i64 36}
!295 = !{!63, !23, i64 352}
!296 = !{!297, !25, i64 0}
!297 = !{!"timeval", !25, i64 0, !25, i64 8}
!298 = !{!297, !25, i64 8}
!299 = !{!33, !25, i64 2088}
!300 = !{i32 -2147022067, i32 -2147022028, i32 -2147022007, i32 -2147021970, i32 -2147021947, i32 -2147022077}
!301 = !{!63, !23, i64 328}
!302 = !{!33, !4, i64 1904}
!303 = !{!33, !25, i64 168}
!304 = !{!63, !23, i64 156}
!305 = !{i32 -2147020854, i32 -2147020815, i32 -2147020794, i32 -2147020757, i32 -2147020734, i32 -2147020864, i32 413862}
!306 = !{i32 -2142448763}
!307 = !{i32 -2142448711}
!308 = !{!309, !23, i64 16}
!309 = !{!"xprt_class", !24, i64 0, !23, i64 16, !4, i64 24, !4, i64 32, !5, i64 40}
!310 = !{!33, !23, i64 1520}
!311 = !{!83, !4, i64 104}
!312 = !{!33, !25, i64 2056}
!313 = !{!83, !4, i64 48}
!314 = !{i32 -2147020388, i32 -2147020349, i32 -2147020328, i32 -2147020291, i32 -2147020268, i32 -2147020398, i32 415114}
!315 = !{!33, !25, i64 2048}
!316 = !{!33, !25, i64 2064}
!317 = !{!83, !4, i64 72}
!318 = !{!83, !4, i64 80}
!319 = !{!33, !25, i64 2096}
!320 = !{!33, !25, i64 2072}
!321 = !{!33, !43, i64 2104}
!322 = !{!33, !12, i64 1280}
!323 = !{!33, !43, i64 2112}
!324 = !{!33, !12, i64 656}
!325 = !{!33, !43, i64 2120}
!326 = !{!33, !12, i64 968}
!327 = !{!33, !43, i64 2128}
!328 = !{!83, !4, i64 24}
!329 = !{i32 -2145798876}
!330 = !{i32 -2145798733}
!331 = !{i32 -2146158383}
!332 = !{i32 -2145799158}
!333 = !{!182, !4, i64 16}
!334 = !{!21, !4, i64 96}
!335 = !{!83, !4, i64 96}
!336 = !{!33, !25, i64 1744}
!337 = !{!83, !4, i64 64}
!338 = !{!309, !4, i64 24}
!339 = !{!41, !25, i64 0}
!340 = !{i64 0, i64 8, !88}
!341 = !{!40, !4, i64 24}
!342 = !{!38, !4, i64 32}
!343 = !{!38, !25, i64 40}
!344 = !{!83, !4, i64 112}
!345 = !{!346, !4, i64 0}
!346 = !{!"xdr_skb_reader", !4, i64 0, !23, i64 8, !25, i64 16, !23, i64 24}
!347 = !{!346, !23, i64 8}
!348 = !{!349, !23, i64 104}
!349 = !{!"sk_buff", !4, i64 0, !4, i64 8, !5, i64 16, !4, i64 24, !4, i64 32, !5, i64 40, !25, i64 88, !4, i64 96, !23, i64 104, !23, i64 108, !12, i64 112, !12, i64 114, !5, i64 116, !23, i64 120, !5, i64 124, !5, i64 124, !5, i64 124, !5, i64 124, !5, i64 124, !5, i64 125, !5, i64 125, !5, i64 125, !5, i64 125, !5, i64 125, !12, i64 126, !4, i64 128, !4, i64 136, !4, i64 144, !4, i64 152, !23, i64 160, !23, i64 164, !12, i64 168, !12, i64 170, !12, i64 172, !12, i64 174, !12, i64 176, !5, i64 178, !5, i64 178, !5, i64 178, !5, i64 178, !5, i64 178, !5, i64 178, !5, i64 178, !5, i64 179, !5, i64 179, !23, i64 180, !23, i64 184, !5, i64 188, !23, i64 192, !23, i64 196, !23, i64 200, !23, i64 204, !23, i64 208, !23, i64 212, !23, i64 216, !23, i64 220, !4, i64 224, !4, i64 232, !23, i64 240, !22, i64 244}
!350 = !{!346, !25, i64 16}
!351 = !{!349, !4, i64 232}
!352 = !{!346, !23, i64 24}
!353 = !{!349, !4, i64 32}
!354 = !{!64, !4, i64 32}
!355 = !{!64, !23, i64 40}
!356 = !{i32 3663554, i32 3663577}
!357 = !{i32 -2143118891}
!358 = !{i32 -2143118748}
!359 = !{i32 -2146074808}
!360 = !{i32 -2143118985}
!361 = !{!362, !4, i64 2208}
!362 = !{!"sock_xprt", !33, i64 0, !4, i64 2200, !4, i64 2208, !23, i64 2216, !23, i64 2220, !23, i64 2224, !23, i64 2228, !23, i64 2232, !25, i64 2240, !25, i64 2248, !363, i64 2256, !34, i64 2480, !12, i64 2608, !25, i64 2616, !25, i64 2624, !4, i64 2632, !4, i64 2640, !4, i64 2648}
!363 = !{!"delayed_work", !40, i64 0, !38, i64 80, !4, i64 208, !23, i64 216}
!364 = !{!365, !4, i64 952}
!365 = !{!"svc_xprt", !4, i64 0, !4, i64 8, !366, i64 16, !24, i64 24, !24, i64 40, !25, i64 56, !4, i64 64, !22, i64 72, !116, i64 80, !36, i64 248, !4, i64 320, !24, i64 328, !34, i64 344, !25, i64 472, !34, i64 480, !25, i64 608, !35, i64 616, !24, i64 928, !4, i64 944, !4, i64 952}
!366 = !{!"kref", !22, i64 0}
!367 = !{!33, !25, i64 1512}
!368 = !{!33, !4, i64 1912}
!369 = !{!370, !4, i64 960}
!370 = !{!"svc_sock", !365, i64 0, !4, i64 960, !4, i64 968, !4, i64 976, !4, i64 984, !4, i64 992, !23, i64 1000, !23, i64 1004, !23, i64 1008, !5, i64 1016}
!371 = !{!362, !4, i64 2200}
!372 = !{!370, !4, i64 968}
!373 = !{i32 -2146929090, i32 -2146929051, i32 -2146929030, i32 -2146928993, i32 -2146928970, i32 -2146929100}
!374 = !{!192, !23, i64 4}
!375 = !{i32 -2141943132, i32 -2141943107, i32 -2141942837, i32 -2141943040, i32 -2141943009, i32 -2141942979}
!376 = !{i32 579979}
!377 = !{!362, !12, i64 2608}
!378 = !{!33, !25, i64 2040}
!379 = !{i32 -2145783584}
!380 = !{i32 -2145783441}
!381 = !{i32 -2146106871}
!382 = !{i32 -2145783866}
!383 = !{i32 -2146927169, i32 -2146927130, i32 -2146927109, i32 -2146927072, i32 -2146927049, i32 -2146927179, i32 507547}
!384 = !{i32 -2146669573}
!385 = !{!90, !23, i64 20}
!386 = !{i32 -2146928382, i32 -2146928343, i32 -2146928322, i32 -2146928285, i32 -2146928262, i32 -2146928392}
!387 = !{!388, !4, i64 32}
!388 = !{!"socket", !5, i64 0, !12, i64 4, !25, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40}
!389 = !{!390, !5, i64 18}
!390 = !{!"sock", !391, i64 0, !392, i64 80, !393, i64 296, !394, i64 392, !23, i64 416, !23, i64 420, !22, i64 424, !23, i64 428, !4, i64 432, !4, i64 440, !393, i64 448, !5, i64 544, !25, i64 560, !4, i64 568, !4, i64 576, !36, i64 584, !22, i64 656, !22, i64 660, !23, i64 664, !393, i64 672, !23, i64 768, !23, i64 768, !23, i64 768, !23, i64 769, !23, i64 770, !23, i64 772, !23, i64 776, !43, i64 784, !43, i64 792, !23, i64 800, !23, i64 804, !12, i64 808, !23, i64 812, !25, i64 816, !393, i64 824, !4, i64 920, !395, i64 928, !23, i64 1000, !23, i64 1004, !12, i64 1008, !12, i64 1010, !23, i64 1012, !23, i64 1016, !4, i64 1024, !4, i64 1032, !25, i64 1040, !25, i64 1048, !4, i64 1056, !38, i64 1064, !5, i64 1192, !4, i64 1200, !4, i64 1208, !117, i64 1216, !4, i64 1232, !23, i64 1240, !23, i64 1244, !4, i64 1248, !23, i64 1256, !23, i64 1260, !4, i64 1264, !4, i64 1272, !4, i64 1280, !4, i64 1288, !4, i64 1296, !4, i64 1304, !4, i64 1312}
!391 = !{!"sock_common", !5, i64 0, !5, i64 8, !5, i64 12, !12, i64 16, !5, i64 18, !5, i64 19, !5, i64 19, !23, i64 20, !5, i64 24, !4, i64 40, !4, i64 48, !5, i64 56, !5, i64 56, !23, i64 72, !22, i64 76, !5, i64 80}
!392 = !{!"", !36, i64 0, !23, i64 72, !262, i64 80, !39, i64 168}
!393 = !{!"sk_buff_head", !4, i64 0, !4, i64 8, !23, i64 16, !36, i64 24}
!394 = !{!"", !22, i64 0, !23, i64 4, !4, i64 8, !4, i64 16}
!395 = !{!"", !5, i64 0, !23, i64 8, !23, i64 12, !4, i64 16, !39, i64 24}
!396 = !{i32 -2146926703, i32 -2146926664, i32 -2146926643, i32 -2146926606, i32 -2146926583, i32 -2146926713, i32 508799}
!397 = !{!388, !5, i64 0}
!398 = !{!390, !4, i64 1208}
!399 = !{!390, !4, i64 1280}
!400 = !{!390, !4, i64 1272}
!401 = !{!390, !4, i64 1288}
!402 = !{!390, !23, i64 776}
!403 = !{!404, !23, i64 2672}
!404 = !{!"tcp_sock", !405, i64 0, !12, i64 2024, !12, i64 2026, !23, i64 2028, !23, i64 2032, !23, i64 2036, !23, i64 2040, !23, i64 2044, !23, i64 2048, !23, i64 2052, !23, i64 2056, !23, i64 2060, !23, i64 2064, !24, i64 2072, !25, i64 2088, !413, i64 2096, !23, i64 2248, !23, i64 2252, !23, i64 2256, !23, i64 2260, !23, i64 2264, !23, i64 2268, !12, i64 2272, !5, i64 2274, !5, i64 2275, !5, i64 2275, !5, i64 2275, !5, i64 2275, !5, i64 2275, !5, i64 2276, !5, i64 2277, !5, i64 2277, !5, i64 2277, !5, i64 2277, !23, i64 2280, !23, i64 2284, !23, i64 2288, !23, i64 2292, !23, i64 2296, !23, i64 2300, !23, i64 2304, !23, i64 2308, !12, i64 2312, !5, i64 2314, !5, i64 2315, !23, i64 2316, !5, i64 2320, !414, i64 2328, !23, i64 2360, !23, i64 2364, !23, i64 2368, !23, i64 2372, !23, i64 2376, !23, i64 2380, !23, i64 2384, !23, i64 2388, !23, i64 2392, !23, i64 2396, !23, i64 2400, !23, i64 2404, !23, i64 2408, !23, i64 2412, !23, i64 2416, !23, i64 2420, !4, i64 2424, !4, i64 2432, !4, i64 2440, !393, i64 2448, !5, i64 2544, !5, i64 2552, !5, i64 2584, !4, i64 2616, !23, i64 2624, !23, i64 2628, !23, i64 2632, !23, i64 2636, !23, i64 2640, !23, i64 2644, !23, i64 2648, !23, i64 2652, !23, i64 2656, !23, i64 2660, !23, i64 2664, !23, i64 2668, !23, i64 2672, !415, i64 2676, !415, i64 2688, !416, i64 2700, !23, i64 2708, !4, i64 2712, !4, i64 2720, !4, i64 2728, !4, i64 2736}
!405 = !{!"inet_connection_sock", !406, i64 0, !410, i64 1488, !4, i64 1600, !25, i64 1608, !38, i64 1616, !38, i64 1744, !23, i64 1872, !23, i64 1876, !4, i64 1880, !4, i64 1888, !4, i64 1896, !5, i64 1904, !5, i64 1905, !5, i64 1906, !5, i64 1907, !5, i64 1908, !5, i64 1909, !12, i64 1910, !411, i64 1912, !412, i64 1936, !5, i64 1952, !23, i64 2016}
!406 = !{!"inet_sock", !390, i64 0, !4, i64 1320, !23, i64 1328, !12, i64 1332, !12, i64 1334, !12, i64 1336, !12, i64 1338, !4, i64 1344, !23, i64 1352, !5, i64 1356, !5, i64 1357, !5, i64 1358, !5, i64 1359, !5, i64 1360, !5, i64 1360, !5, i64 1360, !5, i64 1360, !5, i64 1360, !5, i64 1360, !5, i64 1360, !5, i64 1360, !5, i64 1361, !23, i64 1364, !23, i64 1368, !23, i64 1372, !4, i64 1376, !407, i64 1384}
!407 = !{!"inet_cork_full", !408, i64 0, !409, i64 40}
!408 = !{!"inet_cork", !23, i64 0, !23, i64 4, !4, i64 8, !23, i64 16, !23, i64 20, !4, i64 24, !5, i64 32}
!409 = !{!"flowi", !5, i64 0}
!410 = !{!"request_sock_queue", !4, i64 0, !4, i64 8, !395, i64 16, !5, i64 88, !4, i64 96, !4, i64 104}
!411 = !{!"", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !23, i64 4, !25, i64 8, !23, i64 16, !12, i64 20, !12, i64 22}
!412 = !{!"", !23, i64 0, !23, i64 4, !23, i64 8, !23, i64 12}
!413 = !{!"", !393, i64 0, !4, i64 96, !4, i64 104, !23, i64 112, !23, i64 116, !4, i64 120, !23, i64 128, !4, i64 136, !23, i64 144}
!414 = !{!"tcp_options_received", !25, i64 0, !23, i64 8, !23, i64 12, !23, i64 16, !12, i64 20, !12, i64 20, !12, i64 20, !12, i64 20, !12, i64 20, !12, i64 21, !12, i64 21, !5, i64 22, !12, i64 24, !12, i64 26}
!415 = !{!"", !23, i64 0, !23, i64 4, !23, i64 8}
!416 = !{!"", !23, i64 0, !23, i64 4}
!417 = !{i32 -2142401350}
!418 = !{i32 -2142401298}
!419 = !{!362, !4, i64 2632}
!420 = !{!362, !4, i64 2640}
!421 = !{!362, !4, i64 2648}
!422 = !{!423, !25, i64 8}
!423 = !{!"", !25, i64 0, !25, i64 8, !5, i64 16, !23, i64 24}
!424 = !{!362, !23, i64 2228}
!425 = !{!362, !23, i64 2232}
!426 = !{!362, !25, i64 2240}
!427 = !{!362, !25, i64 2248}
!428 = !{i32 -2141759628}
!429 = !{i32 -2141759572}
!430 = !{i32 -2141759468}
!431 = !{i32 -2141759416}
!432 = !{i32 505509}
!433 = !{!390, !23, i64 664}
!434 = !{!390, !23, i64 772}
!435 = !{!390, !4, i64 1200}
!436 = !{i32 -2141761151}
!437 = !{i32 -2141761087}
!438 = !{i32 510798, i32 510809}
!439 = !{!362, !23, i64 2216}
!440 = !{!362, !23, i64 2224}
!441 = !{!362, !23, i64 2220}
!442 = !{!33, !4, i64 1920}
!443 = !{!63, !23, i64 292}
!444 = !{!390, !23, i64 152}
!445 = !{!362, !25, i64 152}
!446 = !{!34, !12, i64 0}
!447 = !{!63, !25, i64 224}
!448 = !{i32 -2141935113}
!449 = !{i32 -2141935053}
!450 = !{!390, !23, i64 1244}
!451 = !{!452, !4, i64 0}
!452 = !{!"msghdr", !4, i64 0, !23, i64 8, !4, i64 16, !25, i64 24, !4, i64 32, !25, i64 40, !23, i64 48}
!453 = !{!452, !23, i64 8}
!454 = !{!452, !4, i64 16}
!455 = !{!452, !25, i64 24}
!456 = !{!452, !4, i64 32}
!457 = !{!452, !25, i64 40}
!458 = !{!452, !23, i64 48}
!459 = !{!388, !4, i64 40}
!460 = !{!461, !4, i64 160}
!461 = !{!"proto_ops", !23, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112, !4, i64 120, !4, i64 128, !4, i64 136, !4, i64 144, !4, i64 152, !4, i64 160, !4, i64 168, !4, i64 176}
!462 = !{!390, !12, i64 16}
!463 = !{i32 -2141895418}
!464 = !{i32 -2141860226}
!465 = !{i32 -2141824291}
!466 = !{i32 -2141784612}
!467 = !{!362, !25, i64 2616}
!468 = !{!390, !23, i64 428}
!469 = !{!362, !25, i64 2624}
!470 = !{!349, !23, i64 108}
!471 = !{!472, !12, i64 0}
!472 = !{!"sockaddr_un", !12, i64 0, !5, i64 2}
!473 = !{!21, !4, i64 120}
!474 = !{i32 -2146193182, i32 -2146193143, i32 -2146193122, i32 -2146193085, i32 -2146193062, i32 -2146193192}
!475 = !{!182, !4, i64 24}
!476 = !{!182, !4, i64 8}
!477 = !{i32 -2141959811}
!478 = !{!35, !5, i64 140}
!479 = !{!35, !12, i64 144}
!480 = !{i32 -2141967858}
!481 = !{i32 -2147029171, i32 -2147029132, i32 -2147029111, i32 -2147029074, i32 -2147029051, i32 -2147029181}
!482 = !{i32 -2141967808}
!483 = !{i32 -2147027958, i32 -2147027919, i32 -2147027898, i32 -2147027861, i32 -2147027838, i32 -2147027968, i32 406758}
!484 = !{i32 -2146733615}
!485 = !{!21, !4, i64 72}
!486 = !{i32 -2141938263}
!487 = !{i32 -2141938213}
!488 = !{i32 -2147029879, i32 -2147029840, i32 -2147029819, i32 -2147029782, i32 -2147029759, i32 -2147029889}
!489 = !{!490, !4, i64 0}
!490 = !{!"wait_bit_key", !4, i64 0, !23, i64 8}
!491 = !{!490, !23, i64 8}
!492 = !{i32 -2145797982}
!493 = !{i32 -2145792761}
!494 = !{i32 -2145792610}
!495 = !{i32 -2146165487}
!496 = !{i32 -2146264552, i32 -2146264527, i32 -2146264257, i32 -2146264460, i32 -2146264429, i32 -2146264399}
!497 = !{i32 -2146264972, i32 -2146262994, i32 -2146262972, i32 -2146262959, i32 -2146262636, i32 -2146262569, i32 -2146262867, i32 -2146262840, i32 -2146262812, i32 -2146262782}
!498 = !{i32 -2144638394}
!499 = !{i32 410009, i32 410020}
!500 = !{i32 -2141976787}
!501 = !{!35, !25, i64 296}
!502 = !{!35, !5, i64 141}
!503 = !{!21, !23, i64 224}
!504 = !{!35, !23, i64 136}
!505 = !{!35, !5, i64 142}
!506 = !{!507, !4, i64 8440}
!507 = !{!"trace_iterator", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !23, i64 32, !116, i64 40, !4, i64 208, !25, i64 216, !508, i64 224, !508, i64 4332, !4, i64 8440, !25, i64 8448, !23, i64 8456, !23, i64 8460, !23, i64 8464, !43, i64 8472, !43, i64 8480, !25, i64 8488, !4, i64 8496, !30, i64 8504}
!508 = !{!"trace_seq", !5, i64 0, !23, i64 4096, !23, i64 4100, !23, i64 4104}
!509 = !{!510, !4, i64 16}
!510 = !{!"ftrace_raw_rpc_task_queued", !511, i64 0, !4, i64 8, !4, i64 16, !25, i64 24, !25, i64 32, !23, i64 40, !12, i64 44, !23, i64 48, !5, i64 52}
!511 = !{!"trace_entry", !12, i64 0, !5, i64 2, !5, i64 3, !23, i64 4}
!512 = !{!510, !4, i64 8}
!513 = !{!510, !12, i64 44}
!514 = !{!510, !25, i64 32}
!515 = !{!510, !23, i64 40}
!516 = !{!510, !25, i64 24}
!517 = !{!510, !23, i64 48}
!518 = !{!519, !4, i64 16}
!519 = !{!"ftrace_event_file", !24, i64 0, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !25, i64 48, !22, i64 56}
!520 = !{!521, !23, i64 64}
!521 = !{!"ftrace_event_call", !24, i64 0, !4, i64 16, !4, i64 24, !522, i64 32, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112, !23, i64 120, !23, i64 124, !4, i64 128}
!522 = !{!"trace_event", !67, i64 0, !24, i64 16, !23, i64 32, !4, i64 40}
!523 = !{!524, !23, i64 0}
!524 = !{!"ftrace_data_offsets_rpc_task_queued", !23, i64 0}
!525 = !{!21, !25, i64 112}
!526 = !{!521, !4, i64 128}
!527 = !{i32 -2141985393}
!528 = !{!529, !25, i64 128}
!529 = !{!"pt_regs", !25, i64 0, !25, i64 8, !25, i64 16, !25, i64 24, !25, i64 32, !25, i64 40, !25, i64 48, !25, i64 56, !25, i64 64, !25, i64 72, !25, i64 80, !25, i64 88, !25, i64 96, !25, i64 104, !25, i64 112, !25, i64 120, !25, i64 128, !25, i64 136, !25, i64 144, !25, i64 152, !25, i64 160}
!530 = !{!529, !25, i64 32}
!531 = !{!529, !25, i64 136}
!532 = !{!529, !25, i64 144}
!533 = !{i32 -2142235521}
!534 = !{i32 -2142303091}
!535 = !{!536, !4, i64 0}
!536 = !{!"stack_frame", !4, i64 0, !25, i64 8}
!537 = !{!538, !4, i64 16}
!538 = !{!"ftrace_raw_rpc_task_running", !511, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !25, i64 32, !23, i64 40, !12, i64 44, !5, i64 46}
!539 = !{!538, !4, i64 8}
!540 = !{!538, !12, i64 44}
!541 = !{!538, !25, i64 32}
!542 = !{!538, !23, i64 40}
!543 = !{!538, !4, i64 24}
!544 = !{i32 -2141991107}
!545 = !{!546, !4, i64 8}
!546 = !{!"ftrace_raw_rpc_connect_status", !511, i64 0, !4, i64 8, !4, i64 16, !23, i64 24, !5, i64 28}
!547 = !{!546, !4, i64 16}
!548 = !{!546, !23, i64 24}
!549 = !{i32 -2141995506}
!550 = !{!551, !4, i64 8}
!551 = !{!"ftrace_raw_rpc_task_status", !511, i64 0, !4, i64 8, !4, i64 16, !23, i64 24, !5, i64 28}
!552 = !{!551, !4, i64 16}
!553 = !{!551, !23, i64 24}
!554 = !{i32 -2142000877}
!555 = !{!21, !12, i64 236}
!556 = !{i32 -2146190971, i32 -2146190932, i32 -2146190911, i32 -2146190874, i32 -2146190851, i32 -2146190842}
!557 = !{!90, !23, i64 1204}
!558 = !{!66, !4, i64 56}
!559 = !{!560, !4, i64 16}
!560 = !{!"rpc_credops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72}
!561 = !{!66, !25, i64 72}
!562 = !{i32 -2146137255, i32 -2146137216, i32 -2146137195, i32 -2146137158, i32 -2146137135, i32 -2146137265}
!563 = !{!70, !4, i64 32}
!564 = !{i32 -2142543295}
!565 = !{i32 -2146994770, i32 -2146994731, i32 -2146994710, i32 -2146994673, i32 -2146994650, i32 -2146994780}
!566 = !{!67, !4, i64 8}
!567 = !{!67, !4, i64 0}
!568 = !{i32 -2146137679, i32 -2146137640, i32 -2146137619, i32 -2146137582, i32 -2146137559, i32 -2146137689}
!569 = !{!66, !25, i64 64}
!570 = !{!571, !23, i64 0}
!571 = !{!"auth_cred", !23, i64 0, !23, i64 4, !4, i64 8, !4, i64 16, !5, i64 24}
!572 = !{!66, !23, i64 92}
!573 = !{!574, !23, i64 8}
!574 = !{!"rpc_cred_cache", !4, i64 0, !23, i64 8, !36, i64 16}
!575 = !{!574, !4, i64 0}
!576 = !{!560, !4, i64 24}
!577 = !{!175, !4, i64 48}
!578 = !{i32 -2146995478, i32 -2146995439, i32 -2146995418, i32 -2146995381, i32 -2146995358, i32 -2146995488}
!579 = !{!560, !4, i64 8}
!580 = !{!98, !4, i64 0}
!581 = !{i32 -2145194011}
!582 = !{i32 -2145805928}
!583 = !{i32 -2145805785}
!584 = !{i32 -2146109560}
!585 = !{i32 -2145806210}
!586 = !{!175, !4, i64 0}
!587 = !{!175, !4, i64 24}
!588 = !{!175, !4, i64 32}
!589 = !{!175, !4, i64 72}
!590 = !{!175, !23, i64 8}
!591 = !{!175, !4, i64 88}
!592 = !{!175, !4, i64 80}
!593 = !{i32 447663}
!594 = !{i32 -2146677688}
!595 = !{!90, !4, i64 1616}
!596 = !{!597, !23, i64 44}
!597 = !{!"cred", !22, i64 0, !22, i64 4, !4, i64 8, !23, i64 16, !23, i64 20, !23, i64 24, !23, i64 28, !23, i64 32, !23, i64 36, !23, i64 40, !23, i64 44, !23, i64 48, !23, i64 52, !598, i64 56, !598, i64 64, !598, i64 72, !598, i64 80, !5, i64 88, !4, i64 96, !4, i64 104, !4, i64 112, !4, i64 120, !4, i64 128, !4, i64 136, !4, i64 144, !4, i64 152, !68, i64 160}
!598 = !{!"kernel_cap_struct", !5, i64 0}
!599 = !{!597, !23, i64 48}
!600 = !{!571, !23, i64 4}
!601 = !{!597, !4, i64 152}
!602 = !{!571, !4, i64 8}
!603 = !{!560, !4, i64 40}
!604 = !{!560, !4, i64 56}
!605 = !{!560, !4, i64 64}
!606 = !{!560, !4, i64 72}
!607 = !{!560, !4, i64 48}
!608 = !{!560, !4, i64 32}
!609 = !{!610, !25, i64 8}
!610 = !{!"shrink_control", !23, i64 0, !25, i64 8}
!611 = !{!610, !23, i64 0}
!612 = !{!66, !4, i64 16}
!613 = !{i32 -2146220636, i32 -2146220597, i32 -2146220576, i32 -2146220539, i32 -2146220516, i32 -2146220646}
!614 = !{i32 -2147056909, i32 -2147056870, i32 -2147056849, i32 -2147056812, i32 -2147056789, i32 -2147056919}
!615 = !{i32 452160}
!616 = !{!617, !25, i64 80}
!617 = !{!"unx_cred", !66, i64 0, !23, i64 96, !5, i64 100}
!618 = !{!619, !23, i64 4}
!619 = !{!"group_info", !22, i64 0, !23, i64 4, !23, i64 8, !5, i64 12, !5, i64 144}
!620 = !{!617, !23, i64 96}
!621 = !{!617, !23, i64 92}
!622 = !{i32 -2147011104, i32 -2147011065, i32 -2147011044, i32 -2147011007, i32 -2147010984, i32 -2147011114}
!623 = !{!70, !23, i64 4}
!624 = !{i32 497965}
!625 = !{i32 -2146209964, i32 -2146209925, i32 -2146209904, i32 -2146209867, i32 -2146209844, i32 -2146209974}
!626 = !{!571, !4, i64 16}
!627 = !{!628, !25, i64 80}
!628 = !{!"generic_cred", !66, i64 0, !571, i64 96}
!629 = !{!628, !23, i64 96}
!630 = !{!628, !23, i64 100}
!631 = !{!628, !4, i64 104}
!632 = !{!628, !4, i64 112}
!633 = !{i32 -2146210647, i32 -2146210608, i32 -2146210587, i32 -2146210550, i32 -2146210527, i32 -2146210657}
!634 = !{i32 -2146210223, i32 -2146210184, i32 -2146210163, i32 -2146210126, i32 -2146210103, i32 -2146210233}
!635 = !{!636, !4, i64 32}
!636 = !{!"svc_rqst", !24, i64 0, !24, i64 16, !4, i64 32, !34, i64 40, !25, i64 168, !34, i64 176, !25, i64 304, !4, i64 312, !4, i64 320, !4, i64 328, !4, i64 336, !637, i64 344, !4, i64 376, !4, i64 384, !23, i64 392, !25, i64 400, !64, i64 408, !64, i64 472, !5, i64 536, !4, i64 2608, !23, i64 2616, !4, i64 2624, !5, i64 2632, !23, i64 6776, !23, i64 6780, !23, i64 6784, !23, i64 6788, !23, i64 6792, !12, i64 6796, !4, i64 6800, !4, i64 6808, !4, i64 6816, !23, i64 6824, !638, i64 6832, !30, i64 6848, !4, i64 6856, !4, i64 6864, !23, i64 6872, !4, i64 6880, !23, i64 6888, !262, i64 6896, !4, i64 6984}
!637 = !{!"svc_cred", !23, i64 0, !23, i64 4, !4, i64 8, !23, i64 16, !4, i64 24}
!638 = !{!"cache_req", !4, i64 0, !23, i64 8}
!639 = !{!365, !4, i64 0}
!640 = !{!641, !23, i64 40}
!641 = !{!"svc_xprt_class", !4, i64 0, !4, i64 8, !4, i64 16, !24, i64 24, !23, i64 40}
!642 = !{!636, !4, i64 312}
!643 = !{!644, !23, i64 96}
!644 = !{!"svc_serv", !4, i64 0, !4, i64 8, !36, i64 16, !23, i64 88, !23, i64 92, !23, i64 96, !23, i64 100, !23, i64 104, !24, i64 112, !24, i64 128, !23, i64 144, !38, i64 152, !4, i64 280, !23, i64 288, !4, i64 296, !4, i64 304, !4, i64 312, !4, i64 320, !24, i64 328, !36, i64 344, !262, i64 416, !4, i64 504}
!645 = !{!644, !4, i64 504}
!646 = !{!636, !23, i64 6776}
!647 = !{!636, !23, i64 6792}
!648 = !{!636, !25, i64 168}
!649 = !{i32 -2142418625, i32 -2142418600, i32 -2142418330, i32 -2142418533, i32 -2142418502, i32 -2142418472}
!650 = !{!636, !23, i64 6888}
!651 = !{!636, !23, i64 392}
!652 = !{!636, !30, i64 6848}
!653 = !{!365, !4, i64 8}
!654 = !{!655, !4, i64 32}
!655 = !{!"svc_xprt_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64}
!656 = !{!636, !23, i64 6780}
!657 = !{!636, !23, i64 6784}
!658 = !{!636, !23, i64 6788}
!659 = !{!660, !23, i64 8}
!660 = !{!"svc_program", !4, i64 0, !23, i64 8, !23, i64 12, !23, i64 16, !23, i64 20, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56}
!661 = !{!660, !4, i64 56}
!662 = !{!660, !23, i64 20}
!663 = !{!660, !4, i64 24}
!664 = !{!665, !4, i64 8}
!665 = !{!"svc_version", !23, i64 0, !23, i64 4, !4, i64 8, !23, i64 16, !23, i64 20, !4, i64 24}
!666 = !{!665, !23, i64 4}
!667 = !{!668, !4, i64 0}
!668 = !{!"svc_procedure", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !23, i64 32, !23, i64 36, !23, i64 40, !23, i64 44, !23, i64 48}
!669 = !{!636, !4, i64 328}
!670 = !{!644, !4, i64 8}
!671 = !{!672, !23, i64 24}
!672 = !{!"svc_stat", !4, i64 0, !23, i64 8, !23, i64 12, !23, i64 16, !23, i64 20, !23, i64 24, !23, i64 28, !23, i64 32, !23, i64 36}
!673 = !{!668, !23, i64 40}
!674 = !{!636, !4, i64 6800}
!675 = !{!668, !23, i64 32}
!676 = !{!636, !4, i64 6808}
!677 = !{!668, !23, i64 36}
!678 = !{!668, !23, i64 48}
!679 = !{!665, !4, i64 24}
!680 = !{!668, !4, i64 8}
!681 = !{!668, !4, i64 24}
!682 = !{!668, !4, i64 16}
!683 = !{!672, !23, i64 28}
!684 = !{!672, !23, i64 32}
!685 = !{!660, !4, i64 32}
!686 = !{!660, !23, i64 12}
!687 = !{!660, !23, i64 16}
!688 = !{!636, !4, i64 336}
!689 = !{!690, !23, i64 16}
!690 = !{!"auth_ops", !4, i64 0, !4, i64 8, !23, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48}
!691 = !{!692, !4, i64 0}
!692 = !{!"va_format", !4, i64 0, !4, i64 8}
!693 = !{!692, !4, i64 8}
!694 = !{i32 527498}
!695 = !{!636, !4, i64 2608}
!696 = !{!636, !4, i64 2624}
!697 = !{!636, !4, i64 504}
!698 = !{!636, !23, i64 528}
!699 = !{!636, !23, i64 512}
!700 = !{!636, !23, i64 516}
!701 = !{!636, !23, i64 524}
!702 = !{!636, !4, i64 320}
!703 = !{!636, !4, i64 6816}
!704 = !{!705, !23, i64 112}
!705 = !{!"svc_pool", !23, i64 0, !36, i64 8, !24, i64 80, !24, i64 96, !23, i64 112, !24, i64 120, !706, i64 136, !23, i64 168}
!706 = !{!"svc_pool_stats", !25, i64 0, !25, i64 8, !25, i64 16, !25, i64 24}
!707 = !{!644, !23, i64 88}
!708 = !{i32 -2142446852, i32 -2142446827, i32 -2142446557, i32 -2142446760, i32 -2142446729, i32 -2142446699}
!709 = !{i32 -2142446315, i32 -2142446290, i32 -2142446020, i32 -2142446223, i32 -2142446192, i32 -2142446162}
!710 = !{!644, !4, i64 320}
!711 = !{!644, !4, i64 296}
!712 = !{!713, !23, i64 0}
!713 = !{!"svc_pool_map", !23, i64 0, !23, i64 4, !23, i64 8, !4, i64 16, !4, i64 24}
!714 = !{!713, !4, i64 24}
!715 = !{!713, !4, i64 16}
!716 = !{!713, !23, i64 8}
!717 = !{!705, !23, i64 0}
!718 = !{!644, !4, i64 312}
!719 = !{!644, !4, i64 280}
!720 = !{!636, !4, i64 6984}
!721 = !{!644, !23, i64 288}
!722 = !{!713, !23, i64 4}
!723 = !{!644, !23, i64 104}
!724 = !{!644, !23, i64 100}
!725 = !{!705, !4, i64 120}
!726 = !{i32 -2145247642}
!727 = !{!644, !4, i64 304}
!728 = !{!644, !4, i64 0}
!729 = !{!660, !4, i64 48}
!730 = !{!665, !23, i64 16}
!731 = !{!660, !4, i64 0}
!732 = !{i32 -2146663781}
!733 = !{!90, !4, i64 1880}
!734 = !{i32 -2146095653}
!735 = !{i32 -2146980863, i32 -2146980824, i32 -2146980803, i32 -2146980766, i32 -2146980743, i32 -2146980873}
!736 = !{i32 -2142458199, i32 -2142458174, i32 -2142457904, i32 -2142458107, i32 -2142458076, i32 -2142458046}
!737 = !{i32 -2142457141, i32 -2142457116, i32 -2142456846, i32 -2142457049, i32 -2142457018, i32 -2142456988}
!738 = !{!192, !12, i64 0}
!739 = !{!193, !23, i64 0}
!740 = !{!195, !12, i64 0}
!741 = !{!195, !23, i64 4}
!742 = !{!388, !4, i64 24}
!743 = !{!406, !12, i64 1336}
!744 = !{!370, !4, i64 976}
!745 = !{!370, !4, i64 984}
!746 = !{!370, !4, i64 992}
!747 = !{!388, !12, i64 4}
!748 = !{!365, !25, i64 472}
!749 = !{!406, !4, i64 1320}
!750 = !{i32 -2147076717, i32 -2147076678, i32 -2147076657, i32 -2147076620, i32 -2147076597, i32 -2147076727}
!751 = !{!370, !4, i64 64}
!752 = !{i32 -2147077425, i32 -2147077386, i32 -2147077365, i32 -2147077328, i32 -2147077305, i32 -2147077435}
!753 = !{i32 -2142140315, i32 -2142140290, i32 -2142140020, i32 -2142140223, i32 -2142140192, i32 -2142140162}
!754 = !{!370, !23, i64 1000}
!755 = !{!370, !23, i64 1004}
!756 = !{!370, !23, i64 1008}
!757 = !{!390, !25, i64 1048}
!758 = !{!672, !23, i64 20}
!759 = !{!636, !23, i64 464}
!760 = !{!636, !23, i64 448}
!761 = !{!636, !23, i64 452}
!762 = !{!636, !4, i64 376}
!763 = !{!672, !23, i64 16}
!764 = !{i32 -2142133965, i32 -2142133940, i32 -2142133670, i32 -2142133873, i32 -2142133842, i32 -2142133812}
!765 = !{!766, !23, i64 8}
!766 = !{!"cmsghdr", !25, i64 0, !23, i64 8, !23, i64 12}
!767 = !{!766, !23, i64 12}
!768 = !{!769, !23, i64 0}
!769 = !{!"in_pktinfo", !23, i64 0, !193, i64 4, !193, i64 8}
!770 = !{!769, !23, i64 4}
!771 = !{!766, !25, i64 0}
!772 = !{!773, !23, i64 16}
!773 = !{!"in6_pktinfo", !196, i64 0, !23, i64 16}
!774 = !{i64 0, i64 16, !166, i64 0, i64 16, !166, i64 0, i64 16, !166}
!775 = !{i32 431644}
!776 = !{i32 -2142134713, i32 -2142134688, i32 -2142134418, i32 -2142134621, i32 -2142134590, i32 -2142134560}
!777 = !{!370, !4, i64 952}
!778 = !{!636, !25, i64 400}
!779 = !{!365, !25, i64 608}
!780 = !{i32 -2142149520, i32 -2142149495, i32 -2142149225, i32 -2142149428, i32 -2142149397, i32 -2142149367}
!781 = !{i32 -2142140800, i32 -2142140775, i32 -2142140505, i32 -2142140708, i32 -2142140677, i32 -2142140647}
!782 = !{!365, !4, i64 64}
!783 = !{!636, !25, i64 304}
!784 = !{!672, !23, i64 12}
!785 = !{i32 -2147075038, i32 -2147074999, i32 -2147074978, i32 -2147074941, i32 -2147074918, i32 -2147075048, i32 360464}
!786 = !{i32 -2142157715, i32 -2142157690, i32 -2142157420, i32 -2142157623, i32 -2142157592, i32 -2142157562}
!787 = !{i32 -2145775292}
!788 = !{i32 -2145774132}
!789 = !{i32 -2145773981}
!790 = !{i32 -2146086922}
!791 = !{i32 -2146185987, i32 -2146185962, i32 -2146185692, i32 -2146185895, i32 -2146185864, i32 -2146185834}
!792 = !{i32 -2146186407, i32 -2146184429, i32 -2146184407, i32 -2146184394, i32 -2146184071, i32 -2146184004, i32 -2146184302, i32 -2146184275, i32 -2146184247, i32 -2146184217}
!793 = !{!794, !4, i64 24}
!794 = !{!"auth_domain", !366, i64 0, !67, i64 8, !4, i64 24, !4, i64 32}
!795 = !{i32 -2146216784, i32 -2146216745, i32 -2146216724, i32 -2146216687, i32 -2146216664, i32 -2146216655}
!796 = !{!794, !4, i64 32}
!797 = !{!690, !4, i64 40}
!798 = !{!690, !4, i64 48}
!799 = !{!690, !4, i64 8}
!800 = !{!690, !4, i64 24}
!801 = !{i32 453377}
!802 = !{!690, !4, i64 32}
!803 = !{!637, !4, i64 8}
!804 = !{!637, !4, i64 24}
!805 = !{!636, !4, i64 6856}
!806 = !{!637, !23, i64 0}
!807 = !{!637, !23, i64 4}
!808 = !{!636, !23, i64 360}
!809 = !{!636, !4, i64 352}
!810 = !{!365, !4, i64 944}
!811 = !{!636, !12, i64 40}
!812 = !{i32 -2142503482, i32 -2142503457, i32 -2142503187, i32 -2142503390, i32 -2142503359, i32 -2142503329}
!813 = !{!814, !4, i64 8}
!814 = !{!"sunrpc_net", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !116, i64 48, !24, i64 216, !36, i64 232, !4, i64 304, !4, i64 312, !36, i64 320, !23, i64 392, !116, i64 400, !262, i64 568, !4, i64 656, !23, i64 664, !23, i64 668, !22, i64 672, !4, i64 680, !23, i64 688}
!815 = !{!660, !4, i64 40}
!816 = !{i32 -2142503037, i32 -2142503012, i32 -2142502742, i32 -2142502945, i32 -2142502914, i32 -2142502884}
!817 = !{!818, !4, i64 64}
!818 = !{!"ip_map", !819, i64 0, !5, i64 40, !196, i64 48, !4, i64 64}
!819 = !{!"cache_head", !4, i64 0, !25, i64 8, !25, i64 16, !366, i64 24, !25, i64 32}
!820 = !{i32 -2142517360, i32 -2142517335, i32 -2142517065, i32 -2142517268, i32 -2142517237, i32 -2142517207}
!821 = !{i32 -2142516869, i32 -2142516844, i32 -2142516574, i32 -2142516777, i32 -2142516746, i32 -2142516716}
!822 = !{!365, !4, i64 320}
!823 = !{!814, !4, i64 16}
!824 = !{!825, !4, i64 48}
!825 = !{!"unix_gid", !819, i64 0, !23, i64 40, !4, i64 48}
!826 = !{i32 -2146135203, i32 -2146135164, i32 -2146135143, i32 -2146135106, i32 -2146135083, i32 -2146135213}
!827 = !{!825, !23, i64 40}
!828 = !{!819, !25, i64 8}
!829 = !{!830, !25, i64 216}
!830 = !{!"cache_detail", !4, i64 0, !23, i64 8, !4, i64 16, !395, i64 24, !22, i64 96, !4, i64 104, !4, i64 112, !4, i64 120, !4, i64 128, !4, i64 136, !4, i64 144, !4, i64 152, !4, i64 160, !4, i64 168, !4, i64 176, !4, i64 184, !25, i64 192, !24, i64 200, !25, i64 216, !23, i64 224, !24, i64 232, !22, i64 248, !25, i64 256, !25, i64 264, !5, i64 272, !4, i64 304}
!831 = !{!830, !4, i64 112}
!832 = !{i32 -2146135839, i32 -2146135800, i32 -2146135779, i32 -2146135742, i32 -2146135719, i32 -2146135849}
!833 = !{i32 -2146135627, i32 -2146135588, i32 -2146135567, i32 -2146135530, i32 -2146135507, i32 -2146135637}
!834 = !{i32 -2146132992, i32 -2146132953, i32 -2146132932, i32 -2146132895, i32 -2146132872, i32 -2146132863}
!835 = !{i32 -2145803876}
!836 = !{i32 -2145803733}
!837 = !{i32 -2146107508}
!838 = !{i32 -2145804158}
!839 = !{i32 515643}
!840 = !{!841, !4, i64 24}
!841 = !{!"unix_domain", !794, i64 0}
!842 = !{!841, !4, i64 32}
!843 = !{!825, !25, i64 32}
!844 = !{!825, !25, i64 8}
!845 = !{!103, !25, i64 0}
!846 = !{!830, !4, i64 304}
!847 = !{!818, !25, i64 32}
!848 = !{i32 -2146993426, i32 -2146993387, i32 -2146993366, i32 -2146993329, i32 -2146993306, i32 -2146993436}
!849 = !{!818, !25, i64 8}
!850 = !{!851, !23, i64 184}
!851 = !{!"net_device", !5, i64 0, !67, i64 16, !4, i64 32, !25, i64 40, !25, i64 48, !25, i64 56, !23, i64 64, !25, i64 72, !24, i64 80, !24, i64 96, !24, i64 112, !24, i64 128, !43, i64 144, !43, i64 152, !43, i64 160, !43, i64 168, !43, i64 176, !23, i64 184, !23, i64 188, !852, i64 192, !41, i64 376, !4, i64 384, !4, i64 392, !4, i64 400, !4, i64 408, !4, i64 416, !23, i64 424, !23, i64 428, !12, i64 432, !12, i64 434, !5, i64 436, !5, i64 437, !5, i64 438, !5, i64 439, !23, i64 440, !12, i64 444, !12, i64 446, !12, i64 448, !12, i64 450, !5, i64 452, !5, i64 484, !5, i64 485, !5, i64 486, !12, i64 488, !36, i64 496, !853, i64 568, !853, i64 592, !853, i64 616, !4, i64 640, !30, i64 648, !23, i64 652, !23, i64 656, !4, i64 664, !4, i64 672, !4, i64 680, !4, i64 688, !4, i64 696, !4, i64 704, !4, i64 712, !4, i64 720, !25, i64 728, !4, i64 736, !4, i64 744, !23, i64 752, !23, i64 756, !4, i64 760, !4, i64 768, !4, i64 776, !5, i64 784, !4, i64 832, !23, i64 840, !23, i64 844, !4, i64 848, !25, i64 856, !36, i64 864, !4, i64 936, !4, i64 944, !25, i64 952, !23, i64 960, !38, i64 968, !4, i64 1096, !24, i64 1104, !67, i64 1120, !24, i64 1136, !5, i64 1152, !30, i64 1153, !5, i64 1154, !4, i64 1160, !4, i64 1168, !4, i64 1176, !5, i64 1184, !4, i64 1192, !4, i64 1200, !854, i64 1208, !5, i64 2344, !4, i64 2376, !23, i64 2384, !12, i64 2388, !4, i64 2392, !5, i64 2400, !5, i64 2402, !5, i64 2466, !23, i64 2484, !4, i64 2488, !4, i64 2496, !4, i64 2504, !23, i64 2512, !862, i64 2520}
!852 = !{!"net_device_stats", !25, i64 0, !25, i64 8, !25, i64 16, !25, i64 24, !25, i64 32, !25, i64 40, !25, i64 48, !25, i64 56, !25, i64 64, !25, i64 72, !25, i64 80, !25, i64 88, !25, i64 96, !25, i64 104, !25, i64 112, !25, i64 120, !25, i64 128, !25, i64 136, !25, i64 144, !25, i64 152, !25, i64 160, !25, i64 168, !25, i64 176}
!853 = !{!"netdev_hw_addr_list", !24, i64 0, !23, i64 16}
!854 = !{!"device", !4, i64 0, !4, i64 8, !855, i64 16, !4, i64 80, !4, i64 88, !116, i64 96, !4, i64 264, !4, i64 272, !4, i64 280, !856, i64 288, !4, i64 880, !23, i64 888, !4, i64 896, !43, i64 904, !4, i64 912, !24, i64 920, !4, i64 936, !859, i64 944, !4, i64 960, !860, i64 968, !23, i64 976, !23, i64 980, !36, i64 984, !24, i64 1056, !861, i64 1072, !4, i64 1104, !4, i64 1112, !4, i64 1120, !4, i64 1128}
!855 = !{!"kobject", !4, i64 0, !24, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !366, i64 56, !23, i64 60, !23, i64 60, !23, i64 60, !23, i64 60, !23, i64 60}
!856 = !{!"dev_pm_info", !857, i64 0, !23, i64 4, !23, i64 4, !30, i64 4, !30, i64 4, !30, i64 4, !30, i64 4, !36, i64 8, !24, i64 80, !858, i64 96, !4, i64 192, !30, i64 200, !30, i64 200, !38, i64 208, !25, i64 336, !40, i64 344, !262, i64 424, !22, i64 512, !22, i64 516, !23, i64 520, !23, i64 520, !23, i64 520, !23, i64 520, !23, i64 520, !23, i64 520, !23, i64 521, !23, i64 521, !23, i64 521, !23, i64 521, !23, i64 521, !5, i64 524, !5, i64 528, !23, i64 532, !23, i64 536, !25, i64 544, !25, i64 552, !25, i64 560, !25, i64 568, !4, i64 576, !4, i64 584}
!857 = !{!"pm_message", !23, i64 0}
!858 = !{!"completion", !23, i64 0, !262, i64 8}
!859 = !{!"dev_archdata", !4, i64 0, !4, i64 8}
!860 = !{!"acpi_dev_node", !4, i64 0}
!861 = !{!"klist_node", !4, i64 0, !24, i64 8, !366, i64 24}
!862 = !{!"pm_qos_request", !101, i64 0, !23, i64 40, !363, i64 48}
!863 = !{!851, !4, i64 1096}
!864 = !{i32 -2143160313}
!865 = !{!12, !12, i64 0}
!866 = !{!867, !4, i64 8}
!867 = !{!"rpcb_info", !23, i64 0, !4, i64 8}
!868 = !{!867, !23, i64 0}
!869 = !{!870, !23, i64 8}
!870 = !{!"rpcbind_args", !4, i64 0, !23, i64 8, !23, i64 12, !23, i64 16, !12, i64 20, !4, i64 24, !4, i64 32, !4, i64 40, !23, i64 48}
!871 = !{!870, !23, i64 12}
!872 = !{!870, !23, i64 16}
!873 = !{!870, !12, i64 20}
!874 = !{!870, !4, i64 0}
!875 = !{!870, !23, i64 48}
!876 = !{!870, !4, i64 24}
!877 = !{!870, !4, i64 32}
!878 = !{!870, !4, i64 40}
!879 = !{i32 -2142521804, i32 -2142521779, i32 -2142521509, i32 -2142521712, i32 -2142521681, i32 -2142521651}
!880 = !{i32 -2142559303}
!881 = !{i32 -2147028955, i32 -2147028916, i32 -2147028895, i32 -2147028858, i32 -2147028835, i32 -2147028965}
!882 = !{i32 -2142559251}
!883 = !{!83, !4, i64 40}
!884 = !{i32 -2147027742, i32 -2147027703, i32 -2147027682, i32 -2147027645, i32 -2147027622, i32 -2147027752, i32 406974}
!885 = !{i32 479406}
!886 = !{i32 -2145805764}
!887 = !{i32 -2145805621}
!888 = !{i32 -2146165271}
!889 = !{i32 -2145806046}
!890 = !{!814, !4, i64 304}
!891 = !{!814, !4, i64 312}
!892 = !{!814, !23, i64 392}
!893 = !{i32 -2142538477, i32 -2142538452, i32 -2142538182, i32 -2142538385, i32 -2142538354, i32 -2142538324}
!894 = !{i32 -2142537986, i32 -2142537961, i32 -2142537691, i32 -2142537894, i32 -2142537863, i32 -2142537833}
!895 = !{i32 -2142537555}
!896 = !{!54, !25, i64 0}
!897 = !{i32 -2144119061, i32 -2144119036, i32 -2144118766, i32 -2144118969, i32 -2144118938, i32 -2144118908}
!898 = !{!899, !23, i64 16}
!899 = !{!"scatterlist", !25, i64 0, !25, i64 8, !23, i64 16, !23, i64 20, !43, i64 24, !23, i64 32}
!900 = !{!899, !23, i64 20}
!901 = !{!899, !25, i64 8}
!902 = !{i32 -2144122065, i32 -2144122040, i32 -2144121770, i32 -2144121973, i32 -2144121942, i32 -2144121912}
!903 = !{!899, !25, i64 0}
!904 = !{i32 -2144121519, i32 -2144121494, i32 -2144121224, i32 -2144121427, i32 -2144121396, i32 -2144121366}
!905 = !{i32 -2144120956, i32 -2144120931, i32 -2144120661, i32 -2144120864, i32 -2144120833, i32 -2144120803}
!906 = !{!907, !23, i64 4}
!907 = !{!"xdr_array2_desc", !23, i64 0, !23, i64 4, !23, i64 8, !4, i64 16}
!908 = !{!907, !23, i64 0}
!909 = !{!907, !23, i64 8}
!910 = !{!907, !4, i64 16}
!911 = !{i32 482780}
!912 = !{i32 -2144392724}
!913 = !{i32 -2144392581}
!914 = !{i32 -2146161897}
!915 = !{i32 -2144392818}
!916 = !{!917, !23, i64 0}
!917 = !{!"xdr_netobj", !23, i64 0, !4, i64 8}
!918 = !{!917, !4, i64 8}
!919 = !{i64 0, i64 8, !28, i64 8, i64 8, !88}
!920 = !{!921, !4, i64 8}
!921 = !{!"xdr_stream", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !148, i64 32, !4, i64 48, !23, i64 56}
!922 = !{!921, !23, i64 56}
!923 = !{!921, !4, i64 48}
!924 = !{!921, !4, i64 0}
!925 = !{!921, !4, i64 16}
!926 = !{!921, !4, i64 24}
!927 = !{i32 -2144077763, i32 -2144077738, i32 -2144077468, i32 -2144077671, i32 -2144077640, i32 -2144077610}
!928 = !{i32 -2144088255, i32 -2144088230, i32 -2144087960, i32 -2144088163, i32 -2144088132, i32 -2144088102}
!929 = !{!921, !4, i64 32}
!930 = !{!921, !25, i64 40}
!931 = !{i32 -2144071139, i32 -2144071114, i32 -2144070844, i32 -2144071047, i32 -2144071016, i32 -2144070986}
!932 = !{i32 -2144075055, i32 -2144075030, i32 -2144074760, i32 -2144074963, i32 -2144074932, i32 -2144074902}
!933 = !{i32 -2144074530, i32 -2144074505, i32 -2144074235, i32 -2144074438, i32 -2144074407, i32 -2144074377}
!934 = !{i32 -2144073993, i32 -2144073968, i32 -2144073698, i32 -2144073901, i32 -2144073870, i32 -2144073840}
!935 = !{i32 -2142523961, i32 -2142523936, i32 -2142523666, i32 -2142523869, i32 -2142523838, i32 -2142523808}
!936 = !{i32 -2142523470, i32 -2142523445, i32 -2142523175, i32 -2142523378, i32 -2142523347, i32 -2142523317}
!937 = !{i32 -2145833099}
!938 = !{i32 -2145832956}
!939 = !{i32 -2146192606}
!940 = !{i32 -2145833381}
!941 = !{!942, !4, i64 1032}
!942 = !{!"rpc_inode", !943, i64 0, !4, i64 1032, !4, i64 1040, !262, i64 1048}
!943 = !{!"inode", !12, i64 0, !12, i64 2, !23, i64 4, !23, i64 8, !23, i64 12, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !25, i64 64, !5, i64 72, !23, i64 76, !43, i64 80, !103, i64 88, !103, i64 104, !103, i64 120, !36, i64 136, !12, i64 208, !23, i64 212, !25, i64 216, !25, i64 224, !116, i64 232, !25, i64 400, !67, i64 408, !24, i64 424, !24, i64 440, !24, i64 456, !5, i64 472, !43, i64 488, !22, i64 496, !22, i64 500, !22, i64 504, !4, i64 512, !4, i64 520, !944, i64 528, !5, i64 960, !24, i64 976, !5, i64 992, !23, i64 1000, !23, i64 1004, !98, i64 1008, !22, i64 1016, !4, i64 1024}
!944 = !{!"address_space", !4, i64 0, !945, i64 8, !36, i64 24, !23, i64 96, !946, i64 104, !24, i64 112, !116, i64 128, !25, i64 296, !25, i64 304, !4, i64 312, !25, i64 320, !4, i64 328, !36, i64 336, !24, i64 408, !4, i64 424}
!945 = !{!"radix_tree_root", !23, i64 0, !23, i64 4, !4, i64 8}
!946 = !{!"rb_root", !4, i64 0}
!947 = !{!948, !4, i64 304}
!948 = !{!"file", !5, i64 0, !949, i64 16, !4, i64 32, !4, i64 40, !36, i64 48, !23, i64 120, !41, i64 128, !23, i64 136, !23, i64 140, !43, i64 144, !950, i64 152, !4, i64 248, !951, i64 256, !43, i64 288, !4, i64 296, !4, i64 304, !24, i64 312, !24, i64 328, !4, i64 344, !25, i64 352}
!949 = !{!"path", !4, i64 0, !4, i64 8}
!950 = !{!"fown_struct", !395, i64 0, !4, i64 72, !5, i64 80, !23, i64 84, !23, i64 88, !23, i64 92}
!951 = !{!"file_ra_state", !25, i64 0, !23, i64 8, !23, i64 12, !23, i64 16, !23, i64 20, !43, i64 24}
!952 = !{!953, !23, i64 24}
!953 = !{!"cache_reader", !954, i64 0, !23, i64 24}
!954 = !{!"cache_queue", !24, i64 0, !23, i64 16}
!955 = !{!954, !23, i64 16}
!956 = !{!957, !23, i64 44}
!957 = !{!"cache_request", !954, i64 0, !4, i64 24, !4, i64 32, !23, i64 40, !23, i64 44}
!958 = !{!954, !4, i64 0}
!959 = !{!830, !25, i64 256}
!960 = !{!830, !4, i64 0}
!961 = !{i32 -2146096494, i32 -2146096455, i32 -2146096434, i32 -2146096397, i32 -2146096374, i32 -2146096504}
!962 = !{!948, !23, i64 140}
!963 = !{!953, !23, i64 16}
!964 = !{i32 -2146096706, i32 -2146096667, i32 -2146096646, i32 -2146096609, i32 -2146096586, i32 -2146096716}
!965 = !{!948, !4, i64 32}
!966 = !{!957, !23, i64 40}
!967 = !{i32 -2143338607}
!968 = !{!969, !4, i64 0}
!969 = !{!"poll_table_struct", !4, i64 0, !25, i64 8}
!970 = !{!948, !4, i64 344}
!971 = !{!830, !4, i64 136}
!972 = !{!953, !4, i64 0}
!973 = !{!957, !23, i64 16}
!974 = !{!957, !4, i64 24}
!975 = !{!957, !4, i64 32}
!976 = !{!830, !4, i64 128}
!977 = !{i32 -2146096918, i32 -2146096879, i32 -2146096858, i32 -2146096821, i32 -2146096798, i32 -2146096928}
!978 = !{!979, !4, i64 0}
!979 = !{!"handle", !4, i64 0}
!980 = !{!981, !4, i64 240}
!981 = !{!"seq_file", !4, i64 0, !25, i64 8, !25, i64 16, !25, i64 24, !43, i64 32, !43, i64 40, !43, i64 48, !116, i64 56, !4, i64 224, !23, i64 232, !4, i64 240}
!982 = !{!830, !4, i64 16}
!983 = !{!830, !23, i64 8}
!984 = !{!819, !4, i64 0}
!985 = !{!830, !4, i64 144}
!986 = !{!819, !25, i64 32}
!987 = !{!819, !25, i64 16}
!988 = !{i32 -2146896541, i32 -2146896502, i32 -2146896481, i32 -2146896444, i32 -2146896421, i32 -2146896551}
!989 = !{!830, !25, i64 192}
!990 = !{i32 -2143364471}
!991 = !{i32 -2146895328, i32 -2146895289, i32 -2146895268, i32 -2146895231, i32 -2146895208, i32 -2146895338, i32 539388}
!992 = !{!830, !4, i64 120}
!993 = !{!994, !4, i64 0}
!994 = !{!"cache_deferred_req", !67, i64 0, !24, i64 16, !4, i64 32, !4, i64 40, !4, i64 48}
!995 = !{!994, !4, i64 32}
!996 = !{!994, !4, i64 48}
!997 = !{i32 -2146897249, i32 -2146897210, i32 -2146897189, i32 -2146897152, i32 -2146897129, i32 -2146897259}
!998 = !{!638, !23, i64 8}
!999 = !{!638, !4, i64 0}
!1000 = !{i64 0, i64 4, !49, i64 8, i64 4, !49, i64 8, i64 2, !865, i64 10, i64 2, !865, i64 12, i64 4, !49, i64 16, i64 4, !49, i64 24, i64 8, !28, i64 32, i64 8, !28, i64 40, i64 16, !166, i64 56, i64 8, !28, i64 64, i64 4, !49, i64 72, i64 8, !88, i64 8, i64 24, !166, i64 32, i64 8, !28, i64 40, i64 16, !166, i64 56, i64 8, !28, i64 64, i64 4, !49, i64 72, i64 8, !88, i64 80, i64 8, !28, i64 88, i64 8, !28}
!1001 = !{!858, !23, i64 0}
!1002 = !{i32 -2143366839}
!1003 = !{i32 -2146894862, i32 -2146894823, i32 -2146894802, i32 -2146894765, i32 -2146894742, i32 -2146894872, i32 540640}
!1004 = !{!830, !25, i64 264}
!1005 = !{!830, !4, i64 152}
!1006 = !{i32 -2146094071, i32 -2146094032, i32 -2146094011, i32 -2146093974, i32 -2146093951, i32 -2146093942}
!1007 = !{!830, !23, i64 224}
!1008 = !{!830, !4, i64 104}
!1009 = !{!814, !4, i64 0}
!1010 = !{i32 -2143369340, i32 -2143369315, i32 -2143369045, i32 -2143369248, i32 -2143369217, i32 -2143369187}
!1011 = !{i32 -2143368849, i32 -2143368824, i32 -2143368554, i32 -2143368757, i32 -2143368726, i32 -2143368696}
!1012 = !{i32 -2145884592}
!1013 = !{i32 -2145884449}
!1014 = !{i32 -2146068587}
!1015 = !{i32 -2145884874}
!1016 = !{!830, !4, i64 184}
!1017 = !{!830, !4, i64 160}
!1018 = !{!830, !4, i64 176}
!1019 = !{!830, !4, i64 168}
!1020 = !{!994, !4, i64 16}
!1021 = !{!994, !4, i64 40}
!1022 = !{!814, !4, i64 40}
!1023 = !{i32 -2142245357, i32 -2142245332, i32 -2142245062, i32 -2142245265, i32 -2142245234, i32 -2142245204}
!1024 = !{i32 -2142244866, i32 -2142244841, i32 -2142244571, i32 -2142244774, i32 -2142244743, i32 -2142244713}
!1025 = !{i32 -2145806260}
!1026 = !{i32 -2145806117}
!1027 = !{i32 -2146165767}
!1028 = !{i32 -2145806542}
!1029 = !{!416, !23, i64 0}
!1030 = !{!416, !23, i64 4}
!1031 = !{!257, !4, i64 96}
!1032 = !{!1033, !4, i64 48}
!1033 = !{!"dentry", !23, i64 0, !115, i64 4, !1034, i64 8, !4, i64 24, !246, i64 32, !4, i64 48, !5, i64 56, !23, i64 88, !36, i64 96, !4, i64 168, !4, i64 176, !25, i64 184, !4, i64 192, !24, i64 200, !5, i64 216, !24, i64 232, !67, i64 248}
!1034 = !{!"hlist_bl_node", !4, i64 0, !4, i64 8}
!1035 = !{!942, !4, i64 1040}
!1036 = !{!1037, !23, i64 52}
!1037 = !{!"rpc_pipe", !24, i64 0, !24, i64 16, !24, i64 32, !23, i64 48, !23, i64 52, !23, i64 56, !23, i64 60, !363, i64 64, !4, i64 288, !36, i64 296, !4, i64 368}
!1038 = !{!1037, !23, i64 56}
!1039 = !{!1037, !23, i64 48}
!1040 = !{!1037, !4, i64 368}
!1041 = !{!1037, !4, i64 288}
!1042 = !{!1043, !4, i64 32}
!1043 = !{!"rpc_pipe_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32}
!1044 = !{!1043, !4, i64 16}
!1045 = !{!1033, !23, i64 88}
!1046 = !{!1047, !23, i64 40}
!1047 = !{!"rpc_pipe_msg", !24, i64 0, !4, i64 16, !25, i64 24, !25, i64 32, !23, i64 40}
!1048 = !{!1043, !4, i64 0}
!1049 = !{!1043, !4, i64 8}
!1050 = !{!943, !4, i64 40}
!1051 = !{!943, !25, i64 64}
!1052 = !{!943, !4, i64 512}
!1053 = !{!1033, !4, i64 40}
!1054 = !{i32 -2146733895}
!1055 = !{!90, !4, i64 1984}
!1056 = !{!943, !12, i64 0}
!1057 = !{i64 0, i64 8, !88, i64 8, i64 8, !88}
!1058 = !{!943, !4, i64 32}
!1059 = !{!1037, !4, i64 0}
!1060 = !{!1047, !25, i64 24}
!1061 = !{!1047, !25, i64 32}
!1062 = !{i32 -2142231978}
!1063 = !{!814, !23, i64 688}
!1064 = !{!1043, !4, i64 24}
!1065 = !{!1037, !23, i64 60}
!1066 = !{!1047, !4, i64 16}
!1067 = !{!1068, !4, i64 0}
!1068 = !{!"rpc_filelist", !4, i64 0, !4, i64 8, !12, i64 16}
!1069 = !{!1068, !12, i64 16}
!1070 = !{i32 -2142223926, i32 -2142223901, i32 -2142223631, i32 -2142223834, i32 -2142223803, i32 -2142223773}
!1071 = !{!1068, !4, i64 8}
!1072 = !{i32 -2142224393, i32 -2142224368, i32 -2142224098, i32 -2142224301, i32 -2142224270, i32 -2142224240}
!1073 = !{!948, !4, i64 24}
!1074 = !{i32 -2146188748, i32 -2146188709, i32 -2146188688, i32 -2146188651, i32 -2146188628, i32 -2146188619}
!1075 = !{!1034, !4, i64 8}
!1076 = !{!814, !23, i64 668}
!1077 = !{!243, !4, i64 40}
!1078 = !{i32 -2146193462, i32 -2146193423, i32 -2146193402, i32 -2146193365, i32 -2146193342, i32 -2146193472}
!1079 = !{!257, !25, i64 24}
!1080 = !{!257, !5, i64 20}
!1081 = !{!257, !25, i64 88}
!1082 = !{!257, !4, i64 48}
!1083 = !{!257, !23, i64 1888}
!1084 = !{i32 -2146193886, i32 -2146193847, i32 -2146193826, i32 -2146193789, i32 -2146193766, i32 -2146193896}
!1085 = !{!705, !25, i64 136}
!1086 = !{!705, !25, i64 144}
!1087 = !{!705, !25, i64 152}
!1088 = !{!705, !25, i64 160}
!1089 = !{!641, !4, i64 0}
!1090 = !{!365, !12, i64 344}
!1091 = !{i32 -2146118789, i32 -2146118750, i32 -2146118729, i32 -2146118692, i32 -2146118669, i32 -2146118660}
!1092 = !{i32 -2146979223, i32 -2146979184, i32 -2146979163, i32 -2146979126, i32 -2146979103, i32 -2146979233}
!1093 = !{i32 -2146977302, i32 -2146977263, i32 -2146977242, i32 -2146977205, i32 -2146977182, i32 -2146977312, i32 457414}
!1094 = !{i32 -2142601795, i32 -2142601770, i32 -2142601500, i32 -2142601703, i32 -2142601672, i32 -2142601642}
!1095 = !{!655, !4, i64 56}
!1096 = !{!644, !23, i64 144}
!1097 = !{!365, !4, i64 328}
!1098 = !{i32 -2146978515, i32 -2146978476, i32 -2146978455, i32 -2146978418, i32 -2146978395, i32 -2146978525}
!1099 = !{!1100, !4, i64 16}
!1100 = !{!"svc_xpt_user", !24, i64 0, !4, i64 16}
!1101 = !{!641, !4, i64 8}
!1102 = !{!655, !4, i64 64}
!1103 = !{i32 -2146121636, i32 -2146121597, i32 -2146121576, i32 -2146121539, i32 -2146121516, i32 -2146121646}
!1104 = !{i32 -2146121000, i32 -2146120961, i32 -2146120940, i32 -2146120903, i32 -2146120880, i32 -2146121010}
!1105 = !{!655, !4, i64 48}
!1106 = !{!636, !4, i64 384}
!1107 = !{!636, !23, i64 6824}
!1108 = !{i32 -2146121848, i32 -2146121809, i32 -2146121788, i32 -2146121751, i32 -2146121728, i32 -2146121858}
!1109 = !{i32 -2142632137}
!1110 = !{i32 -2142628032}
!1111 = !{i32 -2142626154}
!1112 = !{i32 -2142626011}
!1113 = !{!705, !4, i64 80}
!1114 = !{!365, !25, i64 56}
!1115 = !{!655, !4, i64 16}
!1116 = !{i32 -2146093305}
!1117 = !{i32 -2146661433}
!1118 = !{!636, !4, i64 6832}
!1119 = !{!672, !23, i64 8}
!1120 = !{i32 -2142613939}
!1121 = !{i32 -2142612654}
!1122 = !{!636, !23, i64 6840}
!1123 = !{!705, !23, i64 168}
!1124 = !{i32 -2142610909}
!1125 = !{i32 -2142609664}
!1126 = !{!655, !4, i64 8}
!1127 = !{!655, !4, i64 24}
!1128 = !{!1129, !4, i64 328}
!1129 = !{!"svc_deferred_req", !23, i64 0, !4, i64 8, !34, i64 16, !25, i64 144, !34, i64 152, !25, i64 280, !994, i64 288, !25, i64 344, !23, i64 352, !5, i64 356}
!1130 = !{!1129, !23, i64 0}
!1131 = !{!1129, !25, i64 144}
!1132 = !{i64 0, i64 2, !865, i64 2, i64 126, !166}
!1133 = !{!1129, !23, i64 352}
!1134 = !{!1129, !25, i64 344}
!1135 = !{!1129, !4, i64 8}
!1136 = !{!1129, !4, i64 336}
!1137 = !{!644, !23, i64 92}
!1138 = !{!644, !4, i64 136}
!1139 = !{!644, !4, i64 184}
!1140 = !{i32 -2146122060, i32 -2146122021, i32 -2146122000, i32 -2146121963, i32 -2146121940, i32 -2146122070}
!1141 = !{!705, !4, i64 96}
!1142 = !{i32 460665, i32 460676}
!1143 = !{!641, !4, i64 16}
!1144 = !{!655, !4, i64 0}
!1145 = !{i32 -2146121424, i32 -2146121385, i32 -2146121364, i32 -2146121327, i32 -2146121304, i32 -2146121434}
!1146 = !{!655, !4, i64 40}
!1147 = !{!365, !4, i64 40}
!1148 = !{!63, !4, i64 384}
!1149 = !{!33, !23, i64 1928}
!1150 = !{i32 -2147015486, i32 -2147015447, i32 -2147015426, i32 -2147015389, i32 -2147015366, i32 -2147015496}
!1151 = !{i32 -2142690307}
!1152 = !{i32 -2147014778, i32 -2147014739, i32 -2147014718, i32 -2147014681, i32 -2147014658, i32 -2147014788}
!1153 = !{i32 -2142689229}
!1154 = !{i32 -2142519319, i32 -2142519294, i32 -2142519024, i32 -2142519227, i32 -2142519196, i32 -2142519166}
!1155 = !{i32 -2142518828, i32 -2142518803, i32 -2142518533, i32 -2142518736, i32 -2142518705, i32 -2142518675}
!1156 = !{i32 -2145828496}
!1157 = !{i32 -2145828353}
!1158 = !{i32 -2146188003}
!1159 = !{i32 -2145828778}
!1160 = !{!672, !4, i64 0}
!1161 = !{!57, !4, i64 0}
!1162 = !{!57, !23, i64 8}
!1163 = !{!57, !23, i64 12}
!1164 = !{!57, !23, i64 16}
!1165 = !{!57, !23, i64 20}
!1166 = !{!83, !4, i64 120}
!1167 = !{!1168, !25, i64 0}
!1168 = !{!"rpc_iostats", !25, i64 0, !25, i64 8, !25, i64 16, !43, i64 24, !43, i64 32, !5, i64 40, !5, i64 48, !5, i64 56}
!1169 = !{!1168, !25, i64 8}
!1170 = !{!1168, !25, i64 16}
!1171 = !{!1168, !43, i64 24}
!1172 = !{!1168, !43, i64 32}
!1173 = !{!51, !23, i64 40}
!1174 = !{!672, !23, i64 36}
!1175 = !{!1176, !4, i64 144}
!1176 = !{!"net", !22, i64 0, !22, i64 4, !36, i64 8, !24, i64 80, !24, i64 96, !24, i64 112, !4, i64 128, !23, i64 136, !4, i64 144, !4, i64 152, !1177, i64 160, !4, i64 248, !4, i64 256, !24, i64 264, !4, i64 280, !4, i64 288, !23, i64 296, !23, i64 300, !24, i64 304, !4, i64 320, !1180, i64 328, !1181, i64 352, !1182, i64 464, !1183, i64 640, !1184, i64 704, !1187, i64 1344, !1190, i64 2368, !1191, i64 2832, !1192, i64 2848, !1193, i64 2968, !1194, i64 3208, !1202, i64 3776, !4, i64 4160, !4, i64 4168, !393, i64 4176, !4, i64 4272, !1203, i64 4288, !4, i64 5440, !4, i64 5448, !22, i64 5456}
!1177 = !{!"ctl_table_set", !4, i64 0, !1178, i64 8}
!1178 = !{!"ctl_dir", !1179, i64 0, !946, i64 72}
!1179 = !{!"ctl_table_header", !5, i64 0, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64}
!1180 = !{!"netns_core", !4, i64 0, !23, i64 8, !4, i64 16}
!1181 = !{!"netns_mib", !5, i64 0, !5, i64 8, !5, i64 16, !5, i64 24, !5, i64 32, !5, i64 40, !4, i64 48, !4, i64 56, !5, i64 64, !5, i64 72, !5, i64 80, !5, i64 88, !4, i64 96, !5, i64 104}
!1182 = !{!"netns_packet", !116, i64 0, !98, i64 168}
!1183 = !{!"netns_unix", !23, i64 0, !4, i64 8}
!1184 = !{!"netns_ipv4", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !30, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !23, i64 96, !4, i64 104, !4, i64 112, !4, i64 120, !4, i64 128, !4, i64 136, !23, i64 144, !1185, i64 192, !4, i64 448, !4, i64 456, !4, i64 464, !4, i64 472, !4, i64 480, !4, i64 488, !23, i64 496, !23, i64 500, !23, i64 504, !23, i64 508, !23, i64 512, !23, i64 516, !23, i64 520, !5, i64 524, !5, i64 536, !22, i64 560, !24, i64 568, !4, i64 584}
!1185 = !{!"netns_frags", !23, i64 0, !24, i64 8, !36, i64 24, !1186, i64 128, !23, i64 232, !23, i64 236, !23, i64 240}
!1186 = !{!"percpu_counter", !111, i64 0, !43, i64 72, !24, i64 80, !4, i64 96}
!1187 = !{!"netns_ipv6", !1188, i64 0, !4, i64 80, !4, i64 88, !4, i64 96, !1185, i64 128, !4, i64 384, !4, i64 392, !4, i64 400, !4, i64 408, !4, i64 416, !4, i64 424, !4, i64 432, !38, i64 440, !4, i64 568, !4, i64 576, !1189, i64 640, !23, i64 896, !25, i64 904, !4, i64 912, !4, i64 920, !4, i64 928, !4, i64 936, !4, i64 944, !4, i64 952, !4, i64 960, !4, i64 968, !24, i64 976, !4, i64 992, !22, i64 1000}
!1188 = !{!"netns_sysctl_ipv6", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !23, i64 40, !23, i64 44, !23, i64 48, !23, i64 52, !23, i64 56, !23, i64 60, !23, i64 64, !23, i64 68, !23, i64 72, !23, i64 76}
!1189 = !{!"dst_ops", !12, i64 0, !12, i64 2, !23, i64 4, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112, !1186, i64 128}
!1190 = !{!"netns_sctp", !5, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !24, i64 32, !24, i64 48, !38, i64 64, !24, i64 192, !36, i64 208, !36, i64 280, !23, i64 352, !23, i64 356, !23, i64 360, !23, i64 364, !23, i64 368, !23, i64 372, !23, i64 376, !4, i64 384, !23, i64 392, !23, i64 396, !23, i64 400, !23, i64 404, !23, i64 408, !23, i64 412, !23, i64 416, !23, i64 420, !23, i64 424, !23, i64 428, !23, i64 432, !23, i64 436, !23, i64 440, !23, i64 444, !23, i64 448, !23, i64 452, !25, i64 456}
!1191 = !{!"netns_dccp", !4, i64 0, !4, i64 8}
!1192 = !{!"netns_nf", !4, i64 0, !5, i64 8, !4, i64 112}
!1193 = !{!"netns_xt", !5, i64 0, !30, i64 208, !4, i64 216, !4, i64 224, !4, i64 232}
!1194 = !{!"netns_ct", !22, i64 0, !23, i64 4, !23, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !1195, i64 40, !1195, i64 48, !1195, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !23, i64 88, !23, i64 92, !23, i64 96, !23, i64 100, !23, i64 104, !23, i64 108, !23, i64 112, !30, i64 116, !1196, i64 120, !23, i64 440, !5, i64 444, !4, i64 448, !23, i64 456, !4, i64 464, !4, i64 472, !4, i64 480, !4, i64 488, !4, i64 496, !4, i64 504}
!1195 = !{!"hlist_nulls_head", !4, i64 0}
!1196 = !{!"nf_ip_net", !1197, i64 0, !1199, i64 48, !1200, i64 160, !1201, i64 208, !1201, i64 256, !4, i64 304, !4, i64 312}
!1197 = !{!"nf_generic_net", !1198, i64 0, !23, i64 40}
!1198 = !{!"nf_proto_net", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !23, i64 32}
!1199 = !{!"nf_tcp_net", !1198, i64 0, !5, i64 40, !23, i64 96, !23, i64 100, !23, i64 104}
!1200 = !{!"nf_udp_net", !1198, i64 0, !5, i64 40}
!1201 = !{!"nf_icmp_net", !1198, i64 0, !23, i64 40}
!1202 = !{!"netns_nf_frag", !1188, i64 0, !1185, i64 128}
!1203 = !{!"netns_xfrm", !24, i64 0, !4, i64 16, !4, i64 24, !4, i64 32, !23, i64 40, !23, i64 44, !40, i64 48, !98, i64 128, !40, i64 136, !262, i64 216, !24, i64 304, !4, i64 320, !23, i64 328, !5, i64 336, !5, i64 384, !5, i64 480, !40, i64 504, !4, i64 584, !4, i64 592, !23, i64 600, !23, i64 604, !23, i64 608, !23, i64 612, !4, i64 616, !1189, i64 640, !1189, i64 896}
!1204 = !{!128, !25, i64 32}
!1205 = !{i32 -2143809955, i32 -2143809948, i32 -2143809934, i32 -2143809932, i32 -2143810605, i32 -2143809892, i32 -2143809844, i32 -2143809778, i32 -2143809716, i32 -2143809664, i32 -2143810525, i32 -2143810500, i32 -2143809459, i32 -2143810427, i32 -2143810402, i32 -2143809199, i32 -2143809275, i32 -2143809182, i32 -2143809231, i32 -2143811115, i32 -2143811074, i32 -2143808416, i32 -2143808402, i32 -2143808400, i32 -2143809073, i32 -2143808360, i32 -2143808312, i32 -2143808246, i32 -2143808184, i32 -2143808132, i32 -2143808993, i32 -2143808968, i32 -2143807927, i32 -2143808895, i32 -2143808870, i32 -2143807667, i32 -2143807743, i32 -2143807650, i32 -2143807699, i32 -2143811042, i32 -2143811003, i32 -2143810974, i32 -2143810928, i32 -2143810903, i32 -2143807633, i32 -2143807589, i32 -2143807566, i32 -2143807533, i32 -2143807502}
!1206 = !{!1207, !4, i64 8}
!1207 = !{!"ctl_table", !4, i64 0, !4, i64 8, !23, i64 16, !12, i64 20, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56}
!1208 = !{!1207, !4, i64 0}
!1209 = !{i32 -2144947142, i32 -2144947135, i32 -2144947119, i32 -2144947658, i32 -2144947095, i32 -2144947047, i32 -2144946981, i32 -2144946919, i32 -2144946867, i32 -2144946662, i32 -2144946614, i32 -2144946548, i32 -2144946486, i32 -2144946434, i32 -2144947542, i32 -2144947517, i32 -2144946229, i32 -2144946069, i32 -2144947419, i32 -2144947394, i32 -2144945816, i32 -2144945885, i32 -2144945799, i32 -2144945841, i32 -2144945758, i32 -2144945672, i32 -2144945714}
!1210 = !{i32 -2143790256}
!1211 = !{i32 -2146107285}
