; ModuleID = 'tests/regression/kernel_modules/snd_intel8x0/snd_intel8x0_new-buggy_semaphore.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.51 }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, %struct.kernel_symbol*, i32*, i32, i32, %struct.kernel_symbol*, i32*, i8, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [56 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, i32, i64*, i8, i8, %struct.klp_modinfo*, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, void ()**, i32, [36 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, %struct.delayed_work, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.1 }
%union.anon.1 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qspinlock = type { %struct.atomic_t }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.hlist_node, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.lockdep_map, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)*, %struct.lock_class_key }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %union.anon.3, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.0, %struct.list_head, %struct.list_head, %union.anon.50 }
%struct.seqcount = type { i32, %struct.lockdep_map }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%struct.lockref = type { %union.anon.47 }
%union.anon.47 = type { %struct.anon.48 }
%struct.anon.48 = type { %struct.spinlock, i32 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %union.anon.3, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, [32 x i8], %struct.list_lru, [40 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %struct.qspinlock, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.6, %union.anon.3, %union.anon.3, %union.anon.0, %union.anon.3, %struct.mem_cgroup* }
%union.anon.6 = type { %struct.address_space* }
%struct.mem_cgroup = type opaque
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.atomic_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %union.anon.3, %struct.list_head, %struct.raw_spinlock, %struct.qspinlock, %struct.task_struct*, %struct.lockdep_map }
%struct.task_struct = type { %union.anon.3, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, %struct.hlist_head, i32, i32, i32, %struct.cpumask, i64, i8, %struct.list_head, i32, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %union.anon.0, i64, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.atomic_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, i32, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.callback_head, %struct.list_head, %struct.numa_group*, i64*, i64, [3 x i64], i64, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, i32, i32, i8*, %struct.kcov*, %struct.mem_cgroup*, i32, i32, i32, %struct.uprobe_task*, i32, i32, i64, i32, %struct.task_struct*, %struct.atomic_t, %struct.thread_struct }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [8 x i8], [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [128 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %union.anon.3*, %struct.atomic_t, %struct.atomic_t, %union.anon.3, %union.anon.3, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.task_struct*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, %struct.cpumask, i64, i64, i32, i8, %struct.uprobes_state, %union.anon.3, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %union.anon.3, i64, %struct.timerqueue_node, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.anon_vma = type opaque
%struct.vm_userfaultfd_ctx = type { %struct.userfaultfd_ctx* }
%struct.userfaultfd_ctx = type opaque
%struct.mm_rss_stat = type { [4 x %union.anon.3] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16, i8* }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type opaque
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.8 }
%union.anon.8 = type { %struct.anon.9 }
%struct.anon.9 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type opaque
%struct.sighand_struct = type opaque
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, %struct.ww_acquire_ctx*, i8* }
%struct.ww_acquire_ctx = type opaque
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.12 }
%union.anon.12 = type { %struct.anon.16, [80 x i8] }
%struct.anon.16 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.numa_group = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.kcov = type opaque
%struct.uprobe_task = type { i32, %union.anon.22, %struct.uprobe*, i64, %struct.return_instance*, i32 }
%union.anon.22 = type { %struct.anon.23 }
%struct.anon.23 = type { %struct.arch_uprobe_task, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.uprobe = type opaque
%struct.return_instance = type { %struct.uprobe*, i64, i64, i64, i8, %struct.return_instance* }
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %union.anon.3, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.25 }
%union.anon.25 = type { %struct.anon.26 }
%struct.anon.26 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.28, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.31 }
%union.anon.28 = type { %struct.timespec }
%struct.timespec = type { i64, i64 }
%union.anon.31 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %union.anon.3* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type opaque
%struct.list_lru = type { %struct.list_lru_node*, %struct.list_head }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, %struct.list_lru_memcg*, [24 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.list_lru_memcg = type { [0 x %struct.list_lru_one*] }
%struct.work_struct = type { %union.anon.3, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%union.anon.0 = type { %struct.list_head }
%union.anon.50 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.atomic_t, %struct.atomic_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %struct.atomic_t, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.bdi_writeback*, i32, i16, i16, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.2, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.46, i32, i32, %struct.hlist_head, %struct.fscrypt_info*, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.atomic_t, %struct.atomic_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.atomic_t, %struct.atomic_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%struct.bdi_writeback = type opaque
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.0, [64 x i8*], [3 x [1 x i64]] }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type opaque
%struct.swap_info_struct = type opaque
%union.anon.46 = type { %struct.pipe_inode_info* }
%struct.fscrypt_info = type opaque
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%union.anon.3 = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.atomic_t, %struct.atomic_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.52, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.3, i64, %struct.atomic_t, %struct.atomic_t, i32, i16, i16, i64, %union.anon.54, %union.anon.56, i32 (%struct.key*, %struct.key_type*, %union.key_payload*)* }
%union.anon.52 = type { %struct.rb_node }
%struct.key_user = type opaque
%union.anon.54 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { %struct.key_type*, i8*, i64 }
%struct.key_type = type opaque
%union.anon.56 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %union.anon.3, i64, i64, i64, %union.anon.3, %struct.key*, %struct.key*, %struct.hlist_node, %struct.atomic_t, %union.anon.3 }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.atomic_t] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %union.anon.3*, %union.anon.3*, %union.anon.3, %struct.page*, %struct.mem_cgroup*, %struct.page*, %union.anon.3*, %struct.spinlock*, %struct.page* }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.qspinlock }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32, %struct.lockdep_map }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.mutex = type { %union.anon.3, %struct.spinlock, %struct.qspinlock, %struct.list_head, i8*, %struct.lockdep_map }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32, i32 }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.qspinlock, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.klp_modinfo = type { %struct.elf64_hdr, %struct.elf64_shdr*, i8*, i32 }
%struct.elf64_hdr = type { [16 x i8], i16, i16, i32, i64, i64, i64, i32, i16, i16, i16, i16, i16, i16 }
%struct.elf64_shdr = type { i32, i32, i64, i64, i64, i64, i32, i32, i64, i64 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.atomic_t = type { i32 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.51 = type { i8* }
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, i32 (%struct.pci_dev*, %struct.pci_device_id*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.__wait_queue_head }
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i16, i8, i8, i8, i8, i8, i8, i16, [4 x i8], i64*, %struct.pci_driver*, i64, %struct.device_dma_parameters, i32, i8, [3 x i8], i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [17 x %struct.resource], i8, i32, i8, i16, %struct.atomic_t, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [17 x %struct.bin_attribute*], [17 x %struct.bin_attribute*], i8, i8, [6 x i8], %struct.attribute_group**, %struct.pci_vpd*, %union.anon.59, i16, i8, i8, %struct.atomic_t, i64, i64, i8* }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, %struct.msi_controller*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.resource = type { i64, i64, i8*, i64, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.pci_ops = type { i32 (%struct.pci_bus*)*, void (%struct.pci_bus*)*, i8* (%struct.pci_bus*, i32, i32)*, i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.msi_controller = type opaque
%struct.proc_dir_entry = type opaque
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.device_dma_parameters = type { i32, i64 }
%struct.pcie_link_state = type opaque
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.dev_pin_info*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.cma*, %union.anon.51, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.atomic_t*, %struct.atomic_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.atomic_t, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head, %struct.pm_domain_data* }
%struct.pm_domain_data = type opaque
%struct.dev_pm_qos = type { %struct.pm_qos_constraints, %struct.pm_qos_constraints, %struct.pm_qos_flags, %struct.dev_pm_qos_request*, %struct.dev_pm_qos_request*, %struct.dev_pm_qos_request* }
%struct.pm_qos_constraints = type { %union.anon.0, i32, i32, i32, i32, %struct.blocking_notifier_head* }
%struct.blocking_notifier_head = type { %struct.rw_semaphore, %struct.notifier_block* }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.pm_qos_flags = type { %struct.list_head, i32 }
%struct.dev_pm_qos_request = type { i32, %union.anon.58, %struct.device* }
%union.anon.58 = type { %struct.plist_node }
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dev_pin_info = type { %struct.pinctrl*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state* }
%struct.pinctrl = type opaque
%struct.pinctrl_state = type opaque
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, i64)*, void (%struct.device*, i64, i8*, i64, i64)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, i64)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, i64 (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.dma_coherent_mem = type opaque
%struct.cma = type opaque
%struct.device_node = type opaque
%struct.fwnode_handle = type opaque
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.pci_vpd = type opaque
%union.anon.59 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*, i1)*, void (%struct.pci_dev*)* }
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.snd_pci_quirk = type { i16, i16, i16, i32, i8* }
%struct.shortname_table = type { i32, i8* }
%struct.ich_pcm_table = type { i8*, %struct.snd_pcm_ops*, %struct.snd_pcm_ops*, i64, i64, i32 }
%struct.snd_pcm_ops = type { i32 (%struct.snd_pcm_substream*)*, i32 (%struct.snd_pcm_substream*)*, i32 (%struct.snd_pcm_substream*, i32, i8*)*, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)*, i32 (%struct.snd_pcm_substream*)*, i32 (%struct.snd_pcm_substream*)*, i32 (%struct.snd_pcm_substream*, i32)*, i64 (%struct.snd_pcm_substream*)*, i32 (%struct.snd_pcm_substream*, %struct.timespec*, %struct.timespec*, %struct.snd_pcm_audio_tstamp_config*, %struct.snd_pcm_audio_tstamp_report*)*, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)*, i32 (%struct.snd_pcm_substream*, i32, i64, i64)*, %struct.page* (%struct.snd_pcm_substream*, i64)*, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)*, i32 (%struct.snd_pcm_substream*)* }
%struct.snd_pcm_substream = type { %struct.snd_pcm*, %struct.snd_pcm_str*, i8*, i32, [32 x i8], i32, %struct.pm_qos_request, i64, %struct.snd_dma_buffer, i64, %struct.snd_pcm_ops*, %struct.snd_pcm_runtime*, %struct.snd_timer*, i8, %struct.snd_pcm_substream*, %struct.list_head, %struct.snd_pcm_group, %struct.snd_pcm_group*, i8*, i32, %struct.atomic_t, i32, void (%struct.snd_pcm_substream*)*, %struct.pid*, %struct.snd_pcm_oss_substream, %struct.snd_info_entry*, %struct.snd_info_entry*, %struct.snd_info_entry*, %struct.snd_info_entry*, %struct.snd_info_entry*, %struct.snd_info_entry*, %struct.snd_info_entry*, %struct.snd_info_entry*, i8 }
%struct.snd_pcm = type { %struct.snd_card*, %struct.list_head, i32, i32, i16, i16, [64 x i8], [80 x i8], [2 x %struct.snd_pcm_str], %struct.mutex, %struct.__wait_queue_head, i8*, void (%struct.snd_pcm*)*, i8, i8, %struct.anon.26 }
%struct.snd_card = type { i32, [16 x i8], [16 x i8], [32 x i8], [80 x i8], [32 x i8], [80 x i8], [128 x i8], %struct.module*, i8*, void (%struct.snd_card*)*, %struct.list_head, %struct.device, i32, %struct.rw_semaphore, %struct.rwlock_t, i32, i32, %struct.list_head, %struct.list_head, %struct.mutex, %struct.snd_info_entry*, %struct.snd_info_entry*, %struct.proc_dir_entry*, %struct.list_head, %struct.snd_shutdown_f_ops*, %struct.spinlock, i32, %struct.completion*, %struct.device*, %struct.device, [4 x %struct.attribute_group*], i8, i32, %struct.mutex, %struct.__wait_queue_head, %struct.snd_mixer_oss*, i32 }
%struct.snd_shutdown_f_ops = type opaque
%struct.snd_mixer_oss = type opaque
%struct.snd_pcm_str = type { i32, %struct.snd_pcm*, i32, i32, %struct.snd_pcm_substream*, %struct.snd_pcm_oss_stream, %struct.snd_info_entry*, %struct.snd_info_entry*, i32, %struct.snd_info_entry*, %struct.snd_kcontrol*, %struct.device }
%struct.snd_pcm_oss_stream = type { %struct.snd_pcm_oss_setup*, %struct.mutex, %struct.snd_info_entry* }
%struct.snd_pcm_oss_setup = type { i8*, i8, i32, i32, %struct.snd_pcm_oss_setup* }
%struct.snd_kcontrol = type { %struct.list_head, %struct.snd_ctl_elem_id, i32, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, %union.anon.71, i64, i8*, void (%struct.snd_kcontrol*)*, [0 x %struct.snd_kcontrol_volatile] }
%struct.snd_ctl_elem_id = type { i32, i32, i32, i32, [44 x i8], i32 }
%struct.snd_ctl_elem_info = type { %struct.snd_ctl_elem_id, i32, i32, i32, i32, %union.anon.61, %union.anon.65, [56 x i8] }
%union.anon.61 = type { %struct.anon.64, [40 x i8] }
%struct.anon.64 = type { i32, i32, [64 x i8], i64, i32 }
%union.anon.65 = type { i16* }
%struct.snd_ctl_elem_value = type { %struct.snd_ctl_elem_id, i8, %union.anon.66, %struct.timespec, [112 x i8] }
%union.anon.66 = type { %struct.cpumask }
%union.anon.71 = type { i32 (%struct.snd_kcontrol*, i32, i32, i32*)* }
%struct.snd_kcontrol_volatile = type { %struct.snd_ctl_file*, i32 }
%struct.snd_ctl_file = type { %struct.list_head, %struct.snd_card*, %struct.pid*, [2 x i32], %struct.__wait_queue_head, %struct.spinlock, %struct.fasync_struct*, i32, %struct.list_head }
%struct.pm_qos_request = type { %struct.plist_node, i32, %struct.delayed_work }
%struct.snd_dma_buffer = type { %struct.snd_dma_device, i8*, i64, i64, i8* }
%struct.snd_dma_device = type { i32, %struct.device* }
%struct.snd_pcm_runtime = type { %struct.snd_pcm_substream*, %struct.timespec, i8, i32, i64, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, i32, i64, i32, i64, i64, i64, i32, i32, i32, i32, i32, i8, i32, i32, i64, i64, i64, i64, i64, i64, i64, %union.snd_pcm_sync_id, %struct.snd_pcm_mmap_status*, %struct.timespec*, i64, %struct.__wait_queue_head, %struct.__wait_queue_head, %struct.fasync_struct*, i8*, void (%struct.snd_pcm_runtime*)*, %struct.snd_pcm_hardware, %struct.snd_pcm_hw_constraints, i32, i32, i8*, i64, i64, %struct.snd_dma_buffer*, %struct.snd_pcm_audio_tstamp_config, %struct.snd_pcm_audio_tstamp_report, %struct.timespec, %struct.snd_pcm_oss_runtime }
%union.snd_pcm_sync_id = type { [4 x i32] }
%struct.snd_pcm_mmap_status = type { i32, i32, i64, %struct.timespec, i32, %struct.timespec }
%struct.snd_pcm_hardware = type { i32, i64, i32, i32, i32, i32, i32, i64, i64, i64, i32, i32, i64 }
%struct.snd_pcm_hw_constraints = type { [3 x %struct.snd_mask], [12 x %struct.snd_interval], i32, i32, %struct.snd_pcm_hw_rule* }
%struct.snd_mask = type { [8 x i32] }
%struct.snd_interval = type { i32, i32, i8 }
%struct.snd_pcm_hw_rule = type { i32, i32, [4 x i32], i32 (%struct.snd_pcm_hw_params*, %struct.snd_pcm_hw_rule*)*, i8* }
%struct.snd_pcm_hw_params = type { i32, [3 x %struct.snd_mask], [5 x %struct.snd_mask], [12 x %struct.snd_interval], [9 x %struct.snd_interval], i32, i32, i32, i32, i32, i32, i64, [64 x i8] }
%struct.snd_pcm_audio_tstamp_config = type { i8, [3 x i8] }
%struct.snd_pcm_audio_tstamp_report = type { i8, i32 }
%struct.snd_pcm_oss_runtime = type { i8, i32, i32, i32, i32, i32, i32, i64, i64, i64, i32, i64, i64, i64, i8*, i64, %struct.mutex, %struct.snd_pcm_plugin*, %struct.snd_pcm_plugin*, i32 }
%struct.snd_pcm_plugin = type opaque
%struct.snd_timer = type opaque
%struct.snd_pcm_group = type { %struct.spinlock, %struct.mutex, %struct.list_head, i32 }
%struct.snd_pcm_oss_substream = type { i8, %struct.snd_pcm_oss_setup }
%struct.snd_info_entry = type { i8*, i16, i64, i16, %union.anon.60, %struct.snd_info_entry*, %struct.snd_card*, %struct.module*, i8*, void (%struct.snd_info_entry*)*, %struct.proc_dir_entry*, %struct.mutex, %struct.list_head, %struct.list_head }
%union.anon.60 = type { %struct.snd_info_entry_text }
%struct.snd_info_entry_text = type { void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* }
%struct.snd_info_buffer = type { i8*, i32, i32, i32, i32, i32 }
%struct.snd_pcm_chmap_elem = type { i8, [15 x i8] }
%struct.snd_pcm_hw_constraint_list = type { i32*, i32, i32 }
%struct.snd_ac97_bus_ops = type { void (%struct.snd_ac97*)*, void (%struct.snd_ac97*)*, void (%struct.snd_ac97*, i16, i16)*, i16 (%struct.snd_ac97*, i16)*, void (%struct.snd_ac97*)*, void (%struct.snd_ac97*)* }
%struct.snd_ac97 = type { %struct.snd_ac97_build_ops*, i8*, {}*, %struct.snd_ac97_bus*, %struct.pci_dev*, %struct.snd_info_entry*, %struct.snd_info_entry*, i16, i16, %struct.mutex, %struct.mutex, i16, i16, i32, i16, i16, i16, %struct.snd_ac97_res_table*, i32, i32, [6 x i32], i32, [128 x i16], [2 x i64], %union.anon.72, i8, i8, i32, %struct.delayed_work, %struct.device, %struct.snd_ac97_gpio_priv*, [2 x %struct.snd_pcm_chmap*] }
%struct.snd_ac97_build_ops = type { i32 (%struct.snd_ac97*)*, i32 (%struct.snd_ac97*)*, i32 (%struct.snd_ac97*)*, i32 (%struct.snd_ac97*)*, {}*, {}*, {}* }
%struct.snd_ac97_bus = type { %struct.snd_ac97_bus_ops*, i8*, void (%struct.snd_ac97_bus*)*, %struct.snd_card*, i16, i8, i32, %struct.spinlock, [2 x [4 x i16]], i16, %struct.ac97_pcm*, [4 x %struct.snd_ac97*], %struct.snd_info_entry* }
%struct.ac97_pcm = type { %struct.snd_ac97_bus*, i8, i16, i16, i32, [2 x %struct.anon.74], i64 }
%struct.anon.74 = type { i16, [4 x i16], [4 x i8], [4 x %struct.snd_ac97*] }
%struct.snd_ac97_res_table = type { i16, i16 }
%union.anon.72 = type { i32, [28 x i8] }
%struct.snd_ac97_gpio_priv = type opaque
%struct.snd_pcm_chmap = type { %struct.snd_pcm*, i32, %struct.snd_kcontrol*, %struct.snd_pcm_chmap_elem*, i32, i32, i8* }
%struct.ac97_quirk = type { i16, i16, i16, i32, i8*, i32 }
%struct.snd_device_ops = type { i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)* }
%struct.snd_device = type { %struct.list_head, %struct.snd_card*, i32, i32, i8*, %struct.snd_device_ops* }
%struct.intel8x0 = type { i32, i32, i8*, i8*, %struct.pci_dev*, %struct.snd_card*, i32, [6 x %struct.snd_pcm*], [6 x %struct.ichdev], i16, i32, i32, %struct.snd_ac97_bus*, [3 x %struct.snd_ac97*], [3 x i32], i32, i32, i32*, i32, i32, %struct.spinlock, i32, %struct.snd_dma_buffer, i32, i32 }
%struct.ichdev = type { i32, i64, i32*, i32, %struct.snd_pcm_substream*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.ac97_pcm*, i32, i8 }
%struct._ddebug = type { i8*, i8*, i8*, i8*, i32 }
%struct.snd_ac97_template = type { i8*, void (%struct.snd_ac97*)*, %struct.pci_dev*, i16, i16, i32, %struct.snd_ac97_res_table* }

@llvm.used = appending global [34 x i8*] [i8* getelementptr inbounds ([40 x i8], [40 x i8]* @__UNIQUE_ID_author12, i32 0, i32 0), i8* getelementptr inbounds ([85 x i8], [85 x i8]* @__UNIQUE_ID_description13, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license14, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_index to i8*), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__UNIQUE_ID_indextype15, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @__UNIQUE_ID_index16, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_id to i8*), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__UNIQUE_ID_idtype17, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @__UNIQUE_ID_id18, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_ac97_clock to i8*), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__UNIQUE_ID_ac97_clocktype19, i32 0, i32 0), i8* getelementptr inbounds ([87 x i8], [87 x i8]* @__UNIQUE_ID_ac97_clock20, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_ac97_quirk to i8*), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__UNIQUE_ID_ac97_quirktype21, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @__UNIQUE_ID_ac97_quirk22, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_buggy_semaphore to i8*), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__UNIQUE_ID_buggy_semaphoretype23, i32 0, i32 0), i8* getelementptr inbounds ([88 x i8], [88 x i8]* @__UNIQUE_ID_buggy_semaphore24, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_buggy_irq to i8*), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__UNIQUE_ID_buggy_irqtype25, i32 0, i32 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @__UNIQUE_ID_buggy_irq26, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_xbox to i8*), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__UNIQUE_ID_xboxtype27, i32 0, i32 0), i8* getelementptr inbounds ([82 x i8], [82 x i8]* @__UNIQUE_ID_xbox28, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_spdif_aclink to i8*), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__UNIQUE_ID_spdif_aclinktype29, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @__UNIQUE_ID_spdif_aclink30, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_inside_vm to i8*), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__UNIQUE_ID_inside_vmtype31, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @__UNIQUE_ID_inside_vm32, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_enable to i8*), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__UNIQUE_ID_enabletype33, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_joystick to i8*), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__UNIQUE_ID_joysticktype34, i32 0, i32 0)], section "llvm.metadata"
@__UNIQUE_ID_author12 = internal constant [40 x i8] c"author=Jaroslav Kysela <perex@perex.cz>\00", section ".modinfo", align 1
@__UNIQUE_ID_description13 = internal constant [85 x i8] c"description=Intel 82801AA,82901AB,i810,i820,i830,i840,i845,MX440; SiS 7012; Ali 5455\00", section ".modinfo", align 1
@__UNIQUE_ID_license14 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__param_index = internal constant %struct.kernel_param { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_index, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @index to i8*) } }, section "__param", align 8
@__UNIQUE_ID_indextype15 = internal constant [19 x i8] c"parmtype=index:int\00", section ".modinfo", align 1
@__UNIQUE_ID_index16 = internal constant [49 x i8] c"parm=index:Index value for Intel i8x0 soundcard.\00", section ".modinfo", align 1
@__param_id = internal constant %struct.kernel_param { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @__param_str_id, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_charp, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i8** @id to i8*) } }, section "__param", align 8
@__UNIQUE_ID_idtype17 = internal constant [18 x i8] c"parmtype=id:charp\00", section ".modinfo", align 1
@__UNIQUE_ID_id18 = internal constant [44 x i8] c"parm=id:ID string for Intel i8x0 soundcard.\00", section ".modinfo", align 1
@__param_ac97_clock = internal constant %struct.kernel_param { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__param_str_ac97_clock, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @ac97_clock to i8*) } }, section "__param", align 8
@__UNIQUE_ID_ac97_clocktype19 = internal constant [24 x i8] c"parmtype=ac97_clock:int\00", section ".modinfo", align 1
@__UNIQUE_ID_ac97_clock20 = internal constant [87 x i8] c"parm=ac97_clock:AC'97 codec clock (0 = whitelist + auto-detect, 1 = force autodetect).\00", section ".modinfo", align 1
@__param_ac97_quirk = internal constant %struct.kernel_param { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__param_str_ac97_quirk, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_charp, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i8** @ac97_quirk to i8*) } }, section "__param", align 8
@__UNIQUE_ID_ac97_quirktype21 = internal constant [26 x i8] c"parmtype=ac97_quirk:charp\00", section ".modinfo", align 1
@__UNIQUE_ID_ac97_quirk22 = internal constant [55 x i8] c"parm=ac97_quirk:AC'97 workaround for strange hardware.\00", section ".modinfo", align 1
@__param_buggy_semaphore = internal constant %struct.kernel_param { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__param_str_buggy_semaphore, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bool, i16 292, i8 -1, i8 0, %union.anon.51 { i8* @buggy_semaphore } }, section "__param", align 8
@__UNIQUE_ID_buggy_semaphoretype23 = internal constant [30 x i8] c"parmtype=buggy_semaphore:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_buggy_semaphore24 = internal constant [88 x i8] c"parm=buggy_semaphore:Enable workaround for hardwares with problematic codec semaphores.\00", section ".modinfo", align 1
@__param_buggy_irq = internal constant %struct.kernel_param { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__param_str_buggy_irq, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bint, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @buggy_irq to i8*) } }, section "__param", align 8
@__UNIQUE_ID_buggy_irqtype25 = internal constant [24 x i8] c"parmtype=buggy_irq:bint\00", section ".modinfo", align 1
@__UNIQUE_ID_buggy_irq26 = internal constant [76 x i8] c"parm=buggy_irq:Enable workaround for buggy interrupts on some motherboards.\00", section ".modinfo", align 1
@__param_xbox = internal constant %struct.kernel_param { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @__param_str_xbox, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bool, i16 292, i8 -1, i8 0, %union.anon.51 { i8* @xbox } }, section "__param", align 8
@__UNIQUE_ID_xboxtype27 = internal constant [19 x i8] c"parmtype=xbox:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_xbox28 = internal constant [82 x i8] c"parm=xbox:Set to 1 for Xbox, if you have problems with the AC'97 codec detection.\00", section ".modinfo", align 1
@__param_spdif_aclink = internal constant %struct.kernel_param { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__param_str_spdif_aclink, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @spdif_aclink to i8*) } }, section "__param", align 8
@__UNIQUE_ID_spdif_aclinktype29 = internal constant [26 x i8] c"parmtype=spdif_aclink:int\00", section ".modinfo", align 1
@__UNIQUE_ID_spdif_aclink30 = internal constant [39 x i8] c"parm=spdif_aclink:S/PDIF over AC-link.\00", section ".modinfo", align 1
@__param_inside_vm = internal constant %struct.kernel_param { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__param_str_inside_vm, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bint, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @inside_vm to i8*) } }, section "__param", align 8
@__UNIQUE_ID_inside_vmtype31 = internal constant [24 x i8] c"parmtype=inside_vm:bint\00", section ".modinfo", align 1
@__UNIQUE_ID_inside_vm32 = internal constant [43 x i8] c"parm=inside_vm:KVM/Parallels optimization.\00", section ".modinfo", align 1
@__param_enable = internal constant %struct.kernel_param { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @__param_str_enable, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bool, i16 292, i8 -1, i8 0, %union.anon.51 { i8* @enable } }, section "__param", align 8
@__UNIQUE_ID_enabletype33 = internal constant [21 x i8] c"parmtype=enable:bool\00", section ".modinfo", align 1
@__param_joystick = internal constant %struct.kernel_param { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__param_str_joystick, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @joystick to i8*) } }, section "__param", align 8
@__UNIQUE_ID_joysticktype34 = internal constant [22 x i8] c"parmtype=joystick:int\00", section ".modinfo", align 1
@__param_str_joystick = internal constant [9 x i8] c"joystick\00", align 1
@__this_module = external global %struct.module, align 64
@param_ops_int = external constant %struct.kernel_param_ops, align 8
@joystick = internal global i32 0, align 4
@__param_str_enable = internal constant [7 x i8] c"enable\00", align 1
@param_ops_bool = external constant %struct.kernel_param_ops, align 8
@enable = internal global i8 0, align 1
@__param_str_inside_vm = internal constant [10 x i8] c"inside_vm\00", align 1
@param_ops_bint = external constant %struct.kernel_param_ops, align 8
@inside_vm = internal global i32 -1, align 4
@__param_str_spdif_aclink = internal constant [13 x i8] c"spdif_aclink\00", align 1
@spdif_aclink = internal global i32 -1, align 4
@__param_str_xbox = internal constant [5 x i8] c"xbox\00", align 1
@xbox = internal global i8 0, align 1
@__param_str_buggy_irq = internal constant [10 x i8] c"buggy_irq\00", align 1
@buggy_irq = internal global i32 -1, align 4
@__param_str_buggy_semaphore = internal constant [16 x i8] c"buggy_semaphore\00", align 16
@buggy_semaphore = internal global i8 0, align 1
@__param_str_ac97_quirk = internal constant [11 x i8] c"ac97_quirk\00", align 1
@param_ops_charp = external constant %struct.kernel_param_ops, align 8
@ac97_quirk = internal global i8* null, align 8
@__param_str_ac97_clock = internal constant [11 x i8] c"ac97_clock\00", align 1
@ac97_clock = internal global i32 0, align 4
@__param_str_id = internal constant [3 x i8] c"id\00", align 1
@id = internal global i8* null, align 8
@__param_str_index = internal constant [6 x i8] c"index\00", align 1
@index = internal global i32 -1, align 4
@snd_intel8x0_ids = internal constant [24 x %struct.pci_device_id] [%struct.pci_device_id { i32 32902, i32 9237, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 9253, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 9285, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 9349, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 9413, i32 -1, i32 -1, i32 0, i32 0, i64 1 }, %struct.pci_device_id { i32 32902, i32 9429, i32 -1, i32 -1, i32 0, i32 0, i64 1 }, %struct.pci_device_id { i32 32902, i32 9638, i32 -1, i32 -1, i32 0, i32 0, i64 1 }, %struct.pci_device_id { i32 32902, i32 9838, i32 -1, i32 -1, i32 0, i32 0, i64 1 }, %struct.pci_device_id { i32 32902, i32 10206, i32 -1, i32 -1, i32 0, i32 0, i64 1 }, %struct.pci_device_id { i32 32902, i32 9880, i32 -1, i32 -1, i32 0, i32 0, i64 1 }, %struct.pci_device_id { i32 32902, i32 29077, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 4153, i32 28690, i32 -1, i32 -1, i32 0, i32 0, i64 2 }, %struct.pci_device_id { i32 4318, i32 433, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 4318, i32 58, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 4318, i32 106, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 4318, i32 89, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 4318, i32 138, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 4318, i32 218, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 4318, i32 234, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 4318, i32 619, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 4130, i32 29805, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 4130, i32 29765, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 4281, i32 21589, i32 -1, i32 -1, i32 0, i32 0, i64 3 }, %struct.pci_device_id zeroinitializer], align 16
@intel8x0_driver = internal global %struct.pci_driver { %struct.list_head zeroinitializer, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), %struct.pci_device_id* getelementptr inbounds ([24 x %struct.pci_device_id], [24 x %struct.pci_device_id]* @snd_intel8x0_ids, i32 0, i32 0), i32 (%struct.pci_dev*, %struct.pci_device_id*)* @snd_intel8x0_probe, void (%struct.pci_dev*)* @snd_intel8x0_remove, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*)* null, i32 (%struct.pci_dev*)* null, void (%struct.pci_dev*)* null, i32 (%struct.pci_dev*, i32)* null, %struct.pci_error_handlers* null, %struct.device_driver { i8* null, %struct.bus_type* null, %struct.module* null, i8* null, i8 0, i32 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* @intel8x0_pm, %struct.driver_private* null }, %struct.__wait_queue_head zeroinitializer }, align 8
@.str = private unnamed_addr constant [13 x i8] c"snd_intel8x0\00", align 1
@intel8x0_pm = internal constant %struct.dev_pm_ops { i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*)* @intel8x0_suspend, i32 (%struct.device*)* @intel8x0_resume, i32 (%struct.device*)* @intel8x0_suspend, i32 (%struct.device*)* @intel8x0_resume, i32 (%struct.device*)* @intel8x0_suspend, i32 (%struct.device*)* @intel8x0_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null }, align 8
@.str.147 = private unnamed_addr constant [41 x i8] c"unable to grab IRQ %d, disabling device\0A\00", align 1
@.str.43 = private unnamed_addr constant [28 x i8] c"reset of registers failed?\0A\00", align 1
@.str.47 = private unnamed_addr constant [21 x i8] c"AC'97 reset failed.\0A\00", align 1
@ich_chip_reset_mode = internal global [2 x %struct.snd_pci_quirk] [%struct.snd_pci_quirk { i16 4116, i16 1311, i16 -1, i32 1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.45, i32 0, i32 0) }, %struct.snd_pci_quirk zeroinitializer], align 16
@jiffies = external global i64, align 8
@.str.44 = private unnamed_addr constant [40 x i8] c"codec_ready: codec is not ready [0x%x]\0A\00", align 1
@.str.46 = private unnamed_addr constant [44 x i8] c"AC'97 warm reset still in progress? [0x%x]\0A\00", align 1
@.str.45 = private unnamed_addr constant [13 x i8] c"Thinkpad R32\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"ICH\00", align 1
@.str.2 = private unnamed_addr constant [7 x i8] c"NFORCE\00", align 1
@.str.3 = private unnamed_addr constant [5 x i8] c"ICH4\00", align 1
@.str.4 = private unnamed_addr constant [10 x i8] c"Intel ICH\00", align 1
@shortnames = internal global [23 x %struct.shortname_table] [%struct.shortname_table { i32 9237, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.11, i32 0, i32 0) }, %struct.shortname_table { i32 9253, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.12, i32 0, i32 0) }, %struct.shortname_table { i32 9285, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.13, i32 0, i32 0) }, %struct.shortname_table { i32 29077, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.14, i32 0, i32 0) }, %struct.shortname_table { i32 9349, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.15, i32 0, i32 0) }, %struct.shortname_table { i32 9413, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.16, i32 0, i32 0) }, %struct.shortname_table { i32 9429, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0) }, %struct.shortname_table { i32 9638, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.18, i32 0, i32 0) }, %struct.shortname_table { i32 9838, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.19, i32 0, i32 0) }, %struct.shortname_table { i32 10206, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.20, i32 0, i32 0) }, %struct.shortname_table { i32 9880, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.21, i32 0, i32 0) }, %struct.shortname_table { i32 28690, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.22, i32 0, i32 0) }, %struct.shortname_table { i32 433, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.23, i32 0, i32 0) }, %struct.shortname_table { i32 106, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.24, i32 0, i32 0) }, %struct.shortname_table { i32 218, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.25, i32 0, i32 0) }, %struct.shortname_table { i32 234, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.26, i32 0, i32 0) }, %struct.shortname_table { i32 89, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.27, i32 0, i32 0) }, %struct.shortname_table { i32 138, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.28, i32 0, i32 0) }, %struct.shortname_table { i32 58, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.29, i32 0, i32 0) }, %struct.shortname_table { i32 29805, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.30, i32 0, i32 0) }, %struct.shortname_table { i32 29765, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.31, i32 0, i32 0) }, %struct.shortname_table { i32 21589, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.32, i32 0, i32 0) }, %struct.shortname_table zeroinitializer], align 16
@.str.5 = private unnamed_addr constant [21 x i8] c"%s with %s at irq %i\00", align 1
@.str.139 = private unnamed_addr constant [60 x i8] c"no playback buffer allocated - aborting measure ac97 clock\0A\00", align 1
@.str.140 = private unnamed_addr constant [34 x i8] c"cannot set ac97 rate: clock = %d\0A\00", align 1
@.str.141 = private unnamed_addr constant [37 x i8] c"measure - unreliable DMA position..\0A\00", align 1
@.str.142 = private unnamed_addr constant [38 x i8] c"%s: measured %lu usecs (%lu samples)\0A\00", align 1
@__func__.intel8x0_measure_ac97_clock = private unnamed_addr constant [28 x i8] c"intel8x0_measure_ac97_clock\00", align 1
@.str.143 = private unnamed_addr constant [24 x i8] c"?? calculation error..\0A\00", align 1
@.str.144 = private unnamed_addr constant [29 x i8] c"measured clock %ld rejected\0A\00", align 1
@.str.145 = private unnamed_addr constant [16 x i8] c"clocking to %d\0A\00", align 1
@.str.146 = private unnamed_addr constant [24 x i8] c"./include/linux/ktime.h\00", align 1
@intel8x0_clock_list = internal global [7 x %struct.snd_pci_quirk] [%struct.snd_pci_quirk { i16 3601, i16 138, i16 -1, i32 41000, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.135, i32 0, i32 0) }, %struct.snd_pci_quirk { i16 4116, i16 1409, i16 -1, i32 48000, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.136, i32 0, i32 0) }, %struct.snd_pci_quirk { i16 4136, i16 190, i16 -1, i32 44100, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.135, i32 0, i32 0) }, %struct.snd_pci_quirk { i16 4136, i16 375, i16 -1, i32 48000, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.137, i32 0, i32 0) }, %struct.snd_pci_quirk { i16 4136, i16 429, i16 -1, i32 48000, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.136, i32 0, i32 0) }, %struct.snd_pci_quirk { i16 4163, i16 -32525, i16 -1, i32 48000, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.138, i32 0, i32 0) }, %struct.snd_pci_quirk zeroinitializer], align 16
@.str.134 = private unnamed_addr constant [37 x i8] c"white list rate for %04x:%04x is %i\0A\00", align 1
@.str.135 = private unnamed_addr constant [7 x i8] c"AD1885\00", align 1
@.str.136 = private unnamed_addr constant [8 x i8] c"AD1981B\00", align 1
@.str.137 = private unnamed_addr constant [7 x i8] c"AD1980\00", align 1
@.str.138 = private unnamed_addr constant [7 x i8] c"AD1985\00", align 1
@.str.121 = private unnamed_addr constant [9 x i8] c"intel8x0\00", align 1
@.str.122 = private unnamed_addr constant [11 x i8] c"Intel8x0\0A\0A\00", align 1
@.str.123 = private unnamed_addr constant [32 x i8] c"Global control        : 0x%08x\0A\00", align 1
@.str.124 = private unnamed_addr constant [32 x i8] c"Global status         : 0x%08x\0A\00", align 1
@.str.125 = private unnamed_addr constant [32 x i8] c"SDM                   : 0x%08x\0A\00", align 1
@.str.126 = private unnamed_addr constant [24 x i8] c"AC'97 codecs ready    :\00", align 1
@snd_intel8x0_proc_read.codecs = internal global [3 x i8*] [i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.127, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.128, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.129, i32 0, i32 0)], align 16
@.str.130 = private unnamed_addr constant [4 x i8] c" %s\00", align 1
@.str.131 = private unnamed_addr constant [6 x i8] c" none\00", align 1
@.str.132 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.133 = private unnamed_addr constant [34 x i8] c"AC'97 codecs SDIN     : %i %i %i\0A\00", align 1
@.str.127 = private unnamed_addr constant [8 x i8] c"primary\00", align 1
@.str.128 = private unnamed_addr constant [10 x i8] c"secondary\00", align 1
@.str.129 = private unnamed_addr constant [9 x i8] c"tertiary\00", align 1
@intel_pcms = internal global [5 x %struct.ich_pcm_table] [%struct.ich_pcm_table { i8* null, %struct.snd_pcm_ops* @snd_intel8x0_playback_ops, %struct.snd_pcm_ops* @snd_intel8x0_capture_ops, i64 65536, i64 131072, i32 0 }, %struct.ich_pcm_table { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.115, i32 0, i32 0), %struct.snd_pcm_ops* null, %struct.snd_pcm_ops* @snd_intel8x0_capture_mic_ops, i64 0, i64 131072, i32 2 }, %struct.ich_pcm_table { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.116, i32 0, i32 0), %struct.snd_pcm_ops* null, %struct.snd_pcm_ops* @snd_intel8x0_capture_mic2_ops, i64 0, i64 131072, i32 3 }, %struct.ich_pcm_table { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.117, i32 0, i32 0), %struct.snd_pcm_ops* null, %struct.snd_pcm_ops* @snd_intel8x0_capture2_ops, i64 0, i64 131072, i32 4 }, %struct.ich_pcm_table { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.118, i32 0, i32 0), %struct.snd_pcm_ops* @snd_intel8x0_spdif_ops, %struct.snd_pcm_ops* null, i64 65536, i64 131072, i32 5 }], align 16
@nforce_pcms = internal global [3 x %struct.ich_pcm_table] [%struct.ich_pcm_table { i8* null, %struct.snd_pcm_ops* @snd_intel8x0_playback_ops, %struct.snd_pcm_ops* @snd_intel8x0_capture_ops, i64 65536, i64 131072, i32 0 }, %struct.ich_pcm_table { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.115, i32 0, i32 0), %struct.snd_pcm_ops* null, %struct.snd_pcm_ops* @snd_intel8x0_capture_mic_ops, i64 0, i64 131072, i32 2 }, %struct.ich_pcm_table { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.118, i32 0, i32 0), %struct.snd_pcm_ops* @snd_intel8x0_spdif_ops, %struct.snd_pcm_ops* null, i64 65536, i64 131072, i32 3 }], align 16
@ali_pcms = internal global [3 x %struct.ich_pcm_table] [%struct.ich_pcm_table { i8* null, %struct.snd_pcm_ops* @snd_intel8x0_ali_playback_ops, %struct.snd_pcm_ops* @snd_intel8x0_ali_capture_ops, i64 65536, i64 131072, i32 0 }, %struct.ich_pcm_table { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.115, i32 0, i32 0), %struct.snd_pcm_ops* null, %struct.snd_pcm_ops* @snd_intel8x0_ali_capture_mic_ops, i64 0, i64 131072, i32 2 }, %struct.ich_pcm_table { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.118, i32 0, i32 0), %struct.snd_pcm_ops* @snd_intel8x0_ali_ac97spdifout_ops, %struct.snd_pcm_ops* null, i64 65536, i64 131072, i32 3 }], align 16
@.str.119 = private unnamed_addr constant [15 x i8] c"Intel ICH - %s\00", align 1
@.str.120 = private unnamed_addr constant [8 x i8] c"%s - %s\00", align 1
@snd_pcm_alt_chmaps = external constant [0 x %struct.snd_pcm_chmap_elem], align 1
@hw_constraints_channels8 = internal global %struct.snd_pcm_hw_constraint_list { i32* getelementptr inbounds ([4 x i32], [4 x i32]* @channels8, i32 0, i32 0), i32 4, i32 0 }, align 8
@hw_constraints_channels6 = internal global %struct.snd_pcm_hw_constraint_list { i32* getelementptr inbounds ([3 x i32], [3 x i32]* @channels6, i32 0, i32 0), i32 3, i32 0 }, align 8
@hw_constraints_channels4 = internal global %struct.snd_pcm_hw_constraint_list { i32* getelementptr inbounds ([2 x i32], [2 x i32]* @channels4, i32 0, i32 0), i32 2, i32 0 }, align 8
@channels4 = internal global [2 x i32] [i32 2, i32 4], align 4
@channels6 = internal global [3 x i32] [i32 2, i32 4, i32 6], align 4
@channels8 = internal global [4 x i32] [i32 2, i32 4, i32 6, i32 8], align 16
@snd_intel8x0_stream = internal global %struct.snd_pcm_hardware { i32 852227, i64 4, i32 128, i32 48000, i32 48000, i32 2, i32 2, i64 131072, i64 32, i64 131072, i32 1, i32 1024, i64 0 }, align 8
@snd_intel8x0_ali_playback_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_playback_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_playback_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_ali_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.timespec*, %struct.timespec*, %struct.snd_pcm_audio_tstamp_config*, %struct.snd_pcm_audio_tstamp_report*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@snd_intel8x0_ali_capture_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_capture_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_capture_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_ali_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.timespec*, %struct.timespec*, %struct.snd_pcm_audio_tstamp_config*, %struct.snd_pcm_audio_tstamp_report*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@.str.115 = private unnamed_addr constant [8 x i8] c"MIC ADC\00", align 1
@snd_intel8x0_ali_capture_mic_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_mic_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_mic_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_ali_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.timespec*, %struct.timespec*, %struct.snd_pcm_audio_tstamp_config*, %struct.snd_pcm_audio_tstamp_report*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@.str.118 = private unnamed_addr constant [7 x i8] c"IEC958\00", align 1
@snd_intel8x0_ali_ac97spdifout_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_ali_ac97spdifout_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_ali_ac97spdifout_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_ali_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.timespec*, %struct.timespec*, %struct.snd_pcm_audio_tstamp_config*, %struct.snd_pcm_audio_tstamp_report*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@snd_intel8x0_ali_trigger.fiforeg = internal global [3 x i32] [i32 12, i32 28, i32 44], align 4
@snd_intel8x0_playback_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_playback_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_playback_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_pcm_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.timespec*, %struct.timespec*, %struct.snd_pcm_audio_tstamp_config*, %struct.snd_pcm_audio_tstamp_report*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@snd_intel8x0_capture_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_capture_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_capture_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_pcm_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.timespec*, %struct.timespec*, %struct.snd_pcm_audio_tstamp_config*, %struct.snd_pcm_audio_tstamp_report*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@snd_intel8x0_capture_mic_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_mic_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_mic_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_pcm_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.timespec*, %struct.timespec*, %struct.snd_pcm_audio_tstamp_config*, %struct.snd_pcm_audio_tstamp_report*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@snd_intel8x0_spdif_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_spdif_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_spdif_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_pcm_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.timespec*, %struct.timespec*, %struct.snd_pcm_audio_tstamp_config*, %struct.snd_pcm_audio_tstamp_report*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@.str.116 = private unnamed_addr constant [9 x i8] c"MIC2 ADC\00", align 1
@snd_intel8x0_capture_mic2_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_mic2_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_mic2_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_pcm_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.timespec*, %struct.timespec*, %struct.snd_pcm_audio_tstamp_config*, %struct.snd_pcm_audio_tstamp_report*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@.str.117 = private unnamed_addr constant [5 x i8] c"ADC2\00", align 1
@snd_intel8x0_capture2_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_capture2_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_capture2_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_pcm_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.timespec*, %struct.timespec*, %struct.snd_pcm_audio_tstamp_config*, %struct.snd_pcm_audio_tstamp_report*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@.str.6 = private unnamed_addr constant [21 x i8] c"sound/pci/intel8x0.c\00", align 1
@snd_intel8x0_mixer.standard_bus_ops = internal global %struct.snd_ac97_bus_ops { void (%struct.snd_ac97*)* null, void (%struct.snd_ac97*)* null, void (%struct.snd_ac97*, i16, i16)* @snd_intel8x0_codec_write, i16 (%struct.snd_ac97*, i16)* @snd_intel8x0_codec_read, void (%struct.snd_ac97*)* null, void (%struct.snd_ac97*)* null }, align 8
@snd_intel8x0_mixer.ali_bus_ops = internal global %struct.snd_ac97_bus_ops { void (%struct.snd_ac97*)* null, void (%struct.snd_ac97*)* null, void (%struct.snd_ac97*, i16, i16)* @snd_intel8x0_ali_codec_write, i16 (%struct.snd_ac97*, i16)* @snd_intel8x0_ali_codec_read, void (%struct.snd_ac97*)* null, void (%struct.snd_ac97*)* null }, align 8
@.str.48 = private unnamed_addr constant [32 x i8] c"Unable to initialize codec #%d\0A\00", align 1
@ac97_quirks = internal constant [66 x %struct.ac97_quirk] [%struct.ac97_quirk { i16 3601, i16 14, i16 0, i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.55, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 3601, i16 138, i16 0, i32 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.56, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 3601, i16 184, i16 0, i32 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.57, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 3601, i16 2144, i16 0, i32 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.58, i32 0, i32 0), i32 7 }, %struct.ac97_quirk { i16 4116, i16 1332, i16 0, i32 0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.59, i32 0, i32 0), i32 6 }, %struct.ac97_quirk { i16 4116, i16 7936, i16 0, i32 0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.60, i32 0, i32 0), i32 5 }, %struct.ac97_quirk { i16 4116, i16 615, i16 0, i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.61, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4133, i16 130, i16 0, i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.62, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4133, i16 131, i16 0, i32 0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.63, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 216, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.64, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 269, i16 0, i32 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.65, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 294, i16 0, i32 0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.66, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 300, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.67, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 301, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.68, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 327, i16 0, i32 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.65, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 337, i16 0, i32 0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.69, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 334, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.70, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 355, i16 0, i32 0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.71, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 362, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.72, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 386, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.73, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 390, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.74, i32 0, i32 0), i32 8 }, %struct.ac97_quirk { i16 4136, i16 392, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.75, i32 0, i32 0), i32 8 }, %struct.ac97_quirk { i16 4136, i16 393, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.76, i32 0, i32 0), i32 8 }, %struct.ac97_quirk { i16 4136, i16 401, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.72, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4156, i16 109, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.77, i32 0, i32 0), i32 7 }, %struct.ac97_quirk { i16 4156, i16 195, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.78, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4156, i16 2188, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.79, i32 0, i32 0), i32 8 }, %struct.ac97_quirk { i16 4156, i16 2192, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.80, i32 0, i32 0), i32 7 }, %struct.ac97_quirk { i16 4156, i16 4765, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.81, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4156, i16 2360, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.82, i32 0, i32 0), i32 8 }, %struct.ac97_quirk { i16 4156, i16 2460, i16 0, i32 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.83, i32 0, i32 0), i32 8 }, %struct.ac97_quirk { i16 4156, i16 2372, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.84, i32 0, i32 0), i32 8 }, %struct.ac97_quirk { i16 4156, i16 2356, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.85, i32 0, i32 0), i32 8 }, %struct.ac97_quirk { i16 4156, i16 4849, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.86, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4156, i16 4850, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.87, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4156, i16 12296, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.88, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4173, i16 -32444, i16 0, i32 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.89, i32 0, i32 0), i32 6 }, %struct.ac97_quirk { i16 4173, i16 -32361, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.90, i32 0, i32 0), i32 6 }, %struct.ac97_quirk { i16 4173, i16 -32320, i16 0, i32 0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.91, i32 0, i32 0), i32 6 }, %struct.ac97_quirk { i16 4173, i16 -32315, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.92, i32 0, i32 0), i32 6 }, %struct.ac97_quirk { i16 4163, i16 -32525, i16 0, i32 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.93, i32 0, i32 0), i32 4 }, %struct.ac97_quirk { i16 4303, i16 4547, i16 0, i32 0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.94, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4303, i16 4645, i16 0, i32 0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.95, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4303, i16 4691, i16 0, i32 0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.96, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4303, i16 4733, i16 0, i32 0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.97, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4303, i16 4734, i16 0, i32 0, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.98, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4303, i16 4844, i16 0, i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.99, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4303, i16 4850, i16 0, i32 0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.100, i32 0, i32 0), i32 2 }, %struct.ac97_quirk { i16 4337, i16 9829, i16 0, i32 0, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.101, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4337, i16 10373, i16 0, i32 0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.102, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4337, i16 10389, i16 0, i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.103, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4343, i16 -31924, i16 0, i32 0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.104, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4362, i16 86, i16 0, i32 0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.105, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4564, i16 21365, i16 0, i32 0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.106, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 5218, i16 21616, i16 0, i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.107, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 5663, i16 8239, i16 0, i32 0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.108, i32 0, i32 0), i32 6 }, %struct.ac97_quirk { i16 5663, i16 8250, i16 0, i32 0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.109, i32 0, i32 0), i32 6 }, %struct.ac97_quirk { i16 5940, i16 136, i16 0, i32 0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.110, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 -32634, i16 8192, i16 -16, i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.111, i32 0, i32 0), i32 4 }, %struct.ac97_quirk { i16 -32634, i16 16384, i16 -16, i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.111, i32 0, i32 0), i32 4 }, %struct.ac97_quirk { i16 -32634, i16 18518, i16 0, i32 0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.112, i32 0, i32 0), i32 2 }, %struct.ac97_quirk { i16 -32634, i16 19780, i16 0, i32 0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.113, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 -32634, i16 19798, i16 0, i32 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.114, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 -32634, i16 24576, i16 -16, i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.111, i32 0, i32 0), i32 4 }, %struct.ac97_quirk { i16 -32634, i16 -8192, i16 -16, i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.111, i32 0, i32 0), i32 4 }, %struct.ac97_quirk zeroinitializer], align 16
@ac97_pcm_defs = internal global [6 x %struct.ac97_pcm] [%struct.ac97_pcm { %struct.snd_ac97_bus* null, i8 2, i16 0, i16 0, i32 0, [2 x %struct.anon.74] [%struct.anon.74 { i16 984, [4 x i16] zeroinitializer, [4 x i8] zeroinitializer, [4 x %struct.snd_ac97*] zeroinitializer }, %struct.anon.74 { i16 408, [4 x i16] zeroinitializer, [4 x i8] zeroinitializer, [4 x %struct.snd_ac97*] zeroinitializer }], i64 0 }, %struct.ac97_pcm { %struct.snd_ac97_bus* null, i8 3, i16 0, i16 0, i32 0, [2 x %struct.anon.74] [%struct.anon.74 { i16 24, [4 x i16] zeroinitializer, [4 x i8] zeroinitializer, [4 x %struct.snd_ac97*] zeroinitializer }, %struct.anon.74 zeroinitializer], i64 0 }, %struct.ac97_pcm { %struct.snd_ac97_bus* null, i8 3, i16 0, i16 0, i32 0, [2 x %struct.anon.74] [%struct.anon.74 { i16 64, [4 x i16] zeroinitializer, [4 x i8] zeroinitializer, [4 x %struct.snd_ac97*] zeroinitializer }, %struct.anon.74 zeroinitializer], i64 0 }, %struct.ac97_pcm { %struct.snd_ac97_bus* null, i8 10, i16 0, i16 0, i32 0, [2 x %struct.anon.74] [%struct.anon.74 { i16 3072, [4 x i16] zeroinitializer, [4 x i8] zeroinitializer, [4 x %struct.snd_ac97*] zeroinitializer }, %struct.anon.74 zeroinitializer], i64 0 }, %struct.ac97_pcm { %struct.snd_ac97_bus* null, i8 3, i16 0, i16 0, i32 0, [2 x %struct.anon.74] [%struct.anon.74 { i16 24, [4 x i16] zeroinitializer, [4 x i8] zeroinitializer, [4 x %struct.snd_ac97*] zeroinitializer }, %struct.anon.74 zeroinitializer], i64 0 }, %struct.ac97_pcm { %struct.snd_ac97_bus* null, i8 3, i16 0, i16 0, i32 0, [2 x %struct.anon.74] [%struct.anon.74 { i16 64, [4 x i16] zeroinitializer, [4 x i8] zeroinitializer, [4 x %struct.snd_ac97*] zeroinitializer }, %struct.anon.74 zeroinitializer], i64 0 }], align 16
@.str.55 = private unnamed_addr constant [18 x i8] c"Compaq Deskpro EN\00", align 1
@.str.56 = private unnamed_addr constant [17 x i8] c"Compaq Evo W4000\00", align 1
@.str.57 = private unnamed_addr constant [17 x i8] c"Compaq Evo D510C\00", align 1
@.str.58 = private unnamed_addr constant [17 x i8] c"HP/Compaq nx7010\00", align 1
@.str.59 = private unnamed_addr constant [13 x i8] c"ThinkPad X31\00", align 1
@.str.60 = private unnamed_addr constant [8 x i8] c"MS-9128\00", align 1
@.str.61 = private unnamed_addr constant [18 x i8] c"IBM NetVista A30p\00", align 1
@.str.62 = private unnamed_addr constant [21 x i8] c"Acer Travelmate 2310\00", align 1
@.str.63 = private unnamed_addr constant [20 x i8] c"Acer Aspire 3003LCi\00", align 1
@.str.64 = private unnamed_addr constant [19 x i8] c"Dell Precision 530\00", align 1
@.str.65 = private unnamed_addr constant [5 x i8] c"Dell\00", align 1
@.str.66 = private unnamed_addr constant [20 x i8] c"Dell Optiplex GX260\00", align 1
@.str.67 = private unnamed_addr constant [19 x i8] c"Dell Precision 650\00", align 1
@.str.68 = private unnamed_addr constant [19 x i8] c"Dell Precision 450\00", align 1
@.str.69 = private unnamed_addr constant [20 x i8] c"Dell Optiplex GX270\00", align 1
@.str.70 = private unnamed_addr constant [10 x i8] c"Dell D800\00", align 1
@.str.71 = private unnamed_addr constant [13 x i8] c"Dell Unknown\00", align 1
@.str.72 = private unnamed_addr constant [19 x i8] c"Dell Inspiron 8600\00", align 1
@.str.73 = private unnamed_addr constant [19 x i8] c"Dell Latitude D610\00", align 1
@.str.74 = private unnamed_addr constant [19 x i8] c"Dell Latitude D810\00", align 1
@.str.75 = private unnamed_addr constant [19 x i8] c"Dell Inspiron 6000\00", align 1
@.str.76 = private unnamed_addr constant [19 x i8] c"Dell Inspiron 9300\00", align 1
@.str.77 = private unnamed_addr constant [10 x i8] c"HP zv5000\00", align 1
@.str.78 = private unnamed_addr constant [10 x i8] c"HP xw6000\00", align 1
@.str.79 = private unnamed_addr constant [10 x i8] c"HP nc8000\00", align 1
@.str.80 = private unnamed_addr constant [10 x i8] c"HP nc6000\00", align 1
@.str.81 = private unnamed_addr constant [10 x i8] c"HP xw8000\00", align 1
@.str.82 = private unnamed_addr constant [10 x i8] c"HP nc4200\00", align 1
@.str.83 = private unnamed_addr constant [17 x i8] c"HP nx6110/nc6120\00", align 1
@.str.84 = private unnamed_addr constant [10 x i8] c"HP nc6220\00", align 1
@.str.85 = private unnamed_addr constant [10 x i8] c"HP nc8220\00", align 1
@.str.86 = private unnamed_addr constant [10 x i8] c"HP xw8200\00", align 1
@.str.87 = private unnamed_addr constant [10 x i8] c"HP xw6200\00", align 1
@.str.88 = private unnamed_addr constant [10 x i8] c"HP xw4200\00", align 1
@.str.89 = private unnamed_addr constant [5 x i8] c"Sony\00", align 1
@.str.90 = private unnamed_addr constant [10 x i8] c"Sony S1XP\00", align 1
@.str.91 = private unnamed_addr constant [20 x i8] c"Sony VAIO VGN-T350P\00", align 1
@.str.92 = private unnamed_addr constant [19 x i8] c"Sony VAIO VGN-B1VP\00", align 1
@.str.93 = private unnamed_addr constant [17 x i8] c"ASUS ICH5/AD1985\00", align 1
@.str.94 = private unnamed_addr constant [22 x i8] c"Fujitsu-Siemens E4010\00", align 1
@.str.95 = private unnamed_addr constant [22 x i8] c"Fujitsu-Siemens T3010\00", align 1
@.str.96 = private unnamed_addr constant [14 x i8] c"Fujitsu S6210\00", align 1
@.str.97 = private unnamed_addr constant [23 x i8] c"Fujitsu Lifebook P7010\00", align 1
@.str.98 = private unnamed_addr constant [24 x i8] c"Fujitsu Lifebook C1211D\00", align 1
@.str.99 = private unnamed_addr constant [21 x i8] c"Fujitsu-Siemens 4010\00", align 1
@.str.100 = private unnamed_addr constant [29 x i8] c"Fujitsu-Siemens Celsius H320\00", align 1
@.str.101 = private unnamed_addr constant [24 x i8] c"Fujitsu-Siemens Celsius\00", align 1
@.str.102 = private unnamed_addr constant [11 x i8] c"AMD64 Mobo\00", align 1
@.str.103 = private unnamed_addr constant [18 x i8] c"Tyan Thunder K8WE\00", align 1
@.str.104 = private unnamed_addr constant [16 x i8] c"Panasonic CF-R4\00", align 1
@.str.105 = private unnamed_addr constant [23 x i8] c"Fujitsu-Siemens Scenic\00", align 1
@.str.106 = private unnamed_addr constant [22 x i8] c"ADI AD1985 (discrete)\00", align 1
@.str.107 = private unnamed_addr constant [21 x i8] c"MSI P4 ATX 645 Ultra\00", align 1
@.str.108 = private unnamed_addr constant [13 x i8] c"Gateway M520\00", align 1
@.str.109 = private unnamed_addr constant [15 x i8] c"Gateway 4525GZ\00", align 1
@.str.110 = private unnamed_addr constant [22 x i8] c"Fujitsu-Siemens D1522\00", align 1
@.str.111 = private unnamed_addr constant [18 x i8] c"Intel ICH5/AD1985\00", align 1
@.str.112 = private unnamed_addr constant [23 x i8] c"Intel D845WN (82801BA)\00", align 1
@.str.113 = private unnamed_addr constant [15 x i8] c"Intel D850EMV2\00", align 1
@.str.114 = private unnamed_addr constant [17 x i8] c"Intel ICH/AD1885\00", align 1
@.str.54 = private unnamed_addr constant [27 x i8] c"AC97 codec ready timeout.\0A\00", align 1
@.str.53 = private unnamed_addr constant [29 x i8] c"ali_codec_semaphore timeout\0A\00", align 1
@.str.51 = private unnamed_addr constant [57 x i8] c"codec_read %d: semaphore is not ready for register 0x%x\0A\00", align 1
@.str.52 = private unnamed_addr constant [47 x i8] c"codec_read %d: read timeout for register 0x%x\0A\00", align 1
@.str.50 = private unnamed_addr constant [54 x i8] c"codec_semaphore: semaphore is not ready [0x%x][0x%x]\0A\00", align 1
@.str.49 = private unnamed_addr constant [58 x i8] c"codec_write %d: semaphore is not ready for register 0x%x\0A\00", align 1
@.str.33 = private unnamed_addr constant [26 x i8] c"&(&chip->reg_lock)->rlock\00", align 1
@snd_intel8x0_create.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.34 = private unnamed_addr constant [29 x i8] c"AC'97 space ioremap problem\0A\00", align 1
@.str.35 = private unnamed_addr constant [34 x i8] c"Controller space ioremap problem\0A\00", align 1
@snd_intel8x0_create.bdbars = internal global [5 x i32] [i32 3, i32 6, i32 3, i32 6, i32 4], align 16
@snd_intel8x0_create.intel_regs = internal global [6 x %struct.anon.26] [%struct.anon.26 { i32 32, i32 0 }, %struct.anon.26 { i32 64, i32 16 }, %struct.anon.26 { i32 128, i32 32 }, %struct.anon.26 { i32 16777216, i32 64 }, %struct.anon.26 { i32 33554432, i32 80 }, %struct.anon.26 { i32 67108864, i32 96 }], align 16
@snd_intel8x0_create.nforce_regs = internal global [4 x %struct.anon.26] [%struct.anon.26 { i32 32, i32 0 }, %struct.anon.26 { i32 64, i32 16 }, %struct.anon.26 { i32 128, i32 32 }, %struct.anon.26 { i32 16, i32 112 }], align 16
@snd_intel8x0_create.ali_regs = internal global [6 x %struct.anon.26] [%struct.anon.26 { i32 65536, i32 64 }, %struct.anon.26 { i32 131072, i32 80 }, %struct.anon.26 { i32 262144, i32 96 }, %struct.anon.26 { i32 524288, i32 112 }, %struct.anon.26 { i32 4194304, i32 160 }, %struct.anon.26 { i32 8388608, i32 176 }], align 16
@.str.36 = private unnamed_addr constant [36 x i8] c"cannot allocate buffer descriptors\0A\00", align 1
@ich_codec_bits = internal global [3 x i32] [i32 256, i32 512, i32 268435456], align 4
@sis_codec_bits = internal global [3 x i32] [i32 256, i32 512, i32 262144], align 4
@.str.37 = private unnamed_addr constant [23 x i8] c"unable to grab IRQ %d\0A\00", align 1
@snd_intel8x0_create.ops = internal global %struct.snd_device_ops { i32 (%struct.snd_device*)* @snd_intel8x0_dev_free, i32 (%struct.snd_device*)* null, i32 (%struct.snd_device*)* null }, align 8
@.str.38 = private unnamed_addr constant [19 x i8] c"enable (forced) VM\00", align 1
@.str.39 = private unnamed_addr constant [20 x i8] c"disable (forced) VM\00", align 1
@.str.41 = private unnamed_addr constant [20 x i8] c"enable Parallels VM\00", align 1
@.str.40 = private unnamed_addr constant [11 x i8] c"enable KVM\00", align 1
@.str.42 = private unnamed_addr constant [17 x i8] c"%s optimization\0A\00", align 1
@.str.11 = private unnamed_addr constant [18 x i8] c"Intel 82801AA-ICH\00", align 1
@.str.12 = private unnamed_addr constant [19 x i8] c"Intel 82901AB-ICH0\00", align 1
@.str.13 = private unnamed_addr constant [19 x i8] c"Intel 82801BA-ICH2\00", align 1
@.str.14 = private unnamed_addr constant [12 x i8] c"Intel 440MX\00", align 1
@.str.15 = private unnamed_addr constant [19 x i8] c"Intel 82801CA-ICH3\00", align 1
@.str.16 = private unnamed_addr constant [19 x i8] c"Intel 82801DB-ICH4\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Intel ICH5\00", align 1
@.str.18 = private unnamed_addr constant [14 x i8] c"Intel 6300ESB\00", align 1
@.str.19 = private unnamed_addr constant [11 x i8] c"Intel ICH6\00", align 1
@.str.20 = private unnamed_addr constant [11 x i8] c"Intel ICH7\00", align 1
@.str.21 = private unnamed_addr constant [11 x i8] c"Intel ESB2\00", align 1
@.str.22 = private unnamed_addr constant [11 x i8] c"SiS SI7012\00", align 1
@.str.23 = private unnamed_addr constant [14 x i8] c"NVidia nForce\00", align 1
@.str.24 = private unnamed_addr constant [15 x i8] c"NVidia nForce2\00", align 1
@.str.25 = private unnamed_addr constant [15 x i8] c"NVidia nForce3\00", align 1
@.str.26 = private unnamed_addr constant [12 x i8] c"NVidia CK8S\00", align 1
@.str.27 = private unnamed_addr constant [13 x i8] c"NVidia CK804\00", align 1
@.str.28 = private unnamed_addr constant [11 x i8] c"NVidia CK8\00", align 1
@.str.29 = private unnamed_addr constant [13 x i8] c"NVidia MCP04\00", align 1
@.str.30 = private unnamed_addr constant [12 x i8] c"AMD AMD8111\00", align 1
@.str.31 = private unnamed_addr constant [11 x i8] c"AMD AMD768\00", align 1
@.str.32 = private unnamed_addr constant [10 x i8] c"ALi M5455\00", align 1
@spdif_aclink_defaults = internal global [2 x %struct.snd_pci_quirk] [%struct.snd_pci_quirk { i16 5243, i16 7194, i16 -1, i32 1, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.10, i32 0, i32 0) }, %struct.snd_pci_quirk zeroinitializer], align 16
@check_default_spdif_aclink.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__func__.check_default_spdif_aclink, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.6, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.7, i32 0, i32 0), i8 -82, i8 12, i8 0, i8 0 }, section "__verbose", align 8
@.str.7 = private unnamed_addr constant [33 x i8] c"Using SPDIF over AC-Link for %s\0A\00", align 1
@check_default_spdif_aclink.descriptor.8 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__func__.check_default_spdif_aclink, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.6, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.9, i32 0, i32 0), i8 -78, i8 12, i8 0, i8 0 }, section "__verbose", align 8
@.str.9 = private unnamed_addr constant [35 x i8] c"Using integrated SPDIF DMA for %s\0A\00", align 1
@__func__.check_default_spdif_aclink = private unnamed_addr constant [27 x i8] c"check_default_spdif_aclink\00", align 1
@.str.10 = private unnamed_addr constant [9 x i8] c"ASUS KN8\00", align 1

@__mod_pci__snd_intel8x0_ids_device_table = alias [24 x %struct.pci_device_id], [24 x %struct.pci_device_id]* @snd_intel8x0_ids
@init_module = alias i32 (), i32 ()* @intel8x0_driver_init
@cleanup_module = alias void (), void ()* @intel8x0_driver_exit

; Function Attrs: nounwind uwtable
define internal i32 @intel8x0_driver_init() #0 section ".init.text" {
entry:
  %call = call i32 @__pci_register_driver(%struct.pci_driver* @intel8x0_driver, %struct.module* @__this_module, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0))
  ret i32 %call
}

declare i32 @__pci_register_driver(%struct.pci_driver*, %struct.module*, i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_probe(%struct.pci_dev* %pci, %struct.pci_device_id* %pci_id) #2 {
entry:
  %card = alloca %struct.snd_card*, align 8
  %chip = alloca %struct.intel8x0*, align 8
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pci, i32 0, i32 35
  %0 = load i32, i32* @index, align 4, !tbaa !2
  %1 = load i8*, i8** @id, align 8, !tbaa !6
  %call = call i32 @snd_card_new(%struct.device* %dev, i32 %0, i8* %1, %struct.module* @__this_module, i32 0, %struct.snd_card** %card)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = load i32, i32* @spdif_aclink, align 4, !tbaa !2
  %cmp1 = icmp slt i32 %2, 0
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %call3 = call i32 @check_default_spdif_aclink(%struct.pci_dev* %pci)
  store i32 %call3, i32* @spdif_aclink, align 4, !tbaa !2
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %3 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %driver = getelementptr inbounds %struct.snd_card, %struct.snd_card* %3, i32 0, i32 2
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %driver, i32 0, i32 0
  %call5 = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0))
  %4 = load i32, i32* @spdif_aclink, align 4, !tbaa !2
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.end14, label %if.then6

if.then6:                                         ; preds = %if.end4
  %driver_data = getelementptr inbounds %struct.pci_device_id, %struct.pci_device_id* %pci_id, i32 0, i32 6
  %5 = load i64, i64* %driver_data, align 8, !tbaa !8
  %Pivot = icmp slt i64 %5, 4
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.then6
  %SwitchLeaf2 = icmp eq i64 %5, 4
  br i1 %SwitchLeaf2, label %sw.bb, label %if.end14

LeafBlock:                                        ; preds = %if.then6
  %SwitchLeaf = icmp eq i64 %5, 1
  br i1 %SwitchLeaf, label %sw.bb10, label %if.end14

sw.bb:                                            ; preds = %LeafBlock1
  %6 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %driver7 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %6, i32 0, i32 2
  %arraydecay8 = getelementptr inbounds [16 x i8], [16 x i8]* %driver7, i32 0, i32 0
  %call9 = call i8* @strcpy(i8* %arraydecay8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.2, i32 0, i32 0))
  br label %if.end14

sw.bb10:                                          ; preds = %LeafBlock
  %7 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %driver11 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %7, i32 0, i32 2
  %arraydecay12 = getelementptr inbounds [16 x i8], [16 x i8]* %driver11, i32 0, i32 0
  %call13 = call i8* @strcpy(i8* %arraydecay12, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.3, i32 0, i32 0))
  br label %if.end14

if.end14:                                         ; preds = %sw.bb10, %sw.bb, %LeafBlock, %LeafBlock1, %if.end4
  %8 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %shortname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %8, i32 0, i32 3
  %arraydecay15 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname, i32 0, i32 0
  %call16 = call i8* @strcpy(i8* %arraydecay15, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.4, i32 0, i32 0))
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end14
  %name.0 = phi %struct.shortname_table* [ getelementptr inbounds ([23 x %struct.shortname_table], [23 x %struct.shortname_table]* @shortnames, i32 0, i32 0), %if.end14 ], [ %incdec.ptr, %for.inc ]
  %id = getelementptr inbounds %struct.shortname_table, %struct.shortname_table* %name.0, i32 0, i32 0
  %9 = load i32, i32* %id, align 8, !tbaa !11
  %tobool17 = icmp ne i32 %9, 0
  br i1 %tobool17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %device = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pci, i32 0, i32 8
  %10 = load i16, i16* %device, align 2, !tbaa !13
  %conv = zext i16 %10 to i32
  %id18 = getelementptr inbounds %struct.shortname_table, %struct.shortname_table* %name.0, i32 0, i32 0
  %11 = load i32, i32* %id18, align 8, !tbaa !11
  %cmp19 = icmp eq i32 %conv, %11
  br i1 %cmp19, label %if.then21, label %for.inc

if.then21:                                        ; preds = %for.body
  %12 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %shortname22 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %12, i32 0, i32 3
  %arraydecay23 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname22, i32 0, i32 0
  %s = getelementptr inbounds %struct.shortname_table, %struct.shortname_table* %name.0, i32 0, i32 1
  %13 = load i8*, i8** %s, align 8, !tbaa !42
  %call24 = call i8* @strcpy(i8* %arraydecay23, i8* %13)
  br label %for.end

for.inc:                                          ; preds = %for.body
  %incdec.ptr = getelementptr inbounds %struct.shortname_table, %struct.shortname_table* %name.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %if.then21, %for.cond
  %14 = load i32, i32* @buggy_irq, align 4, !tbaa !2
  %cmp26 = icmp slt i32 %14, 0
  br i1 %cmp26, label %if.then28, label %if.end34

if.then28:                                        ; preds = %for.end
  %driver_data29 = getelementptr inbounds %struct.pci_device_id, %struct.pci_device_id* %pci_id, i32 0, i32 6
  %15 = load i64, i64* %driver_data29, align 8, !tbaa !8
  %cmp30 = icmp eq i64 %15, 4
  %.sink = select i1 %cmp30, i32 1, i32 0
  store i32 %.sink, i32* @buggy_irq, align 4, !tbaa !2
  br label %if.end34

if.end34:                                         ; preds = %if.then28, %for.end
  %call36 = call i32 @snd_intel8x0_create()
  %cmp37 = icmp slt i32 %call36, 0
  br i1 %cmp37, label %if.then39, label %if.end41

if.then39:                                        ; preds = %if.end34
  %16 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %call40 = call i32 @snd_card_free(%struct.snd_card* %16)
  br label %cleanup

if.end41:                                         ; preds = %if.end34
  %17 = load %struct.intel8x0*, %struct.intel8x0** %chip, align 8, !tbaa !6
  %18 = bitcast %struct.intel8x0* %17 to i8*
  %19 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %private_data = getelementptr inbounds %struct.snd_card, %struct.snd_card* %19, i32 0, i32 9
  store i8* %18, i8** %private_data, align 8, !tbaa !43
  %20 = load %struct.intel8x0*, %struct.intel8x0** %chip, align 8, !tbaa !6
  %21 = load i32, i32* @ac97_clock, align 4, !tbaa !2
  %22 = load i8*, i8** @ac97_quirk, align 8, !tbaa !6
  %call42 = call i32 @snd_intel8x0_mixer(%struct.intel8x0* %20, i32 %21, i8* %22)
  %cmp43 = icmp slt i32 %call42, 0
  br i1 %cmp43, label %if.then45, label %if.end47

if.then45:                                        ; preds = %if.end41
  %23 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %call46 = call i32 @snd_card_free(%struct.snd_card* %23)
  br label %cleanup

if.end47:                                         ; preds = %if.end41
  %24 = load %struct.intel8x0*, %struct.intel8x0** %chip, align 8, !tbaa !6
  %call48 = call i32 @snd_intel8x0_pcm(%struct.intel8x0* %24)
  %cmp49 = icmp slt i32 %call48, 0
  br i1 %cmp49, label %if.then51, label %if.end53

if.then51:                                        ; preds = %if.end47
  %25 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %call52 = call i32 @snd_card_free(%struct.snd_card* %25)
  br label %cleanup

if.end53:                                         ; preds = %if.end47
  %26 = load %struct.intel8x0*, %struct.intel8x0** %chip, align 8, !tbaa !6
  call void @snd_intel8x0_proc_init(%struct.intel8x0* %26)
  %27 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %longname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %27, i32 0, i32 4
  %arraydecay54 = getelementptr inbounds [80 x i8], [80 x i8]* %longname, i32 0, i32 0
  %28 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %shortname55 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %28, i32 0, i32 3
  %arraydecay56 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname55, i32 0, i32 0
  %29 = load %struct.intel8x0*, %struct.intel8x0** %chip, align 8, !tbaa !6
  %ac97 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %29, i32 0, i32 13
  %arrayidx = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97, i64 0, i64 0
  %30 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx, align 8, !tbaa !6
  %call57 = call i8* @snd_ac97_get_short_name(%struct.snd_ac97* %30)
  %31 = load %struct.intel8x0*, %struct.intel8x0** %chip, align 8, !tbaa !6
  %irq = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %31, i32 0, i32 1
  %32 = load i32, i32* %irq, align 4, !tbaa !50
  %call58 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay54, i64 80, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.5, i32 0, i32 0), i8* %arraydecay56, i8* %call57, i32 %32)
  %33 = load i32, i32* @ac97_clock, align 4, !tbaa !2
  %cmp59 = icmp eq i32 %33, 0
  %34 = load i32, i32* @ac97_clock, align 4
  %cmp61 = icmp eq i32 %34, 1
  %or.cond = or i1 %cmp59, %cmp61
  br i1 %or.cond, label %if.then63, label %if.end74

if.then63:                                        ; preds = %if.end53
  %35 = load i32, i32* @ac97_clock, align 4, !tbaa !2
  %cmp64 = icmp eq i32 %35, 0
  %36 = load %struct.intel8x0*, %struct.intel8x0** %chip, align 8, !tbaa !6
  br i1 %cmp64, label %if.then66, label %if.else72

if.then66:                                        ; preds = %if.then63
  %call67 = call i32 @intel8x0_in_clock_list(%struct.intel8x0* %36)
  %cmp68 = icmp eq i32 %call67, 0
  br i1 %cmp68, label %if.then70, label %if.end74

if.then70:                                        ; preds = %if.then66
  %37 = load %struct.intel8x0*, %struct.intel8x0** %chip, align 8, !tbaa !6
  call void @intel8x0_measure_ac97_clock(%struct.intel8x0* %37)
  br label %if.end74

if.else72:                                        ; preds = %if.then63
  call void @intel8x0_measure_ac97_clock(%struct.intel8x0* %36)
  br label %if.end74

if.end74:                                         ; preds = %if.else72, %if.then70, %if.then66, %if.end53
  %38 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %call75 = call i32 @snd_card_register(%struct.snd_card* %38)
  %cmp76 = icmp slt i32 %call75, 0
  %39 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  br i1 %cmp76, label %if.then78, label %if.end80

if.then78:                                        ; preds = %if.end74
  %call79 = call i32 @snd_card_free(%struct.snd_card* %39)
  br label %cleanup

if.end80:                                         ; preds = %if.end74
  %40 = bitcast %struct.snd_card* %39 to i8*
  call void @pci_set_drvdata(%struct.pci_dev* %pci, i8* %40)
  br label %cleanup

cleanup:                                          ; preds = %if.end80, %if.then78, %if.then51, %if.then45, %if.then39, %entry
  %retval.0 = phi i32 [ %call36, %if.then39 ], [ %call42, %if.then45 ], [ %call48, %if.then51 ], [ %call75, %if.then78 ], [ 0, %if.end80 ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_remove(%struct.pci_dev* %pci) #2 {
entry:
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %pci)
  %0 = bitcast i8* %call to %struct.snd_card*
  %call1 = call i32 @snd_card_free(%struct.snd_card* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @intel8x0_suspend(%struct.device* %dev) #2 {
entry:
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.snd_card*
  %private_data = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 9
  %1 = load i8*, i8** %private_data, align 8, !tbaa !43
  %2 = bitcast i8* %1 to %struct.intel8x0*
  call void @snd_power_change_state(%struct.snd_card* %0, i32 768)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %pcm_devs = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %2, i32 0, i32 6
  %3 = load i32, i32* %pcm_devs, align 8, !tbaa !54
  %cmp = icmp slt i32 %i.0, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %pcm = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %2, i32 0, i32 7
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x %struct.snd_pcm*], [6 x %struct.snd_pcm*]* %pcm, i64 0, i64 %idxprom
  %4 = load %struct.snd_pcm*, %struct.snd_pcm** %arrayidx, align 8, !tbaa !6
  %call1 = call i32 @snd_pcm_suspend_all(%struct.snd_pcm* %4)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %fix_nocache = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %2, i32 0, i32 9
  %bf.load = load i16, i16* %fix_nocache, align 8
  %bf.lshr = lshr i16 %bf.load, 8
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.end21

if.then:                                          ; preds = %for.end
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc18, %if.then
  %i.1 = phi i32 [ 0, %if.then ], [ %inc19, %for.inc18 ]
  %bdbars_count = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %2, i32 0, i32 21
  %5 = load i32, i32* %bdbars_count, align 8, !tbaa !55
  %cmp3 = icmp ult i32 %i.1, %5
  br i1 %cmp3, label %for.body4, label %if.end21

for.body4:                                        ; preds = %for.cond2
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %2, i32 0, i32 8
  %idxprom5 = sext i32 %i.1 to i64
  %arrayidx6 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 %idxprom5
  %substream = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx6, i32 0, i32 4
  %6 = load %struct.snd_pcm_substream*, %struct.snd_pcm_substream** %substream, align 8, !tbaa !56
  %tobool7 = icmp ne %struct.snd_pcm_substream* %6, null
  br i1 %tobool7, label %land.lhs.true, label %for.inc18

land.lhs.true:                                    ; preds = %for.body4
  %page_attr_changed = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx6, i32 0, i32 25
  %bf.load8 = load i8, i8* %page_attr_changed, align 4
  %bf.clear9 = and i8 %bf.load8, 1
  %bf.cast10 = zext i8 %bf.clear9 to i32
  %tobool11 = icmp ne i32 %bf.cast10, 0
  br i1 %tobool11, label %if.then12, label %for.inc18

if.then12:                                        ; preds = %land.lhs.true
  br label %for.inc18

for.inc18:                                        ; preds = %if.then12, %land.lhs.true, %for.body4
  %inc19 = add nsw i32 %i.1, 1
  br label %for.cond2

if.end21:                                         ; preds = %for.cond2, %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.body24, %if.end21
  %i.2 = phi i32 [ 0, %if.end21 ], [ %inc28, %for.body24 ]
  %ncodecs = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %2, i32 0, i32 16
  %7 = load i32, i32* %ncodecs, align 8, !tbaa !58
  %cmp23 = icmp ult i32 %i.2, %7
  br i1 %cmp23, label %for.body24, label %for.end29

for.body24:                                       ; preds = %for.cond22
  %ac97 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %2, i32 0, i32 13
  %idxprom25 = sext i32 %i.2 to i64
  %arrayidx26 = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97, i64 0, i64 %idxprom25
  %8 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx26, align 8, !tbaa !6
  call void @snd_ac97_suspend(%struct.snd_ac97* %8)
  %inc28 = add nsw i32 %i.2, 1
  br label %for.cond22

for.end29:                                        ; preds = %for.cond22
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %2, i32 0, i32 0
  %9 = load i32, i32* %device_type, align 8, !tbaa !59
  %cmp30 = icmp eq i32 %9, 1
  br i1 %cmp30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %for.end29
  %call32 = call zeroext i8 @igetbyte(%struct.intel8x0* %2, i32 128)
  %conv = zext i8 %call32 to i32
  %sdm_saved = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %2, i32 0, i32 11
  store i32 %conv, i32* %sdm_saved, align 8, !tbaa !60
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %for.end29
  %irq = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %2, i32 0, i32 1
  %10 = load i32, i32* %irq, align 4, !tbaa !50
  %cmp34 = icmp sge i32 %10, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %if.end33
  %irq37 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %2, i32 0, i32 1
  %11 = load i32, i32* %irq37, align 4, !tbaa !50
  %12 = bitcast %struct.intel8x0* %2 to i8*
  call void @free_irq(i32 %11, i8* %12)
  %irq38 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %2, i32 0, i32 1
  store i32 -1, i32* %irq38, align 4, !tbaa !50
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %if.end33
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @intel8x0_resume(%struct.device* %dev) #2 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -160
  %1 = bitcast i8* %add.ptr to %struct.pci_dev*
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %2 = bitcast i8* %call to %struct.snd_card*
  %private_data = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 9
  %3 = load i8*, i8** %private_data, align 8, !tbaa !43
  %4 = bitcast i8* %3 to %struct.intel8x0*
  call void @snd_intel8x0_chip_init(%struct.intel8x0* %4, i32 0)
  %irq = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %1, i32 0, i32 37
  %5 = load i32, i32* %irq, align 4, !tbaa !61
  %6 = bitcast %struct.intel8x0* %4 to i8*
  %call2 = call i32 @request_irq(i32 %5, i32 (i32, i8*)* @snd_intel8x0_interrupt, i64 128, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* %6)
  %tobool = icmp ne i32 %call2, 0
  %irq3 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %1, i32 0, i32 37
  %7 = load i32, i32* %irq3, align 4, !tbaa !61
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %call4 = call i32 @snd_card_disconnect(%struct.snd_card* %2)
  br label %cleanup89

if.end:                                           ; preds = %entry
  %irq6 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 1
  store i32 %7, i32* %irq6, align 4, !tbaa !50
  %irq7 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 1
  %8 = load i32, i32* %irq7, align 4, !tbaa !50
  call void @synchronize_irq(i32 %8)
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 0
  %9 = load i32, i32* %device_type, align 8, !tbaa !59
  %cmp = icmp ne i32 %9, 1
  %10 = load i32, i32* @spdif_aclink, align 4
  %tobool8 = icmp ne i32 %10, 0
  %or.cond = or i1 %cmp, %tobool8
  br i1 %or.cond, label %if.end11, label %if.then9

if.then9:                                         ; preds = %if.end
  %sdm_saved = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 11
  %11 = load i32, i32* %sdm_saved, align 8, !tbaa !60
  %conv = trunc i32 %11 to i8
  call void @iputbyte(%struct.intel8x0* %4, i32 128, i8 zeroext %conv)
  %call10 = call i32 @igetdword(%struct.intel8x0* %4, i32 44)
  %and = and i32 %call10, 1073741823
  %or = or i32 %and, -1073741824
  call void @iputdword(%struct.intel8x0* %4, i32 44, i32 %or)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end11
  %i.0 = phi i32 [ 0, %if.end11 ], [ %inc, %for.body ]
  %ncodecs = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 16
  %12 = load i32, i32* %ncodecs, align 8, !tbaa !58
  %cmp15 = icmp ult i32 %i.0, %12
  br i1 %cmp15, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ac97 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 13
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97, i64 0, i64 %idxprom
  %13 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx, align 8, !tbaa !6
  call void @snd_ac97_resume(%struct.snd_ac97* %13)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %fix_nocache17 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 9
  %bf.load18 = load i16, i16* %fix_nocache17, align 8
  %bf.lshr19 = lshr i16 %bf.load18, 8
  %bf.clear20 = and i16 %bf.lshr19, 1
  %bf.cast21 = zext i16 %bf.clear20 to i32
  %tobool22 = icmp ne i32 %bf.cast21, 0
  br i1 %tobool22, label %if.then23, label %if.end49

if.then23:                                        ; preds = %for.end
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc46, %if.then23
  %i.1 = phi i32 [ 0, %if.then23 ], [ %inc47, %for.inc46 ]
  %bdbars_count = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 21
  %14 = load i32, i32* %bdbars_count, align 8, !tbaa !55
  %cmp25 = icmp ult i32 %i.1, %14
  br i1 %cmp25, label %for.body27, label %if.end49

for.body27:                                       ; preds = %for.cond24
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 8
  %idxprom28 = sext i32 %i.1 to i64
  %arrayidx29 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 %idxprom28
  %substream = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx29, i32 0, i32 4
  %15 = load %struct.snd_pcm_substream*, %struct.snd_pcm_substream** %substream, align 8, !tbaa !56
  %tobool30 = icmp ne %struct.snd_pcm_substream* %15, null
  br i1 %tobool30, label %land.lhs.true31, label %for.inc46

land.lhs.true31:                                  ; preds = %for.body27
  %page_attr_changed = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx29, i32 0, i32 25
  %bf.load32 = load i8, i8* %page_attr_changed, align 4
  %bf.clear33 = and i8 %bf.load32, 1
  %bf.cast34 = zext i8 %bf.clear33 to i32
  %tobool35 = icmp ne i32 %bf.cast34, 0
  br i1 %tobool35, label %if.then36, label %for.inc46

if.then36:                                        ; preds = %land.lhs.true31
  br label %for.inc46

for.inc46:                                        ; preds = %if.then36, %land.lhs.true31, %for.body27
  %inc47 = add nsw i32 %i.1, 1
  br label %for.cond24

if.end49:                                         ; preds = %for.cond24, %for.end
  br label %for.cond50

for.cond50:                                       ; preds = %LeafBlock, %if.end49
  %i.2 = phi i32 [ 0, %if.end49 ], [ %inc87, %LeafBlock ]
  %bdbars_count51 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 21
  %16 = load i32, i32* %bdbars_count51, align 8, !tbaa !55
  %cmp52 = icmp ult i32 %i.2, %16
  br i1 %cmp52, label %for.body54, label %for.end88

for.body54:                                       ; preds = %for.cond50
  %ichd56 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 8
  %idxprom57 = sext i32 %i.2 to i64
  %arrayidx58 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd56, i64 0, i64 %idxprom57
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx58, i32 0, i32 1
  %17 = load i64, i64* %reg_offset, align 8, !tbaa !62
  %substream59 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx58, i32 0, i32 4
  %18 = load %struct.snd_pcm_substream*, %struct.snd_pcm_substream** %substream59, align 8, !tbaa !56
  %tobool60 = icmp ne %struct.snd_pcm_substream* %18, null
  br i1 %tobool60, label %lor.lhs.false, label %LeafBlock

lor.lhs.false:                                    ; preds = %for.body54
  %suspended = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx58, i32 0, i32 25
  %bf.load61 = load i8, i8* %suspended, align 4
  %bf.lshr62 = lshr i8 %bf.load61, 1
  %bf.clear63 = and i8 %bf.lshr62, 1
  %bf.cast64 = zext i8 %bf.clear63 to i32
  %tobool65 = icmp ne i32 %bf.cast64, 0
  br i1 %tobool65, label %if.end67, label %LeafBlock

if.end67:                                         ; preds = %lor.lhs.false
  %ichd68 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx58, i32 0, i32 0
  %19 = load i32, i32* %ichd68, align 8, !tbaa !63
  %cmp69 = icmp eq i32 %19, 1
  br i1 %cmp69, label %if.then71, label %if.end74

if.then71:                                        ; preds = %if.end67
  %substream72 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx58, i32 0, i32 4
  %20 = load %struct.snd_pcm_substream*, %struct.snd_pcm_substream** %substream72, align 8, !tbaa !56
  %runtime73 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %20, i32 0, i32 11
  %21 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime73, align 8, !tbaa !64
  call void @snd_intel8x0_setup_pcm_out(%struct.intel8x0* %4, %struct.snd_pcm_runtime* %21)
  br label %if.end74

if.end74:                                         ; preds = %if.then71, %if.end67
  %add = add i64 %17, 0
  %conv75 = trunc i64 %add to i32
  %bdbar_addr = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx58, i32 0, i32 3
  %22 = load i32, i32* %bdbar_addr, align 8, !tbaa !71
  call void @iputdword(%struct.intel8x0* %4, i32 %conv75, i32 %22)
  %add76 = add i64 %17, 5
  %conv77 = trunc i64 %add76 to i32
  %lvi = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx58, i32 0, i32 13
  %23 = load i32, i32* %lvi, align 8, !tbaa !72
  %conv78 = trunc i32 %23 to i8
  call void @iputbyte(%struct.intel8x0* %4, i32 %conv77, i8 zeroext %conv78)
  %add79 = add i64 %17, 4
  %conv80 = trunc i64 %add79 to i32
  %civ = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx58, i32 0, i32 15
  %24 = load i32, i32* %civ, align 8, !tbaa !73
  %conv81 = trunc i32 %24 to i8
  call void @iputbyte(%struct.intel8x0* %4, i32 %conv80, i8 zeroext %conv81)
  %roff_sr = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx58, i32 0, i32 19
  %25 = load i32, i32* %roff_sr, align 8, !tbaa !74
  %conv82 = zext i32 %25 to i64
  %add83 = add i64 %17, %conv82
  %conv84 = trunc i64 %add83 to i32
  call void @iputbyte(%struct.intel8x0* %4, i32 %conv84, i8 zeroext 28)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end74, %lor.lhs.false, %for.body54
  %inc87 = add nsw i32 %i.2, 1
  br label %for.cond50

for.end88:                                        ; preds = %for.cond50
  call void @snd_power_change_state(%struct.snd_card* %2, i32 0)
  br label %cleanup89

cleanup89:                                        ; preds = %for.end88, %if.then
  %retval.0 = phi i32 [ -5, %if.then ], [ 0, %for.end88 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_get_drvdata(%struct.device* %dev) #3 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !75
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_chip_init(%struct.intel8x0* %chip, i32 %probing) #2 {
entry:
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %0 = load i32, i32* %device_type, align 8, !tbaa !59
  %cmp = icmp ne i32 %0, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i32 @snd_intel8x0_ich_chip_init(%struct.intel8x0* %chip, i32 %probing)
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %cleanup, label %if.end

if.end:                                           ; preds = %if.then
  %call3 = call zeroext i16 @iagetword(%struct.intel8x0* %chip, i32 0)
  br label %if.end8

if.else:                                          ; preds = %entry
  %call4 = call i32 @snd_intel8x0_ali_chip_init(%struct.intel8x0* %chip, i32 %probing)
  %cmp5 = icmp slt i32 %call4, 0
  br i1 %cmp5, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.else, %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end8
  %i.0 = phi i32 [ 0, %if.end8 ], [ %inc, %for.body ]
  %bdbars_count = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 21
  %1 = load i32, i32* %bdbars_count, align 8, !tbaa !55
  %cmp9 = icmp ult i32 %i.0, %1
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 %idxprom
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 1
  %2 = load i64, i64* %reg_offset, align 8, !tbaa !62
  %add = add i64 11, %2
  %conv = trunc i64 %add to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv, i8 zeroext 0)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond10

for.cond10:                                       ; preds = %for.body14, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc22, %for.body14 ]
  %bdbars_count11 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 21
  %3 = load i32, i32* %bdbars_count11, align 8, !tbaa !55
  %cmp12 = icmp ult i32 %i.1, %3
  br i1 %cmp12, label %for.body14, label %for.end23

for.body14:                                       ; preds = %for.cond10
  %ichd15 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %idxprom16 = zext i32 %i.1 to i64
  %arrayidx17 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd15, i64 0, i64 %idxprom16
  %reg_offset18 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx17, i32 0, i32 1
  %4 = load i64, i64* %reg_offset18, align 8, !tbaa !62
  %add19 = add i64 11, %4
  %conv20 = trunc i64 %add19 to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv20, i8 zeroext 2)
  %inc22 = add i32 %i.1, 1
  br label %for.cond10

for.end23:                                        ; preds = %for.cond10
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc47, %for.end23
  %i.2 = phi i32 [ 0, %for.end23 ], [ %inc48, %for.inc47 ]
  %bdbars_count25 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 21
  %5 = load i32, i32* %bdbars_count25, align 8, !tbaa !55
  %cmp26 = icmp ult i32 %i.2, %5
  br i1 %cmp26, label %for.body28, label %for.end49

for.body28:                                       ; preds = %for.cond24
  br label %while.cond

while.cond:                                       ; preds = %if.end42, %for.body28
  %timeout.0 = phi i32 [ 100000, %for.body28 ], [ %dec, %if.end42 ]
  %dec = add i32 %timeout.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %if.then45, label %while.body

while.body:                                       ; preds = %while.cond
  %ichd31 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %idxprom32 = zext i32 %i.2 to i64
  %arrayidx33 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd31, i64 0, i64 %idxprom32
  %reg_offset34 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx33, i32 0, i32 1
  %6 = load i64, i64* %reg_offset34, align 8, !tbaa !62
  %add35 = add i64 11, %6
  %conv36 = trunc i64 %add35 to i32
  %call37 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 %conv36)
  %conv38 = zext i8 %call37 to i32
  %and = and i32 %conv38, 2
  %cmp39 = icmp eq i32 %and, 0
  br i1 %cmp39, label %while.end, label %if.end42

if.end42:                                         ; preds = %while.body
  br label %while.cond

while.end:                                        ; preds = %while.body
  %cmp43 = icmp eq i32 %dec, 0
  br i1 %cmp43, label %if.then45, label %for.inc47

if.then45:                                        ; preds = %while.end, %while.cond
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %for.inc47

for.inc47:                                        ; preds = %if.then45, %while.end
  %inc48 = add i32 %i.2, 1
  br label %for.cond24

for.end49:                                        ; preds = %for.cond24
  br label %for.cond50

for.cond50:                                       ; preds = %for.body54, %for.end49
  %i.3 = phi i32 [ 0, %for.end49 ], [ %inc65, %for.body54 ]
  %bdbars_count51 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 21
  %7 = load i32, i32* %bdbars_count51, align 8, !tbaa !55
  %cmp52 = icmp ult i32 %i.3, %7
  br i1 %cmp52, label %for.body54, label %cleanup

for.body54:                                       ; preds = %for.cond50
  %ichd55 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %idxprom56 = zext i32 %i.3 to i64
  %arrayidx57 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd55, i64 0, i64 %idxprom56
  %reg_offset58 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx57, i32 0, i32 1
  %8 = load i64, i64* %reg_offset58, align 8, !tbaa !62
  %add59 = add i64 0, %8
  %conv60 = trunc i64 %add59 to i32
  %ichd61 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %idxprom62 = zext i32 %i.3 to i64
  %arrayidx63 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd61, i64 0, i64 %idxprom62
  %bdbar_addr = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx63, i32 0, i32 3
  %9 = load i32, i32* %bdbar_addr, align 8, !tbaa !71
  call void @iputdword(%struct.intel8x0* %chip, i32 %conv60, i32 %9)
  %inc65 = add i32 %i.3, 1
  br label %for.cond50

cleanup:                                          ; preds = %for.cond50, %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_interrupt(i32 %irq, i8* %dev_id) #2 {
entry:
  %0 = bitcast i8* %dev_id to %struct.intel8x0*
  %int_sta_reg = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 23
  %1 = load i32, i32* %int_sta_reg, align 8, !tbaa !76
  %call = call i32 @igetdword(%struct.intel8x0* %0, i32 %1)
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %int_sta_mask = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 24
  %2 = load i32, i32* %int_sta_mask, align 4, !tbaa !77
  %and = and i32 %call, %2
  %cmp1 = icmp eq i32 %and, 0
  br i1 %cmp1, label %if.then2, label %if.end10

if.then2:                                         ; preds = %if.end
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then3, label %if.end8

if.then3:                                         ; preds = %if.then2
  %int_sta_reg4 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 23
  %3 = load i32, i32* %int_sta_reg4, align 8, !tbaa !76
  call void @iputdword(%struct.intel8x0* %0, i32 %3, i32 %call)
  %buggy_irq = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 9
  %bf.load = load i16, i16* %buggy_irq, align 8
  %bf.lshr = lshr i16 %bf.load, 9
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool5 = icmp ne i32 %bf.cast, 0
  %call. = select i1 %tobool5, i32 %call, i32 0
  br label %if.end8

if.end8:                                          ; preds = %if.then3, %if.then2
  %status.1 = phi i32 [ %call., %if.then3 ], [ %call, %if.then2 ]
  %tobool9 = icmp ne i32 %status.1, 0
  %cond = select i1 %tobool9, i32 1, i32 0
  br label %cleanup

if.end10:                                         ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end10
  %i.0 = phi i32 [ 0, %if.end10 ], [ %inc, %for.inc ]
  %bdbars_count = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 21
  %4 = load i32, i32* %bdbars_count, align 8, !tbaa !55
  %cmp11 = icmp ult i32 %i.0, %4
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 8
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 %idxprom
  %int_sta_mask12 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 21
  %5 = load i32, i32* %int_sta_mask12, align 8, !tbaa !78
  %and13 = and i32 %call, %5
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then15, label %for.inc

if.then15:                                        ; preds = %for.body
  call void @snd_intel8x0_update(%struct.intel8x0* %0, %struct.ichdev* %arrayidx)
  br label %for.inc

for.inc:                                          ; preds = %if.then15, %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %int_sta_reg17 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 23
  %6 = load i32, i32* %int_sta_reg17, align 8, !tbaa !76
  %int_sta_mask18 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 24
  %7 = load i32, i32* %int_sta_mask18, align 4, !tbaa !77
  %and19 = and i32 %call, %7
  call void @iputdword(%struct.intel8x0* %0, i32 %6, i32 %and19)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.end8, %entry
  %retval.0 = phi i32 [ %cond, %if.end8 ], [ 1, %for.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @request_irq(i32 %irq, i32 (i32, i8*)* %handler, i64 %flags, i8* %name, i8* %dev) #3 {
entry:
  %call = call i32 @request_threaded_irq(i32 %irq, i32 (i32, i8*)* %handler, i32 (i32, i8*)* null, i64 %flags, i8* %name, i8* %dev)
  ret i32 %call
}

declare void @dev_err(%struct.device*, i8*, ...) #1

declare i32 @snd_card_disconnect(%struct.snd_card*) #1

declare void @synchronize_irq(i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @iputbyte(%struct.intel8x0* %chip, i32 %offset, i8 zeroext %val) #3 {
entry:
  %bmaddr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 3
  %0 = load i8*, i8** %bmaddr, align 8, !tbaa !79
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  call void @iowrite8(i8 zeroext %val, i8* %add.ptr)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @igetdword(%struct.intel8x0* %chip, i32 %offset) #3 {
entry:
  %bmaddr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 3
  %0 = load i8*, i8** %bmaddr, align 8, !tbaa !79
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %call = call i32 @ioread32(i8* %add.ptr)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @iputdword(%struct.intel8x0* %chip, i32 %offset, i32 %val) #3 {
entry:
  %bmaddr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 3
  %0 = load i8*, i8** %bmaddr, align 8, !tbaa !79
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  call void @iowrite32(i32 %val, i8* %add.ptr)
  ret void
}

declare void @snd_ac97_resume(%struct.snd_ac97*) #1

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_setup_pcm_out(%struct.intel8x0* %chip, %struct.snd_pcm_runtime* %runtime) #2 {
entry:
  %rate = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 14
  %0 = load i32, i32* %rate, align 4, !tbaa !80
  %cmp = icmp ugt i32 %0, 48000
  %conv = zext i1 %cmp to i32
  %reg_lock = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reg_lock, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %1 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i1) #6
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %2 = load i32, i32* %device_type, align 8, !tbaa !59
  %Pivot = icmp slt i32 %2, 3
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %2, 3
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %2, 2
  br i1 %SwitchLeaf, label %sw.bb9, label %sw.default

sw.bb:                                            ; preds = %LeafBlock1
  %call = call i32 @igetdword(%struct.intel8x0* %chip, i32 0)
  %and = and i32 %call, -769
  %channels = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 15
  %3 = load i32, i32* %channels, align 8, !tbaa !88
  %cmp1 = icmp eq i32 %3, 4
  %tobool = icmp ne i32 %conv, 0
  %or.cond = or i1 %cmp1, %tobool
  br i1 %or.cond, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %or = or i32 %and, 256
  br label %if.end8

if.else:                                          ; preds = %sw.bb
  %channels3 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 15
  %4 = load i32, i32* %channels3, align 8, !tbaa !88
  %cmp4 = icmp eq i32 %4, 6
  %or7 = or i32 %and, 512
  %or7.and = select i1 %cmp4, i32 %or7, i32 %and
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then
  %cnt.1 = phi i32 [ %or, %if.then ], [ %or7.and, %if.else ]
  call void @iputdword(%struct.intel8x0* %chip, i32 0, i32 %cnt.1)
  br label %sw.epilog

sw.bb9:                                           ; preds = %LeafBlock
  %call10 = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  %and11 = and i32 %call10, -193
  %channels12 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 15
  %5 = load i32, i32* %channels12, align 8, !tbaa !88
  %cmp13 = icmp eq i32 %5, 4
  %tobool16 = icmp ne i32 %conv, 0
  %or.cond3 = or i1 %cmp13, %tobool16
  br i1 %or.cond3, label %if.then17, label %if.else19

if.then17:                                        ; preds = %sw.bb9
  %or18 = or i32 %and11, 64
  br label %if.end26

if.else19:                                        ; preds = %sw.bb9
  %channels20 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 15
  %6 = load i32, i32* %channels20, align 8, !tbaa !88
  %cmp21 = icmp eq i32 %6, 6
  %or24 = or i32 %and11, 128
  %or24.and11 = select i1 %cmp21, i32 %or24, i32 %and11
  br label %if.end26

if.end26:                                         ; preds = %if.else19, %if.then17
  %cnt.3 = phi i32 [ %or18, %if.then17 ], [ %or24.and11, %if.else19 ]
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 %cnt.3)
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %call27 = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  %and28 = and i32 %call27, -7340033
  %channels29 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 15
  %7 = load i32, i32* %channels29, align 8, !tbaa !88
  %cmp30 = icmp eq i32 %7, 4
  %tobool33 = icmp ne i32 %conv, 0
  %or.cond4 = or i1 %cmp30, %tobool33
  br i1 %or.cond4, label %if.then34, label %if.else36

if.then34:                                        ; preds = %sw.default
  %or35 = or i32 %and28, 1048576
  br label %if.end50

if.else36:                                        ; preds = %sw.default
  %channels37 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 15
  %8 = load i32, i32* %channels37, align 8, !tbaa !88
  %cmp38 = icmp eq i32 %8, 6
  br i1 %cmp38, label %if.then40, label %if.else42

if.then40:                                        ; preds = %if.else36
  %or41 = or i32 %and28, 2097152
  br label %if.end50

if.else42:                                        ; preds = %if.else36
  %channels43 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 15
  %9 = load i32, i32* %channels43, align 8, !tbaa !88
  %cmp44 = icmp eq i32 %9, 8
  %or47 = or i32 %and28, 3145728
  %or47.and28 = select i1 %cmp44, i32 %or47, i32 %and28
  br label %if.end50

if.end50:                                         ; preds = %if.else42, %if.then40, %if.then34
  %cnt.6 = phi i32 [ %or35, %if.then34 ], [ %or41, %if.then40 ], [ %or47.and28, %if.else42 ]
  %device_type51 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %10 = load i32, i32* %device_type51, align 8, !tbaa !59
  %cmp52 = icmp eq i32 %10, 4
  br i1 %cmp52, label %if.then54, label %if.else62

if.then54:                                        ; preds = %if.end50
  %and55 = and i32 %cnt.6, 3145728
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %if.then57, label %if.end73

if.then57:                                        ; preds = %if.then54
  %and58 = and i32 %cnt.6, -3145729
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 %and58)
  %reg_lock59 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  %11 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reg_lock59, i32 0, i32 0
  %rlock.i3 = bitcast %union.anon.1* %11 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i3) #6
  call void @msleep(i32 50)
  %reg_lock60 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  %12 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reg_lock60, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %12 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i) #6
  br label %if.end73

if.else62:                                        ; preds = %if.end50
  %device_type63 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %13 = load i32, i32* %device_type63, align 8, !tbaa !59
  %cmp64 = icmp eq i32 %13, 1
  br i1 %cmp64, label %if.then66, label %if.end73

if.then66:                                        ; preds = %if.else62
  %sample_bits = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 22
  %14 = load i32, i32* %sample_bits, align 4, !tbaa !89
  %cmp67 = icmp ugt i32 %14, 16
  %or70 = or i32 %cnt.6, 4194304
  %or70.cnt.6 = select i1 %cmp67, i32 %or70, i32 %cnt.6
  br label %if.end73

if.end73:                                         ; preds = %if.then66, %if.else62, %if.then57, %if.then54
  %cnt.9 = phi i32 [ %cnt.6, %if.then57 ], [ %cnt.6, %if.then54 ], [ %or70.cnt.6, %if.then66 ], [ %cnt.6, %if.else62 ]
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 %cnt.9)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end73, %if.end26, %if.end8
  %reg_lock74 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  %15 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reg_lock74, i32 0, i32 0
  %rlock.i2 = bitcast %union.anon.1* %15 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i2) #6
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @snd_power_change_state(%struct.snd_card* %card, i32 %state) #3 {
entry:
  %power_state = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 33
  store i32 %state, i32* %power_state, align 4, !tbaa !90
  %power_sleep = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 35
  call void @__wake_up(%struct.__wait_queue_head* %power_sleep, i32 3, i32 1, i8* null)
  ret void
}

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #1

declare void @msleep(i32) #1

declare void @_raw_spin_unlock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare void @_raw_spin_lock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare void @iowrite32(i32, i8*) #1

declare i32 @ioread32(i8*) #1

declare void @iowrite8(i8 zeroext, i8*) #1

declare i32 @request_threaded_irq(i32, i32 (i32, i8*)*, i32 (i32, i8*)*, i64, i8*, i8*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @snd_intel8x0_update(%struct.intel8x0* %chip, %struct.ichdev* %ichdev) #3 {
entry:
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 1
  %0 = load i64, i64* %reg_offset, align 8, !tbaa !62
  %reg_lock = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reg_lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %1 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %roff_sr = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 19
  %2 = load i32, i32* %roff_sr, align 8, !tbaa !74
  %conv5 = zext i32 %2 to i64
  %add = add i64 %0, %conv5
  %conv6 = trunc i64 %add to i32
  %call7 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 %conv6)
  %conv8 = zext i8 %call7 to i32
  %add9 = add i64 %0, 4
  %conv10 = trunc i64 %add9 to i32
  %call11 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 %conv10)
  %conv12 = zext i8 %call11 to i32
  %and = and i32 %conv8, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else, label %if.end28

if.else:                                          ; preds = %entry
  %civ13 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 15
  %3 = load i32, i32* %civ13, align 8, !tbaa !73
  %cmp14 = icmp eq i32 %conv12, %3
  %civ17 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 15
  %4 = load i32, i32* %civ17, align 8, !tbaa !73
  br i1 %cmp14, label %if.then16, label %if.else20

if.then16:                                        ; preds = %if.else
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %civ17, align 8, !tbaa !73
  %civ18 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 15
  %5 = load i32, i32* %civ18, align 8, !tbaa !73
  %and19 = and i32 %5, 31
  store i32 %and19, i32* %civ18, align 8, !tbaa !73
  br label %if.end28

if.else20:                                        ; preds = %if.else
  %sub = sub nsw i32 %conv12, %4
  %cmp22 = icmp slt i32 %sub, 0
  %add25 = add nsw i32 %sub, 32
  %add25.sub = select i1 %cmp22, i32 %add25, i32 %sub
  %civ26 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 15
  store i32 %conv12, i32* %civ26, align 8, !tbaa !73
  br label %if.end28

if.end28:                                         ; preds = %if.else20, %if.then16, %entry
  %step.2 = phi i32 [ 0, %entry ], [ 1, %if.then16 ], [ %add25.sub, %if.else20 ]
  %fragsize1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 8
  %6 = load i32, i32* %fragsize1, align 4, !tbaa !91
  %mul = mul i32 %step.2, %6
  %position = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 9
  %7 = load i32, i32* %position, align 8, !tbaa !92
  %add29 = add i32 %7, %mul
  store i32 %add29, i32* %position, align 8, !tbaa !92
  %in_measurement = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load = load i16, i16* %in_measurement, align 8
  %bf.lshr = lshr i16 %bf.load, 7
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool30 = icmp ne i32 %bf.cast, 0
  br i1 %tobool30, label %if.end33, label %if.then31

if.then31:                                        ; preds = %if.end28
  %size = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 6
  %8 = load i32, i32* %size, align 4, !tbaa !93
  %position32 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 9
  %9 = load i32, i32* %position32, align 8, !tbaa !92
  %rem = urem i32 %9, %8
  store i32 %rem, i32* %position32, align 8, !tbaa !92
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end28
  %lvi = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 13
  %10 = load i32, i32* %lvi, align 8, !tbaa !72
  %add34 = add nsw i32 %10, %step.2
  store i32 %add34, i32* %lvi, align 8, !tbaa !72
  %lvi35 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 13
  %11 = load i32, i32* %lvi35, align 8, !tbaa !72
  %and36 = and i32 %11, 31
  store i32 %and36, i32* %lvi35, align 8, !tbaa !72
  %add37 = add i64 %0, 5
  %conv38 = trunc i64 %add37 to i32
  %lvi39 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 13
  %12 = load i32, i32* %lvi39, align 8, !tbaa !72
  %conv40 = trunc i32 %12 to i8
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv38, i8 zeroext %conv40)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end33
  %i.0 = phi i32 [ 0, %if.end33 ], [ %inc58, %for.inc ]
  %ack.0 = phi i32 [ 0, %if.end33 ], [ %ack.1, %for.inc ]
  %cmp41 = icmp slt i32 %i.0, %step.2
  br i1 %cmp41, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %lvi_frag = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 14
  %13 = load i32, i32* %lvi_frag, align 4, !tbaa !94
  %inc43 = add nsw i32 %13, 1
  store i32 %inc43, i32* %lvi_frag, align 4, !tbaa !94
  %frags = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 12
  %14 = load i32, i32* %frags, align 4, !tbaa !95
  %lvi_frag44 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 14
  %15 = load i32, i32* %lvi_frag44, align 4, !tbaa !94
  %rem45 = srem i32 %15, %14
  store i32 %rem45, i32* %lvi_frag44, align 4, !tbaa !94
  %physbuf = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 5
  %16 = load i32, i32* %physbuf, align 8, !tbaa !96
  %lvi_frag46 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 14
  %17 = load i32, i32* %lvi_frag46, align 4, !tbaa !94
  %fragsize147 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 8
  %18 = load i32, i32* %fragsize147, align 4, !tbaa !91
  %mul48 = mul i32 %17, %18
  %add49 = add i32 %16, %mul48
  %bdbar = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 2
  %19 = load i32*, i32** %bdbar, align 8, !tbaa !97
  %lvi50 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 13
  %20 = load i32, i32* %lvi50, align 8, !tbaa !72
  %mul51 = mul nsw i32 %20, 2
  %idxprom = sext i32 %mul51 to i64
  %arrayidx = getelementptr inbounds i32, i32* %19, i64 %idxprom
  store i32 %add49, i32* %arrayidx, align 4, !tbaa !2
  %ack52 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 16
  %21 = load i32, i32* %ack52, align 4, !tbaa !98
  %dec = add nsw i32 %21, -1
  store i32 %dec, i32* %ack52, align 4, !tbaa !98
  %cmp53 = icmp eq i32 %dec, 0
  br i1 %cmp53, label %if.then55, label %for.inc

if.then55:                                        ; preds = %for.body
  %ack_reload = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 17
  %22 = load i32, i32* %ack_reload, align 8, !tbaa !99
  %ack56 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 16
  store i32 %22, i32* %ack56, align 4, !tbaa !98
  br label %for.inc

for.inc:                                          ; preds = %if.then55, %for.body
  %ack.1 = phi i32 [ 1, %if.then55 ], [ %ack.0, %for.body ]
  %inc58 = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %reg_lock59 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  %23 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reg_lock59, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %23 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #6
  %tobool60 = icmp ne i32 %ack.0, 0
  br i1 %tobool60, label %land.lhs.true, label %if.end64

land.lhs.true:                                    ; preds = %for.end
  %substream = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 4
  %24 = load %struct.snd_pcm_substream*, %struct.snd_pcm_substream** %substream, align 8, !tbaa !56
  %tobool61 = icmp ne %struct.snd_pcm_substream* %24, null
  br i1 %tobool61, label %if.then62, label %if.end64

if.then62:                                        ; preds = %land.lhs.true
  %substream63 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 4
  %25 = load %struct.snd_pcm_substream*, %struct.snd_pcm_substream** %substream63, align 8, !tbaa !56
  call void @snd_pcm_period_elapsed(%struct.snd_pcm_substream* %25)
  br label %if.end64

if.end64:                                         ; preds = %if.then62, %land.lhs.true, %for.end
  %roff_sr65 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 19
  %26 = load i32, i32* %roff_sr65, align 8, !tbaa !74
  %conv66 = zext i32 %26 to i64
  %add67 = add i64 %0, %conv66
  %conv68 = trunc i64 %add67 to i32
  %and69 = and i32 %conv8, 28
  %conv70 = trunc i32 %and69 to i8
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv68, i8 zeroext %conv70)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #4

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 %offset) #3 {
entry:
  %bmaddr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 3
  %0 = load i8*, i8** %bmaddr, align 8, !tbaa !79
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %call = call i32 @ioread8(i8* %add.ptr)
  %conv = trunc i32 %call to i8
  ret i8 %conv
}

declare void @snd_pcm_period_elapsed(%struct.snd_pcm_substream*) #1

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #1 section ".spinlock.text"

declare i32 @ioread8(i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ich_chip_init(%struct.intel8x0* %chip, i32 %probing) #2 {
entry:
  %val = alloca i32, align 4
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %0 = load i32, i32* %device_type, align 8, !tbaa !59
  %cmp = icmp eq i32 %0, 4
  %or = or i32 32992, 16
  %or. = select i1 %cmp, i32 %or, i32 32992
  %call = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  %and = and i32 %call, %or.
  call void @iputdword(%struct.intel8x0* %chip, i32 48, i32 %and)
  %pci = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %1 = load %struct.pci_dev*, %struct.pci_dev** %pci, align 8, !tbaa !100
  %call1 = call %struct.snd_pci_quirk* @snd_pci_quirk_lookup(%struct.pci_dev* %1, %struct.snd_pci_quirk* getelementptr inbounds ([2 x %struct.snd_pci_quirk], [2 x %struct.snd_pci_quirk]* @ich_chip_reset_mode, i32 0, i32 0))
  %tobool = icmp ne %struct.snd_pci_quirk* %call1, null
  br i1 %tobool, label %if.else, label %if.then2

if.then2:                                         ; preds = %entry
  %call3 = call i32 @snd_intel8x0_ich_chip_cold_reset(%struct.intel8x0* %chip)
  br label %if.end5

if.else:                                          ; preds = %entry
  %call4 = call i32 @snd_intel8x0_ich_chip_reset(%struct.intel8x0* %chip)
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then2
  %err.0 = phi i32 [ %call4, %if.else ], [ %call3, %if.then2 ]
  %cmp6 = icmp slt i32 %err.0, 0
  br i1 %cmp6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end5
  %tobool9 = icmp ne i32 %probing, 0
  br i1 %tobool9, label %if.then10, label %if.else60

if.then10:                                        ; preds = %if.end8
  %2 = load volatile i64, i64* @jiffies, align 8, !tbaa !101
  %add = add i64 %2, 250
  br label %do.body

do.body:                                          ; preds = %land.lhs.true, %if.then10
  %call11 = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  %codec_isr_bits = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 18
  %3 = load i32, i32* %codec_isr_bits, align 8, !tbaa !102
  %and12 = and i32 %call11, %3
  %cond = icmp eq i32 %and12, 0
  br i1 %cond, label %if.end15, label %if.end30

if.end15:                                         ; preds = %do.body
  %call16 = call i64 @schedule_timeout_uninterruptible(i64 1)
  %tobool18 = icmp ne i32 1, 0
  br i1 %tobool18, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %if.end15
  %4 = load volatile i64, i64* @jiffies, align 8, !tbaa !101
  %sub = sub i64 %add, %4
  %cmp25 = icmp sge i64 %sub, 0
  br i1 %cmp25, label %do.body, label %do.end

do.end:                                           ; preds = %land.lhs.true, %if.end15
  %tobool27 = icmp ne i32 %and12, 0
  br i1 %tobool27, label %if.end30, label %if.then28

if.then28:                                        ; preds = %do.end
  %call29 = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end30:                                         ; preds = %do.end, %do.body
  %5 = load volatile i64, i64* @jiffies, align 8, !tbaa !101
  %add31 = add i64 %5, 62
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end30
  %status.1 = phi i32 [ %and12, %if.end30 ], [ %or59, %while.body ]
  %codec_isr_bits32 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 18
  %6 = load i32, i32* %codec_isr_bits32, align 8, !tbaa !102
  %cmp33 = icmp ne i32 %status.1, %6
  br i1 %cmp33, label %land.rhs35, label %if.end101

land.rhs35:                                       ; preds = %while.cond
  %tobool41 = icmp ne i32 1, 0
  br i1 %tobool41, label %land.lhs.true42, label %if.end101

land.lhs.true42:                                  ; preds = %land.rhs35
  %7 = load volatile i64, i64* @jiffies, align 8, !tbaa !101
  %sub50 = sub i64 %add31, %7
  %cmp51 = icmp sge i64 %sub50, 0
  br i1 %cmp51, label %while.body, label %if.end101

while.body:                                       ; preds = %land.lhs.true42
  %call55 = call i64 @schedule_timeout_uninterruptible(i64 1)
  %call56 = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  %codec_isr_bits57 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 18
  %8 = load i32, i32* %codec_isr_bits57, align 8, !tbaa !102
  %and58 = and i32 %call56, %8
  %or59 = or i32 %status.1, %and58
  br label %while.cond

if.else60:                                        ; preds = %if.end8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else60
  %status.2 = phi i32 [ 0, %if.else60 ], [ %status.3, %for.inc ]
  %i.0 = phi i32 [ 0, %if.else60 ], [ %inc, %for.inc ]
  %ncodecs = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 16
  %9 = load i32, i32* %ncodecs, align 8, !tbaa !58
  %cmp61 = icmp ult i32 %i.0, %9
  br i1 %cmp61, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ac97 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 13
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97, i64 0, i64 %idxprom
  %10 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx, align 8, !tbaa !6
  %tobool63 = icmp ne %struct.snd_ac97* %10, null
  br i1 %tobool63, label %if.then64, label %for.inc

if.then64:                                        ; preds = %for.body
  %codec_bit = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 17
  %11 = load i32*, i32** %codec_bit, align 8, !tbaa !103
  %ac97_sdin = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 14
  %idxprom65 = sext i32 %i.0 to i64
  %arrayidx66 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin, i64 0, i64 %idxprom65
  %12 = load i32, i32* %arrayidx66, align 4, !tbaa !2
  %idxprom67 = zext i32 %12 to i64
  %arrayidx68 = getelementptr inbounds i32, i32* %11, i64 %idxprom67
  %13 = load i32, i32* %arrayidx68, align 4, !tbaa !2
  %or69 = or i32 %status.2, %13
  br label %for.inc

for.inc:                                          ; preds = %if.then64, %for.body
  %status.3 = phi i32 [ %or69, %if.then64 ], [ %status.2, %for.body ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load volatile i64, i64* @jiffies, align 8, !tbaa !101
  %add71 = add i64 %14, 250
  br label %do.body72

do.body72:                                        ; preds = %land.lhs.true88, %for.end
  %call73 = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  %codec_isr_bits74 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 18
  %15 = load i32, i32* %codec_isr_bits74, align 8, !tbaa !102
  %and75 = and i32 %call73, %15
  %cmp76 = icmp eq i32 %status.2, %and75
  br i1 %cmp76, label %if.end101, label %if.end79

if.end79:                                         ; preds = %do.body72
  %call80 = call i64 @schedule_timeout_uninterruptible(i64 1)
  %tobool87 = icmp ne i32 1, 0
  br i1 %tobool87, label %land.lhs.true88, label %if.end101

land.lhs.true88:                                  ; preds = %if.end79
  %16 = load volatile i64, i64* @jiffies, align 8, !tbaa !101
  %sub96 = sub i64 %add71, %16
  %cmp97 = icmp sge i64 %sub96, 0
  br i1 %cmp97, label %do.body72, label %if.end101

if.end101:                                        ; preds = %land.lhs.true88, %if.end79, %do.body72, %land.lhs.true42, %land.rhs35, %while.cond
  %device_type102 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %17 = load i32, i32* %device_type102, align 8, !tbaa !59
  %cmp103 = icmp eq i32 %17, 2
  br i1 %cmp103, label %if.then105, label %if.end110

if.then105:                                       ; preds = %if.end101
  %call106 = call zeroext i16 @igetword(%struct.intel8x0* %chip, i32 76)
  %conv107 = zext i16 %call106 to i32
  %or108 = or i32 %conv107, 1
  %conv109 = trunc i32 %or108 to i16
  call void @iputword(%struct.intel8x0* %chip, i32 76, i16 zeroext %conv109)
  br label %if.end110

if.end110:                                        ; preds = %if.then105, %if.end101
  %device_type111 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %18 = load i32, i32* %device_type111, align 8, !tbaa !59
  %cmp112 = icmp ne i32 %18, 4
  %19 = load i32, i32* @spdif_aclink, align 4
  %tobool115 = icmp ne i32 %19, 0
  %or.cond = or i1 %cmp112, %tobool115
  br i1 %or.cond, label %cleanup, label %if.then116

if.then116:                                       ; preds = %if.end110
  %pci117 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %20 = load %struct.pci_dev*, %struct.pci_dev** %pci117, align 8, !tbaa !100
  call void @pci_read_config_dword(%struct.pci_dev* %20, i32 76, i32* %val)
  %21 = load i32, i32* %val, align 4, !tbaa !2
  %or119 = or i32 %21, 16777216
  store i32 %or119, i32* %val, align 4, !tbaa !2
  %pci120 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %22 = load %struct.pci_dev*, %struct.pci_dev** %pci120, align 8, !tbaa !100
  %23 = load i32, i32* %val, align 4, !tbaa !2
  call void @pci_write_config_dword(%struct.pci_dev* %22, i32 76, i32 %23)
  br label %cleanup

cleanup:                                          ; preds = %if.then116, %if.end110, %if.then28, %if.end5
  %retval.0 = phi i32 [ -5, %if.then28 ], [ %err.0, %if.end5 ], [ 0, %if.end110 ], [ 0, %if.then116 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @iagetword(%struct.intel8x0* %chip, i32 %offset) #3 {
entry:
  %addr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 2
  %0 = load i8*, i8** %addr, align 8, !tbaa !104
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %call = call i32 @ioread16(i8* %add.ptr)
  %conv = trunc i32 %call to i16
  ret i16 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ali_chip_init(%struct.intel8x0* %chip, i32 %probing) #2 {
entry:
  %call = call i32 @igetdword(%struct.intel8x0* %chip, i32 0)
  %and = and i32 %call, 2
  %cmp = icmp eq i32 %and, 0
  %.sink = select i1 %cmp, i32 2, i32 1
  %or1 = or i32 %call, %.sink
  %and2 = and i32 %or1, 2147483647
  call void @iputdword(%struct.intel8x0* %chip, i32 0, i32 %and2)
  br label %for.cond

for.cond:                                         ; preds = %if.end7, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %if.end7 ]
  %cmp3 = icmp slt i32 %i.0, 125
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call4 = call i32 @igetdword(%struct.intel8x0* %chip, i32 24)
  %and5 = and i32 %call4, 2
  %tobool = icmp ne i32 %and5, 0
  br i1 %tobool, label %if.end7, label %__ok

if.end7:                                          ; preds = %for.body
  %call8 = call i64 @schedule_timeout_uninterruptible(i64 1)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %tobool9 = icmp ne i32 %probing, 0
  br i1 %tobool9, label %cleanup, label %__ok

__ok:                                             ; preds = %for.end, %for.body
  br label %for.cond12

for.cond12:                                       ; preds = %if.end19, %__ok
  %i.1 = phi i32 [ 0, %__ok ], [ %inc23, %if.end19 ]
  %cmp13 = icmp slt i32 %i.1, 125
  br i1 %cmp13, label %for.body14, label %for.end24

for.body14:                                       ; preds = %for.cond12
  %call15 = call i32 @igetdword(%struct.intel8x0* %chip, i32 52)
  %and16 = and i32 %call15, 128
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %for.end24, label %if.end19

if.end19:                                         ; preds = %for.body14
  %or20 = or i32 %call15, 128
  call void @iputdword(%struct.intel8x0* %chip, i32 52, i32 %or20)
  %call21 = call i64 @schedule_timeout_uninterruptible(i64 1)
  %inc23 = add nsw i32 %i.1, 1
  br label %for.cond12

for.end24:                                        ; preds = %for.body14, %for.cond12
  call void @do_ali_reset(%struct.intel8x0* %chip)
  br label %cleanup

cleanup:                                          ; preds = %for.end24, %for.end
  %retval.0 = phi i32 [ 0, %for.end24 ], [ -5, %for.end ]
  ret i32 %retval.0
}

declare i64 @schedule_timeout_uninterruptible(i64) #1

; Function Attrs: nounwind uwtable
define internal void @do_ali_reset(%struct.intel8x0* %chip) #2 {
entry:
  call void @iputdword(%struct.intel8x0* %chip, i32 0, i32 -2147483648)
  call void @iputdword(%struct.intel8x0* %chip, i32 12, i32 -2088533117)
  call void @iputdword(%struct.intel8x0* %chip, i32 28, i32 -2088533117)
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 -2088533117)
  call void @iputdword(%struct.intel8x0* %chip, i32 16, i32 524290)
  call void @iputdword(%struct.intel8x0* %chip, i32 20, i32 0)
  call void @iputdword(%struct.intel8x0* %chip, i32 24, i32 0)
  ret void
}

declare i32 @ioread16(i8*) #1

declare %struct.snd_pci_quirk* @snd_pci_quirk_lookup(%struct.pci_dev*, %struct.snd_pci_quirk*) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ich_chip_cold_reset(%struct.intel8x0* %chip) #2 {
entry:
  %pci = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %0 = load %struct.pci_dev*, %struct.pci_dev** %pci, align 8, !tbaa !100
  %call = call %struct.snd_pci_quirk* @snd_pci_quirk_lookup(%struct.pci_dev* %0, %struct.snd_pci_quirk* getelementptr inbounds ([2 x %struct.snd_pci_quirk], [2 x %struct.snd_pci_quirk]* @ich_chip_reset_mode, i32 0, i32 0))
  %tobool = icmp ne %struct.snd_pci_quirk* %call, null
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  %and = and i32 %call1, -3145737
  %and2 = and i32 %and, -3
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 %and2)
  %call3 = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  call void @__const_udelay(i64 42950)
  %or = or i32 %call3, 2
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 %or)
  call void @msleep(i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -5, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ich_chip_reset(%struct.intel8x0* %chip) #2 {
entry:
  %call = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  %and = and i32 %call, -3145737
  %and1 = and i32 %and, 2
  %cmp = icmp eq i32 %and1, 0
  %cond = select i1 %cmp, i32 2, i32 4
  %or = or i32 %and, %cond
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 %or)
  %0 = load volatile i64, i64* @jiffies, align 8, !tbaa !101
  %add = add i64 %0, 62
  %add2 = add i64 %add, 1
  br label %do.body

do.body:                                          ; preds = %land.lhs.true, %entry
  %call3 = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  %and4 = and i32 %call3, 4
  %cmp5 = icmp eq i32 %and4, 0
  br i1 %cmp5, label %cleanup, label %if.end

if.end:                                           ; preds = %do.body
  %call6 = call i64 @schedule_timeout_uninterruptible(i64 1)
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %if.end
  %1 = load volatile i64, i64* @jiffies, align 8, !tbaa !101
  %sub = sub i64 %add2, %1
  %cmp14 = icmp sge i64 %sub, 0
  br i1 %cmp14, label %do.body, label %do.end

do.end:                                           ; preds = %land.lhs.true, %if.end
  %call16 = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %do.end, %do.body
  %retval.0 = phi i32 [ -5, %do.end ], [ 0, %do.body ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @igetword(%struct.intel8x0* %chip, i32 %offset) #3 {
entry:
  %bmaddr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 3
  %0 = load i8*, i8** %bmaddr, align 8, !tbaa !79
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %call = call i32 @ioread16(i8* %add.ptr)
  %conv = trunc i32 %call to i16
  ret i16 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @iputword(%struct.intel8x0* %chip, i32 %offset, i16 zeroext %val) #3 {
entry:
  %bmaddr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 3
  %0 = load i8*, i8** %bmaddr, align 8, !tbaa !79
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  call void @iowrite16(i16 zeroext %val, i8* %add.ptr)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pci_read_config_dword(%struct.pci_dev* %dev, i32 %where, i32* %val) #3 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !105
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !106
  %call = call i32 @pci_bus_read_config_dword(%struct.pci_bus* %0, i32 %1, i32 %where, i32* %val)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pci_write_config_dword(%struct.pci_dev* %dev, i32 %where, i32 %val) #3 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !105
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !106
  %call = call i32 @pci_bus_write_config_dword(%struct.pci_bus* %0, i32 %1, i32 %where, i32 %val)
  ret void
}

declare i32 @pci_bus_write_config_dword(%struct.pci_bus*, i32, i32, i32) #1

declare i32 @pci_bus_read_config_dword(%struct.pci_bus*, i32, i32, i32*) #1

declare void @iowrite16(i16 zeroext, i8*) #1

declare void @__const_udelay(i64) #1

declare i32 @snd_pcm_suspend_all(%struct.snd_pcm*) #1

declare void @snd_ac97_suspend(%struct.snd_ac97*) #1

declare void @free_irq(i32, i8*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @pci_get_drvdata(%struct.pci_dev* %pdev) #3 {
entry:
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

declare i32 @snd_card_free(%struct.snd_card*) #1

declare i32 @snd_card_new(%struct.device*, i32, i8*, %struct.module*, i32, %struct.snd_card**) #1

; Function Attrs: nounwind uwtable
define internal i32 @check_default_spdif_aclink(%struct.pci_dev* %pci) #2 {
entry:
  %call = call %struct.snd_pci_quirk* @snd_pci_quirk_lookup(%struct.pci_dev* %pci, %struct.snd_pci_quirk* getelementptr inbounds ([2 x %struct.snd_pci_quirk], [2 x %struct.snd_pci_quirk]* @spdif_aclink_defaults, i32 0, i32 0))
  %tobool = icmp ne %struct.snd_pci_quirk* %call, null
  br i1 %tobool, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  %value = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %call, i32 0, i32 3
  %0 = load i32, i32* %value, align 8, !tbaa !107
  %tobool1 = icmp ne i32 %0, 0
  br i1 %tobool1, label %do.body3, label %do.body11

do.body3:                                         ; preds = %if.then
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @check_default_spdif_aclink.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool4 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool4, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then7, label %if.end32

if.then7:                                         ; preds = %do.body3
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pci, i32 0, i32 35
  %name = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %call, i32 0, i32 4
  %1 = load i8*, i8** %name, align 8, !tbaa !109
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @check_default_spdif_aclink.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.7, i32 0, i32 0), i8* %1)
  br label %if.end32

do.body11:                                        ; preds = %if.then
  %bf.load12 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @check_default_spdif_aclink.descriptor.8 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr13 = lshr i32 %bf.load12, 18
  %bf.clear14 = and i32 %bf.lshr13, 255
  %and15 = and i32 %bf.clear14, 1
  %tobool16 = icmp ne i32 %and15, 0
  %lnot17 = xor i1 %tobool16, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool23 = icmp ne i64 %expval22, 0
  br i1 %tobool23, label %if.then24, label %if.end32

if.then24:                                        ; preds = %do.body11
  %dev25 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pci, i32 0, i32 35
  %name26 = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %call, i32 0, i32 4
  %2 = load i8*, i8** %name26, align 8, !tbaa !109
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @check_default_spdif_aclink.descriptor.8 to %struct._ddebug*), %struct.device* %dev25, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.9, i32 0, i32 0), i8* %2)
  br label %if.end32

if.end32:                                         ; preds = %if.then24, %do.body11, %if.then7, %do.body3
  %value33 = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %call, i32 0, i32 3
  %3 = load i32, i32* %value33, align 8, !tbaa !107
  br label %cleanup

cleanup:                                          ; preds = %if.end32, %entry
  %retval.0 = phi i32 [ %3, %if.end32 ], [ 0, %entry ]
  ret i32 %retval.0
}

declare i8* @strcpy(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_create() #2 {
entry:
  br label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i8* @kzalloc(i64 1088, i32 20971712)
  %0 = bitcast i8* %call1 to %struct.intel8x0*
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load i8, i8* @buggy_semaphore, align 1, !tbaa !110, !range !111
  %tobool = trunc i8 %1 to i1
  %conv13 = zext i1 %tobool to i32
  %buggy_semaphore = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 9
  %2 = trunc i32 %conv13 to i16
  %bf.load14 = load i16, i16* %buggy_semaphore, align 8
  %bf.value15 = and i16 %2, 1
  %bf.shl16 = shl i16 %bf.value15, 11
  %bf.clear17 = and i16 %bf.load14, -2049
  %bf.set18 = or i16 %bf.clear17, %bf.shl16
  store i16 %bf.set18, i16* %buggy_semaphore, align 8
  br label %cleanup

if.end108:                                        ; preds = %if.end108
  br label %if.end108

for.body136:                                      ; preds = %for.body136
  br label %for.body136

for.body173:                                      ; preds = %for.body173
  br label %for.body173

cleanup:                                          ; preds = %do.body
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_mixer(%struct.intel8x0* %chip, i32 %ac97_clock, i8* %quirk_override) #2 {
entry:
  %pbus = alloca %struct.snd_ac97_bus*, align 8
  %ac97 = alloca %struct.snd_ac97_template, align 8
  %spdif_idx = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 10
  store i32 -1, i32* %spdif_idx, align 4, !tbaa !112
  %0 = load i32, i32* @spdif_aclink, align 4, !tbaa !2
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %1 = load i32, i32* %device_type, align 8, !tbaa !59
  %Pivot4 = icmp slt i32 %1, 3
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.then
  %Pivot = icmp slt i32 %1, 4
  br i1 %Pivot, label %sw.bb2, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %1, 4
  br i1 %SwitchLeaf2, label %sw.bb, label %if.end

LeafBlock:                                        ; preds = %if.then
  %SwitchLeaf = icmp eq i32 %1, 1
  br i1 %SwitchLeaf, label %sw.bb4, label %if.end

sw.bb:                                            ; preds = %LeafBlock1
  %spdif_idx1 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 10
  store i32 3, i32* %spdif_idx1, align 4, !tbaa !112
  br label %if.end

sw.bb2:                                           ; preds = %NodeBlock
  %spdif_idx3 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 10
  store i32 3, i32* %spdif_idx3, align 4, !tbaa !112
  br label %if.end

sw.bb4:                                           ; preds = %LeafBlock
  %spdif_idx5 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 10
  store i32 5, i32* %spdif_idx5, align 4, !tbaa !112
  br label %if.end

if.end:                                           ; preds = %sw.bb4, %sw.bb2, %sw.bb, %LeafBlock, %LeafBlock1, %entry
  %in_ac97_init = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load = load i16, i16* %in_ac97_init, align 8
  %bf.clear = and i16 %bf.load, -33
  %bf.set = or i16 %bf.clear, 32
  store i16 %bf.set, i16* %in_ac97_init, align 8
  %2 = bitcast %struct.snd_ac97_template* %ac97 to i8*
  %call = call i8* @__memset(i8* %2, i32 0, i64 40)
  %3 = bitcast %struct.intel8x0* %chip to i8*
  %private_data = getelementptr inbounds %struct.snd_ac97_template, %struct.snd_ac97_template* %ac97, i32 0, i32 0
  store i8* %3, i8** %private_data, align 8, !tbaa !113
  %private_free = getelementptr inbounds %struct.snd_ac97_template, %struct.snd_ac97_template* %ac97, i32 0, i32 1
  store void (%struct.snd_ac97*)* @snd_intel8x0_mixer_free_ac97, void (%struct.snd_ac97*)** %private_free, align 8, !tbaa !115
  %scaps = getelementptr inbounds %struct.snd_ac97_template, %struct.snd_ac97_template* %ac97, i32 0, i32 5
  store i32 2080, i32* %scaps, align 4, !tbaa !116
  %xbox = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load6 = load i16, i16* %xbox, align 8
  %bf.lshr = lshr i16 %bf.load6, 10
  %bf.clear7 = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear7 to i32
  %tobool8 = icmp ne i32 %bf.cast, 0
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end
  %scaps10 = getelementptr inbounds %struct.snd_ac97_template, %struct.snd_ac97_template* %ac97, i32 0, i32 5
  %4 = load i32, i32* %scaps10, align 4, !tbaa !116
  %or = or i32 %4, 256
  store i32 %or, i32* %scaps10, align 4, !tbaa !116
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end
  %device_type12 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %5 = load i32, i32* %device_type12, align 8, !tbaa !59
  %cmp = icmp ne i32 %5, 3
  br i1 %cmp, label %if.then13, label %if.else68

if.then13:                                        ; preds = %if.end11
  %call14 = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  %in_sdin_init = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load15 = load i16, i16* %in_sdin_init, align 8
  %bf.clear16 = and i16 %bf.load15, -65
  %bf.set17 = or i16 %bf.clear16, 64
  store i16 %bf.set17, i16* %in_sdin_init, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then13
  %codecs.0 = phi i32 [ 0, %if.then13 ], [ %codecs.1, %for.inc ]
  %i.0 = phi i32 [ 0, %if.then13 ], [ %inc61, %for.inc ]
  %max_codecs = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 15
  %6 = load i32, i32* %max_codecs, align 4, !tbaa !117
  %cmp18 = icmp ult i32 %i.0, %6
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %codec_bit = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 17
  %7 = load i32*, i32** %codec_bit, align 8, !tbaa !103
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i32, i32* %7, i64 %idxprom
  %8 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %and = and i32 %call14, %8
  %tobool19 = icmp ne i32 %and, 0
  br i1 %tobool19, label %if.end21, label %for.inc

if.end21:                                         ; preds = %for.body
  %device_type22 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %9 = load i32, i32* %device_type22, align 8, !tbaa !59
  %cmp23 = icmp eq i32 %9, 1
  br i1 %cmp23, label %if.then24, label %if.end60.sink.split

if.then24:                                        ; preds = %if.end21
  call void @snd_intel8x0_codec_read_test(%struct.intel8x0* %chip, i32 %codecs.0)
  %call25 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 128)
  %conv = zext i8 %call25 to i32
  %and26 = and i32 %conv, 3
  %ac97_sdin = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 14
  %idxprom27 = zext i32 %codecs.0 to i64
  %arrayidx28 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin, i64 0, i64 %idxprom27
  store i32 %and26, i32* %arrayidx28, align 4, !tbaa !2
  %ac97_sdin29 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 14
  %idxprom30 = zext i32 %codecs.0 to i64
  %arrayidx31 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin29, i64 0, i64 %idxprom30
  %10 = load i32, i32* %arrayidx31, align 4, !tbaa !2
  %cmp32 = icmp uge i32 %10, 3
  %lnot = xor i1 %cmp32, true
  %lnot34 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot34 to i32
  %tobool35 = icmp ne i32 %lnot.ext, 0
  %lnot36 = xor i1 %tobool35, true
  %lnot38 = xor i1 %lnot36, true
  %lnot.ext39 = zext i1 %lnot38 to i32
  %conv40 = sext i32 %lnot.ext39 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv40, i64 0)
  %tobool41 = icmp ne i64 %expval, 0
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.then24
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.6, i32 0, i32 0), i32 2252)
  br label %if.end43

if.end43:                                         ; preds = %if.then42, %if.then24
  %tobool44 = icmp ne i32 %lnot.ext, 0
  %lnot45 = xor i1 %tobool44, true
  %lnot47 = xor i1 %lnot45, true
  %lnot.ext48 = zext i1 %lnot47 to i32
  %conv49 = sext i32 %lnot.ext48 to i64
  %expval50 = call i64 @llvm.expect.i64(i64 %conv49, i64 0)
  %tobool51 = icmp ne i64 %expval50, 0
  br i1 %tobool51, label %if.end60.sink.split, label %if.end60

if.end60.sink.split:                              ; preds = %if.end43, %if.end21
  %.sink = phi i32 [ 0, %if.end43 ], [ %i.0, %if.end21 ]
  %ac97_sdin53 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 14
  %idxprom54 = zext i32 %codecs.0 to i64
  %arrayidx55 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin53, i64 0, i64 %idxprom54
  store i32 %.sink, i32* %arrayidx55, align 4, !tbaa !2
  br label %if.end60

if.end60:                                         ; preds = %if.end60.sink.split, %if.end43
  %inc = add i32 %codecs.0, 1
  br label %for.inc

for.inc:                                          ; preds = %if.end60, %for.body
  %codecs.1 = phi i32 [ %inc, %if.end60 ], [ %codecs.0, %for.body ]
  %inc61 = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %in_sdin_init62 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load63 = load i16, i16* %in_sdin_init62, align 8
  %bf.clear64 = and i16 %bf.load63, -65
  store i16 %bf.clear64, i16* %in_sdin_init62, align 8
  %tobool65 = icmp ne i32 %codecs.0, 0
  %codecs.0. = select i1 %tobool65, i32 %codecs.0, i32 1
  br label %if.end82

if.else68:                                        ; preds = %if.end11
  br label %for.cond69

for.cond69:                                       ; preds = %for.inc79, %if.else68
  %codecs.3 = phi i32 [ 1, %if.else68 ], [ %codecs.4, %for.inc79 ]
  %i.1 = phi i32 [ 0, %if.else68 ], [ %inc80, %for.inc79 ]
  %cmp70 = icmp ult i32 %i.1, 100
  br i1 %cmp70, label %for.body72, label %if.end82

for.body72:                                       ; preds = %for.cond69
  %call73 = call i32 @igetdword(%struct.intel8x0* %chip, i32 52)
  %and74 = and i32 %call73, 64
  %tobool75 = icmp ne i32 %and74, 0
  br i1 %tobool75, label %LeafBlock6, label %if.end77

if.end77:                                         ; preds = %for.body72
  %or78 = or i32 %call73, 64
  call void @iputdword(%struct.intel8x0* %chip, i32 52, i32 %or78)
  call void @__const_udelay(i64 4295)
  br label %LeafBlock6

LeafBlock6:                                       ; preds = %if.end77, %for.body72
  %codecs.4 = phi i32 [ %codecs.3, %if.end77 ], [ 2, %for.body72 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end77 ], [ 6, %for.body72 ]
  %SwitchLeaf7 = icmp eq i32 %cleanup.dest.slot.0, 6
  br i1 %SwitchLeaf7, label %if.end82, label %for.inc79

for.inc79:                                        ; preds = %LeafBlock6
  %inc80 = add i32 %i.1, 1
  br label %for.cond69

if.end82:                                         ; preds = %LeafBlock6, %for.cond69, %for.end
  %codecs.6 = phi i32 [ %codecs.0., %for.end ], [ %codecs.4, %LeafBlock6 ], [ %codecs.3, %for.cond69 ]
  %ops.0 = phi %struct.snd_ac97_bus_ops* [ @snd_intel8x0_mixer.standard_bus_ops, %for.end ], [ @snd_intel8x0_mixer.ali_bus_ops, %LeafBlock6 ], [ @snd_intel8x0_mixer.ali_bus_ops, %for.cond69 ]
  %card = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 5
  %11 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !118
  %12 = bitcast %struct.intel8x0* %chip to i8*
  %call83 = call i32 @snd_ac97_bus(%struct.snd_card* %11, i32 0, %struct.snd_ac97_bus_ops* %ops.0, i8* %12, %struct.snd_ac97_bus** %pbus)
  %cmp84 = icmp slt i32 %call83, 0
  br i1 %cmp84, label %__err, label %if.end87

if.end87:                                         ; preds = %if.end82
  %13 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %private_free88 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %13, i32 0, i32 2
  store void (%struct.snd_ac97_bus*)* @snd_intel8x0_mixer_free_ac97_bus, void (%struct.snd_ac97_bus*)** %private_free88, align 8, !tbaa !119
  %cmp89 = icmp sge i32 %ac97_clock, 8000
  %cmp91 = icmp sle i32 %ac97_clock, 48000
  %or.cond = and i1 %cmp89, %cmp91
  br i1 %or.cond, label %if.then93, label %if.end94

if.then93:                                        ; preds = %if.end87
  %14 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %clock = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %14, i32 0, i32 6
  store i32 %ac97_clock, i32* %clock, align 4, !tbaa !121
  br label %if.end94

if.end94:                                         ; preds = %if.then93, %if.end87
  %device_type95 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %15 = load i32, i32* %device_type95, align 8, !tbaa !59
  %cmp96 = icmp eq i32 %15, 3
  %16 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %no_vra = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %16, i32 0, i32 5
  %bf.load99 = load i8, i8* %no_vra, align 2
  %.sink9 = select i1 %cmp96, i8 -2, i8 -3
  %.sink8 = select i1 %cmp96, i8 1, i8 2
  %bf.clear104 = and i8 %bf.load99, %.sink9
  %bf.set105 = or i8 %bf.clear104, %.sink8
  store i8 %bf.set105, i8* %no_vra, align 2
  %17 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %ac97_bus = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 12
  store %struct.snd_ac97_bus* %17, %struct.snd_ac97_bus** %ac97_bus, align 8, !tbaa !122
  %ncodecs = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 16
  store i32 %codecs.6, i32* %ncodecs, align 8, !tbaa !58
  %pci = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %18 = load %struct.pci_dev*, %struct.pci_dev** %pci, align 8, !tbaa !100
  %pci107 = getelementptr inbounds %struct.snd_ac97_template, %struct.snd_ac97_template* %ac97, i32 0, i32 2
  store %struct.pci_dev* %18, %struct.pci_dev** %pci107, align 8, !tbaa !123
  br label %for.cond108

for.cond108:                                      ; preds = %for.inc130, %if.end94
  %i.2 = phi i32 [ 0, %if.end94 ], [ %inc131, %for.inc130 ]
  %cmp109 = icmp ult i32 %i.2, %codecs.6
  br i1 %cmp109, label %for.body111, label %for.end132

for.body111:                                      ; preds = %for.cond108
  %conv112 = trunc i32 %i.2 to i16
  %num = getelementptr inbounds %struct.snd_ac97_template, %struct.snd_ac97_template* %ac97, i32 0, i32 3
  store i16 %conv112, i16* %num, align 8, !tbaa !124
  %19 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %ac97113 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 13
  %idxprom114 = zext i32 %i.2 to i64
  %arrayidx115 = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97113, i64 0, i64 %idxprom114
  %call116 = call i32 @snd_ac97_mixer(%struct.snd_ac97_bus* %19, %struct.snd_ac97_template* %ac97, %struct.snd_ac97** %arrayidx115)
  %cmp117 = icmp slt i32 %call116, 0
  br i1 %cmp117, label %if.then119, label %for.inc130

if.then119:                                       ; preds = %for.body111
  %cmp120 = icmp ne i32 %call116, -13
  br i1 %cmp120, label %if.then122, label %if.end124

if.then122:                                       ; preds = %if.then119
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end124

if.end124:                                        ; preds = %if.then122, %if.then119
  %cmp125 = icmp eq i32 %i.2, 0
  br i1 %cmp125, label %__err, label %for.inc130

for.inc130:                                       ; preds = %if.end124, %for.body111
  %inc131 = add i32 %i.2, 1
  br label %for.cond108

for.end132:                                       ; preds = %for.cond108
  %ac97133 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 13
  %arrayidx134 = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97133, i64 0, i64 0
  %20 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx134, align 8, !tbaa !6
  %call135 = call i32 @snd_ac97_tune_hardware(%struct.snd_ac97* %20, %struct.ac97_quirk* getelementptr inbounds ([66 x %struct.ac97_quirk], [66 x %struct.ac97_quirk]* @ac97_quirks, i32 0, i32 0), i8* %quirk_override)
  %device_type136 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %21 = load i32, i32* %device_type136, align 8, !tbaa !59
  %cmp137 = icmp eq i32 %21, 1
  br i1 %cmp137, label %if.then139, label %if.end143

if.then139:                                       ; preds = %for.end132
  %22 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %isdin = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %22, i32 0, i32 5
  %bf.load140 = load i8, i8* %isdin, align 2
  %bf.clear141 = and i8 %bf.load140, -5
  %bf.set142 = or i8 %bf.clear141, 4
  store i8 %bf.set142, i8* %isdin, align 2
  br label %if.end143

if.end143:                                        ; preds = %if.then139, %for.end132
  %device_type144 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %23 = load i32, i32* %device_type144, align 8, !tbaa !59
  %cmp145 = icmp ne i32 %23, 1
  %sub = sub i32 6, 2
  %sub. = select i1 %cmp145, i32 %sub, i32 6
  %spdif_idx149 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 10
  %24 = load i32, i32* %spdif_idx149, align 4, !tbaa !112
  %cmp150 = icmp slt i32 %24, 0
  %dec = add i32 %sub., -1
  %i.4 = select i1 %cmp150, i32 %dec, i32 %sub.
  %25 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %conv154 = trunc i32 %i.4 to i16
  %call155 = call i32 @snd_ac97_pcm_assign(%struct.snd_ac97_bus* %25, i16 zeroext %conv154, %struct.ac97_pcm* getelementptr inbounds ([6 x %struct.ac97_pcm], [6 x %struct.ac97_pcm]* @ac97_pcm_defs, i32 0, i32 0))
  %cmp156 = icmp slt i32 %call155, 0
  br i1 %cmp156, label %__err, label %if.end159

if.end159:                                        ; preds = %if.end143
  %26 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %26, i32 0, i32 10
  %27 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms, align 8, !tbaa !125
  %arrayidx160 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %27, i64 0
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %arrayidx161 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 1
  %pcm = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx161, i32 0, i32 23
  store %struct.ac97_pcm* %arrayidx160, %struct.ac97_pcm** %pcm, align 8, !tbaa !126
  %28 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms162 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %28, i32 0, i32 10
  %29 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms162, align 8, !tbaa !125
  %arrayidx163 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %29, i64 1
  %ichd164 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %arrayidx165 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd164, i64 0, i64 0
  %pcm166 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx165, i32 0, i32 23
  store %struct.ac97_pcm* %arrayidx163, %struct.ac97_pcm** %pcm166, align 8, !tbaa !126
  %30 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms167 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %30, i32 0, i32 10
  %31 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms167, align 8, !tbaa !125
  %arrayidx168 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %31, i64 2
  %ichd169 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %arrayidx170 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd169, i64 0, i64 2
  %pcm171 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx170, i32 0, i32 23
  store %struct.ac97_pcm* %arrayidx168, %struct.ac97_pcm** %pcm171, align 8, !tbaa !126
  %spdif_idx172 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 10
  %32 = load i32, i32* %spdif_idx172, align 4, !tbaa !112
  %cmp173 = icmp sge i32 %32, 0
  br i1 %cmp173, label %if.then175, label %if.end183

if.then175:                                       ; preds = %if.end159
  %33 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms176 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %33, i32 0, i32 10
  %34 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms176, align 8, !tbaa !125
  %arrayidx177 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %34, i64 3
  %ichd178 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %spdif_idx179 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 10
  %35 = load i32, i32* %spdif_idx179, align 4, !tbaa !112
  %idxprom180 = sext i32 %35 to i64
  %arrayidx181 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd178, i64 0, i64 %idxprom180
  %pcm182 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx181, i32 0, i32 23
  store %struct.ac97_pcm* %arrayidx177, %struct.ac97_pcm** %pcm182, align 8, !tbaa !126
  br label %if.end183

if.end183:                                        ; preds = %if.then175, %if.end159
  %device_type184 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %36 = load i32, i32* %device_type184, align 8, !tbaa !59
  %cmp185 = icmp eq i32 %36, 1
  br i1 %cmp185, label %if.then187, label %if.end198

if.then187:                                       ; preds = %if.end183
  %37 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms188 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %37, i32 0, i32 10
  %38 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms188, align 8, !tbaa !125
  %arrayidx189 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %38, i64 4
  %ichd190 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %arrayidx191 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd190, i64 0, i64 4
  %pcm192 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx191, i32 0, i32 23
  store %struct.ac97_pcm* %arrayidx189, %struct.ac97_pcm** %pcm192, align 8, !tbaa !126
  %39 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms193 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %39, i32 0, i32 10
  %40 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms193, align 8, !tbaa !125
  %arrayidx194 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %40, i64 5
  %ichd195 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %arrayidx196 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd195, i64 0, i64 3
  %pcm197 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx196, i32 0, i32 23
  store %struct.ac97_pcm* %arrayidx194, %struct.ac97_pcm** %pcm197, align 8, !tbaa !126
  br label %if.end198

if.end198:                                        ; preds = %if.then187, %if.end183
  %device_type199 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %41 = load i32, i32* %device_type199, align 8, !tbaa !59
  %cmp200 = icmp eq i32 %41, 1
  br i1 %cmp200, label %if.then202, label %if.end252

if.then202:                                       ; preds = %if.end198
  %ichd204 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %arrayidx205 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd204, i64 0, i64 4
  %pcm206 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx205, i32 0, i32 23
  %42 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm206, align 8, !tbaa !126
  %call208 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 128)
  %conv209 = zext i8 %call208 to i32
  %and210 = and i32 %conv209, -241
  %conv211 = trunc i32 %and210 to i8
  %tobool212 = icmp ne %struct.ac97_pcm* %42, null
  %conv214 = zext i8 %conv211 to i32
  br i1 %tobool212, label %if.then213, label %if.else247

if.then213:                                       ; preds = %if.then202
  %or215 = or i32 %conv214, 8
  %conv216 = trunc i32 %or215 to i8
  %ac97_sdin217 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 14
  %arrayidx218 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin217, i64 0, i64 0
  %43 = load i32, i32* %arrayidx218, align 8, !tbaa !2
  %shl = shl i32 %43, 4
  %conv219 = zext i8 %conv216 to i32
  %or220 = or i32 %conv219, %shl
  %conv221 = trunc i32 %or220 to i8
  br label %for.cond222

for.cond222:                                      ; preds = %for.inc244, %if.then213
  %i.5 = phi i32 [ 1, %if.then213 ], [ %inc245, %for.inc244 ]
  %cmp223 = icmp ult i32 %i.5, 4
  br i1 %cmp223, label %for.body225, label %if.end251

for.body225:                                      ; preds = %for.cond222
  %r = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %42, i32 0, i32 5
  %arrayidx226 = getelementptr inbounds [2 x %struct.anon.74], [2 x %struct.anon.74]* %r, i64 0, i64 0
  %codec = getelementptr inbounds %struct.anon.74, %struct.anon.74* %arrayidx226, i32 0, i32 3
  %idxprom227 = zext i32 %i.5 to i64
  %arrayidx228 = getelementptr inbounds [4 x %struct.snd_ac97*], [4 x %struct.snd_ac97*]* %codec, i64 0, i64 %idxprom227
  %44 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx228, align 8, !tbaa !6
  %tobool229 = icmp ne %struct.snd_ac97* %44, null
  br i1 %tobool229, label %if.then230, label %for.inc244

if.then230:                                       ; preds = %for.body225
  %ac97_sdin231 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 14
  %r232 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %42, i32 0, i32 5
  %arrayidx233 = getelementptr inbounds [2 x %struct.anon.74], [2 x %struct.anon.74]* %r232, i64 0, i64 0
  %codec234 = getelementptr inbounds %struct.anon.74, %struct.anon.74* %arrayidx233, i32 0, i32 3
  %arrayidx235 = getelementptr inbounds [4 x %struct.snd_ac97*], [4 x %struct.snd_ac97*]* %codec234, i64 0, i64 1
  %45 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx235, align 8, !tbaa !6
  %num236 = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %45, i32 0, i32 11
  %46 = load i16, i16* %num236, align 8, !tbaa !127
  %idxprom237 = zext i16 %46 to i64
  %arrayidx238 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin231, i64 0, i64 %idxprom237
  %47 = load i32, i32* %arrayidx238, align 4, !tbaa !2
  %shl239 = shl i32 %47, 6
  %conv240 = zext i8 %conv221 to i32
  %or241 = or i32 %conv240, %shl239
  %conv242 = trunc i32 %or241 to i8
  br label %if.end251

for.inc244:                                       ; preds = %for.body225
  %inc245 = add i32 %i.5, 1
  br label %for.cond222

if.else247:                                       ; preds = %if.then202
  %and249 = and i32 %conv214, -9
  %conv250 = trunc i32 %and249 to i8
  br label %if.end251

if.end251:                                        ; preds = %if.else247, %if.then230, %for.cond222
  %tmp207.1 = phi i8 [ %conv250, %if.else247 ], [ %conv242, %if.then230 ], [ %conv221, %for.cond222 ]
  call void @iputbyte(%struct.intel8x0* %chip, i32 128, i8 zeroext %tmp207.1)
  br label %if.end252

if.end252:                                        ; preds = %if.end251, %if.end198
  %48 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms253 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %48, i32 0, i32 10
  %49 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms253, align 8, !tbaa !125
  %arrayidx254 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %49, i64 0
  %r255 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %arrayidx254, i32 0, i32 5
  %arrayidx256 = getelementptr inbounds [2 x %struct.anon.74], [2 x %struct.anon.74]* %r255, i64 0, i64 0
  %slots = getelementptr inbounds %struct.anon.74, %struct.anon.74* %arrayidx256, i32 0, i32 0
  %50 = load i16, i16* %slots, align 8, !tbaa !129
  %conv257 = zext i16 %50 to i32
  %and258 = and i32 %conv257, 128
  %tobool259 = icmp ne i32 %and258, 0
  br i1 %tobool259, label %if.then260, label %if.end286

if.then260:                                       ; preds = %if.end252
  %multi4 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load261 = load i16, i16* %multi4, align 8
  %bf.clear262 = and i16 %bf.load261, -2
  %bf.set263 = or i16 %bf.clear262, 1
  store i16 %bf.set263, i16* %multi4, align 8
  %51 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms264 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %51, i32 0, i32 10
  %52 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms264, align 8, !tbaa !125
  %arrayidx265 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %52, i64 0
  %r266 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %arrayidx265, i32 0, i32 5
  %arrayidx267 = getelementptr inbounds [2 x %struct.anon.74], [2 x %struct.anon.74]* %r266, i64 0, i64 0
  %slots268 = getelementptr inbounds %struct.anon.74, %struct.anon.74* %arrayidx267, i32 0, i32 0
  %53 = load i16, i16* %slots268, align 8, !tbaa !129
  %conv269 = zext i16 %53 to i32
  %and270 = and i32 %conv269, 512
  %tobool271 = icmp ne i32 %and270, 0
  br i1 %tobool271, label %if.then272, label %if.end286

if.then272:                                       ; preds = %if.then260
  %multi6 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load273 = load i16, i16* %multi6, align 8
  %bf.clear274 = and i16 %bf.load273, -3
  %bf.set275 = or i16 %bf.clear274, 2
  store i16 %bf.set275, i16* %multi6, align 8
  %ac97276 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 13
  %arrayidx277 = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97276, i64 0, i64 0
  %54 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx277, align 8, !tbaa !6
  %flags = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %54, i32 0, i32 19
  %55 = load i32, i32* %flags, align 4, !tbaa !131
  %and278 = and i32 %55, 524288
  %tobool279 = icmp ne i32 %and278, 0
  br i1 %tobool279, label %if.then280, label %if.end286

if.then280:                                       ; preds = %if.then272
  %multi8 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load281 = load i16, i16* %multi8, align 8
  %bf.clear282 = and i16 %bf.load281, -5
  %bf.set283 = or i16 %bf.clear282, 4
  store i16 %bf.set283, i16* %multi8, align 8
  br label %if.end286

if.end286:                                        ; preds = %if.then280, %if.then272, %if.then260, %if.end252
  %56 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms287 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %56, i32 0, i32 10
  %57 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms287, align 8, !tbaa !125
  %arrayidx288 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %57, i64 0
  %r289 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %arrayidx288, i32 0, i32 5
  %arrayidx290 = getelementptr inbounds [2 x %struct.anon.74], [2 x %struct.anon.74]* %r289, i64 0, i64 1
  %rslots = getelementptr inbounds %struct.anon.74, %struct.anon.74* %arrayidx290, i32 0, i32 1
  %arrayidx291 = getelementptr inbounds [4 x i16], [4 x i16]* %rslots, i64 0, i64 0
  %58 = load i16, i16* %arrayidx291, align 2, !tbaa !132
  %tobool292 = icmp ne i16 %58, 0
  br i1 %tobool292, label %if.then293, label %if.end298

if.then293:                                       ; preds = %if.end286
  %dra294 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load295 = load i16, i16* %dra294, align 8
  %bf.clear296 = and i16 %bf.load295, -9
  %bf.set297 = or i16 %bf.clear296, 8
  store i16 %bf.set297, i16* %dra294, align 8
  br label %if.end298

if.end298:                                        ; preds = %if.then293, %if.end286
  %device_type299 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %59 = load i32, i32* %device_type299, align 8, !tbaa !59
  %cmp300 = icmp eq i32 %59, 1
  br i1 %cmp300, label %if.then302, label %if.end312

if.then302:                                       ; preds = %if.end298
  %call303 = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  %and304 = and i32 %call303, 12582912
  %cmp305 = icmp eq i32 %and304, 4194304
  br i1 %cmp305, label %if.then307, label %if.end312

if.then307:                                       ; preds = %if.then302
  %smp20bit = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load308 = load i16, i16* %smp20bit, align 8
  %bf.clear309 = and i16 %bf.load308, -17
  %bf.set310 = or i16 %bf.clear309, 16
  store i16 %bf.set310, i16* %smp20bit, align 8
  br label %if.end312

if.end312:                                        ; preds = %if.then307, %if.then302, %if.end298
  %device_type313 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %60 = load i32, i32* %device_type313, align 8, !tbaa !59
  %cmp314 = icmp ne i32 %60, 4
  %61 = load i32, i32* @spdif_aclink, align 4
  %tobool317 = icmp ne i32 %61, 0
  %or.cond10 = or i1 %cmp314, %tobool317
  br i1 %or.cond10, label %if.end324, label %if.then318

if.then318:                                       ; preds = %if.end312
  %ichd319 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %spdif_idx320 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 10
  %62 = load i32, i32* %spdif_idx320, align 4, !tbaa !112
  %idxprom321 = sext i32 %62 to i64
  %arrayidx322 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd319, i64 0, i64 %idxprom321
  %pcm323 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx322, i32 0, i32 23
  %63 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm323, align 8, !tbaa !126
  %rates = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %63, i32 0, i32 4
  store i32 128, i32* %rates, align 8, !tbaa !133
  br label %if.end324

if.end324:                                        ; preds = %if.then318, %if.end312
  %device_type325 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %64 = load i32, i32* %device_type325, align 8, !tbaa !59
  %cmp326 = icmp ne i32 %64, 1
  %65 = load i32, i32* @spdif_aclink, align 4
  %tobool329 = icmp ne i32 %65, 0
  %or.cond11 = or i1 %cmp326, %tobool329
  br i1 %or.cond11, label %if.end337, label %if.then330

if.then330:                                       ; preds = %if.end324
  %call331 = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  %and332 = and i32 %call331, 1073741823
  %or333 = or i32 %and332, -1073741824
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 %or333)
  %ac97334 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 13
  %arrayidx335 = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97334, i64 0, i64 0
  %66 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx335, align 8, !tbaa !6
  %call336 = call i32 @snd_ac97_update_bits(%struct.snd_ac97* %66, i16 zeroext 42, i16 zeroext 48, i16 zeroext 48)
  br label %if.end337

if.end337:                                        ; preds = %if.then330, %if.end324
  %in_ac97_init338 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load339 = load i16, i16* %in_ac97_init338, align 8
  %bf.clear340 = and i16 %bf.load339, -33
  store i16 %bf.clear340, i16* %in_ac97_init338, align 8
  br label %cleanup348

__err:                                            ; preds = %if.end143, %if.end124, %if.end82
  %err.0 = phi i32 [ %call83, %if.end82 ], [ %call116, %if.end124 ], [ %call155, %if.end143 ]
  %device_type341 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %67 = load i32, i32* %device_type341, align 8, !tbaa !59
  %cmp342 = icmp ne i32 %67, 3
  br i1 %cmp342, label %if.then344, label %cleanup348

if.then344:                                       ; preds = %__err
  %call345 = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  %and346 = and i32 %call345, -3
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 %and346)
  br label %cleanup348

cleanup348:                                       ; preds = %if.then344, %__err, %if.end337
  %retval.0 = phi i32 [ 0, %if.end337 ], [ %err.0, %if.then344 ], [ %err.0, %__err ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_pcm(%struct.intel8x0* %chip) #2 {
entry:
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %0 = load i32, i32* %device_type, align 8, !tbaa !59
  %Pivot4 = icmp slt i32 %0, 3
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %0, 4
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %0, 4
  br i1 %SwitchLeaf2, label %sw.bb1, label %sw.epilog

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %0, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %1 = load i32, i32* @spdif_aclink, align 4, !tbaa !2
  %tobool = icmp ne i32 %1, 0
  %dec = add nsw i32 5, -1
  %dec. = select i1 %tobool, i32 %dec, i32 5
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %2 = load i32, i32* @spdif_aclink, align 4, !tbaa !2
  %tobool2 = icmp ne i32 %2, 0
  %dec4 = add nsw i32 3, -1
  %dec4. = select i1 %tobool2, i32 %dec4, i32 3
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb1, %sw.bb, %LeafBlock, %LeafBlock1, %NodeBlock
  %tbl.0 = phi %struct.ich_pcm_table* [ getelementptr inbounds ([5 x %struct.ich_pcm_table], [5 x %struct.ich_pcm_table]* @intel_pcms, i32 0, i32 0), %sw.bb ], [ getelementptr inbounds ([3 x %struct.ich_pcm_table], [3 x %struct.ich_pcm_table]* @nforce_pcms, i32 0, i32 0), %sw.bb1 ], [ getelementptr inbounds ([3 x %struct.ich_pcm_table], [3 x %struct.ich_pcm_table]* @ali_pcms, i32 0, i32 0), %NodeBlock ], [ getelementptr inbounds ([5 x %struct.ich_pcm_table], [5 x %struct.ich_pcm_table]* @intel_pcms, i32 0, i32 0), %LeafBlock ], [ getelementptr inbounds ([5 x %struct.ich_pcm_table], [5 x %struct.ich_pcm_table]* @intel_pcms, i32 0, i32 0), %LeafBlock1 ]
  %tblsize.2 = phi i32 [ %dec., %sw.bb ], [ %dec4., %sw.bb1 ], [ 3, %NodeBlock ], [ 2, %LeafBlock ], [ 2, %LeafBlock1 ]
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %device.0 = phi i32 [ 0, %sw.epilog ], [ %device.1, %for.inc ]
  %i.0 = phi i32 [ 0, %sw.epilog ], [ %inc18, %for.inc ]
  %cmp = icmp slt i32 %i.0, %tblsize.2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idx.ext = sext i32 %i.0 to i64
  %add.ptr = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %tbl.0, i64 %idx.ext
  %cmp7 = icmp sgt i32 %i.0, 0
  br i1 %cmp7, label %land.lhs.true, label %if.end14

land.lhs.true:                                    ; preds = %for.body
  %ac97_idx = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %add.ptr, i32 0, i32 5
  %3 = load i32, i32* %ac97_idx, align 8, !tbaa !135
  %tobool8 = icmp ne i32 %3, 0
  br i1 %tobool8, label %if.then9, label %if.end14

if.then9:                                         ; preds = %land.lhs.true
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %ac97_idx10 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %add.ptr, i32 0, i32 5
  %4 = load i32, i32* %ac97_idx10, align 8, !tbaa !135
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 %idxprom
  %pcm = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 23
  %5 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm, align 8, !tbaa !126
  %tobool11 = icmp ne %struct.ac97_pcm* %5, null
  br i1 %tobool11, label %if.end14, label %for.inc

if.end14:                                         ; preds = %if.then9, %land.lhs.true, %for.body
  %call = call i32 @snd_intel8x0_pcm1(%struct.intel8x0* %chip, i32 %device.0, %struct.ich_pcm_table* %add.ptr)
  %cmp15 = icmp slt i32 %call, 0
  br i1 %cmp15, label %cleanup, label %if.end17

if.end17:                                         ; preds = %if.end14
  %inc = add nsw i32 %device.0, 1
  br label %for.inc

for.inc:                                          ; preds = %if.end17, %if.then9
  %device.1 = phi i32 [ %inc, %if.end17 ], [ %device.0, %if.then9 ]
  %inc18 = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %pcm_devs = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 6
  store i32 %device.0, i32* %pcm_devs, align 8, !tbaa !54
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.end14
  %retval.0 = phi i32 [ 0, %for.end ], [ %call, %if.end14 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_proc_init(%struct.intel8x0* %chip) #2 {
entry:
  %entry1 = alloca %struct.snd_info_entry*, align 8
  %card = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 5
  %0 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !118
  %call = call i32 @snd_card_proc_new(%struct.snd_card* %0, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.121, i32 0, i32 0), %struct.snd_info_entry** %entry1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry1, align 8, !tbaa !6
  %2 = bitcast %struct.intel8x0* %chip to i8*
  call void @snd_info_set_text_ops(%struct.snd_info_entry* %1, i8* %2, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_intel8x0_proc_read)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare i8* @snd_ac97_get_short_name(%struct.snd_ac97*) #1

declare i32 @snprintf(i8*, i64, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i32 @intel8x0_in_clock_list(%struct.intel8x0* %chip) #2 {
entry:
  %pci1 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %0 = load %struct.pci_dev*, %struct.pci_dev** %pci1, align 8, !tbaa !100
  %call = call %struct.snd_pci_quirk* @snd_pci_quirk_lookup(%struct.pci_dev* %0, %struct.snd_pci_quirk* getelementptr inbounds ([7 x %struct.snd_pci_quirk], [7 x %struct.snd_pci_quirk]* @intel8x0_clock_list, i32 0, i32 0))
  %tobool = icmp ne %struct.snd_pci_quirk* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %value3 = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %call, i32 0, i32 3
  %1 = load i32, i32* %value3, align 8, !tbaa !107
  %ac97_bus = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 12
  %2 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %ac97_bus, align 8, !tbaa !122
  %clock = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %2, i32 0, i32 6
  store i32 %1, i32* %clock, align 4, !tbaa !121
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 1, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @intel8x0_measure_ac97_clock(%struct.intel8x0* %chip) #2 {
entry:
  %ac97_bus = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 12
  %0 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %ac97_bus, align 8, !tbaa !122
  %clock = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %0, i32 0, i32 6
  %1 = load i32, i32* %clock, align 4, !tbaa !121
  %cmp = icmp ne i32 %1, 48000
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  br label %__again

__again:                                          ; preds = %if.then110, %if.end
  %timeout.0 = phi i32 [ 1000, %if.end ], [ %timeout.2, %if.then110 ]
  %attempt.0 = phi i32 [ 1, %if.end ], [ %inc, %if.then110 ]
  %pcm = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 7
  %arrayidx = getelementptr inbounds [6 x %struct.snd_pcm*], [6 x %struct.snd_pcm*]* %pcm, i64 0, i64 0
  %2 = load %struct.snd_pcm*, %struct.snd_pcm** %arrayidx, align 8, !tbaa !6
  %streams = getelementptr inbounds %struct.snd_pcm, %struct.snd_pcm* %2, i32 0, i32 8
  %arrayidx1 = getelementptr inbounds [2 x %struct.snd_pcm_str], [2 x %struct.snd_pcm_str]* %streams, i64 0, i64 0
  %substream = getelementptr inbounds %struct.snd_pcm_str, %struct.snd_pcm_str* %arrayidx1, i32 0, i32 4
  %3 = load %struct.snd_pcm_substream*, %struct.snd_pcm_substream** %substream, align 8, !tbaa !137
  %tobool = icmp ne %struct.snd_pcm_substream* %3, null
  br i1 %tobool, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %__again
  %dma_buffer = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %3, i32 0, i32 8
  %bytes = getelementptr inbounds %struct.snd_dma_buffer, %struct.snd_dma_buffer* %dma_buffer, i32 0, i32 3
  %4 = load i64, i64* %bytes, align 8, !tbaa !140
  %cmp2 = icmp ult i64 %4, 32768
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %lor.lhs.false, %__again
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup.cont

if.end4:                                          ; preds = %lor.lhs.false
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %arrayidx5 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 1
  %dma_buffer6 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %3, i32 0, i32 8
  %addr = getelementptr inbounds %struct.snd_dma_buffer, %struct.snd_dma_buffer* %dma_buffer6, i32 0, i32 2
  %5 = load i64, i64* %addr, align 8, !tbaa !141
  %conv = trunc i64 %5 to i32
  %physbuf = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 5
  store i32 %conv, i32* %physbuf, align 8, !tbaa !96
  %fragsize = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 7
  store i32 32768, i32* %fragsize, align 8, !tbaa !142
  %size = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 6
  store i32 32768, i32* %size, align 4, !tbaa !93
  %substream7 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 4
  store %struct.snd_pcm_substream* null, %struct.snd_pcm_substream** %substream7, align 8, !tbaa !56
  %ac97 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 13
  %arrayidx8 = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97, i64 0, i64 0
  %6 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx8, align 8, !tbaa !6
  %call = call i32 @snd_ac97_set_rate(%struct.snd_ac97* %6, i32 44, i32 48000)
  %cmp9 = icmp slt i32 %call, 0
  br i1 %cmp9, label %if.then11, label %if.end16

if.then11:                                        ; preds = %if.end4
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup.cont

if.end16:                                         ; preds = %if.end4
  call void @snd_intel8x0_setup_periods(%struct.intel8x0* %chip, %struct.ichdev* %arrayidx5)
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 1
  %7 = load i64, i64* %reg_offset, align 8, !tbaa !62
  %reg_lock = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  %8 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reg_lock, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %8 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i1) #6
  %in_measurement = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load = load i16, i16* %in_measurement, align 8
  %bf.clear = and i16 %bf.load, -129
  %bf.set = or i16 %bf.clear, 128
  store i16 %bf.set, i16* %in_measurement, align 8
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %9 = load i32, i32* %device_type, align 8, !tbaa !59
  %cmp17 = icmp ne i32 %9, 3
  %add = add i64 %7, 11
  %conv20 = trunc i64 %add to i32
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end16
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv20, i8 zeroext 17)
  br label %if.end23

if.else:                                          ; preds = %if.end16
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv20, i8 zeroext 16)
  %ali_slot = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 22
  %10 = load i32, i32* %ali_slot, align 4, !tbaa !143
  %shl = shl i32 1, %10
  call void @iputdword(%struct.intel8x0* %chip, i32 8, i32 %shl)
  br label %if.end23

if.end23:                                         ; preds = %if.else, %if.then19
  %call24 = call i64 @ktime_get()
  %reg_lock25 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  %11 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reg_lock25, i32 0, i32 0
  %rlock.i3 = bitcast %union.anon.1* %11 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i3) #6
  call void @msleep(i32 50)
  %reg_lock26 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  %12 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reg_lock26, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %12 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i) #6
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end23
  %timeout.1 = phi i32 [ %timeout.0, %if.end23 ], [ %dec, %do.cond ]
  %reg_offset27 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 1
  %13 = load i64, i64* %reg_offset27, align 8, !tbaa !62
  %add28 = add i64 %13, 4
  %conv29 = trunc i64 %add28 to i32
  %call30 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 %conv29)
  %conv31 = zext i8 %call30 to i32
  %reg_offset32 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 1
  %14 = load i64, i64* %reg_offset32, align 8, !tbaa !62
  %roff_picb = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 20
  %15 = load i32, i32* %roff_picb, align 4, !tbaa !144
  %conv33 = zext i32 %15 to i64
  %add34 = add i64 %14, %conv33
  %conv35 = trunc i64 %add34 to i32
  %call36 = call zeroext i16 @igetword(%struct.intel8x0* %chip, i32 %conv35)
  %conv37 = zext i16 %call36 to i64
  %cmp38 = icmp eq i64 %conv37, 0
  br i1 %cmp38, label %if.then40, label %if.end41

if.then40:                                        ; preds = %do.body
  call void @__const_udelay(i64 42950)
  br label %do.cond

if.end41:                                         ; preds = %do.body
  %reg_offset42 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 1
  %16 = load i64, i64* %reg_offset42, align 8, !tbaa !62
  %add43 = add i64 %16, 4
  %conv44 = trunc i64 %add43 to i32
  %call45 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 %conv44)
  %conv46 = zext i8 %call45 to i32
  %cmp47 = icmp eq i32 %conv31, %conv46
  br i1 %cmp47, label %land.lhs.true, label %do.cond

land.lhs.true:                                    ; preds = %if.end41
  %reg_offset49 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 1
  %17 = load i64, i64* %reg_offset49, align 8, !tbaa !62
  %roff_picb50 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 20
  %18 = load i32, i32* %roff_picb50, align 4, !tbaa !144
  %conv51 = zext i32 %18 to i64
  %add52 = add i64 %17, %conv51
  %conv53 = trunc i64 %add52 to i32
  %call54 = call zeroext i16 @igetword(%struct.intel8x0* %chip, i32 %conv53)
  %conv55 = zext i16 %call54 to i64
  %cmp56 = icmp eq i64 %conv37, %conv55
  br i1 %cmp56, label %do.end, label %do.cond

do.cond:                                          ; preds = %land.lhs.true, %if.end41, %if.then40
  %dec = add nsw i32 %timeout.1, -1
  %tobool60 = icmp ne i32 %timeout.1, 0
  br i1 %tobool60, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond, %land.lhs.true
  %timeout.2 = phi i32 [ %timeout.1, %land.lhs.true ], [ %dec, %do.cond ]
  %cmp61 = icmp eq i64 %conv37, 0
  br i1 %cmp61, label %if.end69, label %if.else64

if.else64:                                        ; preds = %do.end
  %fragsize1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 8
  %19 = load i32, i32* %fragsize1, align 4, !tbaa !91
  %conv65 = zext i32 %19 to i64
  %pos_shift = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 10
  %20 = load i32, i32* %pos_shift, align 4, !tbaa !145
  %sh_prom = zext i32 %20 to i64
  %shl66 = shl i64 %conv37, %sh_prom
  %sub = sub i64 %conv65, %shl66
  %position = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 9
  %21 = load i32, i32* %position, align 8, !tbaa !92
  %conv67 = zext i32 %21 to i64
  %add68 = add i64 %sub, %conv67
  br label %if.end69

if.end69:                                         ; preds = %if.else64, %do.end
  %pos.0 = phi i64 [ %add68, %if.else64 ], [ 0, %do.end ]
  %in_measurement70 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load71 = load i16, i16* %in_measurement70, align 8
  %bf.clear72 = and i16 %bf.load71, -129
  store i16 %bf.clear72, i16* %in_measurement70, align 8
  %call73 = call i64 @ktime_get()
  %device_type74 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %22 = load i32, i32* %device_type74, align 8, !tbaa !59
  %cmp75 = icmp eq i32 %22, 3
  br i1 %cmp75, label %if.then77, label %if.else87

if.then77:                                        ; preds = %if.end69
  %ali_slot78 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 22
  %23 = load i32, i32* %ali_slot78, align 4, !tbaa !143
  %add79 = add i32 %23, 16
  %shl80 = shl i32 1, %add79
  call void @iputdword(%struct.intel8x0* %chip, i32 8, i32 %shl80)
  %add81 = add i64 %7, 11
  %conv82 = trunc i64 %add81 to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv82, i8 zeroext 0)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then77
  %add83 = add i64 %7, 11
  %conv84 = trunc i64 %add83 to i32
  %call85 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 %conv84)
  %tobool86 = icmp ne i8 %call85, 0
  br i1 %tobool86, label %while.body, label %if.end99

while.body:                                       ; preds = %while.cond
  br label %while.cond

if.else87:                                        ; preds = %if.end69
  %add88 = add i64 %7, 11
  %conv89 = trunc i64 %add88 to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv89, i8 zeroext 0)
  br label %while.cond90

while.cond90:                                     ; preds = %while.body97, %if.else87
  %roff_sr = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 19
  %24 = load i32, i32* %roff_sr, align 8, !tbaa !74
  %conv91 = zext i32 %24 to i64
  %add92 = add i64 %7, %conv91
  %conv93 = trunc i64 %add92 to i32
  %call94 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 %conv93)
  %conv95 = zext i8 %call94 to i32
  %and = and i32 %conv95, 1
  %tobool96 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool96, true
  br i1 %lnot, label %while.body97, label %if.end99

while.body97:                                     ; preds = %while.cond90
  br label %while.cond90

if.end99:                                         ; preds = %while.cond90, %while.cond
  %add100 = add i64 %7, 11
  %conv101 = trunc i64 %add100 to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv101, i8 zeroext 2)
  %reg_lock102 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  %25 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reg_lock102, i32 0, i32 0
  %rlock.i2 = bitcast %union.anon.1* %25 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i2) #6
  %cmp103 = icmp eq i64 %pos.0, 0
  br i1 %cmp103, label %if.then105, label %if.end112

if.then105:                                       ; preds = %if.end99
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %__retry

__retry:                                          ; preds = %if.then132, %if.then118, %if.then105
  %cmp108 = icmp slt i32 %attempt.0, 3
  br i1 %cmp108, label %if.then110, label %__end

if.then110:                                       ; preds = %__retry
  call void @msleep(i32 300)
  %inc = add nsw i32 %attempt.0, 1
  br label %__again

if.end112:                                        ; preds = %if.end99
  %div = udiv i64 %pos.0, 4
  %call113 = call i64 @ktime_us_delta(i64 %call73, i64 %call24)
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %cmp116 = icmp eq i64 %call113, 0
  br i1 %cmp116, label %if.then118, label %if.end121

if.then118:                                       ; preds = %if.end112
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %__retry

if.end121:                                        ; preds = %if.end112
  %mul = mul i64 %div, 1000
  %div122 = udiv i64 %mul, %call113
  %mul123 = mul i64 %div122, 1000
  %rem = urem i64 %mul, %call113
  %mul124 = mul i64 %rem, 1000
  %div125 = udiv i64 %mul124, %call113
  %add126 = add i64 %mul123, %div125
  %cmp127 = icmp ult i64 %add126, 40000
  %cmp130 = icmp uge i64 %add126, 60000
  %or.cond = or i1 %cmp127, %cmp130
  br i1 %or.cond, label %if.then132, label %if.else135

if.then132:                                       ; preds = %if.end121
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %__retry

if.else135:                                       ; preds = %if.end121
  %cmp136 = icmp ugt i64 %add126, 40500
  %cmp139 = icmp ult i64 %add126, 41500
  %or.cond1 = and i1 %cmp136, %cmp139
  br i1 %or.cond1, label %if.then141, label %if.else144

if.then141:                                       ; preds = %if.else135
  %ac97_bus142 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 12
  %26 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %ac97_bus142, align 8, !tbaa !122
  %clock143 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %26, i32 0, i32 6
  store i32 41000, i32* %clock143, align 4, !tbaa !121
  br label %__end

if.else144:                                       ; preds = %if.else135
  %cmp145 = icmp ugt i64 %add126, 43600
  %cmp148 = icmp ult i64 %add126, 44600
  %or.cond2 = and i1 %cmp145, %cmp148
  br i1 %or.cond2, label %if.then150, label %if.else153

if.then150:                                       ; preds = %if.else144
  %ac97_bus151 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 12
  %27 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %ac97_bus151, align 8, !tbaa !122
  %clock152 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %27, i32 0, i32 6
  store i32 44100, i32* %clock152, align 4, !tbaa !121
  br label %__end

if.else153:                                       ; preds = %if.else144
  %cmp154 = icmp ult i64 %add126, 47500
  %cmp157 = icmp ugt i64 %add126, 48500
  %or.cond3 = or i1 %cmp154, %cmp157
  br i1 %or.cond3, label %if.then159, label %__end

if.then159:                                       ; preds = %if.else153
  %ac97_bus160 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 12
  %28 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %ac97_bus160, align 8, !tbaa !122
  %clock161 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %28, i32 0, i32 6
  %29 = load i32, i32* %clock161, align 4, !tbaa !121
  %mul162 = mul i32 %29, 48000
  %conv163 = zext i32 %mul162 to i64
  %div164 = udiv i64 %conv163, %add126
  %conv165 = trunc i64 %div164 to i32
  %ac97_bus166 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 12
  %30 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %ac97_bus166, align 8, !tbaa !122
  %clock167 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %30, i32 0, i32 6
  store i32 %conv165, i32* %clock167, align 4, !tbaa !121
  br label %__end

__end:                                            ; preds = %if.then159, %if.else153, %if.then150, %if.then141, %__retry
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %ac97176 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 13
  %arrayidx177 = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97176, i64 0, i64 0
  %31 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx177, align 8, !tbaa !6
  %call178 = call i32 @snd_ac97_update_power(%struct.snd_ac97* %31, i32 44, i32 0)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %__end, %if.then11, %if.then3, %entry
  ret void
}

declare i32 @snd_card_register(%struct.snd_card*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @pci_set_drvdata(%struct.pci_dev* %pdev, i8* %data) #3 {
entry:
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  call void @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @dev_set_drvdata(%struct.device* %dev, i8* %data) #3 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  store i8* %data, i8** %driver_data, align 8, !tbaa !75
  ret void
}

declare void @dev_warn(%struct.device*, i8*, ...) #1

declare i32 @snd_ac97_set_rate(%struct.snd_ac97*, i32, i32) #1

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_setup_periods(%struct.intel8x0* %chip, %struct.ichdev* %ichdev) #2 {
entry:
  %bdbar1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 2
  %0 = load i32*, i32** %bdbar1, align 8, !tbaa !97
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 1
  %1 = load i64, i64* %reg_offset, align 8, !tbaa !62
  %add = add i64 %1, 0
  %conv = trunc i64 %add to i32
  %bdbar_addr = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 3
  %2 = load i32, i32* %bdbar_addr, align 8, !tbaa !71
  call void @iputdword(%struct.intel8x0* %chip, i32 %conv, i32 %2)
  %size = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 6
  %3 = load i32, i32* %size, align 4, !tbaa !93
  %fragsize = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 7
  %4 = load i32, i32* %fragsize, align 8, !tbaa !142
  %cmp = icmp eq i32 %3, %4
  %ack = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 2, i32* %ack, align 4, !tbaa !98
  %ack_reload = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 17
  store i32 2, i32* %ack_reload, align 8, !tbaa !99
  %fragsize3 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 7
  %5 = load i32, i32* %fragsize3, align 8, !tbaa !142
  %shr = lshr i32 %5, 1
  %fragsize1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 8
  store i32 %shr, i32* %fragsize1, align 4, !tbaa !91
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %idx.0 = phi i32 [ 0, %if.then ], [ %add26, %for.body ]
  %cmp4 = icmp slt i32 %idx.0, 64
  br i1 %cmp4, label %for.body, label %if.end

for.body:                                         ; preds = %for.cond
  %physbuf = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 5
  %6 = load i32, i32* %physbuf, align 8, !tbaa !96
  %add6 = add nsw i32 %idx.0, 0
  %idxprom = sext i32 %add6 to i64
  %arrayidx = getelementptr inbounds i32, i32* %0, i64 %idxprom
  store i32 %6, i32* %arrayidx, align 4, !tbaa !2
  %fragsize17 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 8
  %7 = load i32, i32* %fragsize17, align 4, !tbaa !91
  %pos_shift = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 10
  %8 = load i32, i32* %pos_shift, align 4, !tbaa !145
  %shr8 = lshr i32 %7, %8
  %or = or i32 -2147483648, %shr8
  %add9 = add nsw i32 %idx.0, 1
  %idxprom10 = sext i32 %add9 to i64
  %arrayidx11 = getelementptr inbounds i32, i32* %0, i64 %idxprom10
  store i32 %or, i32* %arrayidx11, align 4, !tbaa !2
  %physbuf12 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 5
  %9 = load i32, i32* %physbuf12, align 8, !tbaa !96
  %size13 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 6
  %10 = load i32, i32* %size13, align 4, !tbaa !93
  %shr14 = lshr i32 %10, 1
  %add15 = add i32 %9, %shr14
  %add16 = add nsw i32 %idx.0, 2
  %idxprom17 = sext i32 %add16 to i64
  %arrayidx18 = getelementptr inbounds i32, i32* %0, i64 %idxprom17
  store i32 %add15, i32* %arrayidx18, align 4, !tbaa !2
  %fragsize119 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 8
  %11 = load i32, i32* %fragsize119, align 4, !tbaa !91
  %pos_shift20 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 10
  %12 = load i32, i32* %pos_shift20, align 4, !tbaa !145
  %shr21 = lshr i32 %11, %12
  %or22 = or i32 -2147483648, %shr21
  %add23 = add nsw i32 %idx.0, 3
  %idxprom24 = sext i32 %add23 to i64
  %arrayidx25 = getelementptr inbounds i32, i32* %0, i64 %idxprom24
  store i32 %or22, i32* %arrayidx25, align 4, !tbaa !2
  %add26 = add nsw i32 %idx.0, 4
  br label %for.cond

if.else:                                          ; preds = %entry
  store i32 1, i32* %ack, align 4, !tbaa !98
  %ack_reload28 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 17
  store i32 1, i32* %ack_reload28, align 8, !tbaa !99
  %fragsize29 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 7
  %13 = load i32, i32* %fragsize29, align 8, !tbaa !142
  %fragsize130 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 8
  store i32 %13, i32* %fragsize130, align 4, !tbaa !91
  br label %for.cond31

for.cond31:                                       ; preds = %for.body34, %if.else
  %idx.1 = phi i32 [ 0, %if.else ], [ %add51, %for.body34 ]
  %cmp32 = icmp slt i32 %idx.1, 64
  br i1 %cmp32, label %for.body34, label %for.end52

for.body34:                                       ; preds = %for.cond31
  %physbuf35 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 5
  %14 = load i32, i32* %physbuf35, align 8, !tbaa !96
  %shr36 = ashr i32 %idx.1, 1
  %fragsize37 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 7
  %15 = load i32, i32* %fragsize37, align 8, !tbaa !142
  %mul = mul i32 %shr36, %15
  %size38 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 6
  %16 = load i32, i32* %size38, align 4, !tbaa !93
  %rem = urem i32 %mul, %16
  %add39 = add i32 %14, %rem
  %add40 = add nsw i32 %idx.1, 0
  %idxprom41 = sext i32 %add40 to i64
  %arrayidx42 = getelementptr inbounds i32, i32* %0, i64 %idxprom41
  store i32 %add39, i32* %arrayidx42, align 4, !tbaa !2
  %fragsize43 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 7
  %17 = load i32, i32* %fragsize43, align 8, !tbaa !142
  %pos_shift44 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 10
  %18 = load i32, i32* %pos_shift44, align 4, !tbaa !145
  %shr45 = lshr i32 %17, %18
  %or46 = or i32 -2147483648, %shr45
  %add47 = add nsw i32 %idx.1, 1
  %idxprom48 = sext i32 %add47 to i64
  %arrayidx49 = getelementptr inbounds i32, i32* %0, i64 %idxprom48
  store i32 %or46, i32* %arrayidx49, align 4, !tbaa !2
  %add51 = add nsw i32 %idx.1, 2
  br label %for.cond31

for.end52:                                        ; preds = %for.cond31
  %size53 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 6
  %19 = load i32, i32* %size53, align 4, !tbaa !93
  %fragsize54 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 7
  %20 = load i32, i32* %fragsize54, align 8, !tbaa !142
  %div = udiv i32 %19, %20
  br label %if.end

if.end:                                           ; preds = %for.end52, %for.cond
  %div.sink = phi i32 [ %div, %for.end52 ], [ 2, %for.cond ]
  %frags55 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 12
  store i32 %div.sink, i32* %frags55, align 4, !tbaa !95
  %add56 = add i64 %1, 5
  %conv57 = trunc i64 %add56 to i32
  %lvi = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 13
  store i32 31, i32* %lvi, align 8, !tbaa !72
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv57, i8 zeroext 31)
  %civ = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 15
  store i32 0, i32* %civ, align 8, !tbaa !73
  %add58 = add i64 %1, 4
  %conv59 = trunc i64 %add58 to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv59, i8 zeroext 0)
  %frags60 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 12
  %21 = load i32, i32* %frags60, align 4, !tbaa !95
  %rem61 = srem i32 31, %21
  %lvi_frag = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 14
  store i32 %rem61, i32* %lvi_frag, align 4, !tbaa !94
  %position = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 9
  store i32 0, i32* %position, align 8, !tbaa !92
  %roff_sr = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 19
  %22 = load i32, i32* %roff_sr, align 8, !tbaa !74
  %conv62 = zext i32 %22 to i64
  %add63 = add i64 %1, %conv62
  %conv64 = trunc i64 %add63 to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv64, i8 zeroext 28)
  ret void
}

declare i64 @ktime_get() #1

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @ktime_us_delta(i64 %later, i64 %earlier) #3 {
entry:
  %sub = sub nsw i64 %later, %earlier
  %call = call i64 @ktime_to_us(i64 %sub)
  ret i64 %call
}

declare void @_dev_info(%struct.device*, i8*, ...) #1

declare i32 @snd_ac97_update_power(%struct.snd_ac97*, i32, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @ktime_to_us(i64 %kt) #3 {
entry:
  %call = call i64 @ktime_divns(i64 %kt, i64 1000)
  ret i64 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @ktime_divns(i64 %kt, i64 %div) #3 {
entry:
  %cmp = icmp slt i64 %div, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.146, i32 0, i32 0), i32 168)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %div14 = sdiv i64 %kt, %div
  ret i64 %div14
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #5

declare void @warn_slowpath_null(i8*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @snd_card_proc_new(%struct.snd_card* %card, i8* %name, %struct.snd_info_entry** %entryp) #3 {
entry:
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !146
  %call = call %struct.snd_info_entry* @snd_info_create_card_entry(%struct.snd_card* %card, i8* %name, %struct.snd_info_entry* %0)
  store %struct.snd_info_entry* %call, %struct.snd_info_entry** %entryp, align 8, !tbaa !6
  %1 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entryp, align 8, !tbaa !6
  %tobool = icmp ne %struct.snd_info_entry* %1, null
  %cond = select i1 %tobool, i32 0, i32 -12
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_proc_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !147
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %buffer2 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %2 = load i8*, i8** %buffer2, align 8, !tbaa !149
  %3 = bitcast i8* %2 to %struct.seq_file*
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %3, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.122, i32 0, i32 0))
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 0
  %4 = load i32, i32* %device_type, align 8, !tbaa !59
  %cmp = icmp eq i32 %4, 3
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @igetdword(%struct.intel8x0* %1, i32 48)
  %buffer3 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %5 = load i8*, i8** %buffer3, align 8, !tbaa !149
  %6 = bitcast i8* %5 to %struct.seq_file*
  %call4 = call i32 @igetdword(%struct.intel8x0* %1, i32 44)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %6, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.123, i32 0, i32 0), i32 %call4)
  %buffer5 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %7 = load i8*, i8** %buffer5, align 8, !tbaa !149
  %8 = bitcast i8* %7 to %struct.seq_file*
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %8, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.124, i32 0, i32 0), i32 %call)
  %device_type6 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 0
  %9 = load i32, i32* %device_type6, align 8, !tbaa !59
  %cmp7 = icmp eq i32 %9, 1
  br i1 %cmp7, label %if.then8, label %if.end11

if.then8:                                         ; preds = %if.end
  %buffer9 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %10 = load i8*, i8** %buffer9, align 8, !tbaa !149
  %11 = bitcast i8* %10 to %struct.seq_file*
  %call10 = call i32 @igetdword(%struct.intel8x0* %1, i32 128)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %11, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.125, i32 0, i32 0), i32 %call10)
  br label %if.end11

if.end11:                                         ; preds = %if.then8, %if.end
  %buffer12 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %12 = load i8*, i8** %buffer12, align 8, !tbaa !149
  %13 = bitcast i8* %12 to %struct.seq_file*
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %13, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.126, i32 0, i32 0))
  %codec_isr_bits = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 18
  %14 = load i32, i32* %codec_isr_bits, align 8, !tbaa !102
  %and = and i32 %call, %14
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then13
  %i.0 = phi i32 [ 0, %if.then13 ], [ %inc, %for.inc ]
  %max_codecs = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 15
  %15 = load i32, i32* %max_codecs, align 4, !tbaa !117
  %cmp14 = icmp ult i32 %i.0, %15
  br i1 %cmp14, label %for.body, label %if.end23

for.body:                                         ; preds = %for.cond
  %codec_bit = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 17
  %16 = load i32*, i32** %codec_bit, align 8, !tbaa !103
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i32, i32* %16, i64 %idxprom
  %17 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %and15 = and i32 %call, %17
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then17, label %for.inc

if.then17:                                        ; preds = %for.body
  %buffer18 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %18 = load i8*, i8** %buffer18, align 8, !tbaa !149
  %19 = bitcast i8* %18 to %struct.seq_file*
  %idxprom19 = sext i32 %i.0 to i64
  %arrayidx20 = getelementptr inbounds [3 x i8*], [3 x i8*]* @snd_intel8x0_proc_read.codecs, i64 0, i64 %idxprom19
  %20 = load i8*, i8** %arrayidx20, align 8, !tbaa !6
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %19, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.130, i32 0, i32 0), i8* %20)
  br label %for.inc

for.inc:                                          ; preds = %if.then17, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.else:                                          ; preds = %if.end11
  %buffer22 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %21 = load i8*, i8** %buffer22, align 8, !tbaa !149
  %22 = bitcast i8* %21 to %struct.seq_file*
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %22, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.131, i32 0, i32 0))
  br label %if.end23

if.end23:                                         ; preds = %if.else, %for.cond
  %buffer24 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %23 = load i8*, i8** %buffer24, align 8, !tbaa !149
  %24 = bitcast i8* %23 to %struct.seq_file*
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %24, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.132, i32 0, i32 0))
  %device_type25 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 0
  %25 = load i32, i32* %device_type25, align 8, !tbaa !59
  %cmp26 = icmp eq i32 %25, 1
  br i1 %cmp26, label %if.then29, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end23
  %device_type27 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 0
  %26 = load i32, i32* %device_type27, align 8, !tbaa !59
  %cmp28 = icmp eq i32 %26, 2
  br i1 %cmp28, label %if.then29, label %cleanup.cont

if.then29:                                        ; preds = %lor.lhs.false, %if.end23
  %buffer30 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %27 = load i8*, i8** %buffer30, align 8, !tbaa !149
  %28 = bitcast i8* %27 to %struct.seq_file*
  %ac97_sdin = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 14
  %arrayidx31 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin, i64 0, i64 0
  %29 = load i32, i32* %arrayidx31, align 8, !tbaa !2
  %ac97_sdin32 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 14
  %arrayidx33 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin32, i64 0, i64 1
  %30 = load i32, i32* %arrayidx33, align 4, !tbaa !2
  %ac97_sdin34 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 14
  %arrayidx35 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin34, i64 0, i64 2
  %31 = load i32, i32* %arrayidx35, align 8, !tbaa !2
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %28, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.133, i32 0, i32 0), i32 %29, i32 %30, i32 %31)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then29, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @snd_info_set_text_ops(%struct.snd_info_entry* %entry1, i8* %private_data, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* %read) #3 {
entry:
  %private_data2 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 8
  store i8* %private_data, i8** %private_data2, align 8, !tbaa !147
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 4
  %text = bitcast %union.anon.60* %c to %struct.snd_info_entry_text*
  %read3 = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* %read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read3, align 8, !tbaa !151
  ret void
}

declare void @seq_printf(%struct.seq_file*, i8*, ...) #1

declare %struct.snd_info_entry* @snd_info_create_card_entry(%struct.snd_card*, i8*, %struct.snd_info_entry*) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_pcm1(%struct.intel8x0* %chip, i32 %device, %struct.ich_pcm_table* %rec) #2 {
entry:
  %pcm = alloca %struct.snd_pcm*, align 8
  %name = alloca [32 x i8], align 16
  %chmap = alloca %struct.snd_pcm_chmap*, align 8
  %suffix = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 0
  %0 = load i8*, i8** %suffix, align 8, !tbaa !152
  %tobool = icmp ne i8* %0, null
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  br label %if.end

if.else:                                          ; preds = %entry
  %call3 = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.4, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %card = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 5
  %2 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !118
  %arraydecay4 = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  %playback_ops = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 1
  %3 = load %struct.snd_pcm_ops*, %struct.snd_pcm_ops** %playback_ops, align 8, !tbaa !153
  %tobool5 = icmp ne %struct.snd_pcm_ops* %3, null
  %cond = select i1 %tobool5, i32 1, i32 0
  %capture_ops = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 2
  %4 = load %struct.snd_pcm_ops*, %struct.snd_pcm_ops** %capture_ops, align 8, !tbaa !154
  %tobool6 = icmp ne %struct.snd_pcm_ops* %4, null
  %cond7 = select i1 %tobool6, i32 1, i32 0
  %call8 = call i32 @snd_pcm_new(%struct.snd_card* %2, i8* %arraydecay4, i32 %device, i32 %cond, i32 %cond7, %struct.snd_pcm** %pcm)
  %cmp = icmp slt i32 %call8, 0
  br i1 %cmp, label %cleanup71, label %if.end10

if.end10:                                         ; preds = %if.end
  %playback_ops11 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 1
  %5 = load %struct.snd_pcm_ops*, %struct.snd_pcm_ops** %playback_ops11, align 8, !tbaa !153
  %tobool12 = icmp ne %struct.snd_pcm_ops* %5, null
  br i1 %tobool12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end10
  %6 = load %struct.snd_pcm*, %struct.snd_pcm** %pcm, align 8, !tbaa !6
  %playback_ops14 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 1
  %7 = load %struct.snd_pcm_ops*, %struct.snd_pcm_ops** %playback_ops14, align 8, !tbaa !153
  call void @snd_pcm_set_ops(%struct.snd_pcm* %6, i32 0, %struct.snd_pcm_ops* %7)
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.end10
  %capture_ops16 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 2
  %8 = load %struct.snd_pcm_ops*, %struct.snd_pcm_ops** %capture_ops16, align 8, !tbaa !154
  %tobool17 = icmp ne %struct.snd_pcm_ops* %8, null
  br i1 %tobool17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end15
  %9 = load %struct.snd_pcm*, %struct.snd_pcm** %pcm, align 8, !tbaa !6
  %capture_ops19 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 2
  %10 = load %struct.snd_pcm_ops*, %struct.snd_pcm_ops** %capture_ops19, align 8, !tbaa !154
  call void @snd_pcm_set_ops(%struct.snd_pcm* %9, i32 1, %struct.snd_pcm_ops* %10)
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end15
  %11 = bitcast %struct.intel8x0* %chip to i8*
  %12 = load %struct.snd_pcm*, %struct.snd_pcm** %pcm, align 8, !tbaa !6
  %private_data = getelementptr inbounds %struct.snd_pcm, %struct.snd_pcm* %12, i32 0, i32 11
  store i8* %11, i8** %private_data, align 8, !tbaa !155
  %13 = load %struct.snd_pcm*, %struct.snd_pcm** %pcm, align 8, !tbaa !6
  %info_flags = getelementptr inbounds %struct.snd_pcm, %struct.snd_pcm* %13, i32 0, i32 3
  store i32 0, i32* %info_flags, align 4, !tbaa !158
  %suffix21 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 0
  %14 = load i8*, i8** %suffix21, align 8, !tbaa !152
  %tobool22 = icmp ne i8* %14, null
  %15 = load %struct.snd_pcm*, %struct.snd_pcm** %pcm, align 8, !tbaa !6
  %name24 = getelementptr inbounds %struct.snd_pcm, %struct.snd_pcm* %15, i32 0, i32 7
  %arraydecay25 = getelementptr inbounds [80 x i8], [80 x i8]* %name24, i32 0, i32 0
  %card26 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 5
  %16 = load %struct.snd_card*, %struct.snd_card** %card26, align 8, !tbaa !118
  %shortname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %16, i32 0, i32 3
  %arraydecay27 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname, i32 0, i32 0
  br i1 %tobool22, label %if.then23, label %if.else30

if.then23:                                        ; preds = %if.end20
  %17 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  br label %if.end37

if.else30:                                        ; preds = %if.end20
  %call36 = call i8* @strcpy(i8* %arraydecay25, i8* %arraydecay27)
  br label %if.end37

if.end37:                                         ; preds = %if.else30, %if.then23
  %18 = load %struct.snd_pcm*, %struct.snd_pcm** %pcm, align 8, !tbaa !6
  %pcm38 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 7
  %idxprom = sext i32 %device to i64
  %arrayidx = getelementptr inbounds [6 x %struct.snd_pcm*], [6 x %struct.snd_pcm*]* %pcm38, i64 0, i64 %idxprom
  store %struct.snd_pcm* %18, %struct.snd_pcm** %arrayidx, align 8, !tbaa !6
  %19 = load %struct.snd_pcm*, %struct.snd_pcm** %pcm, align 8, !tbaa !6
  %pci = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %20 = load %struct.pci_dev*, %struct.pci_dev** %pci, align 8, !tbaa !100
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %20, i32 0, i32 35
  %21 = bitcast %struct.device* %dev to i8*
  %prealloc_size = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 3
  %22 = load i64, i64* %prealloc_size, align 8, !tbaa !159
  %prealloc_max_size = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 4
  %23 = load i64, i64* %prealloc_max_size, align 8, !tbaa !160
  %call39 = call i32 @snd_pcm_lib_preallocate_pages_for_all(%struct.snd_pcm* %19, i32 2, i8* %21, i64 %22, i64 %23)
  %playback_ops40 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 1
  %24 = load %struct.snd_pcm_ops*, %struct.snd_pcm_ops** %playback_ops40, align 8, !tbaa !153
  %tobool41 = icmp ne %struct.snd_pcm_ops* %24, null
  br i1 %tobool41, label %land.lhs.true, label %cleanup71

land.lhs.true:                                    ; preds = %if.end37
  %playback_ops42 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 1
  %25 = load %struct.snd_pcm_ops*, %struct.snd_pcm_ops** %playback_ops42, align 8, !tbaa !153
  %open = getelementptr inbounds %struct.snd_pcm_ops, %struct.snd_pcm_ops* %25, i32 0, i32 0
  %26 = load i32 (%struct.snd_pcm_substream*)*, i32 (%struct.snd_pcm_substream*)** %open, align 8, !tbaa !161
  %cmp43 = icmp eq i32 (%struct.snd_pcm_substream*)* %26, @snd_intel8x0_playback_open
  br i1 %cmp43, label %if.then44, label %cleanup71

if.then44:                                        ; preds = %land.lhs.true
  %multi8 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load = load i16, i16* %multi8, align 8
  %bf.lshr = lshr i16 %bf.load, 2
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool45 = icmp ne i32 %bf.cast, 0
  br i1 %tobool45, label %if.end62, label %if.else47

if.else47:                                        ; preds = %if.then44
  %multi6 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load48 = load i16, i16* %multi6, align 8
  %bf.lshr49 = lshr i16 %bf.load48, 1
  %bf.clear50 = and i16 %bf.lshr49, 1
  %bf.cast51 = zext i16 %bf.clear50 to i32
  %tobool52 = icmp ne i32 %bf.cast51, 0
  br i1 %tobool52, label %if.end62, label %if.else54

if.else54:                                        ; preds = %if.else47
  %multi4 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load55 = load i16, i16* %multi4, align 8
  %bf.clear56 = and i16 %bf.load55, 1
  %bf.cast57 = zext i16 %bf.clear56 to i32
  %tobool58 = icmp ne i32 %bf.cast57, 0
  %. = select i1 %tobool58, i32 4, i32 2
  br label %if.end62

if.end62:                                         ; preds = %if.else54, %if.else47, %if.then44
  %chs.2 = phi i32 [ 8, %if.then44 ], [ %., %if.else54 ], [ 6, %if.else47 ]
  %27 = load %struct.snd_pcm*, %struct.snd_pcm** %pcm, align 8, !tbaa !6
  %call63 = call i32 @snd_pcm_add_chmap_ctls(%struct.snd_pcm* %27, i32 0, %struct.snd_pcm_chmap_elem* getelementptr inbounds ([0 x %struct.snd_pcm_chmap_elem], [0 x %struct.snd_pcm_chmap_elem]* @snd_pcm_alt_chmaps, i32 0, i32 0), i32 %chs.2, i64 0, %struct.snd_pcm_chmap** %chmap)
  %cmp64 = icmp slt i32 %call63, 0
  br i1 %cmp64, label %cleanup, label %if.end66

if.end66:                                         ; preds = %if.end62
  %28 = load %struct.snd_pcm_chmap*, %struct.snd_pcm_chmap** %chmap, align 8, !tbaa !6
  %channel_mask = getelementptr inbounds %struct.snd_pcm_chmap, %struct.snd_pcm_chmap* %28, i32 0, i32 5
  store i32 340, i32* %channel_mask, align 4, !tbaa !163
  %29 = load %struct.snd_pcm_chmap*, %struct.snd_pcm_chmap** %chmap, align 8, !tbaa !6
  %ac97 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 13
  %arrayidx67 = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97, i64 0, i64 0
  %30 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx67, align 8, !tbaa !6
  %chmaps = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %30, i32 0, i32 31
  %arrayidx68 = getelementptr inbounds [2 x %struct.snd_pcm_chmap*], [2 x %struct.snd_pcm_chmap*]* %chmaps, i64 0, i64 0
  store %struct.snd_pcm_chmap* %29, %struct.snd_pcm_chmap** %arrayidx68, align 8, !tbaa !6
  br label %cleanup

cleanup:                                          ; preds = %if.end66, %if.end62
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end66 ], [ 1, %if.end62 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  %.call63 = select i1 %SwitchLeaf, i32 0, i32 %call63
  br label %cleanup71

cleanup71:                                        ; preds = %cleanup, %land.lhs.true, %if.end37, %if.end
  %retval.1 = phi i32 [ %call8, %if.end ], [ 0, %land.lhs.true ], [ 0, %if.end37 ], [ %.call63, %cleanup ]
  ret i32 %retval.1
}

declare i32 @sprintf(i8*, i8*, ...) #1

declare i32 @snd_pcm_new(%struct.snd_card*, i8*, i32, i32, i32, %struct.snd_pcm**) #1

declare void @snd_pcm_set_ops(%struct.snd_pcm*, i32, %struct.snd_pcm_ops*) #1

declare i32 @snd_pcm_lib_preallocate_pages_for_all(%struct.snd_pcm*, i32, i8*, i64, i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_playback_open(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %runtime1 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 11
  %2 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime1, align 8, !tbaa !64
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 1
  %call = call i32 @snd_intel8x0_pcm_open(%struct.snd_pcm_substream* %substream, %struct.ichdev* %arrayidx)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %multi8 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load = load i16, i16* %multi8, align 8
  %bf.lshr = lshr i16 %bf.load, 2
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %hw = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 45
  %channels_max = getelementptr inbounds %struct.snd_pcm_hardware, %struct.snd_pcm_hardware* %hw, i32 0, i32 6
  store i32 8, i32* %channels_max, align 8, !tbaa !166
  %call3 = call i32 @snd_pcm_hw_constraint_list(%struct.snd_pcm_runtime* %2, i32 0, i32 10, %struct.snd_pcm_hw_constraint_list* @hw_constraints_channels8)
  br label %if.end24

if.else:                                          ; preds = %if.end
  %multi6 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load4 = load i16, i16* %multi6, align 8
  %bf.lshr5 = lshr i16 %bf.load4, 1
  %bf.clear6 = and i16 %bf.lshr5, 1
  %bf.cast7 = zext i16 %bf.clear6 to i32
  %tobool8 = icmp ne i32 %bf.cast7, 0
  br i1 %tobool8, label %if.then9, label %if.else13

if.then9:                                         ; preds = %if.else
  %hw10 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 45
  %channels_max11 = getelementptr inbounds %struct.snd_pcm_hardware, %struct.snd_pcm_hardware* %hw10, i32 0, i32 6
  store i32 6, i32* %channels_max11, align 8, !tbaa !166
  %call12 = call i32 @snd_pcm_hw_constraint_list(%struct.snd_pcm_runtime* %2, i32 0, i32 10, %struct.snd_pcm_hw_constraint_list* @hw_constraints_channels6)
  br label %if.end24

if.else13:                                        ; preds = %if.else
  %multi4 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load14 = load i16, i16* %multi4, align 8
  %bf.clear15 = and i16 %bf.load14, 1
  %bf.cast16 = zext i16 %bf.clear15 to i32
  %tobool17 = icmp ne i32 %bf.cast16, 0
  br i1 %tobool17, label %if.then18, label %if.end24

if.then18:                                        ; preds = %if.else13
  %hw19 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 45
  %channels_max20 = getelementptr inbounds %struct.snd_pcm_hardware, %struct.snd_pcm_hardware* %hw19, i32 0, i32 6
  store i32 4, i32* %channels_max20, align 8, !tbaa !166
  %call21 = call i32 @snd_pcm_hw_constraint_list(%struct.snd_pcm_runtime* %2, i32 0, i32 10, %struct.snd_pcm_hw_constraint_list* @hw_constraints_channels4)
  br label %if.end24

if.end24:                                         ; preds = %if.then18, %if.else13, %if.then9, %if.then2
  %dra = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load25 = load i16, i16* %dra, align 8
  %bf.lshr26 = lshr i16 %bf.load25, 3
  %bf.clear27 = and i16 %bf.lshr26, 1
  %bf.cast28 = zext i16 %bf.clear27 to i32
  %tobool29 = icmp ne i32 %bf.cast28, 0
  br i1 %tobool29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.end24
  %call31 = call i32 @snd_ac97_pcm_double_rate_rules(%struct.snd_pcm_runtime* %2)
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %if.end24
  %smp20bit = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load33 = load i16, i16* %smp20bit, align 8
  %bf.lshr34 = lshr i16 %bf.load33, 4
  %bf.clear35 = and i16 %bf.lshr34, 1
  %bf.cast36 = zext i16 %bf.clear35 to i32
  %tobool37 = icmp ne i32 %bf.cast36, 0
  br i1 %tobool37, label %if.then38, label %cleanup

if.then38:                                        ; preds = %if.end32
  %hw39 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 45
  %formats = getelementptr inbounds %struct.snd_pcm_hardware, %struct.snd_pcm_hardware* %hw39, i32 0, i32 1
  %3 = load i64, i64* %formats, align 8, !tbaa !167
  %or = or i64 %3, 1024
  store i64 %or, i64* %formats, align 8, !tbaa !167
  %call40 = call i32 @snd_pcm_hw_constraint_msbits(%struct.snd_pcm_runtime* %2, i32 0, i32 32, i32 20)
  br label %cleanup

cleanup:                                          ; preds = %if.then38, %if.end32, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ 0, %if.then38 ], [ 0, %if.end32 ]
  ret i32 %retval.0
}

declare i32 @snd_pcm_add_chmap_ctls(%struct.snd_pcm*, i32, %struct.snd_pcm_chmap_elem*, i32, i64, %struct.snd_pcm_chmap**) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_pcm_open(%struct.snd_pcm_substream* %substream, %struct.ichdev* %ichdev) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %runtime1 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 11
  %2 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime1, align 8, !tbaa !64
  %substream2 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 4
  store %struct.snd_pcm_substream* %substream, %struct.snd_pcm_substream** %substream2, align 8, !tbaa !56
  %hw = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 45
  %3 = bitcast %struct.snd_pcm_hardware* %hw to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* bitcast (%struct.snd_pcm_hardware* @snd_intel8x0_stream to i8*), i64 80, i32 8, i1 false), !tbaa.struct !168
  %pcm = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 23
  %4 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm, align 8, !tbaa !126
  %rates = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %4, i32 0, i32 4
  %5 = load i32, i32* %rates, align 8, !tbaa !133
  %hw3 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 45
  %rates4 = getelementptr inbounds %struct.snd_pcm_hardware, %struct.snd_pcm_hardware* %hw3, i32 0, i32 2
  store i32 %5, i32* %rates4, align 8, !tbaa !170
  %call = call i32 @snd_pcm_limit_hw_rates(%struct.snd_pcm_runtime* %2)
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 0
  %6 = load i32, i32* %device_type, align 8, !tbaa !59
  %cmp = icmp eq i32 %6, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %hw5 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 45
  %buffer_bytes_max = getelementptr inbounds %struct.snd_pcm_hardware, %struct.snd_pcm_hardware* %hw5, i32 0, i32 7
  store i64 65536, i64* %buffer_bytes_max, align 8, !tbaa !171
  %hw6 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 45
  %period_bytes_max = getelementptr inbounds %struct.snd_pcm_hardware, %struct.snd_pcm_hardware* %hw6, i32 0, i32 9
  store i64 65536, i64* %period_bytes_max, align 8, !tbaa !172
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call7 = call i32 @snd_pcm_hw_constraint_integer(%struct.snd_pcm_runtime* %2, i32 15)
  %cmp8 = icmp slt i32 %call7, 0
  br i1 %cmp8, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end
  %7 = bitcast %struct.ichdev* %ichdev to i8*
  %private_data11 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 43
  store i8* %7, i8** %private_data11, align 8, !tbaa !173
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.end
  %retval.0 = phi i32 [ 0, %if.end10 ], [ %call7, %if.end ]
  ret i32 %retval.0
}

declare i32 @snd_pcm_hw_constraint_list(%struct.snd_pcm_runtime*, i32, i32, %struct.snd_pcm_hw_constraint_list*) #1

declare i32 @snd_ac97_pcm_double_rate_rules(%struct.snd_pcm_runtime*) #1

declare i32 @snd_pcm_hw_constraint_msbits(%struct.snd_pcm_runtime*, i32, i32, i32) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #4

declare i32 @snd_pcm_limit_hw_rates(%struct.snd_pcm_runtime*) #1

declare i32 @snd_pcm_hw_constraint_integer(%struct.snd_pcm_runtime*, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ali_ac97spdifout_open(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %reg_lock = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 20
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reg_lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i) #6
  %call = call i32 @igetdword(%struct.intel8x0* %1, i32 16)
  %or = or i32 %call, 2097152
  call void @iputdword(%struct.intel8x0* %1, i32 16, i32 %or)
  %reg_lock1 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 20
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reg_lock1, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %3 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i1) #6
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 3
  %call2 = call i32 @snd_intel8x0_pcm_open(%struct.snd_pcm_substream* %substream, %struct.ichdev* %arrayidx)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ali_ac97spdifout_close(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 3
  %substream1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 4
  store %struct.snd_pcm_substream* null, %struct.snd_pcm_substream** %substream1, align 8, !tbaa !56
  %reg_lock = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 20
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reg_lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i) #6
  %call = call i32 @igetdword(%struct.intel8x0* %1, i32 16)
  %and = and i32 %call, -2097153
  call void @iputdword(%struct.intel8x0* %1, i32 16, i32 %and)
  %reg_lock2 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 20
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reg_lock2, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %3 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i1) #6
  ret i32 0
}

declare i32 @snd_pcm_lib_ioctl(%struct.snd_pcm_substream*, i32, i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_hw_params(%struct.snd_pcm_substream* %substream, %struct.snd_pcm_hw_params* %hw_params) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %runtime = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 11
  %2 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime, align 8, !tbaa !64
  %private_data1 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 43
  %3 = load i8*, i8** %private_data1, align 8, !tbaa !173
  %4 = bitcast i8* %3 to %struct.ichdev*
  %runtime3 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 11
  %5 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime3, align 8, !tbaa !64
  %call = call i32 @params_rate(%struct.snd_pcm_hw_params* %hw_params)
  %cmp = icmp ugt i32 %call, 48000
  %conv = zext i1 %cmp to i32
  %fix_nocache = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load = load i16, i16* %fix_nocache, align 8
  %bf.lshr = lshr i16 %bf.load, 8
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %page_attr_changed = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load4 = load i8, i8* %page_attr_changed, align 4
  %bf.clear5 = and i8 %bf.load4, 1
  %bf.cast6 = zext i8 %bf.clear5 to i32
  %tobool7 = icmp ne i32 %bf.cast6, 0
  br i1 %tobool7, label %do.end, label %if.end

do.end:                                           ; preds = %land.lhs.true
  %page_attr_changed8 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load9 = load i8, i8* %page_attr_changed8, align 4
  %bf.clear10 = and i8 %bf.load9, -2
  store i8 %bf.clear10, i8* %page_attr_changed8, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %land.lhs.true, %entry
  %call11 = call i32 @params_buffer_bytes(%struct.snd_pcm_hw_params* %hw_params)
  %conv12 = zext i32 %call11 to i64
  %call13 = call i32 @snd_pcm_lib_malloc_pages(%struct.snd_pcm_substream* %substream, i64 %conv12)
  %cmp14 = icmp slt i32 %call13, 0
  br i1 %cmp14, label %cleanup, label %if.end17

if.end17:                                         ; preds = %if.end
  %fix_nocache18 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load19 = load i16, i16* %fix_nocache18, align 8
  %bf.lshr20 = lshr i16 %bf.load19, 8
  %bf.clear21 = and i16 %bf.lshr20, 1
  %bf.cast22 = zext i16 %bf.clear21 to i32
  %tobool23 = icmp ne i32 %bf.cast22, 0
  br i1 %tobool23, label %if.then24, label %if.end40

if.then24:                                        ; preds = %if.end17
  %dma_area = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %5, i32 0, i32 49
  %6 = load i8*, i8** %dma_area, align 8, !tbaa !174
  %tobool25 = icmp ne i8* %6, null
  br i1 %tobool25, label %land.lhs.true26, label %if.end40

land.lhs.true26:                                  ; preds = %if.then24
  %page_attr_changed27 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load28 = load i8, i8* %page_attr_changed27, align 4
  %bf.clear29 = and i8 %bf.load28, 1
  %bf.cast30 = zext i8 %bf.clear29 to i32
  %tobool31 = icmp ne i32 %bf.cast30, 0
  br i1 %tobool31, label %if.end40, label %do.end35

do.end35:                                         ; preds = %land.lhs.true26
  %page_attr_changed36 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load37 = load i8, i8* %page_attr_changed36, align 4
  %bf.clear38 = and i8 %bf.load37, -2
  %bf.set = or i8 %bf.clear38, 1
  store i8 %bf.set, i8* %page_attr_changed36, align 4
  br label %if.end40

if.end40:                                         ; preds = %do.end35, %land.lhs.true26, %if.then24, %if.end17
  %pcm_open_flag = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 24
  %7 = load i32, i32* %pcm_open_flag, align 8, !tbaa !175
  %tobool41 = icmp ne i32 %7, 0
  br i1 %tobool41, label %if.then42, label %if.end45

if.then42:                                        ; preds = %if.end40
  %pcm = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 23
  %8 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm, align 8, !tbaa !126
  %call43 = call i32 @snd_ac97_pcm_close(%struct.ac97_pcm* %8)
  %pcm_open_flag44 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 24
  store i32 0, i32* %pcm_open_flag44, align 8, !tbaa !175
  br label %if.end45

if.end45:                                         ; preds = %if.then42, %if.end40
  %pcm46 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 23
  %9 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm46, align 8, !tbaa !126
  %call47 = call i32 @params_rate(%struct.snd_pcm_hw_params* %hw_params)
  %call48 = call i32 @params_channels(%struct.snd_pcm_hw_params* %hw_params)
  %pcm49 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 23
  %10 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm49, align 8, !tbaa !126
  %r = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %10, i32 0, i32 5
  %idxprom = sext i32 %conv to i64
  %arrayidx = getelementptr inbounds [2 x %struct.anon.74], [2 x %struct.anon.74]* %r, i64 0, i64 %idxprom
  %slots = getelementptr inbounds %struct.anon.74, %struct.anon.74* %arrayidx, i32 0, i32 0
  %11 = load i16, i16* %slots, align 8, !tbaa !129
  %call50 = call i32 @snd_ac97_pcm_open(%struct.ac97_pcm* %9, i32 %call47, i32 %call48, i16 zeroext %11)
  %cmp51 = icmp sge i32 %call50, 0
  br i1 %cmp51, label %if.then53, label %cleanup

if.then53:                                        ; preds = %if.end45
  %pcm_open_flag54 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 24
  store i32 1, i32* %pcm_open_flag54, align 8, !tbaa !175
  %ichd = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 0
  %12 = load i32, i32* %ichd, align 8, !tbaa !63
  %cmp55 = icmp eq i32 %12, 1
  br i1 %cmp55, label %land.lhs.true57, label %cleanup

land.lhs.true57:                                  ; preds = %if.then53
  %spdif_idx = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 10
  %13 = load i32, i32* %spdif_idx, align 4, !tbaa !112
  %cmp58 = icmp slt i32 %13, 0
  br i1 %cmp58, label %if.then60, label %cleanup

if.then60:                                        ; preds = %land.lhs.true57
  %pcm61 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 23
  %14 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm61, align 8, !tbaa !126
  %r62 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %14, i32 0, i32 5
  %arrayidx63 = getelementptr inbounds [2 x %struct.anon.74], [2 x %struct.anon.74]* %r62, i64 0, i64 0
  %codec = getelementptr inbounds %struct.anon.74, %struct.anon.74* %arrayidx63, i32 0, i32 3
  %arrayidx64 = getelementptr inbounds [4 x %struct.snd_ac97*], [4 x %struct.snd_ac97*]* %codec, i64 0, i64 0
  %15 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx64, align 8, !tbaa !6
  %call65 = call i32 @params_rate(%struct.snd_pcm_hw_params* %hw_params)
  %call66 = call i32 @snd_ac97_set_rate(%struct.snd_ac97* %15, i32 58, i32 %call65)
  br label %cleanup

cleanup:                                          ; preds = %if.then60, %land.lhs.true57, %if.then53, %if.end45, %if.end
  %retval.0 = phi i32 [ %call13, %if.end ], [ %call50, %if.then53 ], [ %call50, %land.lhs.true57 ], [ %call50, %if.then60 ], [ %call50, %if.end45 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_hw_free(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %runtime = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 11
  %2 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime, align 8, !tbaa !64
  %private_data1 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 43
  %3 = load i8*, i8** %private_data1, align 8, !tbaa !173
  %4 = bitcast i8* %3 to %struct.ichdev*
  %pcm_open_flag = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 24
  %5 = load i32, i32* %pcm_open_flag, align 8, !tbaa !175
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %pcm = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 23
  %6 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm, align 8, !tbaa !126
  %call = call i32 @snd_ac97_pcm_close(%struct.ac97_pcm* %6)
  %pcm_open_flag2 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 24
  store i32 0, i32* %pcm_open_flag2, align 8, !tbaa !175
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %fix_nocache = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load = load i16, i16* %fix_nocache, align 8
  %bf.lshr = lshr i16 %bf.load, 8
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool3 = icmp ne i32 %bf.cast, 0
  br i1 %tobool3, label %land.lhs.true, label %if.end12

land.lhs.true:                                    ; preds = %if.end
  %page_attr_changed = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load4 = load i8, i8* %page_attr_changed, align 4
  %bf.clear5 = and i8 %bf.load4, 1
  %bf.cast6 = zext i8 %bf.clear5 to i32
  %tobool7 = icmp ne i32 %bf.cast6, 0
  br i1 %tobool7, label %do.end, label %if.end12

do.end:                                           ; preds = %land.lhs.true
  %page_attr_changed9 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load10 = load i8, i8* %page_attr_changed9, align 4
  %bf.clear11 = and i8 %bf.load10, -2
  store i8 %bf.clear11, i8* %page_attr_changed9, align 4
  br label %if.end12

if.end12:                                         ; preds = %do.end, %land.lhs.true, %if.end
  %call13 = call i32 @snd_pcm_lib_free_pages(%struct.snd_pcm_substream* %substream)
  ret i32 %call13
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_pcm_prepare(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %runtime1 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 11
  %2 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime1, align 8, !tbaa !64
  %runtime2 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 11
  %3 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime2, align 8, !tbaa !64
  %private_data3 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %3, i32 0, i32 43
  %4 = load i8*, i8** %private_data3, align 8, !tbaa !173
  %5 = bitcast i8* %4 to %struct.ichdev*
  %dma_addr = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 50
  %6 = load i64, i64* %dma_addr, align 8, !tbaa !176
  %conv = trunc i64 %6 to i32
  %physbuf = getelementptr inbounds %struct.ichdev, %struct.ichdev* %5, i32 0, i32 5
  store i32 %conv, i32* %physbuf, align 8, !tbaa !96
  %call = call i64 @snd_pcm_lib_buffer_bytes(%struct.snd_pcm_substream* %substream)
  %conv4 = trunc i64 %call to i32
  %size = getelementptr inbounds %struct.ichdev, %struct.ichdev* %5, i32 0, i32 6
  store i32 %conv4, i32* %size, align 4, !tbaa !93
  %call5 = call i64 @snd_pcm_lib_period_bytes(%struct.snd_pcm_substream* %substream)
  %conv6 = trunc i64 %call5 to i32
  %fragsize = getelementptr inbounds %struct.ichdev, %struct.ichdev* %5, i32 0, i32 7
  store i32 %conv6, i32* %fragsize, align 8, !tbaa !142
  %ichd = getelementptr inbounds %struct.ichdev, %struct.ichdev* %5, i32 0, i32 0
  %7 = load i32, i32* %ichd, align 8, !tbaa !63
  %cmp = icmp eq i32 %7, 1
  br i1 %cmp, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  call void @snd_intel8x0_setup_pcm_out(%struct.intel8x0* %1, %struct.snd_pcm_runtime* %2)
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 0
  %8 = load i32, i32* %device_type, align 8, !tbaa !59
  %cmp8 = icmp eq i32 %8, 1
  br i1 %cmp8, label %if.then10, label %if.end13

if.then10:                                        ; preds = %if.then
  %sample_bits = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 22
  %9 = load i32, i32* %sample_bits, align 4, !tbaa !89
  %cmp11 = icmp ugt i32 %9, 16
  %cond = select i1 %cmp11, i32 2, i32 1
  %pos_shift = getelementptr inbounds %struct.ichdev, %struct.ichdev* %5, i32 0, i32 10
  store i32 %cond, i32* %pos_shift, align 4, !tbaa !145
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %if.then, %entry
  call void @snd_intel8x0_setup_periods(%struct.intel8x0* %1, %struct.ichdev* %5)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ali_trigger(%struct.snd_pcm_substream* %substream, i32 %cmd) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %runtime = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 11
  %2 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime, align 8, !tbaa !64
  %private_data1 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 43
  %3 = load i8*, i8** %private_data1, align 8, !tbaa !173
  %4 = bitcast i8* %3 to %struct.ichdev*
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 1
  %5 = load i64, i64* %reg_offset, align 8, !tbaa !62
  %call = call i32 @igetdword(%struct.intel8x0* %1, i32 8)
  %Pivot12 = icmp slt i32 %cmd, 4
  br i1 %Pivot12, label %NodeBlock3, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %cmd, 5
  br i1 %Pivot10, label %sw.bb2, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %cmd, 6
  br i1 %Pivot8, label %sw.bb20, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %cmd, 6
  br i1 %SwitchLeaf6, label %sw.bb, label %cleanup

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %cmd, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %cmd, 3
  br i1 %Pivot, label %LeafBlock1, label %sw.bb24

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, 1
  br i1 %SwitchLeaf2, label %sw.bb2, label %cleanup

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %cmd, 0
  br i1 %SwitchLeaf, label %sw.bb24, label %cleanup

sw.bb:                                            ; preds = %LeafBlock5
  %suspended = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load = load i8, i8* %suspended, align 4
  %bf.clear = and i8 %bf.load, -3
  store i8 %bf.clear, i8* %suspended, align 4
  br label %sw.bb2

sw.bb2:                                           ; preds = %sw.bb, %LeafBlock1, %NodeBlock9
  %stream = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 5
  %6 = load i32, i32* %stream, align 4, !tbaa !177
  %cmp = icmp eq i32 %6, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb2
  %ali_slot = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 22
  %7 = load i32, i32* %ali_slot, align 4, !tbaa !143
  %div = udiv i32 %7, 4
  %idxprom = zext i32 %div to i64
  %arrayidx = getelementptr inbounds [3 x i32], [3 x i32]* @snd_intel8x0_ali_trigger.fiforeg, i64 0, i64 %idxprom
  %8 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %call3 = call i32 @igetdword(%struct.intel8x0* %1, i32 %8)
  %ali_slot4 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 22
  %9 = load i32, i32* %ali_slot4, align 4, !tbaa !143
  %rem = urem i32 %9, 4
  %shl = shl i32 255, %rem
  %neg = xor i32 %shl, -1
  %and = and i32 %call3, %neg
  %ali_slot5 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 22
  %10 = load i32, i32* %ali_slot5, align 4, !tbaa !143
  %rem6 = urem i32 %10, 4
  %shl7 = shl i32 131, %rem6
  %or = or i32 %and, %shl7
  %ali_slot8 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 22
  %11 = load i32, i32* %ali_slot8, align 4, !tbaa !143
  %div9 = udiv i32 %11, 4
  %idxprom10 = zext i32 %div9 to i64
  %arrayidx11 = getelementptr inbounds [3 x i32], [3 x i32]* @snd_intel8x0_ali_trigger.fiforeg, i64 0, i64 %idxprom10
  %12 = load i32, i32* %arrayidx11, align 4, !tbaa !2
  call void @iputdword(%struct.intel8x0* %1, i32 %12, i32 %or)
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb2
  %add = add i64 %5, 11
  %conv = trunc i64 %add to i32
  call void @iputbyte(%struct.intel8x0* %1, i32 %conv, i8 zeroext 16)
  %ali_slot12 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 22
  %13 = load i32, i32* %ali_slot12, align 4, !tbaa !143
  %add13 = add i32 %13, 16
  %shl14 = shl i32 1, %add13
  %neg15 = xor i32 %shl14, -1
  %and16 = and i32 %call, %neg15
  %ali_slot17 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 22
  %14 = load i32, i32* %ali_slot17, align 4, !tbaa !143
  %shl18 = shl i32 1, %14
  %or19 = or i32 %and16, %shl18
  call void @iputdword(%struct.intel8x0* %1, i32 8, i32 %or19)
  br label %cleanup

sw.bb20:                                          ; preds = %NodeBlock7
  %suspended21 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load22 = load i8, i8* %suspended21, align 4
  %bf.clear23 = and i8 %bf.load22, -3
  %bf.set = or i8 %bf.clear23, 2
  store i8 %bf.set, i8* %suspended21, align 4
  br label %sw.bb24

sw.bb24:                                          ; preds = %sw.bb20, %LeafBlock, %NodeBlock
  %ali_slot25 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 22
  %15 = load i32, i32* %ali_slot25, align 4, !tbaa !143
  %add26 = add i32 %15, 16
  %shl27 = shl i32 1, %add26
  %or28 = or i32 %call, %shl27
  call void @iputdword(%struct.intel8x0* %1, i32 8, i32 %or28)
  %add29 = add i64 %5, 11
  %conv30 = trunc i64 %add29 to i32
  call void @iputbyte(%struct.intel8x0* %1, i32 %conv30, i8 zeroext 0)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %sw.bb24
  %add31 = add i64 %5, 11
  %conv32 = trunc i64 %add31 to i32
  %call33 = call zeroext i8 @igetbyte(%struct.intel8x0* %1, i32 %conv32)
  %tobool = icmp ne i8 %call33, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %cmp34 = icmp eq i32 %cmd, 3
  br i1 %cmp34, label %cleanup, label %if.end37

if.end37:                                         ; preds = %while.end
  %add38 = add i64 %5, 11
  %conv39 = trunc i64 %add38 to i32
  call void @iputbyte(%struct.intel8x0* %1, i32 %conv39, i8 zeroext 2)
  %add40 = add i64 %5, 6
  %conv41 = trunc i64 %add40 to i32
  %add42 = add i64 %5, 6
  %conv43 = trunc i64 %add42 to i32
  %call44 = call zeroext i8 @igetbyte(%struct.intel8x0* %1, i32 %conv43)
  %conv45 = zext i8 %call44 to i32
  %or46 = or i32 %conv45, 30
  %conv47 = trunc i32 %or46 to i8
  call void @iputbyte(%struct.intel8x0* %1, i32 %conv41, i8 zeroext %conv47)
  %call48 = call i32 @igetdword(%struct.intel8x0* %1, i32 24)
  %int_sta_mask = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 21
  %16 = load i32, i32* %int_sta_mask, align 8, !tbaa !78
  %and49 = and i32 %call48, %16
  call void @iputdword(%struct.intel8x0* %1, i32 24, i32 %and49)
  br label %cleanup

cleanup:                                          ; preds = %if.end37, %while.end, %if.end, %LeafBlock, %LeafBlock1, %LeafBlock5
  %retval.0 = phi i32 [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -22, %LeafBlock5 ], [ 0, %while.end ], [ 0, %if.end37 ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_intel8x0_pcm_pointer(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %runtime = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 11
  %2 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime, align 8, !tbaa !64
  %private_data1 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 43
  %3 = load i8*, i8** %private_data1, align 8, !tbaa !173
  %4 = bitcast i8* %3 to %struct.ichdev*
  %reg_lock = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 20
  %5 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reg_lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %5 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock.i) #6
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %timeout.0 = phi i32 [ 10, %entry ], [ %dec, %do.cond ]
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 1
  %6 = load i64, i64* %reg_offset, align 8, !tbaa !62
  %add = add i64 %6, 4
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @igetbyte(%struct.intel8x0* %1, i32 %conv)
  %conv2 = zext i8 %call to i32
  %reg_offset3 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 1
  %7 = load i64, i64* %reg_offset3, align 8, !tbaa !62
  %roff_picb = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 20
  %8 = load i32, i32* %roff_picb, align 4, !tbaa !144
  %conv4 = zext i32 %8 to i64
  %add5 = add i64 %7, %conv4
  %conv6 = trunc i64 %add5 to i32
  %call7 = call zeroext i16 @igetword(%struct.intel8x0* %1, i32 %conv6)
  %conv8 = zext i16 %call7 to i64
  %position9 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 9
  %9 = load i32, i32* %position9, align 8, !tbaa !92
  %cmp = icmp eq i64 %conv8, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  call void @__const_udelay(i64 42950)
  br label %do.cond

if.end:                                           ; preds = %do.body
  %reg_offset11 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 1
  %10 = load i64, i64* %reg_offset11, align 8, !tbaa !62
  %add12 = add i64 %10, 4
  %conv13 = trunc i64 %add12 to i32
  %call14 = call zeroext i8 @igetbyte(%struct.intel8x0* %1, i32 %conv13)
  %conv15 = zext i8 %call14 to i32
  %cmp16 = icmp ne i32 %conv2, %conv15
  br i1 %cmp16, label %do.cond, label %if.end19

if.end19:                                         ; preds = %if.end
  %inside_vm = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load = load i16, i16* %inside_vm, align 8
  %bf.lshr = lshr i16 %bf.load, 12
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %do.end, label %if.end21

if.end21:                                         ; preds = %if.end19
  %reg_offset22 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 1
  %11 = load i64, i64* %reg_offset22, align 8, !tbaa !62
  %roff_picb23 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 20
  %12 = load i32, i32* %roff_picb23, align 4, !tbaa !144
  %conv24 = zext i32 %12 to i64
  %add25 = add i64 %11, %conv24
  %conv26 = trunc i64 %add25 to i32
  %call27 = call zeroext i16 @igetword(%struct.intel8x0* %1, i32 %conv26)
  %conv28 = zext i16 %call27 to i64
  %cmp29 = icmp eq i64 %conv8, %conv28
  br i1 %cmp29, label %do.end, label %do.cond

do.cond:                                          ; preds = %if.end21, %if.end, %if.then
  %dec = add nsw i32 %timeout.0, -1
  %tobool33 = icmp ne i32 %timeout.0, 0
  br i1 %tobool33, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond, %if.end21, %if.end19
  %last_pos = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 11
  %13 = load i32, i32* %last_pos, align 8, !tbaa !178
  %conv34 = zext i32 %13 to i64
  %cmp35 = icmp ne i64 %conv8, 0
  br i1 %cmp35, label %if.then37, label %if.end57

if.then37:                                        ; preds = %do.end
  %pos_shift = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 10
  %14 = load i32, i32* %pos_shift, align 4, !tbaa !145
  %sh_prom = zext i32 %14 to i64
  %shl = shl i64 %conv8, %sh_prom
  %fragsize1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 8
  %15 = load i32, i32* %fragsize1, align 4, !tbaa !91
  %conv38 = zext i32 %15 to i64
  %sub = sub i64 %conv38, %shl
  %conv39 = zext i32 %9 to i64
  %add40 = add i64 %sub, %conv39
  %last_pos41 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 11
  %16 = load i32, i32* %last_pos41, align 8, !tbaa !178
  %conv42 = zext i32 %16 to i64
  %cmp43 = icmp ult i64 %add40, %conv42
  br i1 %cmp43, label %if.then45, label %if.end57

if.then45:                                        ; preds = %if.then37
  %fragsize146 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 8
  %17 = load i32, i32* %fragsize146, align 4, !tbaa !91
  %div = udiv i32 %9, %17
  %last_pos47 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 11
  %18 = load i32, i32* %last_pos47, align 8, !tbaa !178
  %fragsize148 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 8
  %19 = load i32, i32* %fragsize148, align 4, !tbaa !91
  %div49 = udiv i32 %18, %19
  %cmp50 = icmp eq i32 %div, %div49
  br i1 %cmp50, label %if.then52, label %if.end57

if.then52:                                        ; preds = %if.then45
  %last_pos53 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 11
  %20 = load i32, i32* %last_pos53, align 8, !tbaa !178
  %conv54 = zext i32 %20 to i64
  br label %if.end57

if.end57:                                         ; preds = %if.then52, %if.then45, %if.then37, %do.end
  %ptr.2 = phi i64 [ %conv34, %do.end ], [ %add40, %if.then37 ], [ %conv54, %if.then52 ], [ %add40, %if.then45 ]
  %conv58 = trunc i64 %ptr.2 to i32
  %last_pos59 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 11
  store i32 %conv58, i32* %last_pos59, align 8, !tbaa !178
  %reg_lock60 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 20
  %21 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %reg_lock60, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %21 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock.i1) #6
  %size = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 6
  %22 = load i32, i32* %size, align 4, !tbaa !93
  %conv61 = zext i32 %22 to i64
  %cmp62 = icmp uge i64 %ptr.2, %conv61
  br i1 %cmp62, label %cleanup, label %if.end65

if.end65:                                         ; preds = %if.end57
  %runtime66 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 11
  %23 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime66, align 8, !tbaa !64
  %call67 = call i64 @bytes_to_frames(%struct.snd_pcm_runtime* %23, i64 %ptr.2)
  br label %cleanup

cleanup:                                          ; preds = %if.end65, %if.end57
  %retval.0 = phi i64 [ %call67, %if.end65 ], [ 0, %if.end57 ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @bytes_to_frames(%struct.snd_pcm_runtime* %runtime, i64 %size) #3 {
entry:
  %mul = mul nsw i64 %size, 8
  %frame_bits = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 21
  %0 = load i32, i32* %frame_bits, align 8, !tbaa !179
  %conv = zext i32 %0 to i64
  %div = sdiv i64 %mul, %conv
  ret i64 %div
}

declare void @_raw_spin_unlock(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare void @_raw_spin_lock(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @snd_pcm_lib_buffer_bytes(%struct.snd_pcm_substream* %substream) #3 {
entry:
  %runtime1 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 11
  %0 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime1, align 8, !tbaa !64
  %buffer_size = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %0, i32 0, i32 18
  %1 = load i64, i64* %buffer_size, align 8, !tbaa !180
  %call = call i64 @frames_to_bytes(%struct.snd_pcm_runtime* %0, i64 %1)
  ret i64 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @snd_pcm_lib_period_bytes(%struct.snd_pcm_substream* %substream) #3 {
entry:
  %runtime1 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 11
  %0 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime1, align 8, !tbaa !64
  %period_size = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %0, i32 0, i32 16
  %1 = load i64, i64* %period_size, align 8, !tbaa !181
  %call = call i64 @frames_to_bytes(%struct.snd_pcm_runtime* %0, i64 %1)
  ret i64 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @frames_to_bytes(%struct.snd_pcm_runtime* %runtime, i64 %size) #3 {
entry:
  %frame_bits = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 21
  %0 = load i32, i32* %frame_bits, align 8, !tbaa !179
  %conv = zext i32 %0 to i64
  %mul = mul nsw i64 %size, %conv
  %div = sdiv i64 %mul, 8
  ret i64 %div
}

declare i32 @snd_ac97_pcm_close(%struct.ac97_pcm*) #1

declare i32 @snd_pcm_lib_free_pages(%struct.snd_pcm_substream*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @params_rate(%struct.snd_pcm_hw_params* %p) #3 {
entry:
  %call = call %struct.snd_interval* @hw_param_interval_c(%struct.snd_pcm_hw_params* %p, i32 11)
  %min = getelementptr inbounds %struct.snd_interval, %struct.snd_interval* %call, i32 0, i32 0
  %0 = load i32, i32* %min, align 4, !tbaa !182
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @params_buffer_bytes(%struct.snd_pcm_hw_params* %p) #3 {
entry:
  %call = call %struct.snd_interval* @hw_param_interval_c(%struct.snd_pcm_hw_params* %p, i32 18)
  %min = getelementptr inbounds %struct.snd_interval, %struct.snd_interval* %call, i32 0, i32 0
  %0 = load i32, i32* %min, align 4, !tbaa !182
  ret i32 %0
}

declare i32 @snd_pcm_lib_malloc_pages(%struct.snd_pcm_substream*, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @params_channels(%struct.snd_pcm_hw_params* %p) #3 {
entry:
  %call = call %struct.snd_interval* @hw_param_interval_c(%struct.snd_pcm_hw_params* %p, i32 10)
  %min = getelementptr inbounds %struct.snd_interval, %struct.snd_interval* %call, i32 0, i32 0
  %0 = load i32, i32* %min, align 4, !tbaa !182
  ret i32 %0
}

declare i32 @snd_ac97_pcm_open(%struct.ac97_pcm*, i32, i32, i16 zeroext) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.snd_interval* @hw_param_interval_c(%struct.snd_pcm_hw_params* %params, i32 %var) #3 {
entry:
  %intervals = getelementptr inbounds %struct.snd_pcm_hw_params, %struct.snd_pcm_hw_params* %params, i32 0, i32 3
  %sub = sub nsw i32 %var, 8
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [12 x %struct.snd_interval], [12 x %struct.snd_interval]* %intervals, i64 0, i64 %idxprom
  ret %struct.snd_interval* %arrayidx
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_mic_open(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 2
  %call = call i32 @snd_intel8x0_pcm_open(%struct.snd_pcm_substream* %substream, %struct.ichdev* %arrayidx)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_mic_close(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 2
  %substream1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 4
  store %struct.snd_pcm_substream* null, %struct.snd_pcm_substream** %substream1, align 8, !tbaa !56
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_capture_open(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 0
  %call = call i32 @snd_intel8x0_pcm_open(%struct.snd_pcm_substream* %substream, %struct.ichdev* %arrayidx)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_capture_close(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 0
  %substream1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 4
  store %struct.snd_pcm_substream* null, %struct.snd_pcm_substream** %substream1, align 8, !tbaa !56
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_playback_close(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 1
  %substream1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 4
  store %struct.snd_pcm_substream* null, %struct.snd_pcm_substream** %substream1, align 8, !tbaa !56
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_spdif_open(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 0
  %2 = load i32, i32* %device_type, align 8, !tbaa !59
  %cmp = icmp eq i32 %2, 4
  %cond = select i1 %cmp, i32 3, i32 5
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %idxprom = sext i32 %cond to i64
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 %idxprom
  %call = call i32 @snd_intel8x0_pcm_open(%struct.snd_pcm_substream* %substream, %struct.ichdev* %arrayidx)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_spdif_close(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 0
  %2 = load i32, i32* %device_type, align 8, !tbaa !59
  %cmp = icmp eq i32 %2, 4
  %cond = select i1 %cmp, i32 3, i32 5
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %idxprom = sext i32 %cond to i64
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 %idxprom
  %substream1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 4
  store %struct.snd_pcm_substream* null, %struct.snd_pcm_substream** %substream1, align 8, !tbaa !56
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_pcm_trigger(%struct.snd_pcm_substream* %substream, i32 %cmd) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %runtime = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 11
  %2 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime, align 8, !tbaa !64
  %private_data1 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 43
  %3 = load i8*, i8** %private_data1, align 8, !tbaa !173
  %4 = bitcast i8* %3 to %struct.ichdev*
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 1
  %5 = load i64, i64* %reg_offset, align 8, !tbaa !62
  %Pivot12 = icmp slt i32 %cmd, 4
  br i1 %Pivot12, label %NodeBlock3, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %cmd, 5
  br i1 %Pivot10, label %sw.bb2, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %cmd, 6
  br i1 %Pivot8, label %sw.bb3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %cmd, 6
  br i1 %SwitchLeaf6, label %sw.bb, label %cleanup

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %cmd, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %cmd, 3
  br i1 %Pivot, label %LeafBlock1, label %sw.epilog

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, 1
  br i1 %SwitchLeaf2, label %sw.bb2, label %cleanup

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %cmd, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %cleanup

sw.bb:                                            ; preds = %LeafBlock5
  %suspended = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load = load i8, i8* %suspended, align 4
  %bf.clear = and i8 %bf.load, -3
  store i8 %bf.clear, i8* %suspended, align 4
  br label %sw.bb2

sw.bb2:                                           ; preds = %sw.bb, %LeafBlock1, %NodeBlock9
  %position = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 9
  %6 = load i32, i32* %position, align 8, !tbaa !92
  %last_pos = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 11
  store i32 %6, i32* %last_pos, align 8, !tbaa !178
  br label %sw.epilog

sw.bb3:                                           ; preds = %NodeBlock7
  %suspended4 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load5 = load i8, i8* %suspended4, align 4
  %bf.clear6 = and i8 %bf.load5, -3
  %bf.set = or i8 %bf.clear6, 2
  store i8 %bf.set, i8* %suspended4, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb3, %sw.bb2, %LeafBlock, %NodeBlock
  %val.0 = phi i8 [ 17, %sw.bb2 ], [ 0, %LeafBlock ], [ 0, %sw.bb3 ], [ 16, %NodeBlock ]
  %add = add i64 %5, 11
  %conv = trunc i64 %add to i32
  call void @iputbyte(%struct.intel8x0* %1, i32 %conv, i8 zeroext %val.0)
  %cmp = icmp eq i32 %cmd, 0
  br i1 %cmp, label %if.then, label %cleanup

if.then:                                          ; preds = %sw.epilog
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %roff_sr = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 19
  %7 = load i32, i32* %roff_sr, align 8, !tbaa !74
  %conv10 = zext i32 %7 to i64
  %add11 = add i64 %5, %conv10
  %conv12 = trunc i64 %add11 to i32
  %call = call zeroext i8 @igetbyte(%struct.intel8x0* %1, i32 %conv12)
  %conv13 = zext i8 %call to i32
  %and = and i32 %conv13, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %add14 = add i64 %5, 11
  %conv15 = trunc i64 %add14 to i32
  call void @iputbyte(%struct.intel8x0* %1, i32 %conv15, i8 zeroext 2)
  br label %cleanup

cleanup:                                          ; preds = %while.end, %sw.epilog, %LeafBlock, %LeafBlock1, %LeafBlock5
  %retval.0 = phi i32 [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -22, %LeafBlock5 ], [ 0, %while.end ], [ 0, %sw.epilog ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_capture2_open(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 4
  %call = call i32 @snd_intel8x0_pcm_open(%struct.snd_pcm_substream* %substream, %struct.ichdev* %arrayidx)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_capture2_close(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 4
  %substream1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 4
  store %struct.snd_pcm_substream* null, %struct.snd_pcm_substream** %substream1, align 8, !tbaa !56
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_mic2_open(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 3
  %call = call i32 @snd_intel8x0_pcm_open(%struct.snd_pcm_substream* %substream, %struct.ichdev* %arrayidx)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_mic2_close(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 3
  %substream1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 4
  store %struct.snd_pcm_substream* null, %struct.snd_pcm_substream** %substream1, align 8, !tbaa !56
  ret i32 0
}

declare i8* @__memset(i8*, i32, i64) #1

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_mixer_free_ac97(%struct.snd_ac97* %ac97) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 1
  %0 = load i8*, i8** %private_data, align 8, !tbaa !184
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ac971 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 13
  %num = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %2 = load i16, i16* %num, align 8, !tbaa !127
  %idxprom = zext i16 %2 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac971, i64 0, i64 %idxprom
  store %struct.snd_ac97* null, %struct.snd_ac97** %arrayidx, align 8, !tbaa !6
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_codec_read_test(%struct.intel8x0* %chip, i32 %codec) #2 {
entry:
  %call = call i32 @snd_intel8x0_codec_semaphore(%struct.intel8x0* %chip, i32 %codec)
  %cmp = icmp sge i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %mul = mul i32 %codec, 128
  %call1 = call zeroext i16 @iagetword(%struct.intel8x0* %chip, i32 %mul)
  %call2 = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  %and = and i32 %call2, 32768
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.then
  %codec_ready_bits = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 19
  %0 = load i32, i32* %codec_ready_bits, align 4, !tbaa !185
  %or = or i32 %0, 1
  %neg = xor i32 %or, -1
  %and4 = and i32 %call2, %neg
  call void @iputdword(%struct.intel8x0* %chip, i32 48, i32 %and4)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.then, %entry
  ret void
}

declare i32 @snd_ac97_bus(%struct.snd_card*, i32, %struct.snd_ac97_bus_ops*, i8*, %struct.snd_ac97_bus**) #1

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_mixer_free_ac97_bus(%struct.snd_ac97_bus* %bus) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %bus, i32 0, i32 1
  %0 = load i8*, i8** %private_data, align 8, !tbaa !186
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ac97_bus = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 12
  store %struct.snd_ac97_bus* null, %struct.snd_ac97_bus** %ac97_bus, align 8, !tbaa !122
  ret void
}

declare i32 @snd_ac97_mixer(%struct.snd_ac97_bus*, %struct.snd_ac97_template*, %struct.snd_ac97**) #1

declare i32 @snd_ac97_tune_hardware(%struct.snd_ac97*, %struct.ac97_quirk*, i8*) #1

declare i32 @snd_ac97_pcm_assign(%struct.snd_ac97_bus*, i16 zeroext, %struct.ac97_pcm*) #1

declare i32 @snd_ac97_update_bits(%struct.snd_ac97*, i16 zeroext, i16 zeroext, i16 zeroext) #1

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_ali_codec_write(%struct.snd_ac97* %ac97, i16 zeroext %reg, i16 zeroext %val) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 1
  %0 = load i8*, i8** %private_data, align 8, !tbaa !184
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %call = call i32 @snd_intel8x0_ali_codec_semaphore(%struct.intel8x0* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  call void @iputword(%struct.intel8x0* %1, i32 32, i16 zeroext %val)
  %num = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %2 = load i16, i16* %num, align 8, !tbaa !127
  %tobool1 = icmp ne i16 %2, 0
  %conv = zext i16 %reg to i32
  %or = or i32 %conv, 256
  %conv3 = trunc i32 %or to i16
  %reg.addr.0 = select i1 %tobool1, i16 %conv3, i16 %reg
  call void @iputword(%struct.intel8x0* %1, i32 34, i16 zeroext %reg.addr.0)
  %call5 = call i32 @snd_intel8x0_ali_codec_ready(%struct.intel8x0* %1, i32 1)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @snd_intel8x0_ali_codec_read(%struct.snd_ac97* %ac97, i16 zeroext %reg) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 1
  %0 = load i8*, i8** %private_data, align 8, !tbaa !184
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %call = call i32 @snd_intel8x0_ali_codec_semaphore(%struct.intel8x0* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %__err, label %if.end

if.end:                                           ; preds = %entry
  %conv = zext i16 %reg to i32
  %or = or i32 %conv, 128
  %conv1 = trunc i32 %or to i16
  %num = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %2 = load i16, i16* %num, align 8, !tbaa !127
  %tobool2 = icmp ne i16 %2, 0
  %conv4 = zext i16 %conv1 to i32
  %or5 = or i32 %conv4, 256
  %conv6 = trunc i32 %or5 to i16
  %reg.addr.0 = select i1 %tobool2, i16 %conv6, i16 %conv1
  call void @iputword(%struct.intel8x0* %1, i32 34, i16 zeroext %reg.addr.0)
  %call8 = call i32 @snd_intel8x0_ali_codec_ready(%struct.intel8x0* %1, i32 2)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %__err, label %if.end11

if.end11:                                         ; preds = %if.end
  %call12 = call zeroext i16 @igetword(%struct.intel8x0* %1, i32 36)
  br label %__err

__err:                                            ; preds = %if.end11, %if.end, %entry
  %data.0 = phi i16 [ %call12, %if.end11 ], [ -1, %entry ], [ -1, %if.end ]
  ret i16 %data.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ali_codec_semaphore(%struct.intel8x0* %chip) #2 {
entry:
  %buggy_semaphore = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load = load i16, i16* %buggy_semaphore, align 8
  %bf.lshr = lshr i16 %bf.load, 11
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %time.0 = phi i32 [ 100, %if.end ], [ %dec, %while.body ]
  %dec = add nsw i32 %time.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %land.lhs.true, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %call = call i32 @igetdword(%struct.intel8x0* %chip, i32 60)
  %and = and i32 %call, -2147483648
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool3 = icmp ne i32 %dec, 0
  br i1 %tobool3, label %if.end10, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.end, %while.cond
  %in_ac97_init = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load4 = load i16, i16* %in_ac97_init, align 8
  %bf.lshr5 = lshr i16 %bf.load4, 5
  %bf.clear6 = and i16 %bf.lshr5, 1
  %bf.cast7 = zext i16 %bf.clear6 to i32
  %tobool8 = icmp ne i32 %bf.cast7, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %land.lhs.true
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %land.lhs.true, %while.end
  %call11 = call i32 @snd_intel8x0_ali_codec_ready(%struct.intel8x0* %chip, i32 8)
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %entry
  %retval.0 = phi i32 [ %call11, %if.end10 ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ali_codec_ready(%struct.intel8x0* %chip, i32 %mask) #2 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %count.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %retval.0 = phi i32 [ undef, %entry ], [ %.retval.0, %for.inc ]
  %cmp = icmp slt i32 %count.0, 127
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 56)
  %conv = zext i8 %call to i32
  %and = and i32 %conv, %mask
  %tobool = icmp ne i32 %and, 0
  %. = select i1 %tobool, i32 1, i32 0
  %.retval.0 = select i1 %tobool, i32 0, i32 %retval.0
  %SwitchLeaf = icmp eq i32 %., 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup4

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %count.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %in_ac97_init = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load = load i16, i16* %in_ac97_init, align 8
  %bf.lshr = lshr i16 %bf.load, 5
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool1 = icmp ne i32 %bf.cast, 0
  br i1 %tobool1, label %cleanup4, label %if.then2

if.then2:                                         ; preds = %for.end
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup4

cleanup4:                                         ; preds = %if.then2, %for.end, %for.body
  %retval.2 = phi i32 [ -16, %if.then2 ], [ -16, %for.end ], [ %.retval.0, %for.body ]
  ret i32 %retval.2
}

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_codec_write(%struct.snd_ac97* %ac97, i16 zeroext %reg, i16 zeroext %val) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 1
  %0 = load i8*, i8** %private_data, align 8, !tbaa !184
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %num = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %2 = load i16, i16* %num, align 8, !tbaa !127
  %conv = zext i16 %2 to i32
  %call = call i32 @snd_intel8x0_codec_semaphore(%struct.intel8x0* %1, i32 %conv)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %in_ac97_init = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load = load i16, i16* %in_ac97_init, align 8
  %bf.lshr = lshr i16 %bf.load, 5
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end6, label %if.then2

if.then2:                                         ; preds = %if.then
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end6

if.end6:                                          ; preds = %if.then2, %if.then, %entry
  %conv7 = zext i16 %reg to i32
  %num8 = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %3 = load i16, i16* %num8, align 8, !tbaa !127
  %conv9 = zext i16 %3 to i32
  %mul = mul nsw i32 %conv9, 128
  %add = add nsw i32 %conv7, %mul
  call void @iaputword(%struct.intel8x0* %1, i32 %add, i16 zeroext %val)
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @snd_intel8x0_codec_read(%struct.snd_ac97* %ac97, i16 zeroext %reg) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 1
  %0 = load i8*, i8** %private_data, align 8, !tbaa !184
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %num = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %2 = load i16, i16* %num, align 8, !tbaa !127
  %conv = zext i16 %2 to i32
  %call = call i32 @snd_intel8x0_codec_semaphore(%struct.intel8x0* %1, i32 %conv)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %in_ac97_init = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load = load i16, i16* %in_ac97_init, align 8
  %bf.lshr = lshr i16 %bf.load, 5
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end28, label %if.then2

if.then2:                                         ; preds = %if.then
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end28

if.else:                                          ; preds = %entry
  %conv6 = zext i16 %reg to i32
  %num7 = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %3 = load i16, i16* %num7, align 8, !tbaa !127
  %conv8 = zext i16 %3 to i32
  %mul = mul nsw i32 %conv8, 128
  %add = add nsw i32 %conv6, %mul
  %call9 = call zeroext i16 @iagetword(%struct.intel8x0* %1, i32 %add)
  %call10 = call i32 @igetdword(%struct.intel8x0* %1, i32 48)
  %and = and i32 %call10, 32768
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %if.then12, label %if.end28

if.then12:                                        ; preds = %if.else
  %codec_ready_bits = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 19
  %4 = load i32, i32* %codec_ready_bits, align 4, !tbaa !185
  %or = or i32 %4, 1
  %neg = xor i32 %or, -1
  %and13 = and i32 %call10, %neg
  call void @iputdword(%struct.intel8x0* %1, i32 48, i32 %and13)
  %in_ac97_init14 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load15 = load i16, i16* %in_ac97_init14, align 8
  %bf.lshr16 = lshr i16 %bf.load15, 5
  %bf.clear17 = and i16 %bf.lshr16, 1
  %bf.cast18 = zext i16 %bf.clear17 to i32
  %tobool19 = icmp ne i32 %bf.cast18, 0
  br i1 %tobool19, label %if.end28, label %if.then20

if.then20:                                        ; preds = %if.then12
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %if.end28

if.end28:                                         ; preds = %if.then20, %if.then12, %if.else, %if.then2, %if.then
  %res.1 = phi i16 [ -1, %if.then2 ], [ -1, %if.then ], [ %call9, %if.else ], [ -1, %if.then20 ], [ -1, %if.then12 ]
  ret i16 %res.1
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_codec_semaphore(%struct.intel8x0* %chip, i32 %codec) #2 {
entry:
  %cmp = icmp ugt i32 %codec, 2
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %in_sdin_init = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load = load i16, i16* %in_sdin_init, align 8
  %bf.lshr = lshr i16 %bf.load, 6
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %codec_isr_bits = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 18
  %0 = load i32, i32* %codec_isr_bits, align 8, !tbaa !102
  br label %if.end4

if.else:                                          ; preds = %if.end
  %codec_bit = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 17
  %1 = load i32*, i32** %codec_bit, align 8, !tbaa !103
  %ac97_sdin = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 14
  %idxprom = zext i32 %codec to i64
  %arrayidx = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin, i64 0, i64 %idxprom
  %2 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %idxprom2 = zext i32 %2 to i64
  %arrayidx3 = getelementptr inbounds i32, i32* %1, i64 %idxprom2
  %3 = load i32, i32* %arrayidx3, align 4, !tbaa !2
  br label %if.end4

if.end4:                                          ; preds = %if.else, %if.then1
  %codec.addr.0 = phi i32 [ %0, %if.then1 ], [ %3, %if.else ]
  %call = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  %and = and i32 %call, %codec.addr.0
  %cmp5 = icmp eq i32 %and, 0
  br i1 %cmp5, label %cleanup, label %if.end7

if.end7:                                          ; preds = %if.end4
  %buggy_semaphore = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load8 = load i16, i16* %buggy_semaphore, align 8
  %bf.lshr9 = lshr i16 %bf.load8, 11
  %bf.clear10 = and i16 %bf.lshr9, 1
  %bf.cast11 = zext i16 %bf.clear10 to i32
  %tobool12 = icmp ne i32 %bf.cast11, 0
  br i1 %tobool12, label %cleanup, label %if.end14

if.end14:                                         ; preds = %if.end7
  br label %do.body

do.body:                                          ; preds = %if.end19, %if.end14
  %time.0 = phi i32 [ 100, %if.end14 ], [ %dec, %if.end19 ]
  %call15 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 52)
  %conv = zext i8 %call15 to i32
  %and16 = and i32 %conv, 1
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %if.end19, label %cleanup

if.end19:                                         ; preds = %do.body
  call void @__const_udelay(i64 42950)
  %dec = add nsw i32 %time.0, -1
  %tobool20 = icmp ne i32 %time.0, 0
  br i1 %tobool20, label %do.body, label %do.end

do.end:                                           ; preds = %if.end19
  %call21 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 52)
  %call23 = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %call24 = call zeroext i16 @iagetword(%struct.intel8x0* %chip, i32 0)
  br label %cleanup

cleanup:                                          ; preds = %do.end, %do.body, %if.end7, %if.end4, %entry
  %retval.0 = phi i32 [ -16, %do.end ], [ -5, %entry ], [ -5, %if.end4 ], [ 0, %if.end7 ], [ 0, %do.body ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @iaputword(%struct.intel8x0* %chip, i32 %offset, i16 zeroext %val) #3 {
entry:
  %addr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 2
  %0 = load i8*, i8** %addr, align 8, !tbaa !104
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  call void @iowrite16(i16 zeroext %val, i8* %add.ptr)
  ret void
}

declare i32 @pci_enable_device(%struct.pci_dev*) #1

; Function Attrs: inlinehint nounwind uwtable
declare i8* @kzalloc(i64, i32) #3

declare void @pci_disable_device(%struct.pci_dev*) #1

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #1

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_inside_vm(%struct.pci_dev* %pci) #2 {
entry:
  %0 = load i32, i32* @inside_vm, align 4, !tbaa !2
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %tobool = icmp ne i32 %0, 0
  %cond = select i1 %tobool, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.38, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.39, i32 0, i32 0)
  br label %fini

if.end:                                           ; preds = %entry
  %subsystem_vendor = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pci, i32 0, i32 9
  %1 = load i16, i16* %subsystem_vendor, align 8, !tbaa !187
  %conv = zext i16 %1 to i32
  %cmp1 = icmp eq i32 %conv, 6900
  br i1 %cmp1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %subsystem_device = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pci, i32 0, i32 10
  %2 = load i16, i16* %subsystem_device, align 2, !tbaa !188
  %conv3 = zext i16 %2 to i32
  %cmp4 = icmp eq i32 %conv3, 4352
  br i1 %cmp4, label %fini, label %if.else

if.else:                                          ; preds = %land.lhs.true, %if.end
  %subsystem_vendor7 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pci, i32 0, i32 9
  %3 = load i16, i16* %subsystem_vendor7, align 8, !tbaa !187
  %conv8 = zext i16 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 6840
  %.1 = select i1 %cmp9, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.41, i32 0, i32 0), i8* null
  br label %fini

fini:                                             ; preds = %if.else, %land.lhs.true, %if.then
  %msg.2 = phi i8* [ %cond, %if.then ], [ %.1, %if.else ], [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.40, i32 0, i32 0), %land.lhs.true ]
  %cmp14 = icmp ne i8* %msg.2, null
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %fini
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %fini
  ret void
}

declare i32 @pci_request_regions(%struct.pci_dev*, i8*) #1

declare void @kfree(i8*) #1

declare i8* @pci_iomap(%struct.pci_dev*, i32, i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_free(%struct.intel8x0* %chip) #2 {
entry:
  %val = alloca i32, align 4
  %irq = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 1
  %0 = load i32, i32* %irq, align 4, !tbaa !50
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %__hw_end, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %bdbars_count = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 21
  %1 = load i32, i32* %bdbars_count, align 8, !tbaa !55
  %cmp1 = icmp ult i32 %i.0, %1
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 %idxprom
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 1
  %2 = load i64, i64* %reg_offset, align 8, !tbaa !62
  %add = add i64 11, %2
  %conv = trunc i64 %add to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv, i8 zeroext 0)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond2

for.cond2:                                        ; preds = %for.body6, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc14, %for.body6 ]
  %bdbars_count3 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 21
  %3 = load i32, i32* %bdbars_count3, align 8, !tbaa !55
  %cmp4 = icmp ult i32 %i.1, %3
  br i1 %cmp4, label %for.body6, label %for.end15

for.body6:                                        ; preds = %for.cond2
  %ichd7 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %idxprom8 = zext i32 %i.1 to i64
  %arrayidx9 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd7, i64 0, i64 %idxprom8
  %reg_offset10 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx9, i32 0, i32 1
  %4 = load i64, i64* %reg_offset10, align 8, !tbaa !62
  %add11 = add i64 11, %4
  %conv12 = trunc i64 %add11 to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv12, i8 zeroext 2)
  %inc14 = add i32 %i.1, 1
  br label %for.cond2

for.end15:                                        ; preds = %for.cond2
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %5 = load i32, i32* %device_type, align 8, !tbaa !59
  %cmp16 = icmp ne i32 %5, 4
  %6 = load i32, i32* @spdif_aclink, align 4
  %tobool = icmp ne i32 %6, 0
  %or.cond = or i1 %cmp16, %tobool
  br i1 %or.cond, label %__hw_end, label %if.then18

if.then18:                                        ; preds = %for.end15
  %pci = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %7 = load %struct.pci_dev*, %struct.pci_dev** %pci, align 8, !tbaa !100
  call void @pci_read_config_dword(%struct.pci_dev* %7, i32 76, i32* %val)
  %8 = load i32, i32* %val, align 4, !tbaa !2
  %and = and i32 %8, -16777217
  store i32 %and, i32* %val, align 4, !tbaa !2
  %pci19 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %9 = load %struct.pci_dev*, %struct.pci_dev** %pci19, align 8, !tbaa !100
  %10 = load i32, i32* %val, align 4, !tbaa !2
  call void @pci_write_config_dword(%struct.pci_dev* %9, i32 76, i32 %10)
  br label %__hw_end

__hw_end:                                         ; preds = %if.then18, %for.end15, %entry
  %irq22 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 1
  %11 = load i32, i32* %irq22, align 4, !tbaa !50
  %cmp23 = icmp sge i32 %11, 0
  br i1 %cmp23, label %if.then25, label %if.end27

if.then25:                                        ; preds = %__hw_end
  %irq26 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 1
  %12 = load i32, i32* %irq26, align 4, !tbaa !50
  %13 = bitcast %struct.intel8x0* %chip to i8*
  call void @free_irq(i32 %12, i8* %13)
  br label %if.end27

if.end27:                                         ; preds = %if.then25, %__hw_end
  %bdbars = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 22
  %area = getelementptr inbounds %struct.snd_dma_buffer, %struct.snd_dma_buffer* %bdbars, i32 0, i32 1
  %14 = load i8*, i8** %area, align 8, !tbaa !189
  %tobool28 = icmp ne i8* %14, null
  br i1 %tobool28, label %if.then29, label %if.end34

if.then29:                                        ; preds = %if.end27
  %bdbars33 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 22
  call void @snd_dma_free_pages(%struct.snd_dma_buffer* %bdbars33)
  br label %if.end34

if.end34:                                         ; preds = %if.then29, %if.end27
  %addr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 2
  %15 = load i8*, i8** %addr, align 8, !tbaa !104
  %tobool35 = icmp ne i8* %15, null
  br i1 %tobool35, label %if.then36, label %if.end39

if.then36:                                        ; preds = %if.end34
  %pci37 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %16 = load %struct.pci_dev*, %struct.pci_dev** %pci37, align 8, !tbaa !100
  %addr38 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 2
  %17 = load i8*, i8** %addr38, align 8, !tbaa !104
  call void @pci_iounmap(%struct.pci_dev* %16, i8* %17)
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %if.end34
  %bmaddr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 3
  %18 = load i8*, i8** %bmaddr, align 8, !tbaa !79
  %tobool40 = icmp ne i8* %18, null
  br i1 %tobool40, label %if.then41, label %if.end44

if.then41:                                        ; preds = %if.end39
  %pci42 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %19 = load %struct.pci_dev*, %struct.pci_dev** %pci42, align 8, !tbaa !100
  %bmaddr43 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 3
  %20 = load i8*, i8** %bmaddr43, align 8, !tbaa !79
  call void @pci_iounmap(%struct.pci_dev* %19, i8* %20)
  br label %if.end44

if.end44:                                         ; preds = %if.then41, %if.end39
  %pci45 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %21 = load %struct.pci_dev*, %struct.pci_dev** %pci45, align 8, !tbaa !100
  call void @pci_release_regions(%struct.pci_dev* %21)
  %pci46 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %22 = load %struct.pci_dev*, %struct.pci_dev** %pci46, align 8, !tbaa !100
  call void @pci_disable_device(%struct.pci_dev* %22)
  %23 = bitcast %struct.intel8x0* %chip to i8*
  call void @kfree(i8* %23)
  ret i32 0
}

declare i32 @snd_dma_alloc_pages(i32, %struct.device*, i64, %struct.snd_dma_buffer*) #1

declare void @pci_set_master(%struct.pci_dev*) #1

declare i32 @snd_device_new(%struct.snd_card*, i32, i8*, %struct.snd_device_ops*) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_dev_free(%struct.snd_device* %device) #2 {
entry:
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !190
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %call = call i32 @snd_intel8x0_free(%struct.intel8x0* %1)
  ret i32 %call
}

declare void @snd_dma_free_pages(%struct.snd_dma_buffer*) #1

declare void @pci_iounmap(%struct.pci_dev*, i8*) #1

declare void @pci_release_regions(%struct.pci_dev*) #1

declare noalias i8* @__kmalloc(i64, i32) #1

declare void @__dynamic_dev_dbg(%struct._ddebug*, %struct.device*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal void @intel8x0_driver_exit() #0 section ".exit.text" {
entry:
  call void @pci_unregister_driver(%struct.pci_driver* @intel8x0_driver)
  ret void
}

declare void @pci_unregister_driver(%struct.pci_driver*) #1

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind }
attributes #5 = { nounwind readnone }
attributes #6 = { nounwind }

!llvm.ident = !{!0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{!3, !3, i64 0}
!3 = !{!"int", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!7, !7, i64 0}
!7 = !{!"any pointer", !4, i64 0}
!8 = !{!9, !10, i64 24}
!9 = !{!"pci_device_id", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !3, i64 20, !10, i64 24}
!10 = !{!"long", !4, i64 0}
!11 = !{!12, !3, i64 0}
!12 = !{!"shortname_table", !3, i64 0, !7, i64 8}
!13 = !{!14, !16, i64 62}
!14 = !{!"pci_dev", !15, i64 0, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !3, i64 56, !16, i64 60, !16, i64 62, !16, i64 64, !16, i64 66, !3, i64 68, !4, i64 72, !4, i64 73, !16, i64 74, !4, i64 76, !4, i64 77, !4, i64 78, !4, i64 79, !4, i64 80, !4, i64 81, !16, i64 82, !7, i64 88, !7, i64 96, !17, i64 104, !18, i64 112, !3, i64 128, !4, i64 132, !3, i64 133, !3, i64 133, !3, i64 133, !3, i64 133, !3, i64 134, !3, i64 134, !3, i64 134, !3, i64 134, !3, i64 134, !3, i64 134, !3, i64 134, !3, i64 134, !3, i64 135, !3, i64 135, !3, i64 136, !3, i64 140, !7, i64 144, !3, i64 152, !19, i64 160, !3, i64 1584, !3, i64 1588, !4, i64 1592, !36, i64 2680, !3, i64 2681, !3, i64 2681, !3, i64 2681, !3, i64 2681, !3, i64 2681, !3, i64 2681, !3, i64 2681, !3, i64 2681, !3, i64 2682, !3, i64 2682, !3, i64 2682, !3, i64 2682, !3, i64 2682, !3, i64 2682, !3, i64 2682, !3, i64 2683, !3, i64 2683, !3, i64 2683, !3, i64 2683, !3, i64 2683, !3, i64 2683, !3, i64 2683, !3, i64 2683, !3, i64 2684, !3, i64 2684, !3, i64 2684, !3, i64 2684, !16, i64 2686, !23, i64 2688, !4, i64 2692, !41, i64 2760, !7, i64 2768, !3, i64 2776, !4, i64 2784, !4, i64 2920, !3, i64 3056, !3, i64 3056, !4, i64 3057, !7, i64 3064, !7, i64 3072, !4, i64 3080, !16, i64 3088, !4, i64 3090, !23, i64 3092, !17, i64 3096, !10, i64 3104, !7, i64 3112}
!15 = !{!"list_head", !7, i64 0, !7, i64 8}
!16 = !{!"short", !4, i64 0}
!17 = !{!"long long", !4, i64 0}
!18 = !{!"device_dma_parameters", !3, i64 0, !10, i64 8}
!19 = !{!"device", !7, i64 0, !7, i64 8, !20, i64 16, !7, i64 280, !7, i64 288, !30, i64 296, !7, i64 456, !7, i64 464, !7, i64 472, !7, i64 480, !33, i64 488, !34, i64 528, !7, i64 1104, !7, i64 1112, !7, i64 1120, !15, i64 1128, !3, i64 1144, !7, i64 1152, !7, i64 1160, !17, i64 1168, !10, i64 1176, !7, i64 1184, !15, i64 1192, !7, i64 1208, !7, i64 1216, !39, i64 1224, !7, i64 1232, !7, i64 1240, !3, i64 1248, !3, i64 1252, !31, i64 1256, !15, i64 1328, !40, i64 1344, !7, i64 1376, !7, i64 1384, !7, i64 1392, !7, i64 1400, !7, i64 1408, !36, i64 1416, !36, i64 1416}
!20 = !{!"kobject", !7, i64 0, !15, i64 8, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !21, i64 56, !24, i64 64, !3, i64 256, !3, i64 256, !3, i64 256, !3, i64 256, !3, i64 256}
!21 = !{!"kref", !22, i64 0}
!22 = !{!"refcount_struct", !23, i64 0}
!23 = !{!"", !3, i64 0}
!24 = !{!"delayed_work", !25, i64 0, !28, i64 80, !7, i64 176, !3, i64 184}
!25 = !{!"work_struct", !26, i64 0, !15, i64 8, !7, i64 24, !27, i64 32}
!26 = !{!"", !10, i64 0}
!27 = !{!"lockdep_map", !7, i64 0, !4, i64 8, !7, i64 24, !3, i64 32, !10, i64 40}
!28 = !{!"timer_list", !29, i64 0, !10, i64 16, !7, i64 24, !10, i64 32, !3, i64 40, !27, i64 48}
!29 = !{!"hlist_node", !7, i64 0, !7, i64 8}
!30 = !{!"mutex", !26, i64 0, !31, i64 8, !32, i64 80, !15, i64 88, !7, i64 104, !27, i64 112}
!31 = !{!"spinlock", !4, i64 0}
!32 = !{!"optimistic_spin_queue", !23, i64 0}
!33 = !{!"dev_links_info", !15, i64 0, !15, i64 16, !4, i64 32}
!34 = !{!"dev_pm_info", !35, i64 0, !3, i64 4, !3, i64 4, !36, i64 4, !36, i64 4, !36, i64 4, !36, i64 4, !36, i64 4, !36, i64 4, !36, i64 5, !31, i64 8, !15, i64 80, !37, i64 96, !7, i64 192, !36, i64 200, !36, i64 200, !36, i64 200, !28, i64 208, !10, i64 304, !25, i64 312, !38, i64 392, !7, i64 480, !23, i64 488, !23, i64 492, !3, i64 496, !3, i64 496, !3, i64 496, !3, i64 496, !3, i64 496, !3, i64 496, !36, i64 497, !3, i64 497, !3, i64 497, !3, i64 497, !3, i64 497, !3, i64 497, !3, i64 500, !4, i64 504, !4, i64 508, !3, i64 512, !3, i64 516, !10, i64 520, !10, i64 528, !10, i64 536, !10, i64 544, !7, i64 552, !7, i64 560, !7, i64 568}
!35 = !{!"pm_message", !3, i64 0}
!36 = !{!"_Bool", !4, i64 0}
!37 = !{!"completion", !3, i64 0, !38, i64 8}
!38 = !{!"__wait_queue_head", !31, i64 0, !15, i64 72}
!39 = !{!"dev_archdata", !7, i64 0}
!40 = !{!"klist_node", !7, i64 0, !15, i64 8, !21, i64 24}
!41 = !{!"hlist_head", !7, i64 0}
!42 = !{!12, !7, i64 8}
!43 = !{!44, !7, i64 400}
!44 = !{!"snd_card", !3, i64 0, !4, i64 4, !4, i64 20, !4, i64 36, !4, i64 68, !4, i64 148, !4, i64 180, !4, i64 260, !7, i64 392, !7, i64 400, !7, i64 408, !15, i64 416, !19, i64 432, !3, i64 1856, !45, i64 1864, !48, i64 2024, !3, i64 2096, !3, i64 2100, !15, i64 2104, !15, i64 2120, !30, i64 2136, !7, i64 2296, !7, i64 2304, !7, i64 2312, !15, i64 2320, !7, i64 2336, !31, i64 2344, !3, i64 2416, !7, i64 2424, !7, i64 2432, !19, i64 2440, !4, i64 3864, !36, i64 3896, !3, i64 3900, !30, i64 3904, !38, i64 4064, !7, i64 4152, !3, i64 4160}
!45 = !{!"rw_semaphore", !26, i64 0, !15, i64 8, !46, i64 24, !32, i64 96, !7, i64 104, !27, i64 112}
!46 = !{!"raw_spinlock", !47, i64 0, !3, i64 4, !3, i64 8, !7, i64 16, !27, i64 24}
!47 = !{!"qspinlock", !23, i64 0}
!48 = !{!"", !49, i64 0, !3, i64 8, !3, i64 12, !7, i64 16, !27, i64 24}
!49 = !{!"qrwlock", !23, i64 0, !47, i64 4}
!50 = !{!51, !3, i64 4}
!51 = !{!"intel8x0", !3, i64 0, !3, i64 4, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !3, i64 40, !4, i64 48, !4, i64 96, !3, i64 864, !3, i64 864, !3, i64 864, !3, i64 864, !3, i64 864, !3, i64 864, !3, i64 864, !3, i64 864, !3, i64 865, !3, i64 865, !3, i64 865, !3, i64 865, !3, i64 865, !3, i64 868, !3, i64 872, !7, i64 880, !4, i64 888, !4, i64 912, !3, i64 924, !3, i64 928, !7, i64 936, !3, i64 944, !3, i64 948, !31, i64 952, !3, i64 1024, !52, i64 1032, !3, i64 1080, !3, i64 1084}
!52 = !{!"snd_dma_buffer", !53, i64 0, !7, i64 16, !17, i64 24, !10, i64 32, !7, i64 40}
!53 = !{!"snd_dma_device", !3, i64 0, !7, i64 8}
!54 = !{!51, !3, i64 40}
!55 = !{!51, !3, i64 1024}
!56 = !{!57, !7, i64 32}
!57 = !{!"ichdev", !3, i64 0, !10, i64 8, !7, i64 16, !3, i64 24, !7, i64 32, !3, i64 40, !3, i64 44, !3, i64 48, !3, i64 52, !3, i64 56, !3, i64 60, !3, i64 64, !3, i64 68, !3, i64 72, !3, i64 76, !3, i64 80, !3, i64 84, !3, i64 88, !3, i64 92, !3, i64 96, !3, i64 100, !3, i64 104, !3, i64 108, !7, i64 112, !3, i64 120, !3, i64 124, !3, i64 124}
!58 = !{!51, !3, i64 928}
!59 = !{!51, !3, i64 0}
!60 = !{!51, !3, i64 872}
!61 = !{!14, !3, i64 1588}
!62 = !{!57, !10, i64 8}
!63 = !{!57, !3, i64 0}
!64 = !{!65, !7, i64 376}
!65 = !{!"snd_pcm_substream", !7, i64 0, !7, i64 8, !7, i64 16, !3, i64 24, !4, i64 28, !3, i64 60, !66, i64 64, !10, i64 304, !52, i64 312, !10, i64 360, !7, i64 368, !7, i64 376, !7, i64 384, !3, i64 392, !7, i64 400, !15, i64 408, !68, i64 424, !7, i64 680, !7, i64 688, !3, i64 696, !23, i64 700, !3, i64 704, !7, i64 712, !7, i64 720, !69, i64 728, !7, i64 768, !7, i64 776, !7, i64 784, !7, i64 792, !7, i64 800, !7, i64 808, !7, i64 816, !7, i64 824, !3, i64 832}
!66 = !{!"pm_qos_request", !67, i64 0, !3, i64 40, !24, i64 48}
!67 = !{!"plist_node", !3, i64 0, !15, i64 8, !15, i64 24}
!68 = !{!"snd_pcm_group", !31, i64 0, !30, i64 72, !15, i64 232, !3, i64 248}
!69 = !{!"snd_pcm_oss_substream", !3, i64 0, !70, i64 8}
!70 = !{!"snd_pcm_oss_setup", !7, i64 0, !3, i64 8, !3, i64 8, !3, i64 8, !3, i64 8, !3, i64 8, !3, i64 8, !3, i64 8, !3, i64 12, !3, i64 16, !7, i64 24}
!71 = !{!57, !3, i64 24}
!72 = !{!57, !3, i64 72}
!73 = !{!57, !3, i64 80}
!74 = !{!57, !3, i64 96}
!75 = !{!19, !7, i64 480}
!76 = !{!51, !3, i64 1080}
!77 = !{!51, !3, i64 1084}
!78 = !{!57, !3, i64 104}
!79 = !{!51, !7, i64 16}
!80 = !{!81, !3, i64 100}
!81 = !{!"snd_pcm_runtime", !7, i64 0, !82, i64 8, !36, i64 24, !3, i64 28, !10, i64 32, !10, i64 40, !10, i64 48, !10, i64 56, !10, i64 64, !10, i64 72, !17, i64 80, !3, i64 88, !3, i64 92, !3, i64 96, !3, i64 100, !3, i64 104, !10, i64 112, !3, i64 120, !10, i64 128, !10, i64 136, !10, i64 144, !3, i64 152, !3, i64 156, !3, i64 160, !3, i64 164, !3, i64 168, !3, i64 172, !3, i64 176, !3, i64 180, !10, i64 184, !10, i64 192, !10, i64 200, !10, i64 208, !10, i64 216, !10, i64 224, !10, i64 232, !4, i64 240, !7, i64 256, !7, i64 264, !10, i64 272, !38, i64 280, !38, i64 368, !7, i64 456, !7, i64 464, !7, i64 472, !83, i64 480, !84, i64 560, !3, i64 816, !3, i64 820, !7, i64 824, !17, i64 832, !10, i64 840, !7, i64 848, !85, i64 856, !86, i64 860, !82, i64 872, !87, i64 888}
!82 = !{!"timespec", !10, i64 0, !10, i64 8}
!83 = !{!"snd_pcm_hardware", !3, i64 0, !17, i64 8, !3, i64 16, !3, i64 20, !3, i64 24, !3, i64 28, !3, i64 32, !10, i64 40, !10, i64 48, !10, i64 56, !3, i64 64, !3, i64 68, !10, i64 72}
!84 = !{!"snd_pcm_hw_constraints", !4, i64 0, !4, i64 96, !3, i64 240, !3, i64 244, !7, i64 248}
!85 = !{!"snd_pcm_audio_tstamp_config", !3, i64 0, !3, i64 0}
!86 = !{!"snd_pcm_audio_tstamp_report", !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 4}
!87 = !{!"snd_pcm_oss_runtime", !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !3, i64 20, !3, i64 24, !10, i64 32, !10, i64 40, !10, i64 48, !3, i64 56, !10, i64 64, !10, i64 72, !10, i64 80, !7, i64 88, !10, i64 96, !30, i64 104, !7, i64 264, !7, i64 272, !3, i64 280}
!88 = !{!81, !3, i64 104}
!89 = !{!81, !3, i64 156}
!90 = !{!44, !3, i64 3900}
!91 = !{!57, !3, i64 52}
!92 = !{!57, !3, i64 56}
!93 = !{!57, !3, i64 44}
!94 = !{!57, !3, i64 76}
!95 = !{!57, !3, i64 68}
!96 = !{!57, !3, i64 40}
!97 = !{!57, !7, i64 16}
!98 = !{!57, !3, i64 84}
!99 = !{!57, !3, i64 88}
!100 = !{!51, !7, i64 24}
!101 = !{!10, !10, i64 0}
!102 = !{!51, !3, i64 944}
!103 = !{!51, !7, i64 936}
!104 = !{!51, !7, i64 8}
!105 = !{!14, !7, i64 16}
!106 = !{!14, !3, i64 56}
!107 = !{!108, !3, i64 8}
!108 = !{!"snd_pci_quirk", !16, i64 0, !16, i64 2, !16, i64 4, !3, i64 8, !7, i64 16}
!109 = !{!108, !7, i64 16}
!110 = !{!36, !36, i64 0}
!111 = !{i8 0, i8 2}
!112 = !{!51, !3, i64 868}
!113 = !{!114, !7, i64 0}
!114 = !{!"snd_ac97_template", !7, i64 0, !7, i64 8, !7, i64 16, !16, i64 24, !16, i64 26, !3, i64 28, !7, i64 32}
!115 = !{!114, !7, i64 8}
!116 = !{!114, !3, i64 28}
!117 = !{!51, !3, i64 924}
!118 = !{!51, !7, i64 32}
!119 = !{!120, !7, i64 16}
!120 = !{!"snd_ac97_bus", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !16, i64 32, !16, i64 34, !16, i64 34, !16, i64 34, !3, i64 36, !31, i64 40, !4, i64 112, !16, i64 128, !7, i64 136, !4, i64 144, !7, i64 176}
!121 = !{!120, !3, i64 36}
!122 = !{!51, !7, i64 880}
!123 = !{!114, !7, i64 16}
!124 = !{!114, !16, i64 24}
!125 = !{!120, !7, i64 136}
!126 = !{!57, !7, i64 112}
!127 = !{!128, !16, i64 384}
!128 = !{!"snd_ac97", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !16, i64 56, !16, i64 58, !30, i64 64, !30, i64 224, !16, i64 384, !16, i64 386, !3, i64 388, !16, i64 392, !16, i64 394, !16, i64 396, !7, i64 400, !3, i64 408, !3, i64 412, !4, i64 416, !3, i64 440, !4, i64 444, !4, i64 704, !4, i64 720, !4, i64 752, !4, i64 753, !3, i64 756, !24, i64 760, !19, i64 952, !7, i64 2376, !4, i64 2384}
!129 = !{!130, !16, i64 0}
!130 = !{!"", !16, i64 0, !4, i64 2, !4, i64 10, !4, i64 16}
!131 = !{!128, !3, i64 412}
!132 = !{!16, !16, i64 0}
!133 = !{!134, !3, i64 16}
!134 = !{!"ac97_pcm", !7, i64 0, !3, i64 8, !3, i64 8, !3, i64 8, !3, i64 8, !16, i64 10, !16, i64 12, !3, i64 16, !4, i64 24, !10, i64 120}
!135 = !{!136, !3, i64 40}
!136 = !{!"ich_pcm_table", !7, i64 0, !7, i64 8, !7, i64 16, !10, i64 24, !10, i64 32, !3, i64 40}
!137 = !{!138, !7, i64 24}
!138 = !{!"snd_pcm_str", !3, i64 0, !7, i64 8, !3, i64 16, !3, i64 20, !7, i64 24, !139, i64 32, !7, i64 208, !7, i64 216, !3, i64 224, !7, i64 232, !7, i64 240, !19, i64 248}
!139 = !{!"snd_pcm_oss_stream", !7, i64 0, !30, i64 8, !7, i64 168}
!140 = !{!65, !10, i64 344}
!141 = !{!65, !17, i64 336}
!142 = !{!57, !3, i64 48}
!143 = !{!57, !3, i64 108}
!144 = !{!57, !3, i64 100}
!145 = !{!57, !3, i64 60}
!146 = !{!44, !7, i64 2296}
!147 = !{!148, !7, i64 72}
!148 = !{!"snd_info_entry", !7, i64 0, !16, i64 8, !10, i64 16, !16, i64 24, !4, i64 32, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !30, i64 96, !15, i64 256, !15, i64 272}
!149 = !{!150, !7, i64 0}
!150 = !{!"snd_info_buffer", !7, i64 0, !3, i64 8, !3, i64 12, !3, i64 16, !3, i64 20, !3, i64 24}
!151 = !{!4, !4, i64 0}
!152 = !{!136, !7, i64 0}
!153 = !{!136, !7, i64 8}
!154 = !{!136, !7, i64 16}
!155 = !{!156, !7, i64 3776}
!156 = !{!"snd_pcm", !7, i64 0, !15, i64 8, !3, i64 24, !3, i64 28, !16, i64 32, !16, i64 34, !4, i64 36, !4, i64 100, !4, i64 184, !30, i64 3528, !38, i64 3688, !7, i64 3776, !7, i64 3784, !36, i64 3792, !36, i64 3793, !157, i64 3796}
!157 = !{!"snd_pcm_oss", !3, i64 0, !3, i64 4}
!158 = !{!156, !3, i64 28}
!159 = !{!136, !10, i64 24}
!160 = !{!136, !10, i64 32}
!161 = !{!162, !7, i64 0}
!162 = !{!"snd_pcm_ops", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104}
!163 = !{!164, !3, i64 36}
!164 = !{!"snd_pcm_chmap", !7, i64 0, !3, i64 8, !7, i64 16, !7, i64 24, !3, i64 32, !3, i64 36, !7, i64 40}
!165 = !{!65, !7, i64 16}
!166 = !{!81, !3, i64 512}
!167 = !{!81, !17, i64 488}
!168 = !{i64 0, i64 4, !2, i64 8, i64 8, !169, i64 16, i64 4, !2, i64 20, i64 4, !2, i64 24, i64 4, !2, i64 28, i64 4, !2, i64 32, i64 4, !2, i64 40, i64 8, !101, i64 48, i64 8, !101, i64 56, i64 8, !101, i64 64, i64 4, !2, i64 68, i64 4, !2, i64 72, i64 8, !101}
!169 = !{!17, !17, i64 0}
!170 = !{!81, !3, i64 496}
!171 = !{!81, !10, i64 520}
!172 = !{!81, !10, i64 536}
!173 = !{!81, !7, i64 464}
!174 = !{!81, !7, i64 824}
!175 = !{!57, !3, i64 120}
!176 = !{!81, !17, i64 832}
!177 = !{!65, !3, i64 60}
!178 = !{!57, !3, i64 64}
!179 = !{!81, !3, i64 152}
!180 = !{!81, !10, i64 128}
!181 = !{!81, !10, i64 112}
!182 = !{!183, !3, i64 0}
!183 = !{!"snd_interval", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 8, !3, i64 8, !3, i64 8}
!184 = !{!128, !7, i64 8}
!185 = !{!51, !3, i64 948}
!186 = !{!120, !7, i64 8}
!187 = !{!14, !16, i64 64}
!188 = !{!14, !16, i64 66}
!189 = !{!51, !7, i64 1048}
!190 = !{!191, !7, i64 32}
!191 = !{!"snd_device", !15, i64 0, !7, i64 16, !4, i64 24, !4, i64 28, !7, i64 32, !7, i64 40}
