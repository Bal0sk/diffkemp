; ModuleID = 'drivers/hwmon/sis5595.bc'
source_filename = "drivers/hwmon/sis5595.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, %struct.kernel_symbol*, i32*, i32, i32, %struct.kernel_symbol*, i32*, i8, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [56 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, i32, i64*, i8, i8, %struct.klp_modinfo*, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, void ()**, i32, [36 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, %struct.delayed_work, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.1 }
%union.anon.1 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qspinlock = type { %struct.atomic_t }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.hlist_node, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.lockdep_map, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)*, %struct.lock_class_key }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %struct.atomic64_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.49, %struct.list_head, %struct.list_head, %union.anon.50 }
%struct.seqcount = type { i32, %struct.lockdep_map }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%union.anon.3 = type { i64 }
%struct.lockref = type { %union.anon.47 }
%union.anon.47 = type { %struct.anon.48 }
%struct.anon.48 = type { %struct.spinlock, i32 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, [32 x i8], %struct.list_lru, [40 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.5, i32 }
%union.anon.5 = type { %struct.kuid_t }
%struct.kuid_t = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.6, %union.anon.32, %union.anon.33, %union.anon.37, %union.anon.41, %struct.mem_cgroup* }
%union.anon.6 = type { %struct.address_space* }
%union.anon.32 = type { i64 }
%union.anon.33 = type { i64 }
%union.anon.37 = type { %struct.list_head }
%union.anon.41 = type { i64 }
%struct.mem_cgroup = type opaque
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.kprojid_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.kprojid_t = type { i32 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.list_head, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.task_struct*, %struct.lockdep_map }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.task_struct = type { %struct.thread_info, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, %struct.hlist_head, i32, i32, i32, %struct.cpumask, i64, i8, %struct.list_head, i32, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, i64, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.kuid_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, i32, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.callback_head, %struct.list_head, %struct.numa_group*, i64*, i64, [3 x i64], i64, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, i32, i32, i8*, %struct.kcov*, %struct.mem_cgroup*, i32, i32, i32, %struct.uprobe_task*, i32, i32, i64, i32, %struct.task_struct*, %struct.atomic_t, %struct.thread_struct }
%struct.thread_info = type { i64 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [8 x i8], [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [128 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.task_struct*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, %struct.cpumask, i64, i64, i32, i8, %struct.uprobes_state, %struct.atomic64_t, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %struct.anon.7, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.pgprot = type { i64 }
%struct.anon.7 = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_userfaultfd_ctx = type { %struct.userfaultfd_ctx* }
%struct.userfaultfd_ctx = type opaque
%struct.pgd_t = type { i64 }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16, i8* }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type opaque
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.8 }
%union.anon.8 = type { %struct.anon.9 }
%struct.anon.9 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.sysv_shm = type { %struct.list_head }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type opaque
%struct.sighand_struct = type opaque
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, %struct.ww_acquire_ctx*, i8* }
%struct.ww_acquire_ctx = type opaque
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.12 }
%union.anon.12 = type { %struct.anon.16, [80 x i8] }
%struct.anon.16 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.numa_group = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.kcov = type opaque
%struct.uprobe_task = type { i32, %union.anon.22, %struct.uprobe*, i64, %struct.return_instance*, i32 }
%union.anon.22 = type { %struct.anon.23 }
%struct.anon.23 = type { %struct.arch_uprobe_task, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.uprobe = type opaque
%struct.return_instance = type { %struct.uprobe*, i64, i64, i64, i8, %struct.return_instance* }
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %struct.mm_segment_t, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.25 }
%union.anon.25 = type { %struct.anon.26 }
%struct.anon.26 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.mm_segment_t = type { i64 }
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.28, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.31 }
%union.anon.28 = type { %struct.anon.29 }
%struct.anon.29 = type { i64, i64 }
%union.anon.31 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %struct.atomic64_t* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type opaque
%struct.list_lru = type { %struct.list_lru_node*, %struct.list_head }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, %struct.list_lru_memcg*, [24 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.list_lru_memcg = type { [0 x %struct.list_lru_one*] }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%union.anon.49 = type { %struct.list_head }
%union.anon.50 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.kuid_t, %struct.kgid_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.42, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.bdi_writeback*, i32, i16, i16, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.43, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.46, i32, i32, %struct.hlist_head, %struct.fscrypt_info*, i8* }
%struct.kgid_t = type { i32 }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.42 = type { i32 }
%struct.timespec = type { i64, i64 }
%struct.bdi_writeback = type opaque
%union.anon.43 = type { %struct.callback_head }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.0, [64 x i8*], [3 x [1 x i64]] }
%union.anon.0 = type { %struct.list_head }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type opaque
%struct.swap_info_struct = type opaque
%union.anon.46 = type { %struct.pipe_inode_info* }
%struct.fscrypt_info = type opaque
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type opaque
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.atomic64_t = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.52, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.53, i64, %struct.kuid_t, %struct.kgid_t, i32, i16, i16, i64, %union.anon.54, %union.anon.56, i32 (%struct.key*, %struct.key_type*, %union.key_payload*)* }
%union.anon.52 = type { %struct.rb_node }
%struct.key_user = type opaque
%union.anon.53 = type { i64 }
%union.anon.54 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { %struct.key_type*, i8*, i64 }
%struct.key_type = type opaque
%union.anon.56 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, i64, %struct.atomic64_t, %struct.key*, %struct.key*, %struct.hlist_node, %struct.kuid_t, %struct.atomic64_t }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.kgid_t] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %struct.pmd_t*, %struct.pud_t*, %struct.pte_t, %struct.page*, %struct.mem_cgroup*, %struct.page*, %struct.pte_t*, %struct.spinlock*, %struct.page* }
%struct.pmd_t = type { i64 }
%struct.pud_t = type { i64 }
%struct.pte_t = type { i64 }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.refcount_struct }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32, %struct.lockdep_map }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.mutex = type { %struct.atomic64_t, %struct.spinlock, %struct.optimistic_spin_queue, %struct.list_head, i8*, %struct.lockdep_map }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.51 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.51 = type { i8* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type opaque
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.klp_modinfo = type { %struct.elf64_hdr, %struct.elf64_shdr*, i8*, i32 }
%struct.elf64_hdr = type { [16 x i8], i16, i16, i32, i64, i64, i64, i32, i16, i16, i16, i16, i16, i16 }
%struct.elf64_shdr = type { i32, i32, i64, i64, i64, i64, i32, i32, i64, i64 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.atomic_t = type { i32 }
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, i32 (%struct.pci_dev*, %struct.pci_device_id*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.pci_dynids }
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i16, i8, i8, i8, i8, i8, i8, i16, [4 x i8], i64*, %struct.pci_driver*, i64, %struct.device_dma_parameters, i32, i8, [3 x i8], i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [17 x %struct.resource], i8, i32, i8, i16, %struct.atomic_t, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [17 x %struct.bin_attribute*], [17 x %struct.bin_attribute*], i8, i8, [6 x i8], %struct.attribute_group**, %struct.pci_vpd*, %union.anon.58, i16, i8, i8, %struct.atomic_t, i64, i64, i8* }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, %struct.msi_controller*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.resource = type { i64, i64, i8*, i64, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.pci_ops = type { i32 (%struct.pci_bus*)*, void (%struct.pci_bus*)*, i8* (%struct.pci_bus*, i32, i32)*, i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.msi_controller = type opaque
%struct.proc_dir_entry = type opaque
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.device_dma_parameters = type { i32, i64 }
%struct.pcie_link_state = type opaque
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.dev_pin_info*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.cma*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.pm_message, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head, %struct.pm_domain_data* }
%struct.pm_domain_data = type opaque
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dev_pin_info = type { %struct.pinctrl*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state* }
%struct.pinctrl = type opaque
%struct.pinctrl_state = type opaque
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, i64)*, void (%struct.device*, i64, i8*, i64, i64)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, i64)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, i64 (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.dma_coherent_mem = type opaque
%struct.cma = type opaque
%struct.dev_archdata = type { i8* }
%struct.device_node = type opaque
%struct.fwnode_handle = type { i32, %struct.fwnode_handle* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.pci_vpd = type opaque
%union.anon.58 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*, i1)*, void (%struct.pci_dev*)* }
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.pci_dynids = type { %struct.spinlock, %struct.list_head }
%struct.platform_driver = type { i32 (%struct.platform_device*)*, i32 (%struct.platform_device*)*, void (%struct.platform_device*)*, i32 (%struct.platform_device*, i32)*, i32 (%struct.platform_device*)*, %struct.device_driver, %struct.platform_device_id*, i8 }
%struct.platform_device = type { i8*, i32, i8, %struct.device, i32, %struct.resource*, %struct.platform_device_id*, i8*, %struct.mfd_cell*, %struct.pdev_archdata }
%struct.mfd_cell = type opaque
%struct.pdev_archdata = type {}
%struct.platform_device_id = type { [20 x i8], i64 }
%struct.pv_cpu_ops = type { i64 (i32)*, void (i32, i64)*, i64 ()*, void (i64)*, i64 ()*, void (i64)*, i64 ()*, void (i64)*, void ()*, void (%struct.desc_ptr*)*, void (%struct.desc_ptr*)*, void (%struct.desc_ptr*)*, void (i8*, i32)*, i64 ()*, void (%struct.thread_struct*, i32)*, void (i32)*, void (%struct.desc_struct*, i32, i8*)*, void (%struct.desc_struct*, i32, i8*, i32)*, void (%struct.gate_struct64*, i32, %struct.gate_struct64*)*, void (%struct.desc_struct*, i32)*, void (%struct.desc_struct*, i32)*, void (%struct.tss_struct*, %struct.thread_struct*)*, void (i32)*, void ()*, void ()*, void (i32*, i32*, i32*, i32*)*, i64 (i32)*, void (i32, i32, i32)*, i64 (i32, i32*)*, i32 (i32, i32, i32)*, i64 (i32)*, void ()*, void ()*, void ()*, void (%struct.task_struct*)*, void (%struct.task_struct*)* }
%struct.desc_ptr = type <{ i16, i64 }>
%struct.gate_struct64 = type { i16, i16, i16, i16, i32, i32 }
%struct.tss_struct = type { %struct.x86_hw_tss, [1025 x i64], [16 x i8] }
%struct.x86_hw_tss = type <{ i32, i64, i64, i64, i64, [7 x i64], i32, i32, i16, i16 }>
%struct.sensor_device_attribute = type { %struct.device_attribute, i32 }
%struct._ddebug = type { i8*, i8*, i8*, i8*, i32 }
%struct.sis5595_data = type { i16, i8*, %struct.device*, %struct.mutex, %struct.mutex, i8, i64, i8, i8, [5 x i8], [5 x i8], [5 x i8], [2 x i8], [2 x i8], i8, i8, i8, [2 x i8], i16 }

@__param_str_force_addr = internal constant [11 x i8] c"force_addr\00", align 1
@__this_module = external global %struct.module, align 64
@param_ops_ushort = external constant %struct.kernel_param_ops, align 8
@force_addr = internal global i16 0, align 2
@__param_force_addr = internal constant %struct.kernel_param { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__param_str_force_addr, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_ushort, i16 0, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i16* @force_addr to i8*) } }, section "__param", align 8
@__UNIQUE_ID_force_addrtype12 = internal constant [27 x i8] c"parmtype=force_addr:ushort\00", section ".modinfo", align 1
@__UNIQUE_ID_force_addr13 = internal constant [59 x i8] c"parm=force_addr:Initialize the base address of the sensors\00", section ".modinfo", align 1
@sis5595_pci_ids = internal constant [2 x %struct.pci_device_id] [%struct.pci_device_id { i32 4153, i32 8, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id zeroinitializer], align 16
@__UNIQUE_ID_author26 = internal constant [45 x i8] c"author=Aurelien Jarno <aurelien@aurel32.net>\00", section ".modinfo", align 1
@__UNIQUE_ID_description27 = internal constant [35 x i8] c"description=SiS 5595 Sensor device\00", section ".modinfo", align 1
@__UNIQUE_ID_license28 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@sis5595_pci_driver = internal global %struct.pci_driver { %struct.list_head zeroinitializer, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), %struct.pci_device_id* getelementptr inbounds ([2 x %struct.pci_device_id], [2 x %struct.pci_device_id]* @sis5595_pci_ids, i32 0, i32 0), i32 (%struct.pci_dev*, %struct.pci_device_id*)* @sis5595_pci_probe, void (%struct.pci_dev*)* null, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*)* null, i32 (%struct.pci_dev*)* null, void (%struct.pci_dev*)* null, i32 (%struct.pci_dev*, i32)* null, %struct.pci_error_handlers* null, %struct.device_driver zeroinitializer, %struct.pci_dynids zeroinitializer }, align 8
@.str = private unnamed_addr constant [8 x i8] c"sis5595\00", align 1
@blacklist = internal global [10 x i32] [i32 1344, i32 1360, i32 1584, i32 1605, i32 1840, i32 1845, i32 21777, i32 21911, i32 21912, i32 0], align 16
@.str.1 = private unnamed_addr constant [54 x i8] c"Looked for SIS5595 but found unsupported device %.4x\0A\00", align 1
@.str.2 = private unnamed_addr constant [26 x i8] c"Forcing ISA address 0x%x\0A\00", align 1
@.str.3 = private unnamed_addr constant [28 x i8] c"Failed to read ISA address\0A\00", align 1
@.str.4 = private unnamed_addr constant [62 x i8] c"Base address not set - upgrade BIOS or use force_addr=0xaddr\0A\00", align 1
@.str.5 = private unnamed_addr constant [29 x i8] c"Failed to force ISA address\0A\00", align 1
@.str.6 = private unnamed_addr constant [32 x i8] c"Failed to read enable register\0A\00", align 1
@.str.7 = private unnamed_addr constant [29 x i8] c"Failed to enable HWM device\0A\00", align 1
@sis5595_driver = internal global %struct.platform_driver { i32 (%struct.platform_device*)* @sis5595_probe, i32 (%struct.platform_device*)* @sis5595_remove, void (%struct.platform_device*)* null, i32 (%struct.platform_device*, i32)* null, i32 (%struct.platform_device*)* null, %struct.device_driver { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), %struct.bus_type* null, %struct.module* null, i8* null, i8 0, i32 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* null, %struct.driver_private* null }, %struct.platform_device_id* null, i8 0 }, align 8
@sis5595_pci_probe.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.sis5595_pci_probe, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.9, i32 0, i32 0), i8 114, i8 3, i8 4, i8 0 }, section "__verbose", align 8
@__func__.sis5595_pci_probe = private unnamed_addr constant [18 x i8] c"sis5595_pci_probe\00", align 1
@.str.8 = private unnamed_addr constant [24 x i8] c"drivers/hwmon/sis5595.c\00", align 1
@.str.9 = private unnamed_addr constant [35 x i8] c"Failed to register sis5595 driver\0A\00", align 1
@s_bridge = internal global %struct.pci_dev* null, align 8
@ioport_resource = external global %struct.resource, align 8
@sis5595_probe.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.10 = private unnamed_addr constant [12 x i8] c"&data->lock\00", align 1
@sis5595_probe.__key.11 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.12 = private unnamed_addr constant [19 x i8] c"&data->update_lock\00", align 1
@sis5595_group = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([27 x %struct.attribute*], [27 x %struct.attribute*]* @sis5595_attributes, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@sis5595_group_in4 = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([5 x %struct.attribute*], [5 x %struct.attribute*]* @sis5595_attributes_in4, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@sis5595_group_temp1 = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([5 x %struct.attribute*], [5 x %struct.attribute*]* @sis5595_attributes_temp1, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@pv_cpu_ops = external global %struct.pv_cpu_ops, align 8
@sis5595_attributes = internal global [27 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in0_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in0_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in0_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in0_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_div, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_div, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_alarms, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_name, i32 0, i32 0), %struct.attribute* null], align 16
@sensor_dev_attr_in0_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.13, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_in0_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.15, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 0 }, align 8
@sensor_dev_attr_in0_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.16, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 0 }, align 8
@sensor_dev_attr_in0_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.17, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_in1_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.19, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_in1_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.20, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 1 }, align 8
@sensor_dev_attr_in1_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.21, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 1 }, align 8
@sensor_dev_attr_in1_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.22, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_in2_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.23, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 2 }, align 8
@sensor_dev_attr_in2_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.24, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 2 }, align 8
@sensor_dev_attr_in2_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.25, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 2 }, align 8
@sensor_dev_attr_in2_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.26, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 2 }, align 8
@sensor_dev_attr_in3_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.27, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 3 }, align 8
@sensor_dev_attr_in3_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.28, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 3 }, align 8
@sensor_dev_attr_in3_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.29, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 3 }, align 8
@sensor_dev_attr_in3_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.30, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 3 }, align 8
@sensor_dev_attr_fan1_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.31, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_fan1_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.32, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_fan_min }, i32 0 }, align 8
@sensor_dev_attr_fan1_div = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_div, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_fan_div }, i32 0 }, align 8
@sensor_dev_attr_fan1_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.35, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 6 }, align 8
@sensor_dev_attr_fan2_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.36, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_fan2_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.37, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_fan_min }, i32 1 }, align 8
@sensor_dev_attr_fan2_div = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.38, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_div, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_fan_div }, i32 1 }, align 8
@sensor_dev_attr_fan2_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.39, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 7 }, align 8
@dev_attr_alarms = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.40, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @alarms_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_name = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.41, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @name_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.13 = private unnamed_addr constant [10 x i8] c"in0_input\00", align 1
@.str.14 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@jiffies = external global i64, align 8
@.str.15 = private unnamed_addr constant [8 x i8] c"in0_min\00", align 1
@.str.16 = private unnamed_addr constant [8 x i8] c"in0_max\00", align 1
@.str.17 = private unnamed_addr constant [10 x i8] c"in0_alarm\00", align 1
@.str.18 = private unnamed_addr constant [4 x i8] c"%u\0A\00", align 1
@.str.19 = private unnamed_addr constant [10 x i8] c"in1_input\00", align 1
@.str.20 = private unnamed_addr constant [8 x i8] c"in1_min\00", align 1
@.str.21 = private unnamed_addr constant [8 x i8] c"in1_max\00", align 1
@.str.22 = private unnamed_addr constant [10 x i8] c"in1_alarm\00", align 1
@.str.23 = private unnamed_addr constant [10 x i8] c"in2_input\00", align 1
@.str.24 = private unnamed_addr constant [8 x i8] c"in2_min\00", align 1
@.str.25 = private unnamed_addr constant [8 x i8] c"in2_max\00", align 1
@.str.26 = private unnamed_addr constant [10 x i8] c"in2_alarm\00", align 1
@.str.27 = private unnamed_addr constant [10 x i8] c"in3_input\00", align 1
@.str.28 = private unnamed_addr constant [8 x i8] c"in3_min\00", align 1
@.str.29 = private unnamed_addr constant [8 x i8] c"in3_max\00", align 1
@.str.30 = private unnamed_addr constant [10 x i8] c"in3_alarm\00", align 1
@.str.31 = private unnamed_addr constant [11 x i8] c"fan1_input\00", align 1
@.str.32 = private unnamed_addr constant [9 x i8] c"fan1_min\00", align 1
@.str.33 = private unnamed_addr constant [9 x i8] c"fan1_div\00", align 1
@.str.34 = private unnamed_addr constant [62 x i8] c"fan_div value %ld not supported. Choose one of 1, 2, 4 or 8!\0A\00", align 1
@.str.35 = private unnamed_addr constant [11 x i8] c"fan1_alarm\00", align 1
@.str.36 = private unnamed_addr constant [11 x i8] c"fan2_input\00", align 1
@.str.37 = private unnamed_addr constant [9 x i8] c"fan2_min\00", align 1
@.str.38 = private unnamed_addr constant [9 x i8] c"fan2_div\00", align 1
@.str.39 = private unnamed_addr constant [11 x i8] c"fan2_alarm\00", align 1
@.str.40 = private unnamed_addr constant [7 x i8] c"alarms\00", align 1
@.str.41 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str.42 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@sis5595_attributes_in4 = internal global [5 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_alarm, i32 0, i32 0, i32 0), %struct.attribute* null], align 16
@sensor_dev_attr_in4_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.43, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 4 }, align 8
@sensor_dev_attr_in4_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.44, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 4 }, align 8
@sensor_dev_attr_in4_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.45, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 4 }, align 8
@sensor_dev_attr_in4_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.46, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 15 }, align 8
@.str.43 = private unnamed_addr constant [10 x i8] c"in4_input\00", align 1
@.str.44 = private unnamed_addr constant [8 x i8] c"in4_min\00", align 1
@.str.45 = private unnamed_addr constant [8 x i8] c"in4_max\00", align 1
@.str.46 = private unnamed_addr constant [10 x i8] c"in4_alarm\00", align 1
@sis5595_attributes_temp1 = internal global [5 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_temp1_input, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_temp1_max, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_temp1_max_hyst, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_alarm, i32 0, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_temp1_input = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.47, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @temp1_input_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_temp1_max = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.48, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @temp1_max_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @temp1_max_store }, align 8
@dev_attr_temp1_max_hyst = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.49, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @temp1_max_hyst_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @temp1_max_hyst_store }, align 8
@sensor_dev_attr_temp1_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.50, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 15 }, align 8
@.str.47 = private unnamed_addr constant [12 x i8] c"temp1_input\00", align 1
@.str.48 = private unnamed_addr constant [10 x i8] c"temp1_max\00", align 1
@.str.49 = private unnamed_addr constant [15 x i8] c"temp1_max_hyst\00", align 1
@.str.50 = private unnamed_addr constant [12 x i8] c"temp1_alarm\00", align 1
@pdev = internal global %struct.platform_device* null, align 8
@.str.51 = private unnamed_addr constant [37 x i8] c"\013sis5595: Device allocation failed\0A\00", align 1
@.str.52 = private unnamed_addr constant [49 x i8] c"\013sis5595: Device resource addition failed (%d)\0A\00", align 1
@.str.53 = private unnamed_addr constant [40 x i8] c"\013sis5595: Device addition failed (%d)\0A\00", align 1
@llvm.used = appending global [6 x i8*] [i8* bitcast (%struct.kernel_param* @__param_force_addr to i8*), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__UNIQUE_ID_force_addrtype12, i32 0, i32 0), i8* getelementptr inbounds ([59 x i8], [59 x i8]* @__UNIQUE_ID_force_addr13, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @__UNIQUE_ID_author26, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @__UNIQUE_ID_description27, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license28, i32 0, i32 0)], section "llvm.metadata"

@__mod_pci__sis5595_pci_ids_device_table = alias [2 x %struct.pci_device_id], [2 x %struct.pci_device_id]* @sis5595_pci_ids
@init_module = alias i32 (), i32 ()* @sm_sis5595_init
@cleanup_module = alias void (), void ()* @sm_sis5595_exit

; Function Attrs: nounwind uwtable
define internal i32 @sm_sis5595_init() #0 section ".init.text" {
entry:
  %call = call i32 @__pci_register_driver(%struct.pci_driver* @sis5595_pci_driver, %struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0))
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @sm_sis5595_exit() #0 section ".exit.text" {
entry:
  call void @pci_unregister_driver(%struct.pci_driver* @sis5595_pci_driver)
  %0 = load %struct.pci_dev*, %struct.pci_dev** @s_bridge, align 8, !tbaa !2
  %cmp = icmp ne %struct.pci_dev* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !2
  call void @platform_device_unregister(%struct.platform_device* %1)
  call void @platform_driver_unregister(%struct.platform_driver* @sis5595_driver)
  %2 = load %struct.pci_dev*, %struct.pci_dev** @s_bridge, align 8, !tbaa !2
  call void @pci_dev_put(%struct.pci_dev* %2)
  store %struct.pci_dev* null, %struct.pci_dev** @s_bridge, align 8, !tbaa !2
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare i32 @__pci_register_driver(%struct.pci_driver*, %struct.module*, i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_pci_probe(%struct.pci_dev* %dev, %struct.pci_device_id* %id) #2 {
entry:
  %address = alloca i16, align 2
  %enable = alloca i8, align 1
  %0 = bitcast i16* %address to i8*
  call void @llvm.lifetime.start.p0i8(i64 2, i8* %0) #6
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %enable) #6
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32* [ getelementptr inbounds ([10 x i32], [10 x i32]* @blacklist, i32 0, i32 0), %entry ], [ %incdec.ptr, %for.inc ]
  %retval.0 = phi i32 [ undef, %entry ], [ %retval.1, %for.inc ]
  %1 = load i32, i32* %i.0, align 4, !tbaa !6
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, i32* %i.0, align 4, !tbaa !6
  %call = call %struct.pci_dev* @pci_get_device(i32 4153, i32 %2, %struct.pci_dev* null)
  %tobool = icmp ne %struct.pci_dev* %call, null
  br i1 %tobool, label %if.then, label %LeafBlock

if.then:                                          ; preds = %for.body
  %dev1 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %call, i32 0, i32 35
  %3 = load i32, i32* %i.0, align 4, !tbaa !6
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev1, i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.1, i32 0, i32 0), i32 %3)
  call void @pci_dev_put(%struct.pci_dev* %call)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.then, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then ], [ 0, %for.body ]
  %retval.1 = phi i32 [ -19, %if.then ], [ %retval.0, %for.body ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup77

for.inc:                                          ; preds = %LeafBlock
  %incdec.ptr = getelementptr inbounds i32, i32* %i.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %4 = load i16, i16* @force_addr, align 2, !tbaa !8
  %conv = zext i16 %4 to i32
  %and = and i32 %conv, -8
  %conv2 = trunc i32 %and to i16
  store i16 %conv2, i16* @force_addr, align 2, !tbaa !8
  %5 = load i16, i16* @force_addr, align 2, !tbaa !8
  %tobool3 = icmp ne i16 %5, 0
  br i1 %tobool3, label %if.then4, label %if.end8

if.then4:                                         ; preds = %for.end
  %dev5 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  %6 = load i16, i16* @force_addr, align 2, !tbaa !8
  %conv6 = zext i16 %6 to i32
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev5, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), i32 %conv6)
  %7 = load i16, i16* @force_addr, align 2, !tbaa !8
  %call7 = call i32 @pci_write_config_word(%struct.pci_dev* %dev, i32 104, i16 zeroext %7)
  br label %if.end8

if.end8:                                          ; preds = %if.then4, %for.end
  %call9 = call i32 @pci_read_config_word(%struct.pci_dev* %dev, i32 104, i16* %address)
  %cmp10 = icmp ne i32 0, %call9
  br i1 %cmp10, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end8
  %dev13 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev13, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.3, i32 0, i32 0))
  br label %cleanup77

if.end14:                                         ; preds = %if.end8
  %8 = load i16, i16* %address, align 2, !tbaa !8
  %conv15 = zext i16 %8 to i32
  %and16 = and i32 %conv15, -8
  %conv17 = trunc i32 %and16 to i16
  store i16 %conv17, i16* %address, align 2, !tbaa !8
  %9 = load i16, i16* %address, align 2, !tbaa !8
  %tobool18 = icmp ne i16 %9, 0
  br i1 %tobool18, label %if.end21, label %if.then19

if.then19:                                        ; preds = %if.end14
  %dev20 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev20, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.4, i32 0, i32 0))
  br label %cleanup77

if.end21:                                         ; preds = %if.end14
  %10 = load i16, i16* @force_addr, align 2, !tbaa !8
  %conv22 = zext i16 %10 to i32
  %tobool23 = icmp ne i32 %conv22, 0
  br i1 %tobool23, label %land.lhs.true, label %if.end30

land.lhs.true:                                    ; preds = %if.end21
  %11 = load i16, i16* %address, align 2, !tbaa !8
  %conv24 = zext i16 %11 to i32
  %12 = load i16, i16* @force_addr, align 2, !tbaa !8
  %conv25 = zext i16 %12 to i32
  %cmp26 = icmp ne i32 %conv24, %conv25
  br i1 %cmp26, label %if.then28, label %if.end30

if.then28:                                        ; preds = %land.lhs.true
  %dev29 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev29, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.5, i32 0, i32 0))
  br label %cleanup77

if.end30:                                         ; preds = %land.lhs.true, %if.end21
  %call31 = call i32 @pci_read_config_byte(%struct.pci_dev* %dev, i32 123, i8* %enable)
  %cmp32 = icmp ne i32 0, %call31
  br i1 %cmp32, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end30
  %dev35 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev35, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.6, i32 0, i32 0))
  br label %cleanup77

if.end36:                                         ; preds = %if.end30
  %13 = load i8, i8* %enable, align 1, !tbaa !10
  %conv37 = zext i8 %13 to i32
  %and38 = and i32 %conv37, 128
  %tobool39 = icmp ne i32 %and38, 0
  br i1 %tobool39, label %if.end56, label %if.then40

if.then40:                                        ; preds = %if.end36
  %14 = load i8, i8* %enable, align 1, !tbaa !10
  %conv41 = zext i8 %14 to i32
  %or = or i32 %conv41, 128
  %conv42 = trunc i32 %or to i8
  %call43 = call i32 @pci_write_config_byte(%struct.pci_dev* %dev, i32 123, i8 zeroext %conv42)
  %cmp44 = icmp ne i32 0, %call43
  br i1 %cmp44, label %if.then53, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then40
  %call46 = call i32 @pci_read_config_byte(%struct.pci_dev* %dev, i32 123, i8* %enable)
  %cmp47 = icmp ne i32 0, %call46
  br i1 %cmp47, label %if.then53, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %lor.lhs.false
  %15 = load i8, i8* %enable, align 1, !tbaa !10
  %conv50 = zext i8 %15 to i32
  %and51 = and i32 %conv50, 128
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %if.end56, label %if.then53

if.then53:                                        ; preds = %lor.lhs.false49, %lor.lhs.false, %if.then40
  %dev54 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev54, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.7, i32 0, i32 0))
  br label %cleanup77

if.end56:                                         ; preds = %lor.lhs.false49, %if.end36
  %call57 = call i32 @__platform_driver_register(%struct.platform_driver* @sis5595_driver, %struct.module* @__this_module)
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %do.body60, label %if.end71

do.body60:                                        ; preds = %if.end56
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @sis5595_pci_probe.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and61 = and i32 %bf.clear, 1
  %tobool62 = icmp ne i32 %and61, 0
  %lnot = xor i1 %tobool62, true
  %lnot63 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot63 to i32
  %conv64 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv64, i64 1)
  %tobool65 = icmp ne i64 %expval, 0
  br i1 %tobool65, label %if.then66, label %cleanup77

if.then66:                                        ; preds = %do.body60
  %dev67 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @sis5595_pci_probe.descriptor to %struct._ddebug*), %struct.device* %dev67, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.9, i32 0, i32 0))
  br label %cleanup77

if.end71:                                         ; preds = %if.end56
  %call72 = call %struct.pci_dev* @pci_dev_get(%struct.pci_dev* %dev)
  store %struct.pci_dev* %call72, %struct.pci_dev** @s_bridge, align 8, !tbaa !2
  %16 = load i16, i16* %address, align 2, !tbaa !8
  %call73 = call i32 @sis5595_device_add(i16 zeroext %16)
  %tobool74 = icmp ne i32 %call73, 0
  br i1 %tobool74, label %exit_unregister, label %cleanup77

exit_unregister:                                  ; preds = %if.end71
  call void @pci_dev_put(%struct.pci_dev* %dev)
  call void @platform_driver_unregister(%struct.platform_driver* @sis5595_driver)
  br label %cleanup77

cleanup77:                                        ; preds = %LeafBlock, %exit_unregister, %if.then66, %do.body60, %if.end71, %if.then53, %if.then34, %if.then28, %if.then19, %if.then12
  %retval.2 = phi i32 [ -19, %if.then12 ], [ -19, %if.then28 ], [ -19, %if.then34 ], [ -19, %if.then53 ], [ -19, %if.then19 ], [ -19, %if.end71 ], [ -19, %do.body60 ], [ -19, %if.then66 ], [ -19, %exit_unregister ], [ %retval.1, %LeafBlock ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %enable) #6
  %17 = bitcast i16* %address to i8*
  call void @llvm.lifetime.end.p0i8(i64 2, i8* %17) #6
  ret i32 %retval.2
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #3

declare %struct.pci_dev* @pci_get_device(i32, i32, %struct.pci_dev*) #1

declare void @dev_err(%struct.device*, i8*, ...) #1

declare void @pci_dev_put(%struct.pci_dev*) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #3

declare void @dev_warn(%struct.device*, i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pci_write_config_word(%struct.pci_dev* %dev, i32 %where, i16 zeroext %val) #4 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !11
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !40
  %call = call i32 @pci_bus_write_config_word(%struct.pci_bus* %0, i32 %1, i32 %where, i16 zeroext %val)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pci_read_config_word(%struct.pci_dev* %dev, i32 %where, i16* %val) #4 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !11
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !40
  %call = call i32 @pci_bus_read_config_word(%struct.pci_bus* %0, i32 %1, i32 %where, i16* %val)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pci_read_config_byte(%struct.pci_dev* %dev, i32 %where, i8* %val) #4 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !11
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !40
  %call = call i32 @pci_bus_read_config_byte(%struct.pci_bus* %0, i32 %1, i32 %where, i8* %val)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pci_write_config_byte(%struct.pci_dev* %dev, i32 %where, i8 zeroext %val) #4 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !11
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !40
  %call = call i32 @pci_bus_write_config_byte(%struct.pci_bus* %0, i32 %1, i32 %where, i8 zeroext %val)
  ret i32 %call
}

declare i32 @__platform_driver_register(%struct.platform_driver*, %struct.module*) #1

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #5

declare void @__dynamic_dev_dbg(%struct._ddebug*, %struct.device*, i8*, ...) #1

declare %struct.pci_dev* @pci_dev_get(%struct.pci_dev*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_device_add(i16 zeroext %address) #2 {
entry:
  %res = alloca %struct.resource, align 8
  %0 = bitcast %struct.resource* %res to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %0) #6
  %start = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 0
  %conv = zext i16 %address to i64
  store i64 %conv, i64* %start, align 8, !tbaa !41
  %end = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 1
  %conv1 = zext i16 %address to i32
  %add = add nsw i32 %conv1, 8
  %sub = sub nsw i32 %add, 1
  %conv2 = sext i32 %sub to i64
  store i64 %conv2, i64* %end, align 8, !tbaa !43
  %name = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 2
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i8** %name, align 8, !tbaa !44
  %flags = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 3
  store i64 256, i64* %flags, align 8, !tbaa !45
  %desc = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 4
  store i64 0, i64* %desc, align 8, !tbaa !46
  %parent = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 5
  store %struct.resource* null, %struct.resource** %parent, align 8, !tbaa !47
  %sibling = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 6
  store %struct.resource* null, %struct.resource** %sibling, align 8, !tbaa !48
  %child = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 7
  store %struct.resource* null, %struct.resource** %child, align 8, !tbaa !49
  %call = call i32 @acpi_check_resource_conflict(%struct.resource* %res)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %conv3 = zext i16 %address to i32
  %call4 = call %struct.platform_device* @platform_device_alloc(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i32 %conv3)
  store %struct.platform_device* %call4, %struct.platform_device** @pdev, align 8, !tbaa !2
  %1 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !2
  %tobool5 = icmp ne %struct.platform_device* %1, null
  br i1 %tobool5, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end
  %call7 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.51, i32 0, i32 0))
  br label %cleanup

if.end8:                                          ; preds = %if.end
  %2 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !2
  %call9 = call i32 @platform_device_add_resources(%struct.platform_device* %2, %struct.resource* %res, i32 1)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end8
  %call12 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.52, i32 0, i32 0), i32 %call9)
  br label %exit_device_put

if.end13:                                         ; preds = %if.end8
  %3 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !2
  %call14 = call i32 @platform_device_add(%struct.platform_device* %3)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.then16, label %cleanup

if.then16:                                        ; preds = %if.end13
  %call17 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.53, i32 0, i32 0), i32 %call14)
  br label %exit_device_put

exit_device_put:                                  ; preds = %if.then16, %if.then11
  %err.0 = phi i32 [ %call9, %if.then11 ], [ %call14, %if.then16 ]
  %4 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !2
  call void @platform_device_put(%struct.platform_device* %4)
  br label %cleanup

cleanup:                                          ; preds = %if.then6, %exit_device_put, %entry, %if.end13
  %retval.0 = phi i32 [ 0, %if.end13 ], [ %err.0, %exit_device_put ], [ -12, %if.then6 ], [ %call, %entry ]
  %5 = bitcast %struct.resource* %res to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %5) #6
  ret i32 %retval.0
}

declare void @platform_driver_unregister(%struct.platform_driver*) #1

declare i32 @pci_bus_write_config_word(%struct.pci_bus*, i32, i32, i16 zeroext) #1

declare i32 @pci_bus_read_config_word(%struct.pci_bus*, i32, i32, i16*) #1

declare i32 @pci_bus_read_config_byte(%struct.pci_bus*, i32, i32, i8*) #1

declare i32 @pci_bus_write_config_byte(%struct.pci_bus*, i32, i32, i8 zeroext) #1

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_probe(%struct.platform_device* %pdev) #2 {
entry:
  %val = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %val) #6
  %call = call %struct.resource* @platform_get_resource(%struct.platform_device* %pdev, i32 256, i32 0)
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %start = getelementptr inbounds %struct.resource, %struct.resource* %call, i32 0, i32 0
  %0 = load i64, i64* %start, align 8, !tbaa !41
  %1 = load i8*, i8** getelementptr inbounds (%struct.platform_driver, %struct.platform_driver* @sis5595_driver, i32 0, i32 5, i32 0), align 8, !tbaa !50
  %call1 = call %struct.resource* @__devm_request_region(%struct.device* %dev, %struct.resource* @ioport_resource, i64 %0, i64 8, i8* %1)
  %tobool = icmp ne %struct.resource* %call1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %dev2 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call3 = call i8* @devm_kzalloc(%struct.device* %dev2, i64 392, i32 20971712)
  %2 = bitcast i8* %call3 to %struct.sis5595_data*
  %tobool4 = icmp ne %struct.sis5595_data* %2, null
  br i1 %tobool4, label %do.body, label %cleanup

do.body:                                          ; preds = %if.end
  %lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 3
  call void @__mutex_init(%struct.mutex* %lock, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.10, i32 0, i32 0), %struct.lock_class_key* @sis5595_probe.__key)
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 4
  call void @__mutex_init(%struct.mutex* %update_lock, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.12, i32 0, i32 0), %struct.lock_class_key* @sis5595_probe.__key.11)
  %start10 = getelementptr inbounds %struct.resource, %struct.resource* %call, i32 0, i32 0
  %3 = load i64, i64* %start10, align 8, !tbaa !41
  %conv = trunc i64 %3 to i16
  %addr = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 0
  store i16 %conv, i16* %addr, align 8, !tbaa !53
  %name = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 1
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i8** %name, align 8, !tbaa !55
  %4 = bitcast %struct.sis5595_data* %2 to i8*
  call void @platform_set_drvdata(%struct.platform_device* %pdev, i8* %4)
  %5 = load %struct.pci_dev*, %struct.pci_dev** @s_bridge, align 8, !tbaa !2
  %revision = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %5, i32 0, i32 12
  %6 = load i8, i8* %revision, align 8, !tbaa !56
  %revision11 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 8
  store i8 %6, i8* %revision11, align 1, !tbaa !57
  %maxins = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 7
  store i8 3, i8* %maxins, align 8, !tbaa !58
  %revision12 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 8
  %7 = load i8, i8* %revision12, align 1, !tbaa !57
  %conv13 = zext i8 %7 to i32
  %cmp = icmp sge i32 %conv13, 176
  br i1 %cmp, label %if.then15, label %if.end22

if.then15:                                        ; preds = %do.body
  %8 = load %struct.pci_dev*, %struct.pci_dev** @s_bridge, align 8, !tbaa !2
  %call16 = call i32 @pci_read_config_byte(%struct.pci_dev* %8, i32 122, i8* %val)
  %9 = load i8, i8* %val, align 1, !tbaa !10
  %conv17 = sext i8 %9 to i32
  %and = and i32 %conv17, 128
  %tobool18 = icmp ne i32 %and, 0
  br i1 %tobool18, label %if.end22, label %if.then19

if.then19:                                        ; preds = %if.then15
  %maxins20 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 7
  store i8 4, i8* %maxins20, align 8, !tbaa !58
  br label %if.end22

if.end22:                                         ; preds = %if.then15, %if.then19, %do.body
  call void @sis5595_init_device(%struct.sis5595_data* %2)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end22
  %i.0 = phi i32 [ 0, %if.end22 ], [ %inc, %for.body ]
  %cmp23 = icmp slt i32 %i.0, 2
  br i1 %cmp23, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add = add nsw i32 59, %i.0
  %conv25 = trunc i32 %add to i8
  %call26 = call i32 @sis5595_read_value(%struct.sis5595_data* %2, i8 zeroext %conv25)
  %conv27 = trunc i32 %call26 to i8
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 13
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom
  store i8 %conv27, i8* %arrayidx, align 1, !tbaa !10
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %dev28 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev28, i32 0, i32 2
  %call29 = call i32 @sysfs_create_group(%struct.kobject* %kobj, %struct.attribute_group* @sis5595_group)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %cleanup, label %if.end32

if.end32:                                         ; preds = %for.end
  %maxins33 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 7
  %10 = load i8, i8* %maxins33, align 8, !tbaa !58
  %conv34 = sext i8 %10 to i32
  %cmp35 = icmp eq i32 %conv34, 4
  %dev38 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj39 = getelementptr inbounds %struct.device, %struct.device* %dev38, i32 0, i32 2
  br i1 %cmp35, label %if.then37, label %if.else

if.then37:                                        ; preds = %if.end32
  %call40 = call i32 @sysfs_create_group(%struct.kobject* %kobj39, %struct.attribute_group* @sis5595_group_in4)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %exit_remove_files, label %if.end50

if.else:                                          ; preds = %if.end32
  %call46 = call i32 @sysfs_create_group(%struct.kobject* %kobj39, %struct.attribute_group* @sis5595_group_temp1)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %exit_remove_files, label %if.end50

if.end50:                                         ; preds = %if.else, %if.then37
  %dev51 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call52 = call %struct.device* @hwmon_device_register(%struct.device* %dev51)
  %hwmon_dev = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 2
  store %struct.device* %call52, %struct.device** %hwmon_dev, align 8, !tbaa !59
  %hwmon_dev53 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 2
  %11 = load %struct.device*, %struct.device** %hwmon_dev53, align 8, !tbaa !59
  %12 = bitcast %struct.device* %11 to i8*
  %call54 = call zeroext i1 @IS_ERR(i8* %12)
  br i1 %call54, label %if.then55, label %cleanup

if.then55:                                        ; preds = %if.end50
  %hwmon_dev56 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 2
  %13 = load %struct.device*, %struct.device** %hwmon_dev56, align 8, !tbaa !59
  %14 = bitcast %struct.device* %13 to i8*
  %call57 = call i64 @PTR_ERR(i8* %14)
  %conv58 = trunc i64 %call57 to i32
  br label %exit_remove_files

exit_remove_files:                                ; preds = %if.else, %if.then37, %if.then55
  %err.0 = phi i32 [ %conv58, %if.then55 ], [ %call40, %if.then37 ], [ %call46, %if.else ]
  %dev60 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj61 = getelementptr inbounds %struct.device, %struct.device* %dev60, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj61, %struct.attribute_group* @sis5595_group)
  %dev62 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj63 = getelementptr inbounds %struct.device, %struct.device* %dev62, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj63, %struct.attribute_group* @sis5595_group_in4)
  %dev64 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj65 = getelementptr inbounds %struct.device, %struct.device* %dev64, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj65, %struct.attribute_group* @sis5595_group_temp1)
  br label %cleanup

cleanup:                                          ; preds = %if.end50, %for.end, %if.end, %entry, %exit_remove_files
  %retval.0 = phi i32 [ %err.0, %exit_remove_files ], [ -16, %entry ], [ -12, %if.end ], [ %call29, %for.end ], [ 0, %if.end50 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %val) #6
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_remove(%struct.platform_device* %pdev) #2 {
entry:
  %call = call i8* @platform_get_drvdata(%struct.platform_device* %pdev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %hwmon_dev = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 2
  %1 = load %struct.device*, %struct.device** %hwmon_dev, align 8, !tbaa !59
  call void @hwmon_device_unregister(%struct.device* %1)
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj, %struct.attribute_group* @sis5595_group)
  %dev1 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj2 = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj2, %struct.attribute_group* @sis5595_group_in4)
  %dev3 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj4 = getelementptr inbounds %struct.device, %struct.device* %dev3, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj4, %struct.attribute_group* @sis5595_group_temp1)
  ret i32 0
}

declare %struct.resource* @platform_get_resource(%struct.platform_device*, i32, i32) #1

declare %struct.resource* @__devm_request_region(%struct.device*, %struct.resource*, i64, i64, i8*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @devm_kzalloc(%struct.device* %dev, i64 %size, i32 %gfp) #4 {
entry:
  %or = or i32 %gfp, 32768
  %call = call noalias i8* @devm_kmalloc(%struct.device* %dev, i64 %size, i32 %or)
  ret i8* %call
}

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @platform_set_drvdata(%struct.platform_device* %pdev, i8* %data) #4 {
entry:
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  call void @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sis5595_init_device(%struct.sis5595_data* %data) #2 {
entry:
  %call = call i32 @sis5595_read_value(%struct.sis5595_data* %data, i8 zeroext 64)
  %conv = trunc i32 %call to i8
  %conv1 = zext i8 %conv to i32
  %and = and i32 %conv1, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %conv2 = zext i8 %conv to i32
  %and3 = and i32 %conv2, 247
  %or = or i32 %and3, 1
  %conv4 = trunc i32 %or to i8
  call void @sis5595_write_value(%struct.sis5595_data* %data, i8 zeroext 64, i8 zeroext %conv4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_read_value(%struct.sis5595_data* %data, i8 zeroext %reg) #2 {
entry:
  %lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 3
  call void @mutex_lock_nested(%struct.mutex* %lock, i32 0)
  %addr = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 0
  %0 = load i16, i16* %addr, align 8, !tbaa !53
  %conv = zext i16 %0 to i32
  %add = add nsw i32 %conv, 5
  call void @outb_p(i8 zeroext %reg, i32 %add)
  %addr1 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 0
  %1 = load i16, i16* %addr1, align 8, !tbaa !53
  %conv2 = zext i16 %1 to i32
  %add3 = add nsw i32 %conv2, 6
  %call = call zeroext i8 @inb_p(i32 %add3)
  %conv4 = zext i8 %call to i32
  %lock5 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 3
  call void @mutex_unlock(%struct.mutex* %lock5)
  ret i32 %conv4
}

declare i32 @sysfs_create_group(%struct.kobject*, %struct.attribute_group*) #1

declare %struct.device* @hwmon_device_register(%struct.device*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR(i8* %ptr) #4 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  ret i1 %tobool
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #4 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

declare void @sysfs_remove_group(%struct.kobject*, %struct.attribute_group*) #1

declare noalias i8* @devm_kmalloc(%struct.device*, i64, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @dev_set_drvdata(%struct.device* %dev, i8* %data) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  store i8* %data, i8** %driver_data, align 8, !tbaa !60
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sis5595_write_value(%struct.sis5595_data* %data, i8 zeroext %reg, i8 zeroext %value) #2 {
entry:
  %lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 3
  call void @mutex_lock_nested(%struct.mutex* %lock, i32 0)
  %addr = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 0
  %0 = load i16, i16* %addr, align 8, !tbaa !53
  %conv = zext i16 %0 to i32
  %add = add nsw i32 %conv, 5
  call void @outb_p(i8 zeroext %reg, i32 %add)
  %addr1 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 0
  %1 = load i16, i16* %addr1, align 8, !tbaa !53
  %conv2 = zext i16 %1 to i32
  %add3 = add nsw i32 %conv2, 6
  call void @outb_p(i8 zeroext %value, i32 %add3)
  %lock4 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 3
  call void @mutex_unlock(%struct.mutex* %lock4)
  ret void
}

declare void @mutex_lock_nested(%struct.mutex*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb_p(i8 zeroext %value, i32 %port) #4 {
entry:
  call void @outb(i8 zeroext %value, i32 %port)
  call void @slow_down_io()
  ret void
}

declare void @mutex_unlock(%struct.mutex*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb(i8 zeroext %value, i32 %port) #4 {
entry:
  call void asm sideeffect "outb ${0:b}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i8 %value, i32 %port) #6, !srcloc !61
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @slow_down_io() #4 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.pv_cpu_ops, %struct.pv_cpu_ops* @pv_cpu_ops, i32 0, i32 24), align 8, !tbaa !62
  call void %0()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb_p(i32 %port) #4 {
entry:
  %call = call zeroext i8 @inb(i32 %port)
  call void @slow_down_io()
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb(i32 %port) #4 {
entry:
  %0 = call i8 asm sideeffect "inb ${1:w}, ${0:b}", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #6, !srcloc !64
  ret i8 %0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_in(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #2 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !65
  %in = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 9
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !10
  %conv = zext i8 %3 to i32
  %mul = mul nsw i32 %conv, 16
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i32 %mul)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev) #2 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy1 = alloca i64, align 8
  %__dummy22 = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #6
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #6
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #6
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %5 = bitcast i64* %__dummy1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #6
  %6 = bitcast i64* %__dummy22 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #6
  %cmp3 = icmp eq i64* %__dummy1, %__dummy22
  %conv4 = zext i1 %cmp3 to i32
  %7 = bitcast i64* %__dummy22 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #6
  %8 = bitcast i64* %__dummy1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #6
  %last_updated = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 6
  %9 = load i64, i64* %last_updated, align 8, !tbaa !70
  %add = add i64 %9, 250
  %add8 = add i64 %add, 125
  %10 = load volatile i64, i64* @jiffies, align 8, !tbaa !71
  %sub = sub i64 %add8, %10
  %cmp9 = icmp slt i64 %sub, 0
  br i1 %cmp9, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %valid = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 5
  %11 = load i8, i8* %valid, align 8, !tbaa !72
  %tobool11 = icmp ne i8 %11, 0
  br i1 %tobool11, label %if.end90, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %maxins = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 7
  %12 = load i8, i8* %maxins, align 8, !tbaa !58
  %conv12 = sext i8 %12 to i32
  %cmp13 = icmp sle i32 %i.0, %conv12
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add15 = add nsw i32 32, %i.0
  %conv16 = trunc i32 %add15 to i8
  %call17 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv16)
  %conv18 = trunc i32 %call17 to i8
  %in = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 9
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in, i64 0, i64 %idxprom
  store i8 %conv18, i8* %arrayidx, align 1, !tbaa !10
  %mul = mul nsw i32 %i.0, 2
  %add19 = add nsw i32 44, %mul
  %conv20 = trunc i32 %add19 to i8
  %call21 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv20)
  %conv22 = trunc i32 %call21 to i8
  %in_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 11
  %idxprom23 = sext i32 %i.0 to i64
  %arrayidx24 = getelementptr inbounds [5 x i8], [5 x i8]* %in_min, i64 0, i64 %idxprom23
  store i8 %conv22, i8* %arrayidx24, align 1, !tbaa !10
  %mul25 = mul nsw i32 %i.0, 2
  %add26 = add nsw i32 43, %mul25
  %conv27 = trunc i32 %add26 to i8
  %call28 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv27)
  %conv29 = trunc i32 %call28 to i8
  %in_max = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 10
  %idxprom30 = sext i32 %i.0 to i64
  %arrayidx31 = getelementptr inbounds [5 x i8], [5 x i8]* %in_max, i64 0, i64 %idxprom30
  store i8 %conv29, i8* %arrayidx31, align 1, !tbaa !10
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond32

for.cond32:                                       ; preds = %for.body35, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc49, %for.body35 ]
  %cmp33 = icmp slt i32 %i.1, 2
  br i1 %cmp33, label %for.body35, label %for.end50

for.body35:                                       ; preds = %for.cond32
  %add36 = add nsw i32 40, %i.1
  %conv37 = trunc i32 %add36 to i8
  %call38 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv37)
  %conv39 = trunc i32 %call38 to i8
  %fan = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 12
  %idxprom40 = sext i32 %i.1 to i64
  %arrayidx41 = getelementptr inbounds [2 x i8], [2 x i8]* %fan, i64 0, i64 %idxprom40
  store i8 %conv39, i8* %arrayidx41, align 1, !tbaa !10
  %add42 = add nsw i32 59, %i.1
  %conv43 = trunc i32 %add42 to i8
  %call44 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv43)
  %conv45 = trunc i32 %call44 to i8
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom46 = sext i32 %i.1 to i64
  %arrayidx47 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom46
  store i8 %conv45, i8* %arrayidx47, align 1, !tbaa !10
  %inc49 = add nsw i32 %i.1, 1
  br label %for.cond32

for.end50:                                        ; preds = %for.cond32
  %maxins51 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 7
  %13 = load i8, i8* %maxins51, align 8, !tbaa !58
  %conv52 = sext i8 %13 to i32
  %cmp53 = icmp eq i32 %conv52, 3
  br i1 %cmp53, label %if.then55, label %if.end

if.then55:                                        ; preds = %for.end50
  %revision = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %14 = load i8, i8* %revision, align 1, !tbaa !57
  %conv56 = zext i8 %14 to i32
  %cmp57 = icmp sge i32 %conv56, 176
  %15 = zext i1 %cmp57 to i64
  %cond = select i1 %cmp57, i32 36, i32 39
  %conv59 = trunc i32 %cond to i8
  %call60 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv59)
  %conv61 = trunc i32 %call60 to i8
  %temp = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 14
  store i8 %conv61, i8* %temp, align 1, !tbaa !73
  %revision62 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %16 = load i8, i8* %revision62, align 1, !tbaa !57
  %conv63 = zext i8 %16 to i32
  %cmp64 = icmp sge i32 %conv63, 176
  %17 = zext i1 %cmp64 to i64
  %cond66 = select i1 %cmp64, i32 51, i32 57
  %conv67 = trunc i32 %cond66 to i8
  %call68 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv67)
  %conv69 = trunc i32 %call68 to i8
  %temp_over = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 15
  store i8 %conv69, i8* %temp_over, align 2, !tbaa !74
  %revision70 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %18 = load i8, i8* %revision70, align 1, !tbaa !57
  %conv71 = zext i8 %18 to i32
  %cmp72 = icmp sge i32 %conv71, 176
  %19 = zext i1 %cmp72 to i64
  %cond74 = select i1 %cmp72, i32 52, i32 58
  %conv75 = trunc i32 %cond74 to i8
  %call76 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv75)
  %conv77 = trunc i32 %call76 to i8
  %temp_hyst = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 16
  store i8 %conv77, i8* %temp_hyst, align 1, !tbaa !75
  br label %if.end

if.end:                                           ; preds = %if.then55, %for.end50
  %call78 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext 71)
  %shr = ashr i32 %call78, 4
  %and = and i32 %shr, 3
  %conv79 = trunc i32 %and to i8
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %arrayidx80 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 0
  store i8 %conv79, i8* %arrayidx80, align 8, !tbaa !10
  %shr81 = ashr i32 %call78, 6
  %conv82 = trunc i32 %shr81 to i8
  %fan_div83 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %arrayidx84 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div83, i64 0, i64 1
  store i8 %conv82, i8* %arrayidx84, align 1, !tbaa !10
  %call85 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext 65)
  %call86 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext 66)
  %shl = shl i32 %call86, 8
  %or = or i32 %call85, %shl
  %conv87 = trunc i32 %or to i16
  %alarms = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 18
  store i16 %conv87, i16* %alarms, align 2, !tbaa !76
  %20 = load volatile i64, i64* @jiffies, align 8, !tbaa !71
  %last_updated88 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 6
  store i64 %20, i64* %last_updated88, align 8, !tbaa !70
  %valid89 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 5
  store i8 1, i8* %valid89, align 8, !tbaa !72
  br label %if.end90

if.end90:                                         ; preds = %if.end, %lor.lhs.false
  %update_lock91 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock91)
  ret %struct.sis5595_data* %0
}

declare i32 @sprintf(i8*, i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_get_drvdata(%struct.device* %dev) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !60
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_in_min(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #2 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !65
  %in_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 11
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in_min, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !10
  %conv = zext i8 %3 to i32
  %mul = mul nsw i32 %conv, 16
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i32 %mul)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @set_in_min(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf, i64 %count) #2 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !65
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #6
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %5 = load i64, i64* %val, align 8, !tbaa !71
  %call2 = call zeroext i8 @IN_TO_REG(i64 %5)
  %in_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 11
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in_min, i64 0, i64 %idxprom
  store i8 %call2, i8* %arrayidx, align 1, !tbaa !10
  %mul = mul nsw i32 %3, 2
  %add = add nsw i32 44, %mul
  %conv3 = trunc i32 %add to i8
  %in_min4 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 11
  %idxprom5 = sext i32 %3 to i64
  %arrayidx6 = getelementptr inbounds [5 x i8], [5 x i8]* %in_min4, i64 0, i64 %idxprom5
  %6 = load i8, i8* %arrayidx6, align 1, !tbaa !10
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv3, i8 zeroext %6)
  %update_lock7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock7)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %7 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #6
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul(i8* %s, i32 %base, i64* %res) #4 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @IN_TO_REG(i64 %val) #4 {
entry:
  %__UNIQUE_ID_min1_16 = alloca i64, align 8
  %__UNIQUE_ID_min1_14 = alloca i64, align 8
  %__UNIQUE_ID_min2_15 = alloca i64, align 8
  %__UNIQUE_ID_min2_17 = alloca i64, align 8
  %0 = bitcast i64* %__UNIQUE_ID_min1_16 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
  %1 = bitcast i64* %__UNIQUE_ID_min1_14 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
  store i64 %val, i64* %__UNIQUE_ID_min1_14, align 8, !tbaa !71
  %2 = bitcast i64* %__UNIQUE_ID_min2_15 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #6
  store i64 0, i64* %__UNIQUE_ID_min2_15, align 8, !tbaa !71
  %cmp = icmp eq i64* %__UNIQUE_ID_min1_14, %__UNIQUE_ID_min2_15
  %conv = zext i1 %cmp to i32
  %3 = load i64, i64* %__UNIQUE_ID_min1_14, align 8, !tbaa !71
  %4 = load i64, i64* %__UNIQUE_ID_min2_15, align 8, !tbaa !71
  %cmp1 = icmp ugt i64 %3, %4
  %5 = load i64, i64* %__UNIQUE_ID_min1_14, align 8
  %6 = load i64, i64* %__UNIQUE_ID_min2_15, align 8
  %cond = select i1 %cmp1, i64 %5, i64 %6
  %7 = bitcast i64* %__UNIQUE_ID_min2_15 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #6
  %8 = bitcast i64* %__UNIQUE_ID_min1_14 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #6
  store i64 %cond, i64* %__UNIQUE_ID_min1_16, align 8, !tbaa !71
  %9 = bitcast i64* %__UNIQUE_ID_min2_17 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #6
  store i64 4080, i64* %__UNIQUE_ID_min2_17, align 8, !tbaa !71
  %cmp3 = icmp eq i64* %__UNIQUE_ID_min1_16, %__UNIQUE_ID_min2_17
  %conv4 = zext i1 %cmp3 to i32
  %10 = load i64, i64* %__UNIQUE_ID_min1_16, align 8, !tbaa !71
  %11 = load i64, i64* %__UNIQUE_ID_min2_17, align 8, !tbaa !71
  %cmp6 = icmp ult i64 %10, %11
  %12 = load i64, i64* %__UNIQUE_ID_min1_16, align 8
  %13 = load i64, i64* %__UNIQUE_ID_min2_17, align 8
  %cond11 = select i1 %cmp6, i64 %12, i64 %13
  %14 = bitcast i64* %__UNIQUE_ID_min2_17 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #6
  %15 = bitcast i64* %__UNIQUE_ID_min1_16 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #6
  %add = add i64 %cond11, 8
  %div = udiv i64 %add, 16
  %conv12 = trunc i64 %div to i8
  ret i8 %conv12
}

declare i32 @kstrtoull(i8*, i32, i64*) #1

; Function Attrs: nounwind uwtable
define internal i64 @show_in_max(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #2 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !65
  %in_max = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 10
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in_max, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !10
  %conv = zext i8 %3 to i32
  %mul = mul nsw i32 %conv, 16
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i32 %mul)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @set_in_max(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf, i64 %count) #2 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !65
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #6
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %5 = load i64, i64* %val, align 8, !tbaa !71
  %call2 = call zeroext i8 @IN_TO_REG(i64 %5)
  %in_max = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 10
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in_max, i64 0, i64 %idxprom
  store i8 %call2, i8* %arrayidx, align 1, !tbaa !10
  %mul = mul nsw i32 %3, 2
  %add = add nsw i32 43, %mul
  %conv3 = trunc i32 %add to i8
  %in_max4 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 10
  %idxprom5 = sext i32 %3 to i64
  %arrayidx6 = getelementptr inbounds [5 x i8], [5 x i8]* %in_max4, i64 0, i64 %idxprom5
  %6 = load i8, i8* %arrayidx6, align 1, !tbaa !10
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv3, i8 zeroext %6)
  %update_lock7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock7)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %7 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #6
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_alarm(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #2 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !65
  %alarms = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 18
  %3 = load i16, i16* %alarms, align 2, !tbaa !76
  %conv = zext i16 %3 to i32
  %shr = ashr i32 %conv, %2
  %and = and i32 %shr, 1
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 %and)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #2 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !65
  %fan = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 12
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !10
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 17
  %idxprom1 = sext i32 %2 to i64
  %arrayidx2 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom1
  %4 = load i8, i8* %arrayidx2, align 1, !tbaa !10
  %conv = zext i8 %4 to i32
  %shl = shl i32 1, %conv
  %call3 = call i32 @FAN_FROM_REG(i8 zeroext %3, i32 %shl)
  %call4 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i32 %call3)
  %conv5 = sext i32 %call4 to i64
  ret i64 %conv5
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @FAN_FROM_REG(i8 zeroext %val, i32 %div) #4 {
entry:
  %conv = zext i8 %val to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.end9, label %cond.false

cond.false:                                       ; preds = %entry
  %conv2 = zext i8 %val to i32
  %cmp3 = icmp eq i32 %conv2, 255
  br i1 %cmp3, label %cond.end9, label %cond.false6

cond.false6:                                      ; preds = %cond.false
  %conv7 = zext i8 %val to i32
  %mul = mul nsw i32 %conv7, %div
  %div8 = sdiv i32 1350000, %mul
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false6, %cond.false, %entry
  %cond10 = phi i32 [ -1, %entry ], [ %div8, %cond.false6 ], [ 0, %cond.false ]
  ret i32 %cond10
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_min(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #2 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !65
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !10
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 17
  %idxprom1 = sext i32 %2 to i64
  %arrayidx2 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom1
  %4 = load i8, i8* %arrayidx2, align 1, !tbaa !10
  %conv = zext i8 %4 to i32
  %shl = shl i32 1, %conv
  %call3 = call i32 @FAN_FROM_REG(i8 zeroext %3, i32 %shl)
  %call4 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i32 %call3)
  %conv5 = sext i32 %call4 to i64
  ret i64 %conv5
}

; Function Attrs: nounwind uwtable
define internal i64 @set_fan_min(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf, i64 %count) #2 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !65
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #6
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %5 = load i64, i64* %val, align 8, !tbaa !71
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1, !tbaa !10
  %conv2 = zext i8 %6 to i32
  %shl = shl i32 1, %conv2
  %call3 = call zeroext i8 @FAN_TO_REG(i64 %5, i32 %shl)
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom4 = sext i32 %3 to i64
  %arrayidx5 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom4
  store i8 %call3, i8* %arrayidx5, align 1, !tbaa !10
  %add = add nsw i32 59, %3
  %conv6 = trunc i32 %add to i8
  %fan_min7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom8 = sext i32 %3 to i64
  %arrayidx9 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min7, i64 0, i64 %idxprom8
  %7 = load i8, i8* %arrayidx9, align 1, !tbaa !10
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv6, i8 zeroext %7)
  %update_lock10 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock10)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %8 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #6
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @FAN_TO_REG(i64 %rpm, i32 %div) #4 {
entry:
  %__UNIQUE_ID_min1_20 = alloca i64, align 8
  %__UNIQUE_ID_min1_18 = alloca i64, align 8
  %__UNIQUE_ID_min2_19 = alloca i64, align 8
  %__UNIQUE_ID_min2_21 = alloca i64, align 8
  %cmp = icmp sle i64 %rpm, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp sgt i64 %rpm, 1350000
  br i1 %cmp1, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  %0 = bitcast i64* %__UNIQUE_ID_min1_20 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
  %1 = bitcast i64* %__UNIQUE_ID_min1_18 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
  %conv = sext i32 %div to i64
  %mul = mul nsw i64 %rpm, %conv
  %div4 = sdiv i64 %mul, 2
  %add = add nsw i64 1350000, %div4
  %conv5 = sext i32 %div to i64
  %mul6 = mul nsw i64 %rpm, %conv5
  %div7 = sdiv i64 %add, %mul6
  store i64 %div7, i64* %__UNIQUE_ID_min1_18, align 8, !tbaa !71
  %2 = bitcast i64* %__UNIQUE_ID_min2_19 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #6
  store i64 1, i64* %__UNIQUE_ID_min2_19, align 8, !tbaa !71
  %cmp8 = icmp eq i64* %__UNIQUE_ID_min1_18, %__UNIQUE_ID_min2_19
  %conv9 = zext i1 %cmp8 to i32
  %3 = load i64, i64* %__UNIQUE_ID_min1_18, align 8, !tbaa !71
  %4 = load i64, i64* %__UNIQUE_ID_min2_19, align 8, !tbaa !71
  %cmp10 = icmp sgt i64 %3, %4
  %5 = load i64, i64* %__UNIQUE_ID_min1_18, align 8
  %6 = load i64, i64* %__UNIQUE_ID_min2_19, align 8
  %cond = select i1 %cmp10, i64 %5, i64 %6
  %7 = bitcast i64* %__UNIQUE_ID_min2_19 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #6
  %8 = bitcast i64* %__UNIQUE_ID_min1_18 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #6
  store i64 %cond, i64* %__UNIQUE_ID_min1_20, align 8, !tbaa !71
  %9 = bitcast i64* %__UNIQUE_ID_min2_21 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #6
  store i64 254, i64* %__UNIQUE_ID_min2_21, align 8, !tbaa !71
  %cmp12 = icmp eq i64* %__UNIQUE_ID_min1_20, %__UNIQUE_ID_min2_21
  %conv13 = zext i1 %cmp12 to i32
  %10 = load i64, i64* %__UNIQUE_ID_min1_20, align 8, !tbaa !71
  %11 = load i64, i64* %__UNIQUE_ID_min2_21, align 8, !tbaa !71
  %cmp15 = icmp slt i64 %10, %11
  %12 = load i64, i64* %__UNIQUE_ID_min1_20, align 8
  %13 = load i64, i64* %__UNIQUE_ID_min2_21, align 8
  %cond20 = select i1 %cmp15, i64 %12, i64 %13
  %14 = bitcast i64* %__UNIQUE_ID_min2_21 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #6
  %15 = bitcast i64* %__UNIQUE_ID_min1_20 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #6
  %conv21 = trunc i64 %cond20 to i8
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end3
  %retval.0 = phi i8 [ %conv21, %if.end3 ], [ -1, %entry ], [ 1, %if.end ]
  ret i8 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_div(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #2 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !65
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 17
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !10
  %conv = zext i8 %3 to i32
  %shl = shl i32 1, %conv
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i32 %shl)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @set_fan_div(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf, i64 %count) #2 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !65
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #6
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom
  %5 = load i8, i8* %arrayidx, align 1, !tbaa !10
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom2 = sext i32 %3 to i64
  %arrayidx3 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom2
  %6 = load i8, i8* %arrayidx3, align 1, !tbaa !10
  %conv4 = zext i8 %6 to i32
  %shl = shl i32 1, %conv4
  %call5 = call i32 @FAN_FROM_REG(i8 zeroext %5, i32 %shl)
  %conv6 = sext i32 %call5 to i64
  %call7 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext 71)
  %7 = load i64, i64* %val, align 8, !tbaa !71
  %Pivot10 = icmp slt i64 %7, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %if.end
  %Pivot8 = icmp slt i64 %7, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i64 %7, 8
  br i1 %SwitchLeaf6, label %sw.epilog, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i64 %7, 4
  br i1 %SwitchLeaf4, label %sw.epilog, label %sw.default

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i64 %7, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i64 %7, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i64 %7, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  %8 = load i64, i64* %val, align 8, !tbaa !71
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.34, i32 0, i32 0), i64 %8)
  %update_lock23 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock23)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock5, %LeafBlock3, %LeafBlock1
  %.sink = phi i8 [ 1, %LeafBlock1 ], [ 2, %LeafBlock3 ], [ 3, %LeafBlock5 ], [ 0, %LeafBlock ]
  %fan_div20 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom21 = sext i32 %3 to i64
  %arrayidx22 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div20, i64 0, i64 %idxprom21
  store i8 %.sink, i8* %arrayidx22, align 1, !tbaa !10
  %Pivot17 = icmp slt i32 %3, 1
  br i1 %Pivot17, label %LeafBlock12, label %LeafBlock14

LeafBlock14:                                      ; preds = %sw.epilog
  %SwitchLeaf15 = icmp eq i32 %3, 1
  br i1 %SwitchLeaf15, label %sw.bb30, label %sw.epilog38

LeafBlock12:                                      ; preds = %sw.epilog
  %SwitchLeaf13 = icmp eq i32 %3, 0
  br i1 %SwitchLeaf13, label %sw.bb24, label %sw.epilog38

sw.bb24:                                          ; preds = %LeafBlock12
  %and = and i32 %call7, 207
  %fan_div25 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom26 = sext i32 %3 to i64
  %arrayidx27 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div25, i64 0, i64 %idxprom26
  %9 = load i8, i8* %arrayidx27, align 1, !tbaa !10
  %conv28 = zext i8 %9 to i32
  %shl29 = shl i32 %conv28, 4
  %or = or i32 %and, %shl29
  br label %sw.epilog38

sw.bb30:                                          ; preds = %LeafBlock14
  %and31 = and i32 %call7, 63
  %fan_div32 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom33 = sext i32 %3 to i64
  %arrayidx34 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div32, i64 0, i64 %idxprom33
  %10 = load i8, i8* %arrayidx34, align 1, !tbaa !10
  %conv35 = zext i8 %10 to i32
  %shl36 = shl i32 %conv35, 6
  %or37 = or i32 %and31, %shl36
  br label %sw.epilog38

sw.epilog38:                                      ; preds = %LeafBlock12, %LeafBlock14, %sw.bb30, %sw.bb24
  %reg.0 = phi i32 [ %or, %sw.bb24 ], [ %or37, %sw.bb30 ], [ %call7, %LeafBlock14 ], [ %call7, %LeafBlock12 ]
  %conv39 = trunc i32 %reg.0 to i8
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext 71, i8 zeroext %conv39)
  %fan_div40 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom41 = sext i32 %3 to i64
  %arrayidx42 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div40, i64 0, i64 %idxprom41
  %11 = load i8, i8* %arrayidx42, align 1, !tbaa !10
  %conv43 = zext i8 %11 to i32
  %shl44 = shl i32 1, %conv43
  %call45 = call zeroext i8 @FAN_TO_REG(i64 %conv6, i32 %shl44)
  %fan_min46 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom47 = sext i32 %3 to i64
  %arrayidx48 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min46, i64 0, i64 %idxprom47
  store i8 %call45, i8* %arrayidx48, align 1, !tbaa !10
  %add = add nsw i32 59, %3
  %conv49 = trunc i32 %add to i8
  %fan_min50 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom51 = sext i32 %3 to i64
  %arrayidx52 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min50, i64 0, i64 %idxprom51
  %12 = load i8, i8* %arrayidx52, align 1, !tbaa !10
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv49, i8 zeroext %12)
  %update_lock53 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock53)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog38, %sw.default, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %sw.epilog38 ], [ -22, %sw.default ]
  %13 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %13) #6
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @alarms_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #2 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %alarms = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 18
  %0 = load i16, i16* %alarms, align 2, !tbaa !76
  %conv = zext i16 %0 to i32
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i32 %conv)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @name_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #2 {
entry:
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %name = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 1
  %1 = load i8*, i8** %name, align 8, !tbaa !55
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.42, i32 0, i32 0), i8* %1)
  %conv = sext i32 %call1 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @temp1_input_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #2 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %temp = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 14
  %0 = load i8, i8* %temp, align 1, !tbaa !73
  %call1 = call i32 @TEMP_FROM_REG(i8 signext %0)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @TEMP_FROM_REG(i8 signext %val) #4 {
entry:
  %conv = sext i8 %val to i32
  %mul = mul nsw i32 %conv, 830
  %add = add nsw i32 %mul, 52120
  ret i32 %add
}

; Function Attrs: nounwind uwtable
define internal i64 @temp1_max_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #2 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %temp_over = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 15
  %0 = load i8, i8* %temp_over, align 2, !tbaa !74
  %call1 = call i32 @TEMP_FROM_REG(i8 signext %0)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @temp1_max_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #2 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
  %call1 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %2 = load i64, i64* %val, align 8, !tbaa !71
  %call2 = call signext i8 @TEMP_TO_REG(i64 %2)
  %temp_over = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 15
  store i8 %call2, i8* %temp_over, align 2, !tbaa !74
  %revision = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %3 = load i8, i8* %revision, align 1, !tbaa !57
  %conv3 = zext i8 %3 to i32
  %cmp = icmp sge i32 %conv3, 176
  %4 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 51, i32 57
  %conv5 = trunc i32 %cond to i8
  %temp_over6 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 15
  %5 = load i8, i8* %temp_over6, align 2, !tbaa !74
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv5, i8 zeroext %5)
  %update_lock7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock7)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #6
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtol(i8* %s, i32 %base, i64* %res) #4 {
entry:
  %call = call i32 @kstrtoll(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal signext i8 @TEMP_TO_REG(i64 %val) #4 {
entry:
  %__UNIQUE_ID_min1_24 = alloca i64, align 8
  %__UNIQUE_ID_min1_22 = alloca i64, align 8
  %__UNIQUE_ID_min2_23 = alloca i64, align 8
  %__UNIQUE_ID_min2_25 = alloca i64, align 8
  %0 = bitcast i64* %__UNIQUE_ID_min1_24 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
  %1 = bitcast i64* %__UNIQUE_ID_min1_22 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
  store i64 %val, i64* %__UNIQUE_ID_min1_22, align 8, !tbaa !71
  %2 = bitcast i64* %__UNIQUE_ID_min2_23 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #6
  store i64 -54120, i64* %__UNIQUE_ID_min2_23, align 8, !tbaa !71
  %cmp = icmp eq i64* %__UNIQUE_ID_min1_22, %__UNIQUE_ID_min2_23
  %conv = zext i1 %cmp to i32
  %3 = load i64, i64* %__UNIQUE_ID_min1_22, align 8, !tbaa !71
  %4 = load i64, i64* %__UNIQUE_ID_min2_23, align 8, !tbaa !71
  %cmp1 = icmp sgt i64 %3, %4
  %5 = load i64, i64* %__UNIQUE_ID_min1_22, align 8
  %6 = load i64, i64* %__UNIQUE_ID_min2_23, align 8
  %cond = select i1 %cmp1, i64 %5, i64 %6
  %7 = bitcast i64* %__UNIQUE_ID_min2_23 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #6
  %8 = bitcast i64* %__UNIQUE_ID_min1_22 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #6
  store i64 %cond, i64* %__UNIQUE_ID_min1_24, align 8, !tbaa !71
  %9 = bitcast i64* %__UNIQUE_ID_min2_25 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #6
  store i64 157530, i64* %__UNIQUE_ID_min2_25, align 8, !tbaa !71
  %cmp3 = icmp eq i64* %__UNIQUE_ID_min1_24, %__UNIQUE_ID_min2_25
  %conv4 = zext i1 %cmp3 to i32
  %10 = load i64, i64* %__UNIQUE_ID_min1_24, align 8, !tbaa !71
  %11 = load i64, i64* %__UNIQUE_ID_min2_25, align 8, !tbaa !71
  %cmp6 = icmp slt i64 %10, %11
  %12 = load i64, i64* %__UNIQUE_ID_min1_24, align 8
  %13 = load i64, i64* %__UNIQUE_ID_min2_25, align 8
  %cond11 = select i1 %cmp6, i64 %12, i64 %13
  %14 = bitcast i64* %__UNIQUE_ID_min2_25 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #6
  %15 = bitcast i64* %__UNIQUE_ID_min1_24 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #6
  %conv12 = trunc i64 %cond11 to i32
  %cmp13 = icmp slt i32 %conv12, 0
  %sub = sub nsw i32 %conv12, 5212
  %add = add nsw i32 %sub, 415
  %sub16 = sub nsw i32 %sub, 415
  %add.sink = select i1 %cmp13, i32 %sub16, i32 %add
  %div19 = sdiv i32 %add.sink, 830
  %conv22 = trunc i32 %div19 to i8
  ret i8 %conv22
}

declare i32 @kstrtoll(i8*, i32, i64*) #1

; Function Attrs: nounwind uwtable
define internal i64 @temp1_max_hyst_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #2 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %temp_hyst = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 16
  %0 = load i8, i8* %temp_hyst, align 1, !tbaa !75
  %call1 = call i32 @TEMP_FROM_REG(i8 signext %0)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @temp1_max_hyst_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #2 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
  %call1 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %2 = load i64, i64* %val, align 8, !tbaa !71
  %call2 = call signext i8 @TEMP_TO_REG(i64 %2)
  %temp_hyst = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 16
  store i8 %call2, i8* %temp_hyst, align 1, !tbaa !75
  %revision = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %3 = load i8, i8* %revision, align 1, !tbaa !57
  %conv3 = zext i8 %3 to i32
  %cmp = icmp sge i32 %conv3, 176
  %4 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 52, i32 58
  %conv5 = trunc i32 %cond to i8
  %temp_hyst6 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 16
  %5 = load i8, i8* %temp_hyst6, align 1, !tbaa !75
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv5, i8 zeroext %5)
  %update_lock7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock7)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #6
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @platform_get_drvdata(%struct.platform_device* %pdev) #4 {
entry:
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

declare void @hwmon_device_unregister(%struct.device*) #1

declare i32 @acpi_check_resource_conflict(%struct.resource*) #1

declare %struct.platform_device* @platform_device_alloc(i8*, i32) #1

declare i32 @printk(i8*, ...) #1

declare i32 @platform_device_add_resources(%struct.platform_device*, %struct.resource*, i32) #1

declare i32 @platform_device_add(%struct.platform_device*) #1

declare void @platform_device_put(%struct.platform_device*) #1

declare void @pci_unregister_driver(%struct.pci_driver*) #1

declare void @platform_device_unregister(%struct.platform_device*) #1

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind }
attributes #4 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readnone }
attributes #6 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !3, i64 0}
!3 = !{!"any pointer", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !4, i64 0}
!8 = !{!9, !9, i64 0}
!9 = !{!"short", !4, i64 0}
!10 = !{!4, !4, i64 0}
!11 = !{!12, !3, i64 16}
!12 = !{!"pci_dev", !13, i64 0, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !7, i64 56, !9, i64 60, !9, i64 62, !9, i64 64, !9, i64 66, !7, i64 68, !4, i64 72, !4, i64 73, !9, i64 74, !4, i64 76, !4, i64 77, !4, i64 78, !4, i64 79, !4, i64 80, !4, i64 81, !9, i64 82, !3, i64 88, !3, i64 96, !14, i64 104, !15, i64 112, !7, i64 128, !4, i64 132, !7, i64 133, !7, i64 133, !7, i64 133, !7, i64 133, !7, i64 134, !7, i64 134, !7, i64 134, !7, i64 134, !7, i64 134, !7, i64 134, !7, i64 134, !7, i64 134, !7, i64 135, !7, i64 135, !7, i64 136, !7, i64 140, !3, i64 144, !7, i64 152, !17, i64 160, !7, i64 1584, !7, i64 1588, !4, i64 1592, !34, i64 2680, !7, i64 2681, !7, i64 2681, !7, i64 2681, !7, i64 2681, !7, i64 2681, !7, i64 2681, !7, i64 2681, !7, i64 2681, !7, i64 2682, !7, i64 2682, !7, i64 2682, !7, i64 2682, !7, i64 2682, !7, i64 2682, !7, i64 2682, !7, i64 2683, !7, i64 2683, !7, i64 2683, !7, i64 2683, !7, i64 2683, !7, i64 2683, !7, i64 2683, !7, i64 2683, !7, i64 2684, !7, i64 2684, !7, i64 2684, !7, i64 2684, !9, i64 2686, !21, i64 2688, !4, i64 2692, !39, i64 2760, !3, i64 2768, !7, i64 2776, !4, i64 2784, !4, i64 2920, !7, i64 3056, !7, i64 3056, !4, i64 3057, !3, i64 3064, !3, i64 3072, !4, i64 3080, !9, i64 3088, !4, i64 3090, !21, i64 3092, !14, i64 3096, !16, i64 3104, !3, i64 3112}
!13 = !{!"list_head", !3, i64 0, !3, i64 8}
!14 = !{!"long long", !4, i64 0}
!15 = !{!"device_dma_parameters", !7, i64 0, !16, i64 8}
!16 = !{!"long", !4, i64 0}
!17 = !{!"device", !3, i64 0, !3, i64 8, !18, i64 16, !3, i64 280, !3, i64 288, !28, i64 296, !3, i64 456, !3, i64 464, !3, i64 472, !3, i64 480, !31, i64 488, !32, i64 528, !3, i64 1104, !3, i64 1112, !3, i64 1120, !13, i64 1128, !7, i64 1144, !3, i64 1152, !3, i64 1160, !14, i64 1168, !16, i64 1176, !3, i64 1184, !13, i64 1192, !3, i64 1208, !3, i64 1216, !37, i64 1224, !3, i64 1232, !3, i64 1240, !7, i64 1248, !7, i64 1252, !29, i64 1256, !13, i64 1328, !38, i64 1344, !3, i64 1376, !3, i64 1384, !3, i64 1392, !3, i64 1400, !3, i64 1408, !34, i64 1416, !34, i64 1416}
!18 = !{!"kobject", !3, i64 0, !13, i64 8, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !19, i64 56, !22, i64 64, !7, i64 256, !7, i64 256, !7, i64 256, !7, i64 256, !7, i64 256}
!19 = !{!"kref", !20, i64 0}
!20 = !{!"refcount_struct", !21, i64 0}
!21 = !{!"", !7, i64 0}
!22 = !{!"delayed_work", !23, i64 0, !26, i64 80, !3, i64 176, !7, i64 184}
!23 = !{!"work_struct", !24, i64 0, !13, i64 8, !3, i64 24, !25, i64 32}
!24 = !{!"", !16, i64 0}
!25 = !{!"lockdep_map", !3, i64 0, !4, i64 8, !3, i64 24, !7, i64 32, !16, i64 40}
!26 = !{!"timer_list", !27, i64 0, !16, i64 16, !3, i64 24, !16, i64 32, !7, i64 40, !25, i64 48}
!27 = !{!"hlist_node", !3, i64 0, !3, i64 8}
!28 = !{!"mutex", !24, i64 0, !29, i64 8, !30, i64 80, !13, i64 88, !3, i64 104, !25, i64 112}
!29 = !{!"spinlock", !4, i64 0}
!30 = !{!"optimistic_spin_queue", !21, i64 0}
!31 = !{!"dev_links_info", !13, i64 0, !13, i64 16, !4, i64 32}
!32 = !{!"dev_pm_info", !33, i64 0, !7, i64 4, !7, i64 4, !34, i64 4, !34, i64 4, !34, i64 4, !34, i64 4, !34, i64 4, !34, i64 4, !34, i64 5, !29, i64 8, !13, i64 80, !35, i64 96, !3, i64 192, !34, i64 200, !34, i64 200, !34, i64 200, !26, i64 208, !16, i64 304, !23, i64 312, !36, i64 392, !3, i64 480, !21, i64 488, !21, i64 492, !7, i64 496, !7, i64 496, !7, i64 496, !7, i64 496, !7, i64 496, !7, i64 496, !34, i64 497, !7, i64 497, !7, i64 497, !7, i64 497, !7, i64 497, !7, i64 497, !7, i64 500, !4, i64 504, !4, i64 508, !7, i64 512, !7, i64 516, !16, i64 520, !16, i64 528, !16, i64 536, !16, i64 544, !3, i64 552, !3, i64 560, !3, i64 568}
!33 = !{!"pm_message", !7, i64 0}
!34 = !{!"_Bool", !4, i64 0}
!35 = !{!"completion", !7, i64 0, !36, i64 8}
!36 = !{!"__wait_queue_head", !29, i64 0, !13, i64 72}
!37 = !{!"dev_archdata", !3, i64 0}
!38 = !{!"klist_node", !3, i64 0, !13, i64 8, !19, i64 24}
!39 = !{!"hlist_head", !3, i64 0}
!40 = !{!12, !7, i64 56}
!41 = !{!42, !14, i64 0}
!42 = !{!"resource", !14, i64 0, !14, i64 8, !3, i64 16, !16, i64 24, !16, i64 32, !3, i64 40, !3, i64 48, !3, i64 56}
!43 = !{!42, !14, i64 8}
!44 = !{!42, !3, i64 16}
!45 = !{!42, !16, i64 24}
!46 = !{!42, !16, i64 32}
!47 = !{!42, !3, i64 40}
!48 = !{!42, !3, i64 48}
!49 = !{!42, !3, i64 56}
!50 = !{!51, !3, i64 40}
!51 = !{!"platform_driver", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !52, i64 40, !3, i64 160, !34, i64 168}
!52 = !{!"device_driver", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !34, i64 32, !4, i64 36, !3, i64 40, !3, i64 48, !3, i64 56, !3, i64 64, !3, i64 72, !3, i64 80, !3, i64 88, !3, i64 96, !3, i64 104, !3, i64 112}
!53 = !{!54, !9, i64 0}
!54 = !{!"sis5595_data", !9, i64 0, !3, i64 8, !3, i64 16, !28, i64 24, !28, i64 184, !4, i64 344, !16, i64 352, !4, i64 360, !4, i64 361, !4, i64 362, !4, i64 367, !4, i64 372, !4, i64 377, !4, i64 379, !4, i64 381, !4, i64 382, !4, i64 383, !4, i64 384, !9, i64 386}
!55 = !{!54, !3, i64 8}
!56 = !{!12, !4, i64 72}
!57 = !{!54, !4, i64 361}
!58 = !{!54, !4, i64 360}
!59 = !{!54, !3, i64 16}
!60 = !{!17, !3, i64 480}
!61 = !{i32 -2145149045}
!62 = !{!63, !3, i64 192}
!63 = !{!"pv_cpu_ops", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !3, i64 56, !3, i64 64, !3, i64 72, !3, i64 80, !3, i64 88, !3, i64 96, !3, i64 104, !3, i64 112, !3, i64 120, !3, i64 128, !3, i64 136, !3, i64 144, !3, i64 152, !3, i64 160, !3, i64 168, !3, i64 176, !3, i64 184, !3, i64 192, !3, i64 200, !3, i64 208, !3, i64 216, !3, i64 224, !3, i64 232, !3, i64 240, !3, i64 248, !3, i64 256, !3, i64 264, !3, i64 272, !3, i64 280}
!64 = !{i32 -2145148843}
!65 = !{!66, !7, i64 48}
!66 = !{!"sensor_device_attribute", !67, i64 0, !7, i64 48}
!67 = !{!"device_attribute", !68, i64 0, !3, i64 32, !3, i64 40}
!68 = !{!"attribute", !3, i64 0, !9, i64 8, !34, i64 10, !3, i64 16, !69, i64 24}
!69 = !{!"lock_class_key", !4, i64 0}
!70 = !{!54, !16, i64 352}
!71 = !{!16, !16, i64 0}
!72 = !{!54, !4, i64 344}
!73 = !{!54, !4, i64 381}
!74 = !{!54, !4, i64 382}
!75 = !{!54, !4, i64 383}
!76 = !{!54, !9, i64 386}
